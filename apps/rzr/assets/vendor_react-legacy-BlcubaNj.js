;
(function () {
  System.register(['./vendor_ionic-legacy-DMDRhAuO.js', './vendor_leaflet-legacy-C0625EaZ.js'], function (exports, module) {
    'use strict';

    var getDefaultExportFromCjs, getAugmentedNamespace, leafletSrcExports, t$1;
    return {
      setters: [module => {
        getDefaultExportFromCjs = module.g;
        getAugmentedNamespace = module.a;
      }, module => {
        leafletSrcExports = module.l;
        t$1 = module.t;
      }],
      execute: function () {
        var __vite_style__ = document.createElement('style');
        __vite_style__.textContent = ".rdw-option-wrapper {\n  border: 1px solid #F1F1F1;\n  padding: 5px;\n  min-width: 25px;\n  height: 20px;\n  border-radius: 2px;\n  margin: 0 4px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n  background: white;\n  text-transform: capitalize;\n}\n.rdw-option-wrapper:hover {\n  box-shadow: 1px 1px 0px #BFBDBD;\n}\n.rdw-option-wrapper:active {\n  box-shadow: 1px 1px 0px #BFBDBD inset;\n}\n.rdw-option-active {\n  box-shadow: 1px 1px 0px #BFBDBD inset;\n}\n.rdw-option-disabled {\n  opacity: 0.3;\n  cursor: default;\n}\n\n.rdw-dropdown-wrapper {\n  height: 30px;\n  cursor: pointer;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  margin: 0 3px;\n  text-transform: capitalize;\n  background: white;\n}\n.rdw-dropdown-wrapper:focus {\n  outline: none;\n}\n.rdw-dropdown-wrapper:hover {\n  box-shadow: 1px 1px 0px #BFBDBD;\n  background-color: #FFFFFF;\n}\n.rdw-dropdown-wrapper:active {\n  box-shadow: 1px 1px 0px #BFBDBD inset;\n}\n.rdw-dropdown-carettoopen {\n  height: 0px;\n  width: 0px;\n  position: absolute;\n  top: 35%;\n  right: 10%;\n  border-top: 6px solid black;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n}\n.rdw-dropdown-carettoclose {\n  height: 0px;\n  width: 0px;\n  position: absolute;\n  top: 35%;\n  right: 10%;\n  border-bottom: 6px solid black;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n}\n.rdw-dropdown-selectedtext {\n  display: flex;\n  position: relative;\n  height: 100%;\n  align-items: center;\n  padding: 0 5px;\n}\n.rdw-dropdown-optionwrapper {\n  z-index: 100;\n  position: relative;\n  border: 1px solid #F1F1F1;\n  width: 98%;\n  background: white;\n  border-radius: 2px;\n  margin: 0;\n  padding: 0;\n  max-height: 250px;\n  overflow-y: scroll;\n}\n.rdw-dropdown-optionwrapper:hover {\n  box-shadow: 1px 1px 0px #BFBDBD;\n  background-color: #FFFFFF;\n}\n\n.rdw-dropdownoption-default {\n  min-height: 25px;\n  display: flex;\n  align-items: center;\n  padding: 0 5px;\n}\n.rdw-dropdownoption-highlighted {\n  background: #F1F1F1;\n}\n.rdw-dropdownoption-active {\n  background: #f5f5f5;\n}\n.rdw-dropdownoption-disabled {\n  opacity: 0.3;\n  cursor: default;\n}\n\n.rdw-inline-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  flex-wrap: wrap\n}\n.rdw-inline-dropdown {\n  width: 50px;\n}\n.rdw-inline-dropdownoption {\n  height: 40px;\n  display: flex;\n  justify-content: center;\n}\n\n.rdw-block-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  flex-wrap: wrap\n}\n.rdw-block-dropdown {\n  width: 110px;\n}\n\n.rdw-fontsize-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  flex-wrap: wrap\n}\n.rdw-fontsize-dropdown {\n  min-width: 40px;\n}\n.rdw-fontsize-option {\n  display: flex;\n  justify-content: center;\n}\n\n.rdw-fontfamily-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  flex-wrap: wrap\n}\n.rdw-fontfamily-dropdown {\n  width: 115px;\n}\n.rdw-fontfamily-placeholder {\n  white-space: nowrap;\n  max-width: 90px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.rdw-fontfamily-optionwrapper {\n  width: 140px;\n}\n\n.rdw-list-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  flex-wrap: wrap\n}\n.rdw-list-dropdown {\n  width: 50px;\n  z-index: 90;\n}\n.rdw-list-dropdownOption {\n  height: 40px;\n  display: flex;\n  justify-content: center;\n}\n\n.rdw-text-align-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  flex-wrap: wrap\n}\n.rdw-text-align-dropdown {\n  width: 50px;\n  z-index: 90;\n}\n.rdw-text-align-dropdownOption {\n  height: 40px;\n  display: flex;\n  justify-content: center;\n}\n.rdw-right-aligned-block {\n  text-align: right;\n}\n.rdw-left-aligned-block {\n  text-align: left !important;\n}\n.rdw-center-aligned-block {\n  text-align: center !important;\n}\n.rdw-justify-aligned-block {\n  text-align: justify !important;\n}\n.rdw-right-aligned-block > div {\n  display: inline-block;\n}\n.rdw-left-aligned-block > div {\n  display: inline-block;\n}\n.rdw-center-aligned-block > div {\n  display: inline-block;\n}\n.rdw-justify-aligned-block > div {\n  display: inline-block;\n}\n\n.rdw-colorpicker-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  position: relative;\n  flex-wrap: wrap\n}\n.rdw-colorpicker-modal {\n  position: absolute;\n  top: 35px;\n  left: 5px;\n  display: flex;\n  flex-direction: column;\n  width: 175px;\n  height: 175px;\n  border: 1px solid #F1F1F1;\n  padding: 15px;\n  border-radius: 2px;\n  z-index: 100;\n  background: white;\n  box-shadow: 3px 3px 5px #BFBDBD;\n}\n.rdw-colorpicker-modal-header {\n  display: flex;\n  padding-bottom: 5px;\n}\n.rdw-colorpicker-modal-style-label {\n  font-size: 15px;\n  width: 50%;\n  text-align: center;\n  cursor: pointer;\n  padding: 0 10px 5px;\n}\n.rdw-colorpicker-modal-style-label-active {\n  border-bottom: 2px solid #0a66b7;\n}\n.rdw-colorpicker-modal-options {\n  margin: 5px auto;\n  display: flex;\n  width: 100%;\n  height: 100%;\n  flex-wrap: wrap;\n  overflow: scroll;\n}\n.rdw-colorpicker-cube {\n  width: 22px;\n  height: 22px;\n  border: 1px solid #F1F1F1;\n}\n.rdw-colorpicker-option {\n  margin: 3px;\n  padding: 0;\n  min-height: 20px;\n  border: none;\n  width: 22px;\n  height: 22px;\n  min-width: 22px;\n  box-shadow: 1px 2px 1px #BFBDBD inset;\n}\n.rdw-colorpicker-option:hover {\n  box-shadow: 1px 2px 1px #BFBDBD;\n}\n.rdw-colorpicker-option:active {\n  box-shadow: -1px -2px 1px #BFBDBD;\n}\n.rdw-colorpicker-option-active {\n  box-shadow: 0px 0px 2px 2px #BFBDBD;\n}\n\n.rdw-link-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  position: relative;\n  flex-wrap: wrap\n}\n.rdw-link-dropdown {\n  width: 50px;\n}\n.rdw-link-dropdownOption {\n  height: 40px;\n  display: flex;\n  justify-content: center;\n}\n.rdw-link-dropdownPlaceholder {\n  margin-left: 8px;\n}\n.rdw-link-modal {\n  position: absolute;\n  top: 35px;\n  left: 5px;\n  display: flex;\n  flex-direction: column;\n  width: 235px;\n  height: 205px;\n  border: 1px solid #F1F1F1;\n  padding: 15px;\n  border-radius: 2px;\n  z-index: 100;\n  background: white;\n  box-shadow: 3px 3px 5px #BFBDBD;\n}\n.rdw-link-modal-label {\n  font-size: 15px;\n}\n.rdw-link-modal-input {\n  margin-top: 5px;\n  border-radius: 2px;\n  border: 1px solid #F1F1F1;\n  height: 25px;\n  margin-bottom: 15px;\n  padding: 0 5px;\n}\n.rdw-link-modal-input:focus {\n  outline: none;\n}\n.rdw-link-modal-buttonsection {\n  margin: 0 auto;\n}\n.rdw-link-modal-target-option {\n  margin-bottom: 20px;\n}\n.rdw-link-modal-target-option > span {\n  margin-left: 5px;\n}\n.rdw-link-modal-btn {\n  margin-left: 10px;\n  width: 75px;\n  height: 30px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  cursor: pointer;\n  background: white;\n  text-transform: capitalize;\n}\n.rdw-link-modal-btn:hover {\n  box-shadow: 1px 1px 0px #BFBDBD;\n}\n.rdw-link-modal-btn:active {\n  box-shadow: 1px 1px 0px #BFBDBD inset;\n}\n.rdw-link-modal-btn:focus {\n  outline: none !important;\n}\n.rdw-link-modal-btn:disabled {\n  background: #ece9e9;\n}\n.rdw-link-dropdownoption {\n  height: 40px;\n  display: flex;\n  justify-content: center;\n}\n.rdw-history-dropdown {\n  width: 50px;\n}\n\n.rdw-embedded-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  position: relative;\n  flex-wrap: wrap\n}\n.rdw-embedded-modal {\n  position: absolute;\n  top: 35px;\n  left: 5px;\n  display: flex;\n  flex-direction: column;\n  width: 235px;\n  height: 180px;\n  border: 1px solid #F1F1F1;\n  padding: 15px;\n  border-radius: 2px;\n  z-index: 100;\n  background: white;\n  justify-content: space-between;\n  box-shadow: 3px 3px 5px #BFBDBD;\n}\n.rdw-embedded-modal-header {\n  font-size: 15px;\n  display: flex;\n}\n.rdw-embedded-modal-header-option {\n  width: 50%;\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n}\n.rdw-embedded-modal-header-label {\n  width: 95px;\n  border: 1px solid #f1f1f1;\n  margin-top: 5px;\n  background: #6EB8D4;\n  border-bottom: 2px solid #0a66b7;\n}\n.rdw-embedded-modal-link-section {\n  display: flex;\n  flex-direction: column;\n}\n.rdw-embedded-modal-link-input {\n  width: 88%;\n  height: 35px;\n  margin: 10px 0;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  font-size: 15px;\n  padding: 0 5px;\n}\n.rdw-embedded-modal-link-input-wrapper {\n  display: flex;\n  align-items: center;\n}\n.rdw-embedded-modal-link-input:focus {\n  outline: none;\n}\n.rdw-embedded-modal-btn-section {\n  display: flex;\n  justify-content: center;\n}\n.rdw-embedded-modal-btn {\n  margin: 0 3px;\n  width: 75px;\n  height: 30px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  cursor: pointer;\n  background: white;\n  text-transform: capitalize;\n}\n.rdw-embedded-modal-btn:hover {\n  box-shadow: 1px 1px 0px #BFBDBD;\n}\n.rdw-embedded-modal-btn:active {\n  box-shadow: 1px 1px 0px #BFBDBD inset;\n}\n.rdw-embedded-modal-btn:focus {\n  outline: none !important;\n}\n.rdw-embedded-modal-btn:disabled {\n  background: #ece9e9;\n}\n.rdw-embedded-modal-size {\n  align-items: center;\n  display: flex;\n  margin: 8px 0;\n  justify-content: space-between;\n}\n.rdw-embedded-modal-size-input {\n  width: 80%;\n  height: 20px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  font-size: 12px;\n}\n.rdw-embedded-modal-size-input:focus {\n  outline: none;\n}\n\n.rdw-emoji-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  position: relative;\n  flex-wrap: wrap\n}\n.rdw-emoji-modal {\n  overflow: auto;\n  position: absolute;\n  top: 35px;\n  left: 5px;\n  display: flex;\n  flex-wrap: wrap;\n  width: 235px;\n  height: 180px;\n  border: 1px solid #F1F1F1;\n  padding: 15px;\n  border-radius: 2px;\n  z-index: 100;\n  background: white;\n  box-shadow: 3px 3px 5px #BFBDBD;\n}\n.rdw-emoji-icon {\n  margin: 2.5px;\n  height: 24px;\n  width: 24px;\n  cursor: pointer;\n  font-size: 22px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.rdw-spinner {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  width: 100%;\n}\n.rdw-spinner > div {\n  width: 12px;\n  height: 12px;\n  background-color: #333;\n\n  border-radius: 100%;\n  display: inline-block;\n  animation: sk-bouncedelay 1.4s infinite ease-in-out both;\n}\n.rdw-spinner .rdw-bounce1 {\n  animation-delay: -0.32s;\n}\n.rdw-spinner .rdw-bounce2 {\n  animation-delay: -0.16s;\n}\n@keyframes sk-bouncedelay {\n  0%, 80%, 100% {\n    transform: scale(0);\n  } 40% {\n    transform: scale(1.0);\n  }\n}\n\n.rdw-image-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  position: relative;\n  flex-wrap: wrap\n}\n.rdw-image-modal {\n  position: absolute;\n  top: 35px;\n  left: 5px;\n  display: flex;\n  flex-direction: column;\n  width: 235px;\n  border: 1px solid #F1F1F1;\n  padding: 15px;\n  border-radius: 2px;\n  z-index: 100;\n  background: white;\n  box-shadow: 3px 3px 5px #BFBDBD;\n}\n.rdw-image-modal-header {\n  font-size: 15px;\n  margin: 10px 0;\n  display: flex;\n}\n.rdw-image-modal-header-option {\n  width: 50%;\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n}\n.rdw-image-modal-header-label {\n  width: 80px;\n  background: #f1f1f1;\n  border: 1px solid #f1f1f1;\n  margin-top: 5px;\n}\n.rdw-image-modal-header-label-highlighted {\n  background: #6EB8D4;\n  border-bottom: 2px solid #0a66b7;\n}\n.rdw-image-modal-upload-option {\n  width: 100%;\n  color: gray;\n  cursor: pointer;\n  display: flex;\n  border: none;\n  font-size: 15px;\n  align-items: center;\n  justify-content: center;\n  background-color: #f1f1f1;\n  outline: 2px dashed gray;\n  outline-offset: -10px;\n  margin: 10px 0;\n  padding: 9px 0;\n}\n.rdw-image-modal-upload-option-highlighted {\n  outline: 2px dashed #0a66b7;\n}\n.rdw-image-modal-upload-option-label {\n  cursor: pointer;\n  height: 100%;\n  width: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  padding: 15px;\n}\n.rdw-image-modal-upload-option-label span{\n  padding: 0 20px;\n}\n.rdw-image-modal-upload-option-image-preview {\n  max-width: 100%;\n  max-height: 200px;\n}\n.rdw-image-modal-upload-option-input {\n\twidth: 0.1px;\n\theight: 0.1px;\n\topacity: 0;\n\toverflow: hidden;\n\tposition: absolute;\n\tz-index: -1;\n}\n.rdw-image-modal-url-section {\n  display: flex;\n  align-items: center;\n}\n.rdw-image-modal-url-input {\n  width: 90%;\n  height: 35px;\n  margin: 15px 0 12px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  font-size: 15px;\n  padding: 0 5px;\n}\n.rdw-image-modal-btn-section {\n  margin: 10px auto 0;\n}\n.rdw-image-modal-url-input:focus {\n  outline: none;\n}\n.rdw-image-modal-btn {\n  margin: 0 5px;\n  width: 75px;\n  height: 30px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  cursor: pointer;\n  background: white;\n  text-transform: capitalize;\n}\n.rdw-image-modal-btn:hover {\n  box-shadow: 1px 1px 0px #BFBDBD;\n}\n.rdw-image-modal-btn:active {\n  box-shadow: 1px 1px 0px #BFBDBD inset;\n}\n.rdw-image-modal-btn:focus {\n  outline: none !important;\n}\n.rdw-image-modal-btn:disabled {\n  background: #ece9e9;\n}\n.rdw-image-modal-spinner {\n  position: absolute;\n  top: -3px;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  opacity: 0.5;\n}\n.rdw-image-modal-alt-input {\n  width: 70%;\n  height: 20px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  font-size: 12px;\n  margin-left: 5px;\n}\n.rdw-image-modal-alt-input:focus {\n  outline: none;\n}\n.rdw-image-modal-alt-lbl {\n  font-size: 12px;\n}\n.rdw-image-modal-size {\n  align-items: center;\n  display: flex;\n  margin: 8px 0;\n  justify-content: space-between;\n}\n.rdw-image-modal-size-input {\n  width: 40%;\n  height: 20px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  font-size: 12px;\n}\n.rdw-image-modal-size-input:focus {\n  outline: none;\n}\n.rdw-image-mandatory-sign {\n  color: red;\n  margin-left: 3px;\n  margin-right: 3px;\n}\n\n.rdw-remove-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  position: relative;\n  flex-wrap: wrap\n}\n\n.rdw-history-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  flex-wrap: wrap\n}\n.rdw-history-dropdownoption {\n  height: 40px;\n  display: flex;\n  justify-content: center;\n}\n.rdw-history-dropdown {\n  width: 50px;\n}\n\n.rdw-link-decorator-wrapper {\n  position: relative;\n}\n.rdw-link-decorator-icon {\n  position: absolute;\n  left: 40%;\n  top: 0;\n  cursor: pointer;\n  background-color: white;\n}\n\n.rdw-mention-link {\n  text-decoration: none;\n  color: #1236ff;\n  background-color: #f0fbff;\n  padding: 1px 2px;\n  border-radius: 2px;\n}\n\n.rdw-suggestion-wrapper {\n  position: relative;\n}\n.rdw-suggestion-dropdown {\n  position: absolute;\n  display: flex;\n  flex-direction: column;\n  border: 1px solid #F1F1F1;\n  min-width: 100px;\n  max-height: 150px;\n  overflow: auto;\n  background: white;\n  z-index: 100;\n}\n.rdw-suggestion-option {\n  padding: 7px 5px;\n  border-bottom: 1px solid #f1f1f1;\n}\n.rdw-suggestion-option-active {\n  background-color: #F1F1F1;\n}\n\n.rdw-hashtag-link {\n  text-decoration: none;\n  color: #1236ff;\n  background-color: #f0fbff;\n  padding: 1px 2px;\n  border-radius: 2px;\n}\n\n.rdw-image-alignment-options-popup {\n  position: absolute;\n  background: white;\n  display: flex;\n  padding: 5px 2px;\n  border-radius: 2px;\n  border: 1px solid #F1F1F1;\n  width: 105px;\n  cursor: pointer;\n  z-index: 100;\n}\n.rdw-alignment-option-left {\n  justify-content: flex-start;\n}\n.rdw-image-alignment-option {\n  height: 15px;\n  width: 15px;\n  min-width: 15px;\n}\n.rdw-image-alignment {\n  position: relative;\n}\n.rdw-image-imagewrapper {\n  position: relative;\n}\n.rdw-image-center {\n  display: flex;\n  justify-content: center;\n}\n.rdw-image-left {\n  display: flex;\n}\n.rdw-image-right {\n  display: flex;\n  justify-content: flex-end;\n}\n.rdw-image-alignment-options-popup-right {\n  right: 0;\n}\n\n.rdw-editor-main {\n  height: 100%;\n  overflow: auto;\n  box-sizing: border-box;\n}\n.rdw-editor-toolbar {\n  padding: 6px 5px 0;\n  border-radius: 2px;\n  border: 1px solid #F1F1F1;\n  display: flex;\n  justify-content: flex-start;\n  background: white;\n  flex-wrap: wrap;\n  font-size: 15px;\n  margin-bottom: 5px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.public-DraftStyleDefault-block {\n  margin: 1em 0;\n}\n.rdw-editor-wrapper:focus {\n  outline: none;\n}\n.rdw-editor-wrapper {\n  box-sizing: content-box;\n}\n.rdw-editor-main blockquote {\n  border-left: 5px solid #f1f1f1;\n  padding-left: 5px;\n}\n.rdw-editor-main pre {\n  background: #f1f1f1;\n  border-radius: 3px;\n  padding: 1px 10px;\n}\n/**\n * Draft v0.9.1\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n.DraftEditor-editorContainer,.DraftEditor-root,.public-DraftEditor-content{height:inherit;text-align:initial}.public-DraftEditor-content[contenteditable=true]{-webkit-user-modify:read-write-plaintext-only}.DraftEditor-root{position:relative}.DraftEditor-editorContainer{background-color:rgba(255,255,255,0);border-left:.1px solid transparent;position:relative;z-index:1}.public-DraftEditor-block{position:relative}.DraftEditor-alignLeft .public-DraftStyleDefault-block{text-align:left}.DraftEditor-alignLeft .public-DraftEditorPlaceholder-root{left:0;text-align:left}.DraftEditor-alignCenter .public-DraftStyleDefault-block{text-align:center}.DraftEditor-alignCenter .public-DraftEditorPlaceholder-root{margin:0 auto;text-align:center;width:100%}.DraftEditor-alignRight .public-DraftStyleDefault-block{text-align:right}.DraftEditor-alignRight .public-DraftEditorPlaceholder-root{right:0;text-align:right}.public-DraftEditorPlaceholder-root{color:#9197a3;position:absolute;z-index:0}.public-DraftEditorPlaceholder-hasFocus{color:#bdc1c9}.DraftEditorPlaceholder-hidden{display:none}.public-DraftStyleDefault-block{position:relative;white-space:pre-wrap}.public-DraftStyleDefault-ltr{direction:ltr;text-align:left}.public-DraftStyleDefault-rtl{direction:rtl;text-align:right}.public-DraftStyleDefault-listLTR{direction:ltr}.public-DraftStyleDefault-listRTL{direction:rtl}.public-DraftStyleDefault-ol,.public-DraftStyleDefault-ul{margin:16px 0;padding:0}.public-DraftStyleDefault-depth0.public-DraftStyleDefault-listLTR{margin-left:1.5em}.public-DraftStyleDefault-depth0.public-DraftStyleDefault-listRTL{margin-right:1.5em}.public-DraftStyleDefault-depth1.public-DraftStyleDefault-listLTR{margin-left:3em}.public-DraftStyleDefault-depth1.public-DraftStyleDefault-listRTL{margin-right:3em}.public-DraftStyleDefault-depth2.public-DraftStyleDefault-listLTR{margin-left:4.5em}.public-DraftStyleDefault-depth2.public-DraftStyleDefault-listRTL{margin-right:4.5em}.public-DraftStyleDefault-depth3.public-DraftStyleDefault-listLTR{margin-left:6em}.public-DraftStyleDefault-depth3.public-DraftStyleDefault-listRTL{margin-right:6em}.public-DraftStyleDefault-depth4.public-DraftStyleDefault-listLTR{margin-left:7.5em}.public-DraftStyleDefault-depth4.public-DraftStyleDefault-listRTL{margin-right:7.5em}.public-DraftStyleDefault-unorderedListItem{list-style-type:square;position:relative}.public-DraftStyleDefault-unorderedListItem.public-DraftStyleDefault-depth0{list-style-type:disc}.public-DraftStyleDefault-unorderedListItem.public-DraftStyleDefault-depth1{list-style-type:circle}.public-DraftStyleDefault-orderedListItem{list-style-type:none;position:relative}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-listLTR:before{left:-36px;position:absolute;text-align:right;width:30px}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-listRTL:before{position:absolute;right:-36px;text-align:left;width:30px}.public-DraftStyleDefault-orderedListItem:before{content:counter(ol0) \". \";counter-increment:ol0}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth1:before{content:counter(ol1) \". \";counter-increment:ol1}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth2:before{content:counter(ol2) \". \";counter-increment:ol2}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth3:before{content:counter(ol3) \". \";counter-increment:ol3}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth4:before{content:counter(ol4) \". \";counter-increment:ol4}.public-DraftStyleDefault-depth0.public-DraftStyleDefault-reset{counter-reset:ol0}.public-DraftStyleDefault-depth1.public-DraftStyleDefault-reset{counter-reset:ol1}.public-DraftStyleDefault-depth2.public-DraftStyleDefault-reset{counter-reset:ol2}.public-DraftStyleDefault-depth3.public-DraftStyleDefault-reset{counter-reset:ol3}.public-DraftStyleDefault-depth4.public-DraftStyleDefault-reset{counter-reset:ol4}\n/*# sourceMappingURL=react-draft-wysiwyg.css.map *//**\n * Draft v0.11.7\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n.DraftEditor-editorContainer,.DraftEditor-root,.public-DraftEditor-content{height:inherit;text-align:initial}.public-DraftEditor-content[contenteditable=true]{-webkit-user-modify:read-write-plaintext-only}.DraftEditor-root{position:relative}.DraftEditor-editorContainer{background-color:rgba(255,255,255,0);border-left:.1px solid transparent;position:relative;z-index:1}.public-DraftEditor-block{position:relative}.DraftEditor-alignLeft .public-DraftStyleDefault-block{text-align:left}.DraftEditor-alignLeft .public-DraftEditorPlaceholder-root{left:0;text-align:left}.DraftEditor-alignCenter .public-DraftStyleDefault-block{text-align:center}.DraftEditor-alignCenter .public-DraftEditorPlaceholder-root{margin:0 auto;text-align:center;width:100%}.DraftEditor-alignRight .public-DraftStyleDefault-block{text-align:right}.DraftEditor-alignRight .public-DraftEditorPlaceholder-root{right:0;text-align:right}.public-DraftEditorPlaceholder-root{color:#9197a3;position:absolute;width:100%;z-index:1}.public-DraftEditorPlaceholder-hasFocus{color:#bdc1c9}.DraftEditorPlaceholder-hidden{display:none}.public-DraftStyleDefault-block{position:relative;white-space:pre-wrap}.public-DraftStyleDefault-ltr{direction:ltr;text-align:left}.public-DraftStyleDefault-rtl{direction:rtl;text-align:right}.public-DraftStyleDefault-listLTR{direction:ltr}.public-DraftStyleDefault-listRTL{direction:rtl}.public-DraftStyleDefault-ol,.public-DraftStyleDefault-ul{margin:16px 0;padding:0}.public-DraftStyleDefault-depth0.public-DraftStyleDefault-listLTR{margin-left:1.5em}.public-DraftStyleDefault-depth0.public-DraftStyleDefault-listRTL{margin-right:1.5em}.public-DraftStyleDefault-depth1.public-DraftStyleDefault-listLTR{margin-left:3em}.public-DraftStyleDefault-depth1.public-DraftStyleDefault-listRTL{margin-right:3em}.public-DraftStyleDefault-depth2.public-DraftStyleDefault-listLTR{margin-left:4.5em}.public-DraftStyleDefault-depth2.public-DraftStyleDefault-listRTL{margin-right:4.5em}.public-DraftStyleDefault-depth3.public-DraftStyleDefault-listLTR{margin-left:6em}.public-DraftStyleDefault-depth3.public-DraftStyleDefault-listRTL{margin-right:6em}.public-DraftStyleDefault-depth4.public-DraftStyleDefault-listLTR{margin-left:7.5em}.public-DraftStyleDefault-depth4.public-DraftStyleDefault-listRTL{margin-right:7.5em}.public-DraftStyleDefault-unorderedListItem{list-style-type:square;position:relative}.public-DraftStyleDefault-unorderedListItem.public-DraftStyleDefault-depth0{list-style-type:disc}.public-DraftStyleDefault-unorderedListItem.public-DraftStyleDefault-depth1{list-style-type:circle}.public-DraftStyleDefault-orderedListItem{list-style-type:none;position:relative}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-listLTR:before{left:-36px;position:absolute;text-align:right;width:30px}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-listRTL:before{position:absolute;right:-36px;text-align:left;width:30px}.public-DraftStyleDefault-orderedListItem:before{content:counter(ol0) \". \";counter-increment:ol0}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth1:before{content:counter(ol1,lower-alpha) \". \";counter-increment:ol1}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth2:before{content:counter(ol2,lower-roman) \". \";counter-increment:ol2}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth3:before{content:counter(ol3) \". \";counter-increment:ol3}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth4:before{content:counter(ol4,lower-alpha) \". \";counter-increment:ol4}.public-DraftStyleDefault-depth0.public-DraftStyleDefault-reset{counter-reset:ol0}.public-DraftStyleDefault-depth1.public-DraftStyleDefault-reset{counter-reset:ol1}.public-DraftStyleDefault-depth2.public-DraftStyleDefault-reset{counter-reset:ol2}.public-DraftStyleDefault-depth3.public-DraftStyleDefault-reset{counter-reset:ol3}.public-DraftStyleDefault-depth4.public-DraftStyleDefault-reset{counter-reset:ol4}/*!\n * Cropper.js v1.6.2\n * https://fengyuanchen.github.io/cropperjs\n *\n * Copyright 2015-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2024-04-21T07:43:02.731Z\n */\n\n.cropper-container {\n  direction: ltr;\n  font-size: 0;\n  line-height: 0;\n  position: relative;\n  touch-action: none;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\n.cropper-container img {\n    backface-visibility: hidden;\n    display: block;\n    height: 100%;\n    image-orientation: 0deg;\n    max-height: none !important;\n    max-width: none !important;\n    min-height: 0 !important;\n    min-width: 0 !important;\n    width: 100%;\n  }\n\n.cropper-wrap-box,\n.cropper-canvas,\n.cropper-drag-box,\n.cropper-crop-box,\n.cropper-modal {\n  bottom: 0;\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.cropper-wrap-box,\n.cropper-canvas {\n  overflow: hidden;\n}\n\n.cropper-drag-box {\n  background-color: #fff;\n  opacity: 0;\n}\n\n.cropper-modal {\n  background-color: #000;\n  opacity: 0.5;\n}\n\n.cropper-view-box {\n  display: block;\n  height: 100%;\n  outline: 1px solid #39f;\n  outline-color: rgba(51, 153, 255, 0.75);\n  overflow: hidden;\n  width: 100%;\n}\n\n.cropper-dashed {\n  border: 0 dashed #eee;\n  display: block;\n  opacity: 0.5;\n  position: absolute;\n}\n\n.cropper-dashed.dashed-h {\n    border-bottom-width: 1px;\n    border-top-width: 1px;\n    height: calc(100% / 3);\n    left: 0;\n    top: calc(100% / 3);\n    width: 100%;\n  }\n\n.cropper-dashed.dashed-v {\n    border-left-width: 1px;\n    border-right-width: 1px;\n    height: 100%;\n    left: calc(100% / 3);\n    top: 0;\n    width: calc(100% / 3);\n  }\n\n.cropper-center {\n  display: block;\n  height: 0;\n  left: 50%;\n  opacity: 0.75;\n  position: absolute;\n  top: 50%;\n  width: 0;\n}\n\n.cropper-center::before,\n  .cropper-center::after {\n    background-color: #eee;\n    content: ' ';\n    display: block;\n    position: absolute;\n  }\n\n.cropper-center::before {\n    height: 1px;\n    left: -3px;\n    top: 0;\n    width: 7px;\n  }\n\n.cropper-center::after {\n    height: 7px;\n    left: 0;\n    top: -3px;\n    width: 1px;\n  }\n\n.cropper-face,\n.cropper-line,\n.cropper-point {\n  display: block;\n  height: 100%;\n  opacity: 0.1;\n  position: absolute;\n  width: 100%;\n}\n\n.cropper-face {\n  background-color: #fff;\n  left: 0;\n  top: 0;\n}\n\n.cropper-line {\n  background-color: #39f;\n}\n\n.cropper-line.line-e {\n    cursor: ew-resize;\n    right: -3px;\n    top: 0;\n    width: 5px;\n  }\n\n.cropper-line.line-n {\n    cursor: ns-resize;\n    height: 5px;\n    left: 0;\n    top: -3px;\n  }\n\n.cropper-line.line-w {\n    cursor: ew-resize;\n    left: -3px;\n    top: 0;\n    width: 5px;\n  }\n\n.cropper-line.line-s {\n    bottom: -3px;\n    cursor: ns-resize;\n    height: 5px;\n    left: 0;\n  }\n\n.cropper-point {\n  background-color: #39f;\n  height: 5px;\n  opacity: 0.75;\n  width: 5px;\n}\n\n.cropper-point.point-e {\n    cursor: ew-resize;\n    margin-top: -3px;\n    right: -3px;\n    top: 50%;\n  }\n\n.cropper-point.point-n {\n    cursor: ns-resize;\n    left: 50%;\n    margin-left: -3px;\n    top: -3px;\n  }\n\n.cropper-point.point-w {\n    cursor: ew-resize;\n    left: -3px;\n    margin-top: -3px;\n    top: 50%;\n  }\n\n.cropper-point.point-s {\n    bottom: -3px;\n    cursor: s-resize;\n    left: 50%;\n    margin-left: -3px;\n  }\n\n.cropper-point.point-ne {\n    cursor: nesw-resize;\n    right: -3px;\n    top: -3px;\n  }\n\n.cropper-point.point-nw {\n    cursor: nwse-resize;\n    left: -3px;\n    top: -3px;\n  }\n\n.cropper-point.point-sw {\n    bottom: -3px;\n    cursor: nesw-resize;\n    left: -3px;\n  }\n\n.cropper-point.point-se {\n    bottom: -3px;\n    cursor: nwse-resize;\n    height: 20px;\n    opacity: 1;\n    right: -3px;\n    width: 20px;\n  }\n\n@media (min-width: 768px) {\n\n.cropper-point.point-se {\n      height: 15px;\n      width: 15px;\n  }\n    }\n\n@media (min-width: 992px) {\n\n.cropper-point.point-se {\n      height: 10px;\n      width: 10px;\n  }\n    }\n\n@media (min-width: 1200px) {\n\n.cropper-point.point-se {\n      height: 5px;\n      opacity: 0.75;\n      width: 5px;\n  }\n    }\n\n.cropper-point.point-se::before {\n    background-color: #39f;\n    bottom: -50%;\n    content: ' ';\n    display: block;\n    height: 200%;\n    opacity: 0;\n    position: absolute;\n    right: -50%;\n    width: 200%;\n  }\n\n.cropper-invisible {\n  opacity: 0;\n}\n\n.cropper-bg {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC');\n}\n\n.cropper-hide {\n  display: block;\n  height: 0;\n  position: absolute;\n  width: 0;\n}\n\n.cropper-hidden {\n  display: none !important;\n}\n\n.cropper-move {\n  cursor: move;\n}\n\n.cropper-crop {\n  cursor: crosshair;\n}\n\n.cropper-disabled .cropper-drag-box,\n.cropper-disabled .cropper-face,\n.cropper-disabled .cropper-line,\n.cropper-disabled .cropper-point {\n  cursor: not-allowed;\n}\n/* global styling */\n.leaflet-control-geosearch *,\n.leaflet-control-geosearch *:before,\n.leaflet-control-geosearch *:after {\n  box-sizing: border-box;\n}\n\n/* leaflet button styling */\n.leaflet-control-geosearch .leaflet-bar-part {\n  border-radius: 4px;\n  border-bottom: none;\n}\n\n.leaflet-control-geosearch a.leaflet-bar-part:before,\n.leaflet-control-geosearch a.leaflet-bar-part:after {\n  position: absolute;\n  display: block;\n  content: '';\n}\n\n/* magnifying glass */\n.leaflet-control-geosearch a.leaflet-bar-part:before {\n  top: 17px;\n  left: 15px;\n  width: 6px;\n  border-top: 2px solid #555;\n  transform: rotateZ(45deg);\n}\n\n.leaflet-control-geosearch a.leaflet-bar-part:after {\n  top: 10px;\n  left: 10px;\n  height: 8px;\n  width: 8px;\n  border-radius: 50%;\n  border: 2px solid #555;\n}\n\n/* resets for pending and error icons */\n.leaflet-control-geosearch.error a.leaflet-bar-part:before,\n.leaflet-control-geosearch.pending a.leaflet-bar-part:before {\n  display: none;\n}\n\n.leaflet-control-geosearch.pending a.leaflet-bar-part:after,\n.leaflet-control-geosearch.error a.leaflet-bar-part:after {\n  left: 50%;\n  top: 50%;\n  width: 18px;\n  height: 18px;\n  margin: -9px 0 0 -9px;\n  border-radius: 50%;\n}\n\n/* pending icon */\n.leaflet-control-geosearch.pending a.leaflet-bar-part:after {\n  content: '';\n  border: 2px solid #555;\n  border-top: 2px solid #f3f3f3;\n  animation: spin 1s linear infinite;\n}\n\n/* error icon */\n.leaflet-control-geosearch.error a.leaflet-bar-part:after {\n  content: '!';\n  line-height: initial;\n  font-weight: 600;\n  font-size: 18px;\n  border: none;\n}\n\n/* search form styling */\n.leaflet-control-geosearch form {\n  display: none;\n  position: absolute;\n  top: 0;\n  left: 30px;\n  border-radius: 0 4px 4px 0;\n  background-color: #fff;\n  background-clip: padding-box;\n  z-index: -1;\n  height: auto;\n  margin: 0;\n  padding: 0 8px;\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);\n}\n\n.leaflet-geosearch-button form.open {\n  border-radius: 0 4px 4px 4px;\n}\n.leaflet-control-geosearch.active form {\n  display: block;\n}\n\n.leaflet-geosearch-button.active .leaflet-bar-part {\n  border-radius: 4px 0 0 4px;\n  width: 30px;\n}\n\n.leaflet-geosearch-button form {\n  max-width: 350px;\n}\n\n.leaflet-control-geosearch form input {\n  min-width: 200px;\n  width: 100%;\n  outline: none;\n  margin: 0;\n  padding: 0;\n  font-size: 12px;\n  height: 30px;\n  border: none;\n  border-radius: 0 4px 4px 0;\n  text-indent: 8px;\n}\n\n.leaflet-touch .leaflet-geosearch-bar form {\n  border: 2px solid rgba(0,0,0,0.2);\n  box-shadow: none;\n}\n\n.leaflet-touch .leaflet-geosearch-bar form input {\n  height: 30px;\n}\n\n.leaflet-control-geosearch .results {\n  background: #fff;\n}\n\n.leaflet-control-geosearch .results > * {\n  line-height: 24px;\n  padding: 0 8px;\n  border: 1px solid transparent;\n\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.leaflet-control-geosearch .results.active {\n  padding: 8px 0;\n  border-top: 1px solid #c6c6c6;\n}\n\n.leaflet-control-geosearch .results > .active,\n.leaflet-control-geosearch .results > :hover {\n  background-color: #f8f8f8;\n  border-color: #c6c6c6;\n  cursor: pointer;\n}\n\n/* add missing border to form */\n.leaflet-control-geosearch .results.active:after {\n  content: '';\n  display: block;\n  width: 0;\n  position: absolute;\n  left: -2px;\n  bottom: -2px;\n  top: 30px;\n}\n\n.leaflet-touch .leaflet-control-geosearch .results.active:after {\n  border-left: 2px solid rgba(0, 0, 0, .2);\n}\n\n/* animations */\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n\n.leaflet-top .leaflet-geosearch-bar,\n.leaflet-bottom .leaflet-geosearch-bar {\n  display: none;\n}\n\n.leaflet-geosearch-bar {\n  position: relative;\n  display: block;\n  height: auto;\n  width: 400px;\n  max-width: calc(100% - 120px);\n  margin: 10px auto 0;\n  cursor: auto;\n  z-index: 1000;\n}\n\n.leaflet-geosearch-bar form {\n  position: relative;\n  top: 0;\n  left: 0;\n  display: block;\n  border-radius: 4px;\n}\n\n.leaflet-geosearch-bar form input {\n  min-width: 100%;\n  width: 100%;\n}\n\n.leaflet-geosearch-bar .results.active:after {\n  opacity: .2;\n}\n\n.leaflet-right .leaflet-control-geosearch form {\n  right: 28px;\n  left: initial;\n  border-radius: 4px 0 0 4px;\n  border-left: inherit;\n  border-right: none;\n}\n\n.leaflet-bar-notfound {\n  font-style: italic;\n}\n\n.leaflet-control-geosearch button.reset {\n  color: black;\n  font-weight: bold;\n  position: absolute;\n  line-height: 26px;\n  padding: 0 8px;\n  right: 0;\n  top: 0;\n  cursor: pointer;\n  border: none;\n  text-decoration: none;\n  background-color: #fff;\n  border-radius: 0 4px 4px 0;\n}\n\n.leaflet-touch .leaflet-control-geosearch button.reset {\n  line-height: 30px;\n}\n\n.leaflet-control-geosearch button.reset:hover {\n  background: #f5f5f5;\n}\n/**\n * Swiper 12.0.2\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2025 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: September 18, 2025\n */\n\n:root {\n  --swiper-theme-color: #007aff;\n  /*\n  --swiper-preloader-color: var(--swiper-theme-color);\n  --swiper-wrapper-transition-timing-function: initial;\n  */\n}\n:host {\n  position: relative;\n  display: block;\n  margin-left: auto;\n  margin-right: auto;\n  z-index: 1;\n}\n.swiper {\n  margin-left: auto;\n  margin-right: auto;\n  position: relative;\n  overflow: hidden;\n  list-style: none;\n  padding: 0;\n  /* Fix of Webkit flickering */\n  z-index: 1;\n  display: block;\n}\n.swiper-vertical > .swiper-wrapper {\n  flex-direction: column;\n}\n.swiper-wrapper {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n  display: flex;\n  transition-property: transform;\n  transition-timing-function: var(--swiper-wrapper-transition-timing-function, initial);\n  box-sizing: content-box;\n}\n.swiper-android .swiper-slide,\n.swiper-ios .swiper-slide,\n.swiper-wrapper {\n  transform: translate3d(0px, 0, 0);\n}\n.swiper-horizontal {\n  touch-action: pan-y;\n}\n.swiper-vertical {\n  touch-action: pan-x;\n}\n.swiper-slide {\n  flex-shrink: 0;\n  width: 100%;\n  height: 100%;\n  position: relative;\n  transition-property: transform;\n  display: block;\n}\n.swiper-slide-invisible-blank {\n  visibility: hidden;\n}\n/* Auto Height */\n.swiper-autoheight,\n.swiper-autoheight .swiper-slide {\n  height: auto;\n}\n.swiper-autoheight .swiper-wrapper {\n  align-items: flex-start;\n  transition-property: transform, height;\n}\n.swiper-backface-hidden .swiper-slide {\n  transform: translateZ(0);\n  backface-visibility: hidden;\n}\n/* 3D Effects */\n.swiper-3d.swiper-css-mode .swiper-wrapper {\n  perspective: 1200px;\n}\n.swiper-3d .swiper-wrapper {\n  transform-style: preserve-3d;\n}\n.swiper-3d {\n  perspective: 1200px;\n  .swiper-slide,\n  .swiper-cube-shadow {\n    transform-style: preserve-3d;\n  }\n}\n\n/* CSS Mode */\n.swiper-css-mode {\n  > .swiper-wrapper {\n    overflow: auto;\n    scrollbar-width: none; /* For Firefox */\n    -ms-overflow-style: none; /* For Internet Explorer and Edge */\n    &::-webkit-scrollbar {\n      display: none;\n    }\n  }\n  > .swiper-wrapper > .swiper-slide {\n    scroll-snap-align: start start;\n  }\n  &.swiper-horizontal {\n    > .swiper-wrapper {\n      scroll-snap-type: x mandatory;\n    }\n  }\n  &.swiper-vertical {\n    > .swiper-wrapper {\n      scroll-snap-type: y mandatory;\n    }\n  }\n  &.swiper-free-mode {\n    > .swiper-wrapper {\n      scroll-snap-type: none;\n    }\n    > .swiper-wrapper > .swiper-slide {\n      scroll-snap-align: none;\n    }\n  }\n  &.swiper-centered {\n    > .swiper-wrapper::before {\n      content: '';\n      flex-shrink: 0;\n      order: 9999;\n    }\n    > .swiper-wrapper > .swiper-slide {\n      scroll-snap-align: center center;\n      scroll-snap-stop: always;\n    }\n  }\n  &.swiper-centered.swiper-horizontal {\n    > .swiper-wrapper > .swiper-slide:first-child {\n      margin-inline-start: var(--swiper-centered-offset-before);\n    }\n    > .swiper-wrapper::before {\n      height: 100%;\n      min-height: 1px;\n      width: var(--swiper-centered-offset-after);\n    }\n  }\n  &.swiper-centered.swiper-vertical {\n    > .swiper-wrapper > .swiper-slide:first-child {\n      margin-block-start: var(--swiper-centered-offset-before);\n    }\n    > .swiper-wrapper::before {\n      width: 100%;\n      min-width: 1px;\n      height: var(--swiper-centered-offset-after);\n    }\n  }\n}\n\n/* Slide styles start */\n/* 3D Shadows */\n.swiper-3d {\n  .swiper-slide-shadow,\n  .swiper-slide-shadow-left,\n  .swiper-slide-shadow-right,\n  .swiper-slide-shadow-top,\n  .swiper-slide-shadow-bottom,\n  .swiper-slide-shadow,\n  .swiper-slide-shadow-left,\n  .swiper-slide-shadow-right,\n  .swiper-slide-shadow-top,\n  .swiper-slide-shadow-bottom {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    z-index: 10;\n  }\n  .swiper-slide-shadow {\n    background: rgba(0, 0, 0, 0.15);\n  }\n  .swiper-slide-shadow-left {\n    background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  }\n  .swiper-slide-shadow-right {\n    background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  }\n  .swiper-slide-shadow-top {\n    background-image: linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  }\n  .swiper-slide-shadow-bottom {\n    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  }\n}\n.swiper-lazy-preloader {\n  width: 42px;\n  height: 42px;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  margin-left: -21px;\n  margin-top: -21px;\n  z-index: 10;\n  transform-origin: 50%;\n  box-sizing: border-box;\n  border: 4px solid var(--swiper-preloader-color, var(--swiper-theme-color));\n  border-radius: 50%;\n  border-top-color: transparent;\n}\n.swiper:not(.swiper-watch-progress),\n.swiper-watch-progress .swiper-slide-visible {\n  .swiper-lazy-preloader {\n    animation: swiper-preloader-spin 1s infinite linear;\n  }\n}\n.swiper-lazy-preloader-white {\n  --swiper-preloader-color: #fff;\n}\n.swiper-lazy-preloader-black {\n  --swiper-preloader-color: #000;\n}\n@keyframes swiper-preloader-spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n/* Slide styles end */\n:root {\n  --swiper-navigation-size: 44px;\n  /*\n  --swiper-navigation-top-offset: 50%;\n  --swiper-navigation-sides-offset: 4px;\n  --swiper-navigation-color: var(--swiper-theme-color);\n  */\n}\n.swiper-button-prev,\n.swiper-button-next {\n  position: absolute;\n\n  width: var(--swiper-navigation-size);\n  height: var(--swiper-navigation-size);\n\n  z-index: 10;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: var(--swiper-navigation-color, var(--swiper-theme-color));\n  &.swiper-button-disabled {\n    opacity: 0.35;\n    cursor: auto;\n    pointer-events: none;\n  }\n  &.swiper-button-hidden {\n    opacity: 0;\n    cursor: auto;\n    pointer-events: none;\n  }\n  .swiper-navigation-disabled & {\n    display: none !important;\n  }\n  svg {\n    width: 100%;\n    height: 100%;\n    -o-object-fit: contain;\n       object-fit: contain;\n    transform-origin: center;\n    fill: currentColor;\n    pointer-events: none;\n  }\n}\n\n.swiper-button-lock {\n  display: none;\n}\n\n.swiper-button-prev,\n.swiper-button-next {\n  top: var(--swiper-navigation-top-offset, 50%);\n  margin-top: calc(0px - (var(--swiper-navigation-size) / 2));\n}\n.swiper-button-prev {\n  left: var(--swiper-navigation-sides-offset, 4px);\n  right: auto;\n  .swiper-navigation-icon {\n    transform: rotate(180deg);\n  }\n}\n.swiper-button-next {\n  right: var(--swiper-navigation-sides-offset, 4px);\n  left: auto;\n}\n.swiper-horizontal {\n  .swiper-button-prev,\n  .swiper-button-next,\n  ~ .swiper-button-prev,\n  ~ .swiper-button-next {\n    top: var(--swiper-navigation-top-offset, 50%);\n    margin-top: calc(0px - (var(--swiper-navigation-size) / 2));\n    margin-left: 0;\n  }\n  .swiper-button-prev,\n  & ~ .swiper-button-prev,\n  &.swiper-rtl .swiper-button-next,\n  &.swiper-rtl ~ .swiper-button-next {\n    left: var(--swiper-navigation-sides-offset, 4px);\n    right: auto;\n  }\n  .swiper-button-next,\n  & ~ .swiper-button-next,\n  &.swiper-rtl .swiper-button-prev,\n  &.swiper-rtl ~ .swiper-button-prev {\n    right: var(--swiper-navigation-sides-offset, 4px);\n    left: auto;\n  }\n  .swiper-button-prev,\n  & ~ .swiper-button-prev,\n  &.swiper-rtl .swiper-button-next,\n  &.swiper-rtl ~ .swiper-button-next {\n    .swiper-navigation-icon {\n      transform: rotate(180deg);\n    }\n  }\n  &.swiper-rtl .swiper-button-prev,\n  &.swiper-rtl ~ .swiper-button-prev {\n    .swiper-navigation-icon {\n      transform: rotate(0deg);\n    }\n  }\n}\n.swiper-vertical {\n  .swiper-button-prev,\n  .swiper-button-next,\n  ~ .swiper-button-prev,\n  ~ .swiper-button-next {\n    left: var(--swiper-navigation-top-offset, 50%);\n    right: auto;\n    margin-left: calc(0px - (var(--swiper-navigation-size) / 2));\n    margin-top: 0;\n  }\n  .swiper-button-prev,\n  ~ .swiper-button-prev {\n    top: var(--swiper-navigation-sides-offset, 4px);\n    bottom: auto;\n    .swiper-navigation-icon {\n      transform: rotate(-90deg);\n    }\n  }\n  .swiper-button-next,\n  ~ .swiper-button-next {\n    bottom: var(--swiper-navigation-sides-offset, 4px);\n    top: auto;\n    .swiper-navigation-icon {\n      transform: rotate(90deg);\n    }\n  }\n}\n.swiper.swiper-cube {\n  overflow: visible;\n}\n.swiper-cube {\n  .swiper-slide {\n    pointer-events: none;\n    backface-visibility: hidden;\n    z-index: 1;\n    visibility: hidden;\n    transform-origin: 0 0;\n    width: 100%;\n    height: 100%;\n    .swiper-slide {\n      pointer-events: none;\n    }\n  }\n  &.swiper-rtl .swiper-slide {\n    transform-origin: 100% 0;\n  }\n  .swiper-slide-active {\n    &,\n    & .swiper-slide-active {\n      pointer-events: auto;\n    }\n  }\n  .swiper-slide-active,\n  .swiper-slide-next,\n  .swiper-slide-prev {\n    pointer-events: auto;\n    visibility: visible;\n  }\n\n  .swiper-cube-shadow {\n    position: absolute;\n    left: 0;\n    bottom: 0px;\n    width: 100%;\n    height: 100%;\n    opacity: 0.6;\n    z-index: 0;\n\n    &:before {\n      content: '';\n      background: #000;\n      position: absolute;\n      left: 0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      filter: blur(50px);\n    }\n  }\n  .swiper-slide-next + .swiper-slide {\n    pointer-events: auto;\n    visibility: visible;\n  }\n}\n/* Cube slide shadows start */\n.swiper-cube {\n  .swiper-slide-shadow-cube.swiper-slide-shadow-top,\n  .swiper-slide-shadow-cube.swiper-slide-shadow-bottom,\n  .swiper-slide-shadow-cube.swiper-slide-shadow-left,\n  .swiper-slide-shadow-cube.swiper-slide-shadow-right {\n    z-index: 0;\n    backface-visibility: hidden;\n  }\n}\n/* Cube slide shadows end */\n/*$vite$:1*/";
        document.head.appendChild(__vite_style__);
        function _mergeNamespaces(n, m) {
          for (var i = 0; i < m.length; i++) {
            const e = m[i];
            if (typeof e !== 'string' && !Array.isArray(e)) {
              for (const k in e) {
                if (k !== 'default' && !(k in n)) {
                  const d = Object.getOwnPropertyDescriptor(e, k);
                  if (d) {
                    Object.defineProperty(n, k, d.get ? d : {
                      enumerable: true,
                      get: () => e[k]
                    });
                  }
                }
              }
            }
          }
          return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, {
            value: 'Module'
          }));
        }
        exports({
          $: o$1,
          A: fetchBaseQuery,
          F: createAction,
          I: isRejectedWithValue,
          J: combineReducers,
          K: configureStore,
          L: persistStore,
          M: persistReducer,
          W: Provider,
          Z: useForm,
          _: __rest,
          a1: create$3,
          a2: create$6,
          a5: setLocale,
          a6: useWatch,
          aA: endOfMonth,
          aB: eachDayOfInterval,
          aC: subMonths,
          aD: addMonths,
          aE: parse,
          aF: addMinutes,
          aG: isWithinInterval,
          aH: differenceInMinutes,
          aI: Redirect,
          aJ: useLocation,
          aK: isPast,
          aL: create$7,
          aM: create$5,
          aN: useParams,
          aO: create$2,
          aQ: w,
          aR: useMap,
          ad: c$1,
          ag: V,
          ah: arrayMove,
          ai: parseISO,
          aj: formatInTimeZone,
          ak: toZonedTime,
          al: format$1,
          am: isValid,
          ap: useTranslation,
          aq: useHistory,
          ar: useGoogleLogin,
          as: GoogleOAuthProvider,
          aw: differenceInCalendarMonths,
          ax: getMonth,
          ay: startOfMonth,
          az: addDays,
          d: deleteDB,
          l: createBrowserHistory,
          n: withRouter,
          o: openDB,
          t: createHashHistory,
          u: matchPath
        });
        var jsxRuntime = {
          exports: {}
        };
        var reactJsxRuntime_production_min = {};
        var react = {
          exports: {}
        };
        var react_production_min = {};
        var hasRequiredReact_production_min;
        function requireReact_production_min() {
          if (hasRequiredReact_production_min) return react_production_min;
          hasRequiredReact_production_min = 1;
          /**
           * @license React
           * react.production.min.js
           *
           * Copyright (c) Facebook, Inc. and its affiliates.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           */
          var l = Symbol.for("react.element"),
            n = Symbol.for("react.portal"),
            p = Symbol.for("react.fragment"),
            q = Symbol.for("react.strict_mode"),
            r = Symbol.for("react.profiler"),
            t = Symbol.for("react.provider"),
            u = Symbol.for("react.context"),
            v = Symbol.for("react.forward_ref"),
            w = Symbol.for("react.suspense"),
            x = Symbol.for("react.memo"),
            y = Symbol.for("react.lazy"),
            z = Symbol.iterator;
          function A(a) {
            if (null === a || "object" !== typeof a) return null;
            a = z && a[z] || a["@@iterator"];
            return "function" === typeof a ? a : null;
          }
          var B = {
              isMounted: function () {
                return false;
              },
              enqueueForceUpdate: function () {},
              enqueueReplaceState: function () {},
              enqueueSetState: function () {}
            },
            C = Object.assign,
            D = {};
          function E(a, b, e) {
            this.props = a;
            this.context = b;
            this.refs = D;
            this.updater = e || B;
          }
          E.prototype.isReactComponent = {};
          E.prototype.setState = function (a, b) {
            if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            this.updater.enqueueSetState(this, a, b, "setState");
          };
          E.prototype.forceUpdate = function (a) {
            this.updater.enqueueForceUpdate(this, a, "forceUpdate");
          };
          function F() {}
          F.prototype = E.prototype;
          function G(a, b, e) {
            this.props = a;
            this.context = b;
            this.refs = D;
            this.updater = e || B;
          }
          var H = G.prototype = new F();
          H.constructor = G;
          C(H, E.prototype);
          H.isPureReactComponent = true;
          var I = Array.isArray,
            J = Object.prototype.hasOwnProperty,
            K = {
              current: null
            },
            L = {
              key: true,
              ref: true,
              __self: true,
              __source: true
            };
          function M(a, b, e) {
            var d,
              c = {},
              k = null,
              h = null;
            if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
            var g = arguments.length - 2;
            if (1 === g) c.children = e;else if (1 < g) {
              for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
              c.children = f;
            }
            if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
            return {
              $$typeof: l,
              type: a,
              key: k,
              ref: h,
              props: c,
              _owner: K.current
            };
          }
          function N(a, b) {
            return {
              $$typeof: l,
              type: a.type,
              key: b,
              ref: a.ref,
              props: a.props,
              _owner: a._owner
            };
          }
          function O(a) {
            return "object" === typeof a && null !== a && a.$$typeof === l;
          }
          function escape(a) {
            var b = {
              "=": "=0",
              ":": "=2"
            };
            return "$" + a.replace(/[=:]/g, function (a2) {
              return b[a2];
            });
          }
          var P = /\/+/g;
          function Q(a, b) {
            return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
          }
          function R(a, b, e, d, c) {
            var k = typeof a;
            if ("undefined" === k || "boolean" === k) a = null;
            var h = false;
            if (null === a) h = true;else switch (k) {
              case "string":
              case "number":
                h = true;
                break;
              case "object":
                switch (a.$$typeof) {
                  case l:
                  case n:
                    h = true;
                }
            }
            if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function (a2) {
              return a2;
            })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
            h = 0;
            d = "" === d ? "." : d + ":";
            if (I(a)) for (var g = 0; g < a.length; g++) {
              k = a[g];
              var f = d + Q(k, g);
              h += R(k, b, e, f, c);
            } else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
            return h;
          }
          function S(a, b, e) {
            if (null == a) return a;
            var d = [],
              c = 0;
            R(a, d, "", "", function (a2) {
              return b.call(e, a2, c++);
            });
            return d;
          }
          function T(a) {
            if (-1 === a._status) {
              var b = a._result;
              b = b();
              b.then(function (b2) {
                if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
              }, function (b2) {
                if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
              });
              -1 === a._status && (a._status = 0, a._result = b);
            }
            if (1 === a._status) return a._result.default;
            throw a._result;
          }
          var U = {
              current: null
            },
            V = {
              transition: null
            },
            W = {
              ReactCurrentDispatcher: U,
              ReactCurrentBatchConfig: V,
              ReactCurrentOwner: K
            };
          react_production_min.Children = {
            map: S,
            forEach: function (a, b, e) {
              S(a, function () {
                b.apply(this, arguments);
              }, e);
            },
            count: function (a) {
              var b = 0;
              S(a, function () {
                b++;
              });
              return b;
            },
            toArray: function (a) {
              return S(a, function (a2) {
                return a2;
              }) || [];
            },
            only: function (a) {
              if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
              return a;
            }
          };
          react_production_min.Component = E;
          react_production_min.Fragment = p;
          react_production_min.Profiler = r;
          react_production_min.PureComponent = G;
          react_production_min.StrictMode = q;
          react_production_min.Suspense = w;
          react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
          react_production_min.cloneElement = function (a, b, e) {
            if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
            var d = C({}, a.props),
              c = a.key,
              k = a.ref,
              h = a._owner;
            if (null != b) {
              void 0 !== b.ref && (k = b.ref, h = K.current);
              void 0 !== b.key && (c = "" + b.key);
              if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
              for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
            }
            var f = arguments.length - 2;
            if (1 === f) d.children = e;else if (1 < f) {
              g = Array(f);
              for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
              d.children = g;
            }
            return {
              $$typeof: l,
              type: a.type,
              key: c,
              ref: k,
              props: d,
              _owner: h
            };
          };
          react_production_min.createContext = function (a) {
            a = {
              $$typeof: u,
              _currentValue: a,
              _currentValue2: a,
              _threadCount: 0,
              Provider: null,
              Consumer: null,
              _defaultValue: null,
              _globalName: null
            };
            a.Provider = {
              $$typeof: t,
              _context: a
            };
            return a.Consumer = a;
          };
          react_production_min.createElement = M;
          react_production_min.createFactory = function (a) {
            var b = M.bind(null, a);
            b.type = a;
            return b;
          };
          react_production_min.createRef = function () {
            return {
              current: null
            };
          };
          react_production_min.forwardRef = function (a) {
            return {
              $$typeof: v,
              render: a
            };
          };
          react_production_min.isValidElement = O;
          react_production_min.lazy = function (a) {
            return {
              $$typeof: y,
              _payload: {
                _status: -1,
                _result: a
              },
              _init: T
            };
          };
          react_production_min.memo = function (a, b) {
            return {
              $$typeof: x,
              type: a,
              compare: void 0 === b ? null : b
            };
          };
          react_production_min.startTransition = function (a) {
            var b = V.transition;
            V.transition = {};
            try {
              a();
            } finally {
              V.transition = b;
            }
          };
          react_production_min.unstable_act = function () {
            throw Error("act(...) is not supported in production builds of React.");
          };
          react_production_min.useCallback = function (a, b) {
            return U.current.useCallback(a, b);
          };
          react_production_min.useContext = function (a) {
            return U.current.useContext(a);
          };
          react_production_min.useDebugValue = function () {};
          react_production_min.useDeferredValue = function (a) {
            return U.current.useDeferredValue(a);
          };
          react_production_min.useEffect = function (a, b) {
            return U.current.useEffect(a, b);
          };
          react_production_min.useId = function () {
            return U.current.useId();
          };
          react_production_min.useImperativeHandle = function (a, b, e) {
            return U.current.useImperativeHandle(a, b, e);
          };
          react_production_min.useInsertionEffect = function (a, b) {
            return U.current.useInsertionEffect(a, b);
          };
          react_production_min.useLayoutEffect = function (a, b) {
            return U.current.useLayoutEffect(a, b);
          };
          react_production_min.useMemo = function (a, b) {
            return U.current.useMemo(a, b);
          };
          react_production_min.useReducer = function (a, b, e) {
            return U.current.useReducer(a, b, e);
          };
          react_production_min.useRef = function (a) {
            return U.current.useRef(a);
          };
          react_production_min.useState = function (a) {
            return U.current.useState(a);
          };
          react_production_min.useSyncExternalStore = function (a, b, e) {
            return U.current.useSyncExternalStore(a, b, e);
          };
          react_production_min.useTransition = function () {
            return U.current.useTransition();
          };
          react_production_min.version = "18.2.0";
          return react_production_min;
        }
        var hasRequiredReact;
        function requireReact() {
          if (hasRequiredReact) return react.exports;
          hasRequiredReact = 1;
          {
            react.exports = requireReact_production_min();
          }
          return react.exports;
        }

        /**
         * @license React
         * react-jsx-runtime.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var hasRequiredReactJsxRuntime_production_min;
        function requireReactJsxRuntime_production_min() {
          if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
          hasRequiredReactJsxRuntime_production_min = 1;
          var f = requireReact(),
            k = Symbol.for("react.element"),
            l = Symbol.for("react.fragment"),
            m = Object.prototype.hasOwnProperty,
            n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
            p = {
              key: true,
              ref: true,
              __self: true,
              __source: true
            };
          function q(c, a, g) {
            var b,
              d = {},
              e = null,
              h = null;
            void 0 !== g && (e = "" + g);
            void 0 !== a.key && (e = "" + a.key);
            void 0 !== a.ref && (h = a.ref);
            for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
            if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
            return {
              $$typeof: k,
              type: c,
              key: e,
              ref: h,
              props: d,
              _owner: n.current
            };
          }
          reactJsxRuntime_production_min.Fragment = l;
          reactJsxRuntime_production_min.jsx = q;
          reactJsxRuntime_production_min.jsxs = q;
          return reactJsxRuntime_production_min;
        }
        var hasRequiredJsxRuntime;
        function requireJsxRuntime() {
          if (hasRequiredJsxRuntime) return jsxRuntime.exports;
          hasRequiredJsxRuntime = 1;
          {
            jsxRuntime.exports = requireReactJsxRuntime_production_min();
          }
          return jsxRuntime.exports;
        }
        var jsxRuntimeExports = exports("j", requireJsxRuntime());
        var reactExports = exports("e", requireReact());
        const React = exports("R", /*@__PURE__*/getDefaultExportFromCjs(reactExports));
        var client = {};
        var reactDom = {
          exports: {}
        };
        var reactDom_production_min = {};
        var scheduler = {
          exports: {}
        };
        var scheduler_production_min = {};

        /**
         * @license React
         * scheduler.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var hasRequiredScheduler_production_min;
        function requireScheduler_production_min() {
          if (hasRequiredScheduler_production_min) return scheduler_production_min;
          hasRequiredScheduler_production_min = 1;
          (function (exports) {
            function f(a, b) {
              var c = a.length;
              a.push(b);
              a: for (; 0 < c;) {
                var d = c - 1 >>> 1,
                  e = a[d];
                if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;else break a;
              }
            }
            function h(a) {
              return 0 === a.length ? null : a[0];
            }
            function k(a) {
              if (0 === a.length) return null;
              var b = a[0],
                c = a.pop();
              if (c !== b) {
                a[0] = c;
                a: for (var d = 0, e = a.length, w = e >>> 1; d < w;) {
                  var m = 2 * (d + 1) - 1,
                    C = a[m],
                    n = m + 1,
                    x = a[n];
                  if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;else break a;
                }
              }
              return b;
            }
            function g(a, b) {
              var c = a.sortIndex - b.sortIndex;
              return 0 !== c ? c : a.id - b.id;
            }
            if ("object" === typeof performance && "function" === typeof performance.now) {
              var l = performance;
              exports.unstable_now = function () {
                return l.now();
              };
            } else {
              var p = Date,
                q = p.now();
              exports.unstable_now = function () {
                return p.now() - q;
              };
            }
            var r = [],
              t = [],
              u = 1,
              v = null,
              y = 3,
              z = false,
              A = false,
              B = false,
              D = "function" === typeof setTimeout ? setTimeout : null,
              E = "function" === typeof clearTimeout ? clearTimeout : null,
              F = "undefined" !== typeof setImmediate ? setImmediate : null;
            "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
            function G(a) {
              for (var b = h(t); null !== b;) {
                if (null === b.callback) k(t);else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);else break;
                b = h(t);
              }
            }
            function H(a) {
              B = false;
              G(a);
              if (!A) if (null !== h(r)) A = true, I(J);else {
                var b = h(t);
                null !== b && K(H, b.startTime - a);
              }
            }
            function J(a, b) {
              A = false;
              B && (B = false, E(L), L = -1);
              z = true;
              var c = y;
              try {
                G(b);
                for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M());) {
                  var d = v.callback;
                  if ("function" === typeof d) {
                    v.callback = null;
                    y = v.priorityLevel;
                    var e = d(v.expirationTime <= b);
                    b = exports.unstable_now();
                    "function" === typeof e ? v.callback = e : v === h(r) && k(r);
                    G(b);
                  } else k(r);
                  v = h(r);
                }
                if (null !== v) var w = !0;else {
                  var m = h(t);
                  null !== m && K(H, m.startTime - b);
                  w = !1;
                }
                return w;
              } finally {
                v = null, y = c, z = false;
              }
            }
            var N = false,
              O = null,
              L = -1,
              P = 5,
              Q = -1;
            function M() {
              return exports.unstable_now() - Q < P ? false : true;
            }
            function R() {
              if (null !== O) {
                var a = exports.unstable_now();
                Q = a;
                var b = true;
                try {
                  b = O(!0, a);
                } finally {
                  b ? S() : (N = false, O = null);
                }
              } else N = false;
            }
            var S;
            if ("function" === typeof F) S = function () {
              F(R);
            };else if ("undefined" !== typeof MessageChannel) {
              var T = new MessageChannel(),
                U = T.port2;
              T.port1.onmessage = R;
              S = function () {
                U.postMessage(null);
              };
            } else S = function () {
              D(R, 0);
            };
            function I(a) {
              O = a;
              N || (N = true, S());
            }
            function K(a, b) {
              L = D(function () {
                a(exports.unstable_now());
              }, b);
            }
            exports.unstable_IdlePriority = 5;
            exports.unstable_ImmediatePriority = 1;
            exports.unstable_LowPriority = 4;
            exports.unstable_NormalPriority = 3;
            exports.unstable_Profiling = null;
            exports.unstable_UserBlockingPriority = 2;
            exports.unstable_cancelCallback = function (a) {
              a.callback = null;
            };
            exports.unstable_continueExecution = function () {
              A || z || (A = true, I(J));
            };
            exports.unstable_forceFrameRate = function (a) {
              0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1E3 / a) : 5;
            };
            exports.unstable_getCurrentPriorityLevel = function () {
              return y;
            };
            exports.unstable_getFirstCallbackNode = function () {
              return h(r);
            };
            exports.unstable_next = function (a) {
              switch (y) {
                case 1:
                case 2:
                case 3:
                  var b = 3;
                  break;
                default:
                  b = y;
              }
              var c = y;
              y = b;
              try {
                return a();
              } finally {
                y = c;
              }
            };
            exports.unstable_pauseExecution = function () {};
            exports.unstable_requestPaint = function () {};
            exports.unstable_runWithPriority = function (a, b) {
              switch (a) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                  break;
                default:
                  a = 3;
              }
              var c = y;
              y = a;
              try {
                return b();
              } finally {
                y = c;
              }
            };
            exports.unstable_scheduleCallback = function (a, b, c) {
              var d = exports.unstable_now();
              "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
              switch (a) {
                case 1:
                  var e = -1;
                  break;
                case 2:
                  e = 250;
                  break;
                case 5:
                  e = 1073741823;
                  break;
                case 4:
                  e = 1E4;
                  break;
                default:
                  e = 5E3;
              }
              e = c + e;
              a = {
                id: u++,
                callback: b,
                priorityLevel: a,
                startTime: c,
                expirationTime: e,
                sortIndex: -1
              };
              c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
              return a;
            };
            exports.unstable_shouldYield = M;
            exports.unstable_wrapCallback = function (a) {
              var b = y;
              return function () {
                var c = y;
                y = b;
                try {
                  return a.apply(this, arguments);
                } finally {
                  y = c;
                }
              };
            };
          })(scheduler_production_min);
          return scheduler_production_min;
        }
        var hasRequiredScheduler;
        function requireScheduler() {
          if (hasRequiredScheduler) return scheduler.exports;
          hasRequiredScheduler = 1;
          {
            scheduler.exports = requireScheduler_production_min();
          }
          return scheduler.exports;
        }

        /**
         * @license React
         * react-dom.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var hasRequiredReactDom_production_min;
        function requireReactDom_production_min() {
          if (hasRequiredReactDom_production_min) return reactDom_production_min;
          hasRequiredReactDom_production_min = 1;
          var aa = requireReact(),
            ca = requireScheduler();
          function p(a) {
            for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
            return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
          }
          var da = new Set(),
            ea = {};
          function fa(a, b) {
            ha(a, b);
            ha(a + "Capture", b);
          }
          function ha(a, b) {
            ea[a] = b;
            for (a = 0; a < b.length; a++) da.add(b[a]);
          }
          var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
            ja = Object.prototype.hasOwnProperty,
            ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
            la = {},
            ma = {};
          function oa(a) {
            if (ja.call(ma, a)) return true;
            if (ja.call(la, a)) return false;
            if (ka.test(a)) return ma[a] = true;
            la[a] = true;
            return false;
          }
          function pa(a, b, c, d) {
            if (null !== c && 0 === c.type) return false;
            switch (typeof b) {
              case "function":
              case "symbol":
                return true;
              case "boolean":
                if (d) return false;
                if (null !== c) return !c.acceptsBooleans;
                a = a.toLowerCase().slice(0, 5);
                return "data-" !== a && "aria-" !== a;
              default:
                return false;
            }
          }
          function qa(a, b, c, d) {
            if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
            if (d) return false;
            if (null !== c) switch (c.type) {
              case 3:
                return !b;
              case 4:
                return false === b;
              case 5:
                return isNaN(b);
              case 6:
                return isNaN(b) || 1 > b;
            }
            return false;
          }
          function v(a, b, c, d, e, f, g) {
            this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
            this.attributeName = d;
            this.attributeNamespace = e;
            this.mustUseProperty = c;
            this.propertyName = a;
            this.type = b;
            this.sanitizeURL = f;
            this.removeEmptyString = g;
          }
          var z = {};
          "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
            z[a] = new v(a, 0, false, a, null, false, false);
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
            var b = a[0];
            z[b] = new v(b, 1, false, a[1], null, false, false);
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
            z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
            z[a] = new v(a, 2, false, a, null, false, false);
          });
          "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
            z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
          });
          ["checked", "multiple", "muted", "selected"].forEach(function (a) {
            z[a] = new v(a, 3, true, a, null, false, false);
          });
          ["capture", "download"].forEach(function (a) {
            z[a] = new v(a, 4, false, a, null, false, false);
          });
          ["cols", "rows", "size", "span"].forEach(function (a) {
            z[a] = new v(a, 6, false, a, null, false, false);
          });
          ["rowSpan", "start"].forEach(function (a) {
            z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
          });
          var ra = /[\-:]([a-z])/g;
          function sa(a) {
            return a[1].toUpperCase();
          }
          "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
            var b = a.replace(ra, sa);
            z[b] = new v(b, 1, false, a, null, false, false);
          });
          "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
            var b = a.replace(ra, sa);
            z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
          });
          ["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
            var b = a.replace(ra, sa);
            z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
          });
          ["tabIndex", "crossOrigin"].forEach(function (a) {
            z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
          });
          z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
          ["src", "href", "action", "formAction"].forEach(function (a) {
            z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
          });
          function ta(a, b, c, d) {
            var e = z.hasOwnProperty(b) ? z[b] : null;
            if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
          }
          var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
            va = Symbol.for("react.element"),
            wa = Symbol.for("react.portal"),
            ya = Symbol.for("react.fragment"),
            za = Symbol.for("react.strict_mode"),
            Aa = Symbol.for("react.profiler"),
            Ba = Symbol.for("react.provider"),
            Ca = Symbol.for("react.context"),
            Da = Symbol.for("react.forward_ref"),
            Ea = Symbol.for("react.suspense"),
            Fa = Symbol.for("react.suspense_list"),
            Ga = Symbol.for("react.memo"),
            Ha = Symbol.for("react.lazy");
          var Ia = Symbol.for("react.offscreen");
          var Ja = Symbol.iterator;
          function Ka(a) {
            if (null === a || "object" !== typeof a) return null;
            a = Ja && a[Ja] || a["@@iterator"];
            return "function" === typeof a ? a : null;
          }
          var A = Object.assign,
            La;
          function Ma(a) {
            if (void 0 === La) try {
              throw Error();
            } catch (c) {
              var b = c.stack.trim().match(/\n( *(at )?)/);
              La = b && b[1] || "";
            }
            return "\n" + La + a;
          }
          var Na = false;
          function Oa(a, b) {
            if (!a || Na) return "";
            Na = true;
            var c = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            try {
              if (b) {
                if (b = function () {
                  throw Error();
                }, Object.defineProperty(b.prototype, "props", {
                  set: function () {
                    throw Error();
                  }
                }), "object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(b, []);
                  } catch (l) {
                    var d = l;
                  }
                  Reflect.construct(a, [], b);
                } else {
                  try {
                    b.call();
                  } catch (l) {
                    d = l;
                  }
                  a.call(b.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (l) {
                  d = l;
                }
                a();
              }
            } catch (l) {
              if (l && d && "string" === typeof l.stack) {
                for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h];) h--;
                for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
                  if (1 !== g || 1 !== h) {
                    do if (g--, h--, 0 > h || e[g] !== f[h]) {
                      var k = "\n" + e[g].replace(" at new ", " at ");
                      a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                      return k;
                    } while (1 <= g && 0 <= h);
                  }
                  break;
                }
              }
            } finally {
              Na = false, Error.prepareStackTrace = c;
            }
            return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
          }
          function Pa(a) {
            switch (a.tag) {
              case 5:
                return Ma(a.type);
              case 16:
                return Ma("Lazy");
              case 13:
                return Ma("Suspense");
              case 19:
                return Ma("SuspenseList");
              case 0:
              case 2:
              case 15:
                return a = Oa(a.type, false), a;
              case 11:
                return a = Oa(a.type.render, false), a;
              case 1:
                return a = Oa(a.type, true), a;
              default:
                return "";
            }
          }
          function Qa(a) {
            if (null == a) return null;
            if ("function" === typeof a) return a.displayName || a.name || null;
            if ("string" === typeof a) return a;
            switch (a) {
              case ya:
                return "Fragment";
              case wa:
                return "Portal";
              case Aa:
                return "Profiler";
              case za:
                return "StrictMode";
              case Ea:
                return "Suspense";
              case Fa:
                return "SuspenseList";
            }
            if ("object" === typeof a) switch (a.$$typeof) {
              case Ca:
                return (a.displayName || "Context") + ".Consumer";
              case Ba:
                return (a._context.displayName || "Context") + ".Provider";
              case Da:
                var b = a.render;
                a = a.displayName;
                a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
                return a;
              case Ga:
                return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
              case Ha:
                b = a._payload;
                a = a._init;
                try {
                  return Qa(a(b));
                } catch (c) {}
            }
            return null;
          }
          function Ra(a) {
            var b = a.type;
            switch (a.tag) {
              case 24:
                return "Cache";
              case 9:
                return (b.displayName || "Context") + ".Consumer";
              case 10:
                return (b._context.displayName || "Context") + ".Provider";
              case 18:
                return "DehydratedFragment";
              case 11:
                return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
              case 7:
                return "Fragment";
              case 5:
                return b;
              case 4:
                return "Portal";
              case 3:
                return "Root";
              case 6:
                return "Text";
              case 16:
                return Qa(b);
              case 8:
                return b === za ? "StrictMode" : "Mode";
              case 22:
                return "Offscreen";
              case 12:
                return "Profiler";
              case 21:
                return "Scope";
              case 13:
                return "Suspense";
              case 19:
                return "SuspenseList";
              case 25:
                return "TracingMarker";
              case 1:
              case 0:
              case 17:
              case 2:
              case 14:
              case 15:
                if ("function" === typeof b) return b.displayName || b.name || null;
                if ("string" === typeof b) return b;
            }
            return null;
          }
          function Sa(a) {
            switch (typeof a) {
              case "boolean":
              case "number":
              case "string":
              case "undefined":
                return a;
              case "object":
                return a;
              default:
                return "";
            }
          }
          function Ta(a) {
            var b = a.type;
            return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
          }
          function Ua(a) {
            var b = Ta(a) ? "checked" : "value",
              c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
              d = "" + a[b];
            if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
              var e = c.get,
                f = c.set;
              Object.defineProperty(a, b, {
                configurable: true,
                get: function () {
                  return e.call(this);
                },
                set: function (a) {
                  d = "" + a;
                  f.call(this, a);
                }
              });
              Object.defineProperty(a, b, {
                enumerable: c.enumerable
              });
              return {
                getValue: function () {
                  return d;
                },
                setValue: function (a) {
                  d = "" + a;
                },
                stopTracking: function () {
                  a._valueTracker = null;
                  delete a[b];
                }
              };
            }
          }
          function Va(a) {
            a._valueTracker || (a._valueTracker = Ua(a));
          }
          function Wa(a) {
            if (!a) return false;
            var b = a._valueTracker;
            if (!b) return true;
            var c = b.getValue();
            var d = "";
            a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
            a = d;
            return a !== c ? (b.setValue(a), true) : false;
          }
          function Xa(a) {
            a = a || ("undefined" !== typeof document ? document : void 0);
            if ("undefined" === typeof a) return null;
            try {
              return a.activeElement || a.body;
            } catch (b) {
              return a.body;
            }
          }
          function Ya(a, b) {
            var c = b.checked;
            return A({}, b, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: void 0,
              checked: null != c ? c : a._wrapperState.initialChecked
            });
          }
          function Za(a, b) {
            var c = null == b.defaultValue ? "" : b.defaultValue,
              d = null != b.checked ? b.checked : b.defaultChecked;
            c = Sa(null != b.value ? b.value : c);
            a._wrapperState = {
              initialChecked: d,
              initialValue: c,
              controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
            };
          }
          function ab(a, b) {
            b = b.checked;
            null != b && ta(a, "checked", b, false);
          }
          function bb(a, b) {
            ab(a, b);
            var c = Sa(b.value),
              d = b.type;
            if (null != c) {
              if ("number" === d) {
                if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
              } else a.value !== "" + c && (a.value = "" + c);
            } else if ("submit" === d || "reset" === d) {
              a.removeAttribute("value");
              return;
            }
            b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
            null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
          }
          function db(a, b, c) {
            if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
              var d = b.type;
              if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
              b = "" + a._wrapperState.initialValue;
              c || b === a.value || (a.value = b);
              a.defaultValue = b;
            }
            c = a.name;
            "" !== c && (a.name = "");
            a.defaultChecked = !!a._wrapperState.initialChecked;
            "" !== c && (a.name = c);
          }
          function cb(a, b, c) {
            if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
          }
          var eb = Array.isArray;
          function fb(a, b, c, d) {
            a = a.options;
            if (b) {
              b = {};
              for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
              for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
            } else {
              c = "" + Sa(c);
              b = null;
              for (e = 0; e < a.length; e++) {
                if (a[e].value === c) {
                  a[e].selected = true;
                  d && (a[e].defaultSelected = true);
                  return;
                }
                null !== b || a[e].disabled || (b = a[e]);
              }
              null !== b && (b.selected = true);
            }
          }
          function gb(a, b) {
            if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
            return A({}, b, {
              value: void 0,
              defaultValue: void 0,
              children: "" + a._wrapperState.initialValue
            });
          }
          function hb(a, b) {
            var c = b.value;
            if (null == c) {
              c = b.children;
              b = b.defaultValue;
              if (null != c) {
                if (null != b) throw Error(p(92));
                if (eb(c)) {
                  if (1 < c.length) throw Error(p(93));
                  c = c[0];
                }
                b = c;
              }
              null == b && (b = "");
              c = b;
            }
            a._wrapperState = {
              initialValue: Sa(c)
            };
          }
          function ib(a, b) {
            var c = Sa(b.value),
              d = Sa(b.defaultValue);
            null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
            null != d && (a.defaultValue = "" + d);
          }
          function jb(a) {
            var b = a.textContent;
            b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
          }
          function kb(a) {
            switch (a) {
              case "svg":
                return "http://www.w3.org/2000/svg";
              case "math":
                return "http://www.w3.org/1998/Math/MathML";
              default:
                return "http://www.w3.org/1999/xhtml";
            }
          }
          function lb(a, b) {
            return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
          }
          var mb,
            nb = function (a) {
              return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
                MSApp.execUnsafeLocalFunction(function () {
                  return a(b, c, d, e);
                });
              } : a;
            }(function (a, b) {
              if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;else {
                mb = mb || document.createElement("div");
                mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
                for (b = mb.firstChild; a.firstChild;) a.removeChild(a.firstChild);
                for (; b.firstChild;) a.appendChild(b.firstChild);
              }
            });
          function ob(a, b) {
            if (b) {
              var c = a.firstChild;
              if (c && c === a.lastChild && 3 === c.nodeType) {
                c.nodeValue = b;
                return;
              }
            }
            a.textContent = b;
          }
          var pb = {
              animationIterationCount: true,
              aspectRatio: true,
              borderImageOutset: true,
              borderImageSlice: true,
              borderImageWidth: true,
              boxFlex: true,
              boxFlexGroup: true,
              boxOrdinalGroup: true,
              columnCount: true,
              columns: true,
              flex: true,
              flexGrow: true,
              flexPositive: true,
              flexShrink: true,
              flexNegative: true,
              flexOrder: true,
              gridArea: true,
              gridRow: true,
              gridRowEnd: true,
              gridRowSpan: true,
              gridRowStart: true,
              gridColumn: true,
              gridColumnEnd: true,
              gridColumnSpan: true,
              gridColumnStart: true,
              fontWeight: true,
              lineClamp: true,
              lineHeight: true,
              opacity: true,
              order: true,
              orphans: true,
              tabSize: true,
              widows: true,
              zIndex: true,
              zoom: true,
              fillOpacity: true,
              floodOpacity: true,
              stopOpacity: true,
              strokeDasharray: true,
              strokeDashoffset: true,
              strokeMiterlimit: true,
              strokeOpacity: true,
              strokeWidth: true
            },
            qb = ["Webkit", "ms", "Moz", "O"];
          Object.keys(pb).forEach(function (a) {
            qb.forEach(function (b) {
              b = b + a.charAt(0).toUpperCase() + a.substring(1);
              pb[b] = pb[a];
            });
          });
          function rb(a, b, c) {
            return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
          }
          function sb(a, b) {
            a = a.style;
            for (var c in b) if (b.hasOwnProperty(c)) {
              var d = 0 === c.indexOf("--"),
                e = rb(c, b[c], d);
              "float" === c && (c = "cssFloat");
              d ? a.setProperty(c, e) : a[c] = e;
            }
          }
          var tb = A({
            menuitem: true
          }, {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
          });
          function ub(a, b) {
            if (b) {
              if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
              if (null != b.dangerouslySetInnerHTML) {
                if (null != b.children) throw Error(p(60));
                if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
              }
              if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
            }
          }
          function vb(a, b) {
            if (-1 === a.indexOf("-")) return "string" === typeof b.is;
            switch (a) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var wb = null;
          function xb(a) {
            a = a.target || a.srcElement || window;
            a.correspondingUseElement && (a = a.correspondingUseElement);
            return 3 === a.nodeType ? a.parentNode : a;
          }
          var yb = null,
            zb = null,
            Ab = null;
          function Bb(a) {
            if (a = Cb(a)) {
              if ("function" !== typeof yb) throw Error(p(280));
              var b = a.stateNode;
              b && (b = Db(b), yb(a.stateNode, a.type, b));
            }
          }
          function Eb(a) {
            zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
          }
          function Fb() {
            if (zb) {
              var a = zb,
                b = Ab;
              Ab = zb = null;
              Bb(a);
              if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
            }
          }
          function Gb(a, b) {
            return a(b);
          }
          function Hb() {}
          var Ib = false;
          function Jb(a, b, c) {
            if (Ib) return a(b, c);
            Ib = true;
            try {
              return Gb(a, b, c);
            } finally {
              if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
            }
          }
          function Kb(a, b) {
            var c = a.stateNode;
            if (null === c) return null;
            var d = Db(c);
            if (null === d) return null;
            c = d[b];
            a: switch (b) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
                a = !d;
                break a;
              default:
                a = false;
            }
            if (a) return null;
            if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
            return c;
          }
          var Lb = false;
          if (ia) try {
            var Mb = {};
            Object.defineProperty(Mb, "passive", {
              get: function () {
                Lb = !0;
              }
            });
            window.addEventListener("test", Mb, Mb);
            window.removeEventListener("test", Mb, Mb);
          } catch (a) {
            Lb = false;
          }
          function Nb(a, b, c, d, e, f, g, h, k) {
            var l = Array.prototype.slice.call(arguments, 3);
            try {
              b.apply(c, l);
            } catch (m) {
              this.onError(m);
            }
          }
          var Ob = false,
            Pb = null,
            Qb = false,
            Rb = null,
            Sb = {
              onError: function (a) {
                Ob = true;
                Pb = a;
              }
            };
          function Tb(a, b, c, d, e, f, g, h, k) {
            Ob = false;
            Pb = null;
            Nb.apply(Sb, arguments);
          }
          function Ub(a, b, c, d, e, f, g, h, k) {
            Tb.apply(this, arguments);
            if (Ob) {
              if (Ob) {
                var l = Pb;
                Ob = false;
                Pb = null;
              } else throw Error(p(198));
              Qb || (Qb = true, Rb = l);
            }
          }
          function Vb(a) {
            var b = a,
              c = a;
            if (a.alternate) for (; b.return;) b = b.return;else {
              a = b;
              do b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return; while (a);
            }
            return 3 === b.tag ? c : null;
          }
          function Wb(a) {
            if (13 === a.tag) {
              var b = a.memoizedState;
              null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
              if (null !== b) return b.dehydrated;
            }
            return null;
          }
          function Xb(a) {
            if (Vb(a) !== a) throw Error(p(188));
          }
          function Yb(a) {
            var b = a.alternate;
            if (!b) {
              b = Vb(a);
              if (null === b) throw Error(p(188));
              return b !== a ? null : a;
            }
            for (var c = a, d = b;;) {
              var e = c.return;
              if (null === e) break;
              var f = e.alternate;
              if (null === f) {
                d = e.return;
                if (null !== d) {
                  c = d;
                  continue;
                }
                break;
              }
              if (e.child === f.child) {
                for (f = e.child; f;) {
                  if (f === c) return Xb(e), a;
                  if (f === d) return Xb(e), b;
                  f = f.sibling;
                }
                throw Error(p(188));
              }
              if (c.return !== d.return) c = e, d = f;else {
                for (var g = false, h = e.child; h;) {
                  if (h === c) {
                    g = true;
                    c = e;
                    d = f;
                    break;
                  }
                  if (h === d) {
                    g = true;
                    d = e;
                    c = f;
                    break;
                  }
                  h = h.sibling;
                }
                if (!g) {
                  for (h = f.child; h;) {
                    if (h === c) {
                      g = true;
                      c = f;
                      d = e;
                      break;
                    }
                    if (h === d) {
                      g = true;
                      d = f;
                      c = e;
                      break;
                    }
                    h = h.sibling;
                  }
                  if (!g) throw Error(p(189));
                }
              }
              if (c.alternate !== d) throw Error(p(190));
            }
            if (3 !== c.tag) throw Error(p(188));
            return c.stateNode.current === c ? a : b;
          }
          function Zb(a) {
            a = Yb(a);
            return null !== a ? $b(a) : null;
          }
          function $b(a) {
            if (5 === a.tag || 6 === a.tag) return a;
            for (a = a.child; null !== a;) {
              var b = $b(a);
              if (null !== b) return b;
              a = a.sibling;
            }
            return null;
          }
          var ac = ca.unstable_scheduleCallback,
            bc = ca.unstable_cancelCallback,
            cc = ca.unstable_shouldYield,
            dc = ca.unstable_requestPaint,
            B = ca.unstable_now,
            ec = ca.unstable_getCurrentPriorityLevel,
            fc = ca.unstable_ImmediatePriority,
            gc = ca.unstable_UserBlockingPriority,
            hc = ca.unstable_NormalPriority,
            ic = ca.unstable_LowPriority,
            jc = ca.unstable_IdlePriority,
            kc = null,
            lc = null;
          function mc(a) {
            if (lc && "function" === typeof lc.onCommitFiberRoot) try {
              lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
            } catch (b) {}
          }
          var oc = Math.clz32 ? Math.clz32 : nc,
            pc = Math.log,
            qc = Math.LN2;
          function nc(a) {
            a >>>= 0;
            return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
          }
          var rc = 64,
            sc = 4194304;
          function tc(a) {
            switch (a & -a) {
              case 1:
                return 1;
              case 2:
                return 2;
              case 4:
                return 4;
              case 8:
                return 8;
              case 16:
                return 16;
              case 32:
                return 32;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
                return a & 4194240;
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                return a & 130023424;
              case 134217728:
                return 134217728;
              case 268435456:
                return 268435456;
              case 536870912:
                return 536870912;
              case 1073741824:
                return 1073741824;
              default:
                return a;
            }
          }
          function uc(a, b) {
            var c = a.pendingLanes;
            if (0 === c) return 0;
            var d = 0,
              e = a.suspendedLanes,
              f = a.pingedLanes,
              g = c & 268435455;
            if (0 !== g) {
              var h = g & ~e;
              0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
            } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
            if (0 === d) return 0;
            if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
            0 !== (d & 4) && (d |= c & 16);
            b = a.entangledLanes;
            if (0 !== b) for (a = a.entanglements, b &= d; 0 < b;) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
            return d;
          }
          function vc(a, b) {
            switch (a) {
              case 1:
              case 2:
              case 4:
                return b + 250;
              case 8:
              case 16:
              case 32:
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
                return b + 5E3;
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                return -1;
              case 134217728:
              case 268435456:
              case 536870912:
              case 1073741824:
                return -1;
              default:
                return -1;
            }
          }
          function wc(a, b) {
            for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f;) {
              var g = 31 - oc(f),
                h = 1 << g,
                k = e[g];
              if (-1 === k) {
                if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
              } else k <= b && (a.expiredLanes |= h);
              f &= ~h;
            }
          }
          function xc(a) {
            a = a.pendingLanes & -1073741825;
            return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
          }
          function yc() {
            var a = rc;
            rc <<= 1;
            0 === (rc & 4194240) && (rc = 64);
            return a;
          }
          function zc(a) {
            for (var b = [], c = 0; 31 > c; c++) b.push(a);
            return b;
          }
          function Ac(a, b, c) {
            a.pendingLanes |= b;
            536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
            a = a.eventTimes;
            b = 31 - oc(b);
            a[b] = c;
          }
          function Bc(a, b) {
            var c = a.pendingLanes & ~b;
            a.pendingLanes = b;
            a.suspendedLanes = 0;
            a.pingedLanes = 0;
            a.expiredLanes &= b;
            a.mutableReadLanes &= b;
            a.entangledLanes &= b;
            b = a.entanglements;
            var d = a.eventTimes;
            for (a = a.expirationTimes; 0 < c;) {
              var e = 31 - oc(c),
                f = 1 << e;
              b[e] = 0;
              d[e] = -1;
              a[e] = -1;
              c &= ~f;
            }
          }
          function Cc(a, b) {
            var c = a.entangledLanes |= b;
            for (a = a.entanglements; c;) {
              var d = 31 - oc(c),
                e = 1 << d;
              e & b | a[d] & b && (a[d] |= b);
              c &= ~e;
            }
          }
          var C = 0;
          function Dc(a) {
            a &= -a;
            return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
          }
          var Ec,
            Fc,
            Gc,
            Hc,
            Ic,
            Jc = false,
            Kc = [],
            Lc = null,
            Mc = null,
            Nc = null,
            Oc = new Map(),
            Pc = new Map(),
            Qc = [],
            Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
          function Sc(a, b) {
            switch (a) {
              case "focusin":
              case "focusout":
                Lc = null;
                break;
              case "dragenter":
              case "dragleave":
                Mc = null;
                break;
              case "mouseover":
              case "mouseout":
                Nc = null;
                break;
              case "pointerover":
              case "pointerout":
                Oc.delete(b.pointerId);
                break;
              case "gotpointercapture":
              case "lostpointercapture":
                Pc.delete(b.pointerId);
            }
          }
          function Tc(a, b, c, d, e, f) {
            if (null === a || a.nativeEvent !== f) return a = {
              blockedOn: b,
              domEventName: c,
              eventSystemFlags: d,
              nativeEvent: f,
              targetContainers: [e]
            }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
            a.eventSystemFlags |= d;
            b = a.targetContainers;
            null !== e && -1 === b.indexOf(e) && b.push(e);
            return a;
          }
          function Uc(a, b, c, d, e) {
            switch (b) {
              case "focusin":
                return Lc = Tc(Lc, a, b, c, d, e), true;
              case "dragenter":
                return Mc = Tc(Mc, a, b, c, d, e), true;
              case "mouseover":
                return Nc = Tc(Nc, a, b, c, d, e), true;
              case "pointerover":
                var f = e.pointerId;
                Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
                return true;
              case "gotpointercapture":
                return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
            }
            return false;
          }
          function Vc(a) {
            var b = Wc(a.target);
            if (null !== b) {
              var c = Vb(b);
              if (null !== c) if (b = c.tag, 13 === b) {
                if (b = Wb(c), null !== b) {
                  a.blockedOn = b;
                  Ic(a.priority, function () {
                    Gc(c);
                  });
                  return;
                }
              } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
                a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
                return;
              }
            }
            a.blockedOn = null;
          }
          function Xc(a) {
            if (null !== a.blockedOn) return false;
            for (var b = a.targetContainers; 0 < b.length;) {
              var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
              if (null === c) {
                c = a.nativeEvent;
                var d = new c.constructor(c.type, c);
                wb = d;
                c.target.dispatchEvent(d);
                wb = null;
              } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
              b.shift();
            }
            return true;
          }
          function Zc(a, b, c) {
            Xc(a) && c.delete(b);
          }
          function $c() {
            Jc = false;
            null !== Lc && Xc(Lc) && (Lc = null);
            null !== Mc && Xc(Mc) && (Mc = null);
            null !== Nc && Xc(Nc) && (Nc = null);
            Oc.forEach(Zc);
            Pc.forEach(Zc);
          }
          function ad(a, b) {
            a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
          }
          function bd(a) {
            function b(b) {
              return ad(b, a);
            }
            if (0 < Kc.length) {
              ad(Kc[0], a);
              for (var c = 1; c < Kc.length; c++) {
                var d = Kc[c];
                d.blockedOn === a && (d.blockedOn = null);
              }
            }
            null !== Lc && ad(Lc, a);
            null !== Mc && ad(Mc, a);
            null !== Nc && ad(Nc, a);
            Oc.forEach(b);
            Pc.forEach(b);
            for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
            for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn);) Vc(c), null === c.blockedOn && Qc.shift();
          }
          var cd = ua.ReactCurrentBatchConfig,
            dd = true;
          function ed(a, b, c, d) {
            var e = C,
              f = cd.transition;
            cd.transition = null;
            try {
              C = 1, fd(a, b, c, d);
            } finally {
              C = e, cd.transition = f;
            }
          }
          function gd(a, b, c, d) {
            var e = C,
              f = cd.transition;
            cd.transition = null;
            try {
              C = 4, fd(a, b, c, d);
            } finally {
              C = e, cd.transition = f;
            }
          }
          function fd(a, b, c, d) {
            if (dd) {
              var e = Yc(a, b, c, d);
              if (null === e) hd(a, b, d, id, c), Sc(a, d);else if (Uc(e, a, b, c, d)) d.stopPropagation();else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
                for (; null !== e;) {
                  var f = Cb(e);
                  null !== f && Ec(f);
                  f = Yc(a, b, c, d);
                  null === f && hd(a, b, d, id, c);
                  if (f === e) break;
                  e = f;
                }
                null !== e && d.stopPropagation();
              } else hd(a, b, d, null, c);
            }
          }
          var id = null;
          function Yc(a, b, c, d) {
            id = null;
            a = xb(d);
            a = Wc(a);
            if (null !== a) if (b = Vb(a), null === b) a = null;else if (c = b.tag, 13 === c) {
              a = Wb(b);
              if (null !== a) return a;
              a = null;
            } else if (3 === c) {
              if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
              a = null;
            } else b !== a && (a = null);
            id = a;
            return null;
          }
          function jd(a) {
            switch (a) {
              case "cancel":
              case "click":
              case "close":
              case "contextmenu":
              case "copy":
              case "cut":
              case "auxclick":
              case "dblclick":
              case "dragend":
              case "dragstart":
              case "drop":
              case "focusin":
              case "focusout":
              case "input":
              case "invalid":
              case "keydown":
              case "keypress":
              case "keyup":
              case "mousedown":
              case "mouseup":
              case "paste":
              case "pause":
              case "play":
              case "pointercancel":
              case "pointerdown":
              case "pointerup":
              case "ratechange":
              case "reset":
              case "resize":
              case "seeked":
              case "submit":
              case "touchcancel":
              case "touchend":
              case "touchstart":
              case "volumechange":
              case "change":
              case "selectionchange":
              case "textInput":
              case "compositionstart":
              case "compositionend":
              case "compositionupdate":
              case "beforeblur":
              case "afterblur":
              case "beforeinput":
              case "blur":
              case "fullscreenchange":
              case "focus":
              case "hashchange":
              case "popstate":
              case "select":
              case "selectstart":
                return 1;
              case "drag":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "mousemove":
              case "mouseout":
              case "mouseover":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "scroll":
              case "toggle":
              case "touchmove":
              case "wheel":
              case "mouseenter":
              case "mouseleave":
              case "pointerenter":
              case "pointerleave":
                return 4;
              case "message":
                switch (ec()) {
                  case fc:
                    return 1;
                  case gc:
                    return 4;
                  case hc:
                  case ic:
                    return 16;
                  case jc:
                    return 536870912;
                  default:
                    return 16;
                }
              default:
                return 16;
            }
          }
          var kd = null,
            ld = null,
            md = null;
          function nd() {
            if (md) return md;
            var a,
              b = ld,
              c = b.length,
              d,
              e = "value" in kd ? kd.value : kd.textContent,
              f = e.length;
            for (a = 0; a < c && b[a] === e[a]; a++);
            var g = c - a;
            for (d = 1; d <= g && b[c - d] === e[f - d]; d++);
            return md = e.slice(a, 1 < d ? 1 - d : void 0);
          }
          function od(a) {
            var b = a.keyCode;
            "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
            10 === a && (a = 13);
            return 32 <= a || 13 === a ? a : 0;
          }
          function pd() {
            return true;
          }
          function qd() {
            return false;
          }
          function rd(a) {
            function b(b, d, e, f, g) {
              this._reactName = b;
              this._targetInst = e;
              this.type = d;
              this.nativeEvent = f;
              this.target = g;
              this.currentTarget = null;
              for (var c in a) a.hasOwnProperty(c) && (b = a[c], this[c] = b ? b(f) : f[c]);
              this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
              this.isPropagationStopped = qd;
              return this;
            }
            A(b.prototype, {
              preventDefault: function () {
                this.defaultPrevented = true;
                var a = this.nativeEvent;
                a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = false), this.isDefaultPrevented = pd);
              },
              stopPropagation: function () {
                var a = this.nativeEvent;
                a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = true), this.isPropagationStopped = pd);
              },
              persist: function () {},
              isPersistent: pd
            });
            return b;
          }
          var sd = {
              eventPhase: 0,
              bubbles: 0,
              cancelable: 0,
              timeStamp: function (a) {
                return a.timeStamp || Date.now();
              },
              defaultPrevented: 0,
              isTrusted: 0
            },
            td = rd(sd),
            ud = A({}, sd, {
              view: 0,
              detail: 0
            }),
            vd = rd(ud),
            wd,
            xd,
            yd,
            Ad = A({}, ud, {
              screenX: 0,
              screenY: 0,
              clientX: 0,
              clientY: 0,
              pageX: 0,
              pageY: 0,
              ctrlKey: 0,
              shiftKey: 0,
              altKey: 0,
              metaKey: 0,
              getModifierState: zd,
              button: 0,
              buttons: 0,
              relatedTarget: function (a) {
                return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
              },
              movementX: function (a) {
                if ("movementX" in a) return a.movementX;
                a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
                return wd;
              },
              movementY: function (a) {
                return "movementY" in a ? a.movementY : xd;
              }
            }),
            Bd = rd(Ad),
            Cd = A({}, Ad, {
              dataTransfer: 0
            }),
            Dd = rd(Cd),
            Ed = A({}, ud, {
              relatedTarget: 0
            }),
            Fd = rd(Ed),
            Gd = A({}, sd, {
              animationName: 0,
              elapsedTime: 0,
              pseudoElement: 0
            }),
            Hd = rd(Gd),
            Id = A({}, sd, {
              clipboardData: function (a) {
                return "clipboardData" in a ? a.clipboardData : window.clipboardData;
              }
            }),
            Jd = rd(Id),
            Kd = A({}, sd, {
              data: 0
            }),
            Ld = rd(Kd),
            Md = {
              Esc: "Escape",
              Spacebar: " ",
              Left: "ArrowLeft",
              Up: "ArrowUp",
              Right: "ArrowRight",
              Down: "ArrowDown",
              Del: "Delete",
              Win: "OS",
              Menu: "ContextMenu",
              Apps: "ContextMenu",
              Scroll: "ScrollLock",
              MozPrintableKey: "Unidentified"
            },
            Nd = {
              8: "Backspace",
              9: "Tab",
              12: "Clear",
              13: "Enter",
              16: "Shift",
              17: "Control",
              18: "Alt",
              19: "Pause",
              20: "CapsLock",
              27: "Escape",
              32: " ",
              33: "PageUp",
              34: "PageDown",
              35: "End",
              36: "Home",
              37: "ArrowLeft",
              38: "ArrowUp",
              39: "ArrowRight",
              40: "ArrowDown",
              45: "Insert",
              46: "Delete",
              112: "F1",
              113: "F2",
              114: "F3",
              115: "F4",
              116: "F5",
              117: "F6",
              118: "F7",
              119: "F8",
              120: "F9",
              121: "F10",
              122: "F11",
              123: "F12",
              144: "NumLock",
              145: "ScrollLock",
              224: "Meta"
            },
            Od = {
              Alt: "altKey",
              Control: "ctrlKey",
              Meta: "metaKey",
              Shift: "shiftKey"
            };
          function Pd(a) {
            var b = this.nativeEvent;
            return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
          }
          function zd() {
            return Pd;
          }
          var Qd = A({}, ud, {
              key: function (a) {
                if (a.key) {
                  var b = Md[a.key] || a.key;
                  if ("Unidentified" !== b) return b;
                }
                return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
              },
              code: 0,
              location: 0,
              ctrlKey: 0,
              shiftKey: 0,
              altKey: 0,
              metaKey: 0,
              repeat: 0,
              locale: 0,
              getModifierState: zd,
              charCode: function (a) {
                return "keypress" === a.type ? od(a) : 0;
              },
              keyCode: function (a) {
                return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
              },
              which: function (a) {
                return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
              }
            }),
            Rd = rd(Qd),
            Sd = A({}, Ad, {
              pointerId: 0,
              width: 0,
              height: 0,
              pressure: 0,
              tangentialPressure: 0,
              tiltX: 0,
              tiltY: 0,
              twist: 0,
              pointerType: 0,
              isPrimary: 0
            }),
            Td = rd(Sd),
            Ud = A({}, ud, {
              touches: 0,
              targetTouches: 0,
              changedTouches: 0,
              altKey: 0,
              metaKey: 0,
              ctrlKey: 0,
              shiftKey: 0,
              getModifierState: zd
            }),
            Vd = rd(Ud),
            Wd = A({}, sd, {
              propertyName: 0,
              elapsedTime: 0,
              pseudoElement: 0
            }),
            Xd = rd(Wd),
            Yd = A({}, Ad, {
              deltaX: function (a) {
                return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
              },
              deltaY: function (a) {
                return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
              },
              deltaZ: 0,
              deltaMode: 0
            }),
            Zd = rd(Yd),
            $d = [9, 13, 27, 32],
            ae = ia && "CompositionEvent" in window,
            be = null;
          ia && "documentMode" in document && (be = document.documentMode);
          var ce = ia && "TextEvent" in window && !be,
            de = ia && (!ae || be && 8 < be && 11 >= be),
            ee = String.fromCharCode(32),
            fe = false;
          function ge(a, b) {
            switch (a) {
              case "keyup":
                return -1 !== $d.indexOf(b.keyCode);
              case "keydown":
                return 229 !== b.keyCode;
              case "keypress":
              case "mousedown":
              case "focusout":
                return true;
              default:
                return false;
            }
          }
          function he(a) {
            a = a.detail;
            return "object" === typeof a && "data" in a ? a.data : null;
          }
          var ie = false;
          function je(a, b) {
            switch (a) {
              case "compositionend":
                return he(b);
              case "keypress":
                if (32 !== b.which) return null;
                fe = true;
                return ee;
              case "textInput":
                return a = b.data, a === ee && fe ? null : a;
              default:
                return null;
            }
          }
          function ke(a, b) {
            if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
            switch (a) {
              case "paste":
                return null;
              case "keypress":
                if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
                  if (b.char && 1 < b.char.length) return b.char;
                  if (b.which) return String.fromCharCode(b.which);
                }
                return null;
              case "compositionend":
                return de && "ko" !== b.locale ? null : b.data;
              default:
                return null;
            }
          }
          var le = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          };
          function me(a) {
            var b = a && a.nodeName && a.nodeName.toLowerCase();
            return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
          }
          function ne(a, b, c, d) {
            Eb(d);
            b = oe(b, "onChange");
            0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({
              event: c,
              listeners: b
            }));
          }
          var pe = null,
            qe = null;
          function re(a) {
            se(a, 0);
          }
          function te(a) {
            var b = ue(a);
            if (Wa(b)) return a;
          }
          function ve(a, b) {
            if ("change" === a) return b;
          }
          var we = false;
          if (ia) {
            var xe;
            if (ia) {
              var ye = "oninput" in document;
              if (!ye) {
                var ze = document.createElement("div");
                ze.setAttribute("oninput", "return;");
                ye = "function" === typeof ze.oninput;
              }
              xe = ye;
            } else xe = false;
            we = xe && (!document.documentMode || 9 < document.documentMode);
          }
          function Ae() {
            pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
          }
          function Be(a) {
            if ("value" === a.propertyName && te(qe)) {
              var b = [];
              ne(b, qe, a, xb(a));
              Jb(re, b);
            }
          }
          function Ce(a, b, c) {
            "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
          }
          function De(a) {
            if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
          }
          function Ee(a, b) {
            if ("click" === a) return te(b);
          }
          function Fe(a, b) {
            if ("input" === a || "change" === a) return te(b);
          }
          function Ge(a, b) {
            return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
          }
          var He = "function" === typeof Object.is ? Object.is : Ge;
          function Ie(a, b) {
            if (He(a, b)) return true;
            if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
            var c = Object.keys(a),
              d = Object.keys(b);
            if (c.length !== d.length) return false;
            for (d = 0; d < c.length; d++) {
              var e = c[d];
              if (!ja.call(b, e) || !He(a[e], b[e])) return false;
            }
            return true;
          }
          function Je(a) {
            for (; a && a.firstChild;) a = a.firstChild;
            return a;
          }
          function Ke(a, b) {
            var c = Je(a);
            a = 0;
            for (var d; c;) {
              if (3 === c.nodeType) {
                d = a + c.textContent.length;
                if (a <= b && d >= b) return {
                  node: c,
                  offset: b - a
                };
                a = d;
              }
              a: {
                for (; c;) {
                  if (c.nextSibling) {
                    c = c.nextSibling;
                    break a;
                  }
                  c = c.parentNode;
                }
                c = void 0;
              }
              c = Je(c);
            }
          }
          function Le(a, b) {
            return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
          }
          function Me() {
            for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement;) {
              try {
                var c = "string" === typeof b.contentWindow.location.href;
              } catch (d) {
                c = false;
              }
              if (c) a = b.contentWindow;else break;
              b = Xa(a.document);
            }
            return b;
          }
          function Ne(a) {
            var b = a && a.nodeName && a.nodeName.toLowerCase();
            return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
          }
          function Oe(a) {
            var b = Me(),
              c = a.focusedElem,
              d = a.selectionRange;
            if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
              if (null !== d && Ne(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
                a = a.getSelection();
                var e = c.textContent.length,
                  f = Math.min(d.start, e);
                d = void 0 === d.end ? f : Math.min(d.end, e);
                !a.extend && f > d && (e = d, d = f, f = e);
                e = Ke(c, f);
                var g = Ke(c, d);
                e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
              }
              b = [];
              for (a = c; a = a.parentNode;) 1 === a.nodeType && b.push({
                element: a,
                left: a.scrollLeft,
                top: a.scrollTop
              });
              "function" === typeof c.focus && c.focus();
              for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
            }
          }
          var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
            Qe = null,
            Re = null,
            Se = null,
            Te = false;
          function Ue(a, b, c) {
            var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
            Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = {
              start: d.selectionStart,
              end: d.selectionEnd
            } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
              anchorNode: d.anchorNode,
              anchorOffset: d.anchorOffset,
              focusNode: d.focusNode,
              focusOffset: d.focusOffset
            }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({
              event: b,
              listeners: d
            }), b.target = Qe)));
          }
          function Ve(a, b) {
            var c = {};
            c[a.toLowerCase()] = b.toLowerCase();
            c["Webkit" + a] = "webkit" + b;
            c["Moz" + a] = "moz" + b;
            return c;
          }
          var We = {
              animationend: Ve("Animation", "AnimationEnd"),
              animationiteration: Ve("Animation", "AnimationIteration"),
              animationstart: Ve("Animation", "AnimationStart"),
              transitionend: Ve("Transition", "TransitionEnd")
            },
            Xe = {},
            Ye = {};
          ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
          function Ze(a) {
            if (Xe[a]) return Xe[a];
            if (!We[a]) return a;
            var b = We[a],
              c;
            for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
            return a;
          }
          var $e = Ze("animationend"),
            af = Ze("animationiteration"),
            bf = Ze("animationstart"),
            cf = Ze("transitionend"),
            df = new Map(),
            ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
          function ff(a, b) {
            df.set(a, b);
            fa(b, [a]);
          }
          for (var gf = 0; gf < ef.length; gf++) {
            var hf = ef[gf],
              jf = hf.toLowerCase(),
              kf = hf[0].toUpperCase() + hf.slice(1);
            ff(jf, "on" + kf);
          }
          ff($e, "onAnimationEnd");
          ff(af, "onAnimationIteration");
          ff(bf, "onAnimationStart");
          ff("dblclick", "onDoubleClick");
          ff("focusin", "onFocus");
          ff("focusout", "onBlur");
          ff(cf, "onTransitionEnd");
          ha("onMouseEnter", ["mouseout", "mouseover"]);
          ha("onMouseLeave", ["mouseout", "mouseover"]);
          ha("onPointerEnter", ["pointerout", "pointerover"]);
          ha("onPointerLeave", ["pointerout", "pointerover"]);
          fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
          fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
          fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
          fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
          fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
          fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
          var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
            mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
          function nf(a, b, c) {
            var d = a.type || "unknown-event";
            a.currentTarget = c;
            Ub(d, b, void 0, a);
            a.currentTarget = null;
          }
          function se(a, b) {
            b = 0 !== (b & 4);
            for (var c = 0; c < a.length; c++) {
              var d = a[c],
                e = d.event;
              d = d.listeners;
              a: {
                var f = void 0;
                if (b) for (var g = d.length - 1; 0 <= g; g--) {
                  var h = d[g],
                    k = h.instance,
                    l = h.currentTarget;
                  h = h.listener;
                  if (k !== f && e.isPropagationStopped()) break a;
                  nf(e, h, l);
                  f = k;
                } else for (g = 0; g < d.length; g++) {
                  h = d[g];
                  k = h.instance;
                  l = h.currentTarget;
                  h = h.listener;
                  if (k !== f && e.isPropagationStopped()) break a;
                  nf(e, h, l);
                  f = k;
                }
              }
            }
            if (Qb) throw a = Rb, Qb = false, Rb = null, a;
          }
          function D(a, b) {
            var c = b[of];
            void 0 === c && (c = b[of] = new Set());
            var d = a + "__bubble";
            c.has(d) || (pf(b, a, 2, false), c.add(d));
          }
          function qf(a, b, c) {
            var d = 0;
            b && (d |= 4);
            pf(c, a, d, b);
          }
          var rf = "_reactListening" + Math.random().toString(36).slice(2);
          function sf(a) {
            if (!a[rf]) {
              a[rf] = true;
              da.forEach(function (b) {
                "selectionchange" !== b && (mf.has(b) || qf(b, false, a), qf(b, true, a));
              });
              var b = 9 === a.nodeType ? a : a.ownerDocument;
              null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
            }
          }
          function pf(a, b, c, d) {
            switch (jd(b)) {
              case 1:
                var e = ed;
                break;
              case 4:
                e = gd;
                break;
              default:
                e = fd;
            }
            c = e.bind(null, b, c, a);
            e = void 0;
            !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
            d ? void 0 !== e ? a.addEventListener(b, c, {
              capture: true,
              passive: e
            }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, {
              passive: e
            }) : a.addEventListener(b, c, false);
          }
          function hd(a, b, c, d, e) {
            var f = d;
            if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (;;) {
              if (null === d) return;
              var g = d.tag;
              if (3 === g || 4 === g) {
                var h = d.stateNode.containerInfo;
                if (h === e || 8 === h.nodeType && h.parentNode === e) break;
                if (4 === g) for (g = d.return; null !== g;) {
                  var k = g.tag;
                  if (3 === k || 4 === k) if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
                  g = g.return;
                }
                for (; null !== h;) {
                  g = Wc(h);
                  if (null === g) return;
                  k = g.tag;
                  if (5 === k || 6 === k) {
                    d = f = g;
                    continue a;
                  }
                  h = h.parentNode;
                }
              }
              d = d.return;
            }
            Jb(function () {
              var d = f,
                e = xb(c),
                g = [];
              a: {
                var h = df.get(a);
                if (void 0 !== h) {
                  var k = td,
                    n = a;
                  switch (a) {
                    case "keypress":
                      if (0 === od(c)) break a;
                    case "keydown":
                    case "keyup":
                      k = Rd;
                      break;
                    case "focusin":
                      n = "focus";
                      k = Fd;
                      break;
                    case "focusout":
                      n = "blur";
                      k = Fd;
                      break;
                    case "beforeblur":
                    case "afterblur":
                      k = Fd;
                      break;
                    case "click":
                      if (2 === c.button) break a;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                      k = Bd;
                      break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                      k = Dd;
                      break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                      k = Vd;
                      break;
                    case $e:
                    case af:
                    case bf:
                      k = Hd;
                      break;
                    case cf:
                      k = Xd;
                      break;
                    case "scroll":
                      k = vd;
                      break;
                    case "wheel":
                      k = Zd;
                      break;
                    case "copy":
                    case "cut":
                    case "paste":
                      k = Jd;
                      break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                      k = Td;
                  }
                  var t = 0 !== (b & 4),
                    J = !t && "scroll" === a,
                    x = t ? null !== h ? h + "Capture" : null : h;
                  t = [];
                  for (var w = d, u; null !== w;) {
                    u = w;
                    var F = u.stateNode;
                    5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
                    if (J) break;
                    w = w.return;
                  }
                  0 < t.length && (h = new k(h, n, null, c, e), g.push({
                    event: h,
                    listeners: t
                  }));
                }
              }
              if (0 === (b & 7)) {
                a: {
                  h = "mouseover" === a || "pointerover" === a;
                  k = "mouseout" === a || "pointerout" === a;
                  if (h && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
                  if (k || h) {
                    h = e.window === e ? e : (h = e.ownerDocument) ? h.defaultView || h.parentWindow : window;
                    if (k) {
                      if (n = c.relatedTarget || c.toElement, k = d, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
                    } else k = null, n = d;
                    if (k !== n) {
                      t = Bd;
                      F = "onMouseLeave";
                      x = "onMouseEnter";
                      w = "mouse";
                      if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                      J = null == k ? h : ue(k);
                      u = null == n ? h : ue(n);
                      h = new t(F, w + "leave", k, c, e);
                      h.target = J;
                      h.relatedTarget = u;
                      F = null;
                      Wc(e) === d && (t = new t(x, w + "enter", n, c, e), t.target = u, t.relatedTarget = J, F = t);
                      J = F;
                      if (k && n) b: {
                        t = k;
                        x = n;
                        w = 0;
                        for (u = t; u; u = vf(u)) w++;
                        u = 0;
                        for (F = x; F; F = vf(F)) u++;
                        for (; 0 < w - u;) t = vf(t), w--;
                        for (; 0 < u - w;) x = vf(x), u--;
                        for (; w--;) {
                          if (t === x || null !== x && t === x.alternate) break b;
                          t = vf(t);
                          x = vf(x);
                        }
                        t = null;
                      } else t = null;
                      null !== k && wf(g, h, k, t, false);
                      null !== n && null !== J && wf(g, J, n, t, true);
                    }
                  }
                }
                a: {
                  h = d ? ue(d) : window;
                  k = h.nodeName && h.nodeName.toLowerCase();
                  if ("select" === k || "input" === k && "file" === h.type) var na = ve;else if (me(h)) {
                    if (we) na = Fe;else {
                      na = De;
                      var xa = Ce;
                    }
                  } else (k = h.nodeName) && "input" === k.toLowerCase() && ("checkbox" === h.type || "radio" === h.type) && (na = Ee);
                  if (na && (na = na(a, d))) {
                    ne(g, na, c, e);
                    break a;
                  }
                  xa && xa(a, h, d);
                  "focusout" === a && (xa = h._wrapperState) && xa.controlled && "number" === h.type && cb(h, "number", h.value);
                }
                xa = d ? ue(d) : window;
                switch (a) {
                  case "focusin":
                    if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d, Se = null;
                    break;
                  case "focusout":
                    Se = Re = Qe = null;
                    break;
                  case "mousedown":
                    Te = true;
                    break;
                  case "contextmenu":
                  case "mouseup":
                  case "dragend":
                    Te = false;
                    Ue(g, c, e);
                    break;
                  case "selectionchange":
                    if (Pe) break;
                  case "keydown":
                  case "keyup":
                    Ue(g, c, e);
                }
                var $a;
                if (ae) b: {
                  switch (a) {
                    case "compositionstart":
                      var ba = "onCompositionStart";
                      break b;
                    case "compositionend":
                      ba = "onCompositionEnd";
                      break b;
                    case "compositionupdate":
                      ba = "onCompositionUpdate";
                      break b;
                  }
                  ba = void 0;
                } else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
                ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e), g.push({
                  event: ba,
                  listeners: xa
                }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
                if ($a = ce ? je(a, c) : ke(a, c)) d = oe(d, "onBeforeInput"), 0 < d.length && (e = new Ld("onBeforeInput", "beforeinput", null, c, e), g.push({
                  event: e,
                  listeners: d
                }), e.data = $a);
              }
              se(g, b);
            });
          }
          function tf(a, b, c) {
            return {
              instance: a,
              listener: b,
              currentTarget: c
            };
          }
          function oe(a, b) {
            for (var c = b + "Capture", d = []; null !== a;) {
              var e = a,
                f = e.stateNode;
              5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
              a = a.return;
            }
            return d;
          }
          function vf(a) {
            if (null === a) return null;
            do a = a.return; while (a && 5 !== a.tag);
            return a ? a : null;
          }
          function wf(a, b, c, d, e) {
            for (var f = b._reactName, g = []; null !== c && c !== d;) {
              var h = c,
                k = h.alternate,
                l = h.stateNode;
              if (null !== k && k === d) break;
              5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
              c = c.return;
            }
            0 !== g.length && a.push({
              event: b,
              listeners: g
            });
          }
          var xf = /\r\n?/g,
            yf = /\u0000|\uFFFD/g;
          function zf(a) {
            return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
          }
          function Af(a, b, c) {
            b = zf(b);
            if (zf(a) !== b && c) throw Error(p(425));
          }
          function Bf() {}
          var Cf = null,
            Df = null;
          function Ef(a, b) {
            return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
          }
          var Ff = "function" === typeof setTimeout ? setTimeout : void 0,
            Gf = "function" === typeof clearTimeout ? clearTimeout : void 0,
            Hf = "function" === typeof Promise ? Promise : void 0,
            Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function (a) {
              return Hf.resolve(null).then(a).catch(If);
            } : Ff;
          function If(a) {
            setTimeout(function () {
              throw a;
            });
          }
          function Kf(a, b) {
            var c = b,
              d = 0;
            do {
              var e = c.nextSibling;
              a.removeChild(c);
              if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
                if (0 === d) {
                  a.removeChild(e);
                  bd(b);
                  return;
                }
                d--;
              } else "$" !== c && "$?" !== c && "$!" !== c || d++;
              c = e;
            } while (c);
            bd(b);
          }
          function Lf(a) {
            for (; null != a; a = a.nextSibling) {
              var b = a.nodeType;
              if (1 === b || 3 === b) break;
              if (8 === b) {
                b = a.data;
                if ("$" === b || "$!" === b || "$?" === b) break;
                if ("/$" === b) return null;
              }
            }
            return a;
          }
          function Mf(a) {
            a = a.previousSibling;
            for (var b = 0; a;) {
              if (8 === a.nodeType) {
                var c = a.data;
                if ("$" === c || "$!" === c || "$?" === c) {
                  if (0 === b) return a;
                  b--;
                } else "/$" === c && b++;
              }
              a = a.previousSibling;
            }
            return null;
          }
          var Nf = Math.random().toString(36).slice(2),
            Of = "__reactFiber$" + Nf,
            Pf = "__reactProps$" + Nf,
            uf = "__reactContainer$" + Nf,
            of = "__reactEvents$" + Nf,
            Qf = "__reactListeners$" + Nf,
            Rf = "__reactHandles$" + Nf;
          function Wc(a) {
            var b = a[Of];
            if (b) return b;
            for (var c = a.parentNode; c;) {
              if (b = c[uf] || c[Of]) {
                c = b.alternate;
                if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a;) {
                  if (c = a[Of]) return c;
                  a = Mf(a);
                }
                return b;
              }
              a = c;
              c = a.parentNode;
            }
            return null;
          }
          function Cb(a) {
            a = a[Of] || a[uf];
            return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
          }
          function ue(a) {
            if (5 === a.tag || 6 === a.tag) return a.stateNode;
            throw Error(p(33));
          }
          function Db(a) {
            return a[Pf] || null;
          }
          var Sf = [],
            Tf = -1;
          function Uf(a) {
            return {
              current: a
            };
          }
          function E(a) {
            0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
          }
          function G(a, b) {
            Tf++;
            Sf[Tf] = a.current;
            a.current = b;
          }
          var Vf = {},
            H = Uf(Vf),
            Wf = Uf(false),
            Xf = Vf;
          function Yf(a, b) {
            var c = a.type.contextTypes;
            if (!c) return Vf;
            var d = a.stateNode;
            if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
            var e = {},
              f;
            for (f in c) e[f] = b[f];
            d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
            return e;
          }
          function Zf(a) {
            a = a.childContextTypes;
            return null !== a && void 0 !== a;
          }
          function $f() {
            E(Wf);
            E(H);
          }
          function ag(a, b, c) {
            if (H.current !== Vf) throw Error(p(168));
            G(H, b);
            G(Wf, c);
          }
          function bg(a, b, c) {
            var d = a.stateNode;
            b = b.childContextTypes;
            if ("function" !== typeof d.getChildContext) return c;
            d = d.getChildContext();
            for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
            return A({}, c, d);
          }
          function cg(a) {
            a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
            Xf = H.current;
            G(H, a);
            G(Wf, Wf.current);
            return true;
          }
          function dg(a, b, c) {
            var d = a.stateNode;
            if (!d) throw Error(p(169));
            c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
            G(Wf, c);
          }
          var eg = null,
            fg = false,
            gg = false;
          function hg(a) {
            null === eg ? eg = [a] : eg.push(a);
          }
          function ig(a) {
            fg = true;
            hg(a);
          }
          function jg() {
            if (!gg && null !== eg) {
              gg = true;
              var a = 0,
                b = C;
              try {
                var c = eg;
                for (C = 1; a < c.length; a++) {
                  var d = c[a];
                  do d = d(!0); while (null !== d);
                }
                eg = null;
                fg = !1;
              } catch (e) {
                throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
              } finally {
                C = b, gg = false;
              }
            }
            return null;
          }
          var kg = [],
            lg = 0,
            mg = null,
            ng = 0,
            og = [],
            pg = 0,
            qg = null,
            rg = 1,
            sg = "";
          function tg(a, b) {
            kg[lg++] = ng;
            kg[lg++] = mg;
            mg = a;
            ng = b;
          }
          function ug(a, b, c) {
            og[pg++] = rg;
            og[pg++] = sg;
            og[pg++] = qg;
            qg = a;
            var d = rg;
            a = sg;
            var e = 32 - oc(d) - 1;
            d &= ~(1 << e);
            c += 1;
            var f = 32 - oc(b) + e;
            if (30 < f) {
              var g = e - e % 5;
              f = (d & (1 << g) - 1).toString(32);
              d >>= g;
              e -= g;
              rg = 1 << 32 - oc(b) + e | c << e | d;
              sg = f + a;
            } else rg = 1 << f | c << e | d, sg = a;
          }
          function vg(a) {
            null !== a.return && (tg(a, 1), ug(a, 1, 0));
          }
          function wg(a) {
            for (; a === mg;) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
            for (; a === qg;) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
          }
          var xg = null,
            yg = null,
            I = false,
            zg = null;
          function Ag(a, b) {
            var c = Bg(5, null, null, 0);
            c.elementType = "DELETED";
            c.stateNode = b;
            c.return = a;
            b = a.deletions;
            null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
          }
          function Cg(a, b) {
            switch (a.tag) {
              case 5:
                var c = a.type;
                b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
                return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
              case 6:
                return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
              case 13:
                return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? {
                  id: rg,
                  overflow: sg
                } : null, a.memoizedState = {
                  dehydrated: b,
                  treeContext: c,
                  retryLane: 1073741824
                }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
              default:
                return false;
            }
          }
          function Dg(a) {
            return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
          }
          function Eg(a) {
            if (I) {
              var b = yg;
              if (b) {
                var c = b;
                if (!Cg(a, b)) {
                  if (Dg(a)) throw Error(p(418));
                  b = Lf(c.nextSibling);
                  var d = xg;
                  b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
                }
              } else {
                if (Dg(a)) throw Error(p(418));
                a.flags = a.flags & -4097 | 2;
                I = false;
                xg = a;
              }
            }
          }
          function Fg(a) {
            for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) a = a.return;
            xg = a;
          }
          function Gg(a) {
            if (a !== xg) return false;
            if (!I) return Fg(a), I = true, false;
            var b;
            (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
            if (b && (b = yg)) {
              if (Dg(a)) throw Hg(), Error(p(418));
              for (; b;) Ag(a, b), b = Lf(b.nextSibling);
            }
            Fg(a);
            if (13 === a.tag) {
              a = a.memoizedState;
              a = null !== a ? a.dehydrated : null;
              if (!a) throw Error(p(317));
              a: {
                a = a.nextSibling;
                for (b = 0; a;) {
                  if (8 === a.nodeType) {
                    var c = a.data;
                    if ("/$" === c) {
                      if (0 === b) {
                        yg = Lf(a.nextSibling);
                        break a;
                      }
                      b--;
                    } else "$" !== c && "$!" !== c && "$?" !== c || b++;
                  }
                  a = a.nextSibling;
                }
                yg = null;
              }
            } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
            return true;
          }
          function Hg() {
            for (var a = yg; a;) a = Lf(a.nextSibling);
          }
          function Ig() {
            yg = xg = null;
            I = false;
          }
          function Jg(a) {
            null === zg ? zg = [a] : zg.push(a);
          }
          var Kg = ua.ReactCurrentBatchConfig;
          function Lg(a, b) {
            if (a && a.defaultProps) {
              b = A({}, b);
              a = a.defaultProps;
              for (var c in a) void 0 === b[c] && (b[c] = a[c]);
              return b;
            }
            return b;
          }
          var Mg = Uf(null),
            Ng = null,
            Og = null,
            Pg = null;
          function Qg() {
            Pg = Og = Ng = null;
          }
          function Rg(a) {
            var b = Mg.current;
            E(Mg);
            a._currentValue = b;
          }
          function Sg(a, b, c) {
            for (; null !== a;) {
              var d = a.alternate;
              (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
              if (a === c) break;
              a = a.return;
            }
          }
          function Tg(a, b) {
            Ng = a;
            Pg = Og = null;
            a = a.dependencies;
            null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (Ug = true), a.firstContext = null);
          }
          function Vg(a) {
            var b = a._currentValue;
            if (Pg !== a) if (a = {
              context: a,
              memoizedValue: b,
              next: null
            }, null === Og) {
              if (null === Ng) throw Error(p(308));
              Og = a;
              Ng.dependencies = {
                lanes: 0,
                firstContext: a
              };
            } else Og = Og.next = a;
            return b;
          }
          var Wg = null;
          function Xg(a) {
            null === Wg ? Wg = [a] : Wg.push(a);
          }
          function Yg(a, b, c, d) {
            var e = b.interleaved;
            null === e ? (c.next = c, Xg(b)) : (c.next = e.next, e.next = c);
            b.interleaved = c;
            return Zg(a, d);
          }
          function Zg(a, b) {
            a.lanes |= b;
            var c = a.alternate;
            null !== c && (c.lanes |= b);
            c = a;
            for (a = a.return; null !== a;) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
            return 3 === c.tag ? c.stateNode : null;
          }
          var $g = false;
          function ah(a) {
            a.updateQueue = {
              baseState: a.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: {
                pending: null,
                interleaved: null,
                lanes: 0
              },
              effects: null
            };
          }
          function bh(a, b) {
            a = a.updateQueue;
            b.updateQueue === a && (b.updateQueue = {
              baseState: a.baseState,
              firstBaseUpdate: a.firstBaseUpdate,
              lastBaseUpdate: a.lastBaseUpdate,
              shared: a.shared,
              effects: a.effects
            });
          }
          function ch(a, b) {
            return {
              eventTime: a,
              lane: b,
              tag: 0,
              payload: null,
              callback: null,
              next: null
            };
          }
          function dh(a, b, c) {
            var d = a.updateQueue;
            if (null === d) return null;
            d = d.shared;
            if (0 !== (K & 2)) {
              var e = d.pending;
              null === e ? b.next = b : (b.next = e.next, e.next = b);
              d.pending = b;
              return Zg(a, c);
            }
            e = d.interleaved;
            null === e ? (b.next = b, Xg(d)) : (b.next = e.next, e.next = b);
            d.interleaved = b;
            return Zg(a, c);
          }
          function eh(a, b, c) {
            b = b.updateQueue;
            if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
              var d = b.lanes;
              d &= a.pendingLanes;
              c |= d;
              b.lanes = c;
              Cc(a, c);
            }
          }
          function fh(a, b) {
            var c = a.updateQueue,
              d = a.alternate;
            if (null !== d && (d = d.updateQueue, c === d)) {
              var e = null,
                f = null;
              c = c.firstBaseUpdate;
              if (null !== c) {
                do {
                  var g = {
                    eventTime: c.eventTime,
                    lane: c.lane,
                    tag: c.tag,
                    payload: c.payload,
                    callback: c.callback,
                    next: null
                  };
                  null === f ? e = f = g : f = f.next = g;
                  c = c.next;
                } while (null !== c);
                null === f ? e = f = b : f = f.next = b;
              } else e = f = b;
              c = {
                baseState: d.baseState,
                firstBaseUpdate: e,
                lastBaseUpdate: f,
                shared: d.shared,
                effects: d.effects
              };
              a.updateQueue = c;
              return;
            }
            a = c.lastBaseUpdate;
            null === a ? c.firstBaseUpdate = b : a.next = b;
            c.lastBaseUpdate = b;
          }
          function gh(a, b, c, d) {
            var e = a.updateQueue;
            $g = false;
            var f = e.firstBaseUpdate,
              g = e.lastBaseUpdate,
              h = e.shared.pending;
            if (null !== h) {
              e.shared.pending = null;
              var k = h,
                l = k.next;
              k.next = null;
              null === g ? f = l : g.next = l;
              g = k;
              var m = a.alternate;
              null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
            }
            if (null !== f) {
              var q = e.baseState;
              g = 0;
              m = l = k = null;
              h = f;
              do {
                var r = h.lane,
                  y = h.eventTime;
                if ((d & r) === r) {
                  null !== m && (m = m.next = {
                    eventTime: y,
                    lane: 0,
                    tag: h.tag,
                    payload: h.payload,
                    callback: h.callback,
                    next: null
                  });
                  a: {
                    var n = a,
                      t = h;
                    r = b;
                    y = c;
                    switch (t.tag) {
                      case 1:
                        n = t.payload;
                        if ("function" === typeof n) {
                          q = n.call(y, q, r);
                          break a;
                        }
                        q = n;
                        break a;
                      case 3:
                        n.flags = n.flags & -65537 | 128;
                      case 0:
                        n = t.payload;
                        r = "function" === typeof n ? n.call(y, q, r) : n;
                        if (null === r || void 0 === r) break a;
                        q = A({}, q, r);
                        break a;
                      case 2:
                        $g = true;
                    }
                  }
                  null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
                } else y = {
                  eventTime: y,
                  lane: r,
                  tag: h.tag,
                  payload: h.payload,
                  callback: h.callback,
                  next: null
                }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
                h = h.next;
                if (null === h) if (h = e.shared.pending, null === h) break;else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
              } while (1);
              null === m && (k = q);
              e.baseState = k;
              e.firstBaseUpdate = l;
              e.lastBaseUpdate = m;
              b = e.shared.interleaved;
              if (null !== b) {
                e = b;
                do g |= e.lane, e = e.next; while (e !== b);
              } else null === f && (e.shared.lanes = 0);
              hh |= g;
              a.lanes = g;
              a.memoizedState = q;
            }
          }
          function ih(a, b, c) {
            a = b.effects;
            b.effects = null;
            if (null !== a) for (b = 0; b < a.length; b++) {
              var d = a[b],
                e = d.callback;
              if (null !== e) {
                d.callback = null;
                d = c;
                if ("function" !== typeof e) throw Error(p(191, e));
                e.call(d);
              }
            }
          }
          var jh = new aa.Component().refs;
          function kh(a, b, c, d) {
            b = a.memoizedState;
            c = c(d, b);
            c = null === c || void 0 === c ? b : A({}, b, c);
            a.memoizedState = c;
            0 === a.lanes && (a.updateQueue.baseState = c);
          }
          var nh = {
            isMounted: function (a) {
              return (a = a._reactInternals) ? Vb(a) === a : false;
            },
            enqueueSetState: function (a, b, c) {
              a = a._reactInternals;
              var d = L(),
                e = lh(a),
                f = ch(d, e);
              f.payload = b;
              void 0 !== c && null !== c && (f.callback = c);
              b = dh(a, f, e);
              null !== b && (mh(b, a, e, d), eh(b, a, e));
            },
            enqueueReplaceState: function (a, b, c) {
              a = a._reactInternals;
              var d = L(),
                e = lh(a),
                f = ch(d, e);
              f.tag = 1;
              f.payload = b;
              void 0 !== c && null !== c && (f.callback = c);
              b = dh(a, f, e);
              null !== b && (mh(b, a, e, d), eh(b, a, e));
            },
            enqueueForceUpdate: function (a, b) {
              a = a._reactInternals;
              var c = L(),
                d = lh(a),
                e = ch(c, d);
              e.tag = 2;
              void 0 !== b && null !== b && (e.callback = b);
              b = dh(a, e, d);
              null !== b && (mh(b, a, d, c), eh(b, a, d));
            }
          };
          function oh(a, b, c, d, e, f, g) {
            a = a.stateNode;
            return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
          }
          function ph(a, b, c) {
            var d = false,
              e = Vf;
            var f = b.contextType;
            "object" === typeof f && null !== f ? f = Vg(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
            b = new b(c, f);
            a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
            b.updater = nh;
            a.stateNode = b;
            b._reactInternals = a;
            d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
            return b;
          }
          function qh(a, b, c, d) {
            a = b.state;
            "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
            "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
            b.state !== a && nh.enqueueReplaceState(b, b.state, null);
          }
          function rh(a, b, c, d) {
            var e = a.stateNode;
            e.props = c;
            e.state = a.memoizedState;
            e.refs = jh;
            ah(a);
            var f = b.contextType;
            "object" === typeof f && null !== f ? e.context = Vg(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
            e.state = a.memoizedState;
            f = b.getDerivedStateFromProps;
            "function" === typeof f && (kh(a, b, f, c), e.state = a.memoizedState);
            "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && nh.enqueueReplaceState(e, e.state, null), gh(a, c, e, d), e.state = a.memoizedState);
            "function" === typeof e.componentDidMount && (a.flags |= 4194308);
          }
          function sh(a, b, c) {
            a = c.ref;
            if (null !== a && "function" !== typeof a && "object" !== typeof a) {
              if (c._owner) {
                c = c._owner;
                if (c) {
                  if (1 !== c.tag) throw Error(p(309));
                  var d = c.stateNode;
                }
                if (!d) throw Error(p(147, a));
                var e = d,
                  f = "" + a;
                if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
                b = function (a) {
                  var b = e.refs;
                  b === jh && (b = e.refs = {});
                  null === a ? delete b[f] : b[f] = a;
                };
                b._stringRef = f;
                return b;
              }
              if ("string" !== typeof a) throw Error(p(284));
              if (!c._owner) throw Error(p(290, a));
            }
            return a;
          }
          function th(a, b) {
            a = Object.prototype.toString.call(b);
            throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
          }
          function uh(a) {
            var b = a._init;
            return b(a._payload);
          }
          function vh(a) {
            function b(b, c) {
              if (a) {
                var d = b.deletions;
                null === d ? (b.deletions = [c], b.flags |= 16) : d.push(c);
              }
            }
            function c(c, d) {
              if (!a) return null;
              for (; null !== d;) b(c, d), d = d.sibling;
              return null;
            }
            function d(a, b) {
              for (a = new Map(); null !== b;) null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
              return a;
            }
            function e(a, b) {
              a = wh(a, b);
              a.index = 0;
              a.sibling = null;
              return a;
            }
            function f(b, c, d) {
              b.index = d;
              if (!a) return b.flags |= 1048576, c;
              d = b.alternate;
              if (null !== d) return d = d.index, d < c ? (b.flags |= 2, c) : d;
              b.flags |= 2;
              return c;
            }
            function g(b) {
              a && null === b.alternate && (b.flags |= 2);
              return b;
            }
            function h(a, b, c, d) {
              if (null === b || 6 !== b.tag) return b = xh(c, a.mode, d), b.return = a, b;
              b = e(b, c);
              b.return = a;
              return b;
            }
            function k(a, b, c, d) {
              var f = c.type;
              if (f === ya) return m(a, b, c.props.children, d, c.key);
              if (null !== b && (b.elementType === f || "object" === typeof f && null !== f && f.$$typeof === Ha && uh(f) === b.type)) return d = e(b, c.props), d.ref = sh(a, b, c), d.return = a, d;
              d = yh(c.type, c.key, c.props, null, a.mode, d);
              d.ref = sh(a, b, c);
              d.return = a;
              return d;
            }
            function l(a, b, c, d) {
              if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = zh(c, a.mode, d), b.return = a, b;
              b = e(b, c.children || []);
              b.return = a;
              return b;
            }
            function m(a, b, c, d, f) {
              if (null === b || 7 !== b.tag) return b = Ah(c, a.mode, d, f), b.return = a, b;
              b = e(b, c);
              b.return = a;
              return b;
            }
            function q(a, b, c) {
              if ("string" === typeof b && "" !== b || "number" === typeof b) return b = xh("" + b, a.mode, c), b.return = a, b;
              if ("object" === typeof b && null !== b) {
                switch (b.$$typeof) {
                  case va:
                    return c = yh(b.type, b.key, b.props, null, a.mode, c), c.ref = sh(a, null, b), c.return = a, c;
                  case wa:
                    return b = zh(b, a.mode, c), b.return = a, b;
                  case Ha:
                    var d = b._init;
                    return q(a, d(b._payload), c);
                }
                if (eb(b) || Ka(b)) return b = Ah(b, a.mode, c, null), b.return = a, b;
                th(a, b);
              }
              return null;
            }
            function r(a, b, c, d) {
              var e = null !== b ? b.key : null;
              if ("string" === typeof c && "" !== c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);
              if ("object" === typeof c && null !== c) {
                switch (c.$$typeof) {
                  case va:
                    return c.key === e ? k(a, b, c, d) : null;
                  case wa:
                    return c.key === e ? l(a, b, c, d) : null;
                  case Ha:
                    return e = c._init, r(a, b, e(c._payload), d);
                }
                if (eb(c) || Ka(c)) return null !== e ? null : m(a, b, c, d, null);
                th(a, c);
              }
              return null;
            }
            function y(a, b, c, d, e) {
              if ("string" === typeof d && "" !== d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);
              if ("object" === typeof d && null !== d) {
                switch (d.$$typeof) {
                  case va:
                    return a = a.get(null === d.key ? c : d.key) || null, k(b, a, d, e);
                  case wa:
                    return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);
                  case Ha:
                    var f = d._init;
                    return y(a, b, c, f(d._payload), e);
                }
                if (eb(d) || Ka(d)) return a = a.get(c) || null, m(b, a, d, e, null);
                th(b, d);
              }
              return null;
            }
            function n(e, g, h, k) {
              for (var l = null, m = null, u = g, w = g = 0, x = null; null !== u && w < h.length; w++) {
                u.index > w ? (x = u, u = null) : x = u.sibling;
                var n = r(e, u, h[w], k);
                if (null === n) {
                  null === u && (u = x);
                  break;
                }
                a && u && null === n.alternate && b(e, u);
                g = f(n, g, w);
                null === m ? l = n : m.sibling = n;
                m = n;
                u = x;
              }
              if (w === h.length) return c(e, u), I && tg(e, w), l;
              if (null === u) {
                for (; w < h.length; w++) u = q(e, h[w], k), null !== u && (g = f(u, g, w), null === m ? l = u : m.sibling = u, m = u);
                I && tg(e, w);
                return l;
              }
              for (u = d(e, u); w < h.length; w++) x = y(u, e, w, h[w], k), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g = f(x, g, w), null === m ? l = x : m.sibling = x, m = x);
              a && u.forEach(function (a) {
                return b(e, a);
              });
              I && tg(e, w);
              return l;
            }
            function t(e, g, h, k) {
              var l = Ka(h);
              if ("function" !== typeof l) throw Error(p(150));
              h = l.call(h);
              if (null == h) throw Error(p(151));
              for (var u = l = null, m = g, w = g = 0, x = null, n = h.next(); null !== m && !n.done; w++, n = h.next()) {
                m.index > w ? (x = m, m = null) : x = m.sibling;
                var t = r(e, m, n.value, k);
                if (null === t) {
                  null === m && (m = x);
                  break;
                }
                a && m && null === t.alternate && b(e, m);
                g = f(t, g, w);
                null === u ? l = t : u.sibling = t;
                u = t;
                m = x;
              }
              if (n.done) return c(e, m), I && tg(e, w), l;
              if (null === m) {
                for (; !n.done; w++, n = h.next()) n = q(e, n.value, k), null !== n && (g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
                I && tg(e, w);
                return l;
              }
              for (m = d(e, m); !n.done; w++, n = h.next()) n = y(m, e, w, n.value, k), null !== n && (a && null !== n.alternate && m.delete(null === n.key ? w : n.key), g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
              a && m.forEach(function (a) {
                return b(e, a);
              });
              I && tg(e, w);
              return l;
            }
            function J(a, d, f, h) {
              "object" === typeof f && null !== f && f.type === ya && null === f.key && (f = f.props.children);
              if ("object" === typeof f && null !== f) {
                switch (f.$$typeof) {
                  case va:
                    a: {
                      for (var k = f.key, l = d; null !== l;) {
                        if (l.key === k) {
                          k = f.type;
                          if (k === ya) {
                            if (7 === l.tag) {
                              c(a, l.sibling);
                              d = e(l, f.props.children);
                              d.return = a;
                              a = d;
                              break a;
                            }
                          } else if (l.elementType === k || "object" === typeof k && null !== k && k.$$typeof === Ha && uh(k) === l.type) {
                            c(a, l.sibling);
                            d = e(l, f.props);
                            d.ref = sh(a, l, f);
                            d.return = a;
                            a = d;
                            break a;
                          }
                          c(a, l);
                          break;
                        } else b(a, l);
                        l = l.sibling;
                      }
                      f.type === ya ? (d = Ah(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = yh(f.type, f.key, f.props, null, a.mode, h), h.ref = sh(a, d, f), h.return = a, a = h);
                    }
                    return g(a);
                  case wa:
                    a: {
                      for (l = f.key; null !== d;) {
                        if (d.key === l) {
                          if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                            c(a, d.sibling);
                            d = e(d, f.children || []);
                            d.return = a;
                            a = d;
                            break a;
                          } else {
                            c(a, d);
                            break;
                          }
                        } else b(a, d);
                        d = d.sibling;
                      }
                      d = zh(f, a.mode, h);
                      d.return = a;
                      a = d;
                    }
                    return g(a);
                  case Ha:
                    return l = f._init, J(a, d, l(f._payload), h);
                }
                if (eb(f)) return n(a, d, f, h);
                if (Ka(f)) return t(a, d, f, h);
                th(a, f);
              }
              return "string" === typeof f && "" !== f || "number" === typeof f ? (f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = xh(f, a.mode, h), d.return = a, a = d), g(a)) : c(a, d);
            }
            return J;
          }
          var Bh = vh(true),
            Ch = vh(false),
            Dh = {},
            Eh = Uf(Dh),
            Fh = Uf(Dh),
            Gh = Uf(Dh);
          function Hh(a) {
            if (a === Dh) throw Error(p(174));
            return a;
          }
          function Ih(a, b) {
            G(Gh, b);
            G(Fh, a);
            G(Eh, Dh);
            a = b.nodeType;
            switch (a) {
              case 9:
              case 11:
                b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
                break;
              default:
                a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
            }
            E(Eh);
            G(Eh, b);
          }
          function Jh() {
            E(Eh);
            E(Fh);
            E(Gh);
          }
          function Kh(a) {
            Hh(Gh.current);
            var b = Hh(Eh.current);
            var c = lb(b, a.type);
            b !== c && (G(Fh, a), G(Eh, c));
          }
          function Lh(a) {
            Fh.current === a && (E(Eh), E(Fh));
          }
          var M = Uf(0);
          function Mh(a) {
            for (var b = a; null !== b;) {
              if (13 === b.tag) {
                var c = b.memoizedState;
                if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
              } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
                if (0 !== (b.flags & 128)) return b;
              } else if (null !== b.child) {
                b.child.return = b;
                b = b.child;
                continue;
              }
              if (b === a) break;
              for (; null === b.sibling;) {
                if (null === b.return || b.return === a) return null;
                b = b.return;
              }
              b.sibling.return = b.return;
              b = b.sibling;
            }
            return null;
          }
          var Nh = [];
          function Oh() {
            for (var a = 0; a < Nh.length; a++) Nh[a]._workInProgressVersionPrimary = null;
            Nh.length = 0;
          }
          var Ph = ua.ReactCurrentDispatcher,
            Qh = ua.ReactCurrentBatchConfig,
            Rh = 0,
            N = null,
            O = null,
            P = null,
            Sh = false,
            Th = false,
            Uh = 0,
            Vh = 0;
          function Q() {
            throw Error(p(321));
          }
          function Wh(a, b) {
            if (null === b) return false;
            for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
            return true;
          }
          function Xh(a, b, c, d, e, f) {
            Rh = f;
            N = b;
            b.memoizedState = null;
            b.updateQueue = null;
            b.lanes = 0;
            Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
            a = c(d, e);
            if (Th) {
              f = 0;
              do {
                Th = false;
                Uh = 0;
                if (25 <= f) throw Error(p(301));
                f += 1;
                P = O = null;
                b.updateQueue = null;
                Ph.current = $h;
                a = c(d, e);
              } while (Th);
            }
            Ph.current = ai;
            b = null !== O && null !== O.next;
            Rh = 0;
            P = O = N = null;
            Sh = false;
            if (b) throw Error(p(300));
            return a;
          }
          function bi() {
            var a = 0 !== Uh;
            Uh = 0;
            return a;
          }
          function ci() {
            var a = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            null === P ? N.memoizedState = P = a : P = P.next = a;
            return P;
          }
          function di() {
            if (null === O) {
              var a = N.alternate;
              a = null !== a ? a.memoizedState : null;
            } else a = O.next;
            var b = null === P ? N.memoizedState : P.next;
            if (null !== b) P = b, O = a;else {
              if (null === a) throw Error(p(310));
              O = a;
              a = {
                memoizedState: O.memoizedState,
                baseState: O.baseState,
                baseQueue: O.baseQueue,
                queue: O.queue,
                next: null
              };
              null === P ? N.memoizedState = P = a : P = P.next = a;
            }
            return P;
          }
          function ei(a, b) {
            return "function" === typeof b ? b(a) : b;
          }
          function fi(a) {
            var b = di(),
              c = b.queue;
            if (null === c) throw Error(p(311));
            c.lastRenderedReducer = a;
            var d = O,
              e = d.baseQueue,
              f = c.pending;
            if (null !== f) {
              if (null !== e) {
                var g = e.next;
                e.next = f.next;
                f.next = g;
              }
              d.baseQueue = e = f;
              c.pending = null;
            }
            if (null !== e) {
              f = e.next;
              d = d.baseState;
              var h = g = null,
                k = null,
                l = f;
              do {
                var m = l.lane;
                if ((Rh & m) === m) null !== k && (k = k.next = {
                  lane: 0,
                  action: l.action,
                  hasEagerState: l.hasEagerState,
                  eagerState: l.eagerState,
                  next: null
                }), d = l.hasEagerState ? l.eagerState : a(d, l.action);else {
                  var q = {
                    lane: m,
                    action: l.action,
                    hasEagerState: l.hasEagerState,
                    eagerState: l.eagerState,
                    next: null
                  };
                  null === k ? (h = k = q, g = d) : k = k.next = q;
                  N.lanes |= m;
                  hh |= m;
                }
                l = l.next;
              } while (null !== l && l !== f);
              null === k ? g = d : k.next = h;
              He(d, b.memoizedState) || (Ug = true);
              b.memoizedState = d;
              b.baseState = g;
              b.baseQueue = k;
              c.lastRenderedState = d;
            }
            a = c.interleaved;
            if (null !== a) {
              e = a;
              do f = e.lane, N.lanes |= f, hh |= f, e = e.next; while (e !== a);
            } else null === e && (c.lanes = 0);
            return [b.memoizedState, c.dispatch];
          }
          function gi(a) {
            var b = di(),
              c = b.queue;
            if (null === c) throw Error(p(311));
            c.lastRenderedReducer = a;
            var d = c.dispatch,
              e = c.pending,
              f = b.memoizedState;
            if (null !== e) {
              c.pending = null;
              var g = e = e.next;
              do f = a(f, g.action), g = g.next; while (g !== e);
              He(f, b.memoizedState) || (Ug = true);
              b.memoizedState = f;
              null === b.baseQueue && (b.baseState = f);
              c.lastRenderedState = f;
            }
            return [f, d];
          }
          function hi() {}
          function ii(a, b) {
            var c = N,
              d = di(),
              e = b(),
              f = !He(d.memoizedState, e);
            f && (d.memoizedState = e, Ug = true);
            d = d.queue;
            ji(ki.bind(null, c, d, a), [a]);
            if (d.getSnapshot !== b || f || null !== P && P.memoizedState.tag & 1) {
              c.flags |= 2048;
              li(9, mi.bind(null, c, d, e, b), void 0, null);
              if (null === R) throw Error(p(349));
              0 !== (Rh & 30) || ni(c, b, e);
            }
            return e;
          }
          function ni(a, b, c) {
            a.flags |= 16384;
            a = {
              getSnapshot: b,
              value: c
            };
            b = N.updateQueue;
            null === b ? (b = {
              lastEffect: null,
              stores: null
            }, N.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
          }
          function mi(a, b, c, d) {
            b.value = c;
            b.getSnapshot = d;
            oi(b) && pi(a);
          }
          function ki(a, b, c) {
            return c(function () {
              oi(b) && pi(a);
            });
          }
          function oi(a) {
            var b = a.getSnapshot;
            a = a.value;
            try {
              var c = b();
              return !He(a, c);
            } catch (d) {
              return true;
            }
          }
          function pi(a) {
            var b = Zg(a, 1);
            null !== b && mh(b, a, 1, -1);
          }
          function qi(a) {
            var b = ci();
            "function" === typeof a && (a = a());
            b.memoizedState = b.baseState = a;
            a = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: ei,
              lastRenderedState: a
            };
            b.queue = a;
            a = a.dispatch = ri.bind(null, N, a);
            return [b.memoizedState, a];
          }
          function li(a, b, c, d) {
            a = {
              tag: a,
              create: b,
              destroy: c,
              deps: d,
              next: null
            };
            b = N.updateQueue;
            null === b ? (b = {
              lastEffect: null,
              stores: null
            }, N.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
            return a;
          }
          function si() {
            return di().memoizedState;
          }
          function ti(a, b, c, d) {
            var e = ci();
            N.flags |= a;
            e.memoizedState = li(1 | b, c, void 0, void 0 === d ? null : d);
          }
          function ui(a, b, c, d) {
            var e = di();
            d = void 0 === d ? null : d;
            var f = void 0;
            if (null !== O) {
              var g = O.memoizedState;
              f = g.destroy;
              if (null !== d && Wh(d, g.deps)) {
                e.memoizedState = li(b, c, f, d);
                return;
              }
            }
            N.flags |= a;
            e.memoizedState = li(1 | b, c, f, d);
          }
          function vi(a, b) {
            return ti(8390656, 8, a, b);
          }
          function ji(a, b) {
            return ui(2048, 8, a, b);
          }
          function wi(a, b) {
            return ui(4, 2, a, b);
          }
          function xi(a, b) {
            return ui(4, 4, a, b);
          }
          function yi(a, b) {
            if ("function" === typeof b) return a = a(), b(a), function () {
              b(null);
            };
            if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
              b.current = null;
            };
          }
          function zi(a, b, c) {
            c = null !== c && void 0 !== c ? c.concat([a]) : null;
            return ui(4, 4, yi.bind(null, b, a), c);
          }
          function Ai() {}
          function Bi(a, b) {
            var c = di();
            b = void 0 === b ? null : b;
            var d = c.memoizedState;
            if (null !== d && null !== b && Wh(b, d[1])) return d[0];
            c.memoizedState = [a, b];
            return a;
          }
          function Ci(a, b) {
            var c = di();
            b = void 0 === b ? null : b;
            var d = c.memoizedState;
            if (null !== d && null !== b && Wh(b, d[1])) return d[0];
            a = a();
            c.memoizedState = [a, b];
            return a;
          }
          function Di(a, b, c) {
            if (0 === (Rh & 21)) return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c;
            He(c, b) || (c = yc(), N.lanes |= c, hh |= c, a.baseState = true);
            return b;
          }
          function Ei(a, b) {
            var c = C;
            C = 0 !== c && 4 > c ? c : 4;
            a(true);
            var d = Qh.transition;
            Qh.transition = {};
            try {
              a(!1), b();
            } finally {
              C = c, Qh.transition = d;
            }
          }
          function Fi() {
            return di().memoizedState;
          }
          function Gi(a, b, c) {
            var d = lh(a);
            c = {
              lane: d,
              action: c,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (Hi(a)) Ii(b, c);else if (c = Yg(a, b, c, d), null !== c) {
              var e = L();
              mh(c, a, d, e);
              Ji(c, b, d);
            }
          }
          function ri(a, b, c) {
            var d = lh(a),
              e = {
                lane: d,
                action: c,
                hasEagerState: false,
                eagerState: null,
                next: null
              };
            if (Hi(a)) Ii(b, e);else {
              var f = a.alternate;
              if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
                var g = b.lastRenderedState,
                  h = f(g, c);
                e.hasEagerState = !0;
                e.eagerState = h;
                if (He(h, g)) {
                  var k = b.interleaved;
                  null === k ? (e.next = e, Xg(b)) : (e.next = k.next, k.next = e);
                  b.interleaved = e;
                  return;
                }
              } catch (l) {} finally {}
              c = Yg(a, b, e, d);
              null !== c && (e = L(), mh(c, a, d, e), Ji(c, b, d));
            }
          }
          function Hi(a) {
            var b = a.alternate;
            return a === N || null !== b && b === N;
          }
          function Ii(a, b) {
            Th = Sh = true;
            var c = a.pending;
            null === c ? b.next = b : (b.next = c.next, c.next = b);
            a.pending = b;
          }
          function Ji(a, b, c) {
            if (0 !== (c & 4194240)) {
              var d = b.lanes;
              d &= a.pendingLanes;
              c |= d;
              b.lanes = c;
              Cc(a, c);
            }
          }
          var ai = {
              readContext: Vg,
              useCallback: Q,
              useContext: Q,
              useEffect: Q,
              useImperativeHandle: Q,
              useInsertionEffect: Q,
              useLayoutEffect: Q,
              useMemo: Q,
              useReducer: Q,
              useRef: Q,
              useState: Q,
              useDebugValue: Q,
              useDeferredValue: Q,
              useTransition: Q,
              useMutableSource: Q,
              useSyncExternalStore: Q,
              useId: Q,
              unstable_isNewReconciler: false
            },
            Yh = {
              readContext: Vg,
              useCallback: function (a, b) {
                ci().memoizedState = [a, void 0 === b ? null : b];
                return a;
              },
              useContext: Vg,
              useEffect: vi,
              useImperativeHandle: function (a, b, c) {
                c = null !== c && void 0 !== c ? c.concat([a]) : null;
                return ti(4194308, 4, yi.bind(null, b, a), c);
              },
              useLayoutEffect: function (a, b) {
                return ti(4194308, 4, a, b);
              },
              useInsertionEffect: function (a, b) {
                return ti(4, 2, a, b);
              },
              useMemo: function (a, b) {
                var c = ci();
                b = void 0 === b ? null : b;
                a = a();
                c.memoizedState = [a, b];
                return a;
              },
              useReducer: function (a, b, c) {
                var d = ci();
                b = void 0 !== c ? c(b) : b;
                d.memoizedState = d.baseState = b;
                a = {
                  pending: null,
                  interleaved: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: a,
                  lastRenderedState: b
                };
                d.queue = a;
                a = a.dispatch = Gi.bind(null, N, a);
                return [d.memoizedState, a];
              },
              useRef: function (a) {
                var b = ci();
                a = {
                  current: a
                };
                return b.memoizedState = a;
              },
              useState: qi,
              useDebugValue: Ai,
              useDeferredValue: function (a) {
                return ci().memoizedState = a;
              },
              useTransition: function () {
                var a = qi(false),
                  b = a[0];
                a = Ei.bind(null, a[1]);
                ci().memoizedState = a;
                return [b, a];
              },
              useMutableSource: function () {},
              useSyncExternalStore: function (a, b, c) {
                var d = N,
                  e = ci();
                if (I) {
                  if (void 0 === c) throw Error(p(407));
                  c = c();
                } else {
                  c = b();
                  if (null === R) throw Error(p(349));
                  0 !== (Rh & 30) || ni(d, b, c);
                }
                e.memoizedState = c;
                var f = {
                  value: c,
                  getSnapshot: b
                };
                e.queue = f;
                vi(ki.bind(null, d, f, a), [a]);
                d.flags |= 2048;
                li(9, mi.bind(null, d, f, c, b), void 0, null);
                return c;
              },
              useId: function () {
                var a = ci(),
                  b = R.identifierPrefix;
                if (I) {
                  var c = sg;
                  var d = rg;
                  c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
                  b = ":" + b + "R" + c;
                  c = Uh++;
                  0 < c && (b += "H" + c.toString(32));
                  b += ":";
                } else c = Vh++, b = ":" + b + "r" + c.toString(32) + ":";
                return a.memoizedState = b;
              },
              unstable_isNewReconciler: false
            },
            Zh = {
              readContext: Vg,
              useCallback: Bi,
              useContext: Vg,
              useEffect: ji,
              useImperativeHandle: zi,
              useInsertionEffect: wi,
              useLayoutEffect: xi,
              useMemo: Ci,
              useReducer: fi,
              useRef: si,
              useState: function () {
                return fi(ei);
              },
              useDebugValue: Ai,
              useDeferredValue: function (a) {
                var b = di();
                return Di(b, O.memoizedState, a);
              },
              useTransition: function () {
                var a = fi(ei)[0],
                  b = di().memoizedState;
                return [a, b];
              },
              useMutableSource: hi,
              useSyncExternalStore: ii,
              useId: Fi,
              unstable_isNewReconciler: false
            },
            $h = {
              readContext: Vg,
              useCallback: Bi,
              useContext: Vg,
              useEffect: ji,
              useImperativeHandle: zi,
              useInsertionEffect: wi,
              useLayoutEffect: xi,
              useMemo: Ci,
              useReducer: gi,
              useRef: si,
              useState: function () {
                return gi(ei);
              },
              useDebugValue: Ai,
              useDeferredValue: function (a) {
                var b = di();
                return null === O ? b.memoizedState = a : Di(b, O.memoizedState, a);
              },
              useTransition: function () {
                var a = gi(ei)[0],
                  b = di().memoizedState;
                return [a, b];
              },
              useMutableSource: hi,
              useSyncExternalStore: ii,
              useId: Fi,
              unstable_isNewReconciler: false
            };
          function Ki(a, b) {
            try {
              var c = "",
                d = b;
              do c += Pa(d), d = d.return; while (d);
              var e = c;
            } catch (f) {
              e = "\nError generating stack: " + f.message + "\n" + f.stack;
            }
            return {
              value: a,
              source: b,
              stack: e,
              digest: null
            };
          }
          function Li(a, b, c) {
            return {
              value: a,
              source: null,
              stack: null != c ? c : null,
              digest: null != b ? b : null
            };
          }
          function Mi(a, b) {
            try {
              console.error(b.value);
            } catch (c) {
              setTimeout(function () {
                throw c;
              });
            }
          }
          var Ni = "function" === typeof WeakMap ? WeakMap : Map;
          function Oi(a, b, c) {
            c = ch(-1, c);
            c.tag = 3;
            c.payload = {
              element: null
            };
            var d = b.value;
            c.callback = function () {
              Pi || (Pi = true, Qi = d);
              Mi(a, b);
            };
            return c;
          }
          function Ri(a, b, c) {
            c = ch(-1, c);
            c.tag = 3;
            var d = a.type.getDerivedStateFromError;
            if ("function" === typeof d) {
              var e = b.value;
              c.payload = function () {
                return d(e);
              };
              c.callback = function () {
                Mi(a, b);
              };
            }
            var f = a.stateNode;
            null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
              Mi(a, b);
              "function" !== typeof d && (null === Si ? Si = new Set([this]) : Si.add(this));
              var c = b.stack;
              this.componentDidCatch(b.value, {
                componentStack: null !== c ? c : ""
              });
            });
            return c;
          }
          function Ti(a, b, c) {
            var d = a.pingCache;
            if (null === d) {
              d = a.pingCache = new Ni();
              var e = new Set();
              d.set(b, e);
            } else e = d.get(b), void 0 === e && (e = new Set(), d.set(b, e));
            e.has(c) || (e.add(c), a = Ui.bind(null, a, b, c), b.then(a, a));
          }
          function Vi(a) {
            do {
              var b;
              if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
              if (b) return a;
              a = a.return;
            } while (null !== a);
            return null;
          }
          function Wi(a, b, c, d, e) {
            if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ch(-1, 1), b.tag = 2, dh(c, b, 1))), c.lanes |= 1), a;
            a.flags |= 65536;
            a.lanes = e;
            return a;
          }
          var Xi = ua.ReactCurrentOwner,
            Ug = false;
          function Yi(a, b, c, d) {
            b.child = null === a ? Ch(b, null, c, d) : Bh(b, a.child, c, d);
          }
          function Zi(a, b, c, d, e) {
            c = c.render;
            var f = b.ref;
            Tg(b, e);
            d = Xh(a, b, c, d, f, e);
            c = bi();
            if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
            I && c && vg(b);
            b.flags |= 1;
            Yi(a, b, d, e);
            return b.child;
          }
          function aj(a, b, c, d, e) {
            if (null === a) {
              var f = c.type;
              if ("function" === typeof f && !bj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, cj(a, b, f, d, e);
              a = yh(c.type, null, d, b, b.mode, e);
              a.ref = b.ref;
              a.return = b;
              return b.child = a;
            }
            f = a.child;
            if (0 === (a.lanes & e)) {
              var g = f.memoizedProps;
              c = c.compare;
              c = null !== c ? c : Ie;
              if (c(g, d) && a.ref === b.ref) return $i(a, b, e);
            }
            b.flags |= 1;
            a = wh(f, d);
            a.ref = b.ref;
            a.return = b;
            return b.child = a;
          }
          function cj(a, b, c, d, e) {
            if (null !== a) {
              var f = a.memoizedProps;
              if (Ie(f, d) && a.ref === b.ref) if (Ug = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (Ug = true);else return b.lanes = a.lanes, $i(a, b, e);
            }
            return dj(a, b, c, d, e);
          }
          function ej(a, b, c) {
            var d = b.pendingProps,
              e = d.children,
              f = null !== a ? a.memoizedState : null;
            if ("hidden" === d.mode) {
              if (0 === (b.mode & 1)) b.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
              }, G(fj, gj), gj |= c;else {
                if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {
                  baseLanes: a,
                  cachePool: null,
                  transitions: null
                }, b.updateQueue = null, G(fj, gj), gj |= a, null;
                b.memoizedState = {
                  baseLanes: 0,
                  cachePool: null,
                  transitions: null
                };
                d = null !== f ? f.baseLanes : c;
                G(fj, gj);
                gj |= d;
              }
            } else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(fj, gj), gj |= d;
            Yi(a, b, e, c);
            return b.child;
          }
          function hj(a, b) {
            var c = b.ref;
            if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
          }
          function dj(a, b, c, d, e) {
            var f = Zf(c) ? Xf : H.current;
            f = Yf(b, f);
            Tg(b, e);
            c = Xh(a, b, c, d, f, e);
            d = bi();
            if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
            I && d && vg(b);
            b.flags |= 1;
            Yi(a, b, c, e);
            return b.child;
          }
          function ij(a, b, c, d, e) {
            if (Zf(c)) {
              var f = true;
              cg(b);
            } else f = false;
            Tg(b, e);
            if (null === b.stateNode) jj(a, b), ph(b, c, d), rh(b, c, d, e), d = true;else if (null === a) {
              var g = b.stateNode,
                h = b.memoizedProps;
              g.props = h;
              var k = g.context,
                l = c.contextType;
              "object" === typeof l && null !== l ? l = Vg(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
              var m = c.getDerivedStateFromProps,
                q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
              q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && qh(b, g, d, l);
              $g = false;
              var r = b.memoizedState;
              g.state = r;
              gh(b, d, g, e);
              k = b.memoizedState;
              h !== d || r !== k || Wf.current || $g ? ("function" === typeof m && (kh(b, c, m, d), k = b.memoizedState), (h = $g || oh(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
            } else {
              g = b.stateNode;
              bh(a, b);
              h = b.memoizedProps;
              l = b.type === b.elementType ? h : Lg(b.type, h);
              g.props = l;
              q = b.pendingProps;
              r = g.context;
              k = c.contextType;
              "object" === typeof k && null !== k ? k = Vg(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
              var y = c.getDerivedStateFromProps;
              (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && qh(b, g, d, k);
              $g = false;
              r = b.memoizedState;
              g.state = r;
              gh(b, d, g, e);
              var n = b.memoizedState;
              h !== q || r !== n || Wf.current || $g ? ("function" === typeof y && (kh(b, c, y, d), n = b.memoizedState), (l = $g || oh(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
            }
            return kj(a, b, c, d, f, e);
          }
          function kj(a, b, c, d, e, f) {
            hj(a, b);
            var g = 0 !== (b.flags & 128);
            if (!d && !g) return e && dg(b, c, false), $i(a, b, f);
            d = b.stateNode;
            Xi.current = b;
            var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
            b.flags |= 1;
            null !== a && g ? (b.child = Bh(b, a.child, null, f), b.child = Bh(b, null, h, f)) : Yi(a, b, h, f);
            b.memoizedState = d.state;
            e && dg(b, c, true);
            return b.child;
          }
          function lj(a) {
            var b = a.stateNode;
            b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
            Ih(a, b.containerInfo);
          }
          function mj(a, b, c, d, e) {
            Ig();
            Jg(e);
            b.flags |= 256;
            Yi(a, b, c, d);
            return b.child;
          }
          var nj = {
            dehydrated: null,
            treeContext: null,
            retryLane: 0
          };
          function oj(a) {
            return {
              baseLanes: a,
              cachePool: null,
              transitions: null
            };
          }
          function pj(a, b, c) {
            var d = b.pendingProps,
              e = M.current,
              f = false,
              g = 0 !== (b.flags & 128),
              h;
            (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
            if (h) f = true, b.flags &= -129;else if (null === a || null !== a.memoizedState) e |= 1;
            G(M, e & 1);
            if (null === a) {
              Eg(b);
              a = b.memoizedState;
              if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
              g = d.children;
              a = d.fallback;
              return f ? (d = b.mode, f = b.child, g = {
                mode: "hidden",
                children: g
              }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = qj(g, d, 0, null), a = Ah(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = oj(c), b.memoizedState = nj, a) : rj(b, g);
            }
            e = a.memoizedState;
            if (null !== e && (h = e.dehydrated, null !== h)) return sj(a, b, g, d, h, e, c);
            if (f) {
              f = d.fallback;
              g = b.mode;
              e = a.child;
              h = e.sibling;
              var k = {
                mode: "hidden",
                children: d.children
              };
              0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = wh(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
              null !== h ? f = wh(h, f) : (f = Ah(f, g, c, null), f.flags |= 2);
              f.return = b;
              d.return = b;
              d.sibling = f;
              b.child = d;
              d = f;
              f = b.child;
              g = a.child.memoizedState;
              g = null === g ? oj(c) : {
                baseLanes: g.baseLanes | c,
                cachePool: null,
                transitions: g.transitions
              };
              f.memoizedState = g;
              f.childLanes = a.childLanes & ~c;
              b.memoizedState = nj;
              return d;
            }
            f = a.child;
            a = f.sibling;
            d = wh(f, {
              mode: "visible",
              children: d.children
            });
            0 === (b.mode & 1) && (d.lanes = c);
            d.return = b;
            d.sibling = null;
            null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
            b.child = d;
            b.memoizedState = null;
            return d;
          }
          function rj(a, b) {
            b = qj({
              mode: "visible",
              children: b
            }, a.mode, 0, null);
            b.return = a;
            return a.child = b;
          }
          function tj(a, b, c, d) {
            null !== d && Jg(d);
            Bh(b, a.child, null, c);
            a = rj(b, b.pendingProps.children);
            a.flags |= 2;
            b.memoizedState = null;
            return a;
          }
          function sj(a, b, c, d, e, f, g) {
            if (c) {
              if (b.flags & 256) return b.flags &= -257, d = Li(Error(p(422))), tj(a, b, g, d);
              if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
              f = d.fallback;
              e = b.mode;
              d = qj({
                mode: "visible",
                children: d.children
              }, e, 0, null);
              f = Ah(f, e, g, null);
              f.flags |= 2;
              d.return = b;
              f.return = b;
              d.sibling = f;
              b.child = d;
              0 !== (b.mode & 1) && Bh(b, a.child, null, g);
              b.child.memoizedState = oj(g);
              b.memoizedState = nj;
              return f;
            }
            if (0 === (b.mode & 1)) return tj(a, b, g, null);
            if ("$!" === e.data) {
              d = e.nextSibling && e.nextSibling.dataset;
              if (d) var h = d.dgst;
              d = h;
              f = Error(p(419));
              d = Li(f, d, void 0);
              return tj(a, b, g, d);
            }
            h = 0 !== (g & a.childLanes);
            if (Ug || h) {
              d = R;
              if (null !== d) {
                switch (g & -g) {
                  case 4:
                    e = 2;
                    break;
                  case 16:
                    e = 8;
                    break;
                  case 64:
                  case 128:
                  case 256:
                  case 512:
                  case 1024:
                  case 2048:
                  case 4096:
                  case 8192:
                  case 16384:
                  case 32768:
                  case 65536:
                  case 131072:
                  case 262144:
                  case 524288:
                  case 1048576:
                  case 2097152:
                  case 4194304:
                  case 8388608:
                  case 16777216:
                  case 33554432:
                  case 67108864:
                    e = 32;
                    break;
                  case 536870912:
                    e = 268435456;
                    break;
                  default:
                    e = 0;
                }
                e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
                0 !== e && e !== f.retryLane && (f.retryLane = e, Zg(a, e), mh(d, a, e, -1));
              }
              uj();
              d = Li(Error(p(421)));
              return tj(a, b, g, d);
            }
            if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = vj.bind(null, a), e._reactRetry = b, null;
            a = f.treeContext;
            yg = Lf(e.nextSibling);
            xg = b;
            I = true;
            zg = null;
            null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
            b = rj(b, d.children);
            b.flags |= 4096;
            return b;
          }
          function wj(a, b, c) {
            a.lanes |= b;
            var d = a.alternate;
            null !== d && (d.lanes |= b);
            Sg(a.return, b, c);
          }
          function xj(a, b, c, d, e) {
            var f = a.memoizedState;
            null === f ? a.memoizedState = {
              isBackwards: b,
              rendering: null,
              renderingStartTime: 0,
              last: d,
              tail: c,
              tailMode: e
            } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
          }
          function yj(a, b, c) {
            var d = b.pendingProps,
              e = d.revealOrder,
              f = d.tail;
            Yi(a, b, d.children, c);
            d = M.current;
            if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;else {
              if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a;) {
                if (13 === a.tag) null !== a.memoizedState && wj(a, c, b);else if (19 === a.tag) wj(a, c, b);else if (null !== a.child) {
                  a.child.return = a;
                  a = a.child;
                  continue;
                }
                if (a === b) break a;
                for (; null === a.sibling;) {
                  if (null === a.return || a.return === b) break a;
                  a = a.return;
                }
                a.sibling.return = a.return;
                a = a.sibling;
              }
              d &= 1;
            }
            G(M, d);
            if (0 === (b.mode & 1)) b.memoizedState = null;else switch (e) {
              case "forwards":
                c = b.child;
                for (e = null; null !== c;) a = c.alternate, null !== a && null === Mh(a) && (e = c), c = c.sibling;
                c = e;
                null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
                xj(b, false, e, c, f);
                break;
              case "backwards":
                c = null;
                e = b.child;
                for (b.child = null; null !== e;) {
                  a = e.alternate;
                  if (null !== a && null === Mh(a)) {
                    b.child = e;
                    break;
                  }
                  a = e.sibling;
                  e.sibling = c;
                  c = e;
                  e = a;
                }
                xj(b, true, c, null, f);
                break;
              case "together":
                xj(b, false, null, null, void 0);
                break;
              default:
                b.memoizedState = null;
            }
            return b.child;
          }
          function jj(a, b) {
            0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
          }
          function $i(a, b, c) {
            null !== a && (b.dependencies = a.dependencies);
            hh |= b.lanes;
            if (0 === (c & b.childLanes)) return null;
            if (null !== a && b.child !== a.child) throw Error(p(153));
            if (null !== b.child) {
              a = b.child;
              c = wh(a, a.pendingProps);
              b.child = c;
              for (c.return = b; null !== a.sibling;) a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b;
              c.sibling = null;
            }
            return b.child;
          }
          function zj(a, b, c) {
            switch (b.tag) {
              case 3:
                lj(b);
                Ig();
                break;
              case 5:
                Kh(b);
                break;
              case 1:
                Zf(b.type) && cg(b);
                break;
              case 4:
                Ih(b, b.stateNode.containerInfo);
                break;
              case 10:
                var d = b.type._context,
                  e = b.memoizedProps.value;
                G(Mg, d._currentValue);
                d._currentValue = e;
                break;
              case 13:
                d = b.memoizedState;
                if (null !== d) {
                  if (null !== d.dehydrated) return G(M, M.current & 1), b.flags |= 128, null;
                  if (0 !== (c & b.child.childLanes)) return pj(a, b, c);
                  G(M, M.current & 1);
                  a = $i(a, b, c);
                  return null !== a ? a.sibling : null;
                }
                G(M, M.current & 1);
                break;
              case 19:
                d = 0 !== (c & b.childLanes);
                if (0 !== (a.flags & 128)) {
                  if (d) return yj(a, b, c);
                  b.flags |= 128;
                }
                e = b.memoizedState;
                null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
                G(M, M.current);
                if (d) break;else return null;
              case 22:
              case 23:
                return b.lanes = 0, ej(a, b, c);
            }
            return $i(a, b, c);
          }
          var Aj, Bj, Cj, Dj;
          Aj = function (a, b) {
            for (var c = b.child; null !== c;) {
              if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);else if (4 !== c.tag && null !== c.child) {
                c.child.return = c;
                c = c.child;
                continue;
              }
              if (c === b) break;
              for (; null === c.sibling;) {
                if (null === c.return || c.return === b) return;
                c = c.return;
              }
              c.sibling.return = c.return;
              c = c.sibling;
            }
          };
          Bj = function () {};
          Cj = function (a, b, c, d) {
            var e = a.memoizedProps;
            if (e !== d) {
              a = b.stateNode;
              Hh(Eh.current);
              var f = null;
              switch (c) {
                case "input":
                  e = Ya(a, e);
                  d = Ya(a, d);
                  f = [];
                  break;
                case "select":
                  e = A({}, e, {
                    value: void 0
                  });
                  d = A({}, d, {
                    value: void 0
                  });
                  f = [];
                  break;
                case "textarea":
                  e = gb(a, e);
                  d = gb(a, d);
                  f = [];
                  break;
                default:
                  "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
              }
              ub(c, d);
              var g;
              c = null;
              for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
                var h = e[l];
                for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
              } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
              for (l in d) {
                var k = d[l];
                h = null != e ? e[l] : void 0;
                if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) {
                  if (h) {
                    for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
                    for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
                  } else c || (f || (f = []), f.push(l, c)), c = k;
                } else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
              }
              c && (f = f || []).push("style", c);
              var l = f;
              if (b.updateQueue = l) b.flags |= 4;
            }
          };
          Dj = function (a, b, c, d) {
            c !== d && (b.flags |= 4);
          };
          function Ej(a, b) {
            if (!I) switch (a.tailMode) {
              case "hidden":
                b = a.tail;
                for (var c = null; null !== b;) null !== b.alternate && (c = b), b = b.sibling;
                null === c ? a.tail = null : c.sibling = null;
                break;
              case "collapsed":
                c = a.tail;
                for (var d = null; null !== c;) null !== c.alternate && (d = c), c = c.sibling;
                null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
            }
          }
          function S(a) {
            var b = null !== a.alternate && a.alternate.child === a.child,
              c = 0,
              d = 0;
            if (b) for (var e = a.child; null !== e;) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;else for (e = a.child; null !== e;) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
            a.subtreeFlags |= d;
            a.childLanes = c;
            return b;
          }
          function Fj(a, b, c) {
            var d = b.pendingProps;
            wg(b);
            switch (b.tag) {
              case 2:
              case 16:
              case 15:
              case 0:
              case 11:
              case 7:
              case 8:
              case 12:
              case 9:
              case 14:
                return S(b), null;
              case 1:
                return Zf(b.type) && $f(), S(b), null;
              case 3:
                d = b.stateNode;
                Jh();
                E(Wf);
                E(H);
                Oh();
                d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
                if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null));
                Bj(a, b);
                S(b);
                return null;
              case 5:
                Lh(b);
                var e = Hh(Gh.current);
                c = b.type;
                if (null !== a && null != b.stateNode) Cj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);else {
                  if (!d) {
                    if (null === b.stateNode) throw Error(p(166));
                    S(b);
                    return null;
                  }
                  a = Hh(Eh.current);
                  if (Gg(b)) {
                    d = b.stateNode;
                    c = b.type;
                    var f = b.memoizedProps;
                    d[Of] = b;
                    d[Pf] = f;
                    a = 0 !== (b.mode & 1);
                    switch (c) {
                      case "dialog":
                        D("cancel", d);
                        D("close", d);
                        break;
                      case "iframe":
                      case "object":
                      case "embed":
                        D("load", d);
                        break;
                      case "video":
                      case "audio":
                        for (e = 0; e < lf.length; e++) D(lf[e], d);
                        break;
                      case "source":
                        D("error", d);
                        break;
                      case "img":
                      case "image":
                      case "link":
                        D("error", d);
                        D("load", d);
                        break;
                      case "details":
                        D("toggle", d);
                        break;
                      case "input":
                        Za(d, f);
                        D("invalid", d);
                        break;
                      case "select":
                        d._wrapperState = {
                          wasMultiple: !!f.multiple
                        };
                        D("invalid", d);
                        break;
                      case "textarea":
                        hb(d, f), D("invalid", d);
                    }
                    ub(c, f);
                    e = null;
                    for (var g in f) if (f.hasOwnProperty(g)) {
                      var h = f[g];
                      "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
                    }
                    switch (c) {
                      case "input":
                        Va(d);
                        db(d, f, true);
                        break;
                      case "textarea":
                        Va(d);
                        jb(d);
                        break;
                      case "select":
                      case "option":
                        break;
                      default:
                        "function" === typeof f.onClick && (d.onclick = Bf);
                    }
                    d = e;
                    b.updateQueue = d;
                    null !== d && (b.flags |= 4);
                  } else {
                    g = 9 === e.nodeType ? e : e.ownerDocument;
                    "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                    "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script>\x3c/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, {
                      is: d.is
                    }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                    a[Of] = b;
                    a[Pf] = d;
                    Aj(a, b, false, false);
                    b.stateNode = a;
                    a: {
                      g = vb(c, d);
                      switch (c) {
                        case "dialog":
                          D("cancel", a);
                          D("close", a);
                          e = d;
                          break;
                        case "iframe":
                        case "object":
                        case "embed":
                          D("load", a);
                          e = d;
                          break;
                        case "video":
                        case "audio":
                          for (e = 0; e < lf.length; e++) D(lf[e], a);
                          e = d;
                          break;
                        case "source":
                          D("error", a);
                          e = d;
                          break;
                        case "img":
                        case "image":
                        case "link":
                          D("error", a);
                          D("load", a);
                          e = d;
                          break;
                        case "details":
                          D("toggle", a);
                          e = d;
                          break;
                        case "input":
                          Za(a, d);
                          e = Ya(a, d);
                          D("invalid", a);
                          break;
                        case "option":
                          e = d;
                          break;
                        case "select":
                          a._wrapperState = {
                            wasMultiple: !!d.multiple
                          };
                          e = A({}, d, {
                            value: void 0
                          });
                          D("invalid", a);
                          break;
                        case "textarea":
                          hb(a, d);
                          e = gb(a, d);
                          D("invalid", a);
                          break;
                        default:
                          e = d;
                      }
                      ub(c, e);
                      h = e;
                      for (f in h) if (h.hasOwnProperty(f)) {
                        var k = h[f];
                        "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                      }
                      switch (c) {
                        case "input":
                          Va(a);
                          db(a, d, false);
                          break;
                        case "textarea":
                          Va(a);
                          jb(a);
                          break;
                        case "option":
                          null != d.value && a.setAttribute("value", "" + Sa(d.value));
                          break;
                        case "select":
                          a.multiple = !!d.multiple;
                          f = d.value;
                          null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, true);
                          break;
                        default:
                          "function" === typeof e.onClick && (a.onclick = Bf);
                      }
                      switch (c) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                          d = !!d.autoFocus;
                          break a;
                        case "img":
                          d = true;
                          break a;
                        default:
                          d = false;
                      }
                    }
                    d && (b.flags |= 4);
                  }
                  null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
                }
                S(b);
                return null;
              case 6:
                if (a && null != b.stateNode) Dj(a, b, a.memoizedProps, d);else {
                  if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
                  c = Hh(Gh.current);
                  Hh(Eh.current);
                  if (Gg(b)) {
                    d = b.stateNode;
                    c = b.memoizedProps;
                    d[Of] = b;
                    if (f = d.nodeValue !== c) if (a = xg, null !== a) switch (a.tag) {
                      case 3:
                        Af(d.nodeValue, c, 0 !== (a.mode & 1));
                        break;
                      case 5:
                        true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                    }
                    f && (b.flags |= 4);
                  } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
                }
                S(b);
                return null;
              case 13:
                E(M);
                d = b.memoizedState;
                if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
                  if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;else if (f = Gg(b), null !== d && null !== d.dehydrated) {
                    if (null === a) {
                      if (!f) throw Error(p(318));
                      f = b.memoizedState;
                      f = null !== f ? f.dehydrated : null;
                      if (!f) throw Error(p(317));
                      f[Of] = b;
                    } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                    S(b);
                    f = false;
                  } else null !== zg && (Gj(zg), zg = null), f = true;
                  if (!f) return b.flags & 65536 ? b : null;
                }
                if (0 !== (b.flags & 128)) return b.lanes = c, b;
                d = null !== d;
                d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
                null !== b.updateQueue && (b.flags |= 4);
                S(b);
                return null;
              case 4:
                return Jh(), Bj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
              case 10:
                return Rg(b.type._context), S(b), null;
              case 17:
                return Zf(b.type) && $f(), S(b), null;
              case 19:
                E(M);
                f = b.memoizedState;
                if (null === f) return S(b), null;
                d = 0 !== (b.flags & 128);
                g = f.rendering;
                if (null === g) {
                  if (d) Ej(f, false);else {
                    if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a;) {
                      g = Mh(a);
                      if (null !== g) {
                        b.flags |= 128;
                        Ej(f, false);
                        d = g.updateQueue;
                        null !== d && (b.updateQueue = d, b.flags |= 4);
                        b.subtreeFlags = 0;
                        d = c;
                        for (c = b.child; null !== c;) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : {
                          lanes: a.lanes,
                          firstContext: a.firstContext
                        }), c = c.sibling;
                        G(M, M.current & 1 | 2);
                        return b.child;
                      }
                      a = a.sibling;
                    }
                    null !== f.tail && B() > Hj && (b.flags |= 128, d = true, Ej(f, false), b.lanes = 4194304);
                  }
                } else {
                  if (!d) if (a = Mh(g), null !== a) {
                    if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Ej(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
                  } else 2 * B() - f.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d = true, Ej(f, false), b.lanes = 4194304);
                  f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
                }
                if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = M.current, G(M, d ? c & 1 | 2 : c & 1), b;
                S(b);
                return null;
              case 22:
              case 23:
                return Ij(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (gj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
              case 24:
                return null;
              case 25:
                return null;
            }
            throw Error(p(156, b.tag));
          }
          function Jj(a, b) {
            wg(b);
            switch (b.tag) {
              case 1:
                return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
              case 3:
                return Jh(), E(Wf), E(H), Oh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
              case 5:
                return Lh(b), null;
              case 13:
                E(M);
                a = b.memoizedState;
                if (null !== a && null !== a.dehydrated) {
                  if (null === b.alternate) throw Error(p(340));
                  Ig();
                }
                a = b.flags;
                return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
              case 19:
                return E(M), null;
              case 4:
                return Jh(), null;
              case 10:
                return Rg(b.type._context), null;
              case 22:
              case 23:
                return Ij(), null;
              case 24:
                return null;
              default:
                return null;
            }
          }
          var Kj = false,
            U = false,
            Lj = "function" === typeof WeakSet ? WeakSet : Set,
            V = null;
          function Mj(a, b) {
            var c = a.ref;
            if (null !== c) if ("function" === typeof c) try {
              c(null);
            } catch (d) {
              W(a, b, d);
            } else c.current = null;
          }
          function Nj(a, b, c) {
            try {
              c();
            } catch (d) {
              W(a, b, d);
            }
          }
          var Oj = false;
          function Pj(a, b) {
            Cf = dd;
            a = Me();
            if (Ne(a)) {
              if ("selectionStart" in a) var c = {
                start: a.selectionStart,
                end: a.selectionEnd
              };else a: {
                c = (c = a.ownerDocument) && c.defaultView || window;
                var d = c.getSelection && c.getSelection();
                if (d && 0 !== d.rangeCount) {
                  c = d.anchorNode;
                  var e = d.anchorOffset,
                    f = d.focusNode;
                  d = d.focusOffset;
                  try {
                    c.nodeType, f.nodeType;
                  } catch (F) {
                    c = null;
                    break a;
                  }
                  var g = 0,
                    h = -1,
                    k = -1,
                    l = 0,
                    m = 0,
                    q = a,
                    r = null;
                  b: for (;;) {
                    for (var y;;) {
                      q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                      q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                      3 === q.nodeType && (g += q.nodeValue.length);
                      if (null === (y = q.firstChild)) break;
                      r = q;
                      q = y;
                    }
                    for (;;) {
                      if (q === a) break b;
                      r === c && ++l === e && (h = g);
                      r === f && ++m === d && (k = g);
                      if (null !== (y = q.nextSibling)) break;
                      q = r;
                      r = q.parentNode;
                    }
                    q = y;
                  }
                  c = -1 === h || -1 === k ? null : {
                    start: h,
                    end: k
                  };
                } else c = null;
              }
              c = c || {
                start: 0,
                end: 0
              };
            } else c = null;
            Df = {
              focusedElem: a,
              selectionRange: c
            };
            dd = false;
            for (V = b; null !== V;) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;else for (; null !== V;) {
              b = V;
              try {
                var n = b.alternate;
                if (0 !== (b.flags & 1024)) switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (null !== n) {
                      var t = n.memoizedProps,
                        J = n.memoizedState,
                        x = b.stateNode,
                        w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Lg(b.type, t), J);
                      x.__reactInternalSnapshotBeforeUpdate = w;
                    }
                    break;
                  case 3:
                    var u = b.stateNode.containerInfo;
                    1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p(163));
                }
              } catch (F) {
                W(b, b.return, F);
              }
              a = b.sibling;
              if (null !== a) {
                a.return = b.return;
                V = a;
                break;
              }
              V = b.return;
            }
            n = Oj;
            Oj = false;
            return n;
          }
          function Qj(a, b, c) {
            var d = b.updateQueue;
            d = null !== d ? d.lastEffect : null;
            if (null !== d) {
              var e = d = d.next;
              do {
                if ((e.tag & a) === a) {
                  var f = e.destroy;
                  e.destroy = void 0;
                  void 0 !== f && Nj(b, c, f);
                }
                e = e.next;
              } while (e !== d);
            }
          }
          function Rj(a, b) {
            b = b.updateQueue;
            b = null !== b ? b.lastEffect : null;
            if (null !== b) {
              var c = b = b.next;
              do {
                if ((c.tag & a) === a) {
                  var d = c.create;
                  c.destroy = d();
                }
                c = c.next;
              } while (c !== b);
            }
          }
          function Sj(a) {
            var b = a.ref;
            if (null !== b) {
              var c = a.stateNode;
              switch (a.tag) {
                case 5:
                  a = c;
                  break;
                default:
                  a = c;
              }
              "function" === typeof b ? b(a) : b.current = a;
            }
          }
          function Tj(a) {
            var b = a.alternate;
            null !== b && (a.alternate = null, Tj(b));
            a.child = null;
            a.deletions = null;
            a.sibling = null;
            5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
            a.stateNode = null;
            a.return = null;
            a.dependencies = null;
            a.memoizedProps = null;
            a.memoizedState = null;
            a.pendingProps = null;
            a.stateNode = null;
            a.updateQueue = null;
          }
          function Uj(a) {
            return 5 === a.tag || 3 === a.tag || 4 === a.tag;
          }
          function Vj(a) {
            a: for (;;) {
              for (; null === a.sibling;) {
                if (null === a.return || Uj(a.return)) return null;
                a = a.return;
              }
              a.sibling.return = a.return;
              for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag;) {
                if (a.flags & 2) continue a;
                if (null === a.child || 4 === a.tag) continue a;else a.child.return = a, a = a.child;
              }
              if (!(a.flags & 2)) return a.stateNode;
            }
          }
          function Wj(a, b, c) {
            var d = a.tag;
            if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a;) Wj(a, b, c), a = a.sibling;
          }
          function Xj(a, b, c) {
            var d = a.tag;
            if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);else if (4 !== d && (a = a.child, null !== a)) for (Xj(a, b, c), a = a.sibling; null !== a;) Xj(a, b, c), a = a.sibling;
          }
          var X = null,
            Yj = false;
          function Zj(a, b, c) {
            for (c = c.child; null !== c;) ak(a, b, c), c = c.sibling;
          }
          function ak(a, b, c) {
            if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
              lc.onCommitFiberUnmount(kc, c);
            } catch (h) {}
            switch (c.tag) {
              case 5:
                U || Mj(c, b);
              case 6:
                var d = X,
                  e = Yj;
                X = null;
                Zj(a, b, c);
                X = d;
                Yj = e;
                null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
                break;
              case 18:
                null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
                break;
              case 4:
                d = X;
                e = Yj;
                X = c.stateNode.containerInfo;
                Yj = true;
                Zj(a, b, c);
                X = d;
                Yj = e;
                break;
              case 0:
              case 11:
              case 14:
              case 15:
                if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
                  e = d = d.next;
                  do {
                    var f = e,
                      g = f.destroy;
                    f = f.tag;
                    void 0 !== g && (0 !== (f & 2) ? Nj(c, b, g) : 0 !== (f & 4) && Nj(c, b, g));
                    e = e.next;
                  } while (e !== d);
                }
                Zj(a, b, c);
                break;
              case 1:
                if (!U && (Mj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
                  d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
                } catch (h) {
                  W(c, b, h);
                }
                Zj(a, b, c);
                break;
              case 21:
                Zj(a, b, c);
                break;
              case 22:
                c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Zj(a, b, c), U = d) : Zj(a, b, c);
                break;
              default:
                Zj(a, b, c);
            }
          }
          function bk(a) {
            var b = a.updateQueue;
            if (null !== b) {
              a.updateQueue = null;
              var c = a.stateNode;
              null === c && (c = a.stateNode = new Lj());
              b.forEach(function (b) {
                var d = ck.bind(null, a, b);
                c.has(b) || (c.add(b), b.then(d, d));
              });
            }
          }
          function dk(a, b) {
            var c = b.deletions;
            if (null !== c) for (var d = 0; d < c.length; d++) {
              var e = c[d];
              try {
                var f = a,
                  g = b,
                  h = g;
                a: for (; null !== h;) {
                  switch (h.tag) {
                    case 5:
                      X = h.stateNode;
                      Yj = !1;
                      break a;
                    case 3:
                      X = h.stateNode.containerInfo;
                      Yj = !0;
                      break a;
                    case 4:
                      X = h.stateNode.containerInfo;
                      Yj = !0;
                      break a;
                  }
                  h = h.return;
                }
                if (null === X) throw Error(p(160));
                ak(f, g, e);
                X = null;
                Yj = !1;
                var k = e.alternate;
                null !== k && (k.return = null);
                e.return = null;
              } catch (l) {
                W(e, b, l);
              }
            }
            if (b.subtreeFlags & 12854) for (b = b.child; null !== b;) ek(b, a), b = b.sibling;
          }
          function ek(a, b) {
            var c = a.alternate,
              d = a.flags;
            switch (a.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                dk(b, a);
                fk(a);
                if (d & 4) {
                  try {
                    Qj(3, a, a.return), Rj(3, a);
                  } catch (t) {
                    W(a, a.return, t);
                  }
                  try {
                    Qj(5, a, a.return);
                  } catch (t) {
                    W(a, a.return, t);
                  }
                }
                break;
              case 1:
                dk(b, a);
                fk(a);
                d & 512 && null !== c && Mj(c, c.return);
                break;
              case 5:
                dk(b, a);
                fk(a);
                d & 512 && null !== c && Mj(c, c.return);
                if (a.flags & 32) {
                  var e = a.stateNode;
                  try {
                    ob(e, "");
                  } catch (t) {
                    W(a, a.return, t);
                  }
                }
                if (d & 4 && (e = a.stateNode, null != e)) {
                  var f = a.memoizedProps,
                    g = null !== c ? c.memoizedProps : f,
                    h = a.type,
                    k = a.updateQueue;
                  a.updateQueue = null;
                  if (null !== k) try {
                    "input" === h && "radio" === f.type && null != f.name && ab(e, f);
                    vb(h, g);
                    var l = vb(h, f);
                    for (g = 0; g < k.length; g += 2) {
                      var m = k[g],
                        q = k[g + 1];
                      "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
                    }
                    switch (h) {
                      case "input":
                        bb(e, f);
                        break;
                      case "textarea":
                        ib(e, f);
                        break;
                      case "select":
                        var r = e._wrapperState.wasMultiple;
                        e._wrapperState.wasMultiple = !!f.multiple;
                        var y = f.value;
                        null != y ? fb(e, !!f.multiple, y, !1) : r !== !!f.multiple && (null != f.defaultValue ? fb(e, !!f.multiple, f.defaultValue, !0) : fb(e, !!f.multiple, f.multiple ? [] : "", !1));
                    }
                    e[Pf] = f;
                  } catch (t) {
                    W(a, a.return, t);
                  }
                }
                break;
              case 6:
                dk(b, a);
                fk(a);
                if (d & 4) {
                  if (null === a.stateNode) throw Error(p(162));
                  e = a.stateNode;
                  f = a.memoizedProps;
                  try {
                    e.nodeValue = f;
                  } catch (t) {
                    W(a, a.return, t);
                  }
                }
                break;
              case 3:
                dk(b, a);
                fk(a);
                if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
                  bd(b.containerInfo);
                } catch (t) {
                  W(a, a.return, t);
                }
                break;
              case 4:
                dk(b, a);
                fk(a);
                break;
              case 13:
                dk(b, a);
                fk(a);
                e = a.child;
                e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (gk = B()));
                d & 4 && bk(a);
                break;
              case 22:
                m = null !== c && null !== c.memoizedState;
                a.mode & 1 ? (U = (l = U) || m, dk(b, a), U = l) : dk(b, a);
                fk(a);
                if (d & 8192) {
                  l = null !== a.memoizedState;
                  if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m;) {
                    for (q = V = m; null !== V;) {
                      r = V;
                      y = r.child;
                      switch (r.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                          Qj(4, r, r.return);
                          break;
                        case 1:
                          Mj(r, r.return);
                          var n = r.stateNode;
                          if ("function" === typeof n.componentWillUnmount) {
                            d = r;
                            c = r.return;
                            try {
                              b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                            } catch (t) {
                              W(d, c, t);
                            }
                          }
                          break;
                        case 5:
                          Mj(r, r.return);
                          break;
                        case 22:
                          if (null !== r.memoizedState) {
                            hk(q);
                            continue;
                          }
                      }
                      null !== y ? (y.return = r, V = y) : hk(q);
                    }
                    m = m.sibling;
                  }
                  a: for (m = null, q = a;;) {
                    if (5 === q.tag) {
                      if (null === m) {
                        m = q;
                        try {
                          e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                        } catch (t) {
                          W(a, a.return, t);
                        }
                      }
                    } else if (6 === q.tag) {
                      if (null === m) try {
                        q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                      } catch (t) {
                        W(a, a.return, t);
                      }
                    } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                      q.child.return = q;
                      q = q.child;
                      continue;
                    }
                    if (q === a) break a;
                    for (; null === q.sibling;) {
                      if (null === q.return || q.return === a) break a;
                      m === q && (m = null);
                      q = q.return;
                    }
                    m === q && (m = null);
                    q.sibling.return = q.return;
                    q = q.sibling;
                  }
                }
                break;
              case 19:
                dk(b, a);
                fk(a);
                d & 4 && bk(a);
                break;
              case 21:
                break;
              default:
                dk(b, a), fk(a);
            }
          }
          function fk(a) {
            var b = a.flags;
            if (b & 2) {
              try {
                a: {
                  for (var c = a.return; null !== c;) {
                    if (Uj(c)) {
                      var d = c;
                      break a;
                    }
                    c = c.return;
                  }
                  throw Error(p(160));
                }
                switch (d.tag) {
                  case 5:
                    var e = d.stateNode;
                    d.flags & 32 && (ob(e, ""), d.flags &= -33);
                    var f = Vj(a);
                    Xj(a, f, e);
                    break;
                  case 3:
                  case 4:
                    var g = d.stateNode.containerInfo,
                      h = Vj(a);
                    Wj(a, h, g);
                    break;
                  default:
                    throw Error(p(161));
                }
              } catch (k) {
                W(a, a.return, k);
              }
              a.flags &= -3;
            }
            b & 4096 && (a.flags &= -4097);
          }
          function ik(a, b, c) {
            V = a;
            jk(a);
          }
          function jk(a, b, c) {
            for (var d = 0 !== (a.mode & 1); null !== V;) {
              var e = V,
                f = e.child;
              if (22 === e.tag && d) {
                var g = null !== e.memoizedState || Kj;
                if (!g) {
                  var h = e.alternate,
                    k = null !== h && null !== h.memoizedState || U;
                  h = Kj;
                  var l = U;
                  Kj = g;
                  if ((U = k) && !l) for (V = e; null !== V;) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e) : null !== k ? (k.return = g, V = k) : kk(e);
                  for (; null !== f;) V = f, jk(f), f = f.sibling;
                  V = e;
                  Kj = h;
                  U = l;
                }
                lk(a);
              } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : lk(a);
            }
          }
          function lk(a) {
            for (; null !== V;) {
              var b = V;
              if (0 !== (b.flags & 8772)) {
                var c = b.alternate;
                try {
                  if (0 !== (b.flags & 8772)) switch (b.tag) {
                    case 0:
                    case 11:
                    case 15:
                      U || Rj(5, b);
                      break;
                    case 1:
                      var d = b.stateNode;
                      if (b.flags & 4 && !U) if (null === c) d.componentDidMount();else {
                        var e = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
                        d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                      }
                      var f = b.updateQueue;
                      null !== f && ih(b, f, d);
                      break;
                    case 3:
                      var g = b.updateQueue;
                      if (null !== g) {
                        c = null;
                        if (null !== b.child) switch (b.child.tag) {
                          case 5:
                            c = b.child.stateNode;
                            break;
                          case 1:
                            c = b.child.stateNode;
                        }
                        ih(b, g, c);
                      }
                      break;
                    case 5:
                      var h = b.stateNode;
                      if (null === c && b.flags & 4) {
                        c = h;
                        var k = b.memoizedProps;
                        switch (b.type) {
                          case "button":
                          case "input":
                          case "select":
                          case "textarea":
                            k.autoFocus && c.focus();
                            break;
                          case "img":
                            k.src && (c.src = k.src);
                        }
                      }
                      break;
                    case 6:
                      break;
                    case 4:
                      break;
                    case 12:
                      break;
                    case 13:
                      if (null === b.memoizedState) {
                        var l = b.alternate;
                        if (null !== l) {
                          var m = l.memoizedState;
                          if (null !== m) {
                            var q = m.dehydrated;
                            null !== q && bd(q);
                          }
                        }
                      }
                      break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                      break;
                    default:
                      throw Error(p(163));
                  }
                  U || b.flags & 512 && Sj(b);
                } catch (r) {
                  W(b, b.return, r);
                }
              }
              if (b === a) {
                V = null;
                break;
              }
              c = b.sibling;
              if (null !== c) {
                c.return = b.return;
                V = c;
                break;
              }
              V = b.return;
            }
          }
          function hk(a) {
            for (; null !== V;) {
              var b = V;
              if (b === a) {
                V = null;
                break;
              }
              var c = b.sibling;
              if (null !== c) {
                c.return = b.return;
                V = c;
                break;
              }
              V = b.return;
            }
          }
          function kk(a) {
            for (; null !== V;) {
              var b = V;
              try {
                switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    var c = b.return;
                    try {
                      Rj(4, b);
                    } catch (k) {
                      W(b, c, k);
                    }
                    break;
                  case 1:
                    var d = b.stateNode;
                    if ("function" === typeof d.componentDidMount) {
                      var e = b.return;
                      try {
                        d.componentDidMount();
                      } catch (k) {
                        W(b, e, k);
                      }
                    }
                    var f = b.return;
                    try {
                      Sj(b);
                    } catch (k) {
                      W(b, f, k);
                    }
                    break;
                  case 5:
                    var g = b.return;
                    try {
                      Sj(b);
                    } catch (k) {
                      W(b, g, k);
                    }
                }
              } catch (k) {
                W(b, b.return, k);
              }
              if (b === a) {
                V = null;
                break;
              }
              var h = b.sibling;
              if (null !== h) {
                h.return = b.return;
                V = h;
                break;
              }
              V = b.return;
            }
          }
          var mk = Math.ceil,
            nk = ua.ReactCurrentDispatcher,
            ok = ua.ReactCurrentOwner,
            pk = ua.ReactCurrentBatchConfig,
            K = 0,
            R = null,
            Y = null,
            Z = 0,
            gj = 0,
            fj = Uf(0),
            T = 0,
            qk = null,
            hh = 0,
            rk = 0,
            sk = 0,
            tk = null,
            uk = null,
            gk = 0,
            Hj = Infinity,
            vk = null,
            Pi = false,
            Qi = null,
            Si = null,
            wk = false,
            xk = null,
            yk = 0,
            zk = 0,
            Ak = null,
            Bk = -1,
            Ck = 0;
          function L() {
            return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
          }
          function lh(a) {
            if (0 === (a.mode & 1)) return 1;
            if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
            if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
            a = C;
            if (0 !== a) return a;
            a = window.event;
            a = void 0 === a ? 16 : jd(a.type);
            return a;
          }
          function mh(a, b, c, d) {
            if (50 < zk) throw zk = 0, Ak = null, Error(p(185));
            Ac(a, c, d);
            if (0 === (K & 2) || a !== R) a === R && (0 === (K & 2) && (rk |= c), 4 === T && Dk(a, Z)), Ek(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Hj = B() + 500, fg && jg());
          }
          function Ek(a, b) {
            var c = a.callbackNode;
            wc(a, b);
            var d = uc(a, a === R ? Z : 0);
            if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;else if (b = d & -d, a.callbackPriority !== b) {
              null != c && bc(c);
              if (1 === b) 0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function () {
                0 === (K & 6) && jg();
              }), c = null;else {
                switch (Dc(d)) {
                  case 1:
                    c = fc;
                    break;
                  case 4:
                    c = gc;
                    break;
                  case 16:
                    c = hc;
                    break;
                  case 536870912:
                    c = jc;
                    break;
                  default:
                    c = hc;
                }
                c = Gk(c, Hk.bind(null, a));
              }
              a.callbackPriority = b;
              a.callbackNode = c;
            }
          }
          function Hk(a, b) {
            Bk = -1;
            Ck = 0;
            if (0 !== (K & 6)) throw Error(p(327));
            var c = a.callbackNode;
            if (Ik() && a.callbackNode !== c) return null;
            var d = uc(a, a === R ? Z : 0);
            if (0 === d) return null;
            if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Jk(a, d);else {
              b = d;
              var e = K;
              K |= 2;
              var f = Kk();
              if (R !== a || Z !== b) vk = null, Hj = B() + 500, Lk(a, b);
              do try {
                Mk();
                break;
              } catch (h) {
                Nk(a, h);
              } while (1);
              Qg();
              nk.current = f;
              K = e;
              null !== Y ? b = 0 : (R = null, Z = 0, b = T);
            }
            if (0 !== b) {
              2 === b && (e = xc(a), 0 !== e && (d = e, b = Ok(a, e)));
              if (1 === b) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
              if (6 === b) Dk(a, d);else {
                e = a.current.alternate;
                if (0 === (d & 30) && !Pk(e) && (b = Jk(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Ok(a, f))), 1 === b)) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
                a.finishedWork = e;
                a.finishedLanes = d;
                switch (b) {
                  case 0:
                  case 1:
                    throw Error(p(345));
                  case 2:
                    Qk(a, uk, vk);
                    break;
                  case 3:
                    Dk(a, d);
                    if ((d & 130023424) === d && (b = gk + 500 - B(), 10 < b)) {
                      if (0 !== uc(a, 0)) break;
                      e = a.suspendedLanes;
                      if ((e & d) !== d) {
                        L();
                        a.pingedLanes |= a.suspendedLanes & e;
                        break;
                      }
                      a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
                      break;
                    }
                    Qk(a, uk, vk);
                    break;
                  case 4:
                    Dk(a, d);
                    if ((d & 4194240) === d) break;
                    b = a.eventTimes;
                    for (e = -1; 0 < d;) {
                      var g = 31 - oc(d);
                      f = 1 << g;
                      g = b[g];
                      g > e && (e = g);
                      d &= ~f;
                    }
                    d = e;
                    d = B() - d;
                    d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3E3 > d ? 3E3 : 4320 > d ? 4320 : 1960 * mk(d / 1960)) - d;
                    if (10 < d) {
                      a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d);
                      break;
                    }
                    Qk(a, uk, vk);
                    break;
                  case 5:
                    Qk(a, uk, vk);
                    break;
                  default:
                    throw Error(p(329));
                }
              }
            }
            Ek(a, B());
            return a.callbackNode === c ? Hk.bind(null, a) : null;
          }
          function Ok(a, b) {
            var c = tk;
            a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
            a = Jk(a, b);
            2 !== a && (b = uk, uk = c, null !== b && Gj(b));
            return a;
          }
          function Gj(a) {
            null === uk ? uk = a : uk.push.apply(uk, a);
          }
          function Pk(a) {
            for (var b = a;;) {
              if (b.flags & 16384) {
                var c = b.updateQueue;
                if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
                  var e = c[d],
                    f = e.getSnapshot;
                  e = e.value;
                  try {
                    if (!He(f(), e)) return !1;
                  } catch (g) {
                    return false;
                  }
                }
              }
              c = b.child;
              if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;else {
                if (b === a) break;
                for (; null === b.sibling;) {
                  if (null === b.return || b.return === a) return true;
                  b = b.return;
                }
                b.sibling.return = b.return;
                b = b.sibling;
              }
            }
            return true;
          }
          function Dk(a, b) {
            b &= ~sk;
            b &= ~rk;
            a.suspendedLanes |= b;
            a.pingedLanes &= ~b;
            for (a = a.expirationTimes; 0 < b;) {
              var c = 31 - oc(b),
                d = 1 << c;
              a[c] = -1;
              b &= ~d;
            }
          }
          function Fk(a) {
            if (0 !== (K & 6)) throw Error(p(327));
            Ik();
            var b = uc(a, 0);
            if (0 === (b & 1)) return Ek(a, B()), null;
            var c = Jk(a, b);
            if (0 !== a.tag && 2 === c) {
              var d = xc(a);
              0 !== d && (b = d, c = Ok(a, d));
            }
            if (1 === c) throw c = qk, Lk(a, 0), Dk(a, b), Ek(a, B()), c;
            if (6 === c) throw Error(p(345));
            a.finishedWork = a.current.alternate;
            a.finishedLanes = b;
            Qk(a, uk, vk);
            Ek(a, B());
            return null;
          }
          function Rk(a, b) {
            var c = K;
            K |= 1;
            try {
              return a(b);
            } finally {
              K = c, 0 === K && (Hj = B() + 500, fg && jg());
            }
          }
          function Sk(a) {
            null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
            var b = K;
            K |= 1;
            var c = pk.transition,
              d = C;
            try {
              if (pk.transition = null, C = 1, a) return a();
            } finally {
              C = d, pk.transition = c, K = b, 0 === (K & 6) && jg();
            }
          }
          function Ij() {
            gj = fj.current;
            E(fj);
          }
          function Lk(a, b) {
            a.finishedWork = null;
            a.finishedLanes = 0;
            var c = a.timeoutHandle;
            -1 !== c && (a.timeoutHandle = -1, Gf(c));
            if (null !== Y) for (c = Y.return; null !== c;) {
              var d = c;
              wg(d);
              switch (d.tag) {
                case 1:
                  d = d.type.childContextTypes;
                  null !== d && void 0 !== d && $f();
                  break;
                case 3:
                  Jh();
                  E(Wf);
                  E(H);
                  Oh();
                  break;
                case 5:
                  Lh(d);
                  break;
                case 4:
                  Jh();
                  break;
                case 13:
                  E(M);
                  break;
                case 19:
                  E(M);
                  break;
                case 10:
                  Rg(d.type._context);
                  break;
                case 22:
                case 23:
                  Ij();
              }
              c = c.return;
            }
            R = a;
            Y = a = wh(a.current, null);
            Z = gj = b;
            T = 0;
            qk = null;
            sk = rk = hh = 0;
            uk = tk = null;
            if (null !== Wg) {
              for (b = 0; b < Wg.length; b++) if (c = Wg[b], d = c.interleaved, null !== d) {
                c.interleaved = null;
                var e = d.next,
                  f = c.pending;
                if (null !== f) {
                  var g = f.next;
                  f.next = e;
                  d.next = g;
                }
                c.pending = d;
              }
              Wg = null;
            }
            return a;
          }
          function Nk(a, b) {
            do {
              var c = Y;
              try {
                Qg();
                Ph.current = ai;
                if (Sh) {
                  for (var d = N.memoizedState; null !== d;) {
                    var e = d.queue;
                    null !== e && (e.pending = null);
                    d = d.next;
                  }
                  Sh = !1;
                }
                Rh = 0;
                P = O = N = null;
                Th = !1;
                Uh = 0;
                ok.current = null;
                if (null === c || null === c.return) {
                  T = 1;
                  qk = b;
                  Y = null;
                  break;
                }
                a: {
                  var f = a,
                    g = c.return,
                    h = c,
                    k = b;
                  b = Z;
                  h.flags |= 32768;
                  if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                    var l = k,
                      m = h,
                      q = m.tag;
                    if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                      var r = m.alternate;
                      r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
                    }
                    var y = Vi(g);
                    if (null !== y) {
                      y.flags &= -257;
                      Wi(y, g, h, f, b);
                      y.mode & 1 && Ti(f, l, b);
                      b = y;
                      k = l;
                      var n = b.updateQueue;
                      if (null === n) {
                        var t = new Set();
                        t.add(k);
                        b.updateQueue = t;
                      } else n.add(k);
                      break a;
                    } else {
                      if (0 === (b & 1)) {
                        Ti(f, l, b);
                        uj();
                        break a;
                      }
                      k = Error(p(426));
                    }
                  } else if (I && h.mode & 1) {
                    var J = Vi(g);
                    if (null !== J) {
                      0 === (J.flags & 65536) && (J.flags |= 256);
                      Wi(J, g, h, f, b);
                      Jg(Ki(k, h));
                      break a;
                    }
                  }
                  f = k = Ki(k, h);
                  4 !== T && (T = 2);
                  null === tk ? tk = [f] : tk.push(f);
                  f = g;
                  do {
                    switch (f.tag) {
                      case 3:
                        f.flags |= 65536;
                        b &= -b;
                        f.lanes |= b;
                        var x = Oi(f, k, b);
                        fh(f, x);
                        break a;
                      case 1:
                        h = k;
                        var w = f.type,
                          u = f.stateNode;
                        if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Si || !Si.has(u)))) {
                          f.flags |= 65536;
                          b &= -b;
                          f.lanes |= b;
                          var F = Ri(f, h, b);
                          fh(f, F);
                          break a;
                        }
                    }
                    f = f.return;
                  } while (null !== f);
                }
                Tk(c);
              } catch (na) {
                b = na;
                Y === c && null !== c && (Y = c = c.return);
                continue;
              }
              break;
            } while (1);
          }
          function Kk() {
            var a = nk.current;
            nk.current = ai;
            return null === a ? ai : a;
          }
          function uj() {
            if (0 === T || 3 === T || 2 === T) T = 4;
            null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
          }
          function Jk(a, b) {
            var c = K;
            K |= 2;
            var d = Kk();
            if (R !== a || Z !== b) vk = null, Lk(a, b);
            do try {
              Uk();
              break;
            } catch (e) {
              Nk(a, e);
            } while (1);
            Qg();
            K = c;
            nk.current = d;
            if (null !== Y) throw Error(p(261));
            R = null;
            Z = 0;
            return T;
          }
          function Uk() {
            for (; null !== Y;) Vk(Y);
          }
          function Mk() {
            for (; null !== Y && !cc();) Vk(Y);
          }
          function Vk(a) {
            var b = Wk(a.alternate, a, gj);
            a.memoizedProps = a.pendingProps;
            null === b ? Tk(a) : Y = b;
            ok.current = null;
          }
          function Tk(a) {
            var b = a;
            do {
              var c = b.alternate;
              a = b.return;
              if (0 === (b.flags & 32768)) {
                if (c = Fj(c, b, gj), null !== c) {
                  Y = c;
                  return;
                }
              } else {
                c = Jj(c, b);
                if (null !== c) {
                  c.flags &= 32767;
                  Y = c;
                  return;
                }
                if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;else {
                  T = 6;
                  Y = null;
                  return;
                }
              }
              b = b.sibling;
              if (null !== b) {
                Y = b;
                return;
              }
              Y = b = a;
            } while (null !== b);
            0 === T && (T = 5);
          }
          function Qk(a, b, c) {
            var d = C,
              e = pk.transition;
            try {
              pk.transition = null, C = 1, Xk(a, b, c, d);
            } finally {
              pk.transition = e, C = d;
            }
            return null;
          }
          function Xk(a, b, c, d) {
            do Ik(); while (null !== xk);
            if (0 !== (K & 6)) throw Error(p(327));
            c = a.finishedWork;
            var e = a.finishedLanes;
            if (null === c) return null;
            a.finishedWork = null;
            a.finishedLanes = 0;
            if (c === a.current) throw Error(p(177));
            a.callbackNode = null;
            a.callbackPriority = 0;
            var f = c.lanes | c.childLanes;
            Bc(a, f);
            a === R && (Y = R = null, Z = 0);
            0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = true, Gk(hc, function () {
              Ik();
              return null;
            }));
            f = 0 !== (c.flags & 15990);
            if (0 !== (c.subtreeFlags & 15990) || f) {
              f = pk.transition;
              pk.transition = null;
              var g = C;
              C = 1;
              var h = K;
              K |= 4;
              ok.current = null;
              Pj(a, c);
              ek(c, a);
              Oe(Df);
              dd = !!Cf;
              Df = Cf = null;
              a.current = c;
              ik(c);
              dc();
              K = h;
              C = g;
              pk.transition = f;
            } else a.current = c;
            wk && (wk = false, xk = a, yk = e);
            f = a.pendingLanes;
            0 === f && (Si = null);
            mc(c.stateNode);
            Ek(a, B());
            if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, {
              componentStack: e.stack,
              digest: e.digest
            });
            if (Pi) throw Pi = false, a = Qi, Qi = null, a;
            0 !== (yk & 1) && 0 !== a.tag && Ik();
            f = a.pendingLanes;
            0 !== (f & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
            jg();
            return null;
          }
          function Ik() {
            if (null !== xk) {
              var a = Dc(yk),
                b = pk.transition,
                c = C;
              try {
                pk.transition = null;
                C = 16 > a ? 16 : a;
                if (null === xk) var d = !1;else {
                  a = xk;
                  xk = null;
                  yk = 0;
                  if (0 !== (K & 6)) throw Error(p(331));
                  var e = K;
                  K |= 4;
                  for (V = a.current; null !== V;) {
                    var f = V,
                      g = f.child;
                    if (0 !== (V.flags & 16)) {
                      var h = f.deletions;
                      if (null !== h) {
                        for (var k = 0; k < h.length; k++) {
                          var l = h[k];
                          for (V = l; null !== V;) {
                            var m = V;
                            switch (m.tag) {
                              case 0:
                              case 11:
                              case 15:
                                Qj(8, m, f);
                            }
                            var q = m.child;
                            if (null !== q) q.return = m, V = q;else for (; null !== V;) {
                              m = V;
                              var r = m.sibling,
                                y = m.return;
                              Tj(m);
                              if (m === l) {
                                V = null;
                                break;
                              }
                              if (null !== r) {
                                r.return = y;
                                V = r;
                                break;
                              }
                              V = y;
                            }
                          }
                        }
                        var n = f.alternate;
                        if (null !== n) {
                          var t = n.child;
                          if (null !== t) {
                            n.child = null;
                            do {
                              var J = t.sibling;
                              t.sibling = null;
                              t = J;
                            } while (null !== t);
                          }
                        }
                        V = f;
                      }
                    }
                    if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;else b: for (; null !== V;) {
                      f = V;
                      if (0 !== (f.flags & 2048)) switch (f.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, f, f.return);
                      }
                      var x = f.sibling;
                      if (null !== x) {
                        x.return = f.return;
                        V = x;
                        break b;
                      }
                      V = f.return;
                    }
                  }
                  var w = a.current;
                  for (V = w; null !== V;) {
                    g = V;
                    var u = g.child;
                    if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;else b: for (g = w; null !== V;) {
                      h = V;
                      if (0 !== (h.flags & 2048)) try {
                        switch (h.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Rj(9, h);
                        }
                      } catch (na) {
                        W(h, h.return, na);
                      }
                      if (h === g) {
                        V = null;
                        break b;
                      }
                      var F = h.sibling;
                      if (null !== F) {
                        F.return = h.return;
                        V = F;
                        break b;
                      }
                      V = h.return;
                    }
                  }
                  K = e;
                  jg();
                  if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                    lc.onPostCommitFiberRoot(kc, a);
                  } catch (na) {}
                  d = !0;
                }
                return d;
              } finally {
                C = c, pk.transition = b;
              }
            }
            return false;
          }
          function Yk(a, b, c) {
            b = Ki(c, b);
            b = Oi(a, b, 1);
            a = dh(a, b, 1);
            b = L();
            null !== a && (Ac(a, 1, b), Ek(a, b));
          }
          function W(a, b, c) {
            if (3 === a.tag) Yk(a, a, c);else for (; null !== b;) {
              if (3 === b.tag) {
                Yk(b, a, c);
                break;
              } else if (1 === b.tag) {
                var d = b.stateNode;
                if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Si || !Si.has(d))) {
                  a = Ki(c, a);
                  a = Ri(b, a, 1);
                  b = dh(b, a, 1);
                  a = L();
                  null !== b && (Ac(b, 1, a), Ek(b, a));
                  break;
                }
              }
              b = b.return;
            }
          }
          function Ui(a, b, c) {
            var d = a.pingCache;
            null !== d && d.delete(b);
            b = L();
            a.pingedLanes |= a.suspendedLanes & c;
            R === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c);
            Ek(a, b);
          }
          function Zk(a, b) {
            0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
            var c = L();
            a = Zg(a, b);
            null !== a && (Ac(a, b, c), Ek(a, c));
          }
          function vj(a) {
            var b = a.memoizedState,
              c = 0;
            null !== b && (c = b.retryLane);
            Zk(a, c);
          }
          function ck(a, b) {
            var c = 0;
            switch (a.tag) {
              case 13:
                var d = a.stateNode;
                var e = a.memoizedState;
                null !== e && (c = e.retryLane);
                break;
              case 19:
                d = a.stateNode;
                break;
              default:
                throw Error(p(314));
            }
            null !== d && d.delete(b);
            Zk(a, c);
          }
          var Wk;
          Wk = function (a, b, c) {
            if (null !== a) {
              if (a.memoizedProps !== b.pendingProps || Wf.current) Ug = true;else {
                if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return Ug = false, zj(a, b, c);
                Ug = 0 !== (a.flags & 131072) ? true : false;
              }
            } else Ug = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
            b.lanes = 0;
            switch (b.tag) {
              case 2:
                var d = b.type;
                jj(a, b);
                a = b.pendingProps;
                var e = Yf(b, H.current);
                Tg(b, c);
                e = Xh(null, b, d, a, e, c);
                var f = bi();
                b.flags |= 1;
                "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ah(b), e.updater = nh, b.stateNode = e, e._reactInternals = b, rh(b, d, a, c), b = kj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Yi(null, b, e, c), b = b.child);
                return b;
              case 16:
                d = b.elementType;
                a: {
                  jj(a, b);
                  a = b.pendingProps;
                  e = d._init;
                  d = e(d._payload);
                  b.type = d;
                  e = b.tag = $k(d);
                  a = Lg(d, a);
                  switch (e) {
                    case 0:
                      b = dj(null, b, d, a, c);
                      break a;
                    case 1:
                      b = ij(null, b, d, a, c);
                      break a;
                    case 11:
                      b = Zi(null, b, d, a, c);
                      break a;
                    case 14:
                      b = aj(null, b, d, Lg(d.type, a), c);
                      break a;
                  }
                  throw Error(p(306, d, ""));
                }
                return b;
              case 0:
                return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), dj(a, b, d, e, c);
              case 1:
                return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), ij(a, b, d, e, c);
              case 3:
                a: {
                  lj(b);
                  if (null === a) throw Error(p(387));
                  d = b.pendingProps;
                  f = b.memoizedState;
                  e = f.element;
                  bh(a, b);
                  gh(b, d, null, c);
                  var g = b.memoizedState;
                  d = g.element;
                  if (f.isDehydrated) {
                    if (f = {
                      element: d,
                      isDehydrated: false,
                      cache: g.cache,
                      pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
                      transitions: g.transitions
                    }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                      e = Ki(Error(p(423)), b);
                      b = mj(a, b, d, c, e);
                      break a;
                    } else if (d !== e) {
                      e = Ki(Error(p(424)), b);
                      b = mj(a, b, d, c, e);
                      break a;
                    } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Ch(b, null, d, c), b.child = c; c;) c.flags = c.flags & -3 | 4096, c = c.sibling;
                  } else {
                    Ig();
                    if (d === e) {
                      b = $i(a, b, c);
                      break a;
                    }
                    Yi(a, b, d, c);
                  }
                  b = b.child;
                }
                return b;
              case 5:
                return Kh(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), hj(a, b), Yi(a, b, g, c), b.child;
              case 6:
                return null === a && Eg(b), null;
              case 13:
                return pj(a, b, c);
              case 4:
                return Ih(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Bh(b, null, d, c) : Yi(a, b, d, c), b.child;
              case 11:
                return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), Zi(a, b, d, e, c);
              case 7:
                return Yi(a, b, b.pendingProps, c), b.child;
              case 8:
                return Yi(a, b, b.pendingProps.children, c), b.child;
              case 12:
                return Yi(a, b, b.pendingProps.children, c), b.child;
              case 10:
                a: {
                  d = b.type._context;
                  e = b.pendingProps;
                  f = b.memoizedProps;
                  g = e.value;
                  G(Mg, d._currentValue);
                  d._currentValue = g;
                  if (null !== f) if (He(f.value, g)) {
                    if (f.children === e.children && !Wf.current) {
                      b = $i(a, b, c);
                      break a;
                    }
                  } else for (f = b.child, null !== f && (f.return = b); null !== f;) {
                    var h = f.dependencies;
                    if (null !== h) {
                      g = f.child;
                      for (var k = h.firstContext; null !== k;) {
                        if (k.context === d) {
                          if (1 === f.tag) {
                            k = ch(-1, c & -c);
                            k.tag = 2;
                            var l = f.updateQueue;
                            if (null !== l) {
                              l = l.shared;
                              var m = l.pending;
                              null === m ? k.next = k : (k.next = m.next, m.next = k);
                              l.pending = k;
                            }
                          }
                          f.lanes |= c;
                          k = f.alternate;
                          null !== k && (k.lanes |= c);
                          Sg(f.return, c, b);
                          h.lanes |= c;
                          break;
                        }
                        k = k.next;
                      }
                    } else if (10 === f.tag) g = f.type === b.type ? null : f.child;else if (18 === f.tag) {
                      g = f.return;
                      if (null === g) throw Error(p(341));
                      g.lanes |= c;
                      h = g.alternate;
                      null !== h && (h.lanes |= c);
                      Sg(g, c, b);
                      g = f.sibling;
                    } else g = f.child;
                    if (null !== g) g.return = f;else for (g = f; null !== g;) {
                      if (g === b) {
                        g = null;
                        break;
                      }
                      f = g.sibling;
                      if (null !== f) {
                        f.return = g.return;
                        g = f;
                        break;
                      }
                      g = g.return;
                    }
                    f = g;
                  }
                  Yi(a, b, e.children, c);
                  b = b.child;
                }
                return b;
              case 9:
                return e = b.type, d = b.pendingProps.children, Tg(b, c), e = Vg(e), d = d(e), b.flags |= 1, Yi(a, b, d, c), b.child;
              case 14:
                return d = b.type, e = Lg(d, b.pendingProps), e = Lg(d.type, e), aj(a, b, d, e, c);
              case 15:
                return cj(a, b, b.type, b.pendingProps, c);
              case 17:
                return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), jj(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, Tg(b, c), ph(b, d, e), rh(b, d, e, c), kj(null, b, d, true, a, c);
              case 19:
                return yj(a, b, c);
              case 22:
                return ej(a, b, c);
            }
            throw Error(p(156, b.tag));
          };
          function Gk(a, b) {
            return ac(a, b);
          }
          function al(a, b, c, d) {
            this.tag = a;
            this.key = c;
            this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = b;
            this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
            this.mode = d;
            this.subtreeFlags = this.flags = 0;
            this.deletions = null;
            this.childLanes = this.lanes = 0;
            this.alternate = null;
          }
          function Bg(a, b, c, d) {
            return new al(a, b, c, d);
          }
          function bj(a) {
            a = a.prototype;
            return !(!a || !a.isReactComponent);
          }
          function $k(a) {
            if ("function" === typeof a) return bj(a) ? 1 : 0;
            if (void 0 !== a && null !== a) {
              a = a.$$typeof;
              if (a === Da) return 11;
              if (a === Ga) return 14;
            }
            return 2;
          }
          function wh(a, b) {
            var c = a.alternate;
            null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
            c.flags = a.flags & 14680064;
            c.childLanes = a.childLanes;
            c.lanes = a.lanes;
            c.child = a.child;
            c.memoizedProps = a.memoizedProps;
            c.memoizedState = a.memoizedState;
            c.updateQueue = a.updateQueue;
            b = a.dependencies;
            c.dependencies = null === b ? null : {
              lanes: b.lanes,
              firstContext: b.firstContext
            };
            c.sibling = a.sibling;
            c.index = a.index;
            c.ref = a.ref;
            return c;
          }
          function yh(a, b, c, d, e, f) {
            var g = 2;
            d = a;
            if ("function" === typeof a) bj(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {
              case ya:
                return Ah(c.children, e, f, b);
              case za:
                g = 8;
                e |= 8;
                break;
              case Aa:
                return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
              case Ea:
                return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
              case Fa:
                return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
              case Ia:
                return qj(c, e, f, b);
              default:
                if ("object" === typeof a && null !== a) switch (a.$$typeof) {
                  case Ba:
                    g = 10;
                    break a;
                  case Ca:
                    g = 9;
                    break a;
                  case Da:
                    g = 11;
                    break a;
                  case Ga:
                    g = 14;
                    break a;
                  case Ha:
                    g = 16;
                    d = null;
                    break a;
                }
                throw Error(p(130, null == a ? a : typeof a, ""));
            }
            b = Bg(g, c, b, e);
            b.elementType = a;
            b.type = d;
            b.lanes = f;
            return b;
          }
          function Ah(a, b, c, d) {
            a = Bg(7, a, d, b);
            a.lanes = c;
            return a;
          }
          function qj(a, b, c, d) {
            a = Bg(22, a, d, b);
            a.elementType = Ia;
            a.lanes = c;
            a.stateNode = {
              isHidden: false
            };
            return a;
          }
          function xh(a, b, c) {
            a = Bg(6, a, null, b);
            a.lanes = c;
            return a;
          }
          function zh(a, b, c) {
            b = Bg(4, null !== a.children ? a.children : [], a.key, b);
            b.lanes = c;
            b.stateNode = {
              containerInfo: a.containerInfo,
              pendingChildren: null,
              implementation: a.implementation
            };
            return b;
          }
          function bl(a, b, c, d, e) {
            this.tag = b;
            this.containerInfo = a;
            this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
            this.timeoutHandle = -1;
            this.callbackNode = this.pendingContext = this.context = null;
            this.callbackPriority = 0;
            this.eventTimes = zc(0);
            this.expirationTimes = zc(-1);
            this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
            this.entanglements = zc(0);
            this.identifierPrefix = d;
            this.onRecoverableError = e;
            this.mutableSourceEagerHydrationData = null;
          }
          function cl(a, b, c, d, e, f, g, h, k) {
            a = new bl(a, b, c, h, k);
            1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
            f = Bg(3, null, null, b);
            a.current = f;
            f.stateNode = a;
            f.memoizedState = {
              element: d,
              isDehydrated: c,
              cache: null,
              transitions: null,
              pendingSuspenseBoundaries: null
            };
            ah(f);
            return a;
          }
          function dl(a, b, c) {
            var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
            return {
              $$typeof: wa,
              key: null == d ? null : "" + d,
              children: a,
              containerInfo: b,
              implementation: c
            };
          }
          function el(a) {
            if (!a) return Vf;
            a = a._reactInternals;
            a: {
              if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
              var b = a;
              do {
                switch (b.tag) {
                  case 3:
                    b = b.stateNode.context;
                    break a;
                  case 1:
                    if (Zf(b.type)) {
                      b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                      break a;
                    }
                }
                b = b.return;
              } while (null !== b);
              throw Error(p(171));
            }
            if (1 === a.tag) {
              var c = a.type;
              if (Zf(c)) return bg(a, c, b);
            }
            return b;
          }
          function fl(a, b, c, d, e, f, g, h, k) {
            a = cl(c, d, true, a, e, f, g, h, k);
            a.context = el(null);
            c = a.current;
            d = L();
            e = lh(c);
            f = ch(d, e);
            f.callback = void 0 !== b && null !== b ? b : null;
            dh(c, f, e);
            a.current.lanes = e;
            Ac(a, e, d);
            Ek(a, d);
            return a;
          }
          function gl(a, b, c, d) {
            var e = b.current,
              f = L(),
              g = lh(e);
            c = el(c);
            null === b.context ? b.context = c : b.pendingContext = c;
            b = ch(f, g);
            b.payload = {
              element: a
            };
            d = void 0 === d ? null : d;
            null !== d && (b.callback = d);
            a = dh(e, b, g);
            null !== a && (mh(a, e, g, f), eh(a, e, g));
            return g;
          }
          function hl(a) {
            a = a.current;
            if (!a.child) return null;
            switch (a.child.tag) {
              case 5:
                return a.child.stateNode;
              default:
                return a.child.stateNode;
            }
          }
          function il(a, b) {
            a = a.memoizedState;
            if (null !== a && null !== a.dehydrated) {
              var c = a.retryLane;
              a.retryLane = 0 !== c && c < b ? c : b;
            }
          }
          function jl(a, b) {
            il(a, b);
            (a = a.alternate) && il(a, b);
          }
          function kl() {
            return null;
          }
          var ll = "function" === typeof reportError ? reportError : function (a) {
            console.error(a);
          };
          function ml(a) {
            this._internalRoot = a;
          }
          nl.prototype.render = ml.prototype.render = function (a) {
            var b = this._internalRoot;
            if (null === b) throw Error(p(409));
            gl(a, b, null, null);
          };
          nl.prototype.unmount = ml.prototype.unmount = function () {
            var a = this._internalRoot;
            if (null !== a) {
              this._internalRoot = null;
              var b = a.containerInfo;
              Sk(function () {
                gl(null, a, null, null);
              });
              b[uf] = null;
            }
          };
          function nl(a) {
            this._internalRoot = a;
          }
          nl.prototype.unstable_scheduleHydration = function (a) {
            if (a) {
              var b = Hc();
              a = {
                blockedOn: null,
                target: a,
                priority: b
              };
              for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++);
              Qc.splice(c, 0, a);
              0 === c && Vc(a);
            }
          };
          function ol(a) {
            return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
          }
          function pl(a) {
            return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
          }
          function ql() {}
          function rl(a, b, c, d, e) {
            if (e) {
              if ("function" === typeof d) {
                var f = d;
                d = function () {
                  var a = hl(g);
                  f.call(a);
                };
              }
              var g = fl(b, d, a, 0, null, false, false, "", ql);
              a._reactRootContainer = g;
              a[uf] = g.current;
              sf(8 === a.nodeType ? a.parentNode : a);
              Sk();
              return g;
            }
            for (; e = a.lastChild;) a.removeChild(e);
            if ("function" === typeof d) {
              var h = d;
              d = function () {
                var a = hl(k);
                h.call(a);
              };
            }
            var k = cl(a, 0, false, null, null, false, false, "", ql);
            a._reactRootContainer = k;
            a[uf] = k.current;
            sf(8 === a.nodeType ? a.parentNode : a);
            Sk(function () {
              gl(b, k, c, d);
            });
            return k;
          }
          function sl(a, b, c, d, e) {
            var f = c._reactRootContainer;
            if (f) {
              var g = f;
              if ("function" === typeof e) {
                var h = e;
                e = function () {
                  var a = hl(g);
                  h.call(a);
                };
              }
              gl(b, g, a, e);
            } else g = rl(c, b, a, e, d);
            return hl(g);
          }
          Ec = function (a) {
            switch (a.tag) {
              case 3:
                var b = a.stateNode;
                if (b.current.memoizedState.isDehydrated) {
                  var c = tc(b.pendingLanes);
                  0 !== c && (Cc(b, c | 1), Ek(b, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
                }
                break;
              case 13:
                Sk(function () {
                  var b = Zg(a, 1);
                  if (null !== b) {
                    var c = L();
                    mh(b, a, 1, c);
                  }
                }), jl(a, 1);
            }
          };
          Fc = function (a) {
            if (13 === a.tag) {
              var b = Zg(a, 134217728);
              if (null !== b) {
                var c = L();
                mh(b, a, 134217728, c);
              }
              jl(a, 134217728);
            }
          };
          Gc = function (a) {
            if (13 === a.tag) {
              var b = lh(a),
                c = Zg(a, b);
              if (null !== c) {
                var d = L();
                mh(c, a, b, d);
              }
              jl(a, b);
            }
          };
          Hc = function () {
            return C;
          };
          Ic = function (a, b) {
            var c = C;
            try {
              return C = a, b();
            } finally {
              C = c;
            }
          };
          yb = function (a, b, c) {
            switch (b) {
              case "input":
                bb(a, c);
                b = c.name;
                if ("radio" === c.type && null != b) {
                  for (c = a; c.parentNode;) c = c.parentNode;
                  c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
                  for (b = 0; b < c.length; b++) {
                    var d = c[b];
                    if (d !== a && d.form === a.form) {
                      var e = Db(d);
                      if (!e) throw Error(p(90));
                      Wa(d);
                      bb(d, e);
                    }
                  }
                }
                break;
              case "textarea":
                ib(a, c);
                break;
              case "select":
                b = c.value, null != b && fb(a, !!c.multiple, b, false);
            }
          };
          Gb = Rk;
          Hb = Sk;
          var tl = {
              usingClientEntryPoint: false,
              Events: [Cb, ue, Db, Eb, Fb, Rk]
            },
            ul = {
              findFiberByHostInstance: Wc,
              bundleType: 0,
              version: "18.2.0",
              rendererPackageName: "react-dom"
            };
          var vl = {
            bundleType: ul.bundleType,
            version: ul.version,
            rendererPackageName: ul.rendererPackageName,
            rendererConfig: ul.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: ua.ReactCurrentDispatcher,
            findHostInstanceByFiber: function (a) {
              a = Zb(a);
              return null === a ? null : a.stateNode;
            },
            findFiberByHostInstance: ul.findFiberByHostInstance || kl,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
          };
          if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
            var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (!wl.isDisabled && wl.supportsFiber) try {
              kc = wl.inject(vl), lc = wl;
            } catch (a) {}
          }
          reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
          reactDom_production_min.createPortal = function (a, b) {
            var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
            if (!ol(b)) throw Error(p(200));
            return dl(a, b, null, c);
          };
          reactDom_production_min.createRoot = function (a, b) {
            if (!ol(a)) throw Error(p(299));
            var c = false,
              d = "",
              e = ll;
            null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
            b = cl(a, 1, false, null, null, c, false, d, e);
            a[uf] = b.current;
            sf(8 === a.nodeType ? a.parentNode : a);
            return new ml(b);
          };
          reactDom_production_min.findDOMNode = function (a) {
            if (null == a) return null;
            if (1 === a.nodeType) return a;
            var b = a._reactInternals;
            if (void 0 === b) {
              if ("function" === typeof a.render) throw Error(p(188));
              a = Object.keys(a).join(",");
              throw Error(p(268, a));
            }
            a = Zb(b);
            a = null === a ? null : a.stateNode;
            return a;
          };
          reactDom_production_min.flushSync = function (a) {
            return Sk(a);
          };
          reactDom_production_min.hydrate = function (a, b, c) {
            if (!pl(b)) throw Error(p(200));
            return sl(null, a, b, true, c);
          };
          reactDom_production_min.hydrateRoot = function (a, b, c) {
            if (!ol(a)) throw Error(p(405));
            var d = null != c && c.hydratedSources || null,
              e = false,
              f = "",
              g = ll;
            null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
            b = fl(b, null, a, 1, null != c ? c : null, e, false, f, g);
            a[uf] = b.current;
            sf(a);
            if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(c, e);
            return new nl(b);
          };
          reactDom_production_min.render = function (a, b, c) {
            if (!pl(b)) throw Error(p(200));
            return sl(null, a, b, false, c);
          };
          reactDom_production_min.unmountComponentAtNode = function (a) {
            if (!pl(a)) throw Error(p(40));
            return a._reactRootContainer ? (Sk(function () {
              sl(null, null, a, !1, function () {
                a._reactRootContainer = null;
                a[uf] = null;
              });
            }), true) : false;
          };
          reactDom_production_min.unstable_batchedUpdates = Rk;
          reactDom_production_min.unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
            if (!pl(c)) throw Error(p(200));
            if (null == a || void 0 === a._reactInternals) throw Error(p(38));
            return sl(a, b, c, false, d);
          };
          reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
          return reactDom_production_min;
        }
        var hasRequiredReactDom;
        function requireReactDom() {
          if (hasRequiredReactDom) return reactDom.exports;
          hasRequiredReactDom = 1;
          function checkDCE() {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
              return;
            }
            try {
              __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
            } catch (err) {
              console.error(err);
            }
          }
          {
            checkDCE();
            reactDom.exports = requireReactDom_production_min();
          }
          return reactDom.exports;
        }
        var hasRequiredClient;
        function requireClient() {
          if (hasRequiredClient) return client;
          hasRequiredClient = 1;
          var m = requireReactDom();
          {
            client.createRoot = m.createRoot;
            client.hydrateRoot = m.hydrateRoot;
          }
          return client;
        }
        var clientExports = exports("V", requireClient());
        var shim = {
          exports: {}
        };
        var useSyncExternalStoreShim_production = {};

        /**
         * @license React
         * use-sync-external-store-shim.production.js
         *
         * Copyright (c) Meta Platforms, Inc. and affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var hasRequiredUseSyncExternalStoreShim_production;
        function requireUseSyncExternalStoreShim_production() {
          if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
          hasRequiredUseSyncExternalStoreShim_production = 1;
          var React = requireReact();
          function is(x, y) {
            return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = "function" === typeof Object.is ? Object.is : is,
            useState = React.useState,
            useEffect = React.useEffect,
            useLayoutEffect = React.useLayoutEffect,
            useDebugValue = React.useDebugValue;
          function useSyncExternalStore$2(subscribe, getSnapshot) {
            var value = getSnapshot(),
              _useState = useState({
                inst: {
                  value: value,
                  getSnapshot: getSnapshot
                }
              }),
              inst = _useState[0].inst,
              forceUpdate = _useState[1];
            useLayoutEffect(function () {
              inst.value = value;
              inst.getSnapshot = getSnapshot;
              checkIfSnapshotChanged(inst) && forceUpdate({
                inst: inst
              });
            }, [subscribe, value, getSnapshot]);
            useEffect(function () {
              checkIfSnapshotChanged(inst) && forceUpdate({
                inst: inst
              });
              return subscribe(function () {
                checkIfSnapshotChanged(inst) && forceUpdate({
                  inst: inst
                });
              });
            }, [subscribe]);
            useDebugValue(value);
            return value;
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            inst = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(inst, nextValue);
            } catch (error) {
              return true;
            }
          }
          function useSyncExternalStore$1(subscribe, getSnapshot) {
            return getSnapshot();
          }
          var shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
          useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
          return useSyncExternalStoreShim_production;
        }
        var hasRequiredShim;
        function requireShim() {
          if (hasRequiredShim) return shim.exports;
          hasRequiredShim = 1;
          {
            shim.exports = requireUseSyncExternalStoreShim_production();
          }
          return shim.exports;
        }
        requireShim();
        var withSelector = {
          exports: {}
        };
        var withSelector_production = {};

        /**
         * @license React
         * use-sync-external-store-shim/with-selector.production.js
         *
         * Copyright (c) Meta Platforms, Inc. and affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var hasRequiredWithSelector_production;
        function requireWithSelector_production() {
          if (hasRequiredWithSelector_production) return withSelector_production;
          hasRequiredWithSelector_production = 1;
          var React = requireReact(),
            shim = requireShim();
          function is(x, y) {
            return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = "function" === typeof Object.is ? Object.is : is,
            useSyncExternalStore = shim.useSyncExternalStore,
            useRef = React.useRef,
            useEffect = React.useEffect,
            useMemo = React.useMemo,
            useDebugValue = React.useDebugValue;
          withSelector_production.useSyncExternalStoreWithSelector = function (subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
            var instRef = useRef(null);
            if (null === instRef.current) {
              var inst = {
                hasValue: false,
                value: null
              };
              instRef.current = inst;
            } else inst = instRef.current;
            instRef = useMemo(function () {
              function memoizedSelector(nextSnapshot) {
                if (!hasMemo) {
                  hasMemo = true;
                  memoizedSnapshot = nextSnapshot;
                  nextSnapshot = selector(nextSnapshot);
                  if (void 0 !== isEqual && inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
                  }
                  return memoizedSelection = nextSnapshot;
                }
                currentSelection = memoizedSelection;
                if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
                var nextSelection = selector(nextSnapshot);
                if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
                memoizedSnapshot = nextSnapshot;
                return memoizedSelection = nextSelection;
              }
              var hasMemo = false,
                memoizedSnapshot,
                memoizedSelection,
                maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
              return [function () {
                return memoizedSelector(getSnapshot());
              }, null === maybeGetServerSnapshot ? void 0 : function () {
                return memoizedSelector(maybeGetServerSnapshot());
              }];
            }, [getSnapshot, getServerSnapshot, selector, isEqual]);
            var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
            useEffect(function () {
              inst.hasValue = true;
              inst.value = value;
            }, [value]);
            useDebugValue(value);
            return value;
          };
          return withSelector_production;
        }
        var hasRequiredWithSelector;
        function requireWithSelector() {
          if (hasRequiredWithSelector) return withSelector.exports;
          hasRequiredWithSelector = 1;
          {
            withSelector.exports = requireWithSelector_production();
          }
          return withSelector.exports;
        }
        var withSelectorExports = requireWithSelector();
        var reactDomExports = exports("k", requireReactDom());
        const ao = exports("i", /*@__PURE__*/getDefaultExportFromCjs(reactDomExports));

        // Default to a dummy "batch" implementation that just runs the callback
        function defaultNoopBatch(callback) {
          callback();
        }
        let batch = defaultNoopBatch; // Allow injecting another batching function later

        const setBatch = newBatch => batch = newBatch; // Supply a getter just to skip dealing with ESM bindings

        const getBatch = () => batch;
        const ContextKey = Symbol.for(`react-redux-context`);
        const gT = typeof globalThis !== "undefined" ? globalThis : (/* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
        {});
        function getContext() {
          var _gT$ContextKey;
          if (!reactExports.createContext) return {};
          const contextMap = (_gT$ContextKey = gT[ContextKey]) != null ? _gT$ContextKey : gT[ContextKey] = /* @__PURE__ */new Map();
          let realContext = contextMap.get(reactExports.createContext);
          if (!realContext) {
            realContext = reactExports.createContext(null);
            contextMap.set(reactExports.createContext, realContext);
          }
          return realContext;
        }
        const ReactReduxContext = /* @__PURE__ */getContext();
        function createReduxContextHook(context = ReactReduxContext) {
          return function useReduxContext2() {
            const contextValue = reactExports.useContext(context);
            return contextValue;
          };
        }
        const useReduxContext = /* @__PURE__ */createReduxContextHook();
        const notInitialized = () => {
          throw new Error('uSES not initialized!');
        };
        let useSyncExternalStoreWithSelector = notInitialized;
        const initializeUseSelector = fn => {
          useSyncExternalStoreWithSelector = fn;
        };
        const refEquality = (a, b) => a === b;
        function createSelectorHook(context = ReactReduxContext) {
          const useReduxContext$1 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
          return function useSelector2(selector, equalityFnOrOptions = {}) {
            const {
              equalityFn = refEquality,
              stabilityCheck = void 0,
              noopCheck = void 0
            } = typeof equalityFnOrOptions === "function" ? {
              equalityFn: equalityFnOrOptions
            } : equalityFnOrOptions;
            const {
              store,
              subscription,
              getServerState,
              stabilityCheck: globalStabilityCheck,
              noopCheck: globalNoopCheck
            } = useReduxContext$1();
            reactExports.useRef(true);
            const wrappedSelector = reactExports.useCallback({
              [selector.name](state) {
                const selected = selector(state);
                return selected;
              }
            }[selector.name], [selector, globalStabilityCheck, stabilityCheck]);
            const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);
            reactExports.useDebugValue(selectedState);
            return selectedState;
          };
        }
        const useSelector = exports("ao", /* @__PURE__ */createSelectorHook());
        function _extends$2() {
          return _extends$2 = Object.assign ? Object.assign.bind() : function (n) {
            for (var e = 1; e < arguments.length; e++) {
              var t = arguments[e];
              for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
            }
            return n;
          }, _extends$2.apply(null, arguments);
        }
        function _objectWithoutPropertiesLoose$1(r, e) {
          if (null == r) return {};
          var t = {};
          for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
            if (-1 !== e.indexOf(n)) continue;
            t[n] = r[n];
          }
          return t;
        }
        var reactIs$1 = {
          exports: {}
        };
        var reactIs_production_min$1 = {};

        /** @license React v16.13.1
         * react-is.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var hasRequiredReactIs_production_min$1;
        function requireReactIs_production_min$1() {
          if (hasRequiredReactIs_production_min$1) return reactIs_production_min$1;
          hasRequiredReactIs_production_min$1 = 1;
          var b = "function" === typeof Symbol && Symbol.for,
            c = b ? Symbol.for("react.element") : 60103,
            d = b ? Symbol.for("react.portal") : 60106,
            e = b ? Symbol.for("react.fragment") : 60107,
            f = b ? Symbol.for("react.strict_mode") : 60108,
            g = b ? Symbol.for("react.profiler") : 60114,
            h = b ? Symbol.for("react.provider") : 60109,
            k = b ? Symbol.for("react.context") : 60110,
            l = b ? Symbol.for("react.async_mode") : 60111,
            m = b ? Symbol.for("react.concurrent_mode") : 60111,
            n = b ? Symbol.for("react.forward_ref") : 60112,
            p = b ? Symbol.for("react.suspense") : 60113,
            q = b ? Symbol.for("react.suspense_list") : 60120,
            r = b ? Symbol.for("react.memo") : 60115,
            t = b ? Symbol.for("react.lazy") : 60116,
            v = b ? Symbol.for("react.block") : 60121,
            w = b ? Symbol.for("react.fundamental") : 60117,
            x = b ? Symbol.for("react.responder") : 60118,
            y = b ? Symbol.for("react.scope") : 60119;
          function z(a) {
            if ("object" === typeof a && null !== a) {
              var u = a.$$typeof;
              switch (u) {
                case c:
                  switch (a = a.type, a) {
                    case l:
                    case m:
                    case e:
                    case g:
                    case f:
                    case p:
                      return a;
                    default:
                      switch (a = a && a.$$typeof, a) {
                        case k:
                        case n:
                        case t:
                        case r:
                        case h:
                          return a;
                        default:
                          return u;
                      }
                  }
                case d:
                  return u;
              }
            }
          }
          function A(a) {
            return z(a) === m;
          }
          reactIs_production_min$1.AsyncMode = l;
          reactIs_production_min$1.ConcurrentMode = m;
          reactIs_production_min$1.ContextConsumer = k;
          reactIs_production_min$1.ContextProvider = h;
          reactIs_production_min$1.Element = c;
          reactIs_production_min$1.ForwardRef = n;
          reactIs_production_min$1.Fragment = e;
          reactIs_production_min$1.Lazy = t;
          reactIs_production_min$1.Memo = r;
          reactIs_production_min$1.Portal = d;
          reactIs_production_min$1.Profiler = g;
          reactIs_production_min$1.StrictMode = f;
          reactIs_production_min$1.Suspense = p;
          reactIs_production_min$1.isAsyncMode = function (a) {
            return A(a) || z(a) === l;
          };
          reactIs_production_min$1.isConcurrentMode = A;
          reactIs_production_min$1.isContextConsumer = function (a) {
            return z(a) === k;
          };
          reactIs_production_min$1.isContextProvider = function (a) {
            return z(a) === h;
          };
          reactIs_production_min$1.isElement = function (a) {
            return "object" === typeof a && null !== a && a.$$typeof === c;
          };
          reactIs_production_min$1.isForwardRef = function (a) {
            return z(a) === n;
          };
          reactIs_production_min$1.isFragment = function (a) {
            return z(a) === e;
          };
          reactIs_production_min$1.isLazy = function (a) {
            return z(a) === t;
          };
          reactIs_production_min$1.isMemo = function (a) {
            return z(a) === r;
          };
          reactIs_production_min$1.isPortal = function (a) {
            return z(a) === d;
          };
          reactIs_production_min$1.isProfiler = function (a) {
            return z(a) === g;
          };
          reactIs_production_min$1.isStrictMode = function (a) {
            return z(a) === f;
          };
          reactIs_production_min$1.isSuspense = function (a) {
            return z(a) === p;
          };
          reactIs_production_min$1.isValidElementType = function (a) {
            return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
          };
          reactIs_production_min$1.typeOf = z;
          return reactIs_production_min$1;
        }
        var hasRequiredReactIs$1;
        function requireReactIs$1() {
          if (hasRequiredReactIs$1) return reactIs$1.exports;
          hasRequiredReactIs$1 = 1;
          {
            reactIs$1.exports = requireReactIs_production_min$1();
          }
          return reactIs$1.exports;
        }
        var hoistNonReactStatics_cjs;
        var hasRequiredHoistNonReactStatics_cjs;
        function requireHoistNonReactStatics_cjs() {
          if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
          hasRequiredHoistNonReactStatics_cjs = 1;
          var reactIs = requireReactIs$1();

          /**
           * Copyright 2015, Yahoo! Inc.
           * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
           */
          var REACT_STATICS = {
            childContextTypes: true,
            contextType: true,
            contextTypes: true,
            defaultProps: true,
            displayName: true,
            getDefaultProps: true,
            getDerivedStateFromError: true,
            getDerivedStateFromProps: true,
            mixins: true,
            propTypes: true,
            type: true
          };
          var KNOWN_STATICS = {
            name: true,
            length: true,
            prototype: true,
            caller: true,
            callee: true,
            arguments: true,
            arity: true
          };
          var FORWARD_REF_STATICS = {
            '$$typeof': true,
            render: true,
            defaultProps: true,
            displayName: true,
            propTypes: true
          };
          var MEMO_STATICS = {
            '$$typeof': true,
            compare: true,
            defaultProps: true,
            displayName: true,
            propTypes: true,
            type: true
          };
          var TYPE_STATICS = {};
          TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
          TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
          function getStatics(component) {
            // React v16.11 and below
            if (reactIs.isMemo(component)) {
              return MEMO_STATICS;
            } // React v16.12 and above

            return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
          }
          var defineProperty = Object.defineProperty;
          var getOwnPropertyNames = Object.getOwnPropertyNames;
          var getOwnPropertySymbols = Object.getOwnPropertySymbols;
          var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          var getPrototypeOf = Object.getPrototypeOf;
          var objectPrototype = Object.prototype;
          function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
            if (typeof sourceComponent !== 'string') {
              // don't hoist over string (html) components
              if (objectPrototype) {
                var inheritedComponent = getPrototypeOf(sourceComponent);
                if (inheritedComponent && inheritedComponent !== objectPrototype) {
                  hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
                }
              }
              var keys = getOwnPropertyNames(sourceComponent);
              if (getOwnPropertySymbols) {
                keys = keys.concat(getOwnPropertySymbols(sourceComponent));
              }
              var targetStatics = getStatics(targetComponent);
              var sourceStatics = getStatics(sourceComponent);
              for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                  var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                  try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                  } catch (e) {}
                }
              }
            }
            return targetComponent;
          }
          hoistNonReactStatics_cjs = hoistNonReactStatics;
          return hoistNonReactStatics_cjs;
        }
        var hoistNonReactStatics_cjsExports = requireHoistNonReactStatics_cjs();
        const hoistStatics = /*@__PURE__*/getDefaultExportFromCjs(hoistNonReactStatics_cjsExports);
        var reactIs = {
          exports: {}
        };
        var reactIs_production_min = {};

        /**
         * @license React
         * react-is.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var hasRequiredReactIs_production_min;
        function requireReactIs_production_min() {
          if (hasRequiredReactIs_production_min) return reactIs_production_min;
          hasRequiredReactIs_production_min = 1;
          var b = Symbol.for("react.element"),
            c = Symbol.for("react.portal"),
            d = Symbol.for("react.fragment"),
            e = Symbol.for("react.strict_mode"),
            f = Symbol.for("react.profiler"),
            g = Symbol.for("react.provider"),
            h = Symbol.for("react.context"),
            k = Symbol.for("react.server_context"),
            l = Symbol.for("react.forward_ref"),
            m = Symbol.for("react.suspense"),
            n = Symbol.for("react.suspense_list"),
            p = Symbol.for("react.memo"),
            q = Symbol.for("react.lazy"),
            t = Symbol.for("react.offscreen"),
            u;
          u = Symbol.for("react.module.reference");
          function v(a) {
            if ("object" === typeof a && null !== a) {
              var r = a.$$typeof;
              switch (r) {
                case b:
                  switch (a = a.type, a) {
                    case d:
                    case f:
                    case e:
                    case m:
                    case n:
                      return a;
                    default:
                      switch (a = a && a.$$typeof, a) {
                        case k:
                        case h:
                        case l:
                        case q:
                        case p:
                        case g:
                          return a;
                        default:
                          return r;
                      }
                  }
                case c:
                  return r;
              }
            }
          }
          reactIs_production_min.ContextConsumer = h;
          reactIs_production_min.ContextProvider = g;
          reactIs_production_min.Element = b;
          reactIs_production_min.ForwardRef = l;
          reactIs_production_min.Fragment = d;
          reactIs_production_min.Lazy = q;
          reactIs_production_min.Memo = p;
          reactIs_production_min.Portal = c;
          reactIs_production_min.Profiler = f;
          reactIs_production_min.StrictMode = e;
          reactIs_production_min.Suspense = m;
          reactIs_production_min.SuspenseList = n;
          reactIs_production_min.isAsyncMode = function () {
            return false;
          };
          reactIs_production_min.isConcurrentMode = function () {
            return false;
          };
          reactIs_production_min.isContextConsumer = function (a) {
            return v(a) === h;
          };
          reactIs_production_min.isContextProvider = function (a) {
            return v(a) === g;
          };
          reactIs_production_min.isElement = function (a) {
            return "object" === typeof a && null !== a && a.$$typeof === b;
          };
          reactIs_production_min.isForwardRef = function (a) {
            return v(a) === l;
          };
          reactIs_production_min.isFragment = function (a) {
            return v(a) === d;
          };
          reactIs_production_min.isLazy = function (a) {
            return v(a) === q;
          };
          reactIs_production_min.isMemo = function (a) {
            return v(a) === p;
          };
          reactIs_production_min.isPortal = function (a) {
            return v(a) === c;
          };
          reactIs_production_min.isProfiler = function (a) {
            return v(a) === f;
          };
          reactIs_production_min.isStrictMode = function (a) {
            return v(a) === e;
          };
          reactIs_production_min.isSuspense = function (a) {
            return v(a) === m;
          };
          reactIs_production_min.isSuspenseList = function (a) {
            return v(a) === n;
          };
          reactIs_production_min.isValidElementType = function (a) {
            return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || "object" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? true : false;
          };
          reactIs_production_min.typeOf = v;
          return reactIs_production_min;
        }
        var hasRequiredReactIs;
        function requireReactIs() {
          if (hasRequiredReactIs) return reactIs.exports;
          hasRequiredReactIs = 1;
          {
            reactIs.exports = requireReactIs_production_min();
          }
          return reactIs.exports;
        }
        requireReactIs();

        // well as nesting subscriptions of descendant components, so that we can ensure the
        // ancestor components re-render before descendants

        function createListenerCollection() {
          const batch = getBatch();
          let first = null;
          let last = null;
          return {
            clear() {
              first = null;
              last = null;
            },
            notify() {
              batch(() => {
                let listener = first;
                while (listener) {
                  listener.callback();
                  listener = listener.next;
                }
              });
            },
            get() {
              let listeners = [];
              let listener = first;
              while (listener) {
                listeners.push(listener);
                listener = listener.next;
              }
              return listeners;
            },
            subscribe(callback) {
              let isSubscribed = true;
              let listener = last = {
                callback,
                next: null,
                prev: last
              };
              if (listener.prev) {
                listener.prev.next = listener;
              } else {
                first = listener;
              }
              return function unsubscribe() {
                if (!isSubscribed || first === null) return;
                isSubscribed = false;
                if (listener.next) {
                  listener.next.prev = listener.prev;
                } else {
                  last = listener.prev;
                }
                if (listener.prev) {
                  listener.prev.next = listener.next;
                } else {
                  first = listener.next;
                }
              };
            }
          };
        }
        const nullListeners = {
          notify() {},
          get: () => []
        };
        function createSubscription(store, parentSub) {
          let unsubscribe;
          let listeners = nullListeners; // Reasons to keep the subscription active

          let subscriptionsAmount = 0; // Is this specific subscription subscribed (or only nested ones?)

          let selfSubscribed = false;
          function addNestedSub(listener) {
            trySubscribe();
            const cleanupListener = listeners.subscribe(listener); // cleanup nested sub

            let removed = false;
            return () => {
              if (!removed) {
                removed = true;
                cleanupListener();
                tryUnsubscribe();
              }
            };
          }
          function notifyNestedSubs() {
            listeners.notify();
          }
          function handleChangeWrapper() {
            if (subscription.onStateChange) {
              subscription.onStateChange();
            }
          }
          function isSubscribed() {
            return selfSubscribed;
          }
          function trySubscribe() {
            subscriptionsAmount++;
            if (!unsubscribe) {
              unsubscribe = store.subscribe(handleChangeWrapper);
              listeners = createListenerCollection();
            }
          }
          function tryUnsubscribe() {
            subscriptionsAmount--;
            if (unsubscribe && subscriptionsAmount === 0) {
              unsubscribe();
              unsubscribe = undefined;
              listeners.clear();
              listeners = nullListeners;
            }
          }
          function trySubscribeSelf() {
            if (!selfSubscribed) {
              selfSubscribed = true;
              trySubscribe();
            }
          }
          function tryUnsubscribeSelf() {
            if (selfSubscribed) {
              selfSubscribed = false;
              tryUnsubscribe();
            }
          }
          const subscription = {
            addNestedSub,
            notifyNestedSubs,
            handleChangeWrapper,
            isSubscribed,
            trySubscribe: trySubscribeSelf,
            tryUnsubscribe: tryUnsubscribeSelf,
            getListeners: () => listeners
          };
          return subscription;
        }

        // To get around it, we can conditionally useEffect on the server (no-op) and
        // useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
        // subscription callback always has the selector from the latest render commit
        // available, otherwise a store update may happen between render and the effect,
        // which may cause missed updates; we also must ensure the store subscription
        // is created synchronously, otherwise a store update may occur before the
        // subscription is created and an inconsistent state may be observed
        // Matches logic in React's `shared/ExecutionEnvironment` file

        const canUseDOM$2 = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
        const useIsomorphicLayoutEffect$3 = canUseDOM$2 ? reactExports.useLayoutEffect : reactExports.useEffect;
        function is$2(x, y) {
          if (x === y) {
            return x !== 0 || y !== 0 || 1 / x === 1 / y;
          } else {
            return x !== x && y !== y;
          }
        }
        function shallowEqual(objA, objB) {
          if (is$2(objA, objB)) return true;
          if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
            return false;
          }
          const keysA = Object.keys(objA);
          const keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (let i = 0; i < keysA.length; i++) {
            if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is$2(objA[keysA[i]], objB[keysA[i]])) {
              return false;
            }
          }
          return true;
        }
        function Provider({
          store,
          context,
          children,
          serverState,
          stabilityCheck = 'once',
          noopCheck = 'once'
        }) {
          const contextValue = reactExports.useMemo(() => {
            const subscription = createSubscription(store);
            return {
              store,
              subscription,
              getServerState: serverState ? () => serverState : undefined,
              stabilityCheck,
              noopCheck
            };
          }, [store, serverState, stabilityCheck, noopCheck]);
          const previousState = reactExports.useMemo(() => store.getState(), [store]);
          useIsomorphicLayoutEffect$3(() => {
            const {
              subscription
            } = contextValue;
            subscription.onStateChange = subscription.notifyNestedSubs;
            subscription.trySubscribe();
            if (previousState !== store.getState()) {
              subscription.notifyNestedSubs();
            }
            return () => {
              subscription.tryUnsubscribe();
              subscription.onStateChange = undefined;
            };
          }, [contextValue, previousState]);
          const Context = context || ReactReduxContext; // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype

          return /*#__PURE__*/reactExports.createElement(Context.Provider, {
            value: contextValue
          }, children);
        }

        /**
         * Hook factory, which creates a `useStore` hook bound to a given context.
         *
         * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
         * @returns {Function} A `useStore` hook bound to the specified context.
         */

        function createStoreHook(context = ReactReduxContext) {
          const useReduxContext$1 =
          // @ts-ignore
          context === ReactReduxContext ? useReduxContext :
          // @ts-ignore
          createReduxContextHook(context);
          return function useStore() {
            const {
              store
            } = useReduxContext$1(); // @ts-ignore

            return store;
          };
        }
        /**
         * A hook to access the redux store.
         *
         * @returns {any} the redux store
         *
         * @example
         *
         * import React from 'react'
         * import { useStore } from 'react-redux'
         *
         * export const ExampleComponent = () => {
         *   const store = useStore()
         *   return <div>{store.getState()}</div>
         * }
         */

        const useStore = /*#__PURE__*/createStoreHook();

        /**
         * Hook factory, which creates a `useDispatch` hook bound to a given context.
         *
         * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
         * @returns {Function} A `useDispatch` hook bound to the specified context.
         */

        function createDispatchHook(context = ReactReduxContext) {
          const useStore$1 =
          // @ts-ignore
          context === ReactReduxContext ? useStore : createStoreHook(context);
          return function useDispatch() {
            const store = useStore$1(); // @ts-ignore

            return store.dispatch;
          };
        }
        /**
         * A hook to access the redux `dispatch` function.
         *
         * @returns {any|function} redux store's `dispatch` function
         *
         * @example
         *
         * import React, { useCallback } from 'react'
         * import { useDispatch } from 'react-redux'
         *
         * export const CounterComponent = ({ value }) => {
         *   const dispatch = useDispatch()
         *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])
         *   return (
         *     <div>
         *       <span>{value}</span>
         *       <button onClick={increaseCounter}>Increase counter</button>
         *     </div>
         *   )
         * }
         */

        const useDispatch = exports("an", /*#__PURE__*/createDispatchHook());

        // The primary entry point assumes we're working with standard ReactDOM/RN, but
        // older versions that do not include `useSyncExternalStore` (React 16.9 - 17.x).
        // Because of that, the useSyncExternalStore compat shim is needed.
        initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
        // with standard React renderers (ReactDOM, React Native)

        setBatch(reactDomExports.unstable_batchedUpdates);
        function _typeof$6(o) {
          "@babel/helpers - typeof";

          return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
            return typeof o;
          } : function (o) {
            return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
          }, _typeof$6(o);
        }
        function _classCallCheck$3(a, n) {
          if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
        }
        function toPrimitive(t, r) {
          if ("object" != _typeof$6(t) || !t) return t;
          var e = t[Symbol.toPrimitive];
          if (void 0 !== e) {
            var i = e.call(t, r);
            if ("object" != _typeof$6(i)) return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r ? String : Number)(t);
        }
        function toPropertyKey(t) {
          var i = toPrimitive(t, "string");
          return "symbol" == _typeof$6(i) ? i : i + "";
        }
        function _defineProperties$3(e, r) {
          for (var t = 0; t < r.length; t++) {
            var o = r[t];
            o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
          }
        }
        function _createClass$3(e, r, t) {
          return r && _defineProperties$3(e.prototype, r), t && _defineProperties$3(e, t), Object.defineProperty(e, "prototype", {
            writable: false
          }), e;
        }
        function _assertThisInitialized$1(e) {
          if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e;
        }
        function _setPrototypeOf$1(t, e) {
          return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
            return t.__proto__ = e, t;
          }, _setPrototypeOf$1(t, e);
        }
        function _inherits$1(t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: true,
              configurable: true
            }
          }), Object.defineProperty(t, "prototype", {
            writable: false
          }), e && _setPrototypeOf$1(t, e);
        }
        function _possibleConstructorReturn$1(t, e) {
          if (e && ("object" == _typeof$6(e) || "function" == typeof e)) return e;
          if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
          return _assertThisInitialized$1(t);
        }
        function _getPrototypeOf$1(t) {
          return _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          }, _getPrototypeOf$1(t);
        }
        function _defineProperty$6(e, r, t) {
          return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
            value: t,
            enumerable: true,
            configurable: true,
            writable: true
          }) : e[r] = t, e;
        }
        function _arrayWithHoles(r) {
          if (Array.isArray(r)) return r;
        }
        function _iterableToArray$2(r) {
          if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
        }
        function _arrayLikeToArray$1(r, a) {
          (null == a || a > r.length) && (a = r.length);
          for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
          return n;
        }
        function _unsupportedIterableToArray$1(r, a) {
          if (r) {
            if ("string" == typeof r) return _arrayLikeToArray$1(r, a);
            var t = {}.toString.call(r).slice(8, -1);
            return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0;
          }
        }
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _toArray(r) {
          return _arrayWithHoles(r) || _iterableToArray$2(r) || _unsupportedIterableToArray$1(r) || _nonIterableRest();
        }
        function ownKeys$6(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$6(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$6(Object(source), true).forEach(function (key) {
              _defineProperty$6(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var consoleLogger = {
          type: 'logger',
          log: function log(args) {
            this.output('log', args);
          },
          warn: function warn(args) {
            this.output('warn', args);
          },
          error: function error(args) {
            this.output('error', args);
          },
          output: function output(type, args) {
            if (console && console[type]) console[type].apply(console, args);
          }
        };
        var Logger = function () {
          function Logger(concreteLogger) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck$3(this, Logger);
            this.init(concreteLogger, options);
          }
          _createClass$3(Logger, [{
            key: "init",
            value: function init(concreteLogger) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              this.prefix = options.prefix || 'i18next:';
              this.logger = concreteLogger || consoleLogger;
              this.options = options;
              this.debug = options.debug;
            }
          }, {
            key: "setDebug",
            value: function setDebug(bool) {
              this.debug = bool;
            }
          }, {
            key: "log",
            value: function log() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return this.forward(args, 'log', '', true);
            }
          }, {
            key: "warn",
            value: function warn() {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              return this.forward(args, 'warn', '', true);
            }
          }, {
            key: "error",
            value: function error() {
              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }
              return this.forward(args, 'error', '');
            }
          }, {
            key: "deprecate",
            value: function deprecate() {
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }
              return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
            }
          }, {
            key: "forward",
            value: function forward(args, lvl, prefix, debugOnly) {
              if (debugOnly && !this.debug) return null;
              if (typeof args[0] === 'string') args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
              return this.logger[lvl](args);
            }
          }, {
            key: "create",
            value: function create(moduleName) {
              return new Logger(this.logger, _objectSpread$6(_objectSpread$6({}, {
                prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
              }), this.options));
            }
          }, {
            key: "clone",
            value: function clone(options) {
              options = options || this.options;
              options.prefix = options.prefix || this.prefix;
              return new Logger(this.logger, options);
            }
          }]);
          return Logger;
        }();
        var baseLogger = new Logger();
        var EventEmitter = function () {
          function EventEmitter() {
            _classCallCheck$3(this, EventEmitter);
            this.observers = {};
          }
          _createClass$3(EventEmitter, [{
            key: "on",
            value: function on(events, listener) {
              var _this = this;
              events.split(' ').forEach(function (event) {
                _this.observers[event] = _this.observers[event] || [];
                _this.observers[event].push(listener);
              });
              return this;
            }
          }, {
            key: "off",
            value: function off(event, listener) {
              if (!this.observers[event]) return;
              if (!listener) {
                delete this.observers[event];
                return;
              }
              this.observers[event] = this.observers[event].filter(function (l) {
                return l !== listener;
              });
            }
          }, {
            key: "emit",
            value: function emit(event) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              if (this.observers[event]) {
                var cloned = [].concat(this.observers[event]);
                cloned.forEach(function (observer) {
                  observer.apply(void 0, args);
                });
              }
              if (this.observers['*']) {
                var _cloned = [].concat(this.observers['*']);
                _cloned.forEach(function (observer) {
                  observer.apply(observer, [event].concat(args));
                });
              }
            }
          }]);
          return EventEmitter;
        }();
        function defer() {
          var res;
          var rej;
          var promise = new Promise(function (resolve, reject) {
            res = resolve;
            rej = reject;
          });
          promise.resolve = res;
          promise.reject = rej;
          return promise;
        }
        function makeString(object) {
          if (object == null) return '';
          return '' + object;
        }
        function copy(a, s, t) {
          a.forEach(function (m) {
            if (s[m]) t[m] = s[m];
          });
        }
        function getLastOfPath(object, path, Empty) {
          function cleanKey(key) {
            return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
          }
          function canNotTraverseDeeper() {
            return !object || typeof object === 'string';
          }
          var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');
          while (stack.length > 1) {
            if (canNotTraverseDeeper()) return {};
            var key = cleanKey(stack.shift());
            if (!object[key] && Empty) object[key] = new Empty();
            if (Object.prototype.hasOwnProperty.call(object, key)) {
              object = object[key];
            } else {
              object = {};
            }
          }
          if (canNotTraverseDeeper()) return {};
          return {
            obj: object,
            k: cleanKey(stack.shift())
          };
        }
        function setPath(object, path, newValue) {
          var _getLastOfPath = getLastOfPath(object, path, Object),
            obj = _getLastOfPath.obj,
            k = _getLastOfPath.k;
          obj[k] = newValue;
        }
        function pushPath(object, path, newValue, concat) {
          var _getLastOfPath2 = getLastOfPath(object, path, Object),
            obj = _getLastOfPath2.obj,
            k = _getLastOfPath2.k;
          obj[k] = obj[k] || [];
          obj[k].push(newValue);
        }
        function getPath(object, path) {
          var _getLastOfPath3 = getLastOfPath(object, path),
            obj = _getLastOfPath3.obj,
            k = _getLastOfPath3.k;
          if (!obj) return undefined;
          return obj[k];
        }
        function getPathWithDefaults(data, defaultData, key) {
          var value = getPath(data, key);
          if (value !== undefined) {
            return value;
          }
          return getPath(defaultData, key);
        }
        function deepExtend(target, source, overwrite) {
          for (var prop in source) {
            if (prop !== '__proto__' && prop !== 'constructor') {
              if (prop in target) {
                if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
                  if (overwrite) target[prop] = source[prop];
                } else {
                  deepExtend(target[prop], source[prop], overwrite);
                }
              } else {
                target[prop] = source[prop];
              }
            }
          }
          return target;
        }
        function regexEscape(str) {
          return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
        }
        var _entityMap = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
          '/': '&#x2F;'
        };
        function escape$1(data) {
          if (typeof data === 'string') {
            return data.replace(/[&<>"'\/]/g, function (s) {
              return _entityMap[s];
            });
          }
          return data;
        }
        var isIE10 = typeof window !== 'undefined' && window.navigator && typeof window.navigator.userAgentData === 'undefined' && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1;
        var chars = [' ', ',', '?', '!', ';'];
        function looksLikeObjectPath(key, nsSeparator, keySeparator) {
          nsSeparator = nsSeparator || '';
          keySeparator = keySeparator || '';
          var possibleChars = chars.filter(function (c) {
            return nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0;
          });
          if (possibleChars.length === 0) return true;
          var r = new RegExp("(".concat(possibleChars.map(function (c) {
            return c === '?' ? '\\?' : c;
          }).join('|'), ")"));
          var matched = !r.test(key);
          if (!matched) {
            var ki = key.indexOf(keySeparator);
            if (ki > 0 && !r.test(key.substring(0, ki))) {
              matched = true;
            }
          }
          return matched;
        }
        function deepFind(obj, path) {
          var keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
          if (!obj) return undefined;
          if (obj[path]) return obj[path];
          var paths = path.split(keySeparator);
          var current = obj;
          for (var i = 0; i < paths.length; ++i) {
            if (!current) return undefined;
            if (typeof current[paths[i]] === 'string' && i + 1 < paths.length) {
              return undefined;
            }
            if (current[paths[i]] === undefined) {
              var j = 2;
              var p = paths.slice(i, i + j).join(keySeparator);
              var mix = current[p];
              while (mix === undefined && paths.length > i + j) {
                j++;
                p = paths.slice(i, i + j).join(keySeparator);
                mix = current[p];
              }
              if (mix === undefined) return undefined;
              if (mix === null) return null;
              if (path.endsWith(p)) {
                if (typeof mix === 'string') return mix;
                if (p && typeof mix[p] === 'string') return mix[p];
              }
              var joinedPath = paths.slice(i + j).join(keySeparator);
              if (joinedPath) return deepFind(mix, joinedPath, keySeparator);
              return undefined;
            }
            current = current[paths[i]];
          }
          return current;
        }
        function ownKeys$5$1(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$5(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$5$1(Object(source), true).forEach(function (key) {
              _defineProperty$6(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5$1(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$3(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$1(this, result);
          };
        }
        function _isNativeReflectConstruct$3() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var ResourceStore = function (_EventEmitter) {
          _inherits$1(ResourceStore, _EventEmitter);
          var _super = _createSuper$3(ResourceStore);
          function ResourceStore(data) {
            var _this;
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
              ns: ['translation'],
              defaultNS: 'translation'
            };
            _classCallCheck$3(this, ResourceStore);
            _this = _super.call(this);
            if (isIE10) {
              EventEmitter.call(_assertThisInitialized$1(_this));
            }
            _this.data = data || {};
            _this.options = options;
            if (_this.options.keySeparator === undefined) {
              _this.options.keySeparator = '.';
            }
            if (_this.options.ignoreJSONStructure === undefined) {
              _this.options.ignoreJSONStructure = true;
            }
            return _this;
          }
          _createClass$3(ResourceStore, [{
            key: "addNamespaces",
            value: function addNamespaces(ns) {
              if (this.options.ns.indexOf(ns) < 0) {
                this.options.ns.push(ns);
              }
            }
          }, {
            key: "removeNamespaces",
            value: function removeNamespaces(ns) {
              var index = this.options.ns.indexOf(ns);
              if (index > -1) {
                this.options.ns.splice(index, 1);
              }
            }
          }, {
            key: "getResource",
            value: function getResource(lng, ns, key) {
              var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
              var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
              var ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
              var path = [lng, ns];
              if (key && typeof key !== 'string') path = path.concat(key);
              if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);
              if (lng.indexOf('.') > -1) {
                path = lng.split('.');
              }
              var result = getPath(this.data, path);
              if (result || !ignoreJSONStructure || typeof key !== 'string') return result;
              return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
            }
          }, {
            key: "addResource",
            value: function addResource(lng, ns, key, value) {
              var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
                silent: false
              };
              var keySeparator = this.options.keySeparator;
              if (keySeparator === undefined) keySeparator = '.';
              var path = [lng, ns];
              if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
              if (lng.indexOf('.') > -1) {
                path = lng.split('.');
                value = ns;
                ns = path[1];
              }
              this.addNamespaces(ns);
              setPath(this.data, path, value);
              if (!options.silent) this.emit('added', lng, ns, key, value);
            }
          }, {
            key: "addResources",
            value: function addResources(lng, ns, resources) {
              var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
                silent: false
              };
              for (var m in resources) {
                if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
                  silent: true
                });
              }
              if (!options.silent) this.emit('added', lng, ns, resources);
            }
          }, {
            key: "addResourceBundle",
            value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
              var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
                silent: false
              };
              var path = [lng, ns];
              if (lng.indexOf('.') > -1) {
                path = lng.split('.');
                deep = resources;
                resources = ns;
                ns = path[1];
              }
              this.addNamespaces(ns);
              var pack = getPath(this.data, path) || {};
              if (deep) {
                deepExtend(pack, resources, overwrite);
              } else {
                pack = _objectSpread$5(_objectSpread$5({}, pack), resources);
              }
              setPath(this.data, path, pack);
              if (!options.silent) this.emit('added', lng, ns, resources);
            }
          }, {
            key: "removeResourceBundle",
            value: function removeResourceBundle(lng, ns) {
              if (this.hasResourceBundle(lng, ns)) {
                delete this.data[lng][ns];
              }
              this.removeNamespaces(ns);
              this.emit('removed', lng, ns);
            }
          }, {
            key: "hasResourceBundle",
            value: function hasResourceBundle(lng, ns) {
              return this.getResource(lng, ns) !== undefined;
            }
          }, {
            key: "getResourceBundle",
            value: function getResourceBundle(lng, ns) {
              if (!ns) ns = this.options.defaultNS;
              if (this.options.compatibilityAPI === 'v1') return _objectSpread$5(_objectSpread$5({}, {}), this.getResource(lng, ns));
              return this.getResource(lng, ns);
            }
          }, {
            key: "getDataByLanguage",
            value: function getDataByLanguage(lng) {
              return this.data[lng];
            }
          }, {
            key: "hasLanguageSomeTranslations",
            value: function hasLanguageSomeTranslations(lng) {
              var data = this.getDataByLanguage(lng);
              var n = data && Object.keys(data) || [];
              return !!n.find(function (v) {
                return data[v] && Object.keys(data[v]).length > 0;
              });
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              return this.data;
            }
          }]);
          return ResourceStore;
        }(EventEmitter);
        var postProcessor = {
          processors: {},
          addPostProcessor: function addPostProcessor(module) {
            this.processors[module.name] = module;
          },
          handle: function handle(processors, value, key, options, translator) {
            var _this = this;
            processors.forEach(function (processor) {
              if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
            });
            return value;
          }
        };
        function ownKeys$4$1(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$4$1(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$4$1(Object(source), true).forEach(function (key) {
              _defineProperty$6(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4$1(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$2(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$1(this, result);
          };
        }
        function _isNativeReflectConstruct$2() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var checkedLoadedFor = {};
        var Translator = function (_EventEmitter) {
          _inherits$1(Translator, _EventEmitter);
          var _super = _createSuper$2(Translator);
          function Translator(services) {
            var _this;
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck$3(this, Translator);
            _this = _super.call(this);
            if (isIE10) {
              EventEmitter.call(_assertThisInitialized$1(_this));
            }
            copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, _assertThisInitialized$1(_this));
            _this.options = options;
            if (_this.options.keySeparator === undefined) {
              _this.options.keySeparator = '.';
            }
            _this.logger = baseLogger.create('translator');
            return _this;
          }
          _createClass$3(Translator, [{
            key: "changeLanguage",
            value: function changeLanguage(lng) {
              if (lng) this.language = lng;
            }
          }, {
            key: "exists",
            value: function exists(key) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                interpolation: {}
              };
              if (key === undefined || key === null) {
                return false;
              }
              var resolved = this.resolve(key, options);
              return resolved && resolved.res !== undefined;
            }
          }, {
            key: "extractFromKey",
            value: function extractFromKey(key, options) {
              var nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;
              if (nsSeparator === undefined) nsSeparator = ':';
              var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
              var namespaces = options.ns || this.options.defaultNS || [];
              var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
              var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
              if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
                var m = key.match(this.interpolator.nestingRegexp);
                if (m && m.length > 0) {
                  return {
                    key: key,
                    namespaces: namespaces
                  };
                }
                var parts = key.split(nsSeparator);
                if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
                key = parts.join(keySeparator);
              }
              if (typeof namespaces === 'string') namespaces = [namespaces];
              return {
                key: key,
                namespaces: namespaces
              };
            }
          }, {
            key: "translate",
            value: function translate(keys, options, lastKey) {
              var _this2 = this;
              if (_typeof$6(options) !== 'object' && this.options.overloadTranslationOptionHandler) {
                options = this.options.overloadTranslationOptionHandler(arguments);
              }
              if (_typeof$6(options) === 'object') options = _objectSpread$4$1({}, options);
              if (!options) options = {};
              if (keys === undefined || keys === null) return '';
              if (!Array.isArray(keys)) keys = [String(keys)];
              var returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;
              var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
              var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
                key = _this$extractFromKey.key,
                namespaces = _this$extractFromKey.namespaces;
              var namespace = namespaces[namespaces.length - 1];
              var lng = options.lng || this.language;
              var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
              if (lng && lng.toLowerCase() === 'cimode') {
                if (appendNamespaceToCIMode) {
                  var nsSeparator = options.nsSeparator || this.options.nsSeparator;
                  if (returnDetails) {
                    return {
                      res: "".concat(namespace).concat(nsSeparator).concat(key),
                      usedKey: key,
                      exactUsedKey: key,
                      usedLng: lng,
                      usedNS: namespace
                    };
                  }
                  return "".concat(namespace).concat(nsSeparator).concat(key);
                }
                if (returnDetails) {
                  return {
                    res: key,
                    usedKey: key,
                    exactUsedKey: key,
                    usedLng: lng,
                    usedNS: namespace
                  };
                }
                return key;
              }
              var resolved = this.resolve(keys, options);
              var res = resolved && resolved.res;
              var resUsedKey = resolved && resolved.usedKey || key;
              var resExactUsedKey = resolved && resolved.exactUsedKey || key;
              var resType = Object.prototype.toString.apply(res);
              var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
              var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
              var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
              var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';
              if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
                if (!options.returnObjects && !this.options.returnObjects) {
                  if (!this.options.returnedObjectHandler) {
                    this.logger.warn('accessing an object - but returnObjects options is not enabled!');
                  }
                  var r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$4$1(_objectSpread$4$1({}, options), {}, {
                    ns: namespaces
                  })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
                  if (returnDetails) {
                    resolved.res = r;
                    return resolved;
                  }
                  return r;
                }
                if (keySeparator) {
                  var resTypeIsArray = resType === '[object Array]';
                  var copy = resTypeIsArray ? [] : {};
                  var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
                  for (var m in res) {
                    if (Object.prototype.hasOwnProperty.call(res, m)) {
                      var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
                      copy[m] = this.translate(deepKey, _objectSpread$4$1(_objectSpread$4$1({}, options), {
                        joinArrays: false,
                        ns: namespaces
                      }));
                      if (copy[m] === deepKey) copy[m] = res[m];
                    }
                  }
                  res = copy;
                }
              } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
                res = res.join(joinArrays);
                if (res) res = this.extendTranslation(res, keys, options, lastKey);
              } else {
                var usedDefault = false;
                var usedKey = false;
                var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
                var hasDefaultValue = Translator.hasDefaultValue(options);
                var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';
                var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
                if (!this.isValidLookup(res) && hasDefaultValue) {
                  usedDefault = true;
                  res = defaultValue;
                }
                if (!this.isValidLookup(res)) {
                  usedKey = true;
                  res = key;
                }
                var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
                var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
                var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
                if (usedKey || usedDefault || updateMissing) {
                  this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);
                  if (keySeparator) {
                    var fk = this.resolve(key, _objectSpread$4$1(_objectSpread$4$1({}, options), {}, {
                      keySeparator: false
                    }));
                    if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
                  }
                  var lngs = [];
                  var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
                  if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
                    for (var i = 0; i < fallbackLngs.length; i++) {
                      lngs.push(fallbackLngs[i]);
                    }
                  } else if (this.options.saveMissingTo === 'all') {
                    lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
                  } else {
                    lngs.push(options.lng || this.language);
                  }
                  var send = function send(l, k, specificDefaultValue) {
                    var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
                    if (_this2.options.missingKeyHandler) {
                      _this2.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
                    } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
                      _this2.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
                    }
                    _this2.emit('missingKey', l, namespace, k, res);
                  };
                  if (this.options.saveMissing) {
                    if (this.options.saveMissingPlurals && needsPluralHandling) {
                      lngs.forEach(function (language) {
                        _this2.pluralResolver.getSuffixes(language, options).forEach(function (suffix) {
                          send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                        });
                      });
                    } else {
                      send(lngs, key, defaultValue);
                    }
                  }
                }
                res = this.extendTranslation(res, keys, options, resolved, lastKey);
                if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key);
                if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
                  if (this.options.compatibilityAPI !== 'v1') {
                    res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : undefined);
                  } else {
                    res = this.options.parseMissingKeyHandler(res);
                  }
                }
              }
              if (returnDetails) {
                resolved.res = res;
                return resolved;
              }
              return res;
            }
          }, {
            key: "extendTranslation",
            value: function extendTranslation(res, key, options, resolved, lastKey) {
              var _this3 = this;
              if (this.i18nFormat && this.i18nFormat.parse) {
                res = this.i18nFormat.parse(res, _objectSpread$4$1(_objectSpread$4$1({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
                  resolved: resolved
                });
              } else if (!options.skipInterpolation) {
                if (options.interpolation) this.interpolator.init(_objectSpread$4$1(_objectSpread$4$1({}, options), {
                  interpolation: _objectSpread$4$1(_objectSpread$4$1({}, this.options.interpolation), options.interpolation)
                }));
                var skipOnVariables = typeof res === 'string' && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
                var nestBef;
                if (skipOnVariables) {
                  var nb = res.match(this.interpolator.nestingRegexp);
                  nestBef = nb && nb.length;
                }
                var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
                if (this.options.interpolation.defaultVariables) data = _objectSpread$4$1(_objectSpread$4$1({}, this.options.interpolation.defaultVariables), data);
                res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
                if (skipOnVariables) {
                  var na = res.match(this.interpolator.nestingRegexp);
                  var nestAft = na && na.length;
                  if (nestBef < nestAft) options.nest = false;
                }
                if (!options.lng && this.options.compatibilityAPI !== 'v1' && resolved && resolved.res) options.lng = resolved.usedLng;
                if (options.nest !== false) res = this.interpolator.nest(res, function () {
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  if (lastKey && lastKey[0] === args[0] && !options.context) {
                    _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
                    return null;
                  }
                  return _this3.translate.apply(_this3, args.concat([key]));
                }, options);
                if (options.interpolation) this.interpolator.reset();
              }
              var postProcess = options.postProcess || this.options.postProcess;
              var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;
              if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
                res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$4$1({
                  i18nResolved: resolved
                }, options) : options, this);
              }
              return res;
            }
          }, {
            key: "resolve",
            value: function resolve(keys) {
              var _this4 = this;
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var found;
              var usedKey;
              var exactUsedKey;
              var usedLng;
              var usedNS;
              if (typeof keys === 'string') keys = [keys];
              keys.forEach(function (k) {
                if (_this4.isValidLookup(found)) return;
                var extracted = _this4.extractFromKey(k, options);
                var key = extracted.key;
                usedKey = key;
                var namespaces = extracted.namespaces;
                if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
                var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
                var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
                var needsContextHandling = options.context !== undefined && (typeof options.context === 'string' || typeof options.context === 'number') && options.context !== '';
                var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
                namespaces.forEach(function (ns) {
                  if (_this4.isValidLookup(found)) return;
                  usedNS = ns;
                  if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
                    checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
                    _this4.logger.warn("key \"".concat(usedKey, "\" for languages \"").concat(codes.join(', '), "\" won't get resolved as namespace \"").concat(usedNS, "\" was not yet loaded"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
                  }
                  codes.forEach(function (code) {
                    if (_this4.isValidLookup(found)) return;
                    usedLng = code;
                    var finalKeys = [key];
                    if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
                      _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
                    } else {
                      var pluralSuffix;
                      if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);
                      var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
                      if (needsPluralHandling) {
                        finalKeys.push(key + pluralSuffix);
                        if (needsZeroSuffixLookup) {
                          finalKeys.push(key + zeroSuffix);
                        }
                      }
                      if (needsContextHandling) {
                        var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                        finalKeys.push(contextKey);
                        if (needsPluralHandling) {
                          finalKeys.push(contextKey + pluralSuffix);
                          if (needsZeroSuffixLookup) {
                            finalKeys.push(contextKey + zeroSuffix);
                          }
                        }
                      }
                    }
                    var possibleKey;
                    while (possibleKey = finalKeys.pop()) {
                      if (!_this4.isValidLookup(found)) {
                        exactUsedKey = possibleKey;
                        found = _this4.getResource(code, ns, possibleKey, options);
                      }
                    }
                  });
                });
              });
              return {
                res: found,
                usedKey: usedKey,
                exactUsedKey: exactUsedKey,
                usedLng: usedLng,
                usedNS: usedNS
              };
            }
          }, {
            key: "isValidLookup",
            value: function isValidLookup(res) {
              return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
            }
          }, {
            key: "getResource",
            value: function getResource(code, ns, key) {
              var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
              if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
              return this.resourceStore.getResource(code, ns, key, options);
            }
          }], [{
            key: "hasDefaultValue",
            value: function hasDefaultValue(options) {
              var prefix = 'defaultValue';
              for (var option in options) {
                if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {
                  return true;
                }
              }
              return false;
            }
          }]);
          return Translator;
        }(EventEmitter);
        function capitalize$1(string) {
          return string.charAt(0).toUpperCase() + string.slice(1);
        }
        var LanguageUtil = function () {
          function LanguageUtil(options) {
            _classCallCheck$3(this, LanguageUtil);
            this.options = options;
            this.supportedLngs = this.options.supportedLngs || false;
            this.logger = baseLogger.create('languageUtils');
          }
          _createClass$3(LanguageUtil, [{
            key: "getScriptPartFromCode",
            value: function getScriptPartFromCode(code) {
              if (!code || code.indexOf('-') < 0) return null;
              var p = code.split('-');
              if (p.length === 2) return null;
              p.pop();
              if (p[p.length - 1].toLowerCase() === 'x') return null;
              return this.formatLanguageCode(p.join('-'));
            }
          }, {
            key: "getLanguagePartFromCode",
            value: function getLanguagePartFromCode(code) {
              if (!code || code.indexOf('-') < 0) return code;
              var p = code.split('-');
              return this.formatLanguageCode(p[0]);
            }
          }, {
            key: "formatLanguageCode",
            value: function formatLanguageCode(code) {
              if (typeof code === 'string' && code.indexOf('-') > -1) {
                var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
                var p = code.split('-');
                if (this.options.lowerCaseLng) {
                  p = p.map(function (part) {
                    return part.toLowerCase();
                  });
                } else if (p.length === 2) {
                  p[0] = p[0].toLowerCase();
                  p[1] = p[1].toUpperCase();
                  if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize$1(p[1].toLowerCase());
                } else if (p.length === 3) {
                  p[0] = p[0].toLowerCase();
                  if (p[1].length === 2) p[1] = p[1].toUpperCase();
                  if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
                  if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize$1(p[1].toLowerCase());
                  if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize$1(p[2].toLowerCase());
                }
                return p.join('-');
              }
              return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
            }
          }, {
            key: "isSupportedCode",
            value: function isSupportedCode(code) {
              if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
                code = this.getLanguagePartFromCode(code);
              }
              return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
            }
          }, {
            key: "getBestMatchFromCodes",
            value: function getBestMatchFromCodes(codes) {
              var _this = this;
              if (!codes) return null;
              var found;
              codes.forEach(function (code) {
                if (found) return;
                var cleanedLng = _this.formatLanguageCode(code);
                if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;
              });
              if (!found && this.options.supportedLngs) {
                codes.forEach(function (code) {
                  if (found) return;
                  var lngOnly = _this.getLanguagePartFromCode(code);
                  if (_this.isSupportedCode(lngOnly)) return found = lngOnly;
                  found = _this.options.supportedLngs.find(function (supportedLng) {
                    if (supportedLng === lngOnly) return supportedLng;
                    if (supportedLng.indexOf('-') < 0 && lngOnly.indexOf('-') < 0) return;
                    if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
                  });
                });
              }
              if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
              return found;
            }
          }, {
            key: "getFallbackCodes",
            value: function getFallbackCodes(fallbacks, code) {
              if (!fallbacks) return [];
              if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
              if (typeof fallbacks === 'string') fallbacks = [fallbacks];
              if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
              if (!code) return fallbacks["default"] || [];
              var found = fallbacks[code];
              if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
              if (!found) found = fallbacks[this.formatLanguageCode(code)];
              if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
              if (!found) found = fallbacks["default"];
              return found || [];
            }
          }, {
            key: "toResolveHierarchy",
            value: function toResolveHierarchy(code, fallbackCode) {
              var _this2 = this;
              var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
              var codes = [];
              var addCode = function addCode(c) {
                if (!c) return;
                if (_this2.isSupportedCode(c)) {
                  codes.push(c);
                } else {
                  _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c));
                }
              };
              if (typeof code === 'string' && code.indexOf('-') > -1) {
                if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
                if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
                if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
              } else if (typeof code === 'string') {
                addCode(this.formatLanguageCode(code));
              }
              fallbackCodes.forEach(function (fc) {
                if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));
              });
              return codes;
            }
          }]);
          return LanguageUtil;
        }();
        var sets = [{
          lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'tl', 'ti', 'tr', 'uz', 'wa'],
          nr: [1, 2],
          fc: 1
        }, {
          lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kk', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
          nr: [1, 2],
          fc: 2
        }, {
          lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
          nr: [1],
          fc: 3
        }, {
          lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
          nr: [1, 2, 5],
          fc: 4
        }, {
          lngs: ['ar'],
          nr: [0, 1, 2, 3, 11, 100],
          fc: 5
        }, {
          lngs: ['cs', 'sk'],
          nr: [1, 2, 5],
          fc: 6
        }, {
          lngs: ['csb', 'pl'],
          nr: [1, 2, 5],
          fc: 7
        }, {
          lngs: ['cy'],
          nr: [1, 2, 3, 8],
          fc: 8
        }, {
          lngs: ['fr'],
          nr: [1, 2],
          fc: 9
        }, {
          lngs: ['ga'],
          nr: [1, 2, 3, 7, 11],
          fc: 10
        }, {
          lngs: ['gd'],
          nr: [1, 2, 3, 20],
          fc: 11
        }, {
          lngs: ['is'],
          nr: [1, 2],
          fc: 12
        }, {
          lngs: ['jv'],
          nr: [0, 1],
          fc: 13
        }, {
          lngs: ['kw'],
          nr: [1, 2, 3, 4],
          fc: 14
        }, {
          lngs: ['lt'],
          nr: [1, 2, 10],
          fc: 15
        }, {
          lngs: ['lv'],
          nr: [1, 2, 0],
          fc: 16
        }, {
          lngs: ['mk'],
          nr: [1, 2],
          fc: 17
        }, {
          lngs: ['mnk'],
          nr: [0, 1, 2],
          fc: 18
        }, {
          lngs: ['mt'],
          nr: [1, 2, 11, 20],
          fc: 19
        }, {
          lngs: ['or'],
          nr: [2, 1],
          fc: 2
        }, {
          lngs: ['ro'],
          nr: [1, 2, 20],
          fc: 20
        }, {
          lngs: ['sl'],
          nr: [5, 1, 2, 3],
          fc: 21
        }, {
          lngs: ['he', 'iw'],
          nr: [1, 2, 20, 21],
          fc: 22
        }];
        var _rulesPluralsTypes = {
          1: function _(n) {
            return Number(n > 1);
          },
          2: function _(n) {
            return Number(n != 1);
          },
          3: function _(n) {
            return 0;
          },
          4: function _(n) {
            return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
          },
          5: function _(n) {
            return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
          },
          6: function _(n) {
            return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
          },
          7: function _(n) {
            return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
          },
          8: function _(n) {
            return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
          },
          9: function _(n) {
            return Number(n >= 2);
          },
          10: function _(n) {
            return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
          },
          11: function _(n) {
            return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
          },
          12: function _(n) {
            return Number(n % 10 != 1 || n % 100 == 11);
          },
          13: function _(n) {
            return Number(n !== 0);
          },
          14: function _(n) {
            return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
          },
          15: function _(n) {
            return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
          },
          16: function _(n) {
            return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
          },
          17: function _(n) {
            return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
          },
          18: function _(n) {
            return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
          },
          19: function _(n) {
            return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
          },
          20: function _(n) {
            return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
          },
          21: function _(n) {
            return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
          },
          22: function _(n) {
            return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
          }
        };
        var deprecatedJsonVersions = ['v1', 'v2', 'v3'];
        var suffixesOrder = {
          zero: 0,
          one: 1,
          two: 2,
          few: 3,
          many: 4,
          other: 5
        };
        function createRules() {
          var rules = {};
          sets.forEach(function (set) {
            set.lngs.forEach(function (l) {
              rules[l] = {
                numbers: set.nr,
                plurals: _rulesPluralsTypes[set.fc]
              };
            });
          });
          return rules;
        }
        var PluralResolver = function () {
          function PluralResolver(languageUtils) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck$3(this, PluralResolver);
            this.languageUtils = languageUtils;
            this.options = options;
            this.logger = baseLogger.create('pluralResolver');
            if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === 'v4') && (typeof Intl === 'undefined' || !Intl.PluralRules)) {
              this.options.compatibilityJSON = 'v3';
              this.logger.error('Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.');
            }
            this.rules = createRules();
          }
          _createClass$3(PluralResolver, [{
            key: "addRule",
            value: function addRule(lng, obj) {
              this.rules[lng] = obj;
            }
          }, {
            key: "getRule",
            value: function getRule(code) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              if (this.shouldUseIntlApi()) {
                try {
                  return new Intl.PluralRules(code, {
                    type: options.ordinal ? 'ordinal' : 'cardinal'
                  });
                } catch (_unused) {
                  return;
                }
              }
              return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
            }
          }, {
            key: "needsPlural",
            value: function needsPlural(code) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var rule = this.getRule(code, options);
              if (this.shouldUseIntlApi()) {
                return rule && rule.resolvedOptions().pluralCategories.length > 1;
              }
              return rule && rule.numbers.length > 1;
            }
          }, {
            key: "getPluralFormsOfKey",
            value: function getPluralFormsOfKey(code, key) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              return this.getSuffixes(code, options).map(function (suffix) {
                return "".concat(key).concat(suffix);
              });
            }
          }, {
            key: "getSuffixes",
            value: function getSuffixes(code) {
              var _this = this;
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var rule = this.getRule(code, options);
              if (!rule) {
                return [];
              }
              if (this.shouldUseIntlApi()) {
                return rule.resolvedOptions().pluralCategories.sort(function (pluralCategory1, pluralCategory2) {
                  return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
                }).map(function (pluralCategory) {
                  return "".concat(_this.options.prepend).concat(pluralCategory);
                });
              }
              return rule.numbers.map(function (number) {
                return _this.getSuffix(code, number, options);
              });
            }
          }, {
            key: "getSuffix",
            value: function getSuffix(code, count) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              var rule = this.getRule(code, options);
              if (rule) {
                if (this.shouldUseIntlApi()) {
                  return "".concat(this.options.prepend).concat(rule.select(count));
                }
                return this.getSuffixRetroCompatible(rule, count);
              }
              this.logger.warn("no plural rule found for: ".concat(code));
              return '';
            }
          }, {
            key: "getSuffixRetroCompatible",
            value: function getSuffixRetroCompatible(rule, count) {
              var _this2 = this;
              var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
              var suffix = rule.numbers[idx];
              if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
                if (suffix === 2) {
                  suffix = 'plural';
                } else if (suffix === 1) {
                  suffix = '';
                }
              }
              var returnSuffix = function returnSuffix() {
                return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
              };
              if (this.options.compatibilityJSON === 'v1') {
                if (suffix === 1) return '';
                if (typeof suffix === 'number') return "_plural_".concat(suffix.toString());
                return returnSuffix();
              } else if (this.options.compatibilityJSON === 'v2') {
                return returnSuffix();
              } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
                return returnSuffix();
              }
              return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
            }
          }, {
            key: "shouldUseIntlApi",
            value: function shouldUseIntlApi() {
              return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
            }
          }]);
          return PluralResolver;
        }();
        function ownKeys$3$1(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$3$1(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$3$1(Object(source), true).forEach(function (key) {
              _defineProperty$6(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3$1(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function deepFindWithDefaults(data, defaultData, key) {
          var keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
          var ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
          var path = getPathWithDefaults(data, defaultData, key);
          if (!path && ignoreJSONStructure && typeof key === 'string') {
            path = deepFind(data, key, keySeparator);
            if (path === undefined) path = deepFind(defaultData, key, keySeparator);
          }
          return path;
        }
        var Interpolator = function () {
          function Interpolator() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            _classCallCheck$3(this, Interpolator);
            this.logger = baseLogger.create('interpolator');
            this.options = options;
            this.format = options.interpolation && options.interpolation.format || function (value) {
              return value;
            };
            this.init(options);
          }
          _createClass$3(Interpolator, [{
            key: "init",
            value: function init() {
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              if (!options.interpolation) options.interpolation = {
                escapeValue: true
              };
              var iOpts = options.interpolation;
              this.escape = iOpts.escape !== undefined ? iOpts.escape : escape$1;
              this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
              this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
              this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
              this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
              this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
              this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
              this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
              this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
              this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
              this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';
              this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;
              this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;
              this.resetRegExp();
            }
          }, {
            key: "reset",
            value: function reset() {
              if (this.options) this.init(this.options);
            }
          }, {
            key: "resetRegExp",
            value: function resetRegExp() {
              var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
              this.regexp = new RegExp(regexpStr, 'g');
              var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
              this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
              var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
              this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
            }
          }, {
            key: "interpolate",
            value: function interpolate(str, data, lng, options) {
              var _this = this;
              var match;
              var value;
              var replaces;
              var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
              function regexSafe(val) {
                return val.replace(/\$/g, '$$$$');
              }
              var handleFormat = function handleFormat(key) {
                if (key.indexOf(_this.formatSeparator) < 0) {
                  var path = deepFindWithDefaults(data, defaultData, key, _this.options.keySeparator, _this.options.ignoreJSONStructure);
                  return _this.alwaysFormat ? _this.format(path, undefined, lng, _objectSpread$3$1(_objectSpread$3$1(_objectSpread$3$1({}, options), data), {}, {
                    interpolationkey: key
                  })) : path;
                }
                var p = key.split(_this.formatSeparator);
                var k = p.shift().trim();
                var f = p.join(_this.formatSeparator).trim();
                return _this.format(deepFindWithDefaults(data, defaultData, k, _this.options.keySeparator, _this.options.ignoreJSONStructure), f, lng, _objectSpread$3$1(_objectSpread$3$1(_objectSpread$3$1({}, options), data), {}, {
                  interpolationkey: k
                }));
              };
              this.resetRegExp();
              var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
              var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
              var todos = [{
                regex: this.regexpUnescape,
                safeValue: function safeValue(val) {
                  return regexSafe(val);
                }
              }, {
                regex: this.regexp,
                safeValue: function safeValue(val) {
                  return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
                }
              }];
              todos.forEach(function (todo) {
                replaces = 0;
                while (match = todo.regex.exec(str)) {
                  var matchedVar = match[1].trim();
                  value = handleFormat(matchedVar);
                  if (value === undefined) {
                    if (typeof missingInterpolationHandler === 'function') {
                      var temp = missingInterpolationHandler(str, match, options);
                      value = typeof temp === 'string' ? temp : '';
                    } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
                      value = '';
                    } else if (skipOnVariables) {
                      value = match[0];
                      continue;
                    } else {
                      _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
                      value = '';
                    }
                  } else if (typeof value !== 'string' && !_this.useRawValueToEscape) {
                    value = makeString(value);
                  }
                  var safeValue = todo.safeValue(value);
                  str = str.replace(match[0], safeValue);
                  if (skipOnVariables) {
                    todo.regex.lastIndex += value.length;
                    todo.regex.lastIndex -= match[0].length;
                  } else {
                    todo.regex.lastIndex = 0;
                  }
                  replaces++;
                  if (replaces >= _this.maxReplaces) {
                    break;
                  }
                }
              });
              return str;
            }
          }, {
            key: "nest",
            value: function nest(str, fc) {
              var _this2 = this;
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              var match;
              var value;
              var clonedOptions;
              function handleHasOptions(key, inheritedOptions) {
                var sep = this.nestingOptionsSeparator;
                if (key.indexOf(sep) < 0) return key;
                var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
                var optionsString = "{".concat(c[1]);
                key = c[0];
                optionsString = this.interpolate(optionsString, clonedOptions);
                var matchedSingleQuotes = optionsString.match(/'/g);
                var matchedDoubleQuotes = optionsString.match(/"/g);
                if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
                  optionsString = optionsString.replace(/'/g, '"');
                }
                try {
                  clonedOptions = JSON.parse(optionsString);
                  if (inheritedOptions) clonedOptions = _objectSpread$3$1(_objectSpread$3$1({}, inheritedOptions), clonedOptions);
                } catch (e) {
                  this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
                  return "".concat(key).concat(sep).concat(optionsString);
                }
                delete clonedOptions.defaultValue;
                return key;
              }
              while (match = this.nestingRegexp.exec(str)) {
                var formatters = [];
                clonedOptions = _objectSpread$3$1({}, options);
                clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== 'string' ? clonedOptions.replace : clonedOptions;
                clonedOptions.applyPostProcessor = false;
                delete clonedOptions.defaultValue;
                var doReduce = false;
                if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
                  var r = match[1].split(this.formatSeparator).map(function (elem) {
                    return elem.trim();
                  });
                  match[1] = r.shift();
                  formatters = r;
                  doReduce = true;
                }
                value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
                if (value && match[0] === str && typeof value !== 'string') return value;
                if (typeof value !== 'string') value = makeString(value);
                if (!value) {
                  this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
                  value = '';
                }
                if (doReduce) {
                  value = formatters.reduce(function (v, f) {
                    return _this2.format(v, f, options.lng, _objectSpread$3$1(_objectSpread$3$1({}, options), {}, {
                      interpolationkey: match[1].trim()
                    }));
                  }, value.trim());
                }
                str = str.replace(match[0], value);
                this.regexp.lastIndex = 0;
              }
              return str;
            }
          }]);
          return Interpolator;
        }();
        function ownKeys$2$1(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$2$1(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$2$1(Object(source), true).forEach(function (key) {
              _defineProperty$6(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2$1(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function parseFormatStr(formatStr) {
          var formatName = formatStr.toLowerCase().trim();
          var formatOptions = {};
          if (formatStr.indexOf('(') > -1) {
            var p = formatStr.split('(');
            formatName = p[0].toLowerCase().trim();
            var optStr = p[1].substring(0, p[1].length - 1);
            if (formatName === 'currency' && optStr.indexOf(':') < 0) {
              if (!formatOptions.currency) formatOptions.currency = optStr.trim();
            } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {
              if (!formatOptions.range) formatOptions.range = optStr.trim();
            } else {
              var opts = optStr.split(';');
              opts.forEach(function (opt) {
                if (!opt) return;
                var _opt$split = opt.split(':'),
                  _opt$split2 = _toArray(_opt$split),
                  key = _opt$split2[0],
                  rest = _opt$split2.slice(1);
                var val = rest.join(':').trim().replace(/^'+|'+$/g, '');
                if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;
                if (val === 'false') formatOptions[key.trim()] = false;
                if (val === 'true') formatOptions[key.trim()] = true;
                if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);
              });
            }
          }
          return {
            formatName: formatName,
            formatOptions: formatOptions
          };
        }
        function createCachedFormatter(fn) {
          var cache = {};
          return function invokeFormatter(val, lng, options) {
            var key = lng + JSON.stringify(options);
            var formatter = cache[key];
            if (!formatter) {
              formatter = fn(lng, options);
              cache[key] = formatter;
            }
            return formatter(val);
          };
        }
        var Formatter = function () {
          function Formatter() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            _classCallCheck$3(this, Formatter);
            this.logger = baseLogger.create('formatter');
            this.options = options;
            this.formats = {
              number: createCachedFormatter(function (lng, opt) {
                var formatter = new Intl.NumberFormat(lng, _objectSpread$2$1({}, opt));
                return function (val) {
                  return formatter.format(val);
                };
              }),
              currency: createCachedFormatter(function (lng, opt) {
                var formatter = new Intl.NumberFormat(lng, _objectSpread$2$1(_objectSpread$2$1({}, opt), {}, {
                  style: 'currency'
                }));
                return function (val) {
                  return formatter.format(val);
                };
              }),
              datetime: createCachedFormatter(function (lng, opt) {
                var formatter = new Intl.DateTimeFormat(lng, _objectSpread$2$1({}, opt));
                return function (val) {
                  return formatter.format(val);
                };
              }),
              relativetime: createCachedFormatter(function (lng, opt) {
                var formatter = new Intl.RelativeTimeFormat(lng, _objectSpread$2$1({}, opt));
                return function (val) {
                  return formatter.format(val, opt.range || 'day');
                };
              }),
              list: createCachedFormatter(function (lng, opt) {
                var formatter = new Intl.ListFormat(lng, _objectSpread$2$1({}, opt));
                return function (val) {
                  return formatter.format(val);
                };
              })
            };
            this.init(options);
          }
          _createClass$3(Formatter, [{
            key: "init",
            value: function init(services) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                interpolation: {}
              };
              var iOpts = options.interpolation;
              this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
            }
          }, {
            key: "add",
            value: function add(name, fc) {
              this.formats[name.toLowerCase().trim()] = fc;
            }
          }, {
            key: "addCached",
            value: function addCached(name, fc) {
              this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
            }
          }, {
            key: "format",
            value: function format(value, _format, lng) {
              var _this = this;
              var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
              var formats = _format.split(this.formatSeparator);
              var result = formats.reduce(function (mem, f) {
                var _parseFormatStr = parseFormatStr(f),
                  formatName = _parseFormatStr.formatName,
                  formatOptions = _parseFormatStr.formatOptions;
                if (_this.formats[formatName]) {
                  var formatted = mem;
                  try {
                    var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
                    var l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
                    formatted = _this.formats[formatName](mem, l, _objectSpread$2$1(_objectSpread$2$1(_objectSpread$2$1({}, formatOptions), options), valOptions));
                  } catch (error) {
                    _this.logger.warn(error);
                  }
                  return formatted;
                } else {
                  _this.logger.warn("there was no format function for ".concat(formatName));
                }
                return mem;
              }, value);
              return result;
            }
          }]);
          return Formatter;
        }();
        function ownKeys$1$1(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$1$1(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$1$1(Object(source), true).forEach(function (key) {
              _defineProperty$6(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$1(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$1(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$1(this, result);
          };
        }
        function _isNativeReflectConstruct$1() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        function removePending(q, name) {
          if (q.pending[name] !== undefined) {
            delete q.pending[name];
            q.pendingCount--;
          }
        }
        var Connector = function (_EventEmitter) {
          _inherits$1(Connector, _EventEmitter);
          var _super = _createSuper$1(Connector);
          function Connector(backend, store, services) {
            var _this;
            var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
            _classCallCheck$3(this, Connector);
            _this = _super.call(this);
            if (isIE10) {
              EventEmitter.call(_assertThisInitialized$1(_this));
            }
            _this.backend = backend;
            _this.store = store;
            _this.services = services;
            _this.languageUtils = services.languageUtils;
            _this.options = options;
            _this.logger = baseLogger.create('backendConnector');
            _this.waitingReads = [];
            _this.maxParallelReads = options.maxParallelReads || 10;
            _this.readingCalls = 0;
            _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
            _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
            _this.state = {};
            _this.queue = [];
            if (_this.backend && _this.backend.init) {
              _this.backend.init(services, options.backend, options);
            }
            return _this;
          }
          _createClass$3(Connector, [{
            key: "queueLoad",
            value: function queueLoad(languages, namespaces, options, callback) {
              var _this2 = this;
              var toLoad = {};
              var pending = {};
              var toLoadLanguages = {};
              var toLoadNamespaces = {};
              languages.forEach(function (lng) {
                var hasAllNamespaces = true;
                namespaces.forEach(function (ns) {
                  var name = "".concat(lng, "|").concat(ns);
                  if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
                    _this2.state[name] = 2;
                  } else if (_this2.state[name] < 0) ;else if (_this2.state[name] === 1) {
                    if (pending[name] === undefined) pending[name] = true;
                  } else {
                    _this2.state[name] = 1;
                    hasAllNamespaces = false;
                    if (pending[name] === undefined) pending[name] = true;
                    if (toLoad[name] === undefined) toLoad[name] = true;
                    if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;
                  }
                });
                if (!hasAllNamespaces) toLoadLanguages[lng] = true;
              });
              if (Object.keys(toLoad).length || Object.keys(pending).length) {
                this.queue.push({
                  pending: pending,
                  pendingCount: Object.keys(pending).length,
                  loaded: {},
                  errors: [],
                  callback: callback
                });
              }
              return {
                toLoad: Object.keys(toLoad),
                pending: Object.keys(pending),
                toLoadLanguages: Object.keys(toLoadLanguages),
                toLoadNamespaces: Object.keys(toLoadNamespaces)
              };
            }
          }, {
            key: "loaded",
            value: function loaded(name, err, data) {
              var s = name.split('|');
              var lng = s[0];
              var ns = s[1];
              if (err) this.emit('failedLoading', lng, ns, err);
              if (data) {
                this.store.addResourceBundle(lng, ns, data);
              }
              this.state[name] = err ? -1 : 2;
              var loaded = {};
              this.queue.forEach(function (q) {
                pushPath(q.loaded, [lng], ns);
                removePending(q, name);
                if (err) q.errors.push(err);
                if (q.pendingCount === 0 && !q.done) {
                  Object.keys(q.loaded).forEach(function (l) {
                    if (!loaded[l]) loaded[l] = {};
                    var loadedKeys = q.loaded[l];
                    if (loadedKeys.length) {
                      loadedKeys.forEach(function (n) {
                        if (loaded[l][n] === undefined) loaded[l][n] = true;
                      });
                    }
                  });
                  q.done = true;
                  if (q.errors.length) {
                    q.callback(q.errors);
                  } else {
                    q.callback();
                  }
                }
              });
              this.emit('loaded', loaded);
              this.queue = this.queue.filter(function (q) {
                return !q.done;
              });
            }
          }, {
            key: "read",
            value: function read(lng, ns, fcName) {
              var _this3 = this;
              var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
              var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;
              var callback = arguments.length > 5 ? arguments[5] : undefined;
              if (!lng.length) return callback(null, {});
              if (this.readingCalls >= this.maxParallelReads) {
                this.waitingReads.push({
                  lng: lng,
                  ns: ns,
                  fcName: fcName,
                  tried: tried,
                  wait: wait,
                  callback: callback
                });
                return;
              }
              this.readingCalls++;
              var resolver = function resolver(err, data) {
                _this3.readingCalls--;
                if (_this3.waitingReads.length > 0) {
                  var next = _this3.waitingReads.shift();
                  _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
                }
                if (err && data && tried < _this3.maxRetries) {
                  setTimeout(function () {
                    _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
                  }, wait);
                  return;
                }
                callback(err, data);
              };
              var fc = this.backend[fcName].bind(this.backend);
              if (fc.length === 2) {
                try {
                  var r = fc(lng, ns);
                  if (r && typeof r.then === 'function') {
                    r.then(function (data) {
                      return resolver(null, data);
                    })["catch"](resolver);
                  } else {
                    resolver(null, r);
                  }
                } catch (err) {
                  resolver(err);
                }
                return;
              }
              return fc(lng, ns, resolver);
            }
          }, {
            key: "prepareLoading",
            value: function prepareLoading(languages, namespaces) {
              var _this4 = this;
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              var callback = arguments.length > 3 ? arguments[3] : undefined;
              if (!this.backend) {
                this.logger.warn('No backend was added via i18next.use. Will not load resources.');
                return callback && callback();
              }
              if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
              if (typeof namespaces === 'string') namespaces = [namespaces];
              var toLoad = this.queueLoad(languages, namespaces, options, callback);
              if (!toLoad.toLoad.length) {
                if (!toLoad.pending.length) callback();
                return null;
              }
              toLoad.toLoad.forEach(function (name) {
                _this4.loadOne(name);
              });
            }
          }, {
            key: "load",
            value: function load(languages, namespaces, callback) {
              this.prepareLoading(languages, namespaces, {}, callback);
            }
          }, {
            key: "reload",
            value: function reload(languages, namespaces, callback) {
              this.prepareLoading(languages, namespaces, {
                reload: true
              }, callback);
            }
          }, {
            key: "loadOne",
            value: function loadOne(name) {
              var _this5 = this;
              var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
              var s = name.split('|');
              var lng = s[0];
              var ns = s[1];
              this.read(lng, ns, 'read', undefined, undefined, function (err, data) {
                if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
                if (!err && data) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
                _this5.loaded(name, err, data);
              });
            }
          }, {
            key: "saveMissing",
            value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
              var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
              var clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function () {};
              if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
                this.logger.warn("did not save key \"".concat(key, "\" as the namespace \"").concat(namespace, "\" was not yet loaded"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
                return;
              }
              if (key === undefined || key === null || key === '') return;
              if (this.backend && this.backend.create) {
                var opts = _objectSpread$1$1(_objectSpread$1$1({}, options), {}, {
                  isUpdate: isUpdate
                });
                var fc = this.backend.create.bind(this.backend);
                if (fc.length < 6) {
                  try {
                    var r;
                    if (fc.length === 5) {
                      r = fc(languages, namespace, key, fallbackValue, opts);
                    } else {
                      r = fc(languages, namespace, key, fallbackValue);
                    }
                    if (r && typeof r.then === 'function') {
                      r.then(function (data) {
                        return clb(null, data);
                      })["catch"](clb);
                    } else {
                      clb(null, r);
                    }
                  } catch (err) {
                    clb(err);
                  }
                } else {
                  fc(languages, namespace, key, fallbackValue, clb, opts);
                }
              }
              if (!languages || !languages[0]) return;
              this.store.addResource(languages[0], namespace, key, fallbackValue);
            }
          }]);
          return Connector;
        }(EventEmitter);
        function get$3() {
          return {
            debug: false,
            initImmediate: true,
            ns: ['translation'],
            defaultNS: ['translation'],
            fallbackLng: ['dev'],
            fallbackNS: false,
            supportedLngs: false,
            nonExplicitSupportedLngs: false,
            load: 'all',
            preload: false,
            simplifyPluralSuffix: true,
            keySeparator: '.',
            nsSeparator: ':',
            pluralSeparator: '_',
            contextSeparator: '_',
            partialBundledLanguages: false,
            saveMissing: false,
            updateMissing: false,
            saveMissingTo: 'fallback',
            saveMissingPlurals: true,
            missingKeyHandler: false,
            missingInterpolationHandler: false,
            postProcess: false,
            postProcessPassResolved: false,
            returnNull: true,
            returnEmptyString: true,
            returnObjects: false,
            joinArrays: false,
            returnedObjectHandler: false,
            parseMissingKeyHandler: false,
            appendNamespaceToMissingKey: false,
            appendNamespaceToCIMode: false,
            overloadTranslationOptionHandler: function handle(args) {
              var ret = {};
              if (_typeof$6(args[1]) === 'object') ret = args[1];
              if (typeof args[1] === 'string') ret.defaultValue = args[1];
              if (typeof args[2] === 'string') ret.tDescription = args[2];
              if (_typeof$6(args[2]) === 'object' || _typeof$6(args[3]) === 'object') {
                var options = args[3] || args[2];
                Object.keys(options).forEach(function (key) {
                  ret[key] = options[key];
                });
              }
              return ret;
            },
            interpolation: {
              escapeValue: true,
              format: function format(value, _format, lng, options) {
                return value;
              },
              prefix: '{{',
              suffix: '}}',
              formatSeparator: ',',
              unescapePrefix: '-',
              nestingPrefix: '$t(',
              nestingSuffix: ')',
              nestingOptionsSeparator: ',',
              maxReplaces: 1000,
              skipOnVariables: true
            }
          };
        }
        function transformOptions(options) {
          if (typeof options.ns === 'string') options.ns = [options.ns];
          if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
          if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];
          if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {
            options.supportedLngs = options.supportedLngs.concat(['cimode']);
          }
          return options;
        }
        function ownKeys$7(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$7(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$7(Object(source), true).forEach(function (key) {
              _defineProperty$6(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$1(this, result);
          };
        }
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        function noop$2() {}
        function bindMemberFunctions(inst) {
          var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
          mems.forEach(function (mem) {
            if (typeof inst[mem] === 'function') {
              inst[mem] = inst[mem].bind(inst);
            }
          });
        }
        var I18n = function (_EventEmitter) {
          _inherits$1(I18n, _EventEmitter);
          var _super = _createSuper(I18n);
          function I18n() {
            var _this;
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var callback = arguments.length > 1 ? arguments[1] : undefined;
            _classCallCheck$3(this, I18n);
            _this = _super.call(this);
            if (isIE10) {
              EventEmitter.call(_assertThisInitialized$1(_this));
            }
            _this.options = transformOptions(options);
            _this.services = {};
            _this.logger = baseLogger;
            _this.modules = {
              external: []
            };
            bindMemberFunctions(_assertThisInitialized$1(_this));
            if (callback && !_this.isInitialized && !options.isClone) {
              if (!_this.options.initImmediate) {
                _this.init(options, callback);
                return _possibleConstructorReturn$1(_this, _assertThisInitialized$1(_this));
              }
              setTimeout(function () {
                _this.init(options, callback);
              }, 0);
            }
            return _this;
          }
          _createClass$3(I18n, [{
            key: "init",
            value: function init() {
              var _this2 = this;
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var callback = arguments.length > 1 ? arguments[1] : undefined;
              if (typeof options === 'function') {
                callback = options;
                options = {};
              }
              if (!options.defaultNS && options.defaultNS !== false && options.ns) {
                if (typeof options.ns === 'string') {
                  options.defaultNS = options.ns;
                } else if (options.ns.indexOf('translation') < 0) {
                  options.defaultNS = options.ns[0];
                }
              }
              var defOpts = get$3();
              this.options = _objectSpread$7(_objectSpread$7(_objectSpread$7({}, defOpts), this.options), transformOptions(options));
              if (this.options.compatibilityAPI !== 'v1') {
                this.options.interpolation = _objectSpread$7(_objectSpread$7({}, defOpts.interpolation), this.options.interpolation);
              }
              if (options.keySeparator !== undefined) {
                this.options.userDefinedKeySeparator = options.keySeparator;
              }
              if (options.nsSeparator !== undefined) {
                this.options.userDefinedNsSeparator = options.nsSeparator;
              }
              function createClassOnDemand(ClassOrObject) {
                if (!ClassOrObject) return null;
                if (typeof ClassOrObject === 'function') return new ClassOrObject();
                return ClassOrObject;
              }
              if (!this.options.isClone) {
                if (this.modules.logger) {
                  baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
                } else {
                  baseLogger.init(null, this.options);
                }
                var formatter;
                if (this.modules.formatter) {
                  formatter = this.modules.formatter;
                } else if (typeof Intl !== 'undefined') {
                  formatter = Formatter;
                }
                var lu = new LanguageUtil(this.options);
                this.store = new ResourceStore(this.options.resources, this.options);
                var s = this.services;
                s.logger = baseLogger;
                s.resourceStore = this.store;
                s.languageUtils = lu;
                s.pluralResolver = new PluralResolver(lu, {
                  prepend: this.options.pluralSeparator,
                  compatibilityJSON: this.options.compatibilityJSON,
                  simplifyPluralSuffix: this.options.simplifyPluralSuffix
                });
                if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
                  s.formatter = createClassOnDemand(formatter);
                  s.formatter.init(s, this.options);
                  this.options.interpolation.format = s.formatter.format.bind(s.formatter);
                }
                s.interpolator = new Interpolator(this.options);
                s.utils = {
                  hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
                };
                s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
                s.backendConnector.on('*', function (event) {
                  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  _this2.emit.apply(_this2, [event].concat(args));
                });
                if (this.modules.languageDetector) {
                  s.languageDetector = createClassOnDemand(this.modules.languageDetector);
                  if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
                }
                if (this.modules.i18nFormat) {
                  s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
                  if (s.i18nFormat.init) s.i18nFormat.init(this);
                }
                this.translator = new Translator(this.services, this.options);
                this.translator.on('*', function (event) {
                  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                    args[_key2 - 1] = arguments[_key2];
                  }
                  _this2.emit.apply(_this2, [event].concat(args));
                });
                this.modules.external.forEach(function (m) {
                  if (m.init) m.init(_this2);
                });
              }
              this.format = this.options.interpolation.format;
              if (!callback) callback = noop$2;
              if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
                var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];
              }
              if (!this.services.languageDetector && !this.options.lng) {
                this.logger.warn('init: no languageDetector is used and no lng is defined');
              }
              var storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
              storeApi.forEach(function (fcName) {
                _this2[fcName] = function () {
                  var _this2$store;
                  return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
                };
              });
              var storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];
              storeApiChained.forEach(function (fcName) {
                _this2[fcName] = function () {
                  var _this2$store2;
                  (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
                  return _this2;
                };
              });
              var deferred = defer();
              var load = function load() {
                var finish = function finish(err, t) {
                  if (_this2.isInitialized && !_this2.initializedStoreOnce) _this2.logger.warn('init: i18next is already initialized. You should call init just once!');
                  _this2.isInitialized = true;
                  if (!_this2.options.isClone) _this2.logger.log('initialized', _this2.options);
                  _this2.emit('initialized', _this2.options);
                  deferred.resolve(t);
                  callback(err, t);
                };
                if (_this2.languages && _this2.options.compatibilityAPI !== 'v1' && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));
                _this2.changeLanguage(_this2.options.lng, finish);
              };
              if (this.options.resources || !this.options.initImmediate) {
                load();
              } else {
                setTimeout(load, 0);
              }
              return deferred;
            }
          }, {
            key: "loadResources",
            value: function loadResources(language) {
              var _this3 = this;
              var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$2;
              var usedCallback = callback;
              var usedLng = typeof language === 'string' ? language : this.language;
              if (typeof language === 'function') usedCallback = language;
              if (!this.options.resources || this.options.partialBundledLanguages) {
                if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback();
                var toLoad = [];
                var append = function append(lng) {
                  if (!lng) return;
                  var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
                  lngs.forEach(function (l) {
                    if (toLoad.indexOf(l) < 0) toLoad.push(l);
                  });
                };
                if (!usedLng) {
                  var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                  fallbacks.forEach(function (l) {
                    return append(l);
                  });
                } else {
                  append(usedLng);
                }
                if (this.options.preload) {
                  this.options.preload.forEach(function (l) {
                    return append(l);
                  });
                }
                this.services.backendConnector.load(toLoad, this.options.ns, function (e) {
                  if (!e && !_this3.resolvedLanguage && _this3.language) _this3.setResolvedLanguage(_this3.language);
                  usedCallback(e);
                });
              } else {
                usedCallback(null);
              }
            }
          }, {
            key: "reloadResources",
            value: function reloadResources(lngs, ns, callback) {
              var deferred = defer();
              if (!lngs) lngs = this.languages;
              if (!ns) ns = this.options.ns;
              if (!callback) callback = noop$2;
              this.services.backendConnector.reload(lngs, ns, function (err) {
                deferred.resolve();
                callback(err);
              });
              return deferred;
            }
          }, {
            key: "use",
            value: function use(module) {
              if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
              if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');
              if (module.type === 'backend') {
                this.modules.backend = module;
              }
              if (module.type === 'logger' || module.log && module.warn && module.error) {
                this.modules.logger = module;
              }
              if (module.type === 'languageDetector') {
                this.modules.languageDetector = module;
              }
              if (module.type === 'i18nFormat') {
                this.modules.i18nFormat = module;
              }
              if (module.type === 'postProcessor') {
                postProcessor.addPostProcessor(module);
              }
              if (module.type === 'formatter') {
                this.modules.formatter = module;
              }
              if (module.type === '3rdParty') {
                this.modules.external.push(module);
              }
              return this;
            }
          }, {
            key: "setResolvedLanguage",
            value: function setResolvedLanguage(l) {
              if (!l || !this.languages) return;
              if (['cimode', 'dev'].indexOf(l) > -1) return;
              for (var li = 0; li < this.languages.length; li++) {
                var lngInLngs = this.languages[li];
                if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;
                if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
                  this.resolvedLanguage = lngInLngs;
                  break;
                }
              }
            }
          }, {
            key: "changeLanguage",
            value: function changeLanguage(lng, callback) {
              var _this4 = this;
              this.isLanguageChangingTo = lng;
              var deferred = defer();
              this.emit('languageChanging', lng);
              var setLngProps = function setLngProps(l) {
                _this4.language = l;
                _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
                _this4.resolvedLanguage = undefined;
                _this4.setResolvedLanguage(l);
              };
              var done = function done(err, l) {
                if (l) {
                  setLngProps(l);
                  _this4.translator.changeLanguage(l);
                  _this4.isLanguageChangingTo = undefined;
                  _this4.emit('languageChanged', l);
                  _this4.logger.log('languageChanged', l);
                } else {
                  _this4.isLanguageChangingTo = undefined;
                }
                deferred.resolve(function () {
                  return _this4.t.apply(_this4, arguments);
                });
                if (callback) callback(err, function () {
                  return _this4.t.apply(_this4, arguments);
                });
              };
              var setLng = function setLng(lngs) {
                if (!lng && !lngs && _this4.services.languageDetector) lngs = [];
                var l = typeof lngs === 'string' ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
                if (l) {
                  if (!_this4.language) {
                    setLngProps(l);
                  }
                  if (!_this4.translator.language) _this4.translator.changeLanguage(l);
                  if (_this4.services.languageDetector && _this4.services.languageDetector.cacheUserLanguage) _this4.services.languageDetector.cacheUserLanguage(l);
                }
                _this4.loadResources(l, function (err) {
                  done(err, l);
                });
              };
              if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
                setLng(this.services.languageDetector.detect());
              } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
                if (this.services.languageDetector.detect.length === 0) {
                  this.services.languageDetector.detect().then(setLng);
                } else {
                  this.services.languageDetector.detect(setLng);
                }
              } else {
                setLng(lng);
              }
              return deferred;
            }
          }, {
            key: "getFixedT",
            value: function getFixedT(lng, ns, keyPrefix) {
              var _this5 = this;
              var fixedT = function fixedT(key, opts) {
                var options;
                if (_typeof$6(opts) !== 'object') {
                  for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
                    rest[_key3 - 2] = arguments[_key3];
                  }
                  options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
                } else {
                  options = _objectSpread$7({}, opts);
                }
                options.lng = options.lng || fixedT.lng;
                options.lngs = options.lngs || fixedT.lngs;
                options.ns = options.ns || fixedT.ns;
                options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
                var keySeparator = _this5.options.keySeparator || '.';
                var resultKey;
                if (options.keyPrefix && Array.isArray(key)) {
                  resultKey = key.map(function (k) {
                    return "".concat(options.keyPrefix).concat(keySeparator).concat(k);
                  });
                } else {
                  resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
                }
                return _this5.t(resultKey, options);
              };
              if (typeof lng === 'string') {
                fixedT.lng = lng;
              } else {
                fixedT.lngs = lng;
              }
              fixedT.ns = ns;
              fixedT.keyPrefix = keyPrefix;
              return fixedT;
            }
          }, {
            key: "t",
            value: function t() {
              var _this$translator;
              return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
            }
          }, {
            key: "exists",
            value: function exists() {
              var _this$translator2;
              return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
            }
          }, {
            key: "setDefaultNamespace",
            value: function setDefaultNamespace(ns) {
              this.options.defaultNS = ns;
            }
          }, {
            key: "hasLoadedNamespace",
            value: function hasLoadedNamespace(ns) {
              var _this6 = this;
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              if (!this.isInitialized) {
                this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
                return false;
              }
              if (!this.languages || !this.languages.length) {
                this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
                return false;
              }
              var lng = options.lng || this.resolvedLanguage || this.languages[0];
              var fallbackLng = this.options ? this.options.fallbackLng : false;
              var lastLng = this.languages[this.languages.length - 1];
              if (lng.toLowerCase() === 'cimode') return true;
              var loadNotPending = function loadNotPending(l, n) {
                var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];
                return loadState === -1 || loadState === 2;
              };
              if (options.precheck) {
                var preResult = options.precheck(this, loadNotPending);
                if (preResult !== undefined) return preResult;
              }
              if (this.hasResourceBundle(lng, ns)) return true;
              if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
              if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
              return false;
            }
          }, {
            key: "loadNamespaces",
            value: function loadNamespaces(ns, callback) {
              var _this7 = this;
              var deferred = defer();
              if (!this.options.ns) {
                if (callback) callback();
                return Promise.resolve();
              }
              if (typeof ns === 'string') ns = [ns];
              ns.forEach(function (n) {
                if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);
              });
              this.loadResources(function (err) {
                deferred.resolve();
                if (callback) callback(err);
              });
              return deferred;
            }
          }, {
            key: "loadLanguages",
            value: function loadLanguages(lngs, callback) {
              var deferred = defer();
              if (typeof lngs === 'string') lngs = [lngs];
              var preloaded = this.options.preload || [];
              var newLngs = lngs.filter(function (lng) {
                return preloaded.indexOf(lng) < 0;
              });
              if (!newLngs.length) {
                if (callback) callback();
                return Promise.resolve();
              }
              this.options.preload = preloaded.concat(newLngs);
              this.loadResources(function (err) {
                deferred.resolve();
                if (callback) callback(err);
              });
              return deferred;
            }
          }, {
            key: "dir",
            value: function dir(lng) {
              if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
              if (!lng) return 'rtl';
              var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];
              var languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get$3());
              return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';
            }
          }, {
            key: "cloneInstance",
            value: function cloneInstance() {
              var _this8 = this;
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$2;
              var mergedOptions = _objectSpread$7(_objectSpread$7(_objectSpread$7({}, this.options), options), {
                isClone: true
              });
              var clone = new I18n(mergedOptions);
              if (options.debug !== undefined || options.prefix !== undefined) {
                clone.logger = clone.logger.clone(options);
              }
              var membersToCopy = ['store', 'services', 'language'];
              membersToCopy.forEach(function (m) {
                clone[m] = _this8[m];
              });
              clone.services = _objectSpread$7({}, this.services);
              clone.services.utils = {
                hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
              };
              clone.translator = new Translator(clone.services, clone.options);
              clone.translator.on('*', function (event) {
                for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
                  args[_key4 - 1] = arguments[_key4];
                }
                clone.emit.apply(clone, [event].concat(args));
              });
              clone.init(mergedOptions, callback);
              clone.translator.options = clone.options;
              clone.translator.backendConnector.services.utils = {
                hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
              };
              return clone;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                options: this.options,
                store: this.store,
                language: this.language,
                languages: this.languages,
                resolvedLanguage: this.resolvedLanguage
              };
            }
          }]);
          return I18n;
        }(EventEmitter);
        _defineProperty$6(I18n, "createInstance", function () {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var callback = arguments.length > 1 ? arguments[1] : undefined;
          return new I18n(options, callback);
        });
        var instance = exports("v", I18n.createInstance());
        instance.createInstance = I18n.createInstance;
        instance.createInstance;
        instance.dir;
        instance.init;
        instance.loadResources;
        instance.reloadResources;
        instance.use;
        instance.changeLanguage;
        instance.getFixedT;
        var t = exports("a0", instance.t);
        instance.exists;
        instance.setDefaultNamespace;
        instance.hasLoadedNamespace;
        instance.loadNamespaces;
        instance.loadLanguages;
        function warn() {
          if (console && console.warn) {
            var _console;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (typeof args[0] === 'string') args[0] = "react-i18next:: ".concat(args[0]);
            (_console = console).warn.apply(_console, args);
          }
        }
        var alreadyWarned = {};
        function warnOnce() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          if (typeof args[0] === 'string' && alreadyWarned[args[0]]) return;
          if (typeof args[0] === 'string') alreadyWarned[args[0]] = new Date();
          warn.apply(void 0, args);
        }
        var loadedClb = function loadedClb(i18n, cb) {
          return function () {
            if (i18n.isInitialized) {
              cb();
            } else {
              var initialized = function initialized() {
                setTimeout(function () {
                  i18n.off('initialized', initialized);
                }, 0);
                cb();
              };
              i18n.on('initialized', initialized);
            }
          };
        };
        function loadNamespaces(i18n, ns, cb) {
          i18n.loadNamespaces(ns, loadedClb(i18n, cb));
        }
        function loadLanguages(i18n, lng, ns, cb) {
          if (typeof ns === 'string') ns = [ns];
          ns.forEach(function (n) {
            if (i18n.options.ns.indexOf(n) < 0) i18n.options.ns.push(n);
          });
          i18n.loadLanguages(lng, loadedClb(i18n, cb));
        }
        function oldI18nextHasLoadedNamespace(ns, i18n) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var lng = i18n.languages[0];
          var fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
          var lastLng = i18n.languages[i18n.languages.length - 1];
          if (lng.toLowerCase() === 'cimode') return true;
          var loadNotPending = function loadNotPending(l, n) {
            var loadState = i18n.services.backendConnector.state["".concat(l, "|").concat(n)];
            return loadState === -1 || loadState === 2;
          };
          if (options.bindI18n && options.bindI18n.indexOf('languageChanging') > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns)) return false;
          if (i18n.hasResourceBundle(lng, ns)) return true;
          if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages) return true;
          if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
          return false;
        }
        function hasLoadedNamespace(ns, i18n) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          if (!i18n.languages || !i18n.languages.length) {
            warnOnce('i18n.languages were undefined or empty', i18n.languages);
            return true;
          }
          var isNewerI18next = i18n.options.ignoreJSONStructure !== undefined;
          if (!isNewerI18next) {
            return oldI18nextHasLoadedNamespace(ns, i18n, options);
          }
          return i18n.hasLoadedNamespace(ns, {
            lng: options.lng,
            precheck: function precheck(i18nInstance, loadNotPending) {
              if (options.bindI18n && options.bindI18n.indexOf('languageChanging') > -1 && i18nInstance.services.backendConnector.backend && i18nInstance.isLanguageChangingTo && !loadNotPending(i18nInstance.isLanguageChangingTo, ns)) return false;
            }
          });
        }
        var matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
        var htmlEntities = {
          '&amp;': '&',
          '&#38;': '&',
          '&lt;': '<',
          '&#60;': '<',
          '&gt;': '>',
          '&#62;': '>',
          '&apos;': "'",
          '&#39;': "'",
          '&quot;': '"',
          '&#34;': '"',
          '&nbsp;': ' ',
          '&#160;': ' ',
          '&copy;': '',
          '&#169;': '',
          '&reg;': '',
          '&#174;': '',
          '&hellip;': '',
          '&#8230;': '',
          '&#x2F;': '/',
          '&#47;': '/'
        };
        var unescapeHtmlEntity = function unescapeHtmlEntity(m) {
          return htmlEntities[m];
        };
        var unescape = function unescape(text) {
          return text.replace(matchHtmlEntity, unescapeHtmlEntity);
        };
        function ownKeys$5(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$4(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$5(Object(source), true).forEach(function (key) {
                _defineProperty$6(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$5(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        var defaultOptions$2 = {
          bindI18n: 'languageChanged',
          bindI18nStore: '',
          transEmptyNodeValue: '',
          transSupportBasicHtmlNodes: true,
          transWrapTextNodes: '',
          transKeepBasicHtmlNodesFor: ['br', 'strong', 'i', 'p'],
          useSuspense: true,
          unescape: unescape
        };
        function setDefaults() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          defaultOptions$2 = _objectSpread$4(_objectSpread$4({}, defaultOptions$2), options);
        }
        function getDefaults$2() {
          return defaultOptions$2;
        }
        var i18nInstance;
        function setI18n(instance) {
          i18nInstance = instance;
        }
        function getI18n() {
          return i18nInstance;
        }
        var initReactI18next = exports("z", {
          type: '3rdParty',
          init: function init(instance) {
            setDefaults(instance.options.react);
            setI18n(instance);
          }
        });
        var I18nContext = reactExports.createContext();
        var ReportNamespaces = function () {
          function ReportNamespaces() {
            _classCallCheck$3(this, ReportNamespaces);
            this.usedNamespaces = {};
          }
          _createClass$3(ReportNamespaces, [{
            key: "addUsedNamespaces",
            value: function addUsedNamespaces(namespaces) {
              var _this = this;
              namespaces.forEach(function (ns) {
                if (!_this.usedNamespaces[ns]) _this.usedNamespaces[ns] = true;
              });
            }
          }, {
            key: "getUsedNamespaces",
            value: function getUsedNamespaces() {
              return Object.keys(this.usedNamespaces);
            }
          }]);
          return ReportNamespaces;
        }();
        function _iterableToArrayLimit(r, l) {
          var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
          if (null != t) {
            var e,
              n,
              i,
              u,
              a = [],
              f = true,
              o = false;
            try {
              if (i = (t = t.call(r)).next, 0 === l) ;else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
            } catch (r) {
              o = true, n = r;
            } finally {
              try {
                if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
              } finally {
                if (o) throw n;
              }
            }
            return a;
          }
        }
        function _slicedToArray(r, e) {
          return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$1(r, e) || _nonIterableRest();
        }
        function ownKeys$4(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$3(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$4(Object(source), true).forEach(function (key) {
                _defineProperty$6(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$4(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        var usePrevious = function usePrevious(value, ignore) {
          var ref = reactExports.useRef();
          reactExports.useEffect(function () {
            ref.current = value;
          }, [value, ignore]);
          return ref.current;
        };
        function useTranslation(ns) {
          var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var i18nFromProps = props.i18n;
          var _ref = reactExports.useContext(I18nContext) || {},
            i18nFromContext = _ref.i18n,
            defaultNSFromContext = _ref.defaultNS;
          var i18n = i18nFromProps || i18nFromContext || getI18n();
          if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
          if (!i18n) {
            warnOnce('You will need to pass in an i18next instance by using initReactI18next');
            var notReadyT = function notReadyT(k, optsOrDefaultValue) {
              if (typeof optsOrDefaultValue === 'string') return optsOrDefaultValue;
              if (optsOrDefaultValue && _typeof$6(optsOrDefaultValue) === 'object' && typeof optsOrDefaultValue.defaultValue === 'string') return optsOrDefaultValue.defaultValue;
              return Array.isArray(k) ? k[k.length - 1] : k;
            };
            var retNotReady = [notReadyT, {}, false];
            retNotReady.t = notReadyT;
            retNotReady.i18n = {};
            retNotReady.ready = false;
            return retNotReady;
          }
          if (i18n.options.react && i18n.options.react.wait !== undefined) warnOnce('It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.');
          var i18nOptions = _objectSpread$3(_objectSpread$3(_objectSpread$3({}, getDefaults$2()), i18n.options.react), props);
          var useSuspense = i18nOptions.useSuspense,
            keyPrefix = i18nOptions.keyPrefix;
          var namespaces = defaultNSFromContext || i18n.options && i18n.options.defaultNS;
          namespaces = typeof namespaces === 'string' ? [namespaces] : namespaces || ['translation'];
          if (i18n.reportNamespaces.addUsedNamespaces) i18n.reportNamespaces.addUsedNamespaces(namespaces);
          var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function (n) {
            return hasLoadedNamespace(n, i18n, i18nOptions);
          });
          function getT() {
            return i18n.getFixedT(props.lng || null, i18nOptions.nsMode === 'fallback' ? namespaces : namespaces[0], keyPrefix);
          }
          var _useState = reactExports.useState(getT),
            _useState2 = _slicedToArray(_useState, 2),
            t = _useState2[0],
            setT = _useState2[1];
          var joinedNS = namespaces.join();
          if (props.lng) joinedNS = "".concat(props.lng).concat(joinedNS);
          var previousJoinedNS = usePrevious(joinedNS);
          var isMounted = reactExports.useRef(true);
          reactExports.useEffect(function () {
            var bindI18n = i18nOptions.bindI18n,
              bindI18nStore = i18nOptions.bindI18nStore;
            isMounted.current = true;
            if (!ready && !useSuspense) {
              if (props.lng) {
                loadLanguages(i18n, props.lng, namespaces, function () {
                  if (isMounted.current) setT(getT);
                });
              } else {
                loadNamespaces(i18n, namespaces, function () {
                  if (isMounted.current) setT(getT);
                });
              }
            }
            if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
              setT(getT);
            }
            function boundReset() {
              if (isMounted.current) setT(getT);
            }
            if (bindI18n && i18n) i18n.on(bindI18n, boundReset);
            if (bindI18nStore && i18n) i18n.store.on(bindI18nStore, boundReset);
            return function () {
              isMounted.current = false;
              if (bindI18n && i18n) bindI18n.split(' ').forEach(function (e) {
                return i18n.off(e, boundReset);
              });
              if (bindI18nStore && i18n) bindI18nStore.split(' ').forEach(function (e) {
                return i18n.store.off(e, boundReset);
              });
            };
          }, [i18n, joinedNS]);
          var isInitial = reactExports.useRef(true);
          reactExports.useEffect(function () {
            if (isMounted.current && !isInitial.current) {
              setT(getT);
            }
            isInitial.current = false;
          }, [i18n, keyPrefix]);
          var ret = [t, i18n, ready];
          ret.t = t;
          ret.i18n = i18n;
          ret.ready = ready;
          if (ready) return ret;
          if (!ready && !useSuspense) return ret;
          throw new Promise(function (resolve) {
            if (props.lng) {
              loadLanguages(i18n, props.lng, namespaces, function () {
                return resolve();
              });
            } else {
              loadNamespaces(i18n, namespaces, function () {
                return resolve();
              });
            }
          });
        }
        function _typeof$5(obj) {
          "@babel/helpers - typeof";

          return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          }, _typeof$5(obj);
        }
        var arr$1 = [];
        var each$2 = arr$1.forEach;
        var slice$2 = arr$1.slice;
        function defaults$2(obj) {
          each$2.call(slice$2.call(arguments, 1), function (source) {
            if (source) {
              for (var prop in source) {
                if (obj[prop] === undefined) obj[prop] = source[prop];
              }
            }
          });
          return obj;
        }
        function hasXMLHttpRequest() {
          return typeof XMLHttpRequest === 'function' || (typeof XMLHttpRequest === "undefined" ? "undefined" : _typeof$5(XMLHttpRequest)) === 'object';
        }
        function isPromise(maybePromise) {
          return !!maybePromise && typeof maybePromise.then === 'function';
        }
        function makePromise(maybePromise) {
          if (isPromise(maybePromise)) {
            return maybePromise;
          }
          return Promise.resolve(maybePromise);
        }
        function commonjsRequire(path) {
          throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
        }
        var getFetch$1 = {
          exports: {}
        };
        var browserPonyfill$1 = {
          exports: {}
        };
        var browserPonyfill = browserPonyfill$1.exports;
        var hasRequiredBrowserPonyfill;
        function requireBrowserPonyfill() {
          if (hasRequiredBrowserPonyfill) return browserPonyfill$1.exports;
          hasRequiredBrowserPonyfill = 1;
          (function (module, exports) {
            var global = typeof self !== "undefined" ? self : browserPonyfill;
            var __self__ = function () {
              function F() {
                this.fetch = false;
                this.DOMException = global.DOMException;
              }
              F.prototype = global;
              return new F();
            }();
            (function (self2) {
              (function (exports2) {
                var support = {
                  searchParams: "URLSearchParams" in self2,
                  iterable: "Symbol" in self2 && "iterator" in Symbol,
                  blob: "FileReader" in self2 && "Blob" in self2 && function () {
                    try {
                      new Blob();
                      return true;
                    } catch (e) {
                      return false;
                    }
                  }(),
                  formData: "FormData" in self2,
                  arrayBuffer: "ArrayBuffer" in self2
                };
                function isDataView(obj) {
                  return obj && DataView.prototype.isPrototypeOf(obj);
                }
                if (support.arrayBuffer) {
                  var viewClasses = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"];
                  var isArrayBufferView = ArrayBuffer.isView || function (obj) {
                    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
                  };
                }
                function normalizeName(name) {
                  if (typeof name !== "string") {
                    name = String(name);
                  }
                  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
                    throw new TypeError("Invalid character in header field name");
                  }
                  return name.toLowerCase();
                }
                function normalizeValue(value) {
                  if (typeof value !== "string") {
                    value = String(value);
                  }
                  return value;
                }
                function iteratorFor(items) {
                  var iterator = {
                    next: function () {
                      var value = items.shift();
                      return {
                        done: value === void 0,
                        value
                      };
                    }
                  };
                  if (support.iterable) {
                    iterator[Symbol.iterator] = function () {
                      return iterator;
                    };
                  }
                  return iterator;
                }
                function Headers(headers) {
                  this.map = {};
                  if (headers instanceof Headers) {
                    headers.forEach(function (value, name) {
                      this.append(name, value);
                    }, this);
                  } else if (Array.isArray(headers)) {
                    headers.forEach(function (header) {
                      this.append(header[0], header[1]);
                    }, this);
                  } else if (headers) {
                    Object.getOwnPropertyNames(headers).forEach(function (name) {
                      this.append(name, headers[name]);
                    }, this);
                  }
                }
                Headers.prototype.append = function (name, value) {
                  name = normalizeName(name);
                  value = normalizeValue(value);
                  var oldValue = this.map[name];
                  this.map[name] = oldValue ? oldValue + ", " + value : value;
                };
                Headers.prototype["delete"] = function (name) {
                  delete this.map[normalizeName(name)];
                };
                Headers.prototype.get = function (name) {
                  name = normalizeName(name);
                  return this.has(name) ? this.map[name] : null;
                };
                Headers.prototype.has = function (name) {
                  return this.map.hasOwnProperty(normalizeName(name));
                };
                Headers.prototype.set = function (name, value) {
                  this.map[normalizeName(name)] = normalizeValue(value);
                };
                Headers.prototype.forEach = function (callback, thisArg) {
                  for (var name in this.map) {
                    if (this.map.hasOwnProperty(name)) {
                      callback.call(thisArg, this.map[name], name, this);
                    }
                  }
                };
                Headers.prototype.keys = function () {
                  var items = [];
                  this.forEach(function (value, name) {
                    items.push(name);
                  });
                  return iteratorFor(items);
                };
                Headers.prototype.values = function () {
                  var items = [];
                  this.forEach(function (value) {
                    items.push(value);
                  });
                  return iteratorFor(items);
                };
                Headers.prototype.entries = function () {
                  var items = [];
                  this.forEach(function (value, name) {
                    items.push([name, value]);
                  });
                  return iteratorFor(items);
                };
                if (support.iterable) {
                  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
                }
                function consumed(body) {
                  if (body.bodyUsed) {
                    return Promise.reject(new TypeError("Already read"));
                  }
                  body.bodyUsed = true;
                }
                function fileReaderReady(reader) {
                  return new Promise(function (resolve, reject) {
                    reader.onload = function () {
                      resolve(reader.result);
                    };
                    reader.onerror = function () {
                      reject(reader.error);
                    };
                  });
                }
                function readBlobAsArrayBuffer(blob) {
                  var reader = new FileReader();
                  var promise = fileReaderReady(reader);
                  reader.readAsArrayBuffer(blob);
                  return promise;
                }
                function readBlobAsText(blob) {
                  var reader = new FileReader();
                  var promise = fileReaderReady(reader);
                  reader.readAsText(blob);
                  return promise;
                }
                function readArrayBufferAsText(buf) {
                  var view = new Uint8Array(buf);
                  var chars = new Array(view.length);
                  for (var i = 0; i < view.length; i++) {
                    chars[i] = String.fromCharCode(view[i]);
                  }
                  return chars.join("");
                }
                function bufferClone(buf) {
                  if (buf.slice) {
                    return buf.slice(0);
                  } else {
                    var view = new Uint8Array(buf.byteLength);
                    view.set(new Uint8Array(buf));
                    return view.buffer;
                  }
                }
                function Body() {
                  this.bodyUsed = false;
                  this._initBody = function (body) {
                    this._bodyInit = body;
                    if (!body) {
                      this._bodyText = "";
                    } else if (typeof body === "string") {
                      this._bodyText = body;
                    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                      this._bodyBlob = body;
                    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                      this._bodyFormData = body;
                    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                      this._bodyText = body.toString();
                    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                      this._bodyArrayBuffer = bufferClone(body.buffer);
                      this._bodyInit = new Blob([this._bodyArrayBuffer]);
                    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                      this._bodyArrayBuffer = bufferClone(body);
                    } else {
                      this._bodyText = body = Object.prototype.toString.call(body);
                    }
                    if (!this.headers.get("content-type")) {
                      if (typeof body === "string") {
                        this.headers.set("content-type", "text/plain;charset=UTF-8");
                      } else if (this._bodyBlob && this._bodyBlob.type) {
                        this.headers.set("content-type", this._bodyBlob.type);
                      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                      }
                    }
                  };
                  if (support.blob) {
                    this.blob = function () {
                      var rejected = consumed(this);
                      if (rejected) {
                        return rejected;
                      }
                      if (this._bodyBlob) {
                        return Promise.resolve(this._bodyBlob);
                      } else if (this._bodyArrayBuffer) {
                        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                      } else if (this._bodyFormData) {
                        throw new Error("could not read FormData body as blob");
                      } else {
                        return Promise.resolve(new Blob([this._bodyText]));
                      }
                    };
                    this.arrayBuffer = function () {
                      if (this._bodyArrayBuffer) {
                        return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
                      } else {
                        return this.blob().then(readBlobAsArrayBuffer);
                      }
                    };
                  }
                  this.text = function () {
                    var rejected = consumed(this);
                    if (rejected) {
                      return rejected;
                    }
                    if (this._bodyBlob) {
                      return readBlobAsText(this._bodyBlob);
                    } else if (this._bodyArrayBuffer) {
                      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                    } else if (this._bodyFormData) {
                      throw new Error("could not read FormData body as text");
                    } else {
                      return Promise.resolve(this._bodyText);
                    }
                  };
                  if (support.formData) {
                    this.formData = function () {
                      return this.text().then(decode);
                    };
                  }
                  this.json = function () {
                    return this.text().then(JSON.parse);
                  };
                  return this;
                }
                var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
                function normalizeMethod(method) {
                  var upcased = method.toUpperCase();
                  return methods.indexOf(upcased) > -1 ? upcased : method;
                }
                function Request(input, options) {
                  options = options || {};
                  var body = options.body;
                  if (input instanceof Request) {
                    if (input.bodyUsed) {
                      throw new TypeError("Already read");
                    }
                    this.url = input.url;
                    this.credentials = input.credentials;
                    if (!options.headers) {
                      this.headers = new Headers(input.headers);
                    }
                    this.method = input.method;
                    this.mode = input.mode;
                    this.signal = input.signal;
                    if (!body && input._bodyInit != null) {
                      body = input._bodyInit;
                      input.bodyUsed = true;
                    }
                  } else {
                    this.url = String(input);
                  }
                  this.credentials = options.credentials || this.credentials || "same-origin";
                  if (options.headers || !this.headers) {
                    this.headers = new Headers(options.headers);
                  }
                  this.method = normalizeMethod(options.method || this.method || "GET");
                  this.mode = options.mode || this.mode || null;
                  this.signal = options.signal || this.signal;
                  this.referrer = null;
                  if ((this.method === "GET" || this.method === "HEAD") && body) {
                    throw new TypeError("Body not allowed for GET or HEAD requests");
                  }
                  this._initBody(body);
                }
                Request.prototype.clone = function () {
                  return new Request(this, {
                    body: this._bodyInit
                  });
                };
                function decode(body) {
                  var form = new FormData();
                  body.trim().split("&").forEach(function (bytes) {
                    if (bytes) {
                      var split = bytes.split("=");
                      var name = split.shift().replace(/\+/g, " ");
                      var value = split.join("=").replace(/\+/g, " ");
                      form.append(decodeURIComponent(name), decodeURIComponent(value));
                    }
                  });
                  return form;
                }
                function parseHeaders(rawHeaders) {
                  var headers = new Headers();
                  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
                  preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
                    var parts = line.split(":");
                    var key = parts.shift().trim();
                    if (key) {
                      var value = parts.join(":").trim();
                      headers.append(key, value);
                    }
                  });
                  return headers;
                }
                Body.call(Request.prototype);
                function Response(bodyInit, options) {
                  if (!options) {
                    options = {};
                  }
                  this.type = "default";
                  this.status = options.status === void 0 ? 200 : options.status;
                  this.ok = this.status >= 200 && this.status < 300;
                  this.statusText = "statusText" in options ? options.statusText : "OK";
                  this.headers = new Headers(options.headers);
                  this.url = options.url || "";
                  this._initBody(bodyInit);
                }
                Body.call(Response.prototype);
                Response.prototype.clone = function () {
                  return new Response(this._bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new Headers(this.headers),
                    url: this.url
                  });
                };
                Response.error = function () {
                  var response = new Response(null, {
                    status: 0,
                    statusText: ""
                  });
                  response.type = "error";
                  return response;
                };
                var redirectStatuses = [301, 302, 303, 307, 308];
                Response.redirect = function (url, status) {
                  if (redirectStatuses.indexOf(status) === -1) {
                    throw new RangeError("Invalid status code");
                  }
                  return new Response(null, {
                    status,
                    headers: {
                      location: url
                    }
                  });
                };
                exports2.DOMException = self2.DOMException;
                try {
                  new exports2.DOMException();
                } catch (err) {
                  exports2.DOMException = function (message, name) {
                    this.message = message;
                    this.name = name;
                    var error = Error(message);
                    this.stack = error.stack;
                  };
                  exports2.DOMException.prototype = Object.create(Error.prototype);
                  exports2.DOMException.prototype.constructor = exports2.DOMException;
                }
                function fetch(input, init) {
                  return new Promise(function (resolve, reject) {
                    var request = new Request(input, init);
                    if (request.signal && request.signal.aborted) {
                      return reject(new exports2.DOMException("Aborted", "AbortError"));
                    }
                    var xhr = new XMLHttpRequest();
                    function abortXhr() {
                      xhr.abort();
                    }
                    xhr.onload = function () {
                      var options = {
                        status: xhr.status,
                        statusText: xhr.statusText,
                        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                      };
                      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
                      var body = "response" in xhr ? xhr.response : xhr.responseText;
                      resolve(new Response(body, options));
                    };
                    xhr.onerror = function () {
                      reject(new TypeError("Network request failed"));
                    };
                    xhr.ontimeout = function () {
                      reject(new TypeError("Network request failed"));
                    };
                    xhr.onabort = function () {
                      reject(new exports2.DOMException("Aborted", "AbortError"));
                    };
                    xhr.open(request.method, request.url, true);
                    if (request.credentials === "include") {
                      xhr.withCredentials = true;
                    } else if (request.credentials === "omit") {
                      xhr.withCredentials = false;
                    }
                    if ("responseType" in xhr && support.blob) {
                      xhr.responseType = "blob";
                    }
                    request.headers.forEach(function (value, name) {
                      xhr.setRequestHeader(name, value);
                    });
                    if (request.signal) {
                      request.signal.addEventListener("abort", abortXhr);
                      xhr.onreadystatechange = function () {
                        if (xhr.readyState === 4) {
                          request.signal.removeEventListener("abort", abortXhr);
                        }
                      };
                    }
                    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
                  });
                }
                fetch.polyfill = true;
                if (!self2.fetch) {
                  self2.fetch = fetch;
                  self2.Headers = Headers;
                  self2.Request = Request;
                  self2.Response = Response;
                }
                exports2.Headers = Headers;
                exports2.Request = Request;
                exports2.Response = Response;
                exports2.fetch = fetch;
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                return exports2;
              })({});
            })(__self__);
            __self__.fetch.ponyfill = true;
            delete __self__.fetch.polyfill;
            var ctx = __self__;
            exports = ctx.fetch;
            exports.default = ctx.fetch;
            exports.fetch = ctx.fetch;
            exports.Headers = ctx.Headers;
            exports.Request = ctx.Request;
            exports.Response = ctx.Response;
            module.exports = exports;
          })(browserPonyfill$1, browserPonyfill$1.exports);
          return browserPonyfill$1.exports;
        }
        var hasRequiredGetFetch;
        function requireGetFetch() {
          if (hasRequiredGetFetch) return getFetch$1.exports;
          hasRequiredGetFetch = 1;
          (function (module, exports) {
            var fetchApi;
            if (typeof fetch === "function") {
              if (typeof globalThis !== "undefined" && globalThis.fetch) {
                fetchApi = globalThis.fetch;
              } else if (typeof window !== "undefined" && window.fetch) {
                fetchApi = window.fetch;
              } else {
                fetchApi = fetch;
              }
            }
            if (typeof commonjsRequire !== "undefined" && (typeof window === "undefined" || typeof window.document === "undefined")) {
              var f = fetchApi || requireBrowserPonyfill();
              if (f.default) f = f.default;
              exports.default = f;
              module.exports = exports.default;
            }
          })(getFetch$1, getFetch$1.exports);
          return getFetch$1.exports;
        }
        var getFetchExports = requireGetFetch();
        const getFetch = /*@__PURE__*/getDefaultExportFromCjs(getFetchExports);
        const fetchNode = /*#__PURE__*/_mergeNamespaces({
          __proto__: null,
          default: getFetch
        }, [getFetchExports]);
        function _typeof$4(obj) {
          "@babel/helpers - typeof";

          return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj2) {
            return typeof obj2;
          } : function (obj2) {
            return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          }, _typeof$4(obj);
        }
        var fetchApi;
        if (typeof fetch === "function") {
          if (typeof globalThis !== "undefined" && globalThis.fetch) {
            fetchApi = globalThis.fetch;
          } else if (typeof window !== "undefined" && window.fetch) {
            fetchApi = window.fetch;
          } else {
            fetchApi = fetch;
          }
        }
        var XmlHttpRequestApi;
        if (hasXMLHttpRequest()) {
          if (typeof globalThis !== "undefined" && globalThis.XMLHttpRequest) {
            XmlHttpRequestApi = globalThis.XMLHttpRequest;
          } else if (typeof window !== "undefined" && window.XMLHttpRequest) {
            XmlHttpRequestApi = window.XMLHttpRequest;
          }
        }
        var ActiveXObjectApi;
        if (typeof ActiveXObject === "function") {
          if (typeof globalThis !== "undefined" && globalThis.ActiveXObject) {
            ActiveXObjectApi = globalThis.ActiveXObject;
          } else if (typeof window !== "undefined" && window.ActiveXObject) {
            ActiveXObjectApi = window.ActiveXObject;
          }
        }
        if (!fetchApi && fetchNode && !XmlHttpRequestApi && !ActiveXObjectApi) fetchApi = getFetch || fetchNode;
        if (typeof fetchApi !== "function") fetchApi = void 0;
        var addQueryString = function addQueryString2(url, params) {
          if (params && _typeof$4(params) === "object") {
            var queryString = "";
            for (var paramName in params) {
              queryString += "&" + encodeURIComponent(paramName) + "=" + encodeURIComponent(params[paramName]);
            }
            if (!queryString) return url;
            url = url + (url.indexOf("?") !== -1 ? "&" : "?") + queryString.slice(1);
          }
          return url;
        };
        var fetchIt = function fetchIt2(url, fetchOptions, callback) {
          fetchApi(url, fetchOptions).then(function (response) {
            if (!response.ok) return callback(response.statusText || "Error", {
              status: response.status
            });
            response.text().then(function (data) {
              callback(null, {
                status: response.status,
                data
              });
            }).catch(callback);
          }).catch(callback);
        };
        var omitFetchOptions = false;
        var requestWithFetch = function requestWithFetch2(options, url, payload, callback) {
          if (options.queryStringParams) {
            url = addQueryString(url, options.queryStringParams);
          }
          var headers = defaults$2({}, typeof options.customHeaders === "function" ? options.customHeaders() : options.customHeaders);
          if (payload) headers["Content-Type"] = "application/json";
          var reqOptions = typeof options.requestOptions === "function" ? options.requestOptions(payload) : options.requestOptions;
          var fetchOptions = defaults$2({
            method: payload ? "POST" : "GET",
            body: payload ? options.stringify(payload) : void 0,
            headers
          }, omitFetchOptions ? {} : reqOptions);
          try {
            fetchIt(url, fetchOptions, callback);
          } catch (e) {
            if (!reqOptions || Object.keys(reqOptions).length === 0 || !e.message || e.message.indexOf("not implemented") < 0) {
              return callback(e);
            }
            try {
              Object.keys(reqOptions).forEach(function (opt) {
                delete fetchOptions[opt];
              });
              fetchIt(url, fetchOptions, callback);
              omitFetchOptions = true;
            } catch (err) {
              callback(err);
            }
          }
        };
        var requestWithXmlHttpRequest = function requestWithXmlHttpRequest2(options, url, payload, callback) {
          if (payload && _typeof$4(payload) === "object") {
            payload = addQueryString("", payload).slice(1);
          }
          if (options.queryStringParams) {
            url = addQueryString(url, options.queryStringParams);
          }
          try {
            var x;
            if (XmlHttpRequestApi) {
              x = new XmlHttpRequestApi();
            } else {
              x = new ActiveXObjectApi("MSXML2.XMLHTTP.3.0");
            }
            x.open(payload ? "POST" : "GET", url, 1);
            if (!options.crossDomain) {
              x.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            }
            x.withCredentials = !!options.withCredentials;
            if (payload) {
              x.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            }
            if (x.overrideMimeType) {
              x.overrideMimeType("application/json");
            }
            var h = options.customHeaders;
            h = typeof h === "function" ? h() : h;
            if (h) {
              for (var i in h) {
                x.setRequestHeader(i, h[i]);
              }
            }
            x.onreadystatechange = function () {
              x.readyState > 3 && callback(x.status >= 400 ? x.statusText : null, {
                status: x.status,
                data: x.responseText
              });
            };
            x.send(payload);
          } catch (e) {
            console && console.log(e);
          }
        };
        var request = function request2(options, url, payload, callback) {
          if (typeof payload === "function") {
            callback = payload;
            payload = void 0;
          }
          callback = callback || function () {};
          if (fetchApi && url.indexOf("file:") !== 0) {
            return requestWithFetch(options, url, payload, callback);
          }
          if (hasXMLHttpRequest() || typeof ActiveXObject === "function") {
            return requestWithXmlHttpRequest(options, url, payload, callback);
          }
          callback(new Error("No fetch and no xhr implementation found!"));
        };
        function _typeof$3(obj) {
          "@babel/helpers - typeof";

          return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          }, _typeof$3(obj);
        }
        function _classCallCheck$2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties$2(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
          }
        }
        function _createClass$2(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
          Object.defineProperty(Constructor, "prototype", {
            writable: false
          });
          return Constructor;
        }
        function _defineProperty$5(obj, key, value) {
          key = _toPropertyKey$1(key);
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _toPropertyKey$1(arg) {
          var key = _toPrimitive$1(arg, "string");
          return _typeof$3(key) === "symbol" ? key : String(key);
        }
        function _toPrimitive$1(input, hint) {
          if (_typeof$3(input) !== "object" || input === null) return input;
          var prim = input[Symbol.toPrimitive];
          if (prim !== undefined) {
            var res = prim.call(input, hint);
            if (_typeof$3(res) !== "object") return res;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(input);
        }
        var getDefaults$1 = function getDefaults() {
          return {
            loadPath: '/locales/{{lng}}/{{ns}}.json',
            addPath: '/locales/add/{{lng}}/{{ns}}',
            allowMultiLoading: false,
            parse: function parse(data) {
              return JSON.parse(data);
            },
            stringify: JSON.stringify,
            parsePayload: function parsePayload(namespace, key, fallbackValue) {
              return _defineProperty$5({}, key, fallbackValue || '');
            },
            parseLoadPayload: function parseLoadPayload(languages, namespaces) {
              return undefined;
            },
            request: request,
            reloadInterval: typeof window !== 'undefined' ? false : 60 * 60 * 1000,
            customHeaders: {},
            queryStringParams: {},
            crossDomain: false,
            withCredentials: false,
            overrideMimeType: false,
            requestOptions: {
              mode: 'cors',
              credentials: 'same-origin',
              cache: 'default'
            }
          };
        };
        var Backend = exports("x", function () {
          function Backend(services) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var allOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            _classCallCheck$2(this, Backend);
            this.services = services;
            this.options = options;
            this.allOptions = allOptions;
            this.type = 'backend';
            this.init(services, options, allOptions);
          }
          _createClass$2(Backend, [{
            key: "init",
            value: function init(services) {
              var _this = this;
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var allOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              this.services = services;
              this.options = defaults$2(options, this.options || {}, getDefaults$1());
              this.allOptions = allOptions;
              if (this.services && this.options.reloadInterval) {
                setInterval(function () {
                  return _this.reload();
                }, this.options.reloadInterval);
              }
            }
          }, {
            key: "readMulti",
            value: function readMulti(languages, namespaces, callback) {
              this._readAny(languages, languages, namespaces, namespaces, callback);
            }
          }, {
            key: "read",
            value: function read(language, namespace, callback) {
              this._readAny([language], language, [namespace], namespace, callback);
            }
          }, {
            key: "_readAny",
            value: function _readAny(languages, loadUrlLanguages, namespaces, loadUrlNamespaces, callback) {
              var _this2 = this;
              var loadPath = this.options.loadPath;
              if (typeof this.options.loadPath === 'function') {
                loadPath = this.options.loadPath(languages, namespaces);
              }
              loadPath = makePromise(loadPath);
              loadPath.then(function (resolvedLoadPath) {
                if (!resolvedLoadPath) return callback(null, {});
                var url = _this2.services.interpolator.interpolate(resolvedLoadPath, {
                  lng: languages.join('+'),
                  ns: namespaces.join('+')
                });
                _this2.loadUrl(url, callback, loadUrlLanguages, loadUrlNamespaces);
              });
            }
          }, {
            key: "loadUrl",
            value: function loadUrl(url, callback, languages, namespaces) {
              var _this3 = this;
              var lng = typeof languages === 'string' ? [languages] : languages;
              var ns = typeof namespaces === 'string' ? [namespaces] : namespaces;
              var payload = this.options.parseLoadPayload(lng, ns);
              this.options.request(this.options, url, payload, function (err, res) {
                if (res && (res.status >= 500 && res.status < 600 || !res.status)) return callback('failed loading ' + url + '; status code: ' + res.status, true);
                if (res && res.status >= 400 && res.status < 500) return callback('failed loading ' + url + '; status code: ' + res.status, false);
                if (!res && err && err.message && err.message.indexOf('Failed to fetch') > -1) return callback('failed loading ' + url + ': ' + err.message, true);
                if (err) return callback(err, false);
                var ret, parseErr;
                try {
                  if (typeof res.data === 'string') {
                    ret = _this3.options.parse(res.data, languages, namespaces);
                  } else {
                    ret = res.data;
                  }
                } catch (e) {
                  parseErr = 'failed parsing ' + url + ' to json';
                }
                if (parseErr) return callback(parseErr, false);
                callback(null, ret);
              });
            }
          }, {
            key: "create",
            value: function create(languages, namespace, key, fallbackValue, callback) {
              var _this4 = this;
              if (!this.options.addPath) return;
              if (typeof languages === 'string') languages = [languages];
              var payload = this.options.parsePayload(namespace, key, fallbackValue);
              var finished = 0;
              var dataArray = [];
              var resArray = [];
              languages.forEach(function (lng) {
                var addPath = _this4.options.addPath;
                if (typeof _this4.options.addPath === 'function') {
                  addPath = _this4.options.addPath(lng, namespace);
                }
                var url = _this4.services.interpolator.interpolate(addPath, {
                  lng: lng,
                  ns: namespace
                });
                _this4.options.request(_this4.options, url, payload, function (data, res) {
                  finished += 1;
                  dataArray.push(data);
                  resArray.push(res);
                  if (finished === languages.length) {
                    if (typeof callback === 'function') callback(dataArray, resArray);
                  }
                });
              });
            }
          }, {
            key: "reload",
            value: function reload() {
              var _this5 = this;
              var _this$services = this.services,
                backendConnector = _this$services.backendConnector,
                languageUtils = _this$services.languageUtils,
                logger = _this$services.logger;
              var currentLanguage = backendConnector.language;
              if (currentLanguage && currentLanguage.toLowerCase() === 'cimode') return;
              var toLoad = [];
              var append = function append(lng) {
                var lngs = languageUtils.toResolveHierarchy(lng);
                lngs.forEach(function (l) {
                  if (toLoad.indexOf(l) < 0) toLoad.push(l);
                });
              };
              append(currentLanguage);
              if (this.allOptions.preload) this.allOptions.preload.forEach(function (l) {
                return append(l);
              });
              toLoad.forEach(function (lng) {
                _this5.allOptions.ns.forEach(function (ns) {
                  backendConnector.read(lng, ns, 'read', null, null, function (err, data) {
                    if (err) logger.warn("loading namespace ".concat(ns, " for language ").concat(lng, " failed"), err);
                    if (!err && data) logger.log("loaded namespace ".concat(ns, " for language ").concat(lng), data);
                    backendConnector.loaded("".concat(lng, "|").concat(ns), err, data);
                  });
                });
              });
            }
          }]);
          return Backend;
        }());
        Backend.type = 'backend';
        var arr = [];
        var each$1 = arr.forEach;
        var slice$1 = arr.slice;
        function defaults$1(obj) {
          each$1.call(slice$1.call(arguments, 1), function (source) {
            if (source) {
              for (var prop in source) {
                if (obj[prop] === undefined) obj[prop] = source[prop];
              }
            }
          });
          return obj;
        }

        // eslint-disable-next-line no-control-regex
        var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
        var serializeCookie = function serializeCookie(name, val, options) {
          var opt = options || {};
          opt.path = opt.path || '/';
          var value = encodeURIComponent(val);
          var str = "".concat(name, "=").concat(value);
          if (opt.maxAge > 0) {
            var maxAge = opt.maxAge - 0;
            if (Number.isNaN(maxAge)) throw new Error('maxAge should be a Number');
            str += "; Max-Age=".concat(Math.floor(maxAge));
          }
          if (opt.domain) {
            if (!fieldContentRegExp.test(opt.domain)) {
              throw new TypeError('option domain is invalid');
            }
            str += "; Domain=".concat(opt.domain);
          }
          if (opt.path) {
            if (!fieldContentRegExp.test(opt.path)) {
              throw new TypeError('option path is invalid');
            }
            str += "; Path=".concat(opt.path);
          }
          if (opt.expires) {
            if (typeof opt.expires.toUTCString !== 'function') {
              throw new TypeError('option expires is invalid');
            }
            str += "; Expires=".concat(opt.expires.toUTCString());
          }
          if (opt.httpOnly) str += '; HttpOnly';
          if (opt.secure) str += '; Secure';
          if (opt.sameSite) {
            var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;
            switch (sameSite) {
              case true:
                str += '; SameSite=Strict';
                break;
              case 'lax':
                str += '; SameSite=Lax';
                break;
              case 'strict':
                str += '; SameSite=Strict';
                break;
              case 'none':
                str += '; SameSite=None';
                break;
              default:
                throw new TypeError('option sameSite is invalid');
            }
          }
          return str;
        };
        var cookie = {
          create: function create(name, value, minutes, domain) {
            var cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
              path: '/',
              sameSite: 'strict'
            };
            if (minutes) {
              cookieOptions.expires = new Date();
              cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1000);
            }
            if (domain) cookieOptions.domain = domain;
            document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);
          },
          read: function read(name) {
            var nameEQ = "".concat(name, "=");
            var ca = document.cookie.split(';');
            for (var i = 0; i < ca.length; i++) {
              var c = ca[i];
              while (c.charAt(0) === ' ') {
                c = c.substring(1, c.length);
              }
              if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
          },
          remove: function remove(name) {
            this.create(name, '', -1);
          }
        };
        var cookie$1 = {
          name: 'cookie',
          lookup: function lookup(options) {
            var found;
            if (options.lookupCookie && typeof document !== 'undefined') {
              var c = cookie.read(options.lookupCookie);
              if (c) found = c;
            }
            return found;
          },
          cacheUserLanguage: function cacheUserLanguage(lng, options) {
            if (options.lookupCookie && typeof document !== 'undefined') {
              cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain, options.cookieOptions);
            }
          }
        };
        var querystring = {
          name: 'querystring',
          lookup: function lookup(options) {
            var found;
            if (typeof window !== 'undefined') {
              var search = window.location.search;
              if (!window.location.search && window.location.hash && window.location.hash.indexOf('?') > -1) {
                search = window.location.hash.substring(window.location.hash.indexOf('?'));
              }
              var query = search.substring(1);
              var params = query.split('&');
              for (var i = 0; i < params.length; i++) {
                var pos = params[i].indexOf('=');
                if (pos > 0) {
                  var key = params[i].substring(0, pos);
                  if (key === options.lookupQuerystring) {
                    found = params[i].substring(pos + 1);
                  }
                }
              }
            }
            return found;
          }
        };
        var hasLocalStorageSupport = null;
        var localStorageAvailable = function localStorageAvailable() {
          if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
          try {
            hasLocalStorageSupport = window !== 'undefined' && window.localStorage !== null;
            var testKey = 'i18next.translate.boo';
            window.localStorage.setItem(testKey, 'foo');
            window.localStorage.removeItem(testKey);
          } catch (e) {
            hasLocalStorageSupport = false;
          }
          return hasLocalStorageSupport;
        };
        var localStorage = {
          name: 'localStorage',
          lookup: function lookup(options) {
            var found;
            if (options.lookupLocalStorage && localStorageAvailable()) {
              var lng = window.localStorage.getItem(options.lookupLocalStorage);
              if (lng) found = lng;
            }
            return found;
          },
          cacheUserLanguage: function cacheUserLanguage(lng, options) {
            if (options.lookupLocalStorage && localStorageAvailable()) {
              window.localStorage.setItem(options.lookupLocalStorage, lng);
            }
          }
        };
        var hasSessionStorageSupport = null;
        var sessionStorageAvailable = function sessionStorageAvailable() {
          if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
          try {
            hasSessionStorageSupport = window !== 'undefined' && window.sessionStorage !== null;
            var testKey = 'i18next.translate.boo';
            window.sessionStorage.setItem(testKey, 'foo');
            window.sessionStorage.removeItem(testKey);
          } catch (e) {
            hasSessionStorageSupport = false;
          }
          return hasSessionStorageSupport;
        };
        var sessionStorage = {
          name: 'sessionStorage',
          lookup: function lookup(options) {
            var found;
            if (options.lookupSessionStorage && sessionStorageAvailable()) {
              var lng = window.sessionStorage.getItem(options.lookupSessionStorage);
              if (lng) found = lng;
            }
            return found;
          },
          cacheUserLanguage: function cacheUserLanguage(lng, options) {
            if (options.lookupSessionStorage && sessionStorageAvailable()) {
              window.sessionStorage.setItem(options.lookupSessionStorage, lng);
            }
          }
        };
        var navigator$1 = {
          name: 'navigator',
          lookup: function lookup(options) {
            var found = [];
            if (typeof navigator !== 'undefined') {
              if (navigator.languages) {
                // chrome only; not an array, so can't use .push.apply instead of iterating
                for (var i = 0; i < navigator.languages.length; i++) {
                  found.push(navigator.languages[i]);
                }
              }
              if (navigator.userLanguage) {
                found.push(navigator.userLanguage);
              }
              if (navigator.language) {
                found.push(navigator.language);
              }
            }
            return found.length > 0 ? found : undefined;
          }
        };
        var htmlTag = {
          name: 'htmlTag',
          lookup: function lookup(options) {
            var found;
            var htmlTag = options.htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);
            if (htmlTag && typeof htmlTag.getAttribute === 'function') {
              found = htmlTag.getAttribute('lang');
            }
            return found;
          }
        };
        var path = {
          name: 'path',
          lookup: function lookup(options) {
            var found;
            if (typeof window !== 'undefined') {
              var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
              if (language instanceof Array) {
                if (typeof options.lookupFromPathIndex === 'number') {
                  if (typeof language[options.lookupFromPathIndex] !== 'string') {
                    return undefined;
                  }
                  found = language[options.lookupFromPathIndex].replace('/', '');
                } else {
                  found = language[0].replace('/', '');
                }
              }
            }
            return found;
          }
        };
        var subdomain = {
          name: 'subdomain',
          lookup: function lookup(options) {
            // If given get the subdomain index else 1
            var lookupFromSubdomainIndex = typeof options.lookupFromSubdomainIndex === 'number' ? options.lookupFromSubdomainIndex + 1 : 1;
            // get all matches if window.location. is existing
            // first item of match is the match itself and the second is the first group macht which sould be the first subdomain match
            // is the hostname no public domain get the or option of localhost
            var language = typeof window !== 'undefined' && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);

            // if there is no match (null) return undefined
            if (!language) return undefined;
            // return the given group match
            return language[lookupFromSubdomainIndex];
          }
        };
        function getDefaults() {
          return {
            order: ['querystring', 'cookie', 'localStorage', 'sessionStorage', 'navigator', 'htmlTag'],
            lookupQuerystring: 'lng',
            lookupCookie: 'i18next',
            lookupLocalStorage: 'i18nextLng',
            lookupSessionStorage: 'i18nextLng',
            // cache user language
            caches: ['localStorage'],
            excludeCacheFor: ['cimode']
            // cookieMinutes: 10,
            // cookieDomain: 'myDomain'
          };
        }
        var Browser = exports("y", /*#__PURE__*/function () {
          function Browser(services) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck$3(this, Browser);
            this.type = 'languageDetector';
            this.detectors = {};
            this.init(services, options);
          }
          _createClass$3(Browser, [{
            key: "init",
            value: function init(services) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              this.services = services || {
                languageUtils: {}
              }; // this way the language detector can be used without i18next
              this.options = defaults$1(options, this.options || {}, getDefaults());

              // backwards compatibility
              if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
              this.i18nOptions = i18nOptions;
              this.addDetector(cookie$1);
              this.addDetector(querystring);
              this.addDetector(localStorage);
              this.addDetector(sessionStorage);
              this.addDetector(navigator$1);
              this.addDetector(htmlTag);
              this.addDetector(path);
              this.addDetector(subdomain);
            }
          }, {
            key: "addDetector",
            value: function addDetector(detector) {
              this.detectors[detector.name] = detector;
            }
          }, {
            key: "detect",
            value: function detect(detectionOrder) {
              var _this = this;
              if (!detectionOrder) detectionOrder = this.options.order;
              var detected = [];
              detectionOrder.forEach(function (detectorName) {
                if (_this.detectors[detectorName]) {
                  var lookup = _this.detectors[detectorName].lookup(_this.options);
                  if (lookup && typeof lookup === 'string') lookup = [lookup];
                  if (lookup) detected = detected.concat(lookup);
                }
              });
              if (this.services.languageUtils.getBestMatchFromCodes) return detected; // new i18next v19.5.0
              return detected.length > 0 ? detected[0] : null; // a little backward compatibility
            }
          }, {
            key: "cacheUserLanguage",
            value: function cacheUserLanguage(lng, caches) {
              var _this2 = this;
              if (!caches) caches = this.options.caches;
              if (!caches) return;
              if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
              caches.forEach(function (cacheName) {
                if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
              });
            }
          }]);
          return Browser;
        }());
        Browser.type = 'languageDetector';

        // src/app-data/index.ts
        var BUILD = {
          allRenderFn: false,
          element: true,
          event: true,
          hasRenderFn: true,
          hostListener: true,
          hostListenerTargetWindow: true,
          hostListenerTargetDocument: true,
          hostListenerTargetBody: true,
          hostListenerTargetParent: false,
          hostListenerTarget: true,
          member: true,
          method: true,
          mode: true,
          observeAttribute: true,
          prop: true,
          propMutable: true,
          reflect: true,
          scoped: true,
          shadowDom: true,
          slot: true,
          cssAnnotations: true,
          state: true,
          style: true,
          formAssociated: false,
          svg: true,
          updatable: true,
          vdomAttribute: true,
          vdomXlink: true,
          vdomClass: true,
          vdomFunctional: true,
          vdomKey: true,
          vdomListener: true,
          vdomRef: true,
          vdomPropOrAttr: true,
          vdomRender: true,
          vdomStyle: true,
          vdomText: true,
          watchCallback: true,
          taskQueue: true,
          hotModuleReplacement: false,
          isDebug: false,
          isDev: false,
          isTesting: false,
          hydrateServerSide: false,
          hydrateClientSide: false,
          lifecycleDOMEvents: false,
          lazyLoad: false,
          profile: false,
          slotRelocation: true,
          // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
          appendChildSlotFix: false,
          // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
          cloneNodeFix: false,
          hydratedAttribute: false,
          hydratedClass: true,
          // TODO(STENCIL-1305): remove this option
          scriptDataOpts: false,
          // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
          scopedSlotTextContentFix: false,
          // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
          shadowDomShim: false,
          // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
          slotChildNodesFix: false,
          invisiblePrehydration: true,
          propBoolean: true,
          propNumber: true,
          propString: true,
          constructableCSS: true,
          devTools: false,
          shadowDelegatesFocus: true,
          initializeNextTick: false,
          asyncLoading: true,
          asyncQueue: false,
          transformTagName: false,
          attachStyles: true,
          // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
          experimentalSlotFixes: false
        };
        var NAMESPACE$1 = /* default */
        "app";
        var __defProp = Object.defineProperty;
        var __export = (target, all) => {
          for (var name in all) __defProp(target, name, {
            get: all[name],
            enumerable: true
          });
        };
        var Build = exports("B", {
          isBrowser: true
        });
        var SVG_NS = "http://www.w3.org/2000/svg";
        var HTML_NS = "http://www.w3.org/1999/xhtml";
        var reWireGetterSetter = (instance, hostRef) => {
          var _a;
          const cmpMeta = hostRef.$cmpMeta$;
          const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});
          members.map(([memberName, [memberFlags]]) => {
            if (memberFlags & 31 || memberFlags & 32) {
              const ogValue = instance[memberName];
              const ogDescriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(instance), memberName);
              Object.defineProperty(instance, memberName, {
                get() {
                  return ogDescriptor.get.call(this);
                },
                set(newValue) {
                  ogDescriptor.set.call(this, newValue);
                },
                configurable: true,
                enumerable: true
              });
              instance[memberName] = hostRef.$instanceValues$.has(memberName) ? hostRef.$instanceValues$.get(memberName) : ogValue;
            }
          });
        };
        var getHostRef = ref => {
          if (ref.__stencil__getHostRef) {
            return ref.__stencil__getHostRef();
          }
          return void 0;
        };
        var registerHost = (hostElement, cmpMeta) => {
          const hostRef = {
            $flags$: 0,
            $hostElement$: hostElement,
            $cmpMeta$: cmpMeta,
            $instanceValues$: /* @__PURE__ */new Map()
          };
          {
            hostRef.$onReadyPromise$ = new Promise(r => hostRef.$onReadyResolve$ = r);
            hostElement["s-p"] = [];
            hostElement["s-rc"] = [];
          }
          const ref = hostRef;
          hostElement.__stencil__getHostRef = () => ref;
          if (BUILD.modernPropertyDecls && BUILD.state) {
            reWireGetterSetter(hostElement, hostRef);
          }
          return ref;
        };
        var isMemberInElement = (elm, memberName) => memberName in elm;
        var consoleError = (e, el) => (0, console.error)(e, el);
        var styles = /* @__PURE__ */new Map();
        var modeResolutionChain = [];
        var SLOT_FB_CSS = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
        var XLINK_NS = "http://www.w3.org/1999/xlink";
        var win = typeof window !== "undefined" ? window : {};
        var H = exports("H", win.HTMLElement || class {});
        var plt = {
          $flags$: 0,
          $resourcesUrl$: "",
          jmp: h2 => h2(),
          raf: h2 => requestAnimationFrame(h2),
          ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
          rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
          ce: (eventName, opts) => new CustomEvent(eventName, opts)
        };
        var promiseResolve = v => Promise.resolve(v);
        var supportsConstructableStylesheets = /* @__PURE__ */(() => {
          try {
            new CSSStyleSheet();
            return typeof new CSSStyleSheet().replaceSync === "function";
          } catch (e) {}
          return false;
        })();
        var supportsMutableAdoptedStyleSheets = supportsConstructableStylesheets ? /* @__PURE__ */(() => !!win.document && Object.getOwnPropertyDescriptor(win.document.adoptedStyleSheets, "length").writable)() : false;
        var queuePending = false;
        var queueDomReads = [];
        var queueDomWrites = [];
        var queueTask = (queue, write) => cb => {
          queue.push(cb);
          if (!queuePending) {
            queuePending = true;
            if (write && plt.$flags$ & 4) {
              nextTick$1(flush);
            } else {
              plt.raf(flush);
            }
          }
        };
        var consume = queue => {
          for (let i2 = 0; i2 < queue.length; i2++) {
            try {
              queue[i2](performance.now());
            } catch (e) {
              consoleError(e);
            }
          }
          queue.length = 0;
        };
        var flush = () => {
          consume(queueDomReads);
          {
            consume(queueDomWrites);
            if (queuePending = queueDomReads.length > 0) {
              plt.raf(flush);
            }
          }
        };
        var nextTick$1 = cb => promiseResolve().then(cb);
        var readTask = exports("r", /* @__PURE__ */queueTask(queueDomReads, false));
        var writeTask = exports("w", /* @__PURE__ */queueTask(queueDomWrites, true));
        var getAssetPath = exports("b", path => {
          const assetUrl = new URL(path, plt.$resourcesUrl$);
          return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
        });
        var isDef = v => v != null && v !== void 0;
        var isComplexType = o => {
          o = typeof o;
          return o === "object" || o === "function";
        };
        function queryNonceMetaTagContent(doc) {
          var _a, _b, _c;
          return (_c = (_b = (_a = doc.head) == null ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) == null ? void 0 : _b.getAttribute("content")) != null ? _c : void 0;
        }
        var escapeRegExpSpecialCharacters = text => {
          return text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        };
        var result_exports = {};
        __export(result_exports, {
          err: () => err,
          map: () => map,
          ok: () => ok,
          unwrap: () => unwrap$1,
          unwrapErr: () => unwrapErr
        });
        var ok = value => ({
          isOk: true,
          isErr: false,
          value
        });
        var err = value => ({
          isOk: false,
          isErr: true,
          value
        });
        function map(result, fn) {
          if (result.isOk) {
            const val = fn(result.value);
            if (val instanceof Promise) {
              return val.then(newVal => ok(newVal));
            } else {
              return ok(val);
            }
          }
          if (result.isErr) {
            const value = result.value;
            return err(value);
          }
          throw "should never get here";
        }
        var unwrap$1 = result => {
          if (result.isOk) {
            return result.value;
          } else {
            throw result.value;
          }
        };
        var unwrapErr = result => {
          if (result.isErr) {
            return result.value;
          } else {
            throw result.value;
          }
        };
        function createStyleSheetIfNeededAndSupported(styles2) {
          return void 0;
        }
        var globalStyleSheet;
        function createShadowRoot(cmpMeta) {
          var _a;
          const shadowRoot = this.attachShadow({
            mode: "open",
            delegatesFocus: !!(cmpMeta.$flags$ & 16)
          });
          if (globalStyleSheet === void 0) globalStyleSheet = (_a = createStyleSheetIfNeededAndSupported()) != null ? _a : null;
          if (globalStyleSheet) {
            if (supportsMutableAdoptedStyleSheets) {
              shadowRoot.adoptedStyleSheets.push(globalStyleSheet);
            } else {
              shadowRoot.adoptedStyleSheets = [...shadowRoot.adoptedStyleSheets, globalStyleSheet];
            }
          }
        }
        var updateFallbackSlotVisibility = elm => {
          const childNodes = internalCall(elm, "childNodes");
          if (elm.tagName && elm.tagName.includes("-") && elm["s-cr"] && elm.tagName !== "SLOT-FB") {
            getHostSlotNodes(childNodes, elm.tagName).forEach(slotNode => {
              if (slotNode.nodeType === 1 && slotNode.tagName === "SLOT-FB") {
                if (getSlotChildSiblings(slotNode, getSlotName(slotNode), false).length) {
                  slotNode.hidden = true;
                } else {
                  slotNode.hidden = false;
                }
              }
            });
          }
          let i2 = 0;
          for (i2 = 0; i2 < childNodes.length; i2++) {
            const childNode = childNodes[i2];
            if (childNode.nodeType === 1 && internalCall(childNode, "childNodes").length) {
              updateFallbackSlotVisibility(childNode);
            }
          }
        };
        var getSlottedChildNodes = childNodes => {
          const result = [];
          for (let i2 = 0; i2 < childNodes.length; i2++) {
            const slottedNode = childNodes[i2]["s-nr"] || void 0;
            if (slottedNode && slottedNode.isConnected) {
              result.push(slottedNode);
            }
          }
          return result;
        };
        function getHostSlotNodes(childNodes, hostName, slotName) {
          let i2 = 0;
          let slottedNodes = [];
          let childNode;
          for (; i2 < childNodes.length; i2++) {
            childNode = childNodes[i2];
            if (childNode["s-sr"] && (!hostName || childNode["s-hn"] === hostName) && slotName === void 0) {
              slottedNodes.push(childNode);
            }
            slottedNodes = [...slottedNodes, ...getHostSlotNodes(childNode.childNodes, hostName, slotName)];
          }
          return slottedNodes;
        }
        var getSlotChildSiblings = (slot, slotName, includeSlot = true) => {
          const childNodes = [];
          if (includeSlot && slot["s-sr"] || !slot["s-sr"]) childNodes.push(slot);
          let node = slot;
          while (node = node.nextSibling) {
            if (getSlotName(node) === slotName && (includeSlot || !node["s-sr"])) childNodes.push(node);
          }
          return childNodes;
        };
        var isNodeLocatedInSlot = (nodeToRelocate, slotName) => {
          if (nodeToRelocate.nodeType === 1) {
            if (nodeToRelocate.getAttribute("slot") === null && slotName === "") {
              return true;
            }
            if (nodeToRelocate.getAttribute("slot") === slotName) {
              return true;
            }
            return false;
          }
          if (nodeToRelocate["s-sn"] === slotName) {
            return true;
          }
          return slotName === "";
        };
        var getSlotName = node => typeof node["s-sn"] === "string" ? node["s-sn"] : node.nodeType === 1 && node.getAttribute("slot") || void 0;
        function patchSlotNode(node) {
          if (node.assignedElements || node.assignedNodes || !node["s-sr"]) return;
          const assignedFactory = elementsOnly => function (opts) {
            const toReturn = [];
            const slotName = this["s-sn"];
            if (opts == null ? void 0 : opts.flatten) {
              console.error(`
          Flattening is not supported for Stencil non-shadow slots.
          You can use \`.childNodes\` to nested slot fallback content.
          If you have a particular use case, please open an issue on the Stencil repo.
        `);
            }
            const parent = this["s-cr"].parentElement;
            const slottedNodes = parent.__childNodes ? parent.childNodes : getSlottedChildNodes(parent.childNodes);
            slottedNodes.forEach(n => {
              if (slotName === getSlotName(n)) {
                toReturn.push(n);
              }
            });
            if (elementsOnly) {
              return toReturn.filter(n => n.nodeType === 1
              /* ElementNode */);
            }
            return toReturn;
          }.bind(node);
          node.assignedElements = assignedFactory(true);
          node.assignedNodes = assignedFactory(false);
        }
        function internalCall(node, method) {
          if ("__" + method in node) {
            const toReturn = node["__" + method];
            if (typeof toReturn !== "function") return toReturn;
            return toReturn.bind(node);
          } else {
            if (typeof node[method] !== "function") return node[method];
            return node[method].bind(node);
          }
        }
        var createTime = (fnName, tagName = "") => {
          {
            return () => {
              return;
            };
          }
        };
        var rootAppliedStyles = /* @__PURE__ */new WeakMap();
        var registerStyle = (scopeId2, cssText, allowCS) => {
          let style = styles.get(scopeId2);
          if (supportsConstructableStylesheets && allowCS) {
            style = style || new CSSStyleSheet();
            if (typeof style === "string") {
              style = cssText;
            } else {
              style.replaceSync(cssText);
            }
          } else {
            style = cssText;
          }
          styles.set(scopeId2, style);
        };
        var addStyle$1 = (styleContainerNode, cmpMeta, mode) => {
          var _a;
          const scopeId2 = getScopeId(cmpMeta, mode);
          const style = styles.get(scopeId2);
          if (!win.document) {
            return scopeId2;
          }
          styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : win.document;
          if (style) {
            if (typeof style === "string") {
              styleContainerNode = styleContainerNode.head || styleContainerNode;
              let appliedStyles = rootAppliedStyles.get(styleContainerNode);
              let styleElm;
              if (!appliedStyles) {
                rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */new Set());
              }
              if (!appliedStyles.has(scopeId2)) {
                {
                  styleElm = win.document.createElement("style");
                  styleElm.innerHTML = style;
                  const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(win.document);
                  if (nonce != null) {
                    styleElm.setAttribute("nonce", nonce);
                  }
                  if (!(cmpMeta.$flags$ & 1)) {
                    if (styleContainerNode.nodeName === "HEAD") {
                      const preconnectLinks = styleContainerNode.querySelectorAll("link[rel=preconnect]");
                      const referenceNode2 = preconnectLinks.length > 0 ? preconnectLinks[preconnectLinks.length - 1].nextSibling : styleContainerNode.querySelector("style");
                      styleContainerNode.insertBefore(styleElm, (referenceNode2 == null ? void 0 : referenceNode2.parentNode) === styleContainerNode ? referenceNode2 : null);
                    } else if ("host" in styleContainerNode) {
                      if (supportsConstructableStylesheets) {
                        const stylesheet = new CSSStyleSheet();
                        stylesheet.replaceSync(style);
                        if (supportsMutableAdoptedStyleSheets) {
                          styleContainerNode.adoptedStyleSheets.unshift(stylesheet);
                        } else {
                          styleContainerNode.adoptedStyleSheets = [stylesheet, ...styleContainerNode.adoptedStyleSheets];
                        }
                      } else {
                        const existingStyleContainer = styleContainerNode.querySelector("style");
                        if (existingStyleContainer) {
                          existingStyleContainer.innerHTML = style + existingStyleContainer.innerHTML;
                        } else {
                          styleContainerNode.prepend(styleElm);
                        }
                      }
                    } else {
                      styleContainerNode.append(styleElm);
                    }
                  }
                  if (cmpMeta.$flags$ & 1) {
                    styleContainerNode.insertBefore(styleElm, null);
                  }
                }
                if (cmpMeta.$flags$ & 4) {
                  styleElm.innerHTML += SLOT_FB_CSS;
                }
                if (appliedStyles) {
                  appliedStyles.add(scopeId2);
                }
              }
            } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
              if (supportsMutableAdoptedStyleSheets) {
                styleContainerNode.adoptedStyleSheets.push(style);
              } else {
                styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
              }
            }
          }
          return scopeId2;
        };
        var attachStyles = hostRef => {
          const cmpMeta = hostRef.$cmpMeta$;
          const elm = hostRef.$hostElement$;
          const flags = cmpMeta.$flags$;
          const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
          const scopeId2 = addStyle$1(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$);
          if (flags & 10) {
            elm["s-sc"] = scopeId2;
            elm.classList.add(scopeId2 + "-h");
          }
          endAttachStyles();
        };
        var getScopeId = (cmp, mode) => "sc-" + (mode && cmp.$flags$ & 32 ? cmp.$tagName$ + "-" + mode : cmp.$tagName$);
        var h$1 = exports("h", (nodeName, vnodeData, ...children) => {
          let child = null;
          let key = null;
          let slotName = null;
          let simple = false;
          let lastSimple = false;
          const vNodeChildren = [];
          const walk = c => {
            for (let i2 = 0; i2 < c.length; i2++) {
              child = c[i2];
              if (Array.isArray(child)) {
                walk(child);
              } else if (child != null && typeof child !== "boolean") {
                if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
                  child = String(child);
                }
                if (simple && lastSimple) {
                  vNodeChildren[vNodeChildren.length - 1].$text$ += child;
                } else {
                  vNodeChildren.push(simple ? newVNode(null, child) : child);
                }
                lastSimple = simple;
              }
            }
          };
          walk(children);
          if (vnodeData) {
            if (vnodeData.key) {
              key = vnodeData.key;
            }
            if (vnodeData.name) {
              slotName = vnodeData.name;
            }
            {
              const classData = vnodeData.className || vnodeData.class;
              if (classData) {
                vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter(k => classData[k]).join(" ");
              }
            }
          }
          if (typeof nodeName === "function") {
            return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
          }
          const vnode = newVNode(nodeName, null);
          vnode.$attrs$ = vnodeData;
          if (vNodeChildren.length > 0) {
            vnode.$children$ = vNodeChildren;
          }
          {
            vnode.$key$ = key;
          }
          {
            vnode.$name$ = slotName;
          }
          return vnode;
        });
        var newVNode = (tag, text) => {
          const vnode = {
            $flags$: 0,
            $tag$: tag,
            $text$: text,
            $elm$: null,
            $children$: null
          };
          {
            vnode.$attrs$ = null;
          }
          {
            vnode.$key$ = null;
          }
          {
            vnode.$name$ = null;
          }
          return vnode;
        };
        var Host = exports("a", {});
        var isHost = node => node && node.$tag$ === Host;
        var vdomFnUtils = {
          forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
          map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate)
        };
        var convertToPublic = node => ({
          vattrs: node.$attrs$,
          vchildren: node.$children$,
          vkey: node.$key$,
          vname: node.$name$,
          vtag: node.$tag$,
          vtext: node.$text$
        });
        var convertToPrivate = node => {
          if (typeof node.vtag === "function") {
            const vnodeData = {
              ...node.vattrs
            };
            if (node.vkey) {
              vnodeData.key = node.vkey;
            }
            if (node.vname) {
              vnodeData.name = node.vname;
            }
            return h$1(node.vtag, vnodeData, ...(node.vchildren || []));
          }
          const vnode = newVNode(node.vtag, node.vtext);
          vnode.$attrs$ = node.vattrs;
          vnode.$children$ = node.vchildren;
          vnode.$key$ = node.vkey;
          vnode.$name$ = node.vname;
          return vnode;
        };
        var createSupportsRuleRe = selector => {
          const safeSelector2 = escapeRegExpSpecialCharacters(selector);
          return new RegExp(
          // First capture group: match any context before the selector that's not inside @supports selector()
          // Using negative lookahead to avoid matching inside @supports selector(...) condition
          `(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${safeSelector2}))(${safeSelector2}\\b)`, "g");
        };
        createSupportsRuleRe("::slotted");
        createSupportsRuleRe(":host");
        createSupportsRuleRe(":host-context");
        var computeMode = elm => modeResolutionChain.map(h2 => h2(elm)).find(m => !!m);
        var setMode = exports("s", handler => modeResolutionChain.push(handler));
        var getMode = exports("g", ref => {
          var _a;
          return (_a = getHostRef(ref)) == null ? void 0 : _a.$modeName$;
        });
        var parsePropertyValue = (propValue, propType, isFormAssociated) => {
          if (typeof propValue === "string" && (propType & 16 || propType & 8) && (propValue.startsWith("{") && propValue.endsWith("}") || propValue.startsWith("[") && propValue.endsWith("]"))) {
            try {
              return JSON.parse(propValue);
            } catch (e) {}
          }
          if (propValue != null && !isComplexType(propValue)) {
            if (propType & 4) {
              {
                return propValue === "false" ? false : propValue === "" || !!propValue;
              }
            }
            if (propType & 2) {
              return typeof propValue === "string" ? parseFloat(propValue) : typeof propValue === "number" ? propValue : NaN;
            }
            if (propType & 1) {
              return String(propValue);
            }
            return propValue;
          }
          return propValue;
        };
        var getElement = ref => {
          return ref;
        };
        var createEvent = exports("c", (ref, name, flags) => {
          const elm = getElement(ref);
          return {
            emit: detail => {
              return emitEvent(elm, name, {
                bubbles: !!(flags & 4),
                composed: !!(flags & 2),
                cancelable: !!(flags & 1),
                detail
              });
            }
          };
        });
        var emitEvent = (elm, name, opts) => {
          const ev = plt.ce(name, opts);
          elm.dispatchEvent(ev);
          return ev;
        };
        var setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags, initialRender) => {
          if (oldValue === newValue) {
            return;
          }
          let isProp = isMemberInElement(elm, memberName);
          let ln = memberName.toLowerCase();
          if (memberName === "class") {
            const classList = elm.classList;
            const oldClasses = parseClassList(oldValue);
            let newClasses = parseClassList(newValue);
            {
              classList.remove(...oldClasses.filter(c => c && !newClasses.includes(c)));
              classList.add(...newClasses.filter(c => c && !oldClasses.includes(c)));
            }
          } else if (memberName === "style") {
            {
              for (const prop in oldValue) {
                if (!newValue || newValue[prop] == null) {
                  if (prop.includes("-")) {
                    elm.style.removeProperty(prop);
                  } else {
                    elm.style[prop] = "";
                  }
                }
              }
            }
            for (const prop in newValue) {
              if (!oldValue || newValue[prop] !== oldValue[prop]) {
                if (prop.includes("-")) {
                  elm.style.setProperty(prop, newValue[prop]);
                } else {
                  elm.style[prop] = newValue[prop];
                }
              }
            }
          } else if (memberName === "key") ;else if (memberName === "ref") {
            if (newValue) {
              newValue(elm);
            }
          } else if (!elm.__lookupSetter__(memberName) && memberName[0] === "o" && memberName[1] === "n") {
            if (memberName[2] === "-") {
              memberName = memberName.slice(3);
            } else if (isMemberInElement(win, ln)) {
              memberName = ln.slice(2);
            } else {
              memberName = ln[2] + memberName.slice(3);
            }
            if (oldValue || newValue) {
              const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);
              memberName = memberName.replace(CAPTURE_EVENT_REGEX, "");
              if (oldValue) {
                plt.rel(elm, memberName, oldValue, capture);
              }
              if (newValue) {
                plt.ael(elm, memberName, newValue, capture);
              }
            }
          } else {
            const isComplex = isComplexType(newValue);
            if ((isProp || isComplex && newValue !== null) && !isSvg) {
              try {
                if (!elm.tagName.includes("-")) {
                  const n = newValue == null ? "" : newValue;
                  if (memberName === "list") {
                    isProp = false;
                  } else if (oldValue == null || elm[memberName] != n) {
                    if (typeof elm.__lookupSetter__(memberName) === "function") {
                      elm[memberName] = n;
                    } else {
                      elm.setAttribute(memberName, n);
                    }
                  }
                } else if (elm[memberName] !== newValue) {
                  elm[memberName] = newValue;
                }
              } catch (e) {}
            }
            let xlink = false;
            {
              if (ln !== (ln = ln.replace(/^xlink\:?/, ""))) {
                memberName = ln;
                xlink = true;
              }
            }
            if (newValue == null || newValue === false) {
              if (newValue !== false || elm.getAttribute(memberName) === "") {
                if (xlink) {
                  elm.removeAttributeNS(XLINK_NS, memberName);
                } else {
                  elm.removeAttribute(memberName);
                }
              }
            } else if ((!isProp || flags & 4 || isSvg) && !isComplex && elm.nodeType === 1) {
              newValue = newValue === true ? "" : newValue;
              if (xlink) {
                elm.setAttributeNS(XLINK_NS, memberName, newValue);
              } else {
                elm.setAttribute(memberName, newValue);
              }
            }
          }
        };
        var parseClassListRegex = /\s/;
        var parseClassList = value => {
          if (typeof value === "object" && value && "baseVal" in value) {
            value = value.baseVal;
          }
          if (!value || typeof value !== "string") {
            return [];
          }
          return value.split(parseClassListRegex);
        };
        var CAPTURE_EVENT_SUFFIX = "Capture";
        var CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + "$");
        var updateElement = (oldVnode, newVnode, isSvgMode2, isInitialRender) => {
          const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
          const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || {};
          const newVnodeAttrs = newVnode.$attrs$ || {};
          {
            for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {
              if (!(memberName in newVnodeAttrs)) {
                setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
              }
            }
          }
          for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {
            setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
          }
        };
        function sortedAttrNames(attrNames) {
          return attrNames.includes("ref") ?
          // we need to sort these to ensure that `'ref'` is the last attr
          [...attrNames.filter(attr => attr !== "ref"), "ref"] :
          // no need to sort, return the original array
          attrNames;
        }
        var scopeId;
        var contentRef;
        var hostTagName;
        var useNativeShadowDom = false;
        var checkSlotFallbackVisibility = false;
        var checkSlotRelocate = false;
        var isSvgMode = false;
        var createElm = (oldParentVNode, newParentVNode, childIndex) => {
          var _a;
          const newVNode2 = newParentVNode.$children$[childIndex];
          let i2 = 0;
          let elm;
          let childNode;
          let oldVNode;
          if (!useNativeShadowDom) {
            checkSlotRelocate = true;
            if (newVNode2.$tag$ === "slot") {
              newVNode2.$flags$ |= newVNode2.$children$ ?
              // slot element has fallback content
              // still create an element that "mocks" the slot element
              2 :
              // slot element does not have fallback content
              // create an html comment we'll use to always reference
              // where actual slot content should sit next to
              1;
            }
          }
          if (newVNode2.$text$ !== null) {
            elm = newVNode2.$elm$ = win.document.createTextNode(newVNode2.$text$);
          } else if (newVNode2.$flags$ & 1) {
            elm = newVNode2.$elm$ = win.document.createTextNode("");
            {
              updateElement(null, newVNode2, isSvgMode);
            }
          } else {
            if (!isSvgMode) {
              isSvgMode = newVNode2.$tag$ === "svg";
            }
            if (!win.document) {
              throw new Error("You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.");
            }
            elm = newVNode2.$elm$ = win.document.createElementNS(isSvgMode ? SVG_NS : HTML_NS, !useNativeShadowDom && BUILD.slotRelocation && newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$);
            if (isSvgMode && newVNode2.$tag$ === "foreignObject") {
              isSvgMode = false;
            }
            {
              updateElement(null, newVNode2, isSvgMode);
            }
            if (isDef(scopeId) && elm["s-si"] !== scopeId) {
              elm.classList.add(elm["s-si"] = scopeId);
            }
            if (newVNode2.$children$) {
              for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {
                childNode = createElm(oldParentVNode, newVNode2, i2);
                if (childNode) {
                  elm.appendChild(childNode);
                }
              }
            }
            {
              if (newVNode2.$tag$ === "svg") {
                isSvgMode = false;
              } else if (elm.tagName === "foreignObject") {
                isSvgMode = true;
              }
            }
          }
          elm["s-hn"] = hostTagName;
          {
            if (newVNode2.$flags$ & (2 | 1)) {
              elm["s-sr"] = true;
              elm["s-cr"] = contentRef;
              elm["s-sn"] = newVNode2.$name$ || "";
              elm["s-rf"] = (_a = newVNode2.$attrs$) == null ? void 0 : _a.ref;
              patchSlotNode(elm);
              oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
              if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
                {
                  putBackInOriginalLocation(oldParentVNode.$elm$, false);
                }
              }
              {
                addRemoveSlotScopedClass(contentRef, elm, newParentVNode.$elm$, oldParentVNode == null ? void 0 : oldParentVNode.$elm$);
              }
            }
          }
          return elm;
        };
        var putBackInOriginalLocation = (parentElm, recursive) => {
          plt.$flags$ |= 1;
          const oldSlotChildNodes = Array.from(parentElm.__childNodes || parentElm.childNodes);
          if (parentElm["s-sr"] && BUILD.experimentalSlotFixes) ;
          for (let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--) {
            const childNode = oldSlotChildNodes[i2];
            if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
              insertBefore(referenceNode(childNode).parentNode, childNode, referenceNode(childNode));
              childNode["s-ol"].remove();
              childNode["s-ol"] = void 0;
              childNode["s-sh"] = void 0;
              checkSlotRelocate = true;
            }
            if (recursive) {
              putBackInOriginalLocation(childNode, recursive);
            }
          }
          plt.$flags$ &= -2;
        };
        var addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
          let containerElm = parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
          let childNode;
          if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
            containerElm = containerElm.shadowRoot;
          }
          for (; startIdx <= endIdx; ++startIdx) {
            if (vnodes[startIdx]) {
              childNode = createElm(null, parentVNode, startIdx);
              if (childNode) {
                vnodes[startIdx].$elm$ = childNode;
                insertBefore(containerElm, childNode, referenceNode(before));
              }
            }
          }
        };
        var removeVnodes = (vnodes, startIdx, endIdx) => {
          for (let index = startIdx; index <= endIdx; ++index) {
            const vnode = vnodes[index];
            if (vnode) {
              const elm = vnode.$elm$;
              nullifyVNodeRefs(vnode);
              if (elm) {
                {
                  checkSlotFallbackVisibility = true;
                  if (elm["s-ol"]) {
                    elm["s-ol"].remove();
                  } else {
                    putBackInOriginalLocation(elm, true);
                  }
                }
                elm.remove();
              }
            }
          }
        };
        var updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {
          let oldStartIdx = 0;
          let newStartIdx = 0;
          let idxInOld = 0;
          let i2 = 0;
          let oldEndIdx = oldCh.length - 1;
          let oldStartVnode = oldCh[0];
          let oldEndVnode = oldCh[oldEndIdx];
          let newEndIdx = newCh.length - 1;
          let newStartVnode = newCh[0];
          let newEndVnode = newCh[newEndIdx];
          let node;
          let elmToMove;
          while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
              oldStartVnode = oldCh[++oldStartIdx];
            } else if (oldEndVnode == null) {
              oldEndVnode = oldCh[--oldEndIdx];
            } else if (newStartVnode == null) {
              newStartVnode = newCh[++newStartIdx];
            } else if (newEndVnode == null) {
              newEndVnode = newCh[--newEndIdx];
            } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {
              patch(oldStartVnode, newStartVnode, isInitialRender);
              oldStartVnode = oldCh[++oldStartIdx];
              newStartVnode = newCh[++newStartIdx];
            } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {
              patch(oldEndVnode, newEndVnode, isInitialRender);
              oldEndVnode = oldCh[--oldEndIdx];
              newEndVnode = newCh[--newEndIdx];
            } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {
              if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
              }
              patch(oldStartVnode, newEndVnode, isInitialRender);
              insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
              oldStartVnode = oldCh[++oldStartIdx];
              newEndVnode = newCh[--newEndIdx];
            } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {
              if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
              }
              patch(oldEndVnode, newStartVnode, isInitialRender);
              insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);
              oldEndVnode = oldCh[--oldEndIdx];
              newStartVnode = newCh[++newStartIdx];
            } else {
              idxInOld = -1;
              {
                for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {
                  if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
                    idxInOld = i2;
                    break;
                  }
                }
              }
              if (idxInOld >= 0) {
                elmToMove = oldCh[idxInOld];
                if (elmToMove.$tag$ !== newStartVnode.$tag$) {
                  node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld);
                } else {
                  patch(elmToMove, newStartVnode, isInitialRender);
                  oldCh[idxInOld] = void 0;
                  node = elmToMove.$elm$;
                }
                newStartVnode = newCh[++newStartIdx];
              } else {
                node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx);
                newStartVnode = newCh[++newStartIdx];
              }
              if (node) {
                {
                  insertBefore(referenceNode(oldStartVnode.$elm$).parentNode, node, referenceNode(oldStartVnode.$elm$));
                }
              }
            }
          }
          if (oldStartIdx > oldEndIdx) {
            addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);
          } else if (newStartIdx > newEndIdx) {
            removeVnodes(oldCh, oldStartIdx, oldEndIdx);
          }
        };
        var isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {
          if (leftVNode.$tag$ === rightVNode.$tag$) {
            if (leftVNode.$tag$ === "slot") {
              return leftVNode.$name$ === rightVNode.$name$;
            }
            if (!isInitialRender) {
              return leftVNode.$key$ === rightVNode.$key$;
            }
            if (isInitialRender && !leftVNode.$key$ && rightVNode.$key$) {
              leftVNode.$key$ = rightVNode.$key$;
            }
            return true;
          }
          return false;
        };
        var referenceNode = node => node && node["s-ol"] || node;
        var patch = (oldVNode, newVNode2, isInitialRender = false) => {
          const elm = newVNode2.$elm$ = oldVNode.$elm$;
          const oldChildren = oldVNode.$children$;
          const newChildren = newVNode2.$children$;
          const tag = newVNode2.$tag$;
          const text = newVNode2.$text$;
          let defaultHolder;
          if (text === null) {
            {
              isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
            }
            {
              updateElement(oldVNode, newVNode2, isSvgMode);
            }
            if (oldChildren !== null && newChildren !== null) {
              updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);
            } else if (newChildren !== null) {
              if (oldVNode.$text$ !== null) {
                elm.textContent = "";
              }
              addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
            } else if (
            // don't do this on initial render as it can cause non-hydrated content to be removed
            !isInitialRender && BUILD.updatable && oldChildren !== null) {
              removeVnodes(oldChildren, 0, oldChildren.length - 1);
            } else ;
            if (isSvgMode && tag === "svg") {
              isSvgMode = false;
            }
          } else if (defaultHolder = elm["s-cr"]) {
            defaultHolder.parentNode.textContent = text;
          } else if (oldVNode.$text$ !== text) {
            elm.data = text;
          }
        };
        var relocateNodes = [];
        var markSlotContentForRelocation = elm => {
          let node;
          let hostContentNodes;
          let j;
          const children = elm.__childNodes || elm.childNodes;
          for (const childNode of children) {
            if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
              hostContentNodes = node.parentNode.__childNodes || node.parentNode.childNodes;
              const slotName = childNode["s-sn"];
              for (j = hostContentNodes.length - 1; j >= 0; j--) {
                node = hostContentNodes[j];
                if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"] && true) {
                  if (isNodeLocatedInSlot(node, slotName)) {
                    let relocateNodeData = relocateNodes.find(r => r.$nodeToRelocate$ === node);
                    checkSlotFallbackVisibility = true;
                    node["s-sn"] = node["s-sn"] || slotName;
                    if (relocateNodeData) {
                      relocateNodeData.$nodeToRelocate$["s-sh"] = childNode["s-hn"];
                      relocateNodeData.$slotRefNode$ = childNode;
                    } else {
                      node["s-sh"] = childNode["s-hn"];
                      relocateNodes.push({
                        $slotRefNode$: childNode,
                        $nodeToRelocate$: node
                      });
                    }
                    if (node["s-sr"]) {
                      relocateNodes.map(relocateNode => {
                        if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                          relocateNodeData = relocateNodes.find(r => r.$nodeToRelocate$ === node);
                          if (relocateNodeData && !relocateNode.$slotRefNode$) {
                            relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                          }
                        }
                      });
                    }
                  } else if (!relocateNodes.some(r => r.$nodeToRelocate$ === node)) {
                    relocateNodes.push({
                      $nodeToRelocate$: node
                    });
                  }
                }
              }
            }
            if (childNode.nodeType === 1) {
              markSlotContentForRelocation(childNode);
            }
          }
        };
        var nullifyVNodeRefs = vNode => {
          {
            vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
            vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
          }
        };
        var insertBefore = (parent, newNode, reference) => {
          if (typeof newNode["s-sn"] === "string" && !!newNode["s-sr"] && !!newNode["s-cr"]) {
            addRemoveSlotScopedClass(newNode["s-cr"], newNode, parent, newNode.parentElement);
          }
          {
            return parent == null ? void 0 : parent.insertBefore(newNode, reference);
          }
        };
        function addRemoveSlotScopedClass(reference, slotNode, newParent, oldParent) {
          var _a, _b;
          let scopeId2;
          if (reference && typeof slotNode["s-sn"] === "string" && !!slotNode["s-sr"] && reference.parentNode && reference.parentNode["s-sc"] && (scopeId2 = slotNode["s-si"] || reference.parentNode["s-sc"])) {
            const scopeName = slotNode["s-sn"];
            const hostName = slotNode["s-hn"];
            (_a = newParent.classList) == null ? void 0 : _a.add(scopeId2 + "-s");
            if (oldParent && ((_b = oldParent.classList) == null ? void 0 : _b.contains(scopeId2 + "-s"))) {
              let child = (oldParent.__childNodes || oldParent.childNodes)[0];
              let found = false;
              while (child) {
                if (child["s-sn"] !== scopeName && child["s-hn"] === hostName && !!child["s-sr"]) {
                  found = true;
                  break;
                }
                child = child.nextSibling;
              }
              if (!found) oldParent.classList.remove(scopeId2 + "-s");
            }
          }
        }
        var renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
          var _a, _b, _c, _d, _e;
          const hostElm = hostRef.$hostElement$;
          const cmpMeta = hostRef.$cmpMeta$;
          const oldVNode = hostRef.$vnode$ || newVNode(null, null);
          const isHostElement = isHost(renderFnResults);
          const rootVnode = isHostElement ? renderFnResults : h$1(null, null, renderFnResults);
          hostTagName = hostElm.tagName;
          if (cmpMeta.$attrsToReflect$) {
            rootVnode.$attrs$ = rootVnode.$attrs$ || {};
            cmpMeta.$attrsToReflect$.map(([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]);
          }
          if (isInitialLoad && rootVnode.$attrs$) {
            for (const key of Object.keys(rootVnode.$attrs$)) {
              if (hostElm.hasAttribute(key) && !["key", "ref", "style", "class"].includes(key)) {
                rootVnode.$attrs$[key] = hostElm[key];
              }
            }
          }
          rootVnode.$tag$ = null;
          rootVnode.$flags$ |= 4;
          hostRef.$vnode$ = rootVnode;
          rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
          {
            scopeId = hostElm["s-sc"];
          }
          useNativeShadowDom = !!(cmpMeta.$flags$ & 1) && !(cmpMeta.$flags$ & 128);
          {
            contentRef = hostElm["s-cr"];
            checkSlotFallbackVisibility = false;
          }
          patch(oldVNode, rootVnode, isInitialLoad);
          {
            plt.$flags$ |= 1;
            if (checkSlotRelocate) {
              markSlotContentForRelocation(rootVnode.$elm$);
              for (const relocateData of relocateNodes) {
                const nodeToRelocate = relocateData.$nodeToRelocate$;
                if (!nodeToRelocate["s-ol"] && win.document) {
                  const orgLocationNode = win.document.createTextNode("");
                  orgLocationNode["s-nr"] = nodeToRelocate;
                  insertBefore(nodeToRelocate.parentNode, nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
                }
              }
              for (const relocateData of relocateNodes) {
                const nodeToRelocate = relocateData.$nodeToRelocate$;
                const slotRefNode = relocateData.$slotRefNode$;
                if (slotRefNode) {
                  const parentNodeRef = slotRefNode.parentNode;
                  let insertBeforeNode = slotRefNode.nextSibling;
                  {
                    let orgLocationNode = (_a = nodeToRelocate["s-ol"]) == null ? void 0 : _a.previousSibling;
                    while (orgLocationNode) {
                      let refNode = (_b = orgLocationNode["s-nr"]) != null ? _b : null;
                      if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === (refNode.__parentNode || refNode.parentNode)) {
                        refNode = refNode.nextSibling;
                        while (refNode === nodeToRelocate || (refNode == null ? void 0 : refNode["s-sr"])) {
                          refNode = refNode == null ? void 0 : refNode.nextSibling;
                        }
                        if (!refNode || !refNode["s-nr"]) {
                          insertBeforeNode = refNode;
                          break;
                        }
                      }
                      orgLocationNode = orgLocationNode.previousSibling;
                    }
                  }
                  const parent = nodeToRelocate.__parentNode || nodeToRelocate.parentNode;
                  const nextSibling = nodeToRelocate.__nextSibling || nodeToRelocate.nextSibling;
                  if (!insertBeforeNode && parentNodeRef !== parent || nextSibling !== insertBeforeNode) {
                    if (nodeToRelocate !== insertBeforeNode) {
                      if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                        nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
                      }
                      insertBefore(parentNodeRef, nodeToRelocate, insertBeforeNode);
                      if (nodeToRelocate.nodeType === 1 && nodeToRelocate.tagName !== "SLOT-FB") {
                        nodeToRelocate.hidden = (_c = nodeToRelocate["s-ih"]) != null ? _c : false;
                      }
                    }
                  }
                  nodeToRelocate && typeof slotRefNode["s-rf"] === "function" && slotRefNode["s-rf"](slotRefNode);
                } else {
                  if (nodeToRelocate.nodeType === 1) {
                    if (isInitialLoad) {
                      nodeToRelocate["s-ih"] = (_d = nodeToRelocate.hidden) != null ? _d : false;
                    }
                    nodeToRelocate.hidden = true;
                  }
                }
              }
            }
            if (checkSlotFallbackVisibility) {
              updateFallbackSlotVisibility(rootVnode.$elm$);
            }
            plt.$flags$ &= -2;
            relocateNodes.length = 0;
          }
          if (BUILD.experimentalScopedSlotChanges && cmpMeta.$flags$ & 2) {
            const children = rootVnode.$elm$.__childNodes || rootVnode.$elm$.childNodes;
            for (const childNode of children) {
              if (childNode["s-hn"] !== hostTagName && !childNode["s-sh"]) {
                if (isInitialLoad && childNode["s-ih"] == null) {
                  childNode["s-ih"] = (_e = childNode.hidden) != null ? _e : false;
                }
                childNode.hidden = true;
              }
            }
          }
          contentRef = void 0;
        };
        var attachToAncestor = (hostRef, ancestorComponent) => {
          if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
            const index = ancestorComponent["s-p"].push(new Promise(r => hostRef.$onRenderResolve$ = () => {
              ancestorComponent["s-p"].splice(index - 1, 1);
              r();
            }));
          }
        };
        var scheduleUpdate = (hostRef, isInitialLoad) => {
          {
            hostRef.$flags$ |= 16;
          }
          if (hostRef.$flags$ & 4) {
            hostRef.$flags$ |= 512;
            return;
          }
          attachToAncestor(hostRef, hostRef.$ancestorComponent$);
          const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
          if (isInitialLoad) {
            queueMicrotask(() => {
              dispatch();
            });
            return;
          }
          return writeTask(dispatch);
        };
        var dispatchHooks = (hostRef, isInitialLoad) => {
          const elm = hostRef.$hostElement$;
          const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
          const instance = elm;
          if (!instance) {
            throw new Error(`Can't render component <${elm.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);
          }
          let maybePromise;
          if (isInitialLoad) {
            maybePromise = safeCall(instance, "componentWillLoad", void 0, elm);
          } else {
            maybePromise = safeCall(instance, "componentWillUpdate", void 0, elm);
          }
          maybePromise = enqueue(maybePromise, () => safeCall(instance, "componentWillRender", void 0, elm));
          endSchedule();
          return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
        };
        var enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn).catch(err2 => {
          console.error(err2);
          fn();
        }) : fn();
        var isPromisey = maybePromise => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === "function";
        var updateComponent = async (hostRef, instance, isInitialLoad) => {
          var _a;
          const elm = hostRef.$hostElement$;
          const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
          const rc = elm["s-rc"];
          if (isInitialLoad) {
            attachStyles(hostRef);
          }
          const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
          {
            callRender(hostRef, instance, elm, isInitialLoad);
          }
          if (rc) {
            rc.map(cb => cb());
            elm["s-rc"] = void 0;
          }
          endRender();
          endUpdate();
          {
            const childrenPromises = (_a = elm["s-p"]) != null ? _a : [];
            const postUpdate = () => postUpdateComponent(hostRef);
            if (childrenPromises.length === 0) {
              postUpdate();
            } else {
              Promise.all(childrenPromises).then(postUpdate);
              hostRef.$flags$ |= 4;
              childrenPromises.length = 0;
            }
          }
        };
        var renderingRef = null;
        var callRender = (hostRef, instance, elm, isInitialLoad) => {
          const allRenderFn = false;
          const lazyLoad = false;
          const taskQueue = true;
          const updatable = true;
          try {
            renderingRef = instance;
            instance = allRenderFn ? instance.render() : instance.render && instance.render();
            if (updatable && taskQueue) {
              hostRef.$flags$ &= ~16;
            }
            if (updatable || lazyLoad) {
              hostRef.$flags$ |= 2;
            }
            if (BUILD.hasRenderFn || BUILD.reflect) {
              if (BUILD.vdomRender || BUILD.reflect) {
                if (BUILD.hydrateServerSide) ;else {
                  renderVdom(hostRef, instance, isInitialLoad);
                }
              }
            }
          } catch (e) {
            consoleError(e, hostRef.$hostElement$);
          }
          renderingRef = null;
          return null;
        };
        var postUpdateComponent = hostRef => {
          const tagName = hostRef.$cmpMeta$.$tagName$;
          const elm = hostRef.$hostElement$;
          const endPostUpdate = createTime("postUpdate", tagName);
          const instance = elm;
          const ancestorComponent = hostRef.$ancestorComponent$;
          safeCall(instance, "componentDidRender", void 0, elm);
          if (!(hostRef.$flags$ & 64)) {
            hostRef.$flags$ |= 64;
            {
              addHydratedFlag(elm);
            }
            safeCall(instance, "componentDidLoad", void 0, elm);
            endPostUpdate();
            {
              hostRef.$onReadyResolve$(elm);
              if (!ancestorComponent) {
                appDidLoad();
              }
            }
          } else {
            safeCall(instance, "componentDidUpdate", void 0, elm);
            endPostUpdate();
          }
          {
            if (hostRef.$onRenderResolve$) {
              hostRef.$onRenderResolve$();
              hostRef.$onRenderResolve$ = void 0;
            }
            if (hostRef.$flags$ & 512) {
              nextTick$1(() => scheduleUpdate(hostRef, false));
            }
            hostRef.$flags$ &= -517;
          }
        };
        var forceUpdate = exports("f", ref => {
          var _a;
          {
            const hostRef = getHostRef(ref);
            const isConnected = (_a = hostRef == null ? void 0 : hostRef.$hostElement$) == null ? void 0 : _a.isConnected;
            if (isConnected && (hostRef.$flags$ & (2 | 16)) === 2) {
              scheduleUpdate(hostRef, false);
            }
            return isConnected;
          }
        });
        var appDidLoad = who => {
          nextTick$1(() => emitEvent(win, "appload", {
            detail: {
              namespace: NAMESPACE$1
            }
          }));
        };
        var safeCall = (instance, method, arg, elm) => {
          if (instance && instance[method]) {
            try {
              return instance[method](arg);
            } catch (e) {
              consoleError(e, elm);
            }
          }
          return void 0;
        };
        var addHydratedFlag = elm => {
          var _a;
          return elm.classList.add((_a = BUILD.hydratedSelectorName) != null ? _a : "hydrated");
        };
        var getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
        var setValue = (ref, propName, newVal, cmpMeta) => {
          const hostRef = getHostRef(ref);
          if (!hostRef) {
            return;
          }
          const elm = ref;
          const oldVal = hostRef.$instanceValues$.get(propName);
          const flags = hostRef.$flags$;
          const instance = elm;
          newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
          const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
          const didValueChange = newVal !== oldVal && !areBothNaN;
          if (didValueChange) {
            hostRef.$instanceValues$.set(propName, newVal);
            {
              if (cmpMeta.$watchers$ && flags & 128) {
                const watchMethods = cmpMeta.$watchers$[propName];
                if (watchMethods) {
                  watchMethods.map(watchMethodName => {
                    try {
                      instance[watchMethodName](newVal, oldVal, propName);
                    } catch (e) {
                      consoleError(e, elm);
                    }
                  });
                }
              }
              if ((flags & (2 | 16)) === 2) {
                if (instance.componentShouldUpdate) {
                  if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
                    return;
                  }
                }
                scheduleUpdate(hostRef, false);
              }
            }
          }
        };
        var proxyComponent = (Cstr, cmpMeta, flags) => {
          var _a, _b;
          const prototype = Cstr.prototype;
          if (cmpMeta.$members$ || cmpMeta.$watchers$ || Cstr.watchers) {
            if (Cstr.watchers && !cmpMeta.$watchers$) {
              cmpMeta.$watchers$ = Cstr.watchers;
            }
            const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});
            members.map(([memberName, [memberFlags]]) => {
              if (memberFlags & 31 || memberFlags & 32) {
                const {
                  get: origGetter,
                  set: origSetter
                } = Object.getOwnPropertyDescriptor(prototype, memberName) || {};
                if (origGetter) cmpMeta.$members$[memberName][0] |= 2048;
                if (origSetter) cmpMeta.$members$[memberName][0] |= 4096;
                {
                  Object.defineProperty(prototype, memberName, {
                    get() {
                      {
                        return origGetter ? origGetter.apply(this) : getValue(this, memberName);
                      }
                    },
                    configurable: true,
                    enumerable: true
                  });
                }
                Object.defineProperty(prototype, memberName, {
                  set(newValue) {
                    const ref = getHostRef(this);
                    if (!ref) {
                      return;
                    }
                    if (origSetter) {
                      const currentValue = memberFlags & 32 ? this[memberName] : ref.$hostElement$[memberName];
                      if (typeof currentValue === "undefined" && ref.$instanceValues$.get(memberName)) {
                        newValue = ref.$instanceValues$.get(memberName);
                      } else if (!ref.$instanceValues$.get(memberName) && currentValue) {
                        ref.$instanceValues$.set(memberName, currentValue);
                      }
                      origSetter.apply(this, [parsePropertyValue(newValue, memberFlags)]);
                      newValue = memberFlags & 32 ? this[memberName] : ref.$hostElement$[memberName];
                      setValue(this, memberName, newValue, cmpMeta);
                      return;
                    }
                    {
                      setValue(this, memberName, newValue, cmpMeta);
                      return;
                    }
                  }
                });
              }
            });
            {
              const attrNameToPropName = /* @__PURE__ */new Map();
              prototype.attributeChangedCallback = function (attrName, oldValue, newValue) {
                plt.jmp(() => {
                  var _a2;
                  const propName = attrNameToPropName.get(attrName);
                  if (this.hasOwnProperty(propName) && BUILD.lazyLoad) ;else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" &&
                  // cast type to number to avoid TS compiler issues
                  this[propName] == newValue) {
                    return;
                  } else if (propName == null) {
                    const hostRef = getHostRef(this);
                    const flags2 = hostRef == null ? void 0 : hostRef.$flags$;
                    if (hostRef && flags2 && !(flags2 & 8) && flags2 & 128 && newValue !== oldValue) {
                      const elm = this;
                      const instance = elm;
                      const entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];
                      entry == null ? void 0 : entry.forEach(callbackName => {
                        if (instance[callbackName] != null) {
                          instance[callbackName].call(instance, newValue, oldValue, attrName);
                        }
                      });
                    }
                    return;
                  }
                  const propDesc = Object.getOwnPropertyDescriptor(prototype, propName);
                  newValue = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
                  if (newValue !== this[propName] && (!propDesc.get || !!propDesc.set)) {
                    this[propName] = newValue;
                  }
                });
              };
              Cstr.observedAttributes = Array.from(/* @__PURE__ */new Set([...Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {}), ...members.filter(([_, m]) => m[0] & 15
              /* HasAttribute */).map(([propName, m]) => {
                var _a2;
                const attrName = m[1] || propName;
                attrNameToPropName.set(attrName, propName);
                if (m[0] & 512) {
                  (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);
                }
                return attrName;
              })]));
            }
          }
          return Cstr;
        };
        var initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {
          let Cstr;
          if ((hostRef.$flags$ & 32) === 0) {
            hostRef.$flags$ |= 32;
            cmpMeta.$lazyBundleId$;
            {
              Cstr = elm.constructor;
              const cmpTag = elm.localName;
              customElements.whenDefined(cmpTag).then(() => hostRef.$flags$ |= 128
              /* isWatchReady */);
            }
            if (Cstr && Cstr.style) {
              let style;
              if (typeof Cstr.style === "string") {
                style = Cstr.style;
              } else if (typeof Cstr.style !== "string") {
                hostRef.$modeName$ = computeMode(elm);
                if (hostRef.$modeName$) {
                  style = Cstr.style[hostRef.$modeName$];
                }
              }
              const scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);
              if (!styles.has(scopeId2)) {
                const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
                registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
                endRegisterStyles();
              }
            }
          }
          const ancestorComponent = hostRef.$ancestorComponent$;
          const schedule = () => scheduleUpdate(hostRef, true);
          if (ancestorComponent && ancestorComponent["s-rc"]) {
            ancestorComponent["s-rc"].push(schedule);
          } else {
            schedule();
          }
        };
        var fireConnectedCallback = (instance, elm) => {};
        var connectedCallback = elm => {
          if ((plt.$flags$ & 1) === 0) {
            const hostRef = getHostRef(elm);
            if (!hostRef) {
              return;
            }
            const cmpMeta = hostRef.$cmpMeta$;
            const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
            if (!(hostRef.$flags$ & 1)) {
              hostRef.$flags$ |= 1;
              {
                if (
                // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
                cmpMeta.$flags$ & (4 | 8)) {
                  setContentReference(elm);
                }
              }
              {
                let ancestorComponent = elm;
                while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
                  if (ancestorComponent["s-p"]) {
                    attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
                    break;
                  }
                }
              }
              if (cmpMeta.$members$) {
                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
                  if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
                    const value = elm[memberName];
                    delete elm[memberName];
                    elm[memberName] = value;
                  }
                });
              }
              {
                initializeComponent(elm, hostRef, cmpMeta);
              }
            } else {
              addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
              if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {
                fireConnectedCallback(hostRef.$lazyInstance$);
              } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {
                hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$));
              }
            }
            endConnected();
          }
        };
        var setContentReference = elm => {
          if (!win.document) {
            return;
          }
          const contentRefElm = elm["s-cr"] = win.document.createComment("");
          contentRefElm["s-cn"] = true;
          insertBefore(elm, contentRefElm, elm.firstChild);
        };
        var disconnectedCallback = async elm => {
          if ((plt.$flags$ & 1) === 0) {
            const hostRef = getHostRef(elm);
            {
              if (hostRef == null ? void 0 : hostRef.$rmListeners$) {
                hostRef.$rmListeners$.map(rmListener => rmListener());
                hostRef.$rmListeners$ = void 0;
              }
            }
          }
          if (rootAppliedStyles.has(elm)) {
            rootAppliedStyles.delete(elm);
          }
          if (elm.shadowRoot && rootAppliedStyles.has(elm.shadowRoot)) {
            rootAppliedStyles.delete(elm.shadowRoot);
          }
        };
        var proxyCustomElement = exports("p", (Cstr, compactMeta) => {
          const cmpMeta = {
            $flags$: compactMeta[0],
            $tagName$: compactMeta[1]
          };
          {
            cmpMeta.$members$ = compactMeta[2];
          }
          {
            cmpMeta.$listeners$ = compactMeta[3];
          }
          {
            cmpMeta.$watchers$ = Cstr.$watchers$;
          }
          {
            cmpMeta.$attrsToReflect$ = [];
          }
          if (!(cmpMeta.$flags$ & 1) && cmpMeta.$flags$ & 256) ;
          const originalConnectedCallback = Cstr.prototype.connectedCallback;
          const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
          Object.assign(Cstr.prototype, {
            __hasHostListenerAttached: false,
            __registerHost() {
              registerHost(this, cmpMeta);
            },
            connectedCallback() {
              if (!this.__hasHostListenerAttached) {
                const hostRef = getHostRef(this);
                if (!hostRef) {
                  return;
                }
                addHostEventListeners(this, hostRef, cmpMeta.$listeners$);
                this.__hasHostListenerAttached = true;
              }
              connectedCallback(this);
              if (originalConnectedCallback) {
                originalConnectedCallback.call(this);
              }
            },
            disconnectedCallback() {
              disconnectedCallback(this);
              if (originalDisconnectedCallback) {
                originalDisconnectedCallback.call(this);
              }
            },
            __attachShadow() {
              {
                if (!this.shadowRoot) {
                  createShadowRoot.call(this, cmpMeta);
                } else {
                  if (this.shadowRoot.mode !== "open") {
                    throw new Error(`Unable to re-use existing shadow root for ${cmpMeta.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`);
                  }
                }
              }
            }
          });
          Cstr.is = cmpMeta.$tagName$;
          return proxyComponent(Cstr, cmpMeta);
        });
        var addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
          if (listeners && win.document) {
            listeners.map(([flags, name, method]) => {
              const target = getHostListenerTarget(win.document, elm, flags);
              const handler = hostListenerProxy(hostRef, method);
              const opts = hostListenerOpts(flags);
              plt.ael(target, name, handler, opts);
              (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
            });
          }
        };
        var hostListenerProxy = (hostRef, methodName) => ev => {
          var _a;
          try {
            if (BUILD.lazyLoad) ;else {
              hostRef.$hostElement$[methodName](ev);
            }
          } catch (e) {
            consoleError(e, hostRef.$hostElement$);
          }
        };
        var getHostListenerTarget = (doc, elm, flags) => {
          if (flags & 4) {
            return doc;
          }
          if (flags & 8) {
            return win;
          }
          if (flags & 16) {
            return doc.body;
          }
          return elm;
        };
        var hostListenerOpts = flags => (flags & 2) !== 0;
        var isCheckBoxInput = element => element.type === 'checkbox';
        var isDateObject = value => value instanceof Date;
        var isNullOrUndefined = value => value == null;
        const isObjectType = value => typeof value === 'object';
        var isObject$5 = value => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
        var getEventValue = event => isObject$5(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
        var getNodeParentName = name => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
        var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
        var isPlainObject$4 = tempObject => {
          const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
          return isObject$5(prototypeCopy) && prototypeCopy.hasOwnProperty('isPrototypeOf');
        };
        var isWeb = typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined' && typeof document !== 'undefined';
        function cloneObject(data) {
          let copy;
          const isArray = Array.isArray(data);
          const isFileListInstance = typeof FileList !== 'undefined' ? data instanceof FileList : false;
          if (data instanceof Date) {
            copy = new Date(data);
          } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray || isObject$5(data))) {
            copy = isArray ? [] : Object.create(Object.getPrototypeOf(data));
            if (!isArray && !isPlainObject$4(data)) {
              copy = data;
            } else {
              for (const key in data) {
                if (data.hasOwnProperty(key)) {
                  copy[key] = cloneObject(data[key]);
                }
              }
            }
          } else {
            return data;
          }
          return copy;
        }
        var isKey = value => /^\w*$/.test(value);
        var isUndefined$1 = val => val === undefined;
        var compact = value => Array.isArray(value) ? value.filter(Boolean) : [];
        var stringToPath = input => compact(input.replace(/["|']|\]/g, '').split(/\.|\[/));
        var get$2 = (object, path, defaultValue) => {
          if (!path || !isObject$5(object)) {
            return defaultValue;
          }
          const result = (isKey(path) ? [path] : stringToPath(path)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], object);
          return isUndefined$1(result) || result === object ? isUndefined$1(object[path]) ? defaultValue : object[path] : result;
        };
        var isBoolean$1 = value => typeof value === 'boolean';
        var set$2 = (object, path, value) => {
          let index = -1;
          const tempPath = isKey(path) ? [path] : stringToPath(path);
          const length = tempPath.length;
          const lastIndex = length - 1;
          while (++index < length) {
            const key = tempPath[index];
            let newValue = value;
            if (index !== lastIndex) {
              const objValue = object[key];
              newValue = isObject$5(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};
            }
            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
              return;
            }
            object[key] = newValue;
            object = object[key];
          }
        };
        const EVENTS = {
          BLUR: 'blur',
          FOCUS_OUT: 'focusout',
          CHANGE: 'change'
        };
        const VALIDATION_MODE = {
          onBlur: 'onBlur',
          onChange: 'onChange',
          onSubmit: 'onSubmit',
          onTouched: 'onTouched',
          all: 'all'
        };
        const INPUT_VALIDATION_RULES = {
          max: 'max',
          min: 'min',
          maxLength: 'maxLength',
          minLength: 'minLength',
          pattern: 'pattern',
          required: 'required',
          validate: 'validate'
        };
        const HookFormContext = React.createContext(null);
        HookFormContext.displayName = 'HookFormContext';
        /**
         * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.
         *
         * @remarks
         * [API](https://react-hook-form.com/docs/useformcontext)  [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
         *
         * @returns return all useForm methods
         *
         * @example
         * ```tsx
         * function App() {
         *   const methods = useForm();
         *   const onSubmit = data => console.log(data);
         *
         *   return (
         *     <FormProvider {...methods} >
         *       <form onSubmit={methods.handleSubmit(onSubmit)}>
         *         <NestedInput />
         *         <input type="submit" />
         *       </form>
         *     </FormProvider>
         *   );
         * }
         *
         *  function NestedInput() {
         *   const { register } = useFormContext(); // retrieve all hook methods
         *   return <input {...register("test")} />;
         * }
         * ```
         */
        const useFormContext = () => React.useContext(HookFormContext);
        var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
          const result = {
            defaultValues: control._defaultValues
          };
          for (const key in formState) {
            Object.defineProperty(result, key, {
              get: () => {
                const _key = key;
                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
                  control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
                }
                localProxyFormState && (localProxyFormState[_key] = true);
                return formState[_key];
              }
            });
          }
          return result;
        };
        const useIsomorphicLayoutEffect$2 = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;

        /**
         * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.
         *
         * @remarks
         * [API](https://react-hook-form.com/docs/useformstate)  [Demo](https://codesandbox.io/s/useformstate-75xly)
         *
         * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}
         *
         * @example
         * ```tsx
         * function App() {
         *   const { register, handleSubmit, control } = useForm({
         *     defaultValues: {
         *     firstName: "firstName"
         *   }});
         *   const { dirtyFields } = useFormState({
         *     control
         *   });
         *   const onSubmit = (data) => console.log(data);
         *
         *   return (
         *     <form onSubmit={handleSubmit(onSubmit)}>
         *       <input {...register("firstName")} placeholder="First Name" />
         *       {dirtyFields.firstName && <p>Field is dirty.</p>}
         *       <input type="submit" />
         *     </form>
         *   );
         * }
         * ```
         */
        function useFormState(props) {
          const methods = useFormContext();
          const {
            control = methods.control,
            disabled,
            name,
            exact
          } = props || {};
          const [formState, updateFormState] = React.useState(control._formState);
          const _localProxyFormState = React.useRef({
            isDirty: false,
            isLoading: false,
            dirtyFields: false,
            touchedFields: false,
            validatingFields: false,
            isValidating: false,
            isValid: false,
            errors: false
          });
          useIsomorphicLayoutEffect$2(() => control._subscribe({
            name,
            formState: _localProxyFormState.current,
            exact,
            callback: formState => {
              !disabled && updateFormState({
                ...control._formState,
                ...formState
              });
            }
          }), [name, disabled, exact]);
          React.useEffect(() => {
            _localProxyFormState.current.isValid && control._setValid(true);
          }, [control]);
          return React.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
        }
        var isString = value => typeof value === 'string';
        var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
          if (isString(names)) {
            isGlobal && _names.watch.add(names);
            return get$2(formValues, names, defaultValue);
          }
          if (Array.isArray(names)) {
            return names.map(fieldName => (isGlobal && _names.watch.add(fieldName), get$2(formValues, fieldName)));
          }
          isGlobal && (_names.watchAll = true);
          return formValues;
        };
        var isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);
        function deepEqual$1(object1, object2, _internal_visited = new WeakSet()) {
          if (isPrimitive(object1) || isPrimitive(object2)) {
            return object1 === object2;
          }
          if (isDateObject(object1) && isDateObject(object2)) {
            return object1.getTime() === object2.getTime();
          }
          const keys1 = Object.keys(object1);
          const keys2 = Object.keys(object2);
          if (keys1.length !== keys2.length) {
            return false;
          }
          if (_internal_visited.has(object1) || _internal_visited.has(object2)) {
            return true;
          }
          _internal_visited.add(object1);
          _internal_visited.add(object2);
          for (const key of keys1) {
            const val1 = object1[key];
            if (!keys2.includes(key)) {
              return false;
            }
            if (key !== 'ref') {
              const val2 = object2[key];
              if (isDateObject(val1) && isDateObject(val2) || isObject$5(val1) && isObject$5(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual$1(val1, val2, _internal_visited) : val1 !== val2) {
                return false;
              }
            }
          }
          return true;
        }

        /**
         * Custom hook to subscribe to field change and isolate re-rendering at the component level.
         *
         * @remarks
         *
         * [API](https://react-hook-form.com/docs/usewatch)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
         *
         * @example
         * ```tsx
         * const { control } = useForm();
         * const values = useWatch({
         *   name: "fieldName"
         *   control,
         * })
         * ```
         */
        function useWatch(props) {
          const methods = useFormContext();
          const {
            control = methods.control,
            name,
            defaultValue,
            disabled,
            exact,
            compute
          } = props || {};
          const _defaultValue = React.useRef(defaultValue);
          const _compute = React.useRef(compute);
          const _computeFormValues = React.useRef(undefined);
          _compute.current = compute;
          const defaultValueMemo = React.useMemo(() => control._getWatch(name, _defaultValue.current), [control, name]);
          const [value, updateValue] = React.useState(_compute.current ? _compute.current(defaultValueMemo) : defaultValueMemo);
          useIsomorphicLayoutEffect$2(() => control._subscribe({
            name,
            formState: {
              values: true
            },
            exact,
            callback: formState => {
              if (!disabled) {
                const formValues = generateWatchOutput(name, control._names, formState.values || control._formValues, false, _defaultValue.current);
                if (_compute.current) {
                  const computedFormValues = _compute.current(formValues);
                  if (!deepEqual$1(computedFormValues, _computeFormValues.current)) {
                    updateValue(computedFormValues);
                    _computeFormValues.current = computedFormValues;
                  }
                } else {
                  updateValue(formValues);
                }
              }
            }
          }), [control, disabled, name, exact]);
          React.useEffect(() => control._removeUnmounted());
          return value;
        }

        /**
         * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.
         *
         * @remarks
         * [API](https://react-hook-form.com/docs/usecontroller)  [Demo](https://codesandbox.io/s/usecontroller-0o8px)
         *
         * @param props - the path name to the form field value, and validation rules.
         *
         * @returns field properties, field and form state. {@link UseControllerReturn}
         *
         * @example
         * ```tsx
         * function Input(props) {
         *   const { field, fieldState, formState } = useController(props);
         *   return (
         *     <div>
         *       <input {...field} placeholder={props.name} />
         *       <p>{fieldState.isTouched && "Touched"}</p>
         *       <p>{formState.isSubmitted ? "submitted" : ""}</p>
         *     </div>
         *   );
         * }
         * ```
         */
        function useController(props) {
          const methods = useFormContext();
          const {
            name,
            disabled,
            control = methods.control,
            shouldUnregister,
            defaultValue
          } = props;
          const isArrayField = isNameInFieldArray(control._names.array, name);
          const defaultValueMemo = React.useMemo(() => get$2(control._formValues, name, get$2(control._defaultValues, name, defaultValue)), [control, name, defaultValue]);
          const value = useWatch({
            control,
            name,
            defaultValue: defaultValueMemo,
            exact: true
          });
          const formState = useFormState({
            control,
            name,
            exact: true
          });
          const _props = React.useRef(props);
          const _registerProps = React.useRef(control.register(name, {
            ...props.rules,
            value,
            ...(isBoolean$1(props.disabled) ? {
              disabled: props.disabled
            } : {})
          }));
          _props.current = props;
          const fieldState = React.useMemo(() => Object.defineProperties({}, {
            invalid: {
              enumerable: true,
              get: () => !!get$2(formState.errors, name)
            },
            isDirty: {
              enumerable: true,
              get: () => !!get$2(formState.dirtyFields, name)
            },
            isTouched: {
              enumerable: true,
              get: () => !!get$2(formState.touchedFields, name)
            },
            isValidating: {
              enumerable: true,
              get: () => !!get$2(formState.validatingFields, name)
            },
            error: {
              enumerable: true,
              get: () => get$2(formState.errors, name)
            }
          }), [formState, name]);
          const onChange = React.useCallback(event => _registerProps.current.onChange({
            target: {
              value: getEventValue(event),
              name: name
            },
            type: EVENTS.CHANGE
          }), [name]);
          const onBlur = React.useCallback(() => _registerProps.current.onBlur({
            target: {
              value: get$2(control._formValues, name),
              name: name
            },
            type: EVENTS.BLUR
          }), [name, control._formValues]);
          const ref = React.useCallback(elm => {
            const field = get$2(control._fields, name);
            if (field && elm) {
              field._f.ref = {
                focus: () => elm.focus && elm.focus(),
                select: () => elm.select && elm.select(),
                setCustomValidity: message => elm.setCustomValidity(message),
                reportValidity: () => elm.reportValidity()
              };
            }
          }, [control._fields, name]);
          const field = React.useMemo(() => ({
            name,
            value,
            ...(isBoolean$1(disabled) || formState.disabled ? {
              disabled: formState.disabled || disabled
            } : {}),
            onChange,
            onBlur,
            ref
          }), [name, disabled, formState.disabled, onChange, onBlur, ref, value]);
          React.useEffect(() => {
            const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
            control.register(name, {
              ..._props.current.rules,
              ...(isBoolean$1(_props.current.disabled) ? {
                disabled: _props.current.disabled
              } : {})
            });
            const updateMounted = (name, value) => {
              const field = get$2(control._fields, name);
              if (field && field._f) {
                field._f.mount = value;
              }
            };
            updateMounted(name, true);
            if (_shouldUnregisterField) {
              const value = cloneObject(get$2(control._options.defaultValues, name));
              set$2(control._defaultValues, name, value);
              if (isUndefined$1(get$2(control._formValues, name))) {
                set$2(control._formValues, name, value);
              }
            }
            !isArrayField && control.register(name);
            return () => {
              (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
            };
          }, [name, control, isArrayField, shouldUnregister]);
          React.useEffect(() => {
            control._setDisabledField({
              disabled,
              name
            });
          }, [disabled, name, control]);
          return React.useMemo(() => ({
            field,
            formState,
            fieldState
          }), [field, formState, fieldState]);
        }

        /**
         * Component based on `useController` hook to work with controlled component.
         *
         * @remarks
         * [API](https://react-hook-form.com/docs/usecontroller/controller)  [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw)  [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)
         *
         * @param props - the path name to the form field value, and validation rules.
         *
         * @returns provide field handler functions, field and form state.
         *
         * @example
         * ```tsx
         * function App() {
         *   const { control } = useForm<FormValues>({
         *     defaultValues: {
         *       test: ""
         *     }
         *   });
         *
         *   return (
         *     <form>
         *       <Controller
         *         control={control}
         *         name="test"
         *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (
         *           <>
         *             <input
         *               onChange={onChange} // send value to hook form
         *               onBlur={onBlur} // notify when input is touched
         *               value={value} // return updated value
         *               ref={ref} // set ref for focus management
         *             />
         *             <p>{formState.isSubmitted ? "submitted" : ""}</p>
         *             <p>{fieldState.isTouched ? "touched" : ""}</p>
         *           </>
         *         )}
         *       />
         *     </form>
         *   );
         * }
         * ```
         */
        const Controller$1 = exports("a3", props => props.render(useController(props)));
        var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? {
          ...errors[name],
          types: {
            ...(errors[name] && errors[name].types ? errors[name].types : {}),
            [type]: message || true
          }
        } : {};
        var convertToArrayPayload = value => Array.isArray(value) ? value : [value];
        var createSubject = () => {
          let _observers = [];
          const next = value => {
            for (const observer of _observers) {
              observer.next && observer.next(value);
            }
          };
          const subscribe = observer => {
            _observers.push(observer);
            return {
              unsubscribe: () => {
                _observers = _observers.filter(o => o !== observer);
              }
            };
          };
          const unsubscribe = () => {
            _observers = [];
          };
          return {
            get observers() {
              return _observers;
            },
            next,
            subscribe,
            unsubscribe
          };
        };
        var isEmptyObject = value => isObject$5(value) && !Object.keys(value).length;
        var isFileInput = element => element.type === 'file';
        var isFunction$2 = value => typeof value === 'function';
        var isHTMLElement = value => {
          if (!isWeb) {
            return false;
          }
          const owner = value ? value.ownerDocument : 0;
          return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
        };
        var isMultipleSelect = element => element.type === `select-multiple`;
        var isRadioInput = element => element.type === 'radio';
        var isRadioOrCheckbox = ref => isRadioInput(ref) || isCheckBoxInput(ref);
        var live = ref => isHTMLElement(ref) && ref.isConnected;
        function baseGet(object, updatePath) {
          const length = updatePath.slice(0, -1).length;
          let index = 0;
          while (index < length) {
            object = isUndefined$1(object) ? index++ : object[updatePath[index++]];
          }
          return object;
        }
        function isEmptyArray(obj) {
          for (const key in obj) {
            if (obj.hasOwnProperty(key) && !isUndefined$1(obj[key])) {
              return false;
            }
          }
          return true;
        }
        function unset(object, path) {
          const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
          const childObject = paths.length === 1 ? object : baseGet(object, paths);
          const index = paths.length - 1;
          const key = paths[index];
          if (childObject) {
            delete childObject[key];
          }
          if (index !== 0 && (isObject$5(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
            unset(object, paths.slice(0, -1));
          }
          return object;
        }
        var objectHasFunction = data => {
          for (const key in data) {
            if (isFunction$2(data[key])) {
              return true;
            }
          }
          return false;
        };
        function markFieldsDirty(data, fields = {}) {
          const isParentNodeArray = Array.isArray(data);
          if (isObject$5(data) || isParentNodeArray) {
            for (const key in data) {
              if (Array.isArray(data[key]) || isObject$5(data[key]) && !objectHasFunction(data[key])) {
                fields[key] = Array.isArray(data[key]) ? [] : {};
                markFieldsDirty(data[key], fields[key]);
              } else if (!isNullOrUndefined(data[key])) {
                fields[key] = true;
              }
            }
          }
          return fields;
        }
        function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
          const isParentNodeArray = Array.isArray(data);
          if (isObject$5(data) || isParentNodeArray) {
            for (const key in data) {
              if (Array.isArray(data[key]) || isObject$5(data[key]) && !objectHasFunction(data[key])) {
                if (isUndefined$1(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
                  dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : {
                    ...markFieldsDirty(data[key])
                  };
                } else {
                  getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
                }
              } else {
                dirtyFieldsFromValues[key] = !deepEqual$1(data[key], formValues[key]);
              }
            }
          }
          return dirtyFieldsFromValues;
        }
        var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
        const defaultResult = {
          value: false,
          isValid: false
        };
        const validResult = {
          value: true,
          isValid: true
        };
        var getCheckboxValue = options => {
          if (Array.isArray(options)) {
            if (options.length > 1) {
              const values = options.filter(option => option && option.checked && !option.disabled).map(option => option.value);
              return {
                value: values,
                isValid: !!values.length
              };
            }
            return options[0].checked && !options[0].disabled ?
            // @ts-expect-error expected to work in the browser
            options[0].attributes && !isUndefined$1(options[0].attributes.value) ? isUndefined$1(options[0].value) || options[0].value === '' ? validResult : {
              value: options[0].value,
              isValid: true
            } : validResult : defaultResult;
          }
          return defaultResult;
        };
        var getFieldValueAs = (value, {
          valueAsNumber,
          valueAsDate,
          setValueAs
        }) => isUndefined$1(value) ? value : valueAsNumber ? value === '' ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
        const defaultReturn = {
          isValid: false,
          value: null
        };
        var getRadioValue = options => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
          isValid: true,
          value: option.value
        } : previous, defaultReturn) : defaultReturn;
        function getFieldValue(_f) {
          const ref = _f.ref;
          if (isFileInput(ref)) {
            return ref.files;
          }
          if (isRadioInput(ref)) {
            return getRadioValue(_f.refs).value;
          }
          if (isMultipleSelect(ref)) {
            return [...ref.selectedOptions].map(({
              value
            }) => value);
          }
          if (isCheckBoxInput(ref)) {
            return getCheckboxValue(_f.refs).value;
          }
          return getFieldValueAs(isUndefined$1(ref.value) ? _f.ref.value : ref.value, _f);
        }
        var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
          const fields = {};
          for (const name of fieldsNames) {
            const field = get$2(_fields, name);
            field && set$2(fields, name, field._f);
          }
          return {
            criteriaMode,
            names: [...fieldsNames],
            fields,
            shouldUseNativeValidation
          };
        };
        var isRegex = value => value instanceof RegExp;
        var getRuleValue = rule => isUndefined$1(rule) ? rule : isRegex(rule) ? rule.source : isObject$5(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
        var getValidationModes = mode => ({
          isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
          isOnBlur: mode === VALIDATION_MODE.onBlur,
          isOnChange: mode === VALIDATION_MODE.onChange,
          isOnAll: mode === VALIDATION_MODE.all,
          isOnTouch: mode === VALIDATION_MODE.onTouched
        });
        const ASYNC_FUNCTION = 'AsyncFunction';
        var hasPromiseValidation = fieldReference => !!fieldReference && !!fieldReference.validate && !!(isFunction$2(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject$5(fieldReference.validate) && Object.values(fieldReference.validate).find(validateFunction => validateFunction.constructor.name === ASYNC_FUNCTION));
        var hasValidation = options => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
        var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some(watchName => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
        const iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
          for (const key of fieldsNames || Object.keys(fields)) {
            const field = get$2(fields, key);
            if (field) {
              const {
                _f,
                ...currentField
              } = field;
              if (_f) {
                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
                  return true;
                } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
                  return true;
                } else {
                  if (iterateFieldsByAction(currentField, action)) {
                    break;
                  }
                }
              } else if (isObject$5(currentField)) {
                if (iterateFieldsByAction(currentField, action)) {
                  break;
                }
              }
            }
          }
          return;
        };
        function schemaErrorLookup(errors, _fields, name) {
          const error = get$2(errors, name);
          if (error || isKey(name)) {
            return {
              error,
              name
            };
          }
          const names = name.split('.');
          while (names.length) {
            const fieldName = names.join('.');
            const field = get$2(_fields, fieldName);
            const foundError = get$2(errors, fieldName);
            if (field && !Array.isArray(field) && name !== fieldName) {
              return {
                name
              };
            }
            if (foundError && foundError.type) {
              return {
                name: fieldName,
                error: foundError
              };
            }
            if (foundError && foundError.root && foundError.root.type) {
              return {
                name: `${fieldName}.root`,
                error: foundError.root
              };
            }
            names.pop();
          }
          return {
            name
          };
        }
        var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
          updateFormState(formStateData);
          const {
            name,
            ...formState
          } = formStateData;
          return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find(key => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
        };
        var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some(currentName => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
        var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
          if (mode.isOnAll) {
            return false;
          } else if (!isSubmitted && mode.isOnTouch) {
            return !(isTouched || isBlurEvent);
          } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
            return !isBlurEvent;
          } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
            return isBlurEvent;
          }
          return true;
        };
        var unsetEmptyArray = (ref, name) => !compact(get$2(ref, name)).length && unset(ref, name);
        var updateFieldArrayRootError = (errors, error, name) => {
          const fieldArrayErrors = convertToArrayPayload(get$2(errors, name));
          set$2(fieldArrayErrors, 'root', error[name]);
          set$2(errors, name, fieldArrayErrors);
          return errors;
        };
        var isMessage = value => isString(value);
        function getValidateError(result, ref, type = 'validate') {
          if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean$1(result) && !result) {
            return {
              type,
              message: isMessage(result) ? result : '',
              ref
            };
          }
        }
        var getValueAndMessage = validationData => isObject$5(validationData) && !isRegex(validationData) ? validationData : {
          value: validationData,
          message: ''
        };
        var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
          const {
            ref,
            refs,
            required,
            maxLength,
            minLength,
            min,
            max,
            pattern,
            validate,
            name,
            valueAsNumber,
            mount
          } = field._f;
          const inputValue = get$2(formValues, name);
          if (!mount || disabledFieldNames.has(name)) {
            return {};
          }
          const inputRef = refs ? refs[0] : ref;
          const setCustomValidity = message => {
            if (shouldUseNativeValidation && inputRef.reportValidity) {
              inputRef.setCustomValidity(isBoolean$1(message) ? '' : message || '');
              inputRef.reportValidity();
            }
          };
          const error = {};
          const isRadio = isRadioInput(ref);
          const isCheckBox = isCheckBoxInput(ref);
          const isRadioOrCheckbox = isRadio || isCheckBox;
          const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined$1(ref.value) && isUndefined$1(inputValue) || isHTMLElement(ref) && ref.value === '' || inputValue === '' || Array.isArray(inputValue) && !inputValue.length;
          const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
          const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
            const message = exceedMax ? maxLengthMessage : minLengthMessage;
            error[name] = {
              type: exceedMax ? maxType : minType,
              message,
              ref,
              ...appendErrorsCurry(exceedMax ? maxType : minType, message)
            };
          };
          if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean$1(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
            const {
              value,
              message
            } = isMessage(required) ? {
              value: !!required,
              message: required
            } : getValueAndMessage(required);
            if (value) {
              error[name] = {
                type: INPUT_VALIDATION_RULES.required,
                message,
                ref: inputRef,
                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)
              };
              if (!validateAllFieldCriteria) {
                setCustomValidity(message);
                return error;
              }
            }
          }
          if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {
            let exceedMax;
            let exceedMin;
            const maxOutput = getValueAndMessage(max);
            const minOutput = getValueAndMessage(min);
            if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
              const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
              if (!isNullOrUndefined(maxOutput.value)) {
                exceedMax = valueNumber > maxOutput.value;
              }
              if (!isNullOrUndefined(minOutput.value)) {
                exceedMin = valueNumber < minOutput.value;
              }
            } else {
              const valueDate = ref.valueAsDate || new Date(inputValue);
              const convertTimeToDate = time => new Date(new Date().toDateString() + ' ' + time);
              const isTime = ref.type == 'time';
              const isWeek = ref.type == 'week';
              if (isString(maxOutput.value) && inputValue) {
                exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
              }
              if (isString(minOutput.value) && inputValue) {
                exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
              }
            }
            if (exceedMax || exceedMin) {
              getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
              if (!validateAllFieldCriteria) {
                setCustomValidity(error[name].message);
                return error;
              }
            }
          }
          if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
            const maxLengthOutput = getValueAndMessage(maxLength);
            const minLengthOutput = getValueAndMessage(minLength);
            const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
            const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
            if (exceedMax || exceedMin) {
              getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
              if (!validateAllFieldCriteria) {
                setCustomValidity(error[name].message);
                return error;
              }
            }
          }
          if (pattern && !isEmpty && isString(inputValue)) {
            const {
              value: patternValue,
              message
            } = getValueAndMessage(pattern);
            if (isRegex(patternValue) && !inputValue.match(patternValue)) {
              error[name] = {
                type: INPUT_VALIDATION_RULES.pattern,
                message,
                ref,
                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)
              };
              if (!validateAllFieldCriteria) {
                setCustomValidity(message);
                return error;
              }
            }
          }
          if (validate) {
            if (isFunction$2(validate)) {
              const result = await validate(inputValue, formValues);
              const validateError = getValidateError(result, inputRef);
              if (validateError) {
                error[name] = {
                  ...validateError,
                  ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
                };
                if (!validateAllFieldCriteria) {
                  setCustomValidity(validateError.message);
                  return error;
                }
              }
            } else if (isObject$5(validate)) {
              let validationResult = {};
              for (const key in validate) {
                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
                  break;
                }
                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
                if (validateError) {
                  validationResult = {
                    ...validateError,
                    ...appendErrorsCurry(key, validateError.message)
                  };
                  setCustomValidity(validateError.message);
                  if (validateAllFieldCriteria) {
                    error[name] = validationResult;
                  }
                }
              }
              if (!isEmptyObject(validationResult)) {
                error[name] = {
                  ref: inputRef,
                  ...validationResult
                };
                if (!validateAllFieldCriteria) {
                  return error;
                }
              }
            }
          }
          setCustomValidity(true);
          return error;
        };
        const defaultOptions$1 = {
          mode: VALIDATION_MODE.onSubmit,
          reValidateMode: VALIDATION_MODE.onChange,
          shouldFocusError: true
        };
        function createFormControl(props = {}) {
          let _options = {
            ...defaultOptions$1,
            ...props
          };
          let _formState = {
            submitCount: 0,
            isDirty: false,
            isReady: false,
            isLoading: isFunction$2(_options.defaultValues),
            isValidating: false,
            isSubmitted: false,
            isSubmitting: false,
            isSubmitSuccessful: false,
            isValid: false,
            touchedFields: {},
            dirtyFields: {},
            validatingFields: {},
            errors: _options.errors || {},
            disabled: _options.disabled || false
          };
          let _fields = {};
          let _defaultValues = isObject$5(_options.defaultValues) || isObject$5(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
          let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
          let _state = {
            action: false,
            mount: false,
            watch: false
          };
          let _names = {
            mount: new Set(),
            disabled: new Set(),
            unMount: new Set(),
            array: new Set(),
            watch: new Set()
          };
          let delayErrorCallback;
          let timer = 0;
          const _proxyFormState = {
            isDirty: false,
            dirtyFields: false,
            validatingFields: false,
            touchedFields: false,
            isValidating: false,
            isValid: false,
            errors: false
          };
          let _proxySubscribeFormState = {
            ..._proxyFormState
          };
          const _subjects = {
            array: createSubject(),
            state: createSubject()
          };
          const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
          const debounce = callback => wait => {
            clearTimeout(timer);
            timer = setTimeout(callback, wait);
          };
          const _setValid = async shouldUpdateValid => {
            if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {
              const isValid = _options.resolver ? isEmptyObject((await _runSchema()).errors) : await executeBuiltInValidation(_fields, true);
              if (isValid !== _formState.isValid) {
                _subjects.state.next({
                  isValid
                });
              }
            }
          };
          const _updateIsValidating = (names, isValidating) => {
            if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {
              (names || Array.from(_names.mount)).forEach(name => {
                if (name) {
                  isValidating ? set$2(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
                }
              });
              _subjects.state.next({
                validatingFields: _formState.validatingFields,
                isValidating: !isEmptyObject(_formState.validatingFields)
              });
            }
          };
          const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
            if (args && method && !_options.disabled) {
              _state.action = true;
              if (shouldUpdateFieldsAndState && Array.isArray(get$2(_fields, name))) {
                const fieldValues = method(get$2(_fields, name), args.argA, args.argB);
                shouldSetValues && set$2(_fields, name, fieldValues);
              }
              if (shouldUpdateFieldsAndState && Array.isArray(get$2(_formState.errors, name))) {
                const errors = method(get$2(_formState.errors, name), args.argA, args.argB);
                shouldSetValues && set$2(_formState.errors, name, errors);
                unsetEmptyArray(_formState.errors, name);
              }
              if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get$2(_formState.touchedFields, name))) {
                const touchedFields = method(get$2(_formState.touchedFields, name), args.argA, args.argB);
                shouldSetValues && set$2(_formState.touchedFields, name, touchedFields);
              }
              if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {
                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
              }
              _subjects.state.next({
                name,
                isDirty: _getDirty(name, values),
                dirtyFields: _formState.dirtyFields,
                errors: _formState.errors,
                isValid: _formState.isValid
              });
            } else {
              set$2(_formValues, name, values);
            }
          };
          const updateErrors = (name, error) => {
            set$2(_formState.errors, name, error);
            _subjects.state.next({
              errors: _formState.errors
            });
          };
          const _setErrors = errors => {
            _formState.errors = errors;
            _subjects.state.next({
              errors: _formState.errors,
              isValid: false
            });
          };
          const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
            const field = get$2(_fields, name);
            if (field) {
              const defaultValue = get$2(_formValues, name, isUndefined$1(value) ? get$2(_defaultValues, name) : value);
              isUndefined$1(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set$2(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
              _state.mount && _setValid();
            }
          };
          const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
            let shouldUpdateField = false;
            let isPreviousDirty = false;
            const output = {
              name
            };
            if (!_options.disabled) {
              if (!isBlurEvent || shouldDirty) {
                if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {
                  isPreviousDirty = _formState.isDirty;
                  _formState.isDirty = output.isDirty = _getDirty();
                  shouldUpdateField = isPreviousDirty !== output.isDirty;
                }
                const isCurrentFieldPristine = deepEqual$1(get$2(_defaultValues, name), fieldValue);
                isPreviousDirty = !!get$2(_formState.dirtyFields, name);
                isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set$2(_formState.dirtyFields, name, true);
                output.dirtyFields = _formState.dirtyFields;
                shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;
              }
              if (isBlurEvent) {
                const isPreviousFieldTouched = get$2(_formState.touchedFields, name);
                if (!isPreviousFieldTouched) {
                  set$2(_formState.touchedFields, name, isBlurEvent);
                  output.touchedFields = _formState.touchedFields;
                  shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;
                }
              }
              shouldUpdateField && shouldRender && _subjects.state.next(output);
            }
            return shouldUpdateField ? output : {};
          };
          const shouldRenderByError = (name, isValid, error, fieldState) => {
            const previousFieldError = get$2(_formState.errors, name);
            const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean$1(isValid) && _formState.isValid !== isValid;
            if (_options.delayError && error) {
              delayErrorCallback = debounce(() => updateErrors(name, error));
              delayErrorCallback(_options.delayError);
            } else {
              clearTimeout(timer);
              delayErrorCallback = null;
              error ? set$2(_formState.errors, name, error) : unset(_formState.errors, name);
            }
            if ((error ? !deepEqual$1(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
              const updatedFormState = {
                ...fieldState,
                ...(shouldUpdateValid && isBoolean$1(isValid) ? {
                  isValid
                } : {}),
                errors: _formState.errors,
                name
              };
              _formState = {
                ..._formState,
                ...updatedFormState
              };
              _subjects.state.next(updatedFormState);
            }
          };
          const _runSchema = async name => {
            _updateIsValidating(name, true);
            const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
            _updateIsValidating(name);
            return result;
          };
          const executeSchemaAndUpdateState = async names => {
            const {
              errors
            } = await _runSchema(names);
            if (names) {
              for (const name of names) {
                const error = get$2(errors, name);
                error ? set$2(_formState.errors, name, error) : unset(_formState.errors, name);
              }
            } else {
              _formState.errors = errors;
            }
            return errors;
          };
          const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
            valid: true
          }) => {
            for (const name in fields) {
              const field = fields[name];
              if (field) {
                const {
                  _f,
                  ...fieldValue
                } = field;
                if (_f) {
                  const isFieldArrayRoot = _names.array.has(_f.name);
                  const isPromiseFunction = field._f && hasPromiseValidation(field._f);
                  if (isPromiseFunction && _proxyFormState.validatingFields) {
                    _updateIsValidating([name], true);
                  }
                  const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
                  if (isPromiseFunction && _proxyFormState.validatingFields) {
                    _updateIsValidating([name]);
                  }
                  if (fieldError[_f.name]) {
                    context.valid = false;
                    if (shouldOnlyCheckValid) {
                      break;
                    }
                  }
                  !shouldOnlyCheckValid && (get$2(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set$2(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
                }
                !isEmptyObject(fieldValue) && (await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context));
              }
            }
            return context.valid;
          };
          const _removeUnmounted = () => {
            for (const name of _names.unMount) {
              const field = get$2(_fields, name);
              field && (field._f.refs ? field._f.refs.every(ref => !live(ref)) : !live(field._f.ref)) && unregister(name);
            }
            _names.unMount = new Set();
          };
          const _getDirty = (name, data) => !_options.disabled && (name && data && set$2(_formValues, name, data), !deepEqual$1(getValues(), _defaultValues));
          const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
            ...(_state.mount ? _formValues : isUndefined$1(defaultValue) ? _defaultValues : isString(names) ? {
              [names]: defaultValue
            } : defaultValue)
          }, isGlobal, defaultValue);
          const _getFieldArray = name => compact(get$2(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get$2(_defaultValues, name, []) : []));
          const setFieldValue = (name, value, options = {}) => {
            const field = get$2(_fields, name);
            let fieldValue = value;
            if (field) {
              const fieldReference = field._f;
              if (fieldReference) {
                !fieldReference.disabled && set$2(_formValues, name, getFieldValueAs(value, fieldReference));
                fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value) ? '' : value;
                if (isMultipleSelect(fieldReference.ref)) {
                  [...fieldReference.ref.options].forEach(optionRef => optionRef.selected = fieldValue.includes(optionRef.value));
                } else if (fieldReference.refs) {
                  if (isCheckBoxInput(fieldReference.ref)) {
                    fieldReference.refs.forEach(checkboxRef => {
                      if (!checkboxRef.defaultChecked || !checkboxRef.disabled) {
                        if (Array.isArray(fieldValue)) {
                          checkboxRef.checked = !!fieldValue.find(data => data === checkboxRef.value);
                        } else {
                          checkboxRef.checked = fieldValue === checkboxRef.value || !!fieldValue;
                        }
                      }
                    });
                  } else {
                    fieldReference.refs.forEach(radioRef => radioRef.checked = radioRef.value === fieldValue);
                  }
                } else if (isFileInput(fieldReference.ref)) {
                  fieldReference.ref.value = '';
                } else {
                  fieldReference.ref.value = fieldValue;
                  if (!fieldReference.ref.type) {
                    _subjects.state.next({
                      name,
                      values: cloneObject(_formValues)
                    });
                  }
                }
              }
            }
            (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
            options.shouldValidate && trigger(name);
          };
          const setValues = (name, value, options) => {
            for (const fieldKey in value) {
              if (!value.hasOwnProperty(fieldKey)) {
                return;
              }
              const fieldValue = value[fieldKey];
              const fieldName = name + '.' + fieldKey;
              const field = get$2(_fields, fieldName);
              (_names.array.has(name) || isObject$5(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
            }
          };
          const setValue = (name, value, options = {}) => {
            const field = get$2(_fields, name);
            const isFieldArray = _names.array.has(name);
            const cloneValue = cloneObject(value);
            set$2(_formValues, name, cloneValue);
            if (isFieldArray) {
              _subjects.array.next({
                name,
                values: cloneObject(_formValues)
              });
              if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options.shouldDirty) {
                _subjects.state.next({
                  name,
                  dirtyFields: getDirtyFields(_defaultValues, _formValues),
                  isDirty: _getDirty(name, cloneValue)
                });
              }
            } else {
              field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
            }
            isWatched(name, _names) && _subjects.state.next({
              ..._formState,
              name
            });
            _subjects.state.next({
              name: _state.mount ? name : undefined,
              values: cloneObject(_formValues)
            });
          };
          const onChange = async event => {
            _state.mount = true;
            const target = event.target;
            let name = target.name;
            let isFieldValueUpdated = true;
            const field = get$2(_fields, name);
            const _updateIsFieldValueUpdated = fieldValue => {
              isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual$1(fieldValue, get$2(_formValues, name, fieldValue));
            };
            const validationModeBeforeSubmit = getValidationModes(_options.mode);
            const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
            if (field) {
              let error;
              let isValid;
              const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);
              const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
              const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get$2(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get$2(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
              const watched = isWatched(name, _names, isBlurEvent);
              set$2(_formValues, name, fieldValue);
              if (isBlurEvent) {
                if (!target || !target.readOnly) {
                  field._f.onBlur && field._f.onBlur(event);
                  delayErrorCallback && delayErrorCallback(0);
                }
              } else if (field._f.onChange) {
                field._f.onChange(event);
              }
              const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);
              const shouldRender = !isEmptyObject(fieldState) || watched;
              !isBlurEvent && _subjects.state.next({
                name,
                type: event.type,
                values: cloneObject(_formValues)
              });
              if (shouldSkipValidation) {
                if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
                  if (_options.mode === 'onBlur') {
                    if (isBlurEvent) {
                      _setValid();
                    }
                  } else if (!isBlurEvent) {
                    _setValid();
                  }
                }
                return shouldRender && _subjects.state.next({
                  name,
                  ...(watched ? {} : fieldState)
                });
              }
              !isBlurEvent && watched && _subjects.state.next({
                ..._formState
              });
              if (_options.resolver) {
                const {
                  errors
                } = await _runSchema([name]);
                _updateIsFieldValueUpdated(fieldValue);
                if (isFieldValueUpdated) {
                  const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
                  const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
                  error = errorLookupResult.error;
                  name = errorLookupResult.name;
                  isValid = isEmptyObject(errors);
                }
              } else {
                _updateIsValidating([name], true);
                error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
                _updateIsValidating([name]);
                _updateIsFieldValueUpdated(fieldValue);
                if (isFieldValueUpdated) {
                  if (error) {
                    isValid = false;
                  } else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
                    isValid = await executeBuiltInValidation(_fields, true);
                  }
                }
              }
              if (isFieldValueUpdated) {
                field._f.deps && trigger(field._f.deps);
                shouldRenderByError(name, isValid, error, fieldState);
              }
            }
          };
          const _focusInput = (ref, key) => {
            if (get$2(_formState.errors, key) && ref.focus) {
              ref.focus();
              return 1;
            }
            return;
          };
          const trigger = async (name, options = {}) => {
            let isValid;
            let validationResult;
            const fieldNames = convertToArrayPayload(name);
            if (_options.resolver) {
              const errors = await executeSchemaAndUpdateState(isUndefined$1(name) ? name : fieldNames);
              isValid = isEmptyObject(errors);
              validationResult = name ? !fieldNames.some(name => get$2(errors, name)) : isValid;
            } else if (name) {
              validationResult = (await Promise.all(fieldNames.map(async fieldName => {
                const field = get$2(_fields, fieldName);
                return await executeBuiltInValidation(field && field._f ? {
                  [fieldName]: field
                } : field);
              }))).every(Boolean);
              !(!validationResult && !_formState.isValid) && _setValid();
            } else {
              validationResult = isValid = await executeBuiltInValidation(_fields);
            }
            _subjects.state.next({
              ...(!isString(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid !== _formState.isValid ? {} : {
                name
              }),
              ...(_options.resolver || !name ? {
                isValid
              } : {}),
              errors: _formState.errors
            });
            options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
            return validationResult;
          };
          const getValues = fieldNames => {
            const values = {
              ...(_state.mount ? _formValues : _defaultValues)
            };
            return isUndefined$1(fieldNames) ? values : isString(fieldNames) ? get$2(values, fieldNames) : fieldNames.map(name => get$2(values, name));
          };
          const getFieldState = (name, formState) => ({
            invalid: !!get$2((formState || _formState).errors, name),
            isDirty: !!get$2((formState || _formState).dirtyFields, name),
            error: get$2((formState || _formState).errors, name),
            isValidating: !!get$2(_formState.validatingFields, name),
            isTouched: !!get$2((formState || _formState).touchedFields, name)
          });
          const clearErrors = name => {
            name && convertToArrayPayload(name).forEach(inputName => unset(_formState.errors, inputName));
            _subjects.state.next({
              errors: name ? _formState.errors : {}
            });
          };
          const setError = (name, error, options) => {
            const ref = (get$2(_fields, name, {
              _f: {}
            })._f || {}).ref;
            const currentError = get$2(_formState.errors, name) || {};
            // Don't override existing error messages elsewhere in the object tree.
            const {
              ref: currentRef,
              message,
              type,
              ...restOfErrorTree
            } = currentError;
            set$2(_formState.errors, name, {
              ...restOfErrorTree,
              ...error,
              ref
            });
            _subjects.state.next({
              name,
              errors: _formState.errors,
              isValid: false
            });
            options && options.shouldFocus && ref && ref.focus && ref.focus();
          };
          const watch = (name, defaultValue) => isFunction$2(name) ? _subjects.state.subscribe({
            next: payload => 'values' in payload && name(_getWatch(undefined, defaultValue), payload)
          }) : _getWatch(name, defaultValue, true);
          const _subscribe = props => _subjects.state.subscribe({
            next: formState => {
              if (shouldSubscribeByName(props.name, formState.name, props.exact) && shouldRenderFormState(formState, props.formState || _proxyFormState, _setFormState, props.reRenderRoot)) {
                props.callback({
                  values: {
                    ..._formValues
                  },
                  ..._formState,
                  ...formState,
                  defaultValues: _defaultValues
                });
              }
            }
          }).unsubscribe;
          const subscribe = props => {
            _state.mount = true;
            _proxySubscribeFormState = {
              ..._proxySubscribeFormState,
              ...props.formState
            };
            return _subscribe({
              ...props,
              formState: _proxySubscribeFormState
            });
          };
          const unregister = (name, options = {}) => {
            for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
              _names.mount.delete(fieldName);
              _names.array.delete(fieldName);
              if (!options.keepValue) {
                unset(_fields, fieldName);
                unset(_formValues, fieldName);
              }
              !options.keepError && unset(_formState.errors, fieldName);
              !options.keepDirty && unset(_formState.dirtyFields, fieldName);
              !options.keepTouched && unset(_formState.touchedFields, fieldName);
              !options.keepIsValidating && unset(_formState.validatingFields, fieldName);
              !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
            }
            _subjects.state.next({
              values: cloneObject(_formValues)
            });
            _subjects.state.next({
              ..._formState,
              ...(!options.keepDirty ? {} : {
                isDirty: _getDirty()
              })
            });
            !options.keepIsValid && _setValid();
          };
          const _setDisabledField = ({
            disabled,
            name
          }) => {
            if (isBoolean$1(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {
              disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
            }
          };
          const register = (name, options = {}) => {
            let field = get$2(_fields, name);
            const disabledIsDefined = isBoolean$1(options.disabled) || isBoolean$1(_options.disabled);
            set$2(_fields, name, {
              ...(field || {}),
              _f: {
                ...(field && field._f ? field._f : {
                  ref: {
                    name
                  }
                }),
                name,
                mount: true,
                ...options
              }
            });
            _names.mount.add(name);
            if (field) {
              _setDisabledField({
                disabled: isBoolean$1(options.disabled) ? options.disabled : _options.disabled,
                name
              });
            } else {
              updateValidAndValue(name, true, options.value);
            }
            return {
              ...(disabledIsDefined ? {
                disabled: options.disabled || _options.disabled
              } : {}),
              ...(_options.progressive ? {
                required: !!options.required,
                min: getRuleValue(options.min),
                max: getRuleValue(options.max),
                minLength: getRuleValue(options.minLength),
                maxLength: getRuleValue(options.maxLength),
                pattern: getRuleValue(options.pattern)
              } : {}),
              name,
              onChange,
              onBlur: onChange,
              ref: ref => {
                if (ref) {
                  register(name, options);
                  field = get$2(_fields, name);
                  const fieldRef = isUndefined$1(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll('input,select,textarea')[0] || ref : ref : ref;
                  const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
                  const refs = field._f.refs || [];
                  if (radioOrCheckbox ? refs.find(option => option === fieldRef) : fieldRef === field._f.ref) {
                    return;
                  }
                  set$2(_fields, name, {
                    _f: {
                      ...field._f,
                      ...(radioOrCheckbox ? {
                        refs: [...refs.filter(live), fieldRef, ...(Array.isArray(get$2(_defaultValues, name)) ? [{}] : [])],
                        ref: {
                          type: fieldRef.type,
                          name
                        }
                      } : {
                        ref: fieldRef
                      })
                    }
                  });
                  updateValidAndValue(name, false, undefined, fieldRef);
                } else {
                  field = get$2(_fields, name, {});
                  if (field._f) {
                    field._f.mount = false;
                  }
                  (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
                }
              }
            };
          };
          const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
          const _disableForm = disabled => {
            if (isBoolean$1(disabled)) {
              _subjects.state.next({
                disabled
              });
              iterateFieldsByAction(_fields, (ref, name) => {
                const currentField = get$2(_fields, name);
                if (currentField) {
                  ref.disabled = currentField._f.disabled || disabled;
                  if (Array.isArray(currentField._f.refs)) {
                    currentField._f.refs.forEach(inputRef => {
                      inputRef.disabled = currentField._f.disabled || disabled;
                    });
                  }
                }
              }, 0, false);
            }
          };
          const handleSubmit = (onValid, onInvalid) => async e => {
            let onValidError = undefined;
            if (e) {
              e.preventDefault && e.preventDefault();
              e.persist && e.persist();
            }
            let fieldValues = cloneObject(_formValues);
            _subjects.state.next({
              isSubmitting: true
            });
            if (_options.resolver) {
              const {
                errors,
                values
              } = await _runSchema();
              _formState.errors = errors;
              fieldValues = cloneObject(values);
            } else {
              await executeBuiltInValidation(_fields);
            }
            if (_names.disabled.size) {
              for (const name of _names.disabled) {
                unset(fieldValues, name);
              }
            }
            unset(_formState.errors, 'root');
            if (isEmptyObject(_formState.errors)) {
              _subjects.state.next({
                errors: {}
              });
              try {
                await onValid(fieldValues, e);
              } catch (error) {
                onValidError = error;
              }
            } else {
              if (onInvalid) {
                await onInvalid({
                  ..._formState.errors
                }, e);
              }
              _focusError();
              setTimeout(_focusError);
            }
            _subjects.state.next({
              isSubmitted: true,
              isSubmitting: false,
              isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
              submitCount: _formState.submitCount + 1,
              errors: _formState.errors
            });
            if (onValidError) {
              throw onValidError;
            }
          };
          const resetField = (name, options = {}) => {
            if (get$2(_fields, name)) {
              if (isUndefined$1(options.defaultValue)) {
                setValue(name, cloneObject(get$2(_defaultValues, name)));
              } else {
                setValue(name, options.defaultValue);
                set$2(_defaultValues, name, cloneObject(options.defaultValue));
              }
              if (!options.keepTouched) {
                unset(_formState.touchedFields, name);
              }
              if (!options.keepDirty) {
                unset(_formState.dirtyFields, name);
                _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get$2(_defaultValues, name))) : _getDirty();
              }
              if (!options.keepError) {
                unset(_formState.errors, name);
                _proxyFormState.isValid && _setValid();
              }
              _subjects.state.next({
                ..._formState
              });
            }
          };
          const _reset = (formValues, keepStateOptions = {}) => {
            const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
            const cloneUpdatedValues = cloneObject(updatedValues);
            const isEmptyResetValues = isEmptyObject(formValues);
            const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
            if (!keepStateOptions.keepDefaultValues) {
              _defaultValues = updatedValues;
            }
            if (!keepStateOptions.keepValues) {
              if (keepStateOptions.keepDirtyValues) {
                const fieldsToCheck = new Set([..._names.mount, ...Object.keys(getDirtyFields(_defaultValues, _formValues))]);
                for (const fieldName of Array.from(fieldsToCheck)) {
                  get$2(_formState.dirtyFields, fieldName) ? set$2(values, fieldName, get$2(_formValues, fieldName)) : setValue(fieldName, get$2(values, fieldName));
                }
              } else {
                if (isWeb && isUndefined$1(formValues)) {
                  for (const name of _names.mount) {
                    const field = get$2(_fields, name);
                    if (field && field._f) {
                      const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
                      if (isHTMLElement(fieldReference)) {
                        const form = fieldReference.closest('form');
                        if (form) {
                          form.reset();
                          break;
                        }
                      }
                    }
                  }
                }
                if (keepStateOptions.keepFieldsRef) {
                  for (const fieldName of _names.mount) {
                    setValue(fieldName, get$2(values, fieldName));
                  }
                } else {
                  _fields = {};
                }
              }
              _formValues = _options.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);
              _subjects.array.next({
                values: {
                  ...values
                }
              });
              _subjects.state.next({
                values: {
                  ...values
                }
              });
            }
            _names = {
              mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),
              unMount: new Set(),
              array: new Set(),
              disabled: new Set(),
              watch: new Set(),
              watchAll: false,
              focus: ''
            };
            _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
            _state.watch = !!_options.shouldUnregister;
            _subjects.state.next({
              submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
              isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual$1(formValues, _defaultValues)),
              isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
              dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
              touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
              errors: keepStateOptions.keepErrors ? _formState.errors : {},
              isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
              isSubmitting: false,
              defaultValues: _defaultValues
            });
          };
          const reset = (formValues, keepStateOptions) => _reset(isFunction$2(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
          const setFocus = (name, options = {}) => {
            const field = get$2(_fields, name);
            const fieldReference = field && field._f;
            if (fieldReference) {
              const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
              if (fieldRef.focus) {
                fieldRef.focus();
                options.shouldSelect && isFunction$2(fieldRef.select) && fieldRef.select();
              }
            }
          };
          const _setFormState = updatedFormState => {
            _formState = {
              ..._formState,
              ...updatedFormState
            };
          };
          const _resetDefaultValues = () => isFunction$2(_options.defaultValues) && _options.defaultValues().then(values => {
            reset(values, _options.resetOptions);
            _subjects.state.next({
              isLoading: false
            });
          });
          const methods = {
            control: {
              register,
              unregister,
              getFieldState,
              handleSubmit,
              setError,
              _subscribe,
              _runSchema,
              _focusError,
              _getWatch,
              _getDirty,
              _setValid,
              _setFieldArray,
              _setDisabledField,
              _setErrors,
              _getFieldArray,
              _reset,
              _resetDefaultValues,
              _removeUnmounted,
              _disableForm,
              _subjects,
              _proxyFormState,
              get _fields() {
                return _fields;
              },
              get _formValues() {
                return _formValues;
              },
              get _state() {
                return _state;
              },
              set _state(value) {
                _state = value;
              },
              get _defaultValues() {
                return _defaultValues;
              },
              get _names() {
                return _names;
              },
              set _names(value) {
                _names = value;
              },
              get _formState() {
                return _formState;
              },
              get _options() {
                return _options;
              },
              set _options(value) {
                _options = {
                  ..._options,
                  ...value
                };
              }
            },
            subscribe,
            trigger,
            register,
            handleSubmit,
            watch,
            setValue,
            getValues,
            reset,
            resetField,
            clearErrors,
            unregister,
            setError,
            setFocus,
            getFieldState
          };
          return {
            ...methods,
            formControl: methods
          };
        }

        /**
         * Custom hook to manage the entire form.
         *
         * @remarks
         * [API](https://react-hook-form.com/docs/useform)  [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm)  [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)
         *
         * @param props - form configuration and validation parameters.
         *
         * @returns methods - individual functions to manage the form state. {@link UseFormReturn}
         *
         * @example
         * ```tsx
         * function App() {
         *   const { register, handleSubmit, watch, formState: { errors } } = useForm();
         *   const onSubmit = data => console.log(data);
         *
         *   console.log(watch("example"));
         *
         *   return (
         *     <form onSubmit={handleSubmit(onSubmit)}>
         *       <input defaultValue="test" {...register("example")} />
         *       <input {...register("exampleRequired", { required: true })} />
         *       {errors.exampleRequired && <span>This field is required</span>}
         *       <button>Submit</button>
         *     </form>
         *   );
         * }
         * ```
         */
        function useForm(props = {}) {
          const _formControl = React.useRef(undefined);
          const _values = React.useRef(undefined);
          const [formState, updateFormState] = React.useState({
            isDirty: false,
            isValidating: false,
            isLoading: isFunction$2(props.defaultValues),
            isSubmitted: false,
            isSubmitting: false,
            isSubmitSuccessful: false,
            isValid: false,
            submitCount: 0,
            dirtyFields: {},
            touchedFields: {},
            validatingFields: {},
            errors: props.errors || {},
            disabled: props.disabled || false,
            isReady: false,
            defaultValues: isFunction$2(props.defaultValues) ? undefined : props.defaultValues
          });
          if (!_formControl.current) {
            if (props.formControl) {
              _formControl.current = {
                ...props.formControl,
                formState
              };
              if (props.defaultValues && !isFunction$2(props.defaultValues)) {
                props.formControl.reset(props.defaultValues, props.resetOptions);
              }
            } else {
              const {
                formControl,
                ...rest
              } = createFormControl(props);
              _formControl.current = {
                ...rest,
                formState
              };
            }
          }
          const control = _formControl.current.control;
          control._options = props;
          useIsomorphicLayoutEffect$2(() => {
            const sub = control._subscribe({
              formState: control._proxyFormState,
              callback: () => updateFormState({
                ...control._formState
              }),
              reRenderRoot: true
            });
            updateFormState(data => ({
              ...data,
              isReady: true
            }));
            control._formState.isReady = true;
            return sub;
          }, [control]);
          React.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
          React.useEffect(() => {
            if (props.mode) {
              control._options.mode = props.mode;
            }
            if (props.reValidateMode) {
              control._options.reValidateMode = props.reValidateMode;
            }
          }, [control, props.mode, props.reValidateMode]);
          React.useEffect(() => {
            if (props.errors) {
              control._setErrors(props.errors);
              control._focusError();
            }
          }, [control, props.errors]);
          React.useEffect(() => {
            props.shouldUnregister && control._subjects.state.next({
              values: control._getWatch()
            });
          }, [control, props.shouldUnregister]);
          React.useEffect(() => {
            if (control._proxyFormState.isDirty) {
              const isDirty = control._getDirty();
              if (isDirty !== formState.isDirty) {
                control._subjects.state.next({
                  isDirty
                });
              }
            }
          }, [control, formState.isDirty]);
          React.useEffect(() => {
            if (props.values && !deepEqual$1(props.values, _values.current)) {
              control._reset(props.values, {
                keepFieldsRef: true,
                ...control._options.resetOptions
              });
              _values.current = props.values;
              updateFormState(state => ({
                ...state
              }));
            } else {
              control._resetDefaultValues();
            }
          }, [control, props.values]);
          React.useEffect(() => {
            if (!control._state.mount) {
              control._setValid();
              control._state.mount = true;
            }
            if (control._state.watch) {
              control._state.watch = false;
              control._subjects.state.next({
                ...control._formState
              });
            }
            control._removeUnmounted();
          });
          _formControl.current.formState = getProxyFormState(formState, control);
          return _formControl.current;
        }
        const s$1 = (e, s, o) => {
            if (e && "reportValidity" in e) {
              const r = get$2(o, s);
              e.setCustomValidity(r && r.message || ""), e.reportValidity();
            }
          },
          o$2 = (t, e) => {
            for (const o in e.fields) {
              const r = e.fields[o];
              r && r.ref && "reportValidity" in r.ref ? s$1(r.ref, o, t) : r.refs && r.refs.forEach(e => s$1(e, o, t));
            }
          },
          r$1 = (s, r) => {
            r.shouldUseNativeValidation && o$2(s, r);
            const f = {};
            for (const o in s) {
              const n = get$2(r.fields, o),
                a = Object.assign(s[o] || {}, {
                  ref: n && n.ref
                });
              if (i$2(r.names || Object.keys(s), o)) {
                const s = Object.assign({}, get$2(f, o));
                set$2(s, "root", a), set$2(f, o, s);
              } else set$2(f, o, a);
            }
            return f;
          },
          i$2 = (t, e) => t.some(t => t.startsWith(e + "."));
        function o$1(o2, n, a) {
          return void 0 === n && (n = {}), void 0 === a && (a = {}), function (s, i, c) {
            try {
              return Promise.resolve(function (t2, r2) {
                try {
                  var u = (n.context && false, Promise.resolve(o2["sync" === a.mode ? "validateSync" : "validate"](s, Object.assign({
                    abortEarly: false
                  }, n, {
                    context: i
                  }))).then(function (t3) {
                    return c.shouldUseNativeValidation && o$2({}, c), {
                      values: a.raw ? s : t3,
                      errors: {}
                    };
                  }));
                } catch (e2) {
                  return r2(e2);
                }
                return u && u.then ? u.then(void 0, r2) : u;
              }(0, function (e2) {
                if (!e2.inner) throw e2;
                return {
                  values: {},
                  errors: r$1((o3 = e2, n2 = !c.shouldUseNativeValidation && "all" === c.criteriaMode, (o3.inner || []).reduce(function (e3, t2) {
                    if (e3[t2.path] || (e3[t2.path] = {
                      message: t2.message,
                      type: t2.type
                    }), n2) {
                      var o4 = e3[t2.path].types,
                        a2 = o4 && o4[t2.type];
                      e3[t2.path] = appendErrors(t2.path, n2, e3, t2.type, a2 ? [].concat(a2, t2.message) : t2.message);
                    }
                    return e3;
                  }, {})), c)
                };
                var o3, n2;
              }));
            } catch (e2) {
              return Promise.reject(e2);
            }
          };
        }

        /**
         * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>
         */

        var propertyExpr;
        var hasRequiredPropertyExpr;
        function requirePropertyExpr() {
          if (hasRequiredPropertyExpr) return propertyExpr;
          hasRequiredPropertyExpr = 1;
          function Cache(maxSize) {
            this._maxSize = maxSize;
            this.clear();
          }
          Cache.prototype.clear = function () {
            this._size = 0;
            this._values = Object.create(null);
          };
          Cache.prototype.get = function (key) {
            return this._values[key];
          };
          Cache.prototype.set = function (key, value) {
            this._size >= this._maxSize && this.clear();
            if (!(key in this._values)) this._size++;
            return this._values[key] = value;
          };
          var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
            DIGIT_REGEX = /^\d+$/,
            LEAD_DIGIT_REGEX = /^\d/,
            SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
            CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/,
            MAX_CACHE_SIZE = 512;
          var pathCache = new Cache(MAX_CACHE_SIZE),
            setCache = new Cache(MAX_CACHE_SIZE),
            getCache = new Cache(MAX_CACHE_SIZE);
          propertyExpr = {
            Cache: Cache,
            split: split,
            normalizePath: normalizePath,
            setter: function (path) {
              var parts = normalizePath(path);
              return setCache.get(path) || setCache.set(path, function setter(obj, value) {
                var index = 0;
                var len = parts.length;
                var data = obj;
                while (index < len - 1) {
                  var part = parts[index];
                  if (part === '__proto__' || part === 'constructor' || part === 'prototype') {
                    return obj;
                  }
                  data = data[parts[index++]];
                }
                data[parts[index]] = value;
              });
            },
            getter: function (path, safe) {
              var parts = normalizePath(path);
              return getCache.get(path) || getCache.set(path, function getter(data) {
                var index = 0,
                  len = parts.length;
                while (index < len) {
                  if (data != null || !safe) data = data[parts[index++]];else return;
                }
                return data;
              });
            },
            join: function (segments) {
              return segments.reduce(function (path, part) {
                return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? '[' + part + ']' : (path ? '.' : '') + part);
              }, '');
            },
            forEach: function (path, cb, thisArg) {
              forEach(Array.isArray(path) ? path : split(path), cb, thisArg);
            }
          };
          function normalizePath(path) {
            return pathCache.get(path) || pathCache.set(path, split(path).map(function (part) {
              return part.replace(CLEAN_QUOTES_REGEX, '$2');
            }));
          }
          function split(path) {
            return path.match(SPLIT_REGEX) || [''];
          }
          function forEach(parts, iter, thisArg) {
            var len = parts.length,
              part,
              idx,
              isArray,
              isBracket;
            for (idx = 0; idx < len; idx++) {
              part = parts[idx];
              if (part) {
                if (shouldBeQuoted(part)) {
                  part = '"' + part + '"';
                }
                isBracket = isQuoted(part);
                isArray = !isBracket && /^\d+$/.test(part);
                iter.call(thisArg, part, isBracket, isArray, idx, parts);
              }
            }
          }
          function isQuoted(str) {
            return typeof str === 'string' && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
          }
          function hasLeadingNumber(part) {
            return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
          }
          function hasSpecialChars(part) {
            return SPEC_CHAR_REGEX.test(part);
          }
          function shouldBeQuoted(part) {
            return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
          }
          return propertyExpr;
        }
        var propertyExprExports = requirePropertyExpr();
        var tinyCase;
        var hasRequiredTinyCase;
        function requireTinyCase() {
          if (hasRequiredTinyCase) return tinyCase;
          hasRequiredTinyCase = 1;
          const reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
          const words = str => str.match(reWords) || [];
          const upperFirst = str => str[0].toUpperCase() + str.slice(1);
          const join = (str, d) => words(str).join(d).toLowerCase();
          const camelCase = str => words(str).reduce((acc, next) => `${acc}${!acc ? next.toLowerCase() : next[0].toUpperCase() + next.slice(1).toLowerCase()}`, '');
          const pascalCase = str => upperFirst(camelCase(str));
          const snakeCase = str => join(str, '_');
          const kebabCase = str => join(str, '-');
          const sentenceCase = str => upperFirst(join(str, ' '));
          const titleCase = str => words(str).map(upperFirst).join(' ');
          tinyCase = {
            words,
            upperFirst,
            camelCase,
            pascalCase,
            snakeCase,
            kebabCase,
            sentenceCase,
            titleCase
          };
          return tinyCase;
        }
        var tinyCaseExports = requireTinyCase();
        var toposort$1 = {
          exports: {}
        };
        var hasRequiredToposort;
        function requireToposort() {
          if (hasRequiredToposort) return toposort$1.exports;
          hasRequiredToposort = 1;
          /**
           * Topological sorting function
           *
           * @param {Array} edges
           * @returns {Array}
           */

          toposort$1.exports = function (edges) {
            return toposort(uniqueNodes(edges), edges);
          };
          toposort$1.exports.array = toposort;
          function toposort(nodes, edges) {
            var cursor = nodes.length,
              sorted = new Array(cursor),
              visited = {},
              i = cursor
              // Better data structures make algorithm much faster.
              ,
              outgoingEdges = makeOutgoingEdges(edges),
              nodesHash = makeNodesHash(nodes);

            // check for unknown nodes
            edges.forEach(function (edge) {
              if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
                throw new Error('Unknown node. There is an unknown node in the supplied edges.');
              }
            });
            while (i--) {
              if (!visited[i]) visit(nodes[i], i, new Set());
            }
            return sorted;
            function visit(node, i, predecessors) {
              if (predecessors.has(node)) {
                var nodeRep;
                try {
                  nodeRep = ", node was:" + JSON.stringify(node);
                } catch (e) {
                  nodeRep = "";
                }
                throw new Error('Cyclic dependency' + nodeRep);
              }
              if (!nodesHash.has(node)) {
                throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: ' + JSON.stringify(node));
              }
              if (visited[i]) return;
              visited[i] = true;
              var outgoing = outgoingEdges.get(node) || new Set();
              outgoing = Array.from(outgoing);
              if (i = outgoing.length) {
                predecessors.add(node);
                do {
                  var child = outgoing[--i];
                  visit(child, nodesHash.get(child), predecessors);
                } while (i);
                predecessors.delete(node);
              }
              sorted[--cursor] = node;
            }
          }
          function uniqueNodes(arr) {
            var res = new Set();
            for (var i = 0, len = arr.length; i < len; i++) {
              var edge = arr[i];
              res.add(edge[0]);
              res.add(edge[1]);
            }
            return Array.from(res);
          }
          function makeOutgoingEdges(arr) {
            var edges = new Map();
            for (var i = 0, len = arr.length; i < len; i++) {
              var edge = arr[i];
              if (!edges.has(edge[0])) edges.set(edge[0], new Set());
              if (!edges.has(edge[1])) edges.set(edge[1], new Set());
              edges.get(edge[0]).add(edge[1]);
            }
            return edges;
          }
          function makeNodesHash(arr) {
            var res = new Map();
            for (var i = 0, len = arr.length; i < len; i++) {
              res.set(arr[i], i);
            }
            return res;
          }
          return toposort$1.exports;
        }
        var toposortExports = requireToposort();
        const toposort = /*@__PURE__*/getDefaultExportFromCjs(toposortExports);
        const toString$1 = Object.prototype.toString;
        const errorToString = Error.prototype.toString;
        const regExpToString = RegExp.prototype.toString;
        const symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';
        const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
        function printNumber(val) {
          if (val != +val) return 'NaN';
          const isNegativeZero = val === 0 && 1 / val < 0;
          return isNegativeZero ? '-0' : '' + val;
        }
        function printSimpleValue(val, quoteStrings = false) {
          if (val == null || val === true || val === false) return '' + val;
          const typeOf = typeof val;
          if (typeOf === 'number') return printNumber(val);
          if (typeOf === 'string') return quoteStrings ? `"${val}"` : val;
          if (typeOf === 'function') return '[Function ' + (val.name || 'anonymous') + ']';
          if (typeOf === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
          const tag = toString$1.call(val).slice(8, -1);
          if (tag === 'Date') return isNaN(val.getTime()) ? '' + val : val.toISOString(val);
          if (tag === 'Error' || val instanceof Error) return '[' + errorToString.call(val) + ']';
          if (tag === 'RegExp') return regExpToString.call(val);
          return null;
        }
        function printValue(value, quoteStrings) {
          let result = printSimpleValue(value, quoteStrings);
          if (result !== null) return result;
          return JSON.stringify(value, function (key, value) {
            let result = printSimpleValue(this[key], quoteStrings);
            if (result !== null) return result;
            return value;
          }, 2);
        }
        function toArray$1(value) {
          return value == null ? [] : [].concat(value);
        }
        let _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;
        let strReg = /\$\{\s*(\w+)\s*\}/g;
        _Symbol$toStringTag = Symbol.toStringTag;
        class ValidationErrorNoStack {
          constructor(errorOrErrors, value, field, type) {
            this.name = void 0;
            this.message = void 0;
            this.value = void 0;
            this.path = void 0;
            this.type = void 0;
            this.params = void 0;
            this.errors = void 0;
            this.inner = void 0;
            this[_Symbol$toStringTag] = 'Error';
            this.name = 'ValidationError';
            this.value = value;
            this.path = field;
            this.type = type;
            this.errors = [];
            this.inner = [];
            toArray$1(errorOrErrors).forEach(err => {
              if (ValidationError.isError(err)) {
                this.errors.push(...err.errors);
                const innerErrors = err.inner.length ? err.inner : [err];
                this.inner.push(...innerErrors);
              } else {
                this.errors.push(err);
              }
            });
            this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
          }
        }
        _Symbol$hasInstance = Symbol.hasInstance;
        _Symbol$toStringTag2 = Symbol.toStringTag;
        class ValidationError extends Error {
          static formatError(message, params) {
            // Attempt to make the path more friendly for error message interpolation.
            const path = params.label || params.path || 'this';
            // Store the original path under `originalPath` so it isn't lost to custom
            // message functions; e.g., ones provided in `setLocale()` calls.
            params = Object.assign({}, params, {
              path,
              originalPath: params.path
            });
            if (typeof message === 'string') return message.replace(strReg, (_, key) => printValue(params[key]));
            if (typeof message === 'function') return message(params);
            return message;
          }
          static isError(err) {
            return err && err.name === 'ValidationError';
          }
          constructor(errorOrErrors, value, field, type, disableStack) {
            const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);
            if (disableStack) {
              return errorNoStack;
            }
            super();
            this.value = void 0;
            this.path = void 0;
            this.type = void 0;
            this.params = void 0;
            this.errors = [];
            this.inner = [];
            this[_Symbol$toStringTag2] = 'Error';
            this.name = errorNoStack.name;
            this.message = errorNoStack.message;
            this.type = errorNoStack.type;
            this.value = errorNoStack.value;
            this.path = errorNoStack.path;
            this.errors = errorNoStack.errors;
            this.inner = errorNoStack.inner;
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, ValidationError);
            }
          }
          static [_Symbol$hasInstance](inst) {
            return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);
          }
        }
        let mixed = {
          default: '${path} is invalid',
          required: '${path} is a required field',
          defined: '${path} must be defined',
          notNull: '${path} cannot be null',
          oneOf: '${path} must be one of the following values: ${values}',
          notOneOf: '${path} must not be one of the following values: ${values}',
          notType: ({
            path,
            type,
            value,
            originalValue
          }) => {
            const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : '.';
            return type !== 'mixed' ? `${path} must be a \`${type}\` type, ` + `but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path} must match the configured type. ` + `The validated value was: \`${printValue(value, true)}\`` + castMsg;
          }
        };
        let string = {
          length: '${path} must be exactly ${length} characters',
          min: '${path} must be at least ${min} characters',
          max: '${path} must be at most ${max} characters',
          matches: '${path} must match the following: "${regex}"',
          email: '${path} must be a valid email',
          url: '${path} must be a valid URL',
          uuid: '${path} must be a valid UUID',
          datetime: '${path} must be a valid ISO date-time',
          datetime_precision: '${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits',
          datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
          trim: '${path} must be a trimmed string',
          lowercase: '${path} must be a lowercase string',
          uppercase: '${path} must be a upper case string'
        };
        let number = {
          min: '${path} must be greater than or equal to ${min}',
          max: '${path} must be less than or equal to ${max}',
          lessThan: '${path} must be less than ${less}',
          moreThan: '${path} must be greater than ${more}',
          positive: '${path} must be a positive number',
          negative: '${path} must be a negative number',
          integer: '${path} must be an integer'
        };
        let date = {
          min: '${path} field must be later than ${min}',
          max: '${path} field must be at earlier than ${max}'
        };
        let boolean = {
          isValue: '${path} field must be ${value}'
        };
        let object = {
          noUnknown: '${path} field has unspecified keys: ${unknown}',
          exact: '${path} object contains unknown properties: ${properties}'
        };
        let array = {
          min: '${path} field must have at least ${min} items',
          max: '${path} field must have less than or equal to ${max} items',
          length: '${path} must have ${length} items'
        };
        let tuple = {
          notType: params => {
            const {
              path,
              value,
              spec
            } = params;
            const typeLen = spec.types.length;
            if (Array.isArray(value)) {
              if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
              if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
            }
            return ValidationError.formatError(mixed.notType, params);
          }
        };
        var locale = Object.assign(Object.create(null), {
          mixed,
          string,
          number,
          date,
          object,
          array,
          boolean,
          tuple
        });
        const isSchema = obj => obj && obj.__isYupSchema__;
        class Condition {
          static fromOptions(refs, config) {
            if (!config.then && !config.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');
            let {
              is,
              then,
              otherwise
            } = config;
            let check = typeof is === 'function' ? is : (...values) => values.every(value => value === is);
            return new Condition(refs, (values, schema) => {
              var _branch;
              let branch = check(...values) ? then : otherwise;
              return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
            });
          }
          constructor(refs, builder) {
            this.fn = void 0;
            this.refs = refs;
            this.refs = refs;
            this.fn = builder;
          }
          resolve(base, options) {
            let values = this.refs.map(ref =>
            // TODO: ? operator here?
            ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));
            let schema = this.fn(values, base, options);
            if (schema === undefined ||
            // @ts-ignore this can be base
            schema === base) {
              return base;
            }
            if (!isSchema(schema)) throw new TypeError('conditions must return a schema object');
            return schema.resolve(options);
          }
        }
        const prefixes = {
          context: '$',
          value: '.'
        };
        function create$9(key, options) {
          return new Reference(key, options);
        }
        class Reference {
          constructor(key, options = {}) {
            this.key = void 0;
            this.isContext = void 0;
            this.isValue = void 0;
            this.isSibling = void 0;
            this.path = void 0;
            this.getter = void 0;
            this.map = void 0;
            if (typeof key !== 'string') throw new TypeError('ref must be a string, got: ' + key);
            this.key = key.trim();
            if (key === '') throw new TypeError('ref must be a non-empty string');
            this.isContext = this.key[0] === prefixes.context;
            this.isValue = this.key[0] === prefixes.value;
            this.isSibling = !this.isContext && !this.isValue;
            let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : '';
            this.path = this.key.slice(prefix.length);
            this.getter = this.path && propertyExprExports.getter(this.path, true);
            this.map = options.map;
          }
          getValue(value, parent, context) {
            let result = this.isContext ? context : this.isValue ? value : parent;
            if (this.getter) result = this.getter(result || {});
            if (this.map) result = this.map(result);
            return result;
          }

          /**
           *
           * @param {*} value
           * @param {Object} options
           * @param {Object=} options.context
           * @param {Object=} options.parent
           */
          cast(value, options) {
            return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
          }
          resolve() {
            return this;
          }
          describe() {
            return {
              type: 'ref',
              key: this.key
            };
          }
          toString() {
            return `Ref(${this.key})`;
          }
          static isRef(value) {
            return value && value.__isYupRef;
          }
        }

        // @ts-ignore
        Reference.prototype.__isYupRef = true;
        const isAbsent = value => value == null;
        function createValidation(config) {
          function validate({
            value,
            path = '',
            options,
            originalValue,
            schema
          }, panic, next) {
            const {
              name,
              test,
              params,
              message,
              skipAbsent
            } = config;
            let {
              parent,
              context,
              abortEarly = schema.spec.abortEarly,
              disableStackTrace = schema.spec.disableStackTrace
            } = options;
            const resolveOptions = {
              value,
              parent,
              context
            };
            function createError(overrides = {}) {
              const nextParams = resolveParams(Object.assign({
                value,
                originalValue,
                label: schema.spec.label,
                path: overrides.path || path,
                spec: schema.spec,
                disableStackTrace: overrides.disableStackTrace || disableStackTrace
              }, params, overrides.params), resolveOptions);
              const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);
              error.params = nextParams;
              return error;
            }
            const invalid = abortEarly ? panic : next;
            let ctx = {
              path,
              parent,
              type: name,
              from: options.from,
              createError,
              resolve(item) {
                return resolveMaybeRef(item, resolveOptions);
              },
              options,
              originalValue,
              schema
            };
            const handleResult = validOrError => {
              if (ValidationError.isError(validOrError)) invalid(validOrError);else if (!validOrError) invalid(createError());else next(null);
            };
            const handleError = err => {
              if (ValidationError.isError(err)) invalid(err);else panic(err);
            };
            const shouldSkip = skipAbsent && isAbsent(value);
            if (shouldSkip) {
              return handleResult(true);
            }
            let result;
            try {
              var _result;
              result = test.call(ctx, value, ctx);
              if (typeof ((_result = result) == null ? void 0 : _result.then) === 'function') {
                if (options.sync) {
                  throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. ` + `This test will finish after the validate call has returned`);
                }
                return Promise.resolve(result).then(handleResult, handleError);
              }
            } catch (err) {
              handleError(err);
              return;
            }
            handleResult(result);
          }
          validate.OPTIONS = config;
          return validate;
        }

        // Warning: mutates the input
        function resolveParams(params, options) {
          if (!params) return params;
          for (const key of Object.keys(params)) {
            params[key] = resolveMaybeRef(params[key], options);
          }
          return params;
        }
        function resolveMaybeRef(item, options) {
          return Reference.isRef(item) ? item.getValue(options.value, options.parent, options.context) : item;
        }
        function getIn$2(schema, path, value, context = value) {
          let parent, lastPart, lastPartDebug;

          // root path: ''
          if (!path) return {
            parent,
            parentPath: path,
            schema
          };
          propertyExprExports.forEach(path, (_part, isBracket, isArray) => {
            let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
            schema = schema.resolve({
              context,
              parent,
              value
            });
            let isTuple = schema.type === 'tuple';
            let idx = isArray ? parseInt(part, 10) : 0;
            if (schema.innerType || isTuple) {
              if (isTuple && !isArray) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
              if (value && idx >= value.length) {
                throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);
              }
              parent = value;
              value = value && value[idx];
              schema = isTuple ? schema.spec.types[idx] : schema.innerType;
            }

            // sometimes the array index part of a path doesn't exist: "nested.arr.child"
            // in these cases the current part is the next schema and should be processed
            // in this iteration. For cases where the index signature is included this
            // check will fail and we'll handle the `child` part on the next iteration like normal
            if (!isArray) {
              if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
              parent = value;
              value = value && value[part];
              schema = schema.fields[part];
            }
            lastPart = part;
            lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;
          });
          return {
            schema,
            parent,
            parentPath: lastPart
          };
        }
        function reach(obj, path, value, context) {
          return getIn$2(obj, path, value, context).schema;
        }
        class ReferenceSet extends Set {
          describe() {
            const description = [];
            for (const item of this.values()) {
              description.push(Reference.isRef(item) ? item.describe() : item);
            }
            return description;
          }
          resolveAll(resolve) {
            let result = [];
            for (const item of this.values()) {
              result.push(resolve(item));
            }
            return result;
          }
          clone() {
            return new ReferenceSet(this.values());
          }
          merge(newItems, removeItems) {
            const next = this.clone();
            newItems.forEach(value => next.add(value));
            removeItems.forEach(value => next.delete(value));
            return next;
          }
        }

        // tweaked from https://github.com/Kelin2025/nanoclone/blob/0abeb7635bda9b68ef2277093f76dbe3bf3948e1/src/index.js
        function clone(src, seen = new Map()) {
          if (isSchema(src) || !src || typeof src !== 'object') return src;
          if (seen.has(src)) return seen.get(src);
          let copy;
          if (src instanceof Date) {
            // Date
            copy = new Date(src.getTime());
            seen.set(src, copy);
          } else if (src instanceof RegExp) {
            // RegExp
            copy = new RegExp(src);
            seen.set(src, copy);
          } else if (Array.isArray(src)) {
            // Array
            copy = new Array(src.length);
            seen.set(src, copy);
            for (let i = 0; i < src.length; i++) copy[i] = clone(src[i], seen);
          } else if (src instanceof Map) {
            // Map
            copy = new Map();
            seen.set(src, copy);
            for (const [k, v] of src.entries()) copy.set(k, clone(v, seen));
          } else if (src instanceof Set) {
            // Set
            copy = new Set();
            seen.set(src, copy);
            for (const v of src) copy.add(clone(v, seen));
          } else if (src instanceof Object) {
            // Object
            copy = {};
            seen.set(src, copy);
            for (const [k, v] of Object.entries(src)) copy[k] = clone(v, seen);
          } else {
            throw Error(`Unable to clone ${src}`);
          }
          return copy;
        }

        /**
         * Copied from @standard-schema/spec to avoid having a dependency on it.
         * https://github.com/standard-schema/standard-schema/blob/main/packages/spec/src/index.ts
         */

        function createStandardPath(path) {
          if (!(path != null && path.length)) {
            return undefined;
          }

          // Array to store the final path segments
          const segments = [];
          // Buffer for building the current segment
          let currentSegment = '';
          // Track if we're inside square brackets (array/property access)
          let inBrackets = false;
          // Track if we're inside quotes (for property names with special chars)
          let inQuotes = false;
          for (let i = 0; i < path.length; i++) {
            const char = path[i];
            if (char === '[' && !inQuotes) {
              // When entering brackets, push any accumulated segment after splitting on dots
              if (currentSegment) {
                segments.push(...currentSegment.split('.').filter(Boolean));
                currentSegment = '';
              }
              inBrackets = true;
              continue;
            }
            if (char === ']' && !inQuotes) {
              if (currentSegment) {
                // Handle numeric indices (e.g. arr[0])
                if (/^\d+$/.test(currentSegment)) {
                  segments.push(currentSegment);
                } else {
                  // Handle quoted property names (e.g. obj["foo.bar"])
                  segments.push(currentSegment.replace(/^"|"$/g, ''));
                }
                currentSegment = '';
              }
              inBrackets = false;
              continue;
            }
            if (char === '"') {
              // Toggle quote state for handling quoted property names
              inQuotes = !inQuotes;
              continue;
            }
            if (char === '.' && !inBrackets && !inQuotes) {
              // On dots outside brackets/quotes, push current segment
              if (currentSegment) {
                segments.push(currentSegment);
                currentSegment = '';
              }
              continue;
            }
            currentSegment += char;
          }

          // Push any remaining segment after splitting on dots
          if (currentSegment) {
            segments.push(...currentSegment.split('.').filter(Boolean));
          }
          return segments;
        }
        function createStandardIssues(error, parentPath) {
          const path = parentPath ? `${parentPath}.${error.path}` : error.path;
          return error.errors.map(err => ({
            message: err,
            path: createStandardPath(path)
          }));
        }
        function issuesFromValidationError(error, parentPath) {
          var _error$inner;
          if (!((_error$inner = error.inner) != null && _error$inner.length) && error.errors.length) {
            return createStandardIssues(error, parentPath);
          }
          const path = parentPath ? `${parentPath}.${error.path}` : error.path;
          return error.inner.flatMap(err => issuesFromValidationError(err, path));
        }

        // If `CustomSchemaMeta` isn't extended with any keys, we'll fall back to a
        // loose Record definition allowing free form usage.
        class Schema {
          constructor(options) {
            this.type = void 0;
            this.deps = [];
            this.tests = void 0;
            this.transforms = void 0;
            this.conditions = [];
            this._mutate = void 0;
            this.internalTests = {};
            this._whitelist = new ReferenceSet();
            this._blacklist = new ReferenceSet();
            this.exclusiveTests = Object.create(null);
            this._typeCheck = void 0;
            this.spec = void 0;
            this.tests = [];
            this.transforms = [];
            this.withMutation(() => {
              this.typeError(mixed.notType);
            });
            this.type = options.type;
            this._typeCheck = options.check;
            this.spec = Object.assign({
              strip: false,
              strict: false,
              abortEarly: true,
              recursive: true,
              disableStackTrace: false,
              nullable: false,
              optional: true,
              coerce: true
            }, options == null ? void 0 : options.spec);
            this.withMutation(s => {
              s.nonNullable();
            });
          }

          // TODO: remove
          get _type() {
            return this.type;
          }
          clone(spec) {
            if (this._mutate) {
              if (spec) Object.assign(this.spec, spec);
              return this;
            }

            // if the nested value is a schema we can skip cloning, since
            // they are already immutable
            const next = Object.create(Object.getPrototypeOf(this));

            // @ts-expect-error this is readonly
            next.type = this.type;
            next._typeCheck = this._typeCheck;
            next._whitelist = this._whitelist.clone();
            next._blacklist = this._blacklist.clone();
            next.internalTests = Object.assign({}, this.internalTests);
            next.exclusiveTests = Object.assign({}, this.exclusiveTests);

            // @ts-expect-error this is readonly
            next.deps = [...this.deps];
            next.conditions = [...this.conditions];
            next.tests = [...this.tests];
            next.transforms = [...this.transforms];
            next.spec = clone(Object.assign({}, this.spec, spec));
            return next;
          }
          label(label) {
            let next = this.clone();
            next.spec.label = label;
            return next;
          }
          meta(...args) {
            if (args.length === 0) return this.spec.meta;
            let next = this.clone();
            next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
            return next;
          }
          withMutation(fn) {
            let before = this._mutate;
            this._mutate = true;
            let result = fn(this);
            this._mutate = before;
            return result;
          }
          concat(schema) {
            if (!schema || schema === this) return this;
            if (schema.type !== this.type && this.type !== 'mixed') throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
            let base = this;
            let combined = schema.clone();
            const mergedSpec = Object.assign({}, base.spec, combined.spec);
            combined.spec = mergedSpec;
            combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);

            // manually merge the blacklist/whitelist (the other `schema` takes
            // precedence in case of conflicts)
            combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
            combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);

            // start with the current tests
            combined.tests = base.tests;
            combined.exclusiveTests = base.exclusiveTests;

            // manually add the new tests to ensure
            // the deduping logic is consistent
            combined.withMutation(next => {
              schema.tests.forEach(fn => {
                next.test(fn.OPTIONS);
              });
            });
            combined.transforms = [...base.transforms, ...combined.transforms];
            return combined;
          }
          isType(v) {
            if (v == null) {
              if (this.spec.nullable && v === null) return true;
              if (this.spec.optional && v === undefined) return true;
              return false;
            }
            return this._typeCheck(v);
          }
          resolve(options) {
            let schema = this;
            if (schema.conditions.length) {
              let conditions = schema.conditions;
              schema = schema.clone();
              schema.conditions = [];
              schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);
              schema = schema.resolve(options);
            }
            return schema;
          }
          resolveOptions(options) {
            var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
            return Object.assign({}, options, {
              from: options.from || [],
              strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
              abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
              recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,
              disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
            });
          }

          /**
           * Run the configured transform pipeline over an input value.
           */

          cast(value, options = {}) {
            let resolvedSchema = this.resolve(Object.assign({
              value
            }, options));
            let allowOptionality = options.assert === 'ignore-optionality';
            let result = resolvedSchema._cast(value, options);
            if (options.assert !== false && !resolvedSchema.isType(result)) {
              if (allowOptionality && isAbsent(result)) {
                return result;
              }
              let formattedValue = printValue(value);
              let formattedResult = printValue(result);
              throw new TypeError(`The value of ${options.path || 'field'} could not be cast to a value ` + `that satisfies the schema type: "${resolvedSchema.type}". \n\n` + `attempted value: ${formattedValue} \n` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ''));
            }
            return result;
          }
          _cast(rawValue, options) {
            let value = rawValue === undefined ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);
            if (value === undefined) {
              value = this.getDefault(options);
            }
            return value;
          }
          _validate(_value, options = {}, panic, next) {
            let {
              path,
              originalValue = _value,
              strict = this.spec.strict
            } = options;
            let value = _value;
            if (!strict) {
              value = this._cast(value, Object.assign({
                assert: false
              }, options));
            }
            let initialTests = [];
            for (let test of Object.values(this.internalTests)) {
              if (test) initialTests.push(test);
            }
            this.runTests({
              path,
              value,
              originalValue,
              options,
              tests: initialTests
            }, panic, initialErrors => {
              // even if we aren't ending early we can't proceed further if the types aren't correct
              if (initialErrors.length) {
                return next(initialErrors, value);
              }
              this.runTests({
                path,
                value,
                originalValue,
                options,
                tests: this.tests
              }, panic, next);
            });
          }

          /**
           * Executes a set of validations, either schema, produced Tests or a nested
           * schema validate result.
           */
          runTests(runOptions, panic, next) {
            let fired = false;
            let {
              tests,
              value,
              originalValue,
              path,
              options
            } = runOptions;
            let panicOnce = arg => {
              if (fired) return;
              fired = true;
              panic(arg, value);
            };
            let nextOnce = arg => {
              if (fired) return;
              fired = true;
              next(arg, value);
            };
            let count = tests.length;
            let nestedErrors = [];
            if (!count) return nextOnce([]);
            let args = {
              value,
              originalValue,
              path,
              options,
              schema: this
            };
            for (let i = 0; i < tests.length; i++) {
              const test = tests[i];
              test(args, panicOnce, function finishTestRun(err) {
                if (err) {
                  Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
                }
                if (--count <= 0) {
                  nextOnce(nestedErrors);
                }
              });
            }
          }
          asNestedTest({
            key,
            index,
            parent,
            parentPath,
            originalParent,
            options
          }) {
            const k = key != null ? key : index;
            if (k == null) {
              throw TypeError('Must include `key` or `index` for nested validations');
            }
            const isIndex = typeof k === 'number';
            let value = parent[k];
            const testOptions = Object.assign({}, options, {
              // Nested validations fields are always strict:
              //    1. parent isn't strict so the casting will also have cast inner values
              //    2. parent is strict in which case the nested values weren't cast either
              strict: true,
              parent,
              value,
              originalValue: originalParent[k],
              // FIXME: tests depend on `index` being passed around deeply,
              //   we should not let the options.key/index bleed through
              key: undefined,
              // index: undefined,
              [isIndex ? 'index' : 'key']: k,
              path: isIndex || k.includes('.') ? `${parentPath || ''}[${isIndex ? k : `"${k}"`}]` : (parentPath ? `${parentPath}.` : '') + key
            });
            return (_, panic, next) => this.resolve(testOptions)._validate(value, testOptions, panic, next);
          }
          validate(value, options) {
            var _options$disableStack2;
            let schema = this.resolve(Object.assign({}, options, {
              value
            }));
            let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
            return new Promise((resolve, reject) => schema._validate(value, options, (error, parsed) => {
              if (ValidationError.isError(error)) error.value = parsed;
              reject(error);
            }, (errors, validated) => {
              if (errors.length) reject(new ValidationError(errors, validated, undefined, undefined, disableStackTrace));else resolve(validated);
            }));
          }
          validateSync(value, options) {
            var _options$disableStack3;
            let schema = this.resolve(Object.assign({}, options, {
              value
            }));
            let result;
            let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
            schema._validate(value, Object.assign({}, options, {
              sync: true
            }), (error, parsed) => {
              if (ValidationError.isError(error)) error.value = parsed;
              throw error;
            }, (errors, validated) => {
              if (errors.length) throw new ValidationError(errors, value, undefined, undefined, disableStackTrace);
              result = validated;
            });
            return result;
          }
          isValid(value, options) {
            return this.validate(value, options).then(() => true, err => {
              if (ValidationError.isError(err)) return false;
              throw err;
            });
          }
          isValidSync(value, options) {
            try {
              this.validateSync(value, options);
              return true;
            } catch (err) {
              if (ValidationError.isError(err)) return false;
              throw err;
            }
          }
          _getDefault(options) {
            let defaultValue = this.spec.default;
            if (defaultValue == null) {
              return defaultValue;
            }
            return typeof defaultValue === 'function' ? defaultValue.call(this, options) : clone(defaultValue);
          }
          getDefault(options
          // If schema is defaulted we know it's at least not undefined
          ) {
            let schema = this.resolve(options || {});
            return schema._getDefault(options);
          }
          default(def) {
            if (arguments.length === 0) {
              return this._getDefault();
            }
            let next = this.clone({
              default: def
            });
            return next;
          }
          strict(isStrict = true) {
            return this.clone({
              strict: isStrict
            });
          }
          nullability(nullable, message) {
            const next = this.clone({
              nullable
            });
            next.internalTests.nullable = createValidation({
              message,
              name: 'nullable',
              test(value) {
                return value === null ? this.schema.spec.nullable : true;
              }
            });
            return next;
          }
          optionality(optional, message) {
            const next = this.clone({
              optional
            });
            next.internalTests.optionality = createValidation({
              message,
              name: 'optionality',
              test(value) {
                return value === undefined ? this.schema.spec.optional : true;
              }
            });
            return next;
          }
          optional() {
            return this.optionality(true);
          }
          defined(message = mixed.defined) {
            return this.optionality(false, message);
          }
          nullable() {
            return this.nullability(true);
          }
          nonNullable(message = mixed.notNull) {
            return this.nullability(false, message);
          }
          required(message = mixed.required) {
            return this.clone().withMutation(next => next.nonNullable(message).defined(message));
          }
          notRequired() {
            return this.clone().withMutation(next => next.nullable().optional());
          }
          transform(fn) {
            let next = this.clone();
            next.transforms.push(fn);
            return next;
          }

          /**
           * Adds a test function to the schema's queue of tests.
           * tests can be exclusive or non-exclusive.
           *
           * - exclusive tests, will replace any existing tests of the same name.
           * - non-exclusive: can be stacked
           *
           * If a non-exclusive test is added to a schema with an exclusive test of the same name
           * the exclusive test is removed and further tests of the same name will be stacked.
           *
           * If an exclusive test is added to a schema with non-exclusive tests of the same name
           * the previous tests are removed and further tests of the same name will replace each other.
           */

          test(...args) {
            let opts;
            if (args.length === 1) {
              if (typeof args[0] === 'function') {
                opts = {
                  test: args[0]
                };
              } else {
                opts = args[0];
              }
            } else if (args.length === 2) {
              opts = {
                name: args[0],
                test: args[1]
              };
            } else {
              opts = {
                name: args[0],
                message: args[1],
                test: args[2]
              };
            }
            if (opts.message === undefined) opts.message = mixed.default;
            if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');
            let next = this.clone();
            let validate = createValidation(opts);
            let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
            if (opts.exclusive) {
              if (!opts.name) throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');
            }
            if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;
            next.tests = next.tests.filter(fn => {
              if (fn.OPTIONS.name === opts.name) {
                if (isExclusive) return false;
                if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
              }
              return true;
            });
            next.tests.push(validate);
            return next;
          }
          when(keys, options) {
            if (!Array.isArray(keys) && typeof keys !== 'string') {
              options = keys;
              keys = '.';
            }
            let next = this.clone();
            let deps = toArray$1(keys).map(key => new Reference(key));
            deps.forEach(dep => {
              // @ts-ignore readonly array
              if (dep.isSibling) next.deps.push(dep.key);
            });
            next.conditions.push(typeof options === 'function' ? new Condition(deps, options) : Condition.fromOptions(deps, options));
            return next;
          }
          typeError(message) {
            let next = this.clone();
            next.internalTests.typeError = createValidation({
              message,
              name: 'typeError',
              skipAbsent: true,
              test(value) {
                if (!this.schema._typeCheck(value)) return this.createError({
                  params: {
                    type: this.schema.type
                  }
                });
                return true;
              }
            });
            return next;
          }
          oneOf(enums, message = mixed.oneOf) {
            let next = this.clone();
            enums.forEach(val => {
              next._whitelist.add(val);
              next._blacklist.delete(val);
            });
            next.internalTests.whiteList = createValidation({
              message,
              name: 'oneOf',
              skipAbsent: true,
              test(value) {
                let valids = this.schema._whitelist;
                let resolved = valids.resolveAll(this.resolve);
                return resolved.includes(value) ? true : this.createError({
                  params: {
                    values: Array.from(valids).join(', '),
                    resolved
                  }
                });
              }
            });
            return next;
          }
          notOneOf(enums, message = mixed.notOneOf) {
            let next = this.clone();
            enums.forEach(val => {
              next._blacklist.add(val);
              next._whitelist.delete(val);
            });
            next.internalTests.blacklist = createValidation({
              message,
              name: 'notOneOf',
              test(value) {
                let invalids = this.schema._blacklist;
                let resolved = invalids.resolveAll(this.resolve);
                if (resolved.includes(value)) return this.createError({
                  params: {
                    values: Array.from(invalids).join(', '),
                    resolved
                  }
                });
                return true;
              }
            });
            return next;
          }
          strip(strip = true) {
            let next = this.clone();
            next.spec.strip = strip;
            return next;
          }

          /**
           * Return a serialized description of the schema including validations, flags, types etc.
           *
           * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
           */
          describe(options) {
            const next = (options ? this.resolve(options) : this).clone();
            const {
              label,
              meta,
              optional,
              nullable
            } = next.spec;
            const description = {
              meta,
              label,
              optional,
              nullable,
              default: next.getDefault(options),
              type: next.type,
              oneOf: next._whitelist.describe(),
              notOneOf: next._blacklist.describe(),
              tests: next.tests.filter((n, idx, list) => list.findIndex(c => c.OPTIONS.name === n.OPTIONS.name) === idx).map(fn => {
                const params = fn.OPTIONS.params && options ? resolveParams(Object.assign({}, fn.OPTIONS.params), options) : fn.OPTIONS.params;
                return {
                  name: fn.OPTIONS.name,
                  params
                };
              })
            };
            return description;
          }
          get ['~standard']() {
            const schema = this;
            const standard = {
              version: 1,
              vendor: 'yup',
              async validate(value) {
                try {
                  const result = await schema.validate(value, {
                    abortEarly: false
                  });
                  return {
                    value: result
                  };
                } catch (err) {
                  if (err instanceof ValidationError) {
                    return {
                      issues: issuesFromValidationError(err)
                    };
                  }
                  throw err;
                }
              }
            };
            return standard;
          }
        }
        // @ts-expect-error
        Schema.prototype.__isYupSchema__ = true;
        for (const method of ['validate', 'validateSync']) Schema.prototype[`${method}At`] = function (path, value, options = {}) {
          const {
            parent,
            parentPath,
            schema
          } = getIn$2(this, path, value, options.context);
          return schema[method](parent && parent[parentPath], Object.assign({}, options, {
            parent,
            path
          }));
        };
        for (const alias of ['equals', 'is']) Schema.prototype[alias] = Schema.prototype.oneOf;
        for (const alias of ['not', 'nope']) Schema.prototype[alias] = Schema.prototype.notOneOf;
        const returnsTrue = () => true;
        function create$8(spec) {
          return new MixedSchema(spec);
        }
        class MixedSchema extends Schema {
          constructor(spec) {
            super(typeof spec === 'function' ? {
              type: 'mixed',
              check: spec
            } : Object.assign({
              type: 'mixed',
              check: returnsTrue
            }, spec));
          }
        }
        create$8.prototype = MixedSchema.prototype;
        function create$7() {
          return new BooleanSchema();
        }
        class BooleanSchema extends Schema {
          constructor() {
            super({
              type: 'boolean',
              check(v) {
                if (v instanceof Boolean) v = v.valueOf();
                return typeof v === 'boolean';
              }
            });
            this.withMutation(() => {
              this.transform((value, _raw, ctx) => {
                if (ctx.spec.coerce && !ctx.isType(value)) {
                  if (/^(true|1)$/i.test(String(value))) return true;
                  if (/^(false|0)$/i.test(String(value))) return false;
                }
                return value;
              });
            });
          }
          isTrue(message = boolean.isValue) {
            return this.test({
              message,
              name: 'is-value',
              exclusive: true,
              params: {
                value: 'true'
              },
              test(value) {
                return isAbsent(value) || value === true;
              }
            });
          }
          isFalse(message = boolean.isValue) {
            return this.test({
              message,
              name: 'is-value',
              exclusive: true,
              params: {
                value: 'false'
              },
              test(value) {
                return isAbsent(value) || value === false;
              }
            });
          }
          default(def) {
            return super.default(def);
          }
          defined(msg) {
            return super.defined(msg);
          }
          optional() {
            return super.optional();
          }
          required(msg) {
            return super.required(msg);
          }
          notRequired() {
            return super.notRequired();
          }
          nullable() {
            return super.nullable();
          }
          nonNullable(msg) {
            return super.nonNullable(msg);
          }
          strip(v) {
            return super.strip(v);
          }
        }
        create$7.prototype = BooleanSchema.prototype;

        /**
         * This file is a modified version of the file from the following repository:
         * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>
         * NON-CONFORMANT EDITION.
         *  2011 Colin Snover <http://zetafleet.com>
         * Released under MIT license.
         */

        // prettier-ignore
        //                1 YYYY                2 MM        3 DD              4 HH     5 mm        6 ss           7 msec         8 Z 9    10 tzHH    11 tzmm
        const isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
        function parseIsoDate(date) {
          const struct = parseDateStruct(date);
          if (!struct) return Date.parse ? Date.parse(date) : Number.NaN;

          // timestamps without timezone identifiers should be considered local time
          if (struct.z === undefined && struct.plusMinus === undefined) {
            return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
          }
          let totalMinutesOffset = 0;
          if (struct.z !== 'Z' && struct.plusMinus !== undefined) {
            totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
            if (struct.plusMinus === '+') totalMinutesOffset = 0 - totalMinutesOffset;
          }
          return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
        }
        function parseDateStruct(date) {
          var _regexResult$7$length, _regexResult$;
          const regexResult = isoReg.exec(date);
          if (!regexResult) return null;

          // use of toNumber() avoids NaN timestamps caused by undefined
          // values being passed to Date constructor
          return {
            year: toNumber(regexResult[1]),
            month: toNumber(regexResult[2], 1) - 1,
            day: toNumber(regexResult[3], 1),
            hour: toNumber(regexResult[4]),
            minute: toNumber(regexResult[5]),
            second: toNumber(regexResult[6]),
            millisecond: regexResult[7] ?
            // allow arbitrary sub-second precision beyond milliseconds
            toNumber(regexResult[7].substring(0, 3)) : 0,
            precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : undefined,
            z: regexResult[8] || undefined,
            plusMinus: regexResult[9] || undefined,
            hourOffset: toNumber(regexResult[10]),
            minuteOffset: toNumber(regexResult[11])
          };
        }
        function toNumber(str, defaultValue = 0) {
          return Number(str) || defaultValue;
        }

        // Taken from HTML spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address
        let rEmail =
        // eslint-disable-next-line
        /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
        let rUrl =
        // eslint-disable-next-line
        /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;

        // eslint-disable-next-line
        let rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
        let yearMonthDay = '^\\d{4}-\\d{2}-\\d{2}';
        let hourMinuteSecond = '\\d{2}:\\d{2}:\\d{2}';
        let zOrOffset = '(([+-]\\d{2}(:?\\d{2})?)|Z)';
        let rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\.\\d+)?${zOrOffset}$`);
        let isTrimmed = value => isAbsent(value) || value === value.trim();
        let objStringTag = {}.toString();
        function create$6() {
          return new StringSchema();
        }
        class StringSchema extends Schema {
          constructor() {
            super({
              type: 'string',
              check(value) {
                if (value instanceof String) value = value.valueOf();
                return typeof value === 'string';
              }
            });
            this.withMutation(() => {
              this.transform((value, _raw, ctx) => {
                if (!ctx.spec.coerce || ctx.isType(value)) return value;

                // don't ever convert arrays
                if (Array.isArray(value)) return value;
                const strValue = value != null && value.toString ? value.toString() : value;

                // no one wants plain objects converted to [Object object]
                if (strValue === objStringTag) return value;
                return strValue;
              });
            });
          }
          required(message) {
            return super.required(message).withMutation(schema => schema.test({
              message: message || mixed.required,
              name: 'required',
              skipAbsent: true,
              test: value => !!value.length
            }));
          }
          notRequired() {
            return super.notRequired().withMutation(schema => {
              schema.tests = schema.tests.filter(t => t.OPTIONS.name !== 'required');
              return schema;
            });
          }
          length(length, message = string.length) {
            return this.test({
              message,
              name: 'length',
              exclusive: true,
              params: {
                length
              },
              skipAbsent: true,
              test(value) {
                return value.length === this.resolve(length);
              }
            });
          }
          min(min, message = string.min) {
            return this.test({
              message,
              name: 'min',
              exclusive: true,
              params: {
                min
              },
              skipAbsent: true,
              test(value) {
                return value.length >= this.resolve(min);
              }
            });
          }
          max(max, message = string.max) {
            return this.test({
              name: 'max',
              exclusive: true,
              message,
              params: {
                max
              },
              skipAbsent: true,
              test(value) {
                return value.length <= this.resolve(max);
              }
            });
          }
          matches(regex, options) {
            let excludeEmptyString = false;
            let message;
            let name;
            if (options) {
              if (typeof options === 'object') {
                ({
                  excludeEmptyString = false,
                  message,
                  name
                } = options);
              } else {
                message = options;
              }
            }
            return this.test({
              name: name || 'matches',
              message: message || string.matches,
              params: {
                regex
              },
              skipAbsent: true,
              test: value => value === '' && excludeEmptyString || value.search(regex) !== -1
            });
          }
          email(message = string.email) {
            return this.matches(rEmail, {
              name: 'email',
              message,
              excludeEmptyString: true
            });
          }
          url(message = string.url) {
            return this.matches(rUrl, {
              name: 'url',
              message,
              excludeEmptyString: true
            });
          }
          uuid(message = string.uuid) {
            return this.matches(rUUID, {
              name: 'uuid',
              message,
              excludeEmptyString: false
            });
          }
          datetime(options) {
            let message = '';
            let allowOffset;
            let precision;
            if (options) {
              if (typeof options === 'object') {
                ({
                  message = '',
                  allowOffset = false,
                  precision = undefined
                } = options);
              } else {
                message = options;
              }
            }
            return this.matches(rIsoDateTime, {
              name: 'datetime',
              message: message || string.datetime,
              excludeEmptyString: true
            }).test({
              name: 'datetime_offset',
              message: message || string.datetime_offset,
              params: {
                allowOffset
              },
              skipAbsent: true,
              test: value => {
                if (!value || allowOffset) return true;
                const struct = parseDateStruct(value);
                if (!struct) return false;
                return !!struct.z;
              }
            }).test({
              name: 'datetime_precision',
              message: message || string.datetime_precision,
              params: {
                precision
              },
              skipAbsent: true,
              test: value => {
                if (!value || precision == undefined) return true;
                const struct = parseDateStruct(value);
                if (!struct) return false;
                return struct.precision === precision;
              }
            });
          }

          //-- transforms --
          ensure() {
            return this.default('').transform(val => val === null ? '' : val);
          }
          trim(message = string.trim) {
            return this.transform(val => val != null ? val.trim() : val).test({
              message,
              name: 'trim',
              test: isTrimmed
            });
          }
          lowercase(message = string.lowercase) {
            return this.transform(value => !isAbsent(value) ? value.toLowerCase() : value).test({
              message,
              name: 'string_case',
              exclusive: true,
              skipAbsent: true,
              test: value => isAbsent(value) || value === value.toLowerCase()
            });
          }
          uppercase(message = string.uppercase) {
            return this.transform(value => !isAbsent(value) ? value.toUpperCase() : value).test({
              message,
              name: 'string_case',
              exclusive: true,
              skipAbsent: true,
              test: value => isAbsent(value) || value === value.toUpperCase()
            });
          }
        }
        create$6.prototype = StringSchema.prototype;

        //
        // String Interfaces
        //

        let isNaN$1$1 = value => value != +value;
        function create$5() {
          return new NumberSchema();
        }
        class NumberSchema extends Schema {
          constructor() {
            super({
              type: 'number',
              check(value) {
                if (value instanceof Number) value = value.valueOf();
                return typeof value === 'number' && !isNaN$1$1(value);
              }
            });
            this.withMutation(() => {
              this.transform((value, _raw, ctx) => {
                if (!ctx.spec.coerce) return value;
                let parsed = value;
                if (typeof parsed === 'string') {
                  parsed = parsed.replace(/\s/g, '');
                  if (parsed === '') return NaN;
                  // don't use parseFloat to avoid positives on alpha-numeric strings
                  parsed = +parsed;
                }

                // null -> NaN isn't useful; treat all nulls as null and let it fail on
                // nullability check vs TypeErrors
                if (ctx.isType(parsed) || parsed === null) return parsed;
                return parseFloat(parsed);
              });
            });
          }
          min(min, message = number.min) {
            return this.test({
              message,
              name: 'min',
              exclusive: true,
              params: {
                min
              },
              skipAbsent: true,
              test(value) {
                return value >= this.resolve(min);
              }
            });
          }
          max(max, message = number.max) {
            return this.test({
              message,
              name: 'max',
              exclusive: true,
              params: {
                max
              },
              skipAbsent: true,
              test(value) {
                return value <= this.resolve(max);
              }
            });
          }
          lessThan(less, message = number.lessThan) {
            return this.test({
              message,
              name: 'max',
              exclusive: true,
              params: {
                less
              },
              skipAbsent: true,
              test(value) {
                return value < this.resolve(less);
              }
            });
          }
          moreThan(more, message = number.moreThan) {
            return this.test({
              message,
              name: 'min',
              exclusive: true,
              params: {
                more
              },
              skipAbsent: true,
              test(value) {
                return value > this.resolve(more);
              }
            });
          }
          positive(msg = number.positive) {
            return this.moreThan(0, msg);
          }
          negative(msg = number.negative) {
            return this.lessThan(0, msg);
          }
          integer(message = number.integer) {
            return this.test({
              name: 'integer',
              message,
              skipAbsent: true,
              test: val => Number.isInteger(val)
            });
          }
          truncate() {
            return this.transform(value => !isAbsent(value) ? value | 0 : value);
          }
          round(method) {
            var _method;
            let avail = ['ceil', 'floor', 'round', 'trunc'];
            method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || 'round';

            // this exists for symemtry with the new Math.trunc
            if (method === 'trunc') return this.truncate();
            if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));
            return this.transform(value => !isAbsent(value) ? Math[method](value) : value);
          }
        }
        create$5.prototype = NumberSchema.prototype;

        //
        // Number Interfaces
        //

        let invalidDate = new Date('');
        let isDate$1 = obj => Object.prototype.toString.call(obj) === '[object Date]';
        function create$4() {
          return new DateSchema();
        }
        class DateSchema extends Schema {
          constructor() {
            super({
              type: 'date',
              check(v) {
                return isDate$1(v) && !isNaN(v.getTime());
              }
            });
            this.withMutation(() => {
              this.transform((value, _raw, ctx) => {
                // null -> InvalidDate isn't useful; treat all nulls as null and let it fail on
                // nullability check vs TypeErrors
                if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;
                value = parseIsoDate(value);

                // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.
                return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;
              });
            });
          }
          prepareParam(ref, name) {
            let param;
            if (!Reference.isRef(ref)) {
              let cast = this.cast(ref);
              if (!this._typeCheck(cast)) throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
              param = cast;
            } else {
              param = ref;
            }
            return param;
          }
          min(min, message = date.min) {
            let limit = this.prepareParam(min, 'min');
            return this.test({
              message,
              name: 'min',
              exclusive: true,
              params: {
                min
              },
              skipAbsent: true,
              test(value) {
                return value >= this.resolve(limit);
              }
            });
          }
          max(max, message = date.max) {
            let limit = this.prepareParam(max, 'max');
            return this.test({
              message,
              name: 'max',
              exclusive: true,
              params: {
                max
              },
              skipAbsent: true,
              test(value) {
                return value <= this.resolve(limit);
              }
            });
          }
        }
        DateSchema.INVALID_DATE = invalidDate;
        create$4.prototype = DateSchema.prototype;
        create$4.INVALID_DATE = invalidDate;

        // @ts-expect-error
        function sortFields(fields, excludedEdges = []) {
          let edges = [];
          let nodes = new Set();
          let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));
          function addNode(depPath, key) {
            let node = propertyExprExports.split(depPath)[0];
            nodes.add(node);
            if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);
          }
          for (const key of Object.keys(fields)) {
            let value = fields[key];
            nodes.add(key);
            if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(path => addNode(path, key));
          }
          return toposort.array(Array.from(nodes), edges).reverse();
        }
        function findIndex$1(arr, err) {
          let idx = Infinity;
          arr.some((key, ii) => {
            var _err$path;
            if ((_err$path = err.path) != null && _err$path.includes(key)) {
              idx = ii;
              return true;
            }
          });
          return idx;
        }
        function sortByKeyOrder(keys) {
          return (a, b) => {
            return findIndex$1(keys, a) - findIndex$1(keys, b);
          };
        }
        const parseJson = (value, _, ctx) => {
          if (typeof value !== 'string') {
            return value;
          }
          let parsed = value;
          try {
            parsed = JSON.parse(value);
          } catch (err) {
            /* */
          }
          return ctx.isType(parsed) ? parsed : value;
        };

        // @ts-ignore
        function deepPartial(schema) {
          if ('fields' in schema) {
            const partial = {};
            for (const [key, fieldSchema] of Object.entries(schema.fields)) {
              partial[key] = deepPartial(fieldSchema);
            }
            return schema.setFields(partial);
          }
          if (schema.type === 'array') {
            const nextArray = schema.optional();
            if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);
            return nextArray;
          }
          if (schema.type === 'tuple') {
            return schema.optional().clone({
              types: schema.spec.types.map(deepPartial)
            });
          }
          if ('optional' in schema) {
            return schema.optional();
          }
          return schema;
        }
        const deepHas = (obj, p) => {
          const path = [...propertyExprExports.normalizePath(p)];
          if (path.length === 1) return path[0] in obj;
          let last = path.pop();
          let parent = propertyExprExports.getter(propertyExprExports.join(path), true)(obj);
          return !!(parent && last in parent);
        };
        let isObject$4 = obj => Object.prototype.toString.call(obj) === '[object Object]';
        function unknown(ctx, value) {
          let known = Object.keys(ctx.fields);
          return Object.keys(value).filter(key => known.indexOf(key) === -1);
        }
        const defaultSort = sortByKeyOrder([]);
        function create$3(spec) {
          return new ObjectSchema(spec);
        }
        class ObjectSchema extends Schema {
          constructor(spec) {
            super({
              type: 'object',
              check(value) {
                return isObject$4(value) || typeof value === 'function';
              }
            });
            this.fields = Object.create(null);
            this._sortErrors = defaultSort;
            this._nodes = [];
            this._excludedEdges = [];
            this.withMutation(() => {
              if (spec) {
                this.shape(spec);
              }
            });
          }
          _cast(_value, options = {}) {
            var _options$stripUnknown;
            let value = super._cast(_value, options);

            //should ignore nulls here
            if (value === undefined) return this.getDefault(options);
            if (!this._typeCheck(value)) return value;
            let fields = this.fields;
            let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
            let props = [].concat(this._nodes, Object.keys(value).filter(v => !this._nodes.includes(v)));
            let intermediateValue = {}; // is filled during the transform below
            let innerOptions = Object.assign({}, options, {
              parent: intermediateValue,
              __validating: options.__validating || false
            });
            let isChanged = false;
            for (const prop of props) {
              let field = fields[prop];
              let exists = prop in value;
              if (field) {
                let fieldValue;
                let inputValue = value[prop];

                // safe to mutate since this is fired in sequence
                innerOptions.path = (options.path ? `${options.path}.` : '') + prop;
                field = field.resolve({
                  value: inputValue,
                  context: options.context,
                  parent: intermediateValue
                });
                let fieldSpec = field instanceof Schema ? field.spec : undefined;
                let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
                if (fieldSpec != null && fieldSpec.strip) {
                  isChanged = isChanged || prop in value;
                  continue;
                }
                fieldValue = !options.__validating || !strict ?
                // TODO: use _cast, this is double resolving
                field.cast(value[prop], innerOptions) : value[prop];
                if (fieldValue !== undefined) {
                  intermediateValue[prop] = fieldValue;
                }
              } else if (exists && !strip) {
                intermediateValue[prop] = value[prop];
              }
              if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
                isChanged = true;
              }
            }
            return isChanged ? intermediateValue : value;
          }
          _validate(_value, options = {}, panic, next) {
            let {
              from = [],
              originalValue = _value,
              recursive = this.spec.recursive
            } = options;
            options.from = [{
              schema: this,
              value: originalValue
            }, ...from];
            // this flag is needed for handling `strict` correctly in the context of
            // validation vs just casting. e.g strict() on a field is only used when validating
            options.__validating = true;
            options.originalValue = originalValue;
            super._validate(_value, options, panic, (objectErrors, value) => {
              if (!recursive || !isObject$4(value)) {
                next(objectErrors, value);
                return;
              }
              originalValue = originalValue || value;
              let tests = [];
              for (let key of this._nodes) {
                let field = this.fields[key];
                if (!field || Reference.isRef(field)) {
                  continue;
                }
                tests.push(field.asNestedTest({
                  options,
                  key,
                  parent: value,
                  parentPath: options.path,
                  originalParent: originalValue
                }));
              }
              this.runTests({
                tests,
                value,
                originalValue,
                options
              }, panic, fieldErrors => {
                next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
              });
            });
          }
          clone(spec) {
            const next = super.clone(spec);
            next.fields = Object.assign({}, this.fields);
            next._nodes = this._nodes;
            next._excludedEdges = this._excludedEdges;
            next._sortErrors = this._sortErrors;
            return next;
          }
          concat(schema) {
            let next = super.concat(schema);
            let nextFields = next.fields;
            for (let [field, schemaOrRef] of Object.entries(this.fields)) {
              const target = nextFields[field];
              nextFields[field] = target === undefined ? schemaOrRef : target;
            }
            return next.withMutation(s =>
            // XXX: excludes here is wrong
            s.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges]));
          }
          _getDefault(options) {
            if ('default' in this.spec) {
              return super._getDefault(options);
            }

            // if there is no default set invent one
            if (!this._nodes.length) {
              return undefined;
            }
            let dft = {};
            this._nodes.forEach(key => {
              var _innerOptions;
              const field = this.fields[key];
              let innerOptions = options;
              if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
                innerOptions = Object.assign({}, innerOptions, {
                  parent: innerOptions.value,
                  value: innerOptions.value[key]
                });
              }
              dft[key] = field && 'getDefault' in field ? field.getDefault(innerOptions) : undefined;
            });
            return dft;
          }
          setFields(shape, excludedEdges) {
            let next = this.clone();
            next.fields = shape;
            next._nodes = sortFields(shape, excludedEdges);
            next._sortErrors = sortByKeyOrder(Object.keys(shape));
            // XXX: this carries over edges which may not be what you want
            if (excludedEdges) next._excludedEdges = excludedEdges;
            return next;
          }
          shape(additions, excludes = []) {
            return this.clone().withMutation(next => {
              let edges = next._excludedEdges;
              if (excludes.length) {
                if (!Array.isArray(excludes[0])) excludes = [excludes];
                edges = [...next._excludedEdges, ...excludes];
              }

              // XXX: excludes here is wrong
              return next.setFields(Object.assign(next.fields, additions), edges);
            });
          }
          partial() {
            const partial = {};
            for (const [key, schema] of Object.entries(this.fields)) {
              partial[key] = 'optional' in schema && schema.optional instanceof Function ? schema.optional() : schema;
            }
            return this.setFields(partial);
          }
          deepPartial() {
            const next = deepPartial(this);
            return next;
          }
          pick(keys) {
            const picked = {};
            for (const key of keys) {
              if (this.fields[key]) picked[key] = this.fields[key];
            }
            return this.setFields(picked, this._excludedEdges.filter(([a, b]) => keys.includes(a) && keys.includes(b)));
          }
          omit(keys) {
            const remaining = [];
            for (const key of Object.keys(this.fields)) {
              if (keys.includes(key)) continue;
              remaining.push(key);
            }
            return this.pick(remaining);
          }
          from(from, to, alias) {
            let fromGetter = propertyExprExports.getter(from, true);
            return this.transform(obj => {
              if (!obj) return obj;
              let newObj = obj;
              if (deepHas(obj, from)) {
                newObj = Object.assign({}, obj);
                if (!alias) delete newObj[from];
                newObj[to] = fromGetter(obj);
              }
              return newObj;
            });
          }

          /** Parse an input JSON string to an object */
          json() {
            return this.transform(parseJson);
          }

          /**
           * Similar to `noUnknown` but only validates that an object is the right shape without stripping the unknown keys
           */
          exact(message) {
            return this.test({
              name: 'exact',
              exclusive: true,
              message: message || object.exact,
              test(value) {
                if (value == null) return true;
                const unknownKeys = unknown(this.schema, value);
                return unknownKeys.length === 0 || this.createError({
                  params: {
                    properties: unknownKeys.join(', ')
                  }
                });
              }
            });
          }
          stripUnknown() {
            return this.clone({
              noUnknown: true
            });
          }
          noUnknown(noAllow = true, message = object.noUnknown) {
            if (typeof noAllow !== 'boolean') {
              message = noAllow;
              noAllow = true;
            }
            let next = this.test({
              name: 'noUnknown',
              exclusive: true,
              message: message,
              test(value) {
                if (value == null) return true;
                const unknownKeys = unknown(this.schema, value);
                return !noAllow || unknownKeys.length === 0 || this.createError({
                  params: {
                    unknown: unknownKeys.join(', ')
                  }
                });
              }
            });
            next.spec.noUnknown = noAllow;
            return next;
          }
          unknown(allow = true, message = object.noUnknown) {
            return this.noUnknown(!allow, message);
          }
          transformKeys(fn) {
            return this.transform(obj => {
              if (!obj) return obj;
              const result = {};
              for (const key of Object.keys(obj)) result[fn(key)] = obj[key];
              return result;
            });
          }
          camelCase() {
            return this.transformKeys(tinyCaseExports.camelCase);
          }
          snakeCase() {
            return this.transformKeys(tinyCaseExports.snakeCase);
          }
          constantCase() {
            return this.transformKeys(key => tinyCaseExports.snakeCase(key).toUpperCase());
          }
          describe(options) {
            const next = (options ? this.resolve(options) : this).clone();
            const base = super.describe(options);
            base.fields = {};
            for (const [key, value] of Object.entries(next.fields)) {
              var _innerOptions2;
              let innerOptions = options;
              if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
                innerOptions = Object.assign({}, innerOptions, {
                  parent: innerOptions.value,
                  value: innerOptions.value[key]
                });
              }
              base.fields[key] = value.describe(innerOptions);
            }
            return base;
          }
        }
        create$3.prototype = ObjectSchema.prototype;
        function create$2(type) {
          return new ArraySchema(type);
        }
        class ArraySchema extends Schema {
          constructor(type) {
            super({
              type: 'array',
              spec: {
                types: type
              },
              check(v) {
                return Array.isArray(v);
              }
            });

            // `undefined` specifically means uninitialized, as opposed to "no subtype"
            this.innerType = void 0;
            this.innerType = type;
          }
          _cast(_value, _opts) {
            const value = super._cast(_value, _opts);

            // should ignore nulls here
            if (!this._typeCheck(value) || !this.innerType) {
              return value;
            }
            let isChanged = false;
            const castArray = value.map((v, idx) => {
              const castElement = this.innerType.cast(v, Object.assign({}, _opts, {
                path: `${_opts.path || ''}[${idx}]`
              }));
              if (castElement !== v) {
                isChanged = true;
              }
              return castElement;
            });
            return isChanged ? castArray : value;
          }
          _validate(_value, options = {}, panic, next) {
            var _options$recursive;
            // let sync = options.sync;
            // let path = options.path;
            let innerType = this.innerType;
            // let endEarly = options.abortEarly ?? this.spec.abortEarly;
            let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
            options.originalValue != null ? options.originalValue : _value;
            super._validate(_value, options, panic, (arrayErrors, value) => {
              var _options$originalValu2;
              if (!recursive || !innerType || !this._typeCheck(value)) {
                next(arrayErrors, value);
                return;
              }

              // #950 Ensure that sparse array empty slots are validated
              let tests = new Array(value.length);
              for (let index = 0; index < value.length; index++) {
                var _options$originalValu;
                tests[index] = innerType.asNestedTest({
                  options,
                  index,
                  parent: value,
                  parentPath: options.path,
                  originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
                });
              }
              this.runTests({
                value,
                tests,
                originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
                options
              }, panic, innerTypeErrors => next(innerTypeErrors.concat(arrayErrors), value));
            });
          }
          clone(spec) {
            const next = super.clone(spec);
            // @ts-expect-error readonly
            next.innerType = this.innerType;
            return next;
          }

          /** Parse an input JSON string to an object */
          json() {
            return this.transform(parseJson);
          }
          concat(schema) {
            let next = super.concat(schema);

            // @ts-expect-error readonly
            next.innerType = this.innerType;
            if (schema.innerType)
              // @ts-expect-error readonly
              next.innerType = next.innerType ?
              // @ts-expect-error Lazy doesn't have concat and will break
              next.innerType.concat(schema.innerType) : schema.innerType;
            return next;
          }
          of(schema) {
            // FIXME: this should return a new instance of array without the default to be
            let next = this.clone();
            if (!isSchema(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema not: ' + printValue(schema));

            // @ts-expect-error readonly
            next.innerType = schema;
            next.spec = Object.assign({}, next.spec, {
              types: schema
            });
            return next;
          }
          length(length, message = array.length) {
            return this.test({
              message,
              name: 'length',
              exclusive: true,
              params: {
                length
              },
              skipAbsent: true,
              test(value) {
                return value.length === this.resolve(length);
              }
            });
          }
          min(min, message) {
            message = message || array.min;
            return this.test({
              message,
              name: 'min',
              exclusive: true,
              params: {
                min
              },
              skipAbsent: true,
              // FIXME(ts): Array<typeof T>
              test(value) {
                return value.length >= this.resolve(min);
              }
            });
          }
          max(max, message) {
            message = message || array.max;
            return this.test({
              message,
              name: 'max',
              exclusive: true,
              params: {
                max
              },
              skipAbsent: true,
              test(value) {
                return value.length <= this.resolve(max);
              }
            });
          }
          ensure() {
            return this.default(() => []).transform((val, original) => {
              // We don't want to return `null` for nullable schema
              if (this._typeCheck(val)) return val;
              return original == null ? [] : [].concat(original);
            });
          }
          compact(rejector) {
            let reject = !rejector ? v => !!v : (v, i, a) => !rejector(v, i, a);
            return this.transform(values => values != null ? values.filter(reject) : values);
          }
          describe(options) {
            const next = (options ? this.resolve(options) : this).clone();
            const base = super.describe(options);
            if (next.innerType) {
              var _innerOptions;
              let innerOptions = options;
              if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
                innerOptions = Object.assign({}, innerOptions, {
                  parent: innerOptions.value,
                  value: innerOptions.value[0]
                });
              }
              base.innerType = next.innerType.describe(innerOptions);
            }
            return base;
          }
        }
        create$2.prototype = ArraySchema.prototype;

        // @ts-ignore
        function create$1(schemas) {
          return new TupleSchema(schemas);
        }
        class TupleSchema extends Schema {
          constructor(schemas) {
            super({
              type: 'tuple',
              spec: {
                types: schemas
              },
              check(v) {
                const types = this.spec.types;
                return Array.isArray(v) && v.length === types.length;
              }
            });
            this.withMutation(() => {
              this.typeError(tuple.notType);
            });
          }
          _cast(inputValue, options) {
            const {
              types
            } = this.spec;
            const value = super._cast(inputValue, options);
            if (!this._typeCheck(value)) {
              return value;
            }
            let isChanged = false;
            const castArray = types.map((type, idx) => {
              const castElement = type.cast(value[idx], Object.assign({}, options, {
                path: `${options.path || ''}[${idx}]`
              }));
              if (castElement !== value[idx]) isChanged = true;
              return castElement;
            });
            return isChanged ? castArray : value;
          }
          _validate(_value, options = {}, panic, next) {
            let itemTypes = this.spec.types;
            super._validate(_value, options, panic, (tupleErrors, value) => {
              var _options$originalValu2;
              // intentionally not respecting recursive
              if (!this._typeCheck(value)) {
                next(tupleErrors, value);
                return;
              }
              let tests = [];
              for (let [index, itemSchema] of itemTypes.entries()) {
                var _options$originalValu;
                tests[index] = itemSchema.asNestedTest({
                  options,
                  index,
                  parent: value,
                  parentPath: options.path,
                  originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
                });
              }
              this.runTests({
                value,
                tests,
                originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
                options
              }, panic, innerTypeErrors => next(innerTypeErrors.concat(tupleErrors), value));
            });
          }
          describe(options) {
            const next = (options ? this.resolve(options) : this).clone();
            const base = super.describe(options);
            base.innerType = next.spec.types.map((schema, index) => {
              var _innerOptions;
              let innerOptions = options;
              if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
                innerOptions = Object.assign({}, innerOptions, {
                  parent: innerOptions.value,
                  value: innerOptions.value[index]
                });
              }
              return schema.describe(innerOptions);
            });
            return base;
          }
        }
        create$1.prototype = TupleSchema.prototype;
        function create(builder) {
          return new Lazy(builder);
        }
        function catchValidationError(fn) {
          try {
            return fn();
          } catch (err) {
            if (ValidationError.isError(err)) return Promise.reject(err);
            throw err;
          }
        }
        class Lazy {
          constructor(builder) {
            this.type = 'lazy';
            this.__isYupSchema__ = true;
            this.spec = void 0;
            this._resolve = (value, options = {}) => {
              let schema = this.builder(value, options);
              if (!isSchema(schema)) throw new TypeError('lazy() functions must return a valid schema');
              if (this.spec.optional) schema = schema.optional();
              return schema.resolve(options);
            };
            this.builder = builder;
            this.spec = {
              meta: undefined,
              optional: false
            };
          }
          clone(spec) {
            const next = new Lazy(this.builder);
            next.spec = Object.assign({}, this.spec, spec);
            return next;
          }
          optionality(optional) {
            const next = this.clone({
              optional
            });
            return next;
          }
          optional() {
            return this.optionality(true);
          }
          resolve(options) {
            return this._resolve(options.value, options);
          }
          cast(value, options) {
            return this._resolve(value, options).cast(value, options);
          }
          asNestedTest(config) {
            let {
              key,
              index,
              parent,
              options
            } = config;
            let value = parent[index != null ? index : key];
            return this._resolve(value, Object.assign({}, options, {
              value,
              parent
            })).asNestedTest(config);
          }
          validate(value, options) {
            return catchValidationError(() => this._resolve(value, options).validate(value, options));
          }
          validateSync(value, options) {
            return this._resolve(value, options).validateSync(value, options);
          }
          validateAt(path, value, options) {
            return catchValidationError(() => this._resolve(value, options).validateAt(path, value, options));
          }
          validateSyncAt(path, value, options) {
            return this._resolve(value, options).validateSyncAt(path, value, options);
          }
          isValid(value, options) {
            try {
              return this._resolve(value, options).isValid(value, options);
            } catch (err) {
              if (ValidationError.isError(err)) {
                return Promise.resolve(false);
              }
              throw err;
            }
          }
          isValidSync(value, options) {
            return this._resolve(value, options).isValidSync(value, options);
          }
          describe(options) {
            return options ? this.resolve(options).describe(options) : {
              type: 'lazy',
              meta: this.spec.meta,
              label: undefined
            };
          }
          meta(...args) {
            if (args.length === 0) return this.spec.meta;
            let next = this.clone();
            next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
            return next;
          }
          get ['~standard']() {
            const schema = this;
            const standard = {
              version: 1,
              vendor: 'yup',
              async validate(value) {
                try {
                  const result = await schema.validate(value, {
                    abortEarly: false
                  });
                  return {
                    value: result
                  };
                } catch (err) {
                  if (ValidationError.isError(err)) {
                    return {
                      issues: issuesFromValidationError(err)
                    };
                  }
                  throw err;
                }
              }
            };
            return standard;
          }
        }
        function setLocale(custom) {
          Object.keys(custom).forEach(type => {
            // @ts-ignore
            Object.keys(custom[type]).forEach(method => {
              // @ts-ignore
              locale[type][method] = custom[type][method];
            });
          });
        }
        function addMethod(schemaType, name, fn) {
          if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError('You must provide a yup schema constructor function');
          if (typeof name !== 'string') throw new TypeError('A Method name must be provided');
          if (typeof fn !== 'function') throw new TypeError('Method function must be provided');
          schemaType.prototype[name] = fn;
        }
        const yup = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          ArraySchema,
          BooleanSchema,
          DateSchema,
          LazySchema: Lazy,
          MixedSchema,
          NumberSchema,
          ObjectSchema,
          Schema,
          StringSchema,
          TupleSchema,
          ValidationError,
          addMethod,
          array: create$2,
          bool: create$7,
          boolean: create$7,
          date: create$4,
          defaultLocale: locale,
          getIn: getIn$2,
          isSchema,
          lazy: create,
          mixed: create$8,
          number: create$5,
          object: create$3,
          printValue,
          reach,
          ref: create$9,
          setLocale,
          string: create$6,
          tuple: create$1
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        exports("a4", yup);
        var humps$1 = {
          exports: {}
        };
        var humps = humps$1.exports;
        var hasRequiredHumps;
        function requireHumps() {
          if (hasRequiredHumps) return humps$1.exports;
          hasRequiredHumps = 1;
          (function (module) {
            (function (global) {
              var _processKeys = function (convert, obj, options) {
                if (!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) {
                  return obj;
                }
                var output,
                  i = 0,
                  l = 0;
                if (_isArray(obj)) {
                  output = [];
                  for (l = obj.length; i < l; i++) {
                    output.push(_processKeys(convert, obj[i], options));
                  }
                } else {
                  output = {};
                  for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                      output[convert(key, options)] = _processKeys(convert, obj[key], options);
                    }
                  }
                }
                return output;
              };
              var separateWords = function (string, options) {
                options = options || {};
                var separator = options.separator || "_";
                var split = options.split || /(?=[A-Z])/;
                return string.split(split).join(separator);
              };
              var camelize = function (string) {
                if (_isNumerical(string)) {
                  return string;
                }
                string = string.replace(/[\-_\s]+(.)?/g, function (match, chr) {
                  return chr ? chr.toUpperCase() : "";
                });
                return string.substr(0, 1).toLowerCase() + string.substr(1);
              };
              var pascalize = function (string) {
                var camelized = camelize(string);
                return camelized.substr(0, 1).toUpperCase() + camelized.substr(1);
              };
              var decamelize = function (string, options) {
                return separateWords(string, options).toLowerCase();
              };
              var toString = Object.prototype.toString;
              var _isFunction = function (obj) {
                return typeof obj === "function";
              };
              var _isObject = function (obj) {
                return obj === Object(obj);
              };
              var _isArray = function (obj) {
                return toString.call(obj) == "[object Array]";
              };
              var _isDate = function (obj) {
                return toString.call(obj) == "[object Date]";
              };
              var _isRegExp = function (obj) {
                return toString.call(obj) == "[object RegExp]";
              };
              var _isBoolean = function (obj) {
                return toString.call(obj) == "[object Boolean]";
              };
              var _isNumerical = function (obj) {
                obj = obj - 0;
                return obj === obj;
              };
              var _processor = function (convert, options) {
                var callback = options && "process" in options ? options.process : options;
                if (typeof callback !== "function") {
                  return convert;
                }
                return function (string, options2) {
                  return callback(string, convert, options2);
                };
              };
              var humps = {
                camelize,
                decamelize,
                pascalize,
                depascalize: decamelize,
                camelizeKeys: function (object, options) {
                  return _processKeys(_processor(camelize, options), object);
                },
                decamelizeKeys: function (object, options) {
                  return _processKeys(_processor(decamelize, options), object, options);
                },
                pascalizeKeys: function (object, options) {
                  return _processKeys(_processor(pascalize, options), object);
                },
                depascalizeKeys: function () {
                  return this.decamelizeKeys.apply(this, arguments);
                }
              };
              if (module.exports) {
                module.exports = humps;
              } else {
                global.humps = humps;
              }
            })(humps);
          })(humps$1);
          return humps$1.exports;
        }
        var humpsExports = exports("E", requireHumps());
        function formatProdErrorMessage$1(code) {
          return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
        }
        var $$observable = /* @__PURE__ */(() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
        var symbol_observable_default = $$observable;
        var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
        var ActionTypes = {
          INIT: `@@redux/INIT${/* @__PURE__ */randomString()}`,
          REPLACE: `@@redux/REPLACE${/* @__PURE__ */randomString()}`,
          PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
        };
        var actionTypes_default = ActionTypes;
        function isPlainObject$3(obj) {
          if (typeof obj !== "object" || obj === null) return false;
          let proto = obj;
          while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
          }
          return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
        }
        function createStore(reducer, preloadedState, enhancer) {
          if (typeof reducer !== "function") {
            throw new Error(formatProdErrorMessage$1(2));
          }
          if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
            throw new Error(formatProdErrorMessage$1(0));
          }
          if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
            enhancer = preloadedState;
            preloadedState = void 0;
          }
          if (typeof enhancer !== "undefined") {
            if (typeof enhancer !== "function") {
              throw new Error(formatProdErrorMessage$1(1));
            }
            return enhancer(createStore)(reducer, preloadedState);
          }
          let currentReducer = reducer;
          let currentState = preloadedState;
          let currentListeners = /* @__PURE__ */new Map();
          let nextListeners = currentListeners;
          let listenerIdCounter = 0;
          let isDispatching = false;
          function ensureCanMutateNextListeners() {
            if (nextListeners === currentListeners) {
              nextListeners = /* @__PURE__ */new Map();
              currentListeners.forEach((listener, key) => {
                nextListeners.set(key, listener);
              });
            }
          }
          function getState() {
            if (isDispatching) {
              throw new Error(formatProdErrorMessage$1(3));
            }
            return currentState;
          }
          function subscribe(listener) {
            if (typeof listener !== "function") {
              throw new Error(formatProdErrorMessage$1(4));
            }
            if (isDispatching) {
              throw new Error(formatProdErrorMessage$1(5));
            }
            let isSubscribed = true;
            ensureCanMutateNextListeners();
            const listenerId = listenerIdCounter++;
            nextListeners.set(listenerId, listener);
            return function unsubscribe() {
              if (!isSubscribed) {
                return;
              }
              if (isDispatching) {
                throw new Error(formatProdErrorMessage$1(6));
              }
              isSubscribed = false;
              ensureCanMutateNextListeners();
              nextListeners.delete(listenerId);
              currentListeners = null;
            };
          }
          function dispatch(action) {
            if (!isPlainObject$3(action)) {
              throw new Error(formatProdErrorMessage$1(7));
            }
            if (typeof action.type === "undefined") {
              throw new Error(formatProdErrorMessage$1(8));
            }
            if (typeof action.type !== "string") {
              throw new Error(formatProdErrorMessage$1(17));
            }
            if (isDispatching) {
              throw new Error(formatProdErrorMessage$1(9));
            }
            try {
              isDispatching = true;
              currentState = currentReducer(currentState, action);
            } finally {
              isDispatching = false;
            }
            const listeners = currentListeners = nextListeners;
            listeners.forEach(listener => {
              listener();
            });
            return action;
          }
          function replaceReducer(nextReducer) {
            if (typeof nextReducer !== "function") {
              throw new Error(formatProdErrorMessage$1(10));
            }
            currentReducer = nextReducer;
            dispatch({
              type: actionTypes_default.REPLACE
            });
          }
          function observable() {
            const outerSubscribe = subscribe;
            return {
              /**
               * The minimal observable subscription method.
               * @param observer Any object that can be used as an observer.
               * The observer object should have a `next` method.
               * @returns An object with an `unsubscribe` method that can
               * be used to unsubscribe the observable from the store, and prevent further
               * emission of values from the observable.
               */
              subscribe(observer) {
                if (typeof observer !== "object" || observer === null) {
                  throw new Error(formatProdErrorMessage$1(11));
                }
                function observeState() {
                  const observerAsObserver = observer;
                  if (observerAsObserver.next) {
                    observerAsObserver.next(getState());
                  }
                }
                observeState();
                const unsubscribe = outerSubscribe(observeState);
                return {
                  unsubscribe
                };
              },
              [symbol_observable_default]() {
                return this;
              }
            };
          }
          dispatch({
            type: actionTypes_default.INIT
          });
          const store = {
            dispatch,
            subscribe,
            getState,
            replaceReducer,
            [symbol_observable_default]: observable
          };
          return store;
        }
        function assertReducerShape(reducers) {
          Object.keys(reducers).forEach(key => {
            const reducer = reducers[key];
            const initialState = reducer(void 0, {
              type: actionTypes_default.INIT
            });
            if (typeof initialState === "undefined") {
              throw new Error(formatProdErrorMessage$1(12));
            }
            if (typeof reducer(void 0, {
              type: actionTypes_default.PROBE_UNKNOWN_ACTION()
            }) === "undefined") {
              throw new Error(formatProdErrorMessage$1(13));
            }
          });
        }
        function combineReducers(reducers) {
          const reducerKeys = Object.keys(reducers);
          const finalReducers = {};
          for (let i = 0; i < reducerKeys.length; i++) {
            const key = reducerKeys[i];
            if (typeof reducers[key] === "function") {
              finalReducers[key] = reducers[key];
            }
          }
          const finalReducerKeys = Object.keys(finalReducers);
          let shapeAssertionError;
          try {
            assertReducerShape(finalReducers);
          } catch (e) {
            shapeAssertionError = e;
          }
          return function combination(state = {}, action) {
            if (shapeAssertionError) {
              throw shapeAssertionError;
            }
            let hasChanged = false;
            const nextState = {};
            for (let i = 0; i < finalReducerKeys.length; i++) {
              const key = finalReducerKeys[i];
              const reducer = finalReducers[key];
              const previousStateForKey = state[key];
              const nextStateForKey = reducer(previousStateForKey, action);
              if (typeof nextStateForKey === "undefined") {
                action && action.type;
                throw new Error(formatProdErrorMessage$1(14));
              }
              nextState[key] = nextStateForKey;
              hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
            }
            hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
            return hasChanged ? nextState : state;
          };
        }
        function compose(...funcs) {
          if (funcs.length === 0) {
            return arg => arg;
          }
          if (funcs.length === 1) {
            return funcs[0];
          }
          return funcs.reduce((a, b) => (...args) => a(b(...args)));
        }
        function applyMiddleware(...middlewares) {
          return createStore2 => (reducer, preloadedState) => {
            const store = createStore2(reducer, preloadedState);
            let dispatch = () => {
              throw new Error(formatProdErrorMessage$1(15));
            };
            const middlewareAPI = {
              getState: store.getState,
              dispatch: (action, ...args) => dispatch(action, ...args)
            };
            const chain = middlewares.map(middleware => middleware(middlewareAPI));
            dispatch = compose(...chain)(store.dispatch);
            return {
              ...store,
              dispatch
            };
          };
        }
        function isAction(action) {
          return isPlainObject$3(action) && "type" in action && typeof action.type === "string";
        }
        var NOTHING = Symbol.for("immer-nothing");
        var DRAFTABLE = Symbol.for("immer-draftable");
        var DRAFT_STATE = Symbol.for("immer-state");
        function die(error, ...args) {
          throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);
        }
        var getPrototypeOf = Object.getPrototypeOf;
        function isDraft(value) {
          return !!value && !!value[DRAFT_STATE];
        }
        function isDraftable(value) {
          if (!value) return false;
          return isPlainObject$2(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap$1(value) || isSet$1(value);
        }
        var objectCtorString = Object.prototype.constructor.toString();
        function isPlainObject$2(value) {
          if (!value || typeof value !== "object") return false;
          const proto = getPrototypeOf(value);
          if (proto === null) {
            return true;
          }
          const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
          if (Ctor === Object) return true;
          return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
        }
        function original(value) {
          if (!isDraft(value)) die(15, value);
          return value[DRAFT_STATE].base_;
        }
        function each(obj, iter) {
          if (getArchtype(obj) === 0) {
            Reflect.ownKeys(obj).forEach(key => {
              iter(key, obj[key], obj);
            });
          } else {
            obj.forEach((entry, index) => iter(index, entry, obj));
          }
        }
        function getArchtype(thing) {
          const state = thing[DRAFT_STATE];
          return state ? state.type_ : Array.isArray(thing) ? 1 : isMap$1(thing) ? 2 : isSet$1(thing) ? 3 : 0;
        }
        function has$1(thing, prop) {
          return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
        }
        function get$1(thing, prop) {
          return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
        }
        function set$1(thing, propOrOldValue, value) {
          const t = getArchtype(thing);
          if (t === 2) thing.set(propOrOldValue, value);else if (t === 3) {
            thing.add(value);
          } else thing[propOrOldValue] = value;
        }
        function is$1(x, y) {
          if (x === y) {
            return x !== 0 || 1 / x === 1 / y;
          } else {
            return x !== x && y !== y;
          }
        }
        function isMap$1(target) {
          return target instanceof Map;
        }
        function isSet$1(target) {
          return target instanceof Set;
        }
        function latest(state) {
          return state.copy_ || state.base_;
        }
        function shallowCopy$1(base, strict) {
          if (isMap$1(base)) {
            return new Map(base);
          }
          if (isSet$1(base)) {
            return new Set(base);
          }
          if (Array.isArray(base)) return Array.prototype.slice.call(base);
          const isPlain = isPlainObject$2(base);
          if (strict === true || strict === "class_only" && !isPlain) {
            const descriptors = Object.getOwnPropertyDescriptors(base);
            delete descriptors[DRAFT_STATE];
            let keys = Reflect.ownKeys(descriptors);
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const desc = descriptors[key];
              if (desc.writable === false) {
                desc.writable = true;
                desc.configurable = true;
              }
              if (desc.get || desc.set) descriptors[key] = {
                configurable: true,
                writable: true,
                // could live with !!desc.set as well here...
                enumerable: desc.enumerable,
                value: base[key]
              };
            }
            return Object.create(getPrototypeOf(base), descriptors);
          } else {
            const proto = getPrototypeOf(base);
            if (proto !== null && isPlain) {
              return {
                ...base
              };
            }
            const obj = Object.create(proto);
            return Object.assign(obj, base);
          }
        }
        function freeze(obj, deep = false) {
          if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
          if (getArchtype(obj) > 1) {
            Object.defineProperties(obj, {
              set: {
                value: dontMutateFrozenCollections
              },
              add: {
                value: dontMutateFrozenCollections
              },
              clear: {
                value: dontMutateFrozenCollections
              },
              delete: {
                value: dontMutateFrozenCollections
              }
            });
          }
          Object.freeze(obj);
          if (deep) Object.values(obj).forEach(value => freeze(value, true));
          return obj;
        }
        function dontMutateFrozenCollections() {
          die(2);
        }
        function isFrozen(obj) {
          return Object.isFrozen(obj);
        }
        var plugins = {};
        function getPlugin(pluginKey) {
          const plugin = plugins[pluginKey];
          if (!plugin) {
            die(0, pluginKey);
          }
          return plugin;
        }
        function loadPlugin(pluginKey, implementation) {
          if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
        }
        var currentScope;
        function getCurrentScope() {
          return currentScope;
        }
        function createScope(parent_, immer_) {
          return {
            drafts_: [],
            parent_,
            immer_,
            // Whenever the modified draft contains a draft from another scope, we
            // need to prevent auto-freezing so the unowned draft can be finalized.
            canAutoFreeze_: true,
            unfinalizedDrafts_: 0
          };
        }
        function usePatchesInScope(scope, patchListener) {
          if (patchListener) {
            getPlugin("Patches");
            scope.patches_ = [];
            scope.inversePatches_ = [];
            scope.patchListener_ = patchListener;
          }
        }
        function revokeScope(scope) {
          leaveScope(scope);
          scope.drafts_.forEach(revokeDraft);
          scope.drafts_ = null;
        }
        function leaveScope(scope) {
          if (scope === currentScope) {
            currentScope = scope.parent_;
          }
        }
        function enterScope(immer2) {
          return currentScope = createScope(currentScope, immer2);
        }
        function revokeDraft(draft) {
          const state = draft[DRAFT_STATE];
          if (state.type_ === 0 || state.type_ === 1) state.revoke_();else state.revoked_ = true;
        }
        function processResult(result, scope) {
          scope.unfinalizedDrafts_ = scope.drafts_.length;
          const baseDraft = scope.drafts_[0];
          const isReplaced = result !== void 0 && result !== baseDraft;
          if (isReplaced) {
            if (baseDraft[DRAFT_STATE].modified_) {
              revokeScope(scope);
              die(4);
            }
            if (isDraftable(result)) {
              result = finalize(scope, result);
              if (!scope.parent_) maybeFreeze(scope, result);
            }
            if (scope.patches_) {
              getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
            }
          } else {
            result = finalize(scope, baseDraft, []);
          }
          revokeScope(scope);
          if (scope.patches_) {
            scope.patchListener_(scope.patches_, scope.inversePatches_);
          }
          return result !== NOTHING ? result : void 0;
        }
        function finalize(rootScope, value, path) {
          if (isFrozen(value)) return value;
          const state = value[DRAFT_STATE];
          if (!state) {
            each(value, (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path));
            return value;
          }
          if (state.scope_ !== rootScope) return value;
          if (!state.modified_) {
            maybeFreeze(rootScope, state.base_, true);
            return state.base_;
          }
          if (!state.finalized_) {
            state.finalized_ = true;
            state.scope_.unfinalizedDrafts_--;
            const result = state.copy_;
            let resultEach = result;
            let isSet2 = false;
            if (state.type_ === 3) {
              resultEach = new Set(result);
              result.clear();
              isSet2 = true;
            }
            each(resultEach, (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2));
            maybeFreeze(rootScope, result, false);
            if (path && rootScope.patches_) {
              getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
            }
          }
          return state.copy_;
        }
        function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
          if (isDraft(childValue)) {
            const path = rootPath && parentState && parentState.type_ !== 3 &&
            // Set objects are atomic since they have no keys.
            !has$1(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
            const res = finalize(rootScope, childValue, path);
            set$1(targetObject, prop, res);
            if (isDraft(res)) {
              rootScope.canAutoFreeze_ = false;
            } else return;
          } else if (targetIsSet) {
            targetObject.add(childValue);
          }
          if (isDraftable(childValue) && !isFrozen(childValue)) {
            if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
              return;
            }
            finalize(rootScope, childValue);
            if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap$1(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop))) maybeFreeze(rootScope, childValue);
          }
        }
        function maybeFreeze(scope, value, deep = false) {
          if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
            freeze(value, deep);
          }
        }
        function createProxyProxy(base, parent) {
          const isArray = Array.isArray(base);
          const state = {
            type_: isArray ? 1 : 0,
            // Track which produce call this is associated with.
            scope_: parent ? parent.scope_ : getCurrentScope(),
            // True for both shallow and deep changes.
            modified_: false,
            // Used during finalization.
            finalized_: false,
            // Track which properties have been assigned (true) or deleted (false).
            assigned_: {},
            // The parent draft state.
            parent_: parent,
            // The base state.
            base_: base,
            // The base proxy.
            draft_: null,
            // set below
            // The base copy with any updated values.
            copy_: null,
            // Called by the `produce` function.
            revoke_: null,
            isManual_: false
          };
          let target = state;
          let traps = objectTraps;
          if (isArray) {
            target = [state];
            traps = arrayTraps;
          }
          const {
            revoke,
            proxy
          } = Proxy.revocable(target, traps);
          state.draft_ = proxy;
          state.revoke_ = revoke;
          return proxy;
        }
        var objectTraps = {
          get(state, prop) {
            if (prop === DRAFT_STATE) return state;
            const source = latest(state);
            if (!has$1(source, prop)) {
              return readPropFromProto(state, source, prop);
            }
            const value = source[prop];
            if (state.finalized_ || !isDraftable(value)) {
              return value;
            }
            if (value === peek(state.base_, prop)) {
              prepareCopy(state);
              return state.copy_[prop] = createProxy(value, state);
            }
            return value;
          },
          has(state, prop) {
            return prop in latest(state);
          },
          ownKeys(state) {
            return Reflect.ownKeys(latest(state));
          },
          set(state, prop, value) {
            const desc = getDescriptorFromProto(latest(state), prop);
            if (desc?.set) {
              desc.set.call(state.draft_, value);
              return true;
            }
            if (!state.modified_) {
              const current2 = peek(latest(state), prop);
              const currentState = current2?.[DRAFT_STATE];
              if (currentState && currentState.base_ === value) {
                state.copy_[prop] = value;
                state.assigned_[prop] = false;
                return true;
              }
              if (is$1(value, current2) && (value !== void 0 || has$1(state.base_, prop))) return true;
              prepareCopy(state);
              markChanged(state);
            }
            if (state.copy_[prop] === value && (
            // special case: handle new props with value 'undefined'
            value !== void 0 || prop in state.copy_) ||
            // special case: NaN
            Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;
            state.copy_[prop] = value;
            state.assigned_[prop] = true;
            return true;
          },
          deleteProperty(state, prop) {
            if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
              state.assigned_[prop] = false;
              prepareCopy(state);
              markChanged(state);
            } else {
              delete state.assigned_[prop];
            }
            if (state.copy_) {
              delete state.copy_[prop];
            }
            return true;
          },
          // Note: We never coerce `desc.value` into an Immer draft, because we can't make
          // the same guarantee in ES5 mode.
          getOwnPropertyDescriptor(state, prop) {
            const owner = latest(state);
            const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
            if (!desc) return desc;
            return {
              writable: true,
              configurable: state.type_ !== 1 || prop !== "length",
              enumerable: desc.enumerable,
              value: owner[prop]
            };
          },
          defineProperty() {
            die(11);
          },
          getPrototypeOf(state) {
            return getPrototypeOf(state.base_);
          },
          setPrototypeOf() {
            die(12);
          }
        };
        var arrayTraps = {};
        each(objectTraps, (key, fn) => {
          arrayTraps[key] = function () {
            arguments[0] = arguments[0][0];
            return fn.apply(this, arguments);
          };
        });
        arrayTraps.deleteProperty = function (state, prop) {
          return arrayTraps.set.call(this, state, prop, void 0);
        };
        arrayTraps.set = function (state, prop, value) {
          return objectTraps.set.call(this, state[0], prop, value, state[0]);
        };
        function peek(draft, prop) {
          const state = draft[DRAFT_STATE];
          const source = state ? latest(state) : draft;
          return source[prop];
        }
        function readPropFromProto(state, source, prop) {
          const desc = getDescriptorFromProto(source, prop);
          return desc ? `value` in desc ? desc.value :
          // This is a very special case, if the prop is a getter defined by the
          // prototype, we should invoke it with the draft as context!
          desc.get?.call(state.draft_) : void 0;
        }
        function getDescriptorFromProto(source, prop) {
          if (!(prop in source)) return void 0;
          let proto = getPrototypeOf(source);
          while (proto) {
            const desc = Object.getOwnPropertyDescriptor(proto, prop);
            if (desc) return desc;
            proto = getPrototypeOf(proto);
          }
          return void 0;
        }
        function markChanged(state) {
          if (!state.modified_) {
            state.modified_ = true;
            if (state.parent_) {
              markChanged(state.parent_);
            }
          }
        }
        function prepareCopy(state) {
          if (!state.copy_) {
            state.copy_ = shallowCopy$1(state.base_, state.scope_.immer_.useStrictShallowCopy_);
          }
        }
        var Immer2 = class {
          constructor(config) {
            this.autoFreeze_ = true;
            this.useStrictShallowCopy_ = false;
            this.produce = (base, recipe, patchListener) => {
              if (typeof base === "function" && typeof recipe !== "function") {
                const defaultBase = recipe;
                recipe = base;
                const self = this;
                return function curriedProduce(base2 = defaultBase, ...args) {
                  return self.produce(base2, draft => recipe.call(this, draft, ...args));
                };
              }
              if (typeof recipe !== "function") die(6);
              if (patchListener !== void 0 && typeof patchListener !== "function") die(7);
              let result;
              if (isDraftable(base)) {
                const scope = enterScope(this);
                const proxy = createProxy(base, void 0);
                let hasError = true;
                try {
                  result = recipe(proxy);
                  hasError = false;
                } finally {
                  if (hasError) revokeScope(scope);else leaveScope(scope);
                }
                usePatchesInScope(scope, patchListener);
                return processResult(result, scope);
              } else if (!base || typeof base !== "object") {
                result = recipe(base);
                if (result === void 0) result = base;
                if (result === NOTHING) result = void 0;
                if (this.autoFreeze_) freeze(result, true);
                if (patchListener) {
                  const p = [];
                  const ip = [];
                  getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
                  patchListener(p, ip);
                }
                return result;
              } else die(1, base);
            };
            this.produceWithPatches = (base, recipe) => {
              if (typeof base === "function") {
                return (state, ...args) => this.produceWithPatches(state, draft => base(draft, ...args));
              }
              let patches, inversePatches;
              const result = this.produce(base, recipe, (p, ip) => {
                patches = p;
                inversePatches = ip;
              });
              return [result, patches, inversePatches];
            };
            if (typeof config?.autoFreeze === "boolean") this.setAutoFreeze(config.autoFreeze);
            if (typeof config?.useStrictShallowCopy === "boolean") this.setUseStrictShallowCopy(config.useStrictShallowCopy);
          }
          createDraft(base) {
            if (!isDraftable(base)) die(8);
            if (isDraft(base)) base = current(base);
            const scope = enterScope(this);
            const proxy = createProxy(base, void 0);
            proxy[DRAFT_STATE].isManual_ = true;
            leaveScope(scope);
            return proxy;
          }
          finishDraft(draft, patchListener) {
            const state = draft && draft[DRAFT_STATE];
            if (!state || !state.isManual_) die(9);
            const {
              scope_: scope
            } = state;
            usePatchesInScope(scope, patchListener);
            return processResult(void 0, scope);
          }
          /**
           * Pass true to automatically freeze all copies created by Immer.
           *
           * By default, auto-freezing is enabled.
           */
          setAutoFreeze(value) {
            this.autoFreeze_ = value;
          }
          /**
           * Pass true to enable strict shallow copy.
           *
           * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
           */
          setUseStrictShallowCopy(value) {
            this.useStrictShallowCopy_ = value;
          }
          applyPatches(base, patches) {
            let i;
            for (i = patches.length - 1; i >= 0; i--) {
              const patch = patches[i];
              if (patch.path.length === 0 && patch.op === "replace") {
                base = patch.value;
                break;
              }
            }
            if (i > -1) {
              patches = patches.slice(i + 1);
            }
            const applyPatchesImpl = getPlugin("Patches").applyPatches_;
            if (isDraft(base)) {
              return applyPatchesImpl(base, patches);
            }
            return this.produce(base, draft => applyPatchesImpl(draft, patches));
          }
        };
        function createProxy(value, parent) {
          const draft = isMap$1(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet$1(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
          const scope = parent ? parent.scope_ : getCurrentScope();
          scope.drafts_.push(draft);
          return draft;
        }
        function current(value) {
          if (!isDraft(value)) die(10, value);
          return currentImpl(value);
        }
        function currentImpl(value) {
          if (!isDraftable(value) || isFrozen(value)) return value;
          const state = value[DRAFT_STATE];
          let copy;
          if (state) {
            if (!state.modified_) return state.base_;
            state.finalized_ = true;
            copy = shallowCopy$1(value, state.scope_.immer_.useStrictShallowCopy_);
          } else {
            copy = shallowCopy$1(value, true);
          }
          each(copy, (key, childValue) => {
            set$1(copy, key, currentImpl(childValue));
          });
          if (state) {
            state.finalized_ = false;
          }
          return copy;
        }
        function enablePatches() {
          const errorOffset = 16;
          const REPLACE = "replace";
          const ADD = "add";
          const REMOVE = "remove";
          function generatePatches_(state, basePath, patches, inversePatches) {
            switch (state.type_) {
              case 0:
              case 2:
                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
              case 1:
                return generateArrayPatches(state, basePath, patches, inversePatches);
              case 3:
                return generateSetPatches(state, basePath, patches, inversePatches);
            }
          }
          function generateArrayPatches(state, basePath, patches, inversePatches) {
            let {
              base_,
              assigned_
            } = state;
            let copy_ = state.copy_;
            if (copy_.length < base_.length) {
              [base_, copy_] = [copy_, base_];
              [patches, inversePatches] = [inversePatches, patches];
            }
            for (let i = 0; i < base_.length; i++) {
              if (assigned_[i] && copy_[i] !== base_[i]) {
                const path = basePath.concat([i]);
                patches.push({
                  op: REPLACE,
                  path,
                  // Need to maybe clone it, as it can in fact be the original value
                  // due to the base/copy inversion at the start of this function
                  value: clonePatchValueIfNeeded(copy_[i])
                });
                inversePatches.push({
                  op: REPLACE,
                  path,
                  value: clonePatchValueIfNeeded(base_[i])
                });
              }
            }
            for (let i = base_.length; i < copy_.length; i++) {
              const path = basePath.concat([i]);
              patches.push({
                op: ADD,
                path,
                // Need to maybe clone it, as it can in fact be the original value
                // due to the base/copy inversion at the start of this function
                value: clonePatchValueIfNeeded(copy_[i])
              });
            }
            for (let i = copy_.length - 1; base_.length <= i; --i) {
              const path = basePath.concat([i]);
              inversePatches.push({
                op: REMOVE,
                path
              });
            }
          }
          function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
            const {
              base_,
              copy_
            } = state;
            each(state.assigned_, (key, assignedValue) => {
              const origValue = get$1(base_, key);
              const value = get$1(copy_, key);
              const op = !assignedValue ? REMOVE : has$1(base_, key) ? REPLACE : ADD;
              if (origValue === value && op === REPLACE) return;
              const path = basePath.concat(key);
              patches.push(op === REMOVE ? {
                op,
                path
              } : {
                op,
                path,
                value
              });
              inversePatches.push(op === ADD ? {
                op: REMOVE,
                path
              } : op === REMOVE ? {
                op: ADD,
                path,
                value: clonePatchValueIfNeeded(origValue)
              } : {
                op: REPLACE,
                path,
                value: clonePatchValueIfNeeded(origValue)
              });
            });
          }
          function generateSetPatches(state, basePath, patches, inversePatches) {
            let {
              base_,
              copy_
            } = state;
            let i = 0;
            base_.forEach(value => {
              if (!copy_.has(value)) {
                const path = basePath.concat([i]);
                patches.push({
                  op: REMOVE,
                  path,
                  value
                });
                inversePatches.unshift({
                  op: ADD,
                  path,
                  value
                });
              }
              i++;
            });
            i = 0;
            copy_.forEach(value => {
              if (!base_.has(value)) {
                const path = basePath.concat([i]);
                patches.push({
                  op: ADD,
                  path,
                  value
                });
                inversePatches.unshift({
                  op: REMOVE,
                  path,
                  value
                });
              }
              i++;
            });
          }
          function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
            patches.push({
              op: REPLACE,
              path: [],
              value: replacement === NOTHING ? void 0 : replacement
            });
            inversePatches.push({
              op: REPLACE,
              path: [],
              value: baseValue
            });
          }
          function applyPatches_(draft, patches) {
            patches.forEach(patch => {
              const {
                path,
                op
              } = patch;
              let base = draft;
              for (let i = 0; i < path.length - 1; i++) {
                const parentType = getArchtype(base);
                let p = path[i];
                if (typeof p !== "string" && typeof p !== "number") {
                  p = "" + p;
                }
                if ((parentType === 0 || parentType === 1) && (p === "__proto__" || p === "constructor")) die(errorOffset + 3);
                if (typeof base === "function" && p === "prototype") die(errorOffset + 3);
                base = get$1(base, p);
                if (typeof base !== "object") die(errorOffset + 2, path.join("/"));
              }
              const type = getArchtype(base);
              const value = deepClonePatchValue(patch.value);
              const key = path[path.length - 1];
              switch (op) {
                case REPLACE:
                  switch (type) {
                    case 2:
                      return base.set(key, value);
                    case 3:
                      die(errorOffset);
                    default:
                      return base[key] = value;
                  }
                case ADD:
                  switch (type) {
                    case 1:
                      return key === "-" ? base.push(value) : base.splice(key, 0, value);
                    case 2:
                      return base.set(key, value);
                    case 3:
                      return base.add(value);
                    default:
                      return base[key] = value;
                  }
                case REMOVE:
                  switch (type) {
                    case 1:
                      return base.splice(key, 1);
                    case 2:
                      return base.delete(key);
                    case 3:
                      return base.delete(patch.value);
                    default:
                      return delete base[key];
                  }
                default:
                  die(errorOffset + 1, op);
              }
            });
            return draft;
          }
          function deepClonePatchValue(obj) {
            if (!isDraftable(obj)) return obj;
            if (Array.isArray(obj)) return obj.map(deepClonePatchValue);
            if (isMap$1(obj)) return new Map(Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)]));
            if (isSet$1(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
            const cloned = Object.create(getPrototypeOf(obj));
            for (const key in obj) cloned[key] = deepClonePatchValue(obj[key]);
            if (has$1(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
            return cloned;
          }
          function clonePatchValueIfNeeded(obj) {
            if (isDraft(obj)) {
              return deepClonePatchValue(obj);
            } else return obj;
          }
          loadPlugin("Patches", {
            applyPatches_,
            generatePatches_,
            generateReplacementPatches_
          });
        }
        var immer = new Immer2();
        var produce = immer.produce;
        var produceWithPatches = /* @__PURE__ */immer.produceWithPatches.bind(immer);
        var applyPatches = /* @__PURE__ */immer.applyPatches.bind(immer);
        function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
          if (typeof func !== "function") {
            throw new TypeError(errorMessage);
          }
        }
        function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
          if (typeof object !== "object") {
            throw new TypeError(errorMessage);
          }
        }
        function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
          if (!array.every(item => typeof item === "function")) {
            const itemTypes = array.map(item => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item).join(", ");
            throw new TypeError(`${errorMessage}[${itemTypes}]`);
          }
        }
        var ensureIsArray = item => {
          return Array.isArray(item) ? item : [item];
        };
        function getDependencies(createSelectorArgs) {
          const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
          assertIsArrayOfFunctions(dependencies, `createSelector expects all input-selectors to be functions, but received the following types: `);
          return dependencies;
        }
        function collectInputSelectorResults(dependencies, inputSelectorArgs) {
          const inputSelectorResults = [];
          const {
            length
          } = dependencies;
          for (let i = 0; i < length; i++) {
            inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
          }
          return inputSelectorResults;
        }
        var StrongRef = class {
          constructor(value) {
            this.value = value;
          }
          deref() {
            return this.value;
          }
        };
        var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
        var UNTERMINATED = 0;
        var TERMINATED = 1;
        function createCacheNode() {
          return {
            s: UNTERMINATED,
            v: void 0,
            o: null,
            p: null
          };
        }
        function weakMapMemoize(func, options = {}) {
          let fnNode = createCacheNode();
          const {
            resultEqualityCheck
          } = options;
          let lastResult;
          let resultsCount = 0;
          function memoized() {
            let cacheNode = fnNode;
            const {
              length
            } = arguments;
            for (let i = 0, l = length; i < l; i++) {
              const arg = arguments[i];
              if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
                let objectCache = cacheNode.o;
                if (objectCache === null) {
                  cacheNode.o = objectCache = /* @__PURE__ */new WeakMap();
                }
                const objectNode = objectCache.get(arg);
                if (objectNode === void 0) {
                  cacheNode = createCacheNode();
                  objectCache.set(arg, cacheNode);
                } else {
                  cacheNode = objectNode;
                }
              } else {
                let primitiveCache = cacheNode.p;
                if (primitiveCache === null) {
                  cacheNode.p = primitiveCache = /* @__PURE__ */new Map();
                }
                const primitiveNode = primitiveCache.get(arg);
                if (primitiveNode === void 0) {
                  cacheNode = createCacheNode();
                  primitiveCache.set(arg, cacheNode);
                } else {
                  cacheNode = primitiveNode;
                }
              }
            }
            const terminatedNode = cacheNode;
            let result;
            if (cacheNode.s === TERMINATED) {
              result = cacheNode.v;
            } else {
              result = func.apply(null, arguments);
              resultsCount++;
              if (resultEqualityCheck) {
                const lastResultValue = lastResult?.deref?.() ?? lastResult;
                if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
                  result = lastResultValue;
                  resultsCount !== 0 && resultsCount--;
                }
                const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
                lastResult = needsWeakRef ? new Ref(result) : result;
              }
            }
            terminatedNode.s = TERMINATED;
            terminatedNode.v = result;
            return result;
          }
          memoized.clearCache = () => {
            fnNode = createCacheNode();
            memoized.resetResultsCount();
          };
          memoized.resultsCount = () => resultsCount;
          memoized.resetResultsCount = () => {
            resultsCount = 0;
          };
          return memoized;
        }
        function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
          const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
            memoize: memoizeOrOptions,
            memoizeOptions: memoizeOptionsFromArgs
          } : memoizeOrOptions;
          const createSelector2 = (...createSelectorArgs) => {
            let recomputations = 0;
            let dependencyRecomputations = 0;
            let lastResult;
            let directlyPassedOptions = {};
            let resultFunc = createSelectorArgs.pop();
            if (typeof resultFunc === "object") {
              directlyPassedOptions = resultFunc;
              resultFunc = createSelectorArgs.pop();
            }
            assertIsFunction(resultFunc, `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`);
            const combinedOptions = {
              ...createSelectorCreatorOptions,
              ...directlyPassedOptions
            };
            const {
              memoize,
              memoizeOptions = [],
              argsMemoize = weakMapMemoize,
              argsMemoizeOptions = []
            } = combinedOptions;
            const finalMemoizeOptions = ensureIsArray(memoizeOptions);
            const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
            const dependencies = getDependencies(createSelectorArgs);
            const memoizedResultFunc = memoize(function recomputationWrapper() {
              recomputations++;
              return resultFunc.apply(null, arguments);
            }, ...finalMemoizeOptions);
            const selector = argsMemoize(function dependenciesChecker() {
              dependencyRecomputations++;
              const inputSelectorResults = collectInputSelectorResults(dependencies, arguments);
              lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
              return lastResult;
            }, ...finalArgsMemoizeOptions);
            return Object.assign(selector, {
              resultFunc,
              memoizedResultFunc,
              dependencies,
              dependencyRecomputations: () => dependencyRecomputations,
              resetDependencyRecomputations: () => {
                dependencyRecomputations = 0;
              },
              lastResult: () => lastResult,
              recomputations: () => recomputations,
              resetRecomputations: () => {
                recomputations = 0;
              },
              memoize,
              argsMemoize
            });
          };
          Object.assign(createSelector2, {
            withTypes: () => createSelector2
          });
          return createSelector2;
        }
        var createSelector = /* @__PURE__ */createSelectorCreator(weakMapMemoize);
        var createStructuredSelector = Object.assign((inputSelectorsObject, selectorCreator = createSelector) => {
          assertIsObject(inputSelectorsObject, `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`);
          const inputSelectorKeys = Object.keys(inputSelectorsObject);
          const dependencies = inputSelectorKeys.map(key => inputSelectorsObject[key]);
          const structuredSelector = selectorCreator(dependencies, (...inputSelectorResults) => {
            return inputSelectorResults.reduce((composition, value, index) => {
              composition[inputSelectorKeys[index]] = value;
              return composition;
            }, {});
          });
          return structuredSelector;
        }, {
          withTypes: () => createStructuredSelector
        });

        // src/index.ts
        function createThunkMiddleware(extraArgument) {
          const middleware = ({
            dispatch,
            getState
          }) => next => action => {
            if (typeof action === "function") {
              return action(dispatch, getState, extraArgument);
            }
            return next(action);
          };
          return middleware;
        }
        var thunk = createThunkMiddleware();
        var withExtraArgument = createThunkMiddleware;
        var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
          if (arguments.length === 0) return void 0;
          if (typeof arguments[0] === "object") return compose;
          return compose.apply(null, arguments);
        };
        var hasMatchFunction = v => {
          return v && typeof v.match === "function";
        };
        function createAction(type, prepareAction) {
          function actionCreator(...args) {
            if (prepareAction) {
              let prepared = prepareAction(...args);
              if (!prepared) {
                throw new Error(formatProdErrorMessage(0));
              }
              return {
                type,
                payload: prepared.payload,
                ...("meta" in prepared && {
                  meta: prepared.meta
                }),
                ...("error" in prepared && {
                  error: prepared.error
                })
              };
            }
            return {
              type,
              payload: args[0]
            };
          }
          actionCreator.toString = () => `${type}`;
          actionCreator.type = type;
          actionCreator.match = action => isAction(action) && action.type === type;
          return actionCreator;
        }
        var Tuple = class _Tuple extends Array {
          constructor(...items) {
            super(...items);
            Object.setPrototypeOf(this, _Tuple.prototype);
          }
          static get [Symbol.species]() {
            return _Tuple;
          }
          concat(...arr) {
            return super.concat.apply(this, arr);
          }
          prepend(...arr) {
            if (arr.length === 1 && Array.isArray(arr[0])) {
              return new _Tuple(...arr[0].concat(this));
            }
            return new _Tuple(...arr.concat(this));
          }
        };
        function freezeDraftable(val) {
          return isDraftable(val) ? produce(val, () => {}) : val;
        }
        function getOrInsertComputed$1(map, key, compute) {
          if (map.has(key)) return map.get(key);
          return map.set(key, compute(key)).get(key);
        }
        function isBoolean(x) {
          return typeof x === "boolean";
        }
        var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {
          const {
            thunk: thunk$1 = true,
            immutableCheck = true,
            serializableCheck = true,
            actionCreatorCheck = true
          } = options ?? {};
          let middlewareArray = new Tuple();
          if (thunk$1) {
            if (isBoolean(thunk$1)) {
              middlewareArray.push(thunk);
            } else {
              middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
            }
          }
          return middlewareArray;
        };
        var SHOULD_AUTOBATCH = "RTK_autoBatch";
        var prepareAutoBatched = () => payload => ({
          payload,
          meta: {
            [SHOULD_AUTOBATCH]: true
          }
        });
        var createQueueWithTimer = timeout => {
          return notify => {
            setTimeout(notify, timeout);
          };
        };
        var autoBatchEnhancer = (options = {
          type: "raf"
        }) => next => (...args) => {
          const store = next(...args);
          let notifying = true;
          let shouldNotifyAtEndOfTick = false;
          let notificationQueued = false;
          const listeners = /* @__PURE__ */new Set();
          const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ?
          // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
          typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10) : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
          const notifyListeners = () => {
            notificationQueued = false;
            if (shouldNotifyAtEndOfTick) {
              shouldNotifyAtEndOfTick = false;
              listeners.forEach(l => l());
            }
          };
          return Object.assign({}, store, {
            // Override the base `store.subscribe` method to keep original listeners
            // from running if we're delaying notifications
            subscribe(listener2) {
              const wrappedListener = () => notifying && listener2();
              const unsubscribe = store.subscribe(wrappedListener);
              listeners.add(listener2);
              return () => {
                unsubscribe();
                listeners.delete(listener2);
              };
            },
            // Override the base `store.dispatch` method so that we can check actions
            // for the `shouldAutoBatch` flag and determine if batching is active
            dispatch(action) {
              try {
                notifying = !action?.meta?.[SHOULD_AUTOBATCH];
                shouldNotifyAtEndOfTick = !notifying;
                if (shouldNotifyAtEndOfTick) {
                  if (!notificationQueued) {
                    notificationQueued = true;
                    queueCallback(notifyListeners);
                  }
                }
                return store.dispatch(action);
              } finally {
                notifying = true;
              }
            }
          });
        };
        var buildGetDefaultEnhancers = middlewareEnhancer => function getDefaultEnhancers(options) {
          const {
            autoBatch = true
          } = options ?? {};
          let enhancerArray = new Tuple(middlewareEnhancer);
          if (autoBatch) {
            enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
          }
          return enhancerArray;
        };
        function configureStore(options) {
          const getDefaultMiddleware = buildGetDefaultMiddleware();
          const {
            reducer = void 0,
            middleware,
            devTools = true,
            duplicateMiddlewareCheck = true,
            preloadedState = void 0,
            enhancers = void 0
          } = options || {};
          let rootReducer;
          if (typeof reducer === "function") {
            rootReducer = reducer;
          } else if (isPlainObject$3(reducer)) {
            rootReducer = combineReducers(reducer);
          } else {
            throw new Error(formatProdErrorMessage(1));
          }
          let finalMiddleware;
          if (typeof middleware === "function") {
            finalMiddleware = middleware(getDefaultMiddleware);
          } else {
            finalMiddleware = getDefaultMiddleware();
          }
          let finalCompose = compose;
          if (devTools) {
            finalCompose = composeWithDevTools({
              // Enable capture of stack traces for dispatched Redux actions
              trace: false,
              ...(typeof devTools === "object" && devTools)
            });
          }
          const middlewareEnhancer = applyMiddleware(...finalMiddleware);
          const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
          let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
          const composedEnhancer = finalCompose(...storeEnhancers);
          return createStore(rootReducer, preloadedState, composedEnhancer);
        }
        function executeReducerBuilderCallback(builderCallback) {
          const actionsMap = {};
          const actionMatchers = [];
          let defaultCaseReducer;
          const builder = {
            addCase(typeOrActionCreator, reducer) {
              const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
              if (!type) {
                throw new Error(formatProdErrorMessage(28));
              }
              if (type in actionsMap) {
                throw new Error(formatProdErrorMessage(29));
              }
              actionsMap[type] = reducer;
              return builder;
            },
            addAsyncThunk(asyncThunk, reducers) {
              if (reducers.pending) actionsMap[asyncThunk.pending.type] = reducers.pending;
              if (reducers.rejected) actionsMap[asyncThunk.rejected.type] = reducers.rejected;
              if (reducers.fulfilled) actionsMap[asyncThunk.fulfilled.type] = reducers.fulfilled;
              if (reducers.settled) actionMatchers.push({
                matcher: asyncThunk.settled,
                reducer: reducers.settled
              });
              return builder;
            },
            addMatcher(matcher, reducer) {
              actionMatchers.push({
                matcher,
                reducer
              });
              return builder;
            },
            addDefaultCase(reducer) {
              defaultCaseReducer = reducer;
              return builder;
            }
          };
          builderCallback(builder);
          return [actionsMap, actionMatchers, defaultCaseReducer];
        }
        function isStateFunction(x) {
          return typeof x === "function";
        }
        function createReducer(initialState, mapOrBuilderCallback) {
          let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
          let getInitialState;
          if (isStateFunction(initialState)) {
            getInitialState = () => freezeDraftable(initialState());
          } else {
            const frozenInitialState = freezeDraftable(initialState);
            getInitialState = () => frozenInitialState;
          }
          function reducer(state = getInitialState(), action) {
            let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
              matcher
            }) => matcher(action)).map(({
              reducer: reducer2
            }) => reducer2)];
            if (caseReducers.filter(cr => !!cr).length === 0) {
              caseReducers = [finalDefaultCaseReducer];
            }
            return caseReducers.reduce((previousState, caseReducer) => {
              if (caseReducer) {
                if (isDraft(previousState)) {
                  const draft = previousState;
                  const result = caseReducer(draft, action);
                  if (result === void 0) {
                    return previousState;
                  }
                  return result;
                } else if (!isDraftable(previousState)) {
                  const result = caseReducer(previousState, action);
                  if (result === void 0) {
                    if (previousState === null) {
                      return previousState;
                    }
                    throw Error("A case reducer on a non-draftable value must not return undefined");
                  }
                  return result;
                } else {
                  return produce(previousState, draft => {
                    return caseReducer(draft, action);
                  });
                }
              }
              return previousState;
            }, state);
          }
          reducer.getInitialState = getInitialState;
          return reducer;
        }
        var matches = (matcher, action) => {
          if (hasMatchFunction(matcher)) {
            return matcher.match(action);
          } else {
            return matcher(action);
          }
        };
        function isAnyOf(...matchers) {
          return action => {
            return matchers.some(matcher => matches(matcher, action));
          };
        }
        function isAllOf(...matchers) {
          return action => {
            return matchers.every(matcher => matches(matcher, action));
          };
        }
        function hasExpectedRequestMetadata(action, validStatus) {
          if (!action || !action.meta) return false;
          const hasValidRequestId = typeof action.meta.requestId === "string";
          const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
          return hasValidRequestId && hasValidRequestStatus;
        }
        function isAsyncThunkArray(a) {
          return typeof a[0] === "function" && "pending" in a[0] && "fulfilled" in a[0] && "rejected" in a[0];
        }
        function isPending(...asyncThunks) {
          if (asyncThunks.length === 0) {
            return action => hasExpectedRequestMetadata(action, ["pending"]);
          }
          if (!isAsyncThunkArray(asyncThunks)) {
            return isPending()(asyncThunks[0]);
          }
          return isAnyOf(...asyncThunks.map(asyncThunk => asyncThunk.pending));
        }
        function isRejected(...asyncThunks) {
          if (asyncThunks.length === 0) {
            return action => hasExpectedRequestMetadata(action, ["rejected"]);
          }
          if (!isAsyncThunkArray(asyncThunks)) {
            return isRejected()(asyncThunks[0]);
          }
          return isAnyOf(...asyncThunks.map(asyncThunk => asyncThunk.rejected));
        }
        function isRejectedWithValue(...asyncThunks) {
          const hasFlag = action => {
            return action && action.meta && action.meta.rejectedWithValue;
          };
          if (asyncThunks.length === 0) {
            return isAllOf(isRejected(...asyncThunks), hasFlag);
          }
          if (!isAsyncThunkArray(asyncThunks)) {
            return isRejectedWithValue()(asyncThunks[0]);
          }
          return isAllOf(isRejected(...asyncThunks), hasFlag);
        }
        function isFulfilled(...asyncThunks) {
          if (asyncThunks.length === 0) {
            return action => hasExpectedRequestMetadata(action, ["fulfilled"]);
          }
          if (!isAsyncThunkArray(asyncThunks)) {
            return isFulfilled()(asyncThunks[0]);
          }
          return isAnyOf(...asyncThunks.map(asyncThunk => asyncThunk.fulfilled));
        }
        function isAsyncThunkAction(...asyncThunks) {
          if (asyncThunks.length === 0) {
            return action => hasExpectedRequestMetadata(action, ["pending", "fulfilled", "rejected"]);
          }
          if (!isAsyncThunkArray(asyncThunks)) {
            return isAsyncThunkAction()(asyncThunks[0]);
          }
          return isAnyOf(...asyncThunks.flatMap(asyncThunk => [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled]));
        }
        var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
        var nanoid = (size = 21) => {
          let id = "";
          let i = size;
          while (i--) {
            id += urlAlphabet[Math.random() * 64 | 0];
          }
          return id;
        };
        var commonProperties = ["name", "message", "stack", "code"];
        var RejectWithValue = class {
          constructor(payload, meta) {
            this.payload = payload;
            this.meta = meta;
          }
          /*
          type-only property to distinguish between RejectWithValue and FulfillWithMeta
          does not exist at runtime
          */
          _type;
        };
        var FulfillWithMeta = class {
          constructor(payload, meta) {
            this.payload = payload;
            this.meta = meta;
          }
          /*
          type-only property to distinguish between RejectWithValue and FulfillWithMeta
          does not exist at runtime
          */
          _type;
        };
        var miniSerializeError = value => {
          if (typeof value === "object" && value !== null) {
            const simpleError = {};
            for (const property of commonProperties) {
              if (typeof value[property] === "string") {
                simpleError[property] = value[property];
              }
            }
            return simpleError;
          }
          return {
            message: String(value)
          };
        };
        var externalAbortMessage = "External signal was aborted";
        var createAsyncThunk = /* @__PURE__ */(() => {
          function createAsyncThunk2(typePrefix, payloadCreator, options) {
            const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta) => ({
              payload,
              meta: {
                ...(meta || {}),
                arg,
                requestId,
                requestStatus: "fulfilled"
              }
            }));
            const pending = createAction(typePrefix + "/pending", (requestId, arg, meta) => ({
              payload: void 0,
              meta: {
                ...(meta || {}),
                arg,
                requestId,
                requestStatus: "pending"
              }
            }));
            const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta) => ({
              payload,
              error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
              meta: {
                ...(meta || {}),
                arg,
                requestId,
                rejectedWithValue: !!payload,
                requestStatus: "rejected",
                aborted: error?.name === "AbortError",
                condition: error?.name === "ConditionError"
              }
            }));
            function actionCreator(arg, {
              signal
            } = {}) {
              return (dispatch, getState, extra) => {
                const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();
                const abortController = new AbortController();
                let abortHandler;
                let abortReason;
                function abort(reason) {
                  abortReason = reason;
                  abortController.abort();
                }
                if (signal) {
                  if (signal.aborted) {
                    abort(externalAbortMessage);
                  } else {
                    signal.addEventListener("abort", () => abort(externalAbortMessage), {
                      once: true
                    });
                  }
                }
                const promise = async function () {
                  let finalAction;
                  try {
                    let conditionResult = options?.condition?.(arg, {
                      getState,
                      extra
                    });
                    if (isThenable(conditionResult)) {
                      conditionResult = await conditionResult;
                    }
                    if (conditionResult === false || abortController.signal.aborted) {
                      throw {
                        name: "ConditionError",
                        message: "Aborted due to condition callback returning false."
                      };
                    }
                    const abortedPromise = new Promise((_, reject) => {
                      abortHandler = () => {
                        reject({
                          name: "AbortError",
                          message: abortReason || "Aborted"
                        });
                      };
                      abortController.signal.addEventListener("abort", abortHandler);
                    });
                    dispatch(pending(requestId, arg, options?.getPendingMeta?.({
                      requestId,
                      arg
                    }, {
                      getState,
                      extra
                    })));
                    finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
                      dispatch,
                      getState,
                      extra,
                      requestId,
                      signal: abortController.signal,
                      abort,
                      rejectWithValue: (value, meta) => {
                        return new RejectWithValue(value, meta);
                      },
                      fulfillWithValue: (value, meta) => {
                        return new FulfillWithMeta(value, meta);
                      }
                    })).then(result => {
                      if (result instanceof RejectWithValue) {
                        throw result;
                      }
                      if (result instanceof FulfillWithMeta) {
                        return fulfilled(result.payload, requestId, arg, result.meta);
                      }
                      return fulfilled(result, requestId, arg);
                    })]);
                  } catch (err) {
                    finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
                  } finally {
                    if (abortHandler) {
                      abortController.signal.removeEventListener("abort", abortHandler);
                    }
                  }
                  const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                  if (!skipDispatch) {
                    dispatch(finalAction);
                  }
                  return finalAction;
                }();
                return Object.assign(promise, {
                  abort,
                  requestId,
                  arg,
                  unwrap() {
                    return promise.then(unwrapResult);
                  }
                });
              };
            }
            return Object.assign(actionCreator, {
              pending,
              rejected,
              fulfilled,
              settled: isAnyOf(rejected, fulfilled),
              typePrefix
            });
          }
          createAsyncThunk2.withTypes = () => createAsyncThunk2;
          return createAsyncThunk2;
        })();
        function unwrapResult(action) {
          if (action.meta && action.meta.rejectedWithValue) {
            throw action.payload;
          }
          if (action.error) {
            throw action.error;
          }
          return action.payload;
        }
        function isThenable(value) {
          return value !== null && typeof value === "object" && typeof value.then === "function";
        }
        var asyncThunkSymbol = /* @__PURE__ */Symbol.for("rtk-slice-createasyncthunk");
        function getType(slice, actionKey) {
          return `${slice}/${actionKey}`;
        }
        function buildCreateSlice({
          creators
        } = {}) {
          const cAT = creators?.asyncThunk?.[asyncThunkSymbol];
          return function createSlice2(options) {
            const {
              name,
              reducerPath = name
            } = options;
            if (!name) {
              throw new Error(formatProdErrorMessage(11));
            }
            const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
            const reducerNames = Object.keys(reducers);
            const context = {
              sliceCaseReducersByName: {},
              sliceCaseReducersByType: {},
              actionCreators: {},
              sliceMatchers: []
            };
            const contextMethods = {
              addCase(typeOrActionCreator, reducer2) {
                const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
                if (!type) {
                  throw new Error(formatProdErrorMessage(12));
                }
                if (type in context.sliceCaseReducersByType) {
                  throw new Error(formatProdErrorMessage(13));
                }
                context.sliceCaseReducersByType[type] = reducer2;
                return contextMethods;
              },
              addMatcher(matcher, reducer2) {
                context.sliceMatchers.push({
                  matcher,
                  reducer: reducer2
                });
                return contextMethods;
              },
              exposeAction(name2, actionCreator) {
                context.actionCreators[name2] = actionCreator;
                return contextMethods;
              },
              exposeCaseReducer(name2, reducer2) {
                context.sliceCaseReducersByName[name2] = reducer2;
                return contextMethods;
              }
            };
            reducerNames.forEach(reducerName => {
              const reducerDefinition = reducers[reducerName];
              const reducerDetails = {
                reducerName,
                type: getType(name, reducerName),
                createNotation: typeof options.reducers === "function"
              };
              if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
                handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
              } else {
                handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
              }
            });
            function buildReducer() {
              const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
              const finalCaseReducers = {
                ...extraReducers,
                ...context.sliceCaseReducersByType
              };
              return createReducer(options.initialState, builder => {
                for (let key in finalCaseReducers) {
                  builder.addCase(key, finalCaseReducers[key]);
                }
                for (let sM of context.sliceMatchers) {
                  builder.addMatcher(sM.matcher, sM.reducer);
                }
                for (let m of actionMatchers) {
                  builder.addMatcher(m.matcher, m.reducer);
                }
                if (defaultCaseReducer) {
                  builder.addDefaultCase(defaultCaseReducer);
                }
              });
            }
            const selectSelf = state => state;
            const injectedSelectorCache = /* @__PURE__ */new Map();
            const injectedStateCache = /* @__PURE__ */new WeakMap();
            let _reducer;
            function reducer(state, action) {
              if (!_reducer) _reducer = buildReducer();
              return _reducer(state, action);
            }
            function getInitialState() {
              if (!_reducer) _reducer = buildReducer();
              return _reducer.getInitialState();
            }
            function makeSelectorProps(reducerPath2, injected = false) {
              function selectSlice(state) {
                let sliceState = state[reducerPath2];
                if (typeof sliceState === "undefined") {
                  if (injected) {
                    sliceState = getOrInsertComputed$1(injectedStateCache, selectSlice, getInitialState);
                  }
                }
                return sliceState;
              }
              function getSelectors(selectState = selectSelf) {
                const selectorCache = getOrInsertComputed$1(injectedSelectorCache, injected, () => /* @__PURE__ */new WeakMap());
                return getOrInsertComputed$1(selectorCache, selectState, () => {
                  const map = {};
                  for (const [name2, selector] of Object.entries(options.selectors ?? {})) {
                    map[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed$1(injectedStateCache, selectState, getInitialState), injected);
                  }
                  return map;
                });
              }
              return {
                reducerPath: reducerPath2,
                getSelectors,
                get selectors() {
                  return getSelectors(selectSlice);
                },
                selectSlice
              };
            }
            const slice = {
              name,
              reducer,
              actions: context.actionCreators,
              caseReducers: context.sliceCaseReducersByName,
              getInitialState,
              ...makeSelectorProps(reducerPath),
              injectInto(injectable, {
                reducerPath: pathOpt,
                ...config
              } = {}) {
                const newReducerPath = pathOpt ?? reducerPath;
                injectable.inject({
                  reducerPath: newReducerPath,
                  reducer
                }, config);
                return {
                  ...slice,
                  ...makeSelectorProps(newReducerPath, true)
                };
              }
            };
            return slice;
          };
        }
        function wrapSelector(selector, selectState, getInitialState, injected) {
          function wrapper(rootState, ...args) {
            let sliceState = selectState(rootState);
            if (typeof sliceState === "undefined") {
              if (injected) {
                sliceState = getInitialState();
              }
            }
            return selector(sliceState, ...args);
          }
          wrapper.unwrapped = selector;
          return wrapper;
        }
        var createSlice = exports("G", /* @__PURE__ */buildCreateSlice());
        function buildReducerCreators() {
          function asyncThunk(payloadCreator, config) {
            return {
              _reducerDefinitionType: "asyncThunk",
              payloadCreator,
              ...config
            };
          }
          asyncThunk.withTypes = () => asyncThunk;
          return {
            reducer(caseReducer) {
              return Object.assign({
                // hack so the wrapping function has the same name as the original
                // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
                [caseReducer.name](...args) {
                  return caseReducer(...args);
                }
              }[caseReducer.name], {
                _reducerDefinitionType: "reducer"
                /* reducer */
              });
            },
            preparedReducer(prepare, reducer) {
              return {
                _reducerDefinitionType: "reducerWithPrepare",
                prepare,
                reducer
              };
            },
            asyncThunk
          };
        }
        function handleNormalReducerDefinition({
          type,
          reducerName,
          createNotation
        }, maybeReducerWithPrepare, context) {
          let caseReducer;
          let prepareCallback;
          if ("reducer" in maybeReducerWithPrepare) {
            if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
              throw new Error(formatProdErrorMessage(17));
            }
            caseReducer = maybeReducerWithPrepare.reducer;
            prepareCallback = maybeReducerWithPrepare.prepare;
          } else {
            caseReducer = maybeReducerWithPrepare;
          }
          context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
        }
        function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
          return reducerDefinition._reducerDefinitionType === "asyncThunk";
        }
        function isCaseReducerWithPrepareDefinition(reducerDefinition) {
          return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
        }
        function handleThunkCaseReducerDefinition({
          type,
          reducerName
        }, reducerDefinition, context, cAT) {
          if (!cAT) {
            throw new Error(formatProdErrorMessage(18));
          }
          const {
            payloadCreator,
            fulfilled,
            pending,
            rejected,
            settled,
            options
          } = reducerDefinition;
          const thunk = cAT(type, payloadCreator, options);
          context.exposeAction(reducerName, thunk);
          if (fulfilled) {
            context.addCase(thunk.fulfilled, fulfilled);
          }
          if (pending) {
            context.addCase(thunk.pending, pending);
          }
          if (rejected) {
            context.addCase(thunk.rejected, rejected);
          }
          if (settled) {
            context.addMatcher(thunk.settled, settled);
          }
          context.exposeCaseReducer(reducerName, {
            fulfilled: fulfilled || noop$1,
            pending: pending || noop$1,
            rejected: rejected || noop$1,
            settled: settled || noop$1
          });
        }
        function noop$1() {}
        function formatProdErrorMessage(code) {
          return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
        }

        // src/getDotPath/getDotPath.ts

        // src/SchemaError/SchemaError.ts
        var SchemaError = class extends Error {
          /**
           * The schema issues.
           */
          issues;
          /**
           * Creates a schema error with useful information.
           *
           * @param issues The schema issues.
           */
          constructor(issues) {
            super(issues[0].message);
            this.name = "SchemaError";
            this.issues = issues;
          }
        };
        var QueryStatus = /* @__PURE__ */(QueryStatus2 => {
          QueryStatus2["uninitialized"] = "uninitialized";
          QueryStatus2["pending"] = "pending";
          QueryStatus2["fulfilled"] = "fulfilled";
          QueryStatus2["rejected"] = "rejected";
          return QueryStatus2;
        })(QueryStatus || {});
        function getRequestStatusFlags(status) {
          return {
            status,
            isUninitialized: status === "uninitialized",
            isLoading: status === "pending",
            isSuccess: status === "fulfilled",
            isError: status === "rejected"
            /* rejected */
          };
        }
        var isPlainObject2 = isPlainObject$3;
        function copyWithStructuralSharing(oldObj, newObj) {
          if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {
            return newObj;
          }
          const newKeys = Object.keys(newObj);
          const oldKeys = Object.keys(oldObj);
          let isSameObject = newKeys.length === oldKeys.length;
          const mergeObj = Array.isArray(newObj) ? [] : {};
          for (const key of newKeys) {
            mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);
            if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];
          }
          return isSameObject ? oldObj : mergeObj;
        }
        function countObjectKeys(obj) {
          let count = 0;
          for (const _key in obj) {
            count++;
          }
          return count;
        }
        var flatten = arr => [].concat(...arr);
        function isAbsoluteUrl(url) {
          return new RegExp(`(^|:)//`).test(url);
        }
        function isDocumentVisible() {
          if (typeof document === "undefined") {
            return true;
          }
          return document.visibilityState !== "hidden";
        }
        function isNotNullish(v) {
          return v != null;
        }
        function isOnline() {
          return typeof navigator === "undefined" ? true : navigator.onLine === void 0 ? true : navigator.onLine;
        }
        var withoutTrailingSlash = url => url.replace(/\/$/, "");
        var withoutLeadingSlash = url => url.replace(/^\//, "");
        function joinUrls(base, url) {
          if (!base) {
            return url;
          }
          if (!url) {
            return base;
          }
          if (isAbsoluteUrl(url)) {
            return url;
          }
          const delimiter = base.endsWith("/") || !url.startsWith("?") ? "/" : "";
          base = withoutTrailingSlash(base);
          url = withoutLeadingSlash(url);
          return `${base}${delimiter}${url}`;
        }
        function getOrInsert(map, key, value) {
          if (map.has(key)) return map.get(key);
          return map.set(key, value).get(key);
        }
        function getOrInsertComputed(map, key, compute) {
          if (map.has(key)) return map.get(key);
          return map.set(key, compute(key)).get(key);
        }
        var createNewMap = () => /* @__PURE__ */new Map();
        var defaultFetchFn = (...args) => fetch(...args);
        var defaultValidateStatus = response => response.status >= 200 && response.status <= 299;
        var defaultIsJsonContentType = headers => (/*applicat*/
        /ion\/(vnd\.api\+)?json/.test(headers.get("content-type") || ""));
        function stripUndefined(obj) {
          if (!isPlainObject$3(obj)) {
            return obj;
          }
          const copy = {
            ...obj
          };
          for (const [k, v] of Object.entries(copy)) {
            if (v === void 0) delete copy[k];
          }
          return copy;
        }
        function fetchBaseQuery({
          baseUrl,
          prepareHeaders = x => x,
          fetchFn = defaultFetchFn,
          paramsSerializer,
          isJsonContentType = defaultIsJsonContentType,
          jsonContentType = "application/json",
          jsonReplacer,
          timeout: defaultTimeout,
          responseHandler: globalResponseHandler,
          validateStatus: globalValidateStatus,
          ...baseFetchOptions
        } = {}) {
          if (typeof fetch === "undefined" && fetchFn === defaultFetchFn) {
            console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.");
          }
          return async (arg, api, extraOptions) => {
            const {
              getState,
              extra,
              endpoint,
              forced,
              type
            } = api;
            let meta;
            let {
              url,
              headers = new Headers(baseFetchOptions.headers),
              params = void 0,
              responseHandler = globalResponseHandler ?? "json",
              validateStatus = globalValidateStatus ?? defaultValidateStatus,
              timeout = defaultTimeout,
              ...rest
            } = typeof arg == "string" ? {
              url: arg
            } : arg;
            let abortController,
              signal = api.signal;
            if (timeout) {
              abortController = new AbortController();
              api.signal.addEventListener("abort", abortController.abort);
              signal = abortController.signal;
            }
            let config = {
              ...baseFetchOptions,
              signal,
              ...rest
            };
            headers = new Headers(stripUndefined(headers));
            config.headers = (await prepareHeaders(headers, {
              getState,
              arg,
              extra,
              endpoint,
              forced,
              type,
              extraOptions
            })) || headers;
            const isJsonifiable = body => typeof body === "object" && (isPlainObject$3(body) || Array.isArray(body) || typeof body.toJSON === "function");
            if (!config.headers.has("content-type") && isJsonifiable(config.body)) {
              config.headers.set("content-type", jsonContentType);
            }
            if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {
              config.body = JSON.stringify(config.body, jsonReplacer);
            }
            if (params) {
              const divider = ~url.indexOf("?") ? "&" : "?";
              const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));
              url += divider + query;
            }
            url = joinUrls(baseUrl, url);
            const request = new Request(url, config);
            const requestClone = new Request(url, config);
            meta = {
              request: requestClone
            };
            let response,
              timedOut = false,
              timeoutId = abortController && setTimeout(() => {
                timedOut = true;
                abortController.abort();
              }, timeout);
            try {
              response = await fetchFn(request);
            } catch (e) {
              return {
                error: {
                  status: timedOut ? "TIMEOUT_ERROR" : "FETCH_ERROR",
                  error: String(e)
                },
                meta
              };
            } finally {
              if (timeoutId) clearTimeout(timeoutId);
              abortController?.signal.removeEventListener("abort", abortController.abort);
            }
            const responseClone = response.clone();
            meta.response = responseClone;
            let resultData;
            let responseText = "";
            try {
              let handleResponseError;
              await Promise.all([handleResponse(response, responseHandler).then(r => resultData = r, e => handleResponseError = e),
              // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182
              // we *have* to "use up" both streams at the same time or they will stop running in node-fetch scenarios
              responseClone.text().then(r => responseText = r, () => {})]);
              if (handleResponseError) throw handleResponseError;
            } catch (e) {
              return {
                error: {
                  status: "PARSING_ERROR",
                  originalStatus: response.status,
                  data: responseText,
                  error: String(e)
                },
                meta
              };
            }
            return validateStatus(response, resultData) ? {
              data: resultData,
              meta
            } : {
              error: {
                status: response.status,
                data: resultData
              },
              meta
            };
          };
          async function handleResponse(response, responseHandler) {
            if (typeof responseHandler === "function") {
              return responseHandler(response);
            }
            if (responseHandler === "content-type") {
              responseHandler = isJsonContentType(response.headers) ? "json" : "text";
            }
            if (responseHandler === "json") {
              const text = await response.text();
              return text.length ? JSON.parse(text) : null;
            }
            return response.text();
          }
        }
        var HandledError = class {
          constructor(value, meta = void 0) {
            this.value = value;
            this.meta = meta;
          }
        };
        var onFocus = /* @__PURE__ */createAction("__rtkq/focused");
        var onFocusLost = /* @__PURE__ */createAction("__rtkq/unfocused");
        var onOnline = /* @__PURE__ */createAction("__rtkq/online");
        var onOffline = /* @__PURE__ */createAction("__rtkq/offline");
        function isQueryDefinition$1(e) {
          return e.type === "query";
        }
        function isMutationDefinition$1(e) {
          return e.type === "mutation";
        }
        function isInfiniteQueryDefinition$1(e) {
          return e.type === "infinitequery";
        }
        function isAnyQueryDefinition(e) {
          return isQueryDefinition$1(e) || isInfiniteQueryDefinition$1(e);
        }
        function calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {
          if (isFunction$1(description)) {
            return description(result, error, queryArg, meta).filter(isNotNullish).map(expandTagDescription).map(assertTagTypes);
          }
          if (Array.isArray(description)) {
            return description.map(expandTagDescription).map(assertTagTypes);
          }
          return [];
        }
        function isFunction$1(t) {
          return typeof t === "function";
        }
        function expandTagDescription(description) {
          return typeof description === "string" ? {
            type: description
          } : description;
        }
        function asSafePromise(promise, fallback) {
          return promise.catch(fallback);
        }
        var forceQueryFnSymbol = Symbol("forceQueryFn");
        var isUpsertQuery = arg => typeof arg[forceQueryFnSymbol] === "function";
        function buildInitiate({
          serializeQueryArgs,
          queryThunk,
          infiniteQueryThunk,
          mutationThunk,
          api,
          context,
          internalState
        }) {
          const {
            runningQueries,
            runningMutations
          } = internalState;
          const {
            unsubscribeQueryResult,
            removeMutationResult,
            updateSubscriptionOptions
          } = api.internalActions;
          return {
            buildInitiateQuery,
            buildInitiateInfiniteQuery,
            buildInitiateMutation,
            getRunningQueryThunk,
            getRunningMutationThunk,
            getRunningQueriesThunk,
            getRunningMutationsThunk
          };
          function getRunningQueryThunk(endpointName, queryArgs) {
            return dispatch => {
              const endpointDefinition = context.endpointDefinitions[endpointName];
              const queryCacheKey = serializeQueryArgs({
                queryArgs,
                endpointDefinition,
                endpointName
              });
              return runningQueries.get(dispatch)?.[queryCacheKey];
            };
          }
          function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {
            return dispatch => {
              return runningMutations.get(dispatch)?.[fixedCacheKeyOrRequestId];
            };
          }
          function getRunningQueriesThunk() {
            return dispatch => Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);
          }
          function getRunningMutationsThunk() {
            return dispatch => Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);
          }
          function buildInitiateAnyQuery(endpointName, endpointDefinition) {
            const queryAction = (arg, {
              subscribe = true,
              forceRefetch,
              subscriptionOptions,
              [forceQueryFnSymbol]: forceQueryFn,
              ...rest
            } = {}) => (dispatch, getState) => {
              const queryCacheKey = serializeQueryArgs({
                queryArgs: arg,
                endpointDefinition,
                endpointName
              });
              let thunk;
              const commonThunkArgs = {
                ...rest,
                type: "query",
                subscribe,
                forceRefetch,
                subscriptionOptions,
                endpointName,
                originalArgs: arg,
                queryCacheKey,
                [forceQueryFnSymbol]: forceQueryFn
              };
              if (isQueryDefinition$1(endpointDefinition)) {
                thunk = queryThunk(commonThunkArgs);
              } else {
                const {
                  direction,
                  initialPageParam
                } = rest;
                thunk = infiniteQueryThunk({
                  ...commonThunkArgs,
                  // Supply these even if undefined. This helps with a field existence
                  // check over in `buildSlice.ts`
                  direction,
                  initialPageParam
                });
              }
              const selector = api.endpoints[endpointName].select(arg);
              const thunkResult = dispatch(thunk);
              const stateAfter = selector(getState());
              const {
                requestId,
                abort
              } = thunkResult;
              const skippedSynchronously = stateAfter.requestId !== requestId;
              const runningQuery = runningQueries.get(dispatch)?.[queryCacheKey];
              const selectFromState = () => selector(getState());
              const statePromise = Object.assign(forceQueryFn ?
              // a query has been forced (upsertQueryData)
              // -> we want to resolve it once data has been written with the data that will be written
              thunkResult.then(selectFromState) : skippedSynchronously && !runningQuery ?
              // a query has been skipped due to a condition and we do not have any currently running query
              // -> we want to resolve it immediately with the current data
              Promise.resolve(stateAfter) :
              // query just started or one is already in flight
              // -> wait for the running query, then resolve with data from after that
              Promise.all([runningQuery, thunkResult]).then(selectFromState), {
                arg,
                requestId,
                subscriptionOptions,
                queryCacheKey,
                abort,
                async unwrap() {
                  const result = await statePromise;
                  if (result.isError) {
                    throw result.error;
                  }
                  return result.data;
                },
                refetch: () => dispatch(queryAction(arg, {
                  subscribe: false,
                  forceRefetch: true
                })),
                unsubscribe() {
                  if (subscribe) dispatch(unsubscribeQueryResult({
                    queryCacheKey,
                    requestId
                  }));
                },
                updateSubscriptionOptions(options) {
                  statePromise.subscriptionOptions = options;
                  dispatch(updateSubscriptionOptions({
                    endpointName,
                    requestId,
                    queryCacheKey,
                    options
                  }));
                }
              });
              if (!runningQuery && !skippedSynchronously && !forceQueryFn) {
                const running = getOrInsert(runningQueries, dispatch, {});
                running[queryCacheKey] = statePromise;
                statePromise.then(() => {
                  delete running[queryCacheKey];
                  if (!countObjectKeys(running)) {
                    runningQueries.delete(dispatch);
                  }
                });
              }
              return statePromise;
            };
            return queryAction;
          }
          function buildInitiateQuery(endpointName, endpointDefinition) {
            const queryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
            return queryAction;
          }
          function buildInitiateInfiniteQuery(endpointName, endpointDefinition) {
            const infiniteQueryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
            return infiniteQueryAction;
          }
          function buildInitiateMutation(endpointName) {
            return (arg, {
              track = true,
              fixedCacheKey
            } = {}) => (dispatch, getState) => {
              const thunk = mutationThunk({
                type: "mutation",
                endpointName,
                originalArgs: arg,
                track,
                fixedCacheKey
              });
              const thunkResult = dispatch(thunk);
              const {
                requestId,
                abort,
                unwrap
              } = thunkResult;
              const returnValuePromise = asSafePromise(thunkResult.unwrap().then(data => ({
                data
              })), error => ({
                error
              }));
              const reset = () => {
                dispatch(removeMutationResult({
                  requestId,
                  fixedCacheKey
                }));
              };
              const ret = Object.assign(returnValuePromise, {
                arg: thunkResult.arg,
                requestId,
                abort,
                unwrap,
                reset
              });
              const running = runningMutations.get(dispatch) || {};
              runningMutations.set(dispatch, running);
              running[requestId] = ret;
              ret.then(() => {
                delete running[requestId];
                if (!countObjectKeys(running)) {
                  runningMutations.delete(dispatch);
                }
              });
              if (fixedCacheKey) {
                running[fixedCacheKey] = ret;
                ret.then(() => {
                  if (running[fixedCacheKey] === ret) {
                    delete running[fixedCacheKey];
                    if (!countObjectKeys(running)) {
                      runningMutations.delete(dispatch);
                    }
                  }
                });
              }
              return ret;
            };
          }
        }
        var NamedSchemaError = class extends SchemaError {
          constructor(issues, value, schemaName, _bqMeta) {
            super(issues);
            this.value = value;
            this.schemaName = schemaName;
            this._bqMeta = _bqMeta;
          }
        };
        var shouldSkip = (skipSchemaValidation, schemaName) => Array.isArray(skipSchemaValidation) ? skipSchemaValidation.includes(schemaName) : !!skipSchemaValidation;
        async function parseWithSchema(schema, data, schemaName, bqMeta) {
          const result = await schema["~standard"].validate(data);
          if (result.issues) {
            throw new NamedSchemaError(result.issues, data, schemaName, bqMeta);
          }
          return result.value;
        }
        function defaultTransformResponse(baseQueryReturnValue) {
          return baseQueryReturnValue;
        }
        var addShouldAutoBatch = (arg = {}) => {
          return {
            ...arg,
            [SHOULD_AUTOBATCH]: true
          };
        };
        function buildThunks({
          reducerPath,
          baseQuery,
          context: {
            endpointDefinitions
          },
          serializeQueryArgs,
          api,
          assertTagType,
          selectors,
          onSchemaFailure,
          catchSchemaFailure: globalCatchSchemaFailure,
          skipSchemaValidation: globalSkipSchemaValidation
        }) {
          const patchQueryData = (endpointName, arg, patches, updateProvided) => (dispatch, getState) => {
            const endpointDefinition = endpointDefinitions[endpointName];
            const queryCacheKey = serializeQueryArgs({
              queryArgs: arg,
              endpointDefinition,
              endpointName
            });
            dispatch(api.internalActions.queryResultPatched({
              queryCacheKey,
              patches
            }));
            if (!updateProvided) {
              return;
            }
            const newValue = api.endpoints[endpointName].select(arg)(
            // Work around TS 4.1 mismatch
            getState());
            const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, arg, {}, assertTagType);
            dispatch(api.internalActions.updateProvidedBy([{
              queryCacheKey,
              providedTags
            }]));
          };
          function addToStart(items, item, max = 0) {
            const newItems = [item, ...items];
            return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
          }
          function addToEnd(items, item, max = 0) {
            const newItems = [...items, item];
            return max && newItems.length > max ? newItems.slice(1) : newItems;
          }
          const updateQueryData = (endpointName, arg, updateRecipe, updateProvided = true) => (dispatch, getState) => {
            const endpointDefinition = api.endpoints[endpointName];
            const currentState = endpointDefinition.select(arg)(
            // Work around TS 4.1 mismatch
            getState());
            const ret = {
              patches: [],
              inversePatches: [],
              undo: () => dispatch(api.util.patchQueryData(endpointName, arg, ret.inversePatches, updateProvided))
            };
            if (currentState.status === "uninitialized") {
              return ret;
            }
            let newValue;
            if ("data" in currentState) {
              if (isDraftable(currentState.data)) {
                const [value, patches, inversePatches] = produceWithPatches(currentState.data, updateRecipe);
                ret.patches.push(...patches);
                ret.inversePatches.push(...inversePatches);
                newValue = value;
              } else {
                newValue = updateRecipe(currentState.data);
                ret.patches.push({
                  op: "replace",
                  path: [],
                  value: newValue
                });
                ret.inversePatches.push({
                  op: "replace",
                  path: [],
                  value: currentState.data
                });
              }
            }
            if (ret.patches.length === 0) {
              return ret;
            }
            dispatch(api.util.patchQueryData(endpointName, arg, ret.patches, updateProvided));
            return ret;
          };
          const upsertQueryData = (endpointName, arg, value) => dispatch => {
            const res = dispatch(api.endpoints[endpointName].initiate(arg, {
              subscribe: false,
              forceRefetch: true,
              [forceQueryFnSymbol]: () => ({
                data: value
              })
            }));
            return res;
          };
          const getTransformCallbackForEndpoint = (endpointDefinition, transformFieldName) => {
            return endpointDefinition.query && endpointDefinition[transformFieldName] ? endpointDefinition[transformFieldName] : defaultTransformResponse;
          };
          const executeEndpoint = async (arg, {
            signal,
            abort,
            rejectWithValue,
            fulfillWithValue,
            dispatch,
            getState,
            extra
          }) => {
            const endpointDefinition = endpointDefinitions[arg.endpointName];
            const {
              metaSchema,
              skipSchemaValidation = globalSkipSchemaValidation
            } = endpointDefinition;
            try {
              let transformResponse = defaultTransformResponse;
              const baseQueryApi = {
                signal,
                abort,
                dispatch,
                getState,
                extra,
                endpoint: arg.endpointName,
                type: arg.type,
                forced: arg.type === "query" ? isForcedQuery(arg, getState()) : void 0,
                queryCacheKey: arg.type === "query" ? arg.queryCacheKey : void 0
              };
              const forceQueryFn = arg.type === "query" ? arg[forceQueryFnSymbol] : void 0;
              let finalQueryReturnValue;
              const fetchPage = async (data, param, maxPages, previous) => {
                if (param == null && data.pages.length) {
                  return Promise.resolve({
                    data
                  });
                }
                const finalQueryArg = {
                  queryArg: arg.originalArgs,
                  pageParam: param
                };
                const pageResponse = await executeRequest(finalQueryArg);
                const addTo = previous ? addToStart : addToEnd;
                return {
                  data: {
                    pages: addTo(data.pages, pageResponse.data, maxPages),
                    pageParams: addTo(data.pageParams, param, maxPages)
                  },
                  meta: pageResponse.meta
                };
              };
              async function executeRequest(finalQueryArg) {
                let result;
                const {
                  extraOptions,
                  argSchema,
                  rawResponseSchema,
                  responseSchema
                } = endpointDefinition;
                if (argSchema && !shouldSkip(skipSchemaValidation, "arg")) {
                  finalQueryArg = await parseWithSchema(argSchema, finalQueryArg, "argSchema", {}
                  // we don't have a meta yet, so we can't pass it
                  );
                }
                if (forceQueryFn) {
                  result = forceQueryFn();
                } else if (endpointDefinition.query) {
                  transformResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformResponse");
                  result = await baseQuery(endpointDefinition.query(finalQueryArg), baseQueryApi, extraOptions);
                } else {
                  result = await endpointDefinition.queryFn(finalQueryArg, baseQueryApi, extraOptions, arg2 => baseQuery(arg2, baseQueryApi, extraOptions));
                }
                if (typeof process !== "undefined" && false) ;
                if (result.error) throw new HandledError(result.error, result.meta);
                let {
                  data
                } = result;
                if (rawResponseSchema && !shouldSkip(skipSchemaValidation, "rawResponse")) {
                  data = await parseWithSchema(rawResponseSchema, result.data, "rawResponseSchema", result.meta);
                }
                let transformedResponse = await transformResponse(data, result.meta, finalQueryArg);
                if (responseSchema && !shouldSkip(skipSchemaValidation, "response")) {
                  transformedResponse = await parseWithSchema(responseSchema, transformedResponse, "responseSchema", result.meta);
                }
                return {
                  ...result,
                  data: transformedResponse
                };
              }
              if (arg.type === "query" && "infiniteQueryOptions" in endpointDefinition) {
                const {
                  infiniteQueryOptions
                } = endpointDefinition;
                const {
                  maxPages = Infinity
                } = infiniteQueryOptions;
                let result;
                const blankData = {
                  pages: [],
                  pageParams: []
                };
                const cachedData = selectors.selectQueryEntry(getState(), arg.queryCacheKey)?.data;
                const isForcedQueryNeedingRefetch =
                // arg.forceRefetch
                isForcedQuery(arg, getState()) && !arg.direction;
                const existingData = isForcedQueryNeedingRefetch || !cachedData ? blankData : cachedData;
                if ("direction" in arg && arg.direction && existingData.pages.length) {
                  const previous = arg.direction === "backward";
                  const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
                  const param = pageParamFn(infiniteQueryOptions, existingData, arg.originalArgs);
                  result = await fetchPage(existingData, param, maxPages, previous);
                } else {
                  const {
                    initialPageParam = infiniteQueryOptions.initialPageParam
                  } = arg;
                  const cachedPageParams = cachedData?.pageParams ?? [];
                  const firstPageParam = cachedPageParams[0] ?? initialPageParam;
                  const totalPages = cachedPageParams.length;
                  result = await fetchPage(existingData, firstPageParam, maxPages);
                  if (forceQueryFn) {
                    result = {
                      data: result.data.pages[0]
                    };
                  }
                  for (let i = 1; i < totalPages; i++) {
                    const param = getNextPageParam(infiniteQueryOptions, result.data, arg.originalArgs);
                    result = await fetchPage(result.data, param, maxPages);
                  }
                }
                finalQueryReturnValue = result;
              } else {
                finalQueryReturnValue = await executeRequest(arg.originalArgs);
              }
              if (metaSchema && !shouldSkip(skipSchemaValidation, "meta") && finalQueryReturnValue.meta) {
                finalQueryReturnValue.meta = await parseWithSchema(metaSchema, finalQueryReturnValue.meta, "metaSchema", finalQueryReturnValue.meta);
              }
              return fulfillWithValue(finalQueryReturnValue.data, addShouldAutoBatch({
                fulfilledTimeStamp: Date.now(),
                baseQueryMeta: finalQueryReturnValue.meta
              }));
            } catch (error) {
              let caughtError = error;
              if (caughtError instanceof HandledError) {
                let transformErrorResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformErrorResponse");
                const {
                  rawErrorResponseSchema,
                  errorResponseSchema
                } = endpointDefinition;
                let {
                  value,
                  meta
                } = caughtError;
                try {
                  if (rawErrorResponseSchema && !shouldSkip(skipSchemaValidation, "rawErrorResponse")) {
                    value = await parseWithSchema(rawErrorResponseSchema, value, "rawErrorResponseSchema", meta);
                  }
                  if (metaSchema && !shouldSkip(skipSchemaValidation, "meta")) {
                    meta = await parseWithSchema(metaSchema, meta, "metaSchema", meta);
                  }
                  let transformedErrorResponse = await transformErrorResponse(value, meta, arg.originalArgs);
                  if (errorResponseSchema && !shouldSkip(skipSchemaValidation, "errorResponse")) {
                    transformedErrorResponse = await parseWithSchema(errorResponseSchema, transformedErrorResponse, "errorResponseSchema", meta);
                  }
                  return rejectWithValue(transformedErrorResponse, addShouldAutoBatch({
                    baseQueryMeta: meta
                  }));
                } catch (e) {
                  caughtError = e;
                }
              }
              try {
                if (caughtError instanceof NamedSchemaError) {
                  const info = {
                    endpoint: arg.endpointName,
                    arg: arg.originalArgs,
                    type: arg.type,
                    queryCacheKey: arg.type === "query" ? arg.queryCacheKey : void 0
                  };
                  endpointDefinition.onSchemaFailure?.(caughtError, info);
                  onSchemaFailure?.(caughtError, info);
                  const {
                    catchSchemaFailure = globalCatchSchemaFailure
                  } = endpointDefinition;
                  if (catchSchemaFailure) {
                    return rejectWithValue(catchSchemaFailure(caughtError, info), addShouldAutoBatch({
                      baseQueryMeta: caughtError._bqMeta
                    }));
                  }
                }
              } catch (e) {
                caughtError = e;
              }
              {
                console.error(caughtError);
              }
              throw caughtError;
            }
          };
          function isForcedQuery(arg, state) {
            const requestState = selectors.selectQueryEntry(state, arg.queryCacheKey);
            const baseFetchOnMountOrArgChange = selectors.selectConfig(state).refetchOnMountOrArgChange;
            const fulfilledVal = requestState?.fulfilledTimeStamp;
            const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);
            if (refetchVal) {
              return refetchVal === true || (Number(/* @__PURE__ */new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;
            }
            return false;
          }
          const createQueryThunk = () => {
            const generatedQueryThunk = createAsyncThunk(`${reducerPath}/executeQuery`, executeEndpoint, {
              getPendingMeta({
                arg
              }) {
                const endpointDefinition = endpointDefinitions[arg.endpointName];
                return addShouldAutoBatch({
                  startedTimeStamp: Date.now(),
                  ...(isInfiniteQueryDefinition$1(endpointDefinition) ? {
                    direction: arg.direction
                  } : {})
                });
              },
              condition(queryThunkArg, {
                getState
              }) {
                const state = getState();
                const requestState = selectors.selectQueryEntry(state, queryThunkArg.queryCacheKey);
                const fulfilledVal = requestState?.fulfilledTimeStamp;
                const currentArg = queryThunkArg.originalArgs;
                const previousArg = requestState?.originalArgs;
                const endpointDefinition = endpointDefinitions[queryThunkArg.endpointName];
                const direction = queryThunkArg.direction;
                if (isUpsertQuery(queryThunkArg)) {
                  return true;
                }
                if (requestState?.status === "pending") {
                  return false;
                }
                if (isForcedQuery(queryThunkArg, state)) {
                  return true;
                }
                if (isQueryDefinition$1(endpointDefinition) && endpointDefinition?.forceRefetch?.({
                  currentArg,
                  previousArg,
                  endpointState: requestState,
                  state
                })) {
                  return true;
                }
                if (fulfilledVal && !direction) {
                  return false;
                }
                return true;
              },
              dispatchConditionRejection: true
            });
            return generatedQueryThunk;
          };
          const queryThunk = createQueryThunk();
          const infiniteQueryThunk = createQueryThunk();
          const mutationThunk = createAsyncThunk(`${reducerPath}/executeMutation`, executeEndpoint, {
            getPendingMeta() {
              return addShouldAutoBatch({
                startedTimeStamp: Date.now()
              });
            }
          });
          const hasTheForce = options => "force" in options;
          const hasMaxAge = options => "ifOlderThan" in options;
          const prefetch = (endpointName, arg, options) => (dispatch, getState) => {
            const force = hasTheForce(options) && options.force;
            const maxAge = hasMaxAge(options) && options.ifOlderThan;
            const queryAction = (force2 = true) => {
              const options2 = {
                forceRefetch: force2,
                isPrefetch: true
              };
              return api.endpoints[endpointName].initiate(arg, options2);
            };
            const latestStateValue = api.endpoints[endpointName].select(arg)(getState());
            if (force) {
              dispatch(queryAction());
            } else if (maxAge) {
              const lastFulfilledTs = latestStateValue?.fulfilledTimeStamp;
              if (!lastFulfilledTs) {
                dispatch(queryAction());
                return;
              }
              const shouldRetrigger = (Number(/* @__PURE__ */new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;
              if (shouldRetrigger) {
                dispatch(queryAction());
              }
            } else {
              dispatch(queryAction(false));
            }
          };
          function matchesEndpoint(endpointName) {
            return action => action?.meta?.arg?.endpointName === endpointName;
          }
          function buildMatchThunkActions(thunk, endpointName) {
            return {
              matchPending: isAllOf(isPending(thunk), matchesEndpoint(endpointName)),
              matchFulfilled: isAllOf(isFulfilled(thunk), matchesEndpoint(endpointName)),
              matchRejected: isAllOf(isRejected(thunk), matchesEndpoint(endpointName))
            };
          }
          return {
            queryThunk,
            mutationThunk,
            infiniteQueryThunk,
            prefetch,
            updateQueryData,
            upsertQueryData,
            patchQueryData,
            buildMatchThunkActions
          };
        }
        function getNextPageParam(options, {
          pages,
          pageParams
        }, queryArg) {
          const lastIndex = pages.length - 1;
          return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams, queryArg);
        }
        function getPreviousPageParam(options, {
          pages,
          pageParams
        }, queryArg) {
          return options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams, queryArg);
        }
        function calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {
          return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload : void 0, isRejectedWithValue(action) ? action.payload : void 0, action.meta.arg.originalArgs, "baseQueryMeta" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);
        }
        function updateQuerySubstateIfExists(state, queryCacheKey, update) {
          const substate = state[queryCacheKey];
          if (substate) {
            update(substate);
          }
        }
        function getMutationCacheKey(id) {
          return ("arg" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId;
        }
        function updateMutationSubstateIfExists(state, id, update) {
          const substate = state[getMutationCacheKey(id)];
          if (substate) {
            update(substate);
          }
        }
        var initialState$3 = {};
        function buildSlice({
          reducerPath,
          queryThunk,
          mutationThunk,
          serializeQueryArgs,
          context: {
            endpointDefinitions: definitions,
            apiUid,
            extractRehydrationInfo,
            hasRehydrationInfo
          },
          assertTagType,
          config
        }) {
          const resetApiState = createAction(`${reducerPath}/resetApiState`);
          function writePendingCacheEntry(draft, arg, upserting, meta) {
            draft[arg.queryCacheKey] ??= {
              status: "uninitialized",
              endpointName: arg.endpointName
            };
            updateQuerySubstateIfExists(draft, arg.queryCacheKey, substate => {
              substate.status = "pending";
              substate.requestId = upserting && substate.requestId ?
              // for `upsertQuery` **updates**, keep the current `requestId`
              substate.requestId :
              // for normal queries or `upsertQuery` **inserts** always update the `requestId`
              meta.requestId;
              if (arg.originalArgs !== void 0) {
                substate.originalArgs = arg.originalArgs;
              }
              substate.startedTimeStamp = meta.startedTimeStamp;
              const endpointDefinition = definitions[meta.arg.endpointName];
              if (isInfiniteQueryDefinition$1(endpointDefinition) && "direction" in arg) {
                substate.direction = arg.direction;
              }
            });
          }
          function writeFulfilledCacheEntry(draft, meta, payload, upserting) {
            updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, substate => {
              if (substate.requestId !== meta.requestId && !upserting) return;
              const {
                merge
              } = definitions[meta.arg.endpointName];
              substate.status = "fulfilled";
              if (merge) {
                if (substate.data !== void 0) {
                  const {
                    fulfilledTimeStamp,
                    arg,
                    baseQueryMeta,
                    requestId
                  } = meta;
                  let newData = produce(substate.data, draftSubstateData => {
                    return merge(draftSubstateData, payload, {
                      arg: arg.originalArgs,
                      baseQueryMeta,
                      fulfilledTimeStamp,
                      requestId
                    });
                  });
                  substate.data = newData;
                } else {
                  substate.data = payload;
                }
              } else {
                substate.data = definitions[meta.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing(isDraft(substate.data) ? original(substate.data) : substate.data, payload) : payload;
              }
              delete substate.error;
              substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
            });
          }
          const querySlice = createSlice({
            name: `${reducerPath}/queries`,
            initialState: initialState$3,
            reducers: {
              removeQueryResult: {
                reducer(draft, {
                  payload: {
                    queryCacheKey
                  }
                }) {
                  delete draft[queryCacheKey];
                },
                prepare: prepareAutoBatched()
              },
              cacheEntriesUpserted: {
                reducer(draft, action) {
                  for (const entry of action.payload) {
                    const {
                      queryDescription: arg,
                      value
                    } = entry;
                    writePendingCacheEntry(draft, arg, true, {
                      arg,
                      requestId: action.meta.requestId,
                      startedTimeStamp: action.meta.timestamp
                    });
                    writeFulfilledCacheEntry(draft, {
                      arg,
                      requestId: action.meta.requestId,
                      fulfilledTimeStamp: action.meta.timestamp,
                      baseQueryMeta: {}
                    }, value,
                    // We know we're upserting here
                    true);
                  }
                },
                prepare: payload => {
                  const queryDescriptions = payload.map(entry => {
                    const {
                      endpointName,
                      arg,
                      value
                    } = entry;
                    const endpointDefinition = definitions[endpointName];
                    const queryDescription = {
                      type: "query",
                      endpointName,
                      originalArgs: entry.arg,
                      queryCacheKey: serializeQueryArgs({
                        queryArgs: arg,
                        endpointDefinition,
                        endpointName
                      })
                    };
                    return {
                      queryDescription,
                      value
                    };
                  });
                  const result = {
                    payload: queryDescriptions,
                    meta: {
                      [SHOULD_AUTOBATCH]: true,
                      requestId: nanoid(),
                      timestamp: Date.now()
                    }
                  };
                  return result;
                }
              },
              queryResultPatched: {
                reducer(draft, {
                  payload: {
                    queryCacheKey,
                    patches
                  }
                }) {
                  updateQuerySubstateIfExists(draft, queryCacheKey, substate => {
                    substate.data = applyPatches(substate.data, patches.concat());
                  });
                },
                prepare: prepareAutoBatched()
              }
            },
            extraReducers(builder) {
              builder.addCase(queryThunk.pending, (draft, {
                meta,
                meta: {
                  arg
                }
              }) => {
                const upserting = isUpsertQuery(arg);
                writePendingCacheEntry(draft, arg, upserting, meta);
              }).addCase(queryThunk.fulfilled, (draft, {
                meta,
                payload
              }) => {
                const upserting = isUpsertQuery(meta.arg);
                writeFulfilledCacheEntry(draft, meta, payload, upserting);
              }).addCase(queryThunk.rejected, (draft, {
                meta: {
                  condition,
                  arg,
                  requestId
                },
                error,
                payload
              }) => {
                updateQuerySubstateIfExists(draft, arg.queryCacheKey, substate => {
                  if (condition) ;else {
                    if (substate.requestId !== requestId) return;
                    substate.status = "rejected";
                    substate.error = payload ?? error;
                  }
                });
              }).addMatcher(hasRehydrationInfo, (draft, action) => {
                const {
                  queries
                } = extractRehydrationInfo(action);
                for (const [key, entry] of Object.entries(queries)) {
                  if (
                  // do not rehydrate entries that were currently in flight.
                  entry?.status === "fulfilled" || entry?.status === "rejected") {
                    draft[key] = entry;
                  }
                }
              });
            }
          });
          const mutationSlice = createSlice({
            name: `${reducerPath}/mutations`,
            initialState: initialState$3,
            reducers: {
              removeMutationResult: {
                reducer(draft, {
                  payload
                }) {
                  const cacheKey = getMutationCacheKey(payload);
                  if (cacheKey in draft) {
                    delete draft[cacheKey];
                  }
                },
                prepare: prepareAutoBatched()
              }
            },
            extraReducers(builder) {
              builder.addCase(mutationThunk.pending, (draft, {
                meta,
                meta: {
                  requestId,
                  arg,
                  startedTimeStamp
                }
              }) => {
                if (!arg.track) return;
                draft[getMutationCacheKey(meta)] = {
                  requestId,
                  status: "pending",
                  endpointName: arg.endpointName,
                  startedTimeStamp
                };
              }).addCase(mutationThunk.fulfilled, (draft, {
                payload,
                meta
              }) => {
                if (!meta.arg.track) return;
                updateMutationSubstateIfExists(draft, meta, substate => {
                  if (substate.requestId !== meta.requestId) return;
                  substate.status = "fulfilled";
                  substate.data = payload;
                  substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
                });
              }).addCase(mutationThunk.rejected, (draft, {
                payload,
                error,
                meta
              }) => {
                if (!meta.arg.track) return;
                updateMutationSubstateIfExists(draft, meta, substate => {
                  if (substate.requestId !== meta.requestId) return;
                  substate.status = "rejected";
                  substate.error = payload ?? error;
                });
              }).addMatcher(hasRehydrationInfo, (draft, action) => {
                const {
                  mutations
                } = extractRehydrationInfo(action);
                for (const [key, entry] of Object.entries(mutations)) {
                  if (
                  // do not rehydrate entries that were currently in flight.
                  (entry?.status === "fulfilled" || entry?.status === "rejected") &&
                  // only rehydrate endpoints that were persisted using a `fixedCacheKey`
                  key !== entry?.requestId) {
                    draft[key] = entry;
                  }
                }
              });
            }
          });
          const initialInvalidationState = {
            tags: {},
            keys: {}
          };
          const invalidationSlice = createSlice({
            name: `${reducerPath}/invalidation`,
            initialState: initialInvalidationState,
            reducers: {
              updateProvidedBy: {
                reducer(draft, action) {
                  for (const {
                    queryCacheKey,
                    providedTags
                  } of action.payload) {
                    removeCacheKeyFromTags(draft, queryCacheKey);
                    for (const {
                      type,
                      id
                    } of providedTags) {
                      const subscribedQueries = (draft.tags[type] ??= {})[id || "__internal_without_id"] ??= [];
                      const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
                      if (!alreadySubscribed) {
                        subscribedQueries.push(queryCacheKey);
                      }
                    }
                    draft.keys[queryCacheKey] = providedTags;
                  }
                },
                prepare: prepareAutoBatched()
              }
            },
            extraReducers(builder) {
              builder.addCase(querySlice.actions.removeQueryResult, (draft, {
                payload: {
                  queryCacheKey
                }
              }) => {
                removeCacheKeyFromTags(draft, queryCacheKey);
              }).addMatcher(hasRehydrationInfo, (draft, action) => {
                const {
                  provided
                } = extractRehydrationInfo(action);
                for (const [type, incomingTags] of Object.entries(provided.tags ?? {})) {
                  for (const [id, cacheKeys] of Object.entries(incomingTags)) {
                    const subscribedQueries = (draft.tags[type] ??= {})[id || "__internal_without_id"] ??= [];
                    for (const queryCacheKey of cacheKeys) {
                      const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
                      if (!alreadySubscribed) {
                        subscribedQueries.push(queryCacheKey);
                      }
                      draft.keys[queryCacheKey] = provided.keys[queryCacheKey];
                    }
                  }
                }
              }).addMatcher(isAnyOf(isFulfilled(queryThunk), isRejectedWithValue(queryThunk)), (draft, action) => {
                writeProvidedTagsForQueries(draft, [action]);
              }).addMatcher(querySlice.actions.cacheEntriesUpserted.match, (draft, action) => {
                const mockActions = action.payload.map(({
                  queryDescription,
                  value
                }) => {
                  return {
                    type: "UNKNOWN",
                    payload: value,
                    meta: {
                      requestStatus: "fulfilled",
                      requestId: "UNKNOWN",
                      arg: queryDescription
                    }
                  };
                });
                writeProvidedTagsForQueries(draft, mockActions);
              });
            }
          });
          function removeCacheKeyFromTags(draft, queryCacheKey) {
            const existingTags = draft.keys[queryCacheKey] ?? [];
            for (const tag of existingTags) {
              const tagType = tag.type;
              const tagId = tag.id ?? "__internal_without_id";
              const tagSubscriptions = draft.tags[tagType]?.[tagId];
              if (tagSubscriptions) {
                draft.tags[tagType][tagId] = tagSubscriptions.filter(qc => qc !== queryCacheKey);
              }
            }
            delete draft.keys[queryCacheKey];
          }
          function writeProvidedTagsForQueries(draft, actions2) {
            const providedByEntries = actions2.map(action => {
              const providedTags = calculateProvidedByThunk(action, "providesTags", definitions, assertTagType);
              const {
                queryCacheKey
              } = action.meta.arg;
              return {
                queryCacheKey,
                providedTags
              };
            });
            invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy(providedByEntries));
          }
          const subscriptionSlice = createSlice({
            name: `${reducerPath}/subscriptions`,
            initialState: initialState$3,
            reducers: {
              updateSubscriptionOptions(d, a) {},
              unsubscribeQueryResult(d, a) {},
              internal_getRTKQSubscriptions() {}
            }
          });
          const internalSubscriptionsSlice = createSlice({
            name: `${reducerPath}/internalSubscriptions`,
            initialState: initialState$3,
            reducers: {
              subscriptionsUpdated: {
                reducer(state, action) {
                  return applyPatches(state, action.payload);
                },
                prepare: prepareAutoBatched()
              }
            }
          });
          const configSlice = createSlice({
            name: `${reducerPath}/config`,
            initialState: {
              online: isOnline(),
              focused: isDocumentVisible(),
              middlewareRegistered: false,
              ...config
            },
            reducers: {
              middlewareRegistered(state, {
                payload
              }) {
                state.middlewareRegistered = state.middlewareRegistered === "conflict" || apiUid !== payload ? "conflict" : true;
              }
            },
            extraReducers: builder => {
              builder.addCase(onOnline, state => {
                state.online = true;
              }).addCase(onOffline, state => {
                state.online = false;
              }).addCase(onFocus, state => {
                state.focused = true;
              }).addCase(onFocusLost, state => {
                state.focused = false;
              }).addMatcher(hasRehydrationInfo, draft => ({
                ...draft
              }));
            }
          });
          const combinedReducer = combineReducers({
            queries: querySlice.reducer,
            mutations: mutationSlice.reducer,
            provided: invalidationSlice.reducer,
            subscriptions: internalSubscriptionsSlice.reducer,
            config: configSlice.reducer
          });
          const reducer = (state, action) => combinedReducer(resetApiState.match(action) ? void 0 : state, action);
          const actions = {
            ...configSlice.actions,
            ...querySlice.actions,
            ...subscriptionSlice.actions,
            ...internalSubscriptionsSlice.actions,
            ...mutationSlice.actions,
            ...invalidationSlice.actions,
            resetApiState
          };
          return {
            reducer,
            actions
          };
        }
        var skipToken = /* @__PURE__ */Symbol.for("RTKQ/skipToken");
        var initialSubState = {
          status: "uninitialized"
          /* uninitialized */
        };
        var defaultQuerySubState = /* @__PURE__ */produce(initialSubState, () => {});
        var defaultMutationSubState = /* @__PURE__ */produce(initialSubState, () => {});
        function buildSelectors({
          serializeQueryArgs,
          reducerPath,
          createSelector: createSelector2
        }) {
          const selectSkippedQuery = state => defaultQuerySubState;
          const selectSkippedMutation = state => defaultMutationSubState;
          return {
            buildQuerySelector,
            buildInfiniteQuerySelector,
            buildMutationSelector,
            selectInvalidatedBy,
            selectCachedArgsForQuery,
            selectApiState,
            selectQueries,
            selectMutations,
            selectQueryEntry,
            selectConfig
          };
          function withRequestFlags(substate) {
            return {
              ...substate,
              ...getRequestStatusFlags(substate.status)
            };
          }
          function selectApiState(rootState) {
            const state = rootState[reducerPath];
            return state;
          }
          function selectQueries(rootState) {
            return selectApiState(rootState)?.queries;
          }
          function selectQueryEntry(rootState, cacheKey) {
            return selectQueries(rootState)?.[cacheKey];
          }
          function selectMutations(rootState) {
            return selectApiState(rootState)?.mutations;
          }
          function selectConfig(rootState) {
            return selectApiState(rootState)?.config;
          }
          function buildAnyQuerySelector(endpointName, endpointDefinition, combiner) {
            return queryArgs => {
              if (queryArgs === skipToken) {
                return createSelector2(selectSkippedQuery, combiner);
              }
              const serializedArgs = serializeQueryArgs({
                queryArgs,
                endpointDefinition,
                endpointName
              });
              const selectQuerySubstate = state => selectQueryEntry(state, serializedArgs) ?? defaultQuerySubState;
              return createSelector2(selectQuerySubstate, combiner);
            };
          }
          function buildQuerySelector(endpointName, endpointDefinition) {
            return buildAnyQuerySelector(endpointName, endpointDefinition, withRequestFlags);
          }
          function buildInfiniteQuerySelector(endpointName, endpointDefinition) {
            const {
              infiniteQueryOptions
            } = endpointDefinition;
            function withInfiniteQueryResultFlags(substate) {
              const stateWithRequestFlags = {
                ...substate,
                ...getRequestStatusFlags(substate.status)
              };
              const {
                isLoading,
                isError,
                direction
              } = stateWithRequestFlags;
              const isForward = direction === "forward";
              const isBackward = direction === "backward";
              return {
                ...stateWithRequestFlags,
                hasNextPage: getHasNextPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),
                hasPreviousPage: getHasPreviousPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),
                isFetchingNextPage: isLoading && isForward,
                isFetchingPreviousPage: isLoading && isBackward,
                isFetchNextPageError: isError && isForward,
                isFetchPreviousPageError: isError && isBackward
              };
            }
            return buildAnyQuerySelector(endpointName, endpointDefinition, withInfiniteQueryResultFlags);
          }
          function buildMutationSelector() {
            return id => {
              let mutationId;
              if (typeof id === "object") {
                mutationId = getMutationCacheKey(id) ?? skipToken;
              } else {
                mutationId = id;
              }
              const selectMutationSubstate = state => selectApiState(state)?.mutations?.[mutationId] ?? defaultMutationSubState;
              const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;
              return createSelector2(finalSelectMutationSubstate, withRequestFlags);
            };
          }
          function selectInvalidatedBy(state, tags) {
            const apiState = state[reducerPath];
            const toInvalidate = /* @__PURE__ */new Set();
            for (const tag of tags.filter(isNotNullish).map(expandTagDescription)) {
              const provided = apiState.provided.tags[tag.type];
              if (!provided) {
                continue;
              }
              let invalidateSubscriptions = (tag.id !== void 0 ?
              // id given: invalidate all queries that provide this type & id
              provided[tag.id] :
              // no id: invalidate all queries that provide this type
              flatten(Object.values(provided))) ?? [];
              for (const invalidate of invalidateSubscriptions) {
                toInvalidate.add(invalidate);
              }
            }
            return flatten(Array.from(toInvalidate.values()).map(queryCacheKey => {
              const querySubState = apiState.queries[queryCacheKey];
              return querySubState ? [{
                queryCacheKey,
                endpointName: querySubState.endpointName,
                originalArgs: querySubState.originalArgs
              }] : [];
            }));
          }
          function selectCachedArgsForQuery(state, queryName) {
            return Object.values(selectQueries(state)).filter(entry => entry?.endpointName === queryName && entry.status !== "uninitialized"
            /* uninitialized */).map(entry => entry.originalArgs);
          }
          function getHasNextPage(options, data, queryArg) {
            if (!data) return false;
            return getNextPageParam(options, data, queryArg) != null;
          }
          function getHasPreviousPage(options, data, queryArg) {
            if (!data || !options.getPreviousPageParam) return false;
            return getPreviousPageParam(options, data, queryArg) != null;
          }
        }
        var cache$2 = WeakMap ? /* @__PURE__ */new WeakMap() : void 0;
        var defaultSerializeQueryArgs = ({
          endpointName,
          queryArgs
        }) => {
          let serialized = "";
          const cached = cache$2?.get(queryArgs);
          if (typeof cached === "string") {
            serialized = cached;
          } else {
            const stringified = JSON.stringify(queryArgs, (key, value) => {
              value = typeof value === "bigint" ? {
                $bigint: value.toString()
              } : value;
              value = isPlainObject$3(value) ? Object.keys(value).sort().reduce((acc, key2) => {
                acc[key2] = value[key2];
                return acc;
              }, {}) : value;
              return value;
            });
            if (isPlainObject$3(queryArgs)) {
              cache$2?.set(queryArgs, stringified);
            }
            serialized = stringified;
          }
          return `${endpointName}(${serialized})`;
        };
        function buildCreateApi(...modules) {
          return function baseCreateApi(options) {
            const extractRehydrationInfo = weakMapMemoize(action => options.extractRehydrationInfo?.(action, {
              reducerPath: options.reducerPath ?? "api"
            }));
            const optionsWithDefaults = {
              reducerPath: "api",
              keepUnusedDataFor: 60,
              refetchOnMountOrArgChange: false,
              refetchOnFocus: false,
              refetchOnReconnect: false,
              invalidationBehavior: "delayed",
              ...options,
              extractRehydrationInfo,
              serializeQueryArgs(queryArgsApi) {
                let finalSerializeQueryArgs = defaultSerializeQueryArgs;
                if ("serializeQueryArgs" in queryArgsApi.endpointDefinition) {
                  const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;
                  finalSerializeQueryArgs = queryArgsApi2 => {
                    const initialResult = endpointSQA(queryArgsApi2);
                    if (typeof initialResult === "string") {
                      return initialResult;
                    } else {
                      return defaultSerializeQueryArgs({
                        ...queryArgsApi2,
                        queryArgs: initialResult
                      });
                    }
                  };
                } else if (options.serializeQueryArgs) {
                  finalSerializeQueryArgs = options.serializeQueryArgs;
                }
                return finalSerializeQueryArgs(queryArgsApi);
              },
              tagTypes: [...(options.tagTypes || [])]
            };
            const context = {
              endpointDefinitions: {},
              batch(fn) {
                fn();
              },
              apiUid: nanoid(),
              extractRehydrationInfo,
              hasRehydrationInfo: weakMapMemoize(action => extractRehydrationInfo(action) != null)
            };
            const api = {
              injectEndpoints,
              enhanceEndpoints({
                addTagTypes,
                endpoints
              }) {
                if (addTagTypes) {
                  for (const eT of addTagTypes) {
                    if (!optionsWithDefaults.tagTypes.includes(eT)) {
                      optionsWithDefaults.tagTypes.push(eT);
                    }
                  }
                }
                if (endpoints) {
                  for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {
                    if (typeof partialDefinition === "function") {
                      partialDefinition(context.endpointDefinitions[endpointName]);
                    } else {
                      Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);
                    }
                  }
                }
                return api;
              }
            };
            const initializedModules = modules.map(m => m.init(api, optionsWithDefaults, context));
            function injectEndpoints(inject) {
              const evaluatedEndpoints = inject.endpoints({
                query: x => ({
                  ...x,
                  type: "query"
                  /* query */
                }),
                mutation: x => ({
                  ...x,
                  type: "mutation"
                  /* mutation */
                }),
                infiniteQuery: x => ({
                  ...x,
                  type: "infinitequery"
                  /* infinitequery */
                })
              });
              for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)) {
                if (inject.overrideExisting !== true && endpointName in context.endpointDefinitions) {
                  if (inject.overrideExisting === "throw") {
                    throw new Error(formatProdErrorMessage(39));
                  }
                  continue;
                }
                context.endpointDefinitions[endpointName] = definition;
                for (const m of initializedModules) {
                  m.injectEndpoint(endpointName, definition);
                }
              }
              return api;
            }
            return api.injectEndpoints({
              endpoints: options.endpoints
            });
          };
        }
        function safeAssign$1(target, ...args) {
          return Object.assign(target, ...args);
        }
        var buildBatchedActionsHandler = ({
          api,
          queryThunk,
          internalState,
          mwApi
        }) => {
          const subscriptionsPrefix = `${api.reducerPath}/subscriptions`;
          let previousSubscriptions = null;
          let updateSyncTimer = null;
          const {
            updateSubscriptionOptions,
            unsubscribeQueryResult
          } = api.internalActions;
          const actuallyMutateSubscriptions = (currentSubscriptions, action) => {
            if (updateSubscriptionOptions.match(action)) {
              const {
                queryCacheKey,
                requestId,
                options
              } = action.payload;
              const sub = currentSubscriptions.get(queryCacheKey);
              if (sub?.has(requestId)) {
                sub.set(requestId, options);
              }
              return true;
            }
            if (unsubscribeQueryResult.match(action)) {
              const {
                queryCacheKey,
                requestId
              } = action.payload;
              const sub = currentSubscriptions.get(queryCacheKey);
              if (sub) {
                sub.delete(requestId);
              }
              return true;
            }
            if (api.internalActions.removeQueryResult.match(action)) {
              currentSubscriptions.delete(action.payload.queryCacheKey);
              return true;
            }
            if (queryThunk.pending.match(action)) {
              const {
                meta: {
                  arg,
                  requestId
                }
              } = action;
              const substate = getOrInsertComputed(currentSubscriptions, arg.queryCacheKey, createNewMap);
              if (arg.subscribe) {
                substate.set(requestId, arg.subscriptionOptions ?? substate.get(requestId) ?? {});
              }
              return true;
            }
            let mutated = false;
            if (queryThunk.rejected.match(action)) {
              const {
                meta: {
                  condition,
                  arg,
                  requestId
                }
              } = action;
              if (condition && arg.subscribe) {
                const substate = getOrInsertComputed(currentSubscriptions, arg.queryCacheKey, createNewMap);
                substate.set(requestId, arg.subscriptionOptions ?? substate.get(requestId) ?? {});
                mutated = true;
              }
            }
            return mutated;
          };
          const getSubscriptions = () => internalState.currentSubscriptions;
          const getSubscriptionCount = queryCacheKey => {
            const subscriptions = getSubscriptions();
            const subscriptionsForQueryArg = subscriptions.get(queryCacheKey);
            return subscriptionsForQueryArg?.size ?? 0;
          };
          const isRequestSubscribed = (queryCacheKey, requestId) => {
            const subscriptions = getSubscriptions();
            return !!subscriptions?.get(queryCacheKey)?.get(requestId);
          };
          const subscriptionSelectors = {
            getSubscriptions,
            getSubscriptionCount,
            isRequestSubscribed
          };
          function serializeSubscriptions(currentSubscriptions) {
            return JSON.parse(JSON.stringify(Object.fromEntries([...currentSubscriptions].map(([k, v]) => [k, Object.fromEntries(v)]))));
          }
          return (action, mwApi2) => {
            if (!previousSubscriptions) {
              previousSubscriptions = serializeSubscriptions(internalState.currentSubscriptions);
            }
            if (api.util.resetApiState.match(action)) {
              previousSubscriptions = {};
              internalState.currentSubscriptions.clear();
              updateSyncTimer = null;
              return [true, false];
            }
            if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {
              return [false, subscriptionSelectors];
            }
            const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);
            let actionShouldContinue = true;
            if (didMutate) {
              if (!updateSyncTimer) {
                updateSyncTimer = setTimeout(() => {
                  const newSubscriptions = serializeSubscriptions(internalState.currentSubscriptions);
                  const [, patches] = produceWithPatches(previousSubscriptions, () => newSubscriptions);
                  mwApi2.next(api.internalActions.subscriptionsUpdated(patches));
                  previousSubscriptions = newSubscriptions;
                  updateSyncTimer = null;
                }, 500);
              }
              const isSubscriptionSliceAction = typeof action.type == "string" && !!action.type.startsWith(subscriptionsPrefix);
              const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;
              actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;
            }
            return [actionShouldContinue, false];
          };
        };
        var THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;
        var buildCacheCollectionHandler = ({
          reducerPath,
          api,
          queryThunk,
          context,
          internalState,
          selectors: {
            selectQueryEntry,
            selectConfig
          },
          getRunningQueryThunk,
          mwApi
        }) => {
          const {
            removeQueryResult,
            unsubscribeQueryResult,
            cacheEntriesUpserted
          } = api.internalActions;
          const runningQueries = internalState.runningQueries.get(mwApi.dispatch);
          const canTriggerUnsubscribe = isAnyOf(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected, cacheEntriesUpserted.match);
          function anySubscriptionsRemainingForKey(queryCacheKey) {
            const subscriptions = internalState.currentSubscriptions.get(queryCacheKey);
            if (!subscriptions) {
              return false;
            }
            const hasSubscriptions = subscriptions.size > 0;
            const isRunning = runningQueries?.[queryCacheKey] !== void 0;
            return hasSubscriptions || isRunning;
          }
          const currentRemovalTimeouts = {};
          const handler = (action, mwApi2, internalState2) => {
            const state = mwApi2.getState();
            const config = selectConfig(state);
            if (canTriggerUnsubscribe(action)) {
              let queryCacheKeys;
              if (cacheEntriesUpserted.match(action)) {
                queryCacheKeys = action.payload.map(entry => entry.queryDescription.queryCacheKey);
              } else {
                const {
                  queryCacheKey
                } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;
                queryCacheKeys = [queryCacheKey];
              }
              handleUnsubscribeMany(queryCacheKeys, mwApi2, config);
            }
            if (api.util.resetApiState.match(action)) {
              for (const [key, timeout] of Object.entries(currentRemovalTimeouts)) {
                if (timeout) clearTimeout(timeout);
                delete currentRemovalTimeouts[key];
              }
            }
            if (context.hasRehydrationInfo(action)) {
              const {
                queries
              } = context.extractRehydrationInfo(action);
              handleUnsubscribeMany(Object.keys(queries), mwApi2, config);
            }
          };
          function handleUnsubscribeMany(cacheKeys, api2, config) {
            const state = api2.getState();
            for (const queryCacheKey of cacheKeys) {
              const entry = selectQueryEntry(state, queryCacheKey);
              if (entry?.endpointName) {
                handleUnsubscribe(queryCacheKey, entry.endpointName, api2, config);
              }
            }
          }
          function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {
            const endpointDefinition = context.endpointDefinitions[endpointName];
            const keepUnusedDataFor = endpointDefinition?.keepUnusedDataFor ?? config.keepUnusedDataFor;
            if (keepUnusedDataFor === Infinity) {
              return;
            }
            const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));
            if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
              const currentTimeout = currentRemovalTimeouts[queryCacheKey];
              if (currentTimeout) {
                clearTimeout(currentTimeout);
              }
              currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {
                if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
                  const entry = selectQueryEntry(api2.getState(), queryCacheKey);
                  if (entry?.endpointName) {
                    const runningQuery = api2.dispatch(getRunningQueryThunk(entry.endpointName, entry.originalArgs));
                    runningQuery?.abort();
                  }
                  api2.dispatch(removeQueryResult({
                    queryCacheKey
                  }));
                }
                delete currentRemovalTimeouts[queryCacheKey];
              }, finalKeepUnusedDataFor * 1e3);
            }
          }
          return handler;
        };
        var neverResolvedError = new Error("Promise never resolved before cacheEntryRemoved.");
        var buildCacheLifecycleHandler = ({
          api,
          reducerPath,
          context,
          queryThunk,
          mutationThunk,
          internalState,
          selectors: {
            selectQueryEntry,
            selectApiState
          }
        }) => {
          const isQueryThunk = isAsyncThunkAction(queryThunk);
          const isMutationThunk = isAsyncThunkAction(mutationThunk);
          const isFulfilledThunk = isFulfilled(queryThunk, mutationThunk);
          const lifecycleMap = {};
          function resolveLifecycleEntry(cacheKey, data, meta) {
            const lifecycle = lifecycleMap[cacheKey];
            if (lifecycle?.valueResolved) {
              lifecycle.valueResolved({
                data,
                meta
              });
              delete lifecycle.valueResolved;
            }
          }
          function removeLifecycleEntry(cacheKey) {
            const lifecycle = lifecycleMap[cacheKey];
            if (lifecycle) {
              delete lifecycleMap[cacheKey];
              lifecycle.cacheEntryRemoved();
            }
          }
          const handler = (action, mwApi, stateBefore) => {
            const cacheKey = getCacheKey(action);
            function checkForNewCacheKey(endpointName, cacheKey2, requestId, originalArgs) {
              const oldEntry = selectQueryEntry(stateBefore, cacheKey2);
              const newEntry = selectQueryEntry(mwApi.getState(), cacheKey2);
              if (!oldEntry && newEntry) {
                handleNewKey(endpointName, originalArgs, cacheKey2, mwApi, requestId);
              }
            }
            if (queryThunk.pending.match(action)) {
              checkForNewCacheKey(action.meta.arg.endpointName, cacheKey, action.meta.requestId, action.meta.arg.originalArgs);
            } else if (api.internalActions.cacheEntriesUpserted.match(action)) {
              for (const {
                queryDescription,
                value
              } of action.payload) {
                const {
                  endpointName,
                  originalArgs,
                  queryCacheKey
                } = queryDescription;
                checkForNewCacheKey(endpointName, queryCacheKey, action.meta.requestId, originalArgs);
                resolveLifecycleEntry(queryCacheKey, value, {});
              }
            } else if (mutationThunk.pending.match(action)) {
              const state = mwApi.getState()[reducerPath].mutations[cacheKey];
              if (state) {
                handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
              }
            } else if (isFulfilledThunk(action)) {
              resolveLifecycleEntry(cacheKey, action.payload, action.meta.baseQueryMeta);
            } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {
              removeLifecycleEntry(cacheKey);
            } else if (api.util.resetApiState.match(action)) {
              for (const cacheKey2 of Object.keys(lifecycleMap)) {
                removeLifecycleEntry(cacheKey2);
              }
            }
          };
          function getCacheKey(action) {
            if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;
            if (isMutationThunk(action)) {
              return action.meta.arg.fixedCacheKey ?? action.meta.requestId;
            }
            if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;
            if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);
            return "";
          }
          function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {
            const endpointDefinition = context.endpointDefinitions[endpointName];
            const onCacheEntryAdded = endpointDefinition?.onCacheEntryAdded;
            if (!onCacheEntryAdded) return;
            const lifecycle = {};
            const cacheEntryRemoved = new Promise(resolve => {
              lifecycle.cacheEntryRemoved = resolve;
            });
            const cacheDataLoaded = Promise.race([new Promise(resolve => {
              lifecycle.valueResolved = resolve;
            }), cacheEntryRemoved.then(() => {
              throw neverResolvedError;
            })]);
            cacheDataLoaded.catch(() => {});
            lifecycleMap[queryCacheKey] = lifecycle;
            const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : queryCacheKey);
            const extra = mwApi.dispatch((_, __, extra2) => extra2);
            const lifecycleApi = {
              ...mwApi,
              getCacheEntry: () => selector(mwApi.getState()),
              requestId,
              extra,
              updateCachedData: isAnyQueryDefinition(endpointDefinition) ? updateRecipe => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
              cacheDataLoaded,
              cacheEntryRemoved
            };
            const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);
            Promise.resolve(runningHandler).catch(e => {
              if (e === neverResolvedError) return;
              throw e;
            });
          }
          return handler;
        };
        var buildDevCheckHandler = ({
          api,
          context: {
            apiUid
          },
          reducerPath
        }) => {
          return (action, mwApi) => {
            if (api.util.resetApiState.match(action)) {
              mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
            }
          };
        };
        var buildInvalidationByTagsHandler = ({
          reducerPath,
          context,
          context: {
            endpointDefinitions
          },
          mutationThunk,
          queryThunk,
          api,
          assertTagType,
          refetchQuery,
          internalState
        }) => {
          const {
            removeQueryResult
          } = api.internalActions;
          const isThunkActionWithTags = isAnyOf(isFulfilled(mutationThunk), isRejectedWithValue(mutationThunk));
          const isQueryEnd = isAnyOf(isFulfilled(mutationThunk, queryThunk), isRejected(mutationThunk, queryThunk));
          let pendingTagInvalidations = [];
          const handler = (action, mwApi) => {
            if (isThunkActionWithTags(action)) {
              invalidateTags(calculateProvidedByThunk(action, "invalidatesTags", endpointDefinitions, assertTagType), mwApi);
            } else if (isQueryEnd(action)) {
              invalidateTags([], mwApi);
            } else if (api.util.invalidateTags.match(action)) {
              invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);
            }
          };
          function hasPendingRequests(state) {
            const {
              queries,
              mutations
            } = state;
            for (const cacheRecord of [queries, mutations]) {
              for (const key in cacheRecord) {
                if (cacheRecord[key]?.status === "pending") return true;
              }
            }
            return false;
          }
          function invalidateTags(newTags, mwApi) {
            const rootState = mwApi.getState();
            const state = rootState[reducerPath];
            pendingTagInvalidations.push(...newTags);
            if (state.config.invalidationBehavior === "delayed" && hasPendingRequests(state)) {
              return;
            }
            const tags = pendingTagInvalidations;
            pendingTagInvalidations = [];
            if (tags.length === 0) return;
            const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);
            context.batch(() => {
              const valuesArray = Array.from(toInvalidate.values());
              for (const {
                queryCacheKey
              } of valuesArray) {
                const querySubState = state.queries[queryCacheKey];
                const subscriptionSubState = getOrInsertComputed(internalState.currentSubscriptions, queryCacheKey, createNewMap);
                if (querySubState) {
                  if (subscriptionSubState.size === 0) {
                    mwApi.dispatch(removeQueryResult({
                      queryCacheKey
                    }));
                  } else if (querySubState.status !== "uninitialized") {
                    mwApi.dispatch(refetchQuery(querySubState));
                  }
                }
              }
            });
          }
          return handler;
        };
        var buildPollingHandler = ({
          reducerPath,
          queryThunk,
          api,
          refetchQuery,
          internalState
        }) => {
          const {
            currentPolls,
            currentSubscriptions
          } = internalState;
          const pendingPollingUpdates = /* @__PURE__ */new Set();
          let pollingUpdateTimer = null;
          const handler = (action, mwApi) => {
            if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {
              schedulePollingUpdate(action.payload.queryCacheKey, mwApi);
            }
            if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {
              schedulePollingUpdate(action.meta.arg.queryCacheKey, mwApi);
            }
            if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {
              startNextPoll(action.meta.arg, mwApi);
            }
            if (api.util.resetApiState.match(action)) {
              clearPolls();
              if (pollingUpdateTimer) {
                clearTimeout(pollingUpdateTimer);
                pollingUpdateTimer = null;
              }
              pendingPollingUpdates.clear();
            }
          };
          function schedulePollingUpdate(queryCacheKey, api2) {
            pendingPollingUpdates.add(queryCacheKey);
            if (!pollingUpdateTimer) {
              pollingUpdateTimer = setTimeout(() => {
                for (const key of pendingPollingUpdates) {
                  updatePollingInterval({
                    queryCacheKey: key
                  }, api2);
                }
                pendingPollingUpdates.clear();
                pollingUpdateTimer = null;
              }, 0);
            }
          }
          function startNextPoll({
            queryCacheKey
          }, api2) {
            const state = api2.getState()[reducerPath];
            const querySubState = state.queries[queryCacheKey];
            const subscriptions = currentSubscriptions.get(queryCacheKey);
            if (!querySubState || querySubState.status === "uninitialized") return;
            const {
              lowestPollingInterval,
              skipPollingIfUnfocused
            } = findLowestPollingInterval(subscriptions);
            if (!Number.isFinite(lowestPollingInterval)) return;
            const currentPoll = currentPolls.get(queryCacheKey);
            if (currentPoll?.timeout) {
              clearTimeout(currentPoll.timeout);
              currentPoll.timeout = void 0;
            }
            const nextPollTimestamp = Date.now() + lowestPollingInterval;
            currentPolls.set(queryCacheKey, {
              nextPollTimestamp,
              pollingInterval: lowestPollingInterval,
              timeout: setTimeout(() => {
                if (state.config.focused || !skipPollingIfUnfocused) {
                  api2.dispatch(refetchQuery(querySubState));
                }
                startNextPoll({
                  queryCacheKey
                }, api2);
              }, lowestPollingInterval)
            });
          }
          function updatePollingInterval({
            queryCacheKey
          }, api2) {
            const state = api2.getState()[reducerPath];
            const querySubState = state.queries[queryCacheKey];
            const subscriptions = currentSubscriptions.get(queryCacheKey);
            if (!querySubState || querySubState.status === "uninitialized") {
              return;
            }
            const {
              lowestPollingInterval
            } = findLowestPollingInterval(subscriptions);
            if (!Number.isFinite(lowestPollingInterval)) {
              cleanupPollForKey(queryCacheKey);
              return;
            }
            const currentPoll = currentPolls.get(queryCacheKey);
            const nextPollTimestamp = Date.now() + lowestPollingInterval;
            if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
              startNextPoll({
                queryCacheKey
              }, api2);
            }
          }
          function cleanupPollForKey(key) {
            const existingPoll = currentPolls.get(key);
            if (existingPoll?.timeout) {
              clearTimeout(existingPoll.timeout);
            }
            currentPolls.delete(key);
          }
          function clearPolls() {
            for (const key of currentPolls.keys()) {
              cleanupPollForKey(key);
            }
          }
          function findLowestPollingInterval(subscribers = /* @__PURE__ */new Map()) {
            let skipPollingIfUnfocused = false;
            let lowestPollingInterval = Number.POSITIVE_INFINITY;
            for (const entry of subscribers.values()) {
              if (!!entry.pollingInterval) {
                lowestPollingInterval = Math.min(entry.pollingInterval, lowestPollingInterval);
                skipPollingIfUnfocused = entry.skipPollingIfUnfocused || skipPollingIfUnfocused;
              }
            }
            return {
              lowestPollingInterval,
              skipPollingIfUnfocused
            };
          }
          return handler;
        };
        var buildQueryLifecycleHandler = ({
          api,
          context,
          queryThunk,
          mutationThunk
        }) => {
          const isPendingThunk = isPending(queryThunk, mutationThunk);
          const isRejectedThunk = isRejected(queryThunk, mutationThunk);
          const isFullfilledThunk = isFulfilled(queryThunk, mutationThunk);
          const lifecycleMap = {};
          const handler = (action, mwApi) => {
            if (isPendingThunk(action)) {
              const {
                requestId,
                arg: {
                  endpointName,
                  originalArgs
                }
              } = action.meta;
              const endpointDefinition = context.endpointDefinitions[endpointName];
              const onQueryStarted = endpointDefinition?.onQueryStarted;
              if (onQueryStarted) {
                const lifecycle = {};
                const queryFulfilled = new Promise((resolve, reject) => {
                  lifecycle.resolve = resolve;
                  lifecycle.reject = reject;
                });
                queryFulfilled.catch(() => {});
                lifecycleMap[requestId] = lifecycle;
                const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : requestId);
                const extra = mwApi.dispatch((_, __, extra2) => extra2);
                const lifecycleApi = {
                  ...mwApi,
                  getCacheEntry: () => selector(mwApi.getState()),
                  requestId,
                  extra,
                  updateCachedData: isAnyQueryDefinition(endpointDefinition) ? updateRecipe => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
                  queryFulfilled
                };
                onQueryStarted(originalArgs, lifecycleApi);
              }
            } else if (isFullfilledThunk(action)) {
              const {
                requestId,
                baseQueryMeta
              } = action.meta;
              lifecycleMap[requestId]?.resolve({
                data: action.payload,
                meta: baseQueryMeta
              });
              delete lifecycleMap[requestId];
            } else if (isRejectedThunk(action)) {
              const {
                requestId,
                rejectedWithValue,
                baseQueryMeta
              } = action.meta;
              lifecycleMap[requestId]?.reject({
                error: action.payload ?? action.error,
                isUnhandledError: !rejectedWithValue,
                meta: baseQueryMeta
              });
              delete lifecycleMap[requestId];
            }
          };
          return handler;
        };
        var buildWindowEventHandler = ({
          reducerPath,
          context,
          api,
          refetchQuery,
          internalState
        }) => {
          const {
            removeQueryResult
          } = api.internalActions;
          const handler = (action, mwApi) => {
            if (onFocus.match(action)) {
              refetchValidQueries(mwApi, "refetchOnFocus");
            }
            if (onOnline.match(action)) {
              refetchValidQueries(mwApi, "refetchOnReconnect");
            }
          };
          function refetchValidQueries(api2, type) {
            const state = api2.getState()[reducerPath];
            const queries = state.queries;
            const subscriptions = internalState.currentSubscriptions;
            context.batch(() => {
              for (const queryCacheKey of subscriptions.keys()) {
                const querySubState = queries[queryCacheKey];
                const subscriptionSubState = subscriptions.get(queryCacheKey);
                if (!subscriptionSubState || !querySubState) continue;
                const values = [...subscriptionSubState.values()];
                const shouldRefetch = values.some(sub => sub[type] === true) || values.every(sub => sub[type] === void 0) && state.config[type];
                if (shouldRefetch) {
                  if (subscriptionSubState.size === 0) {
                    api2.dispatch(removeQueryResult({
                      queryCacheKey
                    }));
                  } else if (querySubState.status !== "uninitialized") {
                    api2.dispatch(refetchQuery(querySubState));
                  }
                }
              }
            });
          }
          return handler;
        };
        function buildMiddleware(input) {
          const {
            reducerPath,
            queryThunk,
            api,
            context,
            internalState
          } = input;
          const {
            apiUid
          } = context;
          const actions = {
            invalidateTags: createAction(`${reducerPath}/invalidateTags`)
          };
          const isThisApiSliceAction = action => action.type.startsWith(`${reducerPath}/`);
          const handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];
          const middleware = mwApi => {
            let initialized2 = false;
            const builderArgs = {
              ...input,
              internalState,
              refetchQuery,
              isThisApiSliceAction,
              mwApi
            };
            const handlers = handlerBuilders.map(build => build(builderArgs));
            const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);
            const windowEventsHandler = buildWindowEventHandler(builderArgs);
            return next => {
              return action => {
                if (!isAction(action)) {
                  return next(action);
                }
                if (!initialized2) {
                  initialized2 = true;
                  mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
                }
                const mwApiWithNext = {
                  ...mwApi,
                  next
                };
                const stateBefore = mwApi.getState();
                const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);
                let res;
                if (actionShouldContinue) {
                  res = next(action);
                } else {
                  res = internalProbeResult;
                }
                if (!!mwApi.getState()[reducerPath]) {
                  windowEventsHandler(action, mwApiWithNext, stateBefore);
                  if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {
                    for (const handler of handlers) {
                      handler(action, mwApiWithNext, stateBefore);
                    }
                  }
                }
                return res;
              };
            };
          };
          return {
            middleware,
            actions
          };
          function refetchQuery(querySubState) {
            return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs, {
              subscribe: false,
              forceRefetch: true
            });
          }
        }
        var coreModuleName = /* @__PURE__ */Symbol();
        var coreModule = ({
          createSelector: createSelector2 = createSelector
        } = {}) => ({
          name: coreModuleName,
          init(api, {
            baseQuery,
            tagTypes,
            reducerPath,
            serializeQueryArgs,
            keepUnusedDataFor,
            refetchOnMountOrArgChange,
            refetchOnFocus,
            refetchOnReconnect,
            invalidationBehavior,
            onSchemaFailure,
            catchSchemaFailure,
            skipSchemaValidation
          }, context) {
            enablePatches();
            const assertTagType = tag => {
              return tag;
            };
            Object.assign(api, {
              reducerPath,
              endpoints: {},
              internalActions: {
                onOnline,
                onOffline,
                onFocus,
                onFocusLost
              },
              util: {}
            });
            const selectors = buildSelectors({
              serializeQueryArgs,
              reducerPath,
              createSelector: createSelector2
            });
            const {
              selectInvalidatedBy,
              selectCachedArgsForQuery,
              buildQuerySelector,
              buildInfiniteQuerySelector,
              buildMutationSelector
            } = selectors;
            safeAssign$1(api.util, {
              selectInvalidatedBy,
              selectCachedArgsForQuery
            });
            const {
              queryThunk,
              infiniteQueryThunk,
              mutationThunk,
              patchQueryData,
              updateQueryData,
              upsertQueryData,
              prefetch,
              buildMatchThunkActions
            } = buildThunks({
              baseQuery,
              reducerPath,
              context,
              api,
              serializeQueryArgs,
              assertTagType,
              selectors,
              onSchemaFailure,
              catchSchemaFailure,
              skipSchemaValidation
            });
            const {
              reducer,
              actions: sliceActions
            } = buildSlice({
              context,
              queryThunk,
              mutationThunk,
              serializeQueryArgs,
              reducerPath,
              assertTagType,
              config: {
                refetchOnFocus,
                refetchOnReconnect,
                refetchOnMountOrArgChange,
                keepUnusedDataFor,
                reducerPath,
                invalidationBehavior
              }
            });
            safeAssign$1(api.util, {
              patchQueryData,
              updateQueryData,
              upsertQueryData,
              prefetch,
              resetApiState: sliceActions.resetApiState,
              upsertQueryEntries: sliceActions.cacheEntriesUpserted
            });
            safeAssign$1(api.internalActions, sliceActions);
            const internalState = {
              currentSubscriptions: /* @__PURE__ */new Map(),
              currentPolls: /* @__PURE__ */new Map(),
              runningQueries: /* @__PURE__ */new Map(),
              runningMutations: /* @__PURE__ */new Map()
            };
            const {
              buildInitiateQuery,
              buildInitiateInfiniteQuery,
              buildInitiateMutation,
              getRunningMutationThunk,
              getRunningMutationsThunk,
              getRunningQueriesThunk,
              getRunningQueryThunk
            } = buildInitiate({
              queryThunk,
              mutationThunk,
              infiniteQueryThunk,
              api,
              serializeQueryArgs,
              context,
              internalState
            });
            safeAssign$1(api.util, {
              getRunningMutationThunk,
              getRunningMutationsThunk,
              getRunningQueryThunk,
              getRunningQueriesThunk
            });
            const {
              middleware,
              actions: middlewareActions
            } = buildMiddleware({
              reducerPath,
              context,
              queryThunk,
              mutationThunk,
              infiniteQueryThunk,
              api,
              assertTagType,
              selectors,
              getRunningQueryThunk,
              internalState
            });
            safeAssign$1(api.util, middlewareActions);
            safeAssign$1(api, {
              reducer,
              middleware
            });
            return {
              name: coreModuleName,
              injectEndpoint(endpointName, definition) {
                const anyApi = api;
                const endpoint = anyApi.endpoints[endpointName] ??= {};
                if (isQueryDefinition$1(definition)) {
                  safeAssign$1(endpoint, {
                    name: endpointName,
                    select: buildQuerySelector(endpointName, definition),
                    initiate: buildInitiateQuery(endpointName, definition)
                  }, buildMatchThunkActions(queryThunk, endpointName));
                }
                if (isMutationDefinition$1(definition)) {
                  safeAssign$1(endpoint, {
                    name: endpointName,
                    select: buildMutationSelector(),
                    initiate: buildInitiateMutation(endpointName)
                  }, buildMatchThunkActions(mutationThunk, endpointName));
                }
                if (isInfiniteQueryDefinition$1(definition)) {
                  safeAssign$1(endpoint, {
                    name: endpointName,
                    select: buildInfiniteQuerySelector(endpointName, definition),
                    initiate: buildInitiateInfiniteQuery(endpointName, definition)
                  }, buildMatchThunkActions(queryThunk, endpointName));
                }
              }
            };
          }
        });
        /* @__PURE__ */
        buildCreateApi(coreModule());
        function capitalize(str) {
          return str.replace(str[0], str[0].toUpperCase());
        }
        function isQueryDefinition(e) {
          return e.type === "query";
        }
        function isMutationDefinition(e) {
          return e.type === "mutation";
        }
        function isInfiniteQueryDefinition(e) {
          return e.type === "infinitequery";
        }
        function safeAssign(target, ...args) {
          return Object.assign(target, ...args);
        }
        var UNINITIALIZED_VALUE = Symbol();
        function useStableQueryArgs(queryArgs) {
          const cache = reactExports.useRef(queryArgs);
          const copy = reactExports.useMemo(() => copyWithStructuralSharing(cache.current, queryArgs), [queryArgs]);
          reactExports.useEffect(() => {
            if (cache.current !== copy) {
              cache.current = copy;
            }
          }, [copy]);
          return copy;
        }
        function useShallowStableValue(value) {
          const cache = reactExports.useRef(value);
          reactExports.useEffect(() => {
            if (!shallowEqual(cache.current, value)) {
              cache.current = value;
            }
          }, [value]);
          return shallowEqual(cache.current, value) ? cache.current : value;
        }
        var canUseDOM$1 = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isDOM = /* @__PURE__ */canUseDOM$1();
        var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
        var isReactNative = /* @__PURE__ */isRunningInReactNative();
        var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? reactExports.useLayoutEffect : reactExports.useEffect;
        var useIsomorphicLayoutEffect$1 = /* @__PURE__ */getUseIsomorphicLayoutEffect();
        var noPendingQueryStateSelector = selected => {
          if (selected.isUninitialized) {
            return {
              ...selected,
              isUninitialized: false,
              isFetching: true,
              isLoading: selected.data !== void 0 ? false : true,
              status: QueryStatus.pending
            };
          }
          return selected;
        };
        function pick(obj, ...keys) {
          const ret = {};
          keys.forEach(key => {
            ret[key] = obj[key];
          });
          return ret;
        }
        var COMMON_HOOK_DEBUG_FIELDS = ["data", "status", "isLoading", "isSuccess", "isError", "error"];
        function buildHooks({
          api,
          moduleOptions: {
            batch,
            hooks: {
              useDispatch,
              useSelector,
              useStore
            },
            unstable__sideEffectsInRender,
            createSelector
          },
          serializeQueryArgs,
          context
        }) {
          const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? cb => cb() : reactExports.useEffect;
          return {
            buildQueryHooks,
            buildInfiniteQueryHooks,
            buildMutationHook,
            usePrefetch
          };
          function queryStatePreSelector(currentState, lastResult, queryArgs) {
            if (lastResult?.endpointName && currentState.isUninitialized) {
              const {
                endpointName
              } = lastResult;
              const endpointDefinition = context.endpointDefinitions[endpointName];
              if (queryArgs !== skipToken && serializeQueryArgs({
                queryArgs: lastResult.originalArgs,
                endpointDefinition,
                endpointName
              }) === serializeQueryArgs({
                queryArgs,
                endpointDefinition,
                endpointName
              })) lastResult = void 0;
            }
            let data = currentState.isSuccess ? currentState.data : lastResult?.data;
            if (data === void 0) data = currentState.data;
            const hasData = data !== void 0;
            const isFetching = currentState.isLoading;
            const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;
            const isSuccess = currentState.isSuccess || hasData && (isFetching && !lastResult?.isError || currentState.isUninitialized);
            return {
              ...currentState,
              data,
              currentData: currentState.data,
              isFetching,
              isLoading,
              isSuccess
            };
          }
          function infiniteQueryStatePreSelector(currentState, lastResult, queryArgs) {
            if (lastResult?.endpointName && currentState.isUninitialized) {
              const {
                endpointName
              } = lastResult;
              const endpointDefinition = context.endpointDefinitions[endpointName];
              if (queryArgs !== skipToken && serializeQueryArgs({
                queryArgs: lastResult.originalArgs,
                endpointDefinition,
                endpointName
              }) === serializeQueryArgs({
                queryArgs,
                endpointDefinition,
                endpointName
              })) lastResult = void 0;
            }
            let data = currentState.isSuccess ? currentState.data : lastResult?.data;
            if (data === void 0) data = currentState.data;
            const hasData = data !== void 0;
            const isFetching = currentState.isLoading;
            const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;
            const isSuccess = currentState.isSuccess || isFetching && hasData;
            return {
              ...currentState,
              data,
              currentData: currentState.data,
              isFetching,
              isLoading,
              isSuccess
            };
          }
          function usePrefetch(endpointName, defaultOptions) {
            const dispatch = useDispatch();
            const stableDefaultOptions = useShallowStableValue(defaultOptions);
            return reactExports.useCallback((arg, options) => dispatch(api.util.prefetch(endpointName, arg, {
              ...stableDefaultOptions,
              ...options
            })), [endpointName, dispatch, stableDefaultOptions]);
          }
          function useQuerySubscriptionCommonImpl(endpointName, arg, {
            refetchOnReconnect,
            refetchOnFocus,
            refetchOnMountOrArgChange,
            skip = false,
            pollingInterval = 0,
            skipPollingIfUnfocused = false,
            ...rest
          } = {}) {
            const {
              initiate
            } = api.endpoints[endpointName];
            const dispatch = useDispatch();
            const subscriptionSelectorsRef = reactExports.useRef(void 0);
            if (!subscriptionSelectorsRef.current) {
              const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());
              subscriptionSelectorsRef.current = returnedValue;
            }
            const stableArg = useStableQueryArgs(skip ? skipToken : arg);
            const stableSubscriptionOptions = useShallowStableValue({
              refetchOnReconnect,
              refetchOnFocus,
              pollingInterval,
              skipPollingIfUnfocused
            });
            const initialPageParam = rest.initialPageParam;
            const stableInitialPageParam = useShallowStableValue(initialPageParam);
            const promiseRef = reactExports.useRef(void 0);
            let {
              queryCacheKey,
              requestId
            } = promiseRef.current || {};
            let currentRenderHasSubscription = false;
            if (queryCacheKey && requestId) {
              currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);
            }
            const subscriptionRemoved = !currentRenderHasSubscription && promiseRef.current !== void 0;
            usePossiblyImmediateEffect(() => {
              if (subscriptionRemoved) {
                promiseRef.current = void 0;
              }
            }, [subscriptionRemoved]);
            usePossiblyImmediateEffect(() => {
              const lastPromise = promiseRef.current;
              if (stableArg === skipToken) {
                lastPromise?.unsubscribe();
                promiseRef.current = void 0;
                return;
              }
              const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;
              if (!lastPromise || lastPromise.arg !== stableArg) {
                lastPromise?.unsubscribe();
                const promise = dispatch(initiate(stableArg, {
                  subscriptionOptions: stableSubscriptionOptions,
                  forceRefetch: refetchOnMountOrArgChange,
                  ...(isInfiniteQueryDefinition(context.endpointDefinitions[endpointName]) ? {
                    initialPageParam: stableInitialPageParam
                  } : {})
                }));
                promiseRef.current = promise;
              } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {
                lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);
              }
            }, [dispatch, initiate, refetchOnMountOrArgChange, stableArg, stableSubscriptionOptions, subscriptionRemoved, stableInitialPageParam, endpointName]);
            return [promiseRef, dispatch, initiate, stableSubscriptionOptions];
          }
          function buildUseQueryState(endpointName, preSelector) {
            const useQueryState = (arg, {
              skip = false,
              selectFromResult
            } = {}) => {
              const {
                select
              } = api.endpoints[endpointName];
              const stableArg = useStableQueryArgs(skip ? skipToken : arg);
              const lastValue = reactExports.useRef(void 0);
              const selectDefaultResult = reactExports.useMemo(() =>
              // Normally ts-ignores are bad and should be avoided, but we're
              // already casting this selector to be `Selector<any>` anyway,
              // so the inconsistencies don't matter here
              // @ts-ignore
              createSelector([
              // @ts-ignore
              select(stableArg), (_, lastResult) => lastResult, _ => stableArg], preSelector, {
                memoizeOptions: {
                  resultEqualityCheck: shallowEqual
                }
              }), [select, stableArg]);
              const querySelector = reactExports.useMemo(() => selectFromResult ? createSelector([selectDefaultResult], selectFromResult, {
                devModeChecks: {
                  identityFunctionCheck: "never"
                }
              }) : selectDefaultResult, [selectDefaultResult, selectFromResult]);
              const currentState = useSelector(state => querySelector(state, lastValue.current), shallowEqual);
              const store = useStore();
              const newLastValue = selectDefaultResult(store.getState(), lastValue.current);
              useIsomorphicLayoutEffect$1(() => {
                lastValue.current = newLastValue;
              }, [newLastValue]);
              return currentState;
            };
            return useQueryState;
          }
          function usePromiseRefUnsubscribeOnUnmount(promiseRef) {
            reactExports.useEffect(() => {
              return () => {
                promiseRef.current?.unsubscribe?.();
                promiseRef.current = void 0;
              };
            }, [promiseRef]);
          }
          function refetchOrErrorIfUnmounted(promiseRef) {
            if (!promiseRef.current) throw new Error(formatProdErrorMessage(38));
            return promiseRef.current.refetch();
          }
          function buildQueryHooks(endpointName) {
            const useQuerySubscription = (arg, options = {}) => {
              const [promiseRef] = useQuerySubscriptionCommonImpl(endpointName, arg, options);
              usePromiseRefUnsubscribeOnUnmount(promiseRef);
              return reactExports.useMemo(() => ({
                /**
                 * A method to manually refetch data for the query
                 */
                refetch: () => refetchOrErrorIfUnmounted(promiseRef)
              }), [promiseRef]);
            };
            const useLazyQuerySubscription = ({
              refetchOnReconnect,
              refetchOnFocus,
              pollingInterval = 0,
              skipPollingIfUnfocused = false
            } = {}) => {
              const {
                initiate
              } = api.endpoints[endpointName];
              const dispatch = useDispatch();
              const [arg, setArg] = reactExports.useState(UNINITIALIZED_VALUE);
              const promiseRef = reactExports.useRef(void 0);
              const stableSubscriptionOptions = useShallowStableValue({
                refetchOnReconnect,
                refetchOnFocus,
                pollingInterval,
                skipPollingIfUnfocused
              });
              usePossiblyImmediateEffect(() => {
                const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;
                if (stableSubscriptionOptions !== lastSubscriptionOptions) {
                  promiseRef.current?.updateSubscriptionOptions(stableSubscriptionOptions);
                }
              }, [stableSubscriptionOptions]);
              const subscriptionOptionsRef = reactExports.useRef(stableSubscriptionOptions);
              usePossiblyImmediateEffect(() => {
                subscriptionOptionsRef.current = stableSubscriptionOptions;
              }, [stableSubscriptionOptions]);
              const trigger = reactExports.useCallback(function (arg2, preferCacheValue = false) {
                let promise;
                batch(() => {
                  promiseRef.current?.unsubscribe();
                  promiseRef.current = promise = dispatch(initiate(arg2, {
                    subscriptionOptions: subscriptionOptionsRef.current,
                    forceRefetch: !preferCacheValue
                  }));
                  setArg(arg2);
                });
                return promise;
              }, [dispatch, initiate]);
              const reset = reactExports.useCallback(() => {
                if (promiseRef.current?.queryCacheKey) {
                  dispatch(api.internalActions.removeQueryResult({
                    queryCacheKey: promiseRef.current?.queryCacheKey
                  }));
                }
              }, [dispatch]);
              reactExports.useEffect(() => {
                return () => {
                  promiseRef?.current?.unsubscribe();
                };
              }, []);
              reactExports.useEffect(() => {
                if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {
                  trigger(arg, true);
                }
              }, [arg, trigger]);
              return reactExports.useMemo(() => [trigger, arg, {
                reset
              }], [trigger, arg, reset]);
            };
            const useQueryState = buildUseQueryState(endpointName, queryStatePreSelector);
            return {
              useQueryState,
              useQuerySubscription,
              useLazyQuerySubscription,
              useLazyQuery(options) {
                const [trigger, arg, {
                  reset
                }] = useLazyQuerySubscription(options);
                const queryStateResults = useQueryState(arg, {
                  ...options,
                  skip: arg === UNINITIALIZED_VALUE
                });
                const info = reactExports.useMemo(() => ({
                  lastArg: arg
                }), [arg]);
                return reactExports.useMemo(() => [trigger, {
                  ...queryStateResults,
                  reset
                }, info], [trigger, queryStateResults, reset, info]);
              },
              useQuery(arg, options) {
                const querySubscriptionResults = useQuerySubscription(arg, options);
                const queryStateResults = useQueryState(arg, {
                  selectFromResult: arg === skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,
                  ...options
                });
                const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS);
                reactExports.useDebugValue(debugValue);
                return reactExports.useMemo(() => ({
                  ...queryStateResults,
                  ...querySubscriptionResults
                }), [queryStateResults, querySubscriptionResults]);
              }
            };
          }
          function buildInfiniteQueryHooks(endpointName) {
            const useInfiniteQuerySubscription = (arg, options = {}) => {
              const [promiseRef, dispatch, initiate, stableSubscriptionOptions] = useQuerySubscriptionCommonImpl(endpointName, arg, options);
              const subscriptionOptionsRef = reactExports.useRef(stableSubscriptionOptions);
              usePossiblyImmediateEffect(() => {
                subscriptionOptionsRef.current = stableSubscriptionOptions;
              }, [stableSubscriptionOptions]);
              const trigger = reactExports.useCallback(function (arg2, direction) {
                let promise;
                batch(() => {
                  promiseRef.current?.unsubscribe();
                  promiseRef.current = promise = dispatch(initiate(arg2, {
                    subscriptionOptions: subscriptionOptionsRef.current,
                    direction
                  }));
                });
                return promise;
              }, [promiseRef, dispatch, initiate]);
              usePromiseRefUnsubscribeOnUnmount(promiseRef);
              const stableArg = useStableQueryArgs(options.skip ? skipToken : arg);
              const refetch = reactExports.useCallback(() => refetchOrErrorIfUnmounted(promiseRef), [promiseRef]);
              return reactExports.useMemo(() => {
                const fetchNextPage = () => {
                  return trigger(stableArg, "forward");
                };
                const fetchPreviousPage = () => {
                  return trigger(stableArg, "backward");
                };
                return {
                  trigger,
                  /**
                   * A method to manually refetch data for the query
                   */
                  refetch,
                  fetchNextPage,
                  fetchPreviousPage
                };
              }, [refetch, trigger, stableArg]);
            };
            const useInfiniteQueryState = buildUseQueryState(endpointName, infiniteQueryStatePreSelector);
            return {
              useInfiniteQueryState,
              useInfiniteQuerySubscription,
              useInfiniteQuery(arg, options) {
                const {
                  refetch,
                  fetchNextPage,
                  fetchPreviousPage
                } = useInfiniteQuerySubscription(arg, options);
                const queryStateResults = useInfiniteQueryState(arg, {
                  selectFromResult: arg === skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,
                  ...options
                });
                const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS, "hasNextPage", "hasPreviousPage");
                reactExports.useDebugValue(debugValue);
                return reactExports.useMemo(() => ({
                  ...queryStateResults,
                  fetchNextPage,
                  fetchPreviousPage,
                  refetch
                }), [queryStateResults, fetchNextPage, fetchPreviousPage, refetch]);
              }
            };
          }
          function buildMutationHook(name) {
            return ({
              selectFromResult,
              fixedCacheKey
            } = {}) => {
              const {
                select,
                initiate
              } = api.endpoints[name];
              const dispatch = useDispatch();
              const [promise, setPromise] = reactExports.useState();
              reactExports.useEffect(() => () => {
                if (!promise?.arg.fixedCacheKey) {
                  promise?.reset();
                }
              }, [promise]);
              const triggerMutation = reactExports.useCallback(function (arg) {
                const promise2 = dispatch(initiate(arg, {
                  fixedCacheKey
                }));
                setPromise(promise2);
                return promise2;
              }, [dispatch, initiate, fixedCacheKey]);
              const {
                requestId
              } = promise || {};
              const selectDefaultResult = reactExports.useMemo(() => select({
                fixedCacheKey,
                requestId: promise?.requestId
              }), [fixedCacheKey, promise, select]);
              const mutationSelector = reactExports.useMemo(() => selectFromResult ? createSelector([selectDefaultResult], selectFromResult) : selectDefaultResult, [selectFromResult, selectDefaultResult]);
              const currentState = useSelector(mutationSelector, shallowEqual);
              const originalArgs = fixedCacheKey == null ? promise?.arg.originalArgs : void 0;
              const reset = reactExports.useCallback(() => {
                batch(() => {
                  if (promise) {
                    setPromise(void 0);
                  }
                  if (fixedCacheKey) {
                    dispatch(api.internalActions.removeMutationResult({
                      requestId,
                      fixedCacheKey
                    }));
                  }
                });
              }, [dispatch, fixedCacheKey, promise, requestId]);
              const debugValue = pick(currentState, ...COMMON_HOOK_DEBUG_FIELDS, "endpointName");
              reactExports.useDebugValue(debugValue);
              const finalState = reactExports.useMemo(() => ({
                ...currentState,
                originalArgs,
                reset
              }), [currentState, originalArgs, reset]);
              return reactExports.useMemo(() => [triggerMutation, finalState], [triggerMutation, finalState]);
            };
          }
        }
        var reactHooksModuleName = /* @__PURE__ */Symbol();
        var reactHooksModule = ({
          batch = reactDomExports.unstable_batchedUpdates,
          hooks = {
            useDispatch: useDispatch,
            useSelector: useSelector,
            useStore: useStore
          },
          createSelector: createSelector$1 = createSelector,
          unstable__sideEffectsInRender = false,
          ...rest
        } = {}) => {
          return {
            name: reactHooksModuleName,
            init(api, {
              serializeQueryArgs
            }, context) {
              const anyApi = api;
              const {
                buildQueryHooks,
                buildInfiniteQueryHooks,
                buildMutationHook,
                usePrefetch
              } = buildHooks({
                api,
                moduleOptions: {
                  batch,
                  hooks,
                  unstable__sideEffectsInRender,
                  createSelector: createSelector$1
                },
                serializeQueryArgs,
                context
              });
              safeAssign(anyApi, {
                usePrefetch
              });
              safeAssign(context, {
                batch
              });
              return {
                injectEndpoint(endpointName, definition) {
                  if (isQueryDefinition(definition)) {
                    const {
                      useQuery,
                      useLazyQuery,
                      useLazyQuerySubscription,
                      useQueryState,
                      useQuerySubscription
                    } = buildQueryHooks(endpointName);
                    safeAssign(anyApi.endpoints[endpointName], {
                      useQuery,
                      useLazyQuery,
                      useLazyQuerySubscription,
                      useQueryState,
                      useQuerySubscription
                    });
                    api[`use${capitalize(endpointName)}Query`] = useQuery;
                    api[`useLazy${capitalize(endpointName)}Query`] = useLazyQuery;
                  }
                  if (isMutationDefinition(definition)) {
                    const useMutation = buildMutationHook(endpointName);
                    safeAssign(anyApi.endpoints[endpointName], {
                      useMutation
                    });
                    api[`use${capitalize(endpointName)}Mutation`] = useMutation;
                  } else if (isInfiniteQueryDefinition(definition)) {
                    const {
                      useInfiniteQuery,
                      useInfiniteQuerySubscription,
                      useInfiniteQueryState
                    } = buildInfiniteQueryHooks(endpointName);
                    safeAssign(anyApi.endpoints[endpointName], {
                      useInfiniteQuery,
                      useInfiniteQuerySubscription,
                      useInfiniteQueryState
                    });
                    api[`use${capitalize(endpointName)}InfiniteQuery`] = useInfiniteQuery;
                  }
                }
              };
            }
          };
        };
        var createApi = exports("D", /* @__PURE__ */buildCreateApi(coreModule(), reactHooksModule()));

        /**
         *  base64.ts
         *
         *  Licensed under the BSD 3-Clause License.
         *    http://opensource.org/licenses/BSD-3-Clause
         *
         *  References:
         *    http://en.wikipedia.org/wiki/Base64
         *
         * @author Dan Kogai (https://github.com/dankogai)
         */
        const version$1 = '3.7.8';
        /**
         * @deprecated use lowercase `version`.
         */
        const VERSION = version$1;
        const _hasBuffer = typeof Buffer === 'function';
        const _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
        const _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
        const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        const b64chs = Array.prototype.slice.call(b64ch);
        const b64tab = (a => {
          let tab = {};
          a.forEach((c, i) => tab[c] = i);
          return tab;
        })(b64chs);
        const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
        const _fromCC = String.fromCharCode.bind(String);
        const _U8Afrom = typeof Uint8Array.from === 'function' ? Uint8Array.from.bind(Uint8Array) : it => new Uint8Array(Array.prototype.slice.call(it, 0));
        const _mkUriSafe = src => src.replace(/=/g, '').replace(/[+\/]/g, m0 => m0 == '+' ? '-' : '_');
        const _tidyB64 = s => s.replace(/[^A-Za-z0-9\+\/]/g, '');
        /**
         * polyfill version of `btoa`
         */
        const btoaPolyfill = bin => {
          // console.log('polyfilled');
          let u32,
            c0,
            c1,
            c2,
            asc = '';
          const pad = bin.length % 3;
          for (let i = 0; i < bin.length;) {
            if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255) throw new TypeError('invalid character found');
            u32 = c0 << 16 | c1 << 8 | c2;
            asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
          }
          return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
        };
        /**
         * does what `window.btoa` of web browsers do.
         * @param {String} bin binary string
         * @returns {string} Base64-encoded string
         */
        const _btoa = typeof btoa === 'function' ? bin => btoa(bin) : _hasBuffer ? bin => Buffer.from(bin, 'binary').toString('base64') : btoaPolyfill;
        const _fromUint8Array = _hasBuffer ? u8a => Buffer.from(u8a).toString('base64') : u8a => {
          // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
          const maxargs = 0x1000;
          let strs = [];
          for (let i = 0, l = u8a.length; i < l; i += maxargs) {
            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
          }
          return _btoa(strs.join(''));
        };
        /**
         * converts a Uint8Array to a Base64 string.
         * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 5
         * @returns {string} Base64 string
         */
        const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
        // This trick is found broken https://github.com/dankogai/js-base64/issues/130
        // const utob = (src: string) => unescape(encodeURIComponent(src));
        // reverting good old fationed regexp
        const cb_utob = c => {
          if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c : cc < 0x800 ? _fromCC(0xc0 | cc >>> 6) + _fromCC(0x80 | cc & 0x3f) : _fromCC(0xe0 | cc >>> 12 & 0x0f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);
          } else {
            var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
            return _fromCC(0xf0 | cc >>> 18 & 0x07) + _fromCC(0x80 | cc >>> 12 & 0x3f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);
          }
        };
        const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
        /**
         * @deprecated should have been internal use only.
         * @param {string} src UTF-8 string
         * @returns {string} UTF-16 string
         */
        const utob = u => u.replace(re_utob, cb_utob);
        //
        const _encode = _hasBuffer ? s => Buffer.from(s, 'utf8').toString('base64') : _TE ? s => _fromUint8Array(_TE.encode(s)) : s => _btoa(utob(s));
        /**
         * converts a UTF-8-encoded string to a Base64 string.
         * @param {boolean} [urlsafe] if `true` make the result URL-safe
         * @returns {string} Base64 string
         */
        const encode$1 = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
        /**
         * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 5.
         * @returns {string} Base64 string
         */
        const encodeURI$1 = src => encode$1(src, true);
        // This trick is found broken https://github.com/dankogai/js-base64/issues/130
        // const btou = (src: string) => decodeURIComponent(escape(src));
        // reverting good old fationed regexp
        const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
        const cb_btou = cccc => {
          switch (cccc.length) {
            case 4:
              var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3),
                offset = cp - 0x10000;
              return _fromCC((offset >>> 10) + 0xD800) + _fromCC((offset & 0x3FF) + 0xDC00);
            case 3:
              return _fromCC((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));
            default:
              return _fromCC((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));
          }
        };
        /**
         * @deprecated should have been internal use only.
         * @param {string} src UTF-16 string
         * @returns {string} UTF-8 string
         */
        const btou = b => b.replace(re_btou, cb_btou);
        /**
         * polyfill version of `atob`
         */
        const atobPolyfill = asc => {
          // console.log('polyfilled');
          asc = asc.replace(/\s+/g, '');
          if (!b64re.test(asc)) throw new TypeError('malformed base64.');
          asc += '=='.slice(2 - (asc.length & 3));
          let u24, r1, r2;
          let binArray = []; // use array to avoid minor gc in loop
          for (let i = 0; i < asc.length;) {
            u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
            if (r1 === 64) {
              binArray.push(_fromCC(u24 >> 16 & 255));
            } else if (r2 === 64) {
              binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255));
            } else {
              binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255));
            }
          }
          return binArray.join('');
        };
        /**
         * does what `window.atob` of web browsers do.
         * @param {String} asc Base64-encoded string
         * @returns {string} binary string
         */
        const _atob = typeof atob === 'function' ? asc => atob(_tidyB64(asc)) : _hasBuffer ? asc => Buffer.from(asc, 'base64').toString('binary') : atobPolyfill;
        //
        const _toUint8Array = _hasBuffer ? a => _U8Afrom(Buffer.from(a, 'base64')) : a => _U8Afrom(_atob(a).split('').map(c => c.charCodeAt(0)));
        /**
         * converts a Base64 string to a Uint8Array.
         */
        const toUint8Array = a => _toUint8Array(_unURI(a));
        //
        const _decode = _hasBuffer ? a => Buffer.from(a, 'base64').toString('utf8') : _TD ? a => _TD.decode(_toUint8Array(a)) : a => btou(_atob(a));
        const _unURI = a => _tidyB64(a.replace(/[-_]/g, m0 => m0 == '-' ? '+' : '/'));
        /**
         * converts a Base64 string to a UTF-8 string.
         * @param {String} src Base64 string.  Both normal and URL-safe are supported
         * @returns {string} UTF-8 string
         */
        const decode$1 = src => _decode(_unURI(src));
        /**
         * check if a value is a valid Base64 string
         * @param {String} src a value to check
          */
        const isValid$1 = src => {
          if (typeof src !== 'string') return false;
          const s = src.replace(/\s+/g, '').replace(/={0,2}$/, '');
          return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
        };
        //
        const _noEnum = v => {
          return {
            value: v,
            enumerable: false,
            writable: true,
            configurable: true
          };
        };
        /**
         * extend String.prototype with relevant methods
         */
        const extendString = function () {
          const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
          _add('fromBase64', function () {
            return decode$1(this);
          });
          _add('toBase64', function (urlsafe) {
            return encode$1(this, urlsafe);
          });
          _add('toBase64URI', function () {
            return encode$1(this, true);
          });
          _add('toBase64URL', function () {
            return encode$1(this, true);
          });
          _add('toUint8Array', function () {
            return toUint8Array(this);
          });
        };
        /**
         * extend Uint8Array.prototype with relevant methods
         */
        const extendUint8Array = function () {
          const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
          _add('toBase64', function (urlsafe) {
            return fromUint8Array(this, urlsafe);
          });
          _add('toBase64URI', function () {
            return fromUint8Array(this, true);
          });
          _add('toBase64URL', function () {
            return fromUint8Array(this, true);
          });
        };
        /**
         * extend Builtin prototypes with relevant methods
         */
        const extendBuiltins = () => {
          extendString();
          extendUint8Array();
        };
        const gBase64 = exports("C", {
          version: version$1,
          VERSION: VERSION,
          atob: _atob,
          atobPolyfill: atobPolyfill,
          btoa: _btoa,
          btoaPolyfill: btoaPolyfill,
          fromBase64: decode$1,
          toBase64: encode$1,
          encode: encode$1,
          encodeURI: encodeURI$1,
          encodeURL: encodeURI$1,
          utob: utob,
          btou: btou,
          decode: decode$1,
          isValid: isValid$1,
          fromUint8Array: fromUint8Array,
          toUint8Array: toUint8Array,
          extendString: extendString,
          extendUint8Array: extendUint8Array,
          extendBuiltins: extendBuiltins
        });
        var lodash$1 = {
          exports: {}
        };

        /**
         * @license
         * Lodash <https://lodash.com/>
         * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
         * Released under MIT license <https://lodash.com/license>
         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
         */
        var lodash = lodash$1.exports;
        var hasRequiredLodash;
        function requireLodash() {
          if (hasRequiredLodash) return lodash$1.exports;
          hasRequiredLodash = 1;
          (function (module, exports) {
            (function () {
              var undefined$1;
              var VERSION = "4.17.21";
              var LARGE_ARRAY_SIZE = 200;
              var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
                FUNC_ERROR_TEXT = "Expected a function",
                INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
              var HASH_UNDEFINED = "__lodash_hash_undefined__";
              var MAX_MEMOIZE_SIZE = 500;
              var PLACEHOLDER = "__lodash_placeholder__";
              var CLONE_DEEP_FLAG = 1,
                CLONE_FLAT_FLAG = 2,
                CLONE_SYMBOLS_FLAG = 4;
              var COMPARE_PARTIAL_FLAG = 1,
                COMPARE_UNORDERED_FLAG = 2;
              var WRAP_BIND_FLAG = 1,
                WRAP_BIND_KEY_FLAG = 2,
                WRAP_CURRY_BOUND_FLAG = 4,
                WRAP_CURRY_FLAG = 8,
                WRAP_CURRY_RIGHT_FLAG = 16,
                WRAP_PARTIAL_FLAG = 32,
                WRAP_PARTIAL_RIGHT_FLAG = 64,
                WRAP_ARY_FLAG = 128,
                WRAP_REARG_FLAG = 256,
                WRAP_FLIP_FLAG = 512;
              var DEFAULT_TRUNC_LENGTH = 30,
                DEFAULT_TRUNC_OMISSION = "...";
              var HOT_COUNT = 800,
                HOT_SPAN = 16;
              var LAZY_FILTER_FLAG = 1,
                LAZY_MAP_FLAG = 2,
                LAZY_WHILE_FLAG = 3;
              var INFINITY = 1 / 0,
                MAX_SAFE_INTEGER = 9007199254740991,
                MAX_INTEGER = 17976931348623157e292,
                NAN = 0 / 0;
              var MAX_ARRAY_LENGTH = 4294967295,
                MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
                HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
              var wrapFlags = [["ary", WRAP_ARY_FLAG], ["bind", WRAP_BIND_FLAG], ["bindKey", WRAP_BIND_KEY_FLAG], ["curry", WRAP_CURRY_FLAG], ["curryRight", WRAP_CURRY_RIGHT_FLAG], ["flip", WRAP_FLIP_FLAG], ["partial", WRAP_PARTIAL_FLAG], ["partialRight", WRAP_PARTIAL_RIGHT_FLAG], ["rearg", WRAP_REARG_FLAG]];
              var argsTag = "[object Arguments]",
                arrayTag = "[object Array]",
                asyncTag = "[object AsyncFunction]",
                boolTag = "[object Boolean]",
                dateTag = "[object Date]",
                domExcTag = "[object DOMException]",
                errorTag = "[object Error]",
                funcTag = "[object Function]",
                genTag = "[object GeneratorFunction]",
                mapTag = "[object Map]",
                numberTag = "[object Number]",
                nullTag = "[object Null]",
                objectTag = "[object Object]",
                promiseTag = "[object Promise]",
                proxyTag = "[object Proxy]",
                regexpTag = "[object RegExp]",
                setTag = "[object Set]",
                stringTag = "[object String]",
                symbolTag = "[object Symbol]",
                undefinedTag = "[object Undefined]",
                weakMapTag = "[object WeakMap]",
                weakSetTag = "[object WeakSet]";
              var arrayBufferTag = "[object ArrayBuffer]",
                dataViewTag = "[object DataView]",
                float32Tag = "[object Float32Array]",
                float64Tag = "[object Float64Array]",
                int8Tag = "[object Int8Array]",
                int16Tag = "[object Int16Array]",
                int32Tag = "[object Int32Array]",
                uint8Tag = "[object Uint8Array]",
                uint8ClampedTag = "[object Uint8ClampedArray]",
                uint16Tag = "[object Uint16Array]",
                uint32Tag = "[object Uint32Array]";
              var reEmptyStringLeading = /\b__p \+= '';/g,
                reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
                reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
              var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
                reUnescapedHtml = /[&<>"']/g,
                reHasEscapedHtml = RegExp(reEscapedHtml.source),
                reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
              var reEscape = /<%-([\s\S]+?)%>/g,
                reEvaluate = /<%([\s\S]+?)%>/g,
                reInterpolate = /<%=([\s\S]+?)%>/g;
              var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                reIsPlainProp = /^\w*$/,
                rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
              var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
                reHasRegExpChar = RegExp(reRegExpChar.source);
              var reTrimStart = /^\s+/;
              var reWhitespace = /\s/;
              var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
                reSplitDetails = /,? & /;
              var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
              var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
              var reEscapeChar = /\\(\\)?/g;
              var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
              var reFlags = /\w*$/;
              var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
              var reIsBinary = /^0b[01]+$/i;
              var reIsHostCtor = /^\[object .+?Constructor\]$/;
              var reIsOctal = /^0o[0-7]+$/i;
              var reIsUint = /^(?:0|[1-9]\d*)$/;
              var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
              var reNoMatch = /($^)/;
              var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
              var rsAstralRange = "\\ud800-\\udfff",
                rsComboMarksRange = "\\u0300-\\u036f",
                reComboHalfMarksRange = "\\ufe20-\\ufe2f",
                rsComboSymbolsRange = "\\u20d0-\\u20ff",
                rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
                rsDingbatRange = "\\u2700-\\u27bf",
                rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff",
                rsMathOpRange = "\\xac\\xb1\\xd7\\xf7",
                rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
                rsPunctuationRange = "\\u2000-\\u206f",
                rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
                rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde",
                rsVarRange = "\\ufe0e\\ufe0f",
                rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
              var rsApos = "[']",
                rsAstral = "[" + rsAstralRange + "]",
                rsBreak = "[" + rsBreakRange + "]",
                rsCombo = "[" + rsComboRange + "]",
                rsDigits = "\\d+",
                rsDingbat = "[" + rsDingbatRange + "]",
                rsLower = "[" + rsLowerRange + "]",
                rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]",
                rsFitz = "\\ud83c[\\udffb-\\udfff]",
                rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")",
                rsNonAstral = "[^" + rsAstralRange + "]",
                rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
                rsUpper = "[" + rsUpperRange + "]",
                rsZWJ = "\\u200d";
              var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")",
                rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")",
                rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?",
                rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?",
                reOptMod = rsModifier + "?",
                rsOptVar = "[" + rsVarRange + "]?",
                rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*",
                rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
                rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
                rsSeq = rsOptVar + reOptMod + rsOptJoin,
                rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq,
                rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
              var reApos = RegExp(rsApos, "g");
              var reComboMark = RegExp(rsCombo, "g");
              var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
              var reUnicodeWord = RegExp([rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join("|"), "g");
              var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
              var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
              var contextProps = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"];
              var templateCounter = -1;
              var typedArrayTags = {};
              typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
              typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
              var cloneableTags = {};
              cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
              cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
              var deburredLetters = {
                // Latin-1 Supplement block.
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "C",
                "": "c",
                "": "D",
                "": "d",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "N",
                "": "n",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "Y",
                "": "y",
                "": "y",
                "": "Ae",
                "": "ae",
                "": "Th",
                "": "th",
                "": "ss",
                // Latin Extended-A block.
                "": "A",
                "": "A",
                "": "A",
                "": "a",
                "": "a",
                "": "a",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "D",
                "": "D",
                "": "d",
                "": "d",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "H",
                "": "H",
                "": "h",
                "": "h",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "J",
                "": "j",
                "": "K",
                "": "k",
                "": "k",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "O",
                "": "O",
                "": "O",
                "": "o",
                "": "o",
                "": "o",
                "": "R",
                "": "R",
                "": "R",
                "": "r",
                "": "r",
                "": "r",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "T",
                "": "T",
                "": "T",
                "": "t",
                "": "t",
                "": "t",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "W",
                "": "w",
                "": "Y",
                "": "y",
                "": "Y",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "z",
                "": "z",
                "": "z",
                "": "IJ",
                "": "ij",
                "": "Oe",
                "": "oe",
                "": "'n",
                "": "s"
              };
              var htmlEscapes = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
              };
              var htmlUnescapes = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&quot;": '"',
                "&#39;": "'"
              };
              var stringEscapes = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029"
              };
              var freeParseFloat = parseFloat,
                freeParseInt = parseInt;
              var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
              var freeSelf = typeof self == "object" && self && self.Object === Object && self;
              var root = freeGlobal || freeSelf || Function("return this")();
              var freeExports = exports && !exports.nodeType && exports;
              var freeModule = freeExports && 'object' == "object" && module && !module.nodeType && module;
              var moduleExports = freeModule && freeModule.exports === freeExports;
              var freeProcess = moduleExports && freeGlobal.process;
              var nodeUtil = function () {
                try {
                  var types = freeModule && freeModule.require && freeModule.require("util").types;
                  if (types) {
                    return types;
                  }
                  return freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {}
              }();
              var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
                nodeIsDate = nodeUtil && nodeUtil.isDate,
                nodeIsMap = nodeUtil && nodeUtil.isMap,
                nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
                nodeIsSet = nodeUtil && nodeUtil.isSet,
                nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
              function apply(func, thisArg, args) {
                switch (args.length) {
                  case 0:
                    return func.call(thisArg);
                  case 1:
                    return func.call(thisArg, args[0]);
                  case 2:
                    return func.call(thisArg, args[0], args[1]);
                  case 3:
                    return func.call(thisArg, args[0], args[1], args[2]);
                }
                return func.apply(thisArg, args);
              }
              function arrayAggregator(array, setter, iteratee, accumulator) {
                var index = -1,
                  length = array == null ? 0 : array.length;
                while (++index < length) {
                  var value = array[index];
                  setter(accumulator, value, iteratee(value), array);
                }
                return accumulator;
              }
              function arrayEach(array, iteratee) {
                var index = -1,
                  length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (iteratee(array[index], index, array) === false) {
                    break;
                  }
                }
                return array;
              }
              function arrayEachRight(array, iteratee) {
                var length = array == null ? 0 : array.length;
                while (length--) {
                  if (iteratee(array[length], length, array) === false) {
                    break;
                  }
                }
                return array;
              }
              function arrayEvery(array, predicate) {
                var index = -1,
                  length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (!predicate(array[index], index, array)) {
                    return false;
                  }
                }
                return true;
              }
              function arrayFilter(array, predicate) {
                var index = -1,
                  length = array == null ? 0 : array.length,
                  resIndex = 0,
                  result = [];
                while (++index < length) {
                  var value = array[index];
                  if (predicate(value, index, array)) {
                    result[resIndex++] = value;
                  }
                }
                return result;
              }
              function arrayIncludes(array, value) {
                var length = array == null ? 0 : array.length;
                return !!length && baseIndexOf(array, value, 0) > -1;
              }
              function arrayIncludesWith(array, value, comparator) {
                var index = -1,
                  length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (comparator(value, array[index])) {
                    return true;
                  }
                }
                return false;
              }
              function arrayMap(array, iteratee) {
                var index = -1,
                  length = array == null ? 0 : array.length,
                  result = Array(length);
                while (++index < length) {
                  result[index] = iteratee(array[index], index, array);
                }
                return result;
              }
              function arrayPush(array, values) {
                var index = -1,
                  length = values.length,
                  offset = array.length;
                while (++index < length) {
                  array[offset + index] = values[index];
                }
                return array;
              }
              function arrayReduce(array, iteratee, accumulator, initAccum) {
                var index = -1,
                  length = array == null ? 0 : array.length;
                if (initAccum && length) {
                  accumulator = array[++index];
                }
                while (++index < length) {
                  accumulator = iteratee(accumulator, array[index], index, array);
                }
                return accumulator;
              }
              function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                var length = array == null ? 0 : array.length;
                if (initAccum && length) {
                  accumulator = array[--length];
                }
                while (length--) {
                  accumulator = iteratee(accumulator, array[length], length, array);
                }
                return accumulator;
              }
              function arraySome(array, predicate) {
                var index = -1,
                  length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (predicate(array[index], index, array)) {
                    return true;
                  }
                }
                return false;
              }
              var asciiSize = baseProperty("length");
              function asciiToArray(string) {
                return string.split("");
              }
              function asciiWords(string) {
                return string.match(reAsciiWord) || [];
              }
              function baseFindKey(collection, predicate, eachFunc) {
                var result;
                eachFunc(collection, function (value, key, collection2) {
                  if (predicate(value, key, collection2)) {
                    result = key;
                    return false;
                  }
                });
                return result;
              }
              function baseFindIndex(array, predicate, fromIndex, fromRight) {
                var length = array.length,
                  index = fromIndex + (fromRight ? 1 : -1);
                while (fromRight ? index-- : ++index < length) {
                  if (predicate(array[index], index, array)) {
                    return index;
                  }
                }
                return -1;
              }
              function baseIndexOf(array, value, fromIndex) {
                return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
              }
              function baseIndexOfWith(array, value, fromIndex, comparator) {
                var index = fromIndex - 1,
                  length = array.length;
                while (++index < length) {
                  if (comparator(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }
              function baseIsNaN(value) {
                return value !== value;
              }
              function baseMean(array, iteratee) {
                var length = array == null ? 0 : array.length;
                return length ? baseSum(array, iteratee) / length : NAN;
              }
              function baseProperty(key) {
                return function (object) {
                  return object == null ? undefined$1 : object[key];
                };
              }
              function basePropertyOf(object) {
                return function (key) {
                  return object == null ? undefined$1 : object[key];
                };
              }
              function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                eachFunc(collection, function (value, index, collection2) {
                  accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
                });
                return accumulator;
              }
              function baseSortBy(array, comparer) {
                var length = array.length;
                array.sort(comparer);
                while (length--) {
                  array[length] = array[length].value;
                }
                return array;
              }
              function baseSum(array, iteratee) {
                var result,
                  index = -1,
                  length = array.length;
                while (++index < length) {
                  var current = iteratee(array[index]);
                  if (current !== undefined$1) {
                    result = result === undefined$1 ? current : result + current;
                  }
                }
                return result;
              }
              function baseTimes(n, iteratee) {
                var index = -1,
                  result = Array(n);
                while (++index < n) {
                  result[index] = iteratee(index);
                }
                return result;
              }
              function baseToPairs(object, props) {
                return arrayMap(props, function (key) {
                  return [key, object[key]];
                });
              }
              function baseTrim(string) {
                return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
              }
              function baseUnary(func) {
                return function (value) {
                  return func(value);
                };
              }
              function baseValues(object, props) {
                return arrayMap(props, function (key) {
                  return object[key];
                });
              }
              function cacheHas(cache, key) {
                return cache.has(key);
              }
              function charsStartIndex(strSymbols, chrSymbols) {
                var index = -1,
                  length = strSymbols.length;
                while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
                return index;
              }
              function charsEndIndex(strSymbols, chrSymbols) {
                var index = strSymbols.length;
                while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
                return index;
              }
              function countHolders(array, placeholder) {
                var length = array.length,
                  result = 0;
                while (length--) {
                  if (array[length] === placeholder) {
                    ++result;
                  }
                }
                return result;
              }
              var deburrLetter = basePropertyOf(deburredLetters);
              var escapeHtmlChar = basePropertyOf(htmlEscapes);
              function escapeStringChar(chr) {
                return "\\" + stringEscapes[chr];
              }
              function getValue(object, key) {
                return object == null ? undefined$1 : object[key];
              }
              function hasUnicode(string) {
                return reHasUnicode.test(string);
              }
              function hasUnicodeWord(string) {
                return reHasUnicodeWord.test(string);
              }
              function iteratorToArray(iterator) {
                var data,
                  result = [];
                while (!(data = iterator.next()).done) {
                  result.push(data.value);
                }
                return result;
              }
              function mapToArray(map) {
                var index = -1,
                  result = Array(map.size);
                map.forEach(function (value, key) {
                  result[++index] = [key, value];
                });
                return result;
              }
              function overArg(func, transform) {
                return function (arg) {
                  return func(transform(arg));
                };
              }
              function replaceHolders(array, placeholder) {
                var index = -1,
                  length = array.length,
                  resIndex = 0,
                  result = [];
                while (++index < length) {
                  var value = array[index];
                  if (value === placeholder || value === PLACEHOLDER) {
                    array[index] = PLACEHOLDER;
                    result[resIndex++] = index;
                  }
                }
                return result;
              }
              function setToArray(set) {
                var index = -1,
                  result = Array(set.size);
                set.forEach(function (value) {
                  result[++index] = value;
                });
                return result;
              }
              function setToPairs(set) {
                var index = -1,
                  result = Array(set.size);
                set.forEach(function (value) {
                  result[++index] = [value, value];
                });
                return result;
              }
              function strictIndexOf(array, value, fromIndex) {
                var index = fromIndex - 1,
                  length = array.length;
                while (++index < length) {
                  if (array[index] === value) {
                    return index;
                  }
                }
                return -1;
              }
              function strictLastIndexOf(array, value, fromIndex) {
                var index = fromIndex + 1;
                while (index--) {
                  if (array[index] === value) {
                    return index;
                  }
                }
                return index;
              }
              function stringSize(string) {
                return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
              }
              function stringToArray(string) {
                return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
              }
              function trimmedEndIndex(string) {
                var index = string.length;
                while (index-- && reWhitespace.test(string.charAt(index))) {}
                return index;
              }
              var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
              function unicodeSize(string) {
                var result = reUnicode.lastIndex = 0;
                while (reUnicode.test(string)) {
                  ++result;
                }
                return result;
              }
              function unicodeToArray(string) {
                return string.match(reUnicode) || [];
              }
              function unicodeWords(string) {
                return string.match(reUnicodeWord) || [];
              }
              var runInContext = function runInContext2(context) {
                context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
                var Array2 = context.Array,
                  Date = context.Date,
                  Error = context.Error,
                  Function2 = context.Function,
                  Math = context.Math,
                  Object2 = context.Object,
                  RegExp2 = context.RegExp,
                  String = context.String,
                  TypeError = context.TypeError;
                var arrayProto = Array2.prototype,
                  funcProto = Function2.prototype,
                  objectProto = Object2.prototype;
                var coreJsData = context["__core-js_shared__"];
                var funcToString = funcProto.toString;
                var hasOwnProperty = objectProto.hasOwnProperty;
                var idCounter = 0;
                var maskSrcKey = function () {
                  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                  return uid ? "Symbol(src)_1." + uid : "";
                }();
                var nativeObjectToString = objectProto.toString;
                var objectCtorString = funcToString.call(Object2);
                var oldDash = root._;
                var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
                var Buffer = moduleExports ? context.Buffer : undefined$1,
                  Symbol = context.Symbol,
                  Uint8Array = context.Uint8Array,
                  allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
                  getPrototype = overArg(Object2.getPrototypeOf, Object2),
                  objectCreate = Object2.create,
                  propertyIsEnumerable = objectProto.propertyIsEnumerable,
                  splice = arrayProto.splice,
                  spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
                  symIterator = Symbol ? Symbol.iterator : undefined$1,
                  symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;
                var defineProperty = function () {
                  try {
                    var func = getNative(Object2, "defineProperty");
                    func({}, "", {});
                    return func;
                  } catch (e) {}
                }();
                var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
                  ctxNow = Date && Date.now !== root.Date.now && Date.now,
                  ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
                var nativeCeil = Math.ceil,
                  nativeFloor = Math.floor,
                  nativeGetSymbols = Object2.getOwnPropertySymbols,
                  nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
                  nativeIsFinite = context.isFinite,
                  nativeJoin = arrayProto.join,
                  nativeKeys = overArg(Object2.keys, Object2),
                  nativeMax = Math.max,
                  nativeMin = Math.min,
                  nativeNow = Date.now,
                  nativeParseInt = context.parseInt,
                  nativeRandom = Math.random,
                  nativeReverse = arrayProto.reverse;
                var DataView = getNative(context, "DataView"),
                  Map = getNative(context, "Map"),
                  Promise = getNative(context, "Promise"),
                  Set = getNative(context, "Set"),
                  WeakMap = getNative(context, "WeakMap"),
                  nativeCreate = getNative(Object2, "create");
                var metaMap = WeakMap && new WeakMap();
                var realNames = {};
                var dataViewCtorString = toSource(DataView),
                  mapCtorString = toSource(Map),
                  promiseCtorString = toSource(Promise),
                  setCtorString = toSource(Set),
                  weakMapCtorString = toSource(WeakMap);
                var symbolProto = Symbol ? Symbol.prototype : undefined$1,
                  symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
                  symbolToString = symbolProto ? symbolProto.toString : undefined$1;
                function lodash(value) {
                  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                    if (value instanceof LodashWrapper) {
                      return value;
                    }
                    if (hasOwnProperty.call(value, "__wrapped__")) {
                      return wrapperClone(value);
                    }
                  }
                  return new LodashWrapper(value);
                }
                var baseCreate = /* @__PURE__ */function () {
                  function object() {}
                  return function (proto) {
                    if (!isObject(proto)) {
                      return {};
                    }
                    if (objectCreate) {
                      return objectCreate(proto);
                    }
                    object.prototype = proto;
                    var result2 = new object();
                    object.prototype = undefined$1;
                    return result2;
                  };
                }();
                function baseLodash() {}
                function LodashWrapper(value, chainAll) {
                  this.__wrapped__ = value;
                  this.__actions__ = [];
                  this.__chain__ = !!chainAll;
                  this.__index__ = 0;
                  this.__values__ = undefined$1;
                }
                lodash.templateSettings = {
                  /**
                   * Used to detect `data` property values to be HTML-escaped.
                   *
                   * @memberOf _.templateSettings
                   * @type {RegExp}
                   */
                  "escape": reEscape,
                  /**
                   * Used to detect code to be evaluated.
                   *
                   * @memberOf _.templateSettings
                   * @type {RegExp}
                   */
                  "evaluate": reEvaluate,
                  /**
                   * Used to detect `data` property values to inject.
                   *
                   * @memberOf _.templateSettings
                   * @type {RegExp}
                   */
                  "interpolate": reInterpolate,
                  /**
                   * Used to reference the data object in the template text.
                   *
                   * @memberOf _.templateSettings
                   * @type {string}
                   */
                  "variable": "",
                  /**
                   * Used to import variables into the compiled template.
                   *
                   * @memberOf _.templateSettings
                   * @type {Object}
                   */
                  "imports": {
                    /**
                     * A reference to the `lodash` function.
                     *
                     * @memberOf _.templateSettings.imports
                     * @type {Function}
                     */
                    "_": lodash
                  }
                };
                lodash.prototype = baseLodash.prototype;
                lodash.prototype.constructor = lodash;
                LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                LodashWrapper.prototype.constructor = LodashWrapper;
                function LazyWrapper(value) {
                  this.__wrapped__ = value;
                  this.__actions__ = [];
                  this.__dir__ = 1;
                  this.__filtered__ = false;
                  this.__iteratees__ = [];
                  this.__takeCount__ = MAX_ARRAY_LENGTH;
                  this.__views__ = [];
                }
                function lazyClone() {
                  var result2 = new LazyWrapper(this.__wrapped__);
                  result2.__actions__ = copyArray(this.__actions__);
                  result2.__dir__ = this.__dir__;
                  result2.__filtered__ = this.__filtered__;
                  result2.__iteratees__ = copyArray(this.__iteratees__);
                  result2.__takeCount__ = this.__takeCount__;
                  result2.__views__ = copyArray(this.__views__);
                  return result2;
                }
                function lazyReverse() {
                  if (this.__filtered__) {
                    var result2 = new LazyWrapper(this);
                    result2.__dir__ = -1;
                    result2.__filtered__ = true;
                  } else {
                    result2 = this.clone();
                    result2.__dir__ *= -1;
                  }
                  return result2;
                }
                function lazyValue() {
                  var array = this.__wrapped__.value(),
                    dir = this.__dir__,
                    isArr = isArray(array),
                    isRight = dir < 0,
                    arrLength = isArr ? array.length : 0,
                    view = getView(0, arrLength, this.__views__),
                    start = view.start,
                    end = view.end,
                    length = end - start,
                    index = isRight ? end : start - 1,
                    iteratees = this.__iteratees__,
                    iterLength = iteratees.length,
                    resIndex = 0,
                    takeCount = nativeMin(length, this.__takeCount__);
                  if (!isArr || !isRight && arrLength == length && takeCount == length) {
                    return baseWrapperValue(array, this.__actions__);
                  }
                  var result2 = [];
                  outer: while (length-- && resIndex < takeCount) {
                    index += dir;
                    var iterIndex = -1,
                      value = array[index];
                    while (++iterIndex < iterLength) {
                      var data = iteratees[iterIndex],
                        iteratee2 = data.iteratee,
                        type = data.type,
                        computed = iteratee2(value);
                      if (type == LAZY_MAP_FLAG) {
                        value = computed;
                      } else if (!computed) {
                        if (type == LAZY_FILTER_FLAG) {
                          continue outer;
                        } else {
                          break outer;
                        }
                      }
                    }
                    result2[resIndex++] = value;
                  }
                  return result2;
                }
                LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                LazyWrapper.prototype.constructor = LazyWrapper;
                function Hash(entries) {
                  var index = -1,
                    length = entries == null ? 0 : entries.length;
                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }
                function hashClear() {
                  this.__data__ = nativeCreate ? nativeCreate(null) : {};
                  this.size = 0;
                }
                function hashDelete(key) {
                  var result2 = this.has(key) && delete this.__data__[key];
                  this.size -= result2 ? 1 : 0;
                  return result2;
                }
                function hashGet(key) {
                  var data = this.__data__;
                  if (nativeCreate) {
                    var result2 = data[key];
                    return result2 === HASH_UNDEFINED ? undefined$1 : result2;
                  }
                  return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
                }
                function hashHas(key) {
                  var data = this.__data__;
                  return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty.call(data, key);
                }
                function hashSet(key, value) {
                  var data = this.__data__;
                  this.size += this.has(key) ? 0 : 1;
                  data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
                  return this;
                }
                Hash.prototype.clear = hashClear;
                Hash.prototype["delete"] = hashDelete;
                Hash.prototype.get = hashGet;
                Hash.prototype.has = hashHas;
                Hash.prototype.set = hashSet;
                function ListCache(entries) {
                  var index = -1,
                    length = entries == null ? 0 : entries.length;
                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }
                function listCacheClear() {
                  this.__data__ = [];
                  this.size = 0;
                }
                function listCacheDelete(key) {
                  var data = this.__data__,
                    index = assocIndexOf(data, key);
                  if (index < 0) {
                    return false;
                  }
                  var lastIndex = data.length - 1;
                  if (index == lastIndex) {
                    data.pop();
                  } else {
                    splice.call(data, index, 1);
                  }
                  --this.size;
                  return true;
                }
                function listCacheGet(key) {
                  var data = this.__data__,
                    index = assocIndexOf(data, key);
                  return index < 0 ? undefined$1 : data[index][1];
                }
                function listCacheHas(key) {
                  return assocIndexOf(this.__data__, key) > -1;
                }
                function listCacheSet(key, value) {
                  var data = this.__data__,
                    index = assocIndexOf(data, key);
                  if (index < 0) {
                    ++this.size;
                    data.push([key, value]);
                  } else {
                    data[index][1] = value;
                  }
                  return this;
                }
                ListCache.prototype.clear = listCacheClear;
                ListCache.prototype["delete"] = listCacheDelete;
                ListCache.prototype.get = listCacheGet;
                ListCache.prototype.has = listCacheHas;
                ListCache.prototype.set = listCacheSet;
                function MapCache(entries) {
                  var index = -1,
                    length = entries == null ? 0 : entries.length;
                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }
                function mapCacheClear() {
                  this.size = 0;
                  this.__data__ = {
                    "hash": new Hash(),
                    "map": new (Map || ListCache)(),
                    "string": new Hash()
                  };
                }
                function mapCacheDelete(key) {
                  var result2 = getMapData(this, key)["delete"](key);
                  this.size -= result2 ? 1 : 0;
                  return result2;
                }
                function mapCacheGet(key) {
                  return getMapData(this, key).get(key);
                }
                function mapCacheHas(key) {
                  return getMapData(this, key).has(key);
                }
                function mapCacheSet(key, value) {
                  var data = getMapData(this, key),
                    size2 = data.size;
                  data.set(key, value);
                  this.size += data.size == size2 ? 0 : 1;
                  return this;
                }
                MapCache.prototype.clear = mapCacheClear;
                MapCache.prototype["delete"] = mapCacheDelete;
                MapCache.prototype.get = mapCacheGet;
                MapCache.prototype.has = mapCacheHas;
                MapCache.prototype.set = mapCacheSet;
                function SetCache(values2) {
                  var index = -1,
                    length = values2 == null ? 0 : values2.length;
                  this.__data__ = new MapCache();
                  while (++index < length) {
                    this.add(values2[index]);
                  }
                }
                function setCacheAdd(value) {
                  this.__data__.set(value, HASH_UNDEFINED);
                  return this;
                }
                function setCacheHas(value) {
                  return this.__data__.has(value);
                }
                SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                SetCache.prototype.has = setCacheHas;
                function Stack(entries) {
                  var data = this.__data__ = new ListCache(entries);
                  this.size = data.size;
                }
                function stackClear() {
                  this.__data__ = new ListCache();
                  this.size = 0;
                }
                function stackDelete(key) {
                  var data = this.__data__,
                    result2 = data["delete"](key);
                  this.size = data.size;
                  return result2;
                }
                function stackGet(key) {
                  return this.__data__.get(key);
                }
                function stackHas(key) {
                  return this.__data__.has(key);
                }
                function stackSet(key, value) {
                  var data = this.__data__;
                  if (data instanceof ListCache) {
                    var pairs = data.__data__;
                    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                      pairs.push([key, value]);
                      this.size = ++data.size;
                      return this;
                    }
                    data = this.__data__ = new MapCache(pairs);
                  }
                  data.set(key, value);
                  this.size = data.size;
                  return this;
                }
                Stack.prototype.clear = stackClear;
                Stack.prototype["delete"] = stackDelete;
                Stack.prototype.get = stackGet;
                Stack.prototype.has = stackHas;
                Stack.prototype.set = stackSet;
                function arrayLikeKeys(value, inherited) {
                  var isArr = isArray(value),
                    isArg = !isArr && isArguments(value),
                    isBuff = !isArr && !isArg && isBuffer(value),
                    isType = !isArr && !isArg && !isBuff && isTypedArray(value),
                    skipIndexes = isArr || isArg || isBuff || isType,
                    result2 = skipIndexes ? baseTimes(value.length, String) : [],
                    length = result2.length;
                  for (var key in value) {
                    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
                    // Safari 9 has enumerable `arguments.length` in strict mode.
                    key == "length" ||
                    // Node.js 0.10 has enumerable non-index properties on buffers.
                    isBuff && (key == "offset" || key == "parent") ||
                    // PhantomJS 2 has enumerable non-index properties on typed arrays.
                    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") ||
                    // Skip index properties.
                    isIndex(key, length)))) {
                      result2.push(key);
                    }
                  }
                  return result2;
                }
                function arraySample(array) {
                  var length = array.length;
                  return length ? array[baseRandom(0, length - 1)] : undefined$1;
                }
                function arraySampleSize(array, n) {
                  return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
                }
                function arrayShuffle(array) {
                  return shuffleSelf(copyArray(array));
                }
                function assignMergeValue(object, key, value) {
                  if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
                    baseAssignValue(object, key, value);
                  }
                }
                function assignValue(object, key, value) {
                  var objValue = object[key];
                  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
                    baseAssignValue(object, key, value);
                  }
                }
                function assocIndexOf(array, key) {
                  var length = array.length;
                  while (length--) {
                    if (eq(array[length][0], key)) {
                      return length;
                    }
                  }
                  return -1;
                }
                function baseAggregator(collection, setter, iteratee2, accumulator) {
                  baseEach(collection, function (value, key, collection2) {
                    setter(accumulator, value, iteratee2(value), collection2);
                  });
                  return accumulator;
                }
                function baseAssign(object, source) {
                  return object && copyObject(source, keys(source), object);
                }
                function baseAssignIn(object, source) {
                  return object && copyObject(source, keysIn(source), object);
                }
                function baseAssignValue(object, key, value) {
                  if (key == "__proto__" && defineProperty) {
                    defineProperty(object, key, {
                      "configurable": true,
                      "enumerable": true,
                      "value": value,
                      "writable": true
                    });
                  } else {
                    object[key] = value;
                  }
                }
                function baseAt(object, paths) {
                  var index = -1,
                    length = paths.length,
                    result2 = Array2(length),
                    skip = object == null;
                  while (++index < length) {
                    result2[index] = skip ? undefined$1 : get(object, paths[index]);
                  }
                  return result2;
                }
                function baseClamp(number, lower, upper) {
                  if (number === number) {
                    if (upper !== undefined$1) {
                      number = number <= upper ? number : upper;
                    }
                    if (lower !== undefined$1) {
                      number = number >= lower ? number : lower;
                    }
                  }
                  return number;
                }
                function baseClone(value, bitmask, customizer, key, object, stack) {
                  var result2,
                    isDeep = bitmask & CLONE_DEEP_FLAG,
                    isFlat = bitmask & CLONE_FLAT_FLAG,
                    isFull = bitmask & CLONE_SYMBOLS_FLAG;
                  if (customizer) {
                    result2 = object ? customizer(value, key, object, stack) : customizer(value);
                  }
                  if (result2 !== undefined$1) {
                    return result2;
                  }
                  if (!isObject(value)) {
                    return value;
                  }
                  var isArr = isArray(value);
                  if (isArr) {
                    result2 = initCloneArray(value);
                    if (!isDeep) {
                      return copyArray(value, result2);
                    }
                  } else {
                    var tag = getTag(value),
                      isFunc = tag == funcTag || tag == genTag;
                    if (isBuffer(value)) {
                      return cloneBuffer(value, isDeep);
                    }
                    if (tag == objectTag || tag == argsTag || isFunc && !object) {
                      result2 = isFlat || isFunc ? {} : initCloneObject(value);
                      if (!isDeep) {
                        return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                      }
                    } else {
                      if (!cloneableTags[tag]) {
                        return object ? value : {};
                      }
                      result2 = initCloneByTag(value, tag, isDeep);
                    }
                  }
                  stack || (stack = new Stack());
                  var stacked = stack.get(value);
                  if (stacked) {
                    return stacked;
                  }
                  stack.set(value, result2);
                  if (isSet(value)) {
                    value.forEach(function (subValue) {
                      result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                    });
                  } else if (isMap(value)) {
                    value.forEach(function (subValue, key2) {
                      result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                    });
                  }
                  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
                  var props = isArr ? undefined$1 : keysFunc(value);
                  arrayEach(props || value, function (subValue, key2) {
                    if (props) {
                      key2 = subValue;
                      subValue = value[key2];
                    }
                    assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                  });
                  return result2;
                }
                function baseConforms(source) {
                  var props = keys(source);
                  return function (object) {
                    return baseConformsTo(object, source, props);
                  };
                }
                function baseConformsTo(object, source, props) {
                  var length = props.length;
                  if (object == null) {
                    return !length;
                  }
                  object = Object2(object);
                  while (length--) {
                    var key = props[length],
                      predicate = source[key],
                      value = object[key];
                    if (value === undefined$1 && !(key in object) || !predicate(value)) {
                      return false;
                    }
                  }
                  return true;
                }
                function baseDelay(func, wait, args) {
                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  return setTimeout(function () {
                    func.apply(undefined$1, args);
                  }, wait);
                }
                function baseDifference(array, values2, iteratee2, comparator) {
                  var index = -1,
                    includes2 = arrayIncludes,
                    isCommon = true,
                    length = array.length,
                    result2 = [],
                    valuesLength = values2.length;
                  if (!length) {
                    return result2;
                  }
                  if (iteratee2) {
                    values2 = arrayMap(values2, baseUnary(iteratee2));
                  }
                  if (comparator) {
                    includes2 = arrayIncludesWith;
                    isCommon = false;
                  } else if (values2.length >= LARGE_ARRAY_SIZE) {
                    includes2 = cacheHas;
                    isCommon = false;
                    values2 = new SetCache(values2);
                  }
                  outer: while (++index < length) {
                    var value = array[index],
                      computed = iteratee2 == null ? value : iteratee2(value);
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var valuesIndex = valuesLength;
                      while (valuesIndex--) {
                        if (values2[valuesIndex] === computed) {
                          continue outer;
                        }
                      }
                      result2.push(value);
                    } else if (!includes2(values2, computed, comparator)) {
                      result2.push(value);
                    }
                  }
                  return result2;
                }
                var baseEach = createBaseEach(baseForOwn);
                var baseEachRight = createBaseEach(baseForOwnRight, true);
                function baseEvery(collection, predicate) {
                  var result2 = true;
                  baseEach(collection, function (value, index, collection2) {
                    result2 = !!predicate(value, index, collection2);
                    return result2;
                  });
                  return result2;
                }
                function baseExtremum(array, iteratee2, comparator) {
                  var index = -1,
                    length = array.length;
                  while (++index < length) {
                    var value = array[index],
                      current = iteratee2(value);
                    if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                      var computed = current,
                        result2 = value;
                    }
                  }
                  return result2;
                }
                function baseFill(array, value, start, end) {
                  var length = array.length;
                  start = toInteger(start);
                  if (start < 0) {
                    start = -start > length ? 0 : length + start;
                  }
                  end = end === undefined$1 || end > length ? length : toInteger(end);
                  if (end < 0) {
                    end += length;
                  }
                  end = start > end ? 0 : toLength(end);
                  while (start < end) {
                    array[start++] = value;
                  }
                  return array;
                }
                function baseFilter(collection, predicate) {
                  var result2 = [];
                  baseEach(collection, function (value, index, collection2) {
                    if (predicate(value, index, collection2)) {
                      result2.push(value);
                    }
                  });
                  return result2;
                }
                function baseFlatten(array, depth, predicate, isStrict, result2) {
                  var index = -1,
                    length = array.length;
                  predicate || (predicate = isFlattenable);
                  result2 || (result2 = []);
                  while (++index < length) {
                    var value = array[index];
                    if (depth > 0 && predicate(value)) {
                      if (depth > 1) {
                        baseFlatten(value, depth - 1, predicate, isStrict, result2);
                      } else {
                        arrayPush(result2, value);
                      }
                    } else if (!isStrict) {
                      result2[result2.length] = value;
                    }
                  }
                  return result2;
                }
                var baseFor = createBaseFor();
                var baseForRight = createBaseFor(true);
                function baseForOwn(object, iteratee2) {
                  return object && baseFor(object, iteratee2, keys);
                }
                function baseForOwnRight(object, iteratee2) {
                  return object && baseForRight(object, iteratee2, keys);
                }
                function baseFunctions(object, props) {
                  return arrayFilter(props, function (key) {
                    return isFunction(object[key]);
                  });
                }
                function baseGet(object, path) {
                  path = castPath(path, object);
                  var index = 0,
                    length = path.length;
                  while (object != null && index < length) {
                    object = object[toKey(path[index++])];
                  }
                  return index && index == length ? object : undefined$1;
                }
                function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                  var result2 = keysFunc(object);
                  return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
                }
                function baseGetTag(value) {
                  if (value == null) {
                    return value === undefined$1 ? undefinedTag : nullTag;
                  }
                  return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
                }
                function baseGt(value, other) {
                  return value > other;
                }
                function baseHas(object, key) {
                  return object != null && hasOwnProperty.call(object, key);
                }
                function baseHasIn(object, key) {
                  return object != null && key in Object2(object);
                }
                function baseInRange(number, start, end) {
                  return number >= nativeMin(start, end) && number < nativeMax(start, end);
                }
                function baseIntersection(arrays, iteratee2, comparator) {
                  var includes2 = comparator ? arrayIncludesWith : arrayIncludes,
                    length = arrays[0].length,
                    othLength = arrays.length,
                    othIndex = othLength,
                    caches = Array2(othLength),
                    maxLength = Infinity,
                    result2 = [];
                  while (othIndex--) {
                    var array = arrays[othIndex];
                    if (othIndex && iteratee2) {
                      array = arrayMap(array, baseUnary(iteratee2));
                    }
                    maxLength = nativeMin(array.length, maxLength);
                    caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
                  }
                  array = arrays[0];
                  var index = -1,
                    seen = caches[0];
                  outer: while (++index < length && result2.length < maxLength) {
                    var value = array[index],
                      computed = iteratee2 ? iteratee2(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                      othIndex = othLength;
                      while (--othIndex) {
                        var cache = caches[othIndex];
                        if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                          continue outer;
                        }
                      }
                      if (seen) {
                        seen.push(computed);
                      }
                      result2.push(value);
                    }
                  }
                  return result2;
                }
                function baseInverter(object, setter, iteratee2, accumulator) {
                  baseForOwn(object, function (value, key, object2) {
                    setter(accumulator, iteratee2(value), key, object2);
                  });
                  return accumulator;
                }
                function baseInvoke(object, path, args) {
                  path = castPath(path, object);
                  object = parent(object, path);
                  var func = object == null ? object : object[toKey(last(path))];
                  return func == null ? undefined$1 : apply(func, object, args);
                }
                function baseIsArguments(value) {
                  return isObjectLike(value) && baseGetTag(value) == argsTag;
                }
                function baseIsArrayBuffer(value) {
                  return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
                }
                function baseIsDate(value) {
                  return isObjectLike(value) && baseGetTag(value) == dateTag;
                }
                function baseIsEqual(value, other, bitmask, customizer, stack) {
                  if (value === other) {
                    return true;
                  }
                  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                    return value !== value && other !== other;
                  }
                  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
                }
                function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                  var objIsArr = isArray(object),
                    othIsArr = isArray(other),
                    objTag = objIsArr ? arrayTag : getTag(object),
                    othTag = othIsArr ? arrayTag : getTag(other);
                  objTag = objTag == argsTag ? objectTag : objTag;
                  othTag = othTag == argsTag ? objectTag : othTag;
                  var objIsObj = objTag == objectTag,
                    othIsObj = othTag == objectTag,
                    isSameTag = objTag == othTag;
                  if (isSameTag && isBuffer(object)) {
                    if (!isBuffer(other)) {
                      return false;
                    }
                    objIsArr = true;
                    objIsObj = false;
                  }
                  if (isSameTag && !objIsObj) {
                    stack || (stack = new Stack());
                    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                  }
                  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"),
                      othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                    if (objIsWrapped || othIsWrapped) {
                      var objUnwrapped = objIsWrapped ? object.value() : object,
                        othUnwrapped = othIsWrapped ? other.value() : other;
                      stack || (stack = new Stack());
                      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                    }
                  }
                  if (!isSameTag) {
                    return false;
                  }
                  stack || (stack = new Stack());
                  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
                }
                function baseIsMap(value) {
                  return isObjectLike(value) && getTag(value) == mapTag;
                }
                function baseIsMatch(object, source, matchData, customizer) {
                  var index = matchData.length,
                    length = index,
                    noCustomizer = !customizer;
                  if (object == null) {
                    return !length;
                  }
                  object = Object2(object);
                  while (index--) {
                    var data = matchData[index];
                    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                      return false;
                    }
                  }
                  while (++index < length) {
                    data = matchData[index];
                    var key = data[0],
                      objValue = object[key],
                      srcValue = data[1];
                    if (noCustomizer && data[2]) {
                      if (objValue === undefined$1 && !(key in object)) {
                        return false;
                      }
                    } else {
                      var stack = new Stack();
                      if (customizer) {
                        var result2 = customizer(objValue, srcValue, key, object, source, stack);
                      }
                      if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                        return false;
                      }
                    }
                  }
                  return true;
                }
                function baseIsNative(value) {
                  if (!isObject(value) || isMasked(value)) {
                    return false;
                  }
                  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                  return pattern.test(toSource(value));
                }
                function baseIsRegExp(value) {
                  return isObjectLike(value) && baseGetTag(value) == regexpTag;
                }
                function baseIsSet(value) {
                  return isObjectLike(value) && getTag(value) == setTag;
                }
                function baseIsTypedArray(value) {
                  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
                }
                function baseIteratee(value) {
                  if (typeof value == "function") {
                    return value;
                  }
                  if (value == null) {
                    return identity;
                  }
                  if (typeof value == "object") {
                    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                  }
                  return property(value);
                }
                function baseKeys(object) {
                  if (!isPrototype(object)) {
                    return nativeKeys(object);
                  }
                  var result2 = [];
                  for (var key in Object2(object)) {
                    if (hasOwnProperty.call(object, key) && key != "constructor") {
                      result2.push(key);
                    }
                  }
                  return result2;
                }
                function baseKeysIn(object) {
                  if (!isObject(object)) {
                    return nativeKeysIn(object);
                  }
                  var isProto = isPrototype(object),
                    result2 = [];
                  for (var key in object) {
                    if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                      result2.push(key);
                    }
                  }
                  return result2;
                }
                function baseLt(value, other) {
                  return value < other;
                }
                function baseMap(collection, iteratee2) {
                  var index = -1,
                    result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                  baseEach(collection, function (value, key, collection2) {
                    result2[++index] = iteratee2(value, key, collection2);
                  });
                  return result2;
                }
                function baseMatches(source) {
                  var matchData = getMatchData(source);
                  if (matchData.length == 1 && matchData[0][2]) {
                    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                  }
                  return function (object) {
                    return object === source || baseIsMatch(object, source, matchData);
                  };
                }
                function baseMatchesProperty(path, srcValue) {
                  if (isKey(path) && isStrictComparable(srcValue)) {
                    return matchesStrictComparable(toKey(path), srcValue);
                  }
                  return function (object) {
                    var objValue = get(object, path);
                    return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                  };
                }
                function baseMerge(object, source, srcIndex, customizer, stack) {
                  if (object === source) {
                    return;
                  }
                  baseFor(source, function (srcValue, key) {
                    stack || (stack = new Stack());
                    if (isObject(srcValue)) {
                      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                    } else {
                      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
                      if (newValue === undefined$1) {
                        newValue = srcValue;
                      }
                      assignMergeValue(object, key, newValue);
                    }
                  }, keysIn);
                }
                function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                  var objValue = safeGet(object, key),
                    srcValue = safeGet(source, key),
                    stacked = stack.get(srcValue);
                  if (stacked) {
                    assignMergeValue(object, key, stacked);
                    return;
                  }
                  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
                  var isCommon = newValue === undefined$1;
                  if (isCommon) {
                    var isArr = isArray(srcValue),
                      isBuff = !isArr && isBuffer(srcValue),
                      isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                    newValue = srcValue;
                    if (isArr || isBuff || isTyped) {
                      if (isArray(objValue)) {
                        newValue = objValue;
                      } else if (isArrayLikeObject(objValue)) {
                        newValue = copyArray(objValue);
                      } else if (isBuff) {
                        isCommon = false;
                        newValue = cloneBuffer(srcValue, true);
                      } else if (isTyped) {
                        isCommon = false;
                        newValue = cloneTypedArray(srcValue, true);
                      } else {
                        newValue = [];
                      }
                    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                      newValue = objValue;
                      if (isArguments(objValue)) {
                        newValue = toPlainObject(objValue);
                      } else if (!isObject(objValue) || isFunction(objValue)) {
                        newValue = initCloneObject(srcValue);
                      }
                    } else {
                      isCommon = false;
                    }
                  }
                  if (isCommon) {
                    stack.set(srcValue, newValue);
                    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                    stack["delete"](srcValue);
                  }
                  assignMergeValue(object, key, newValue);
                }
                function baseNth(array, n) {
                  var length = array.length;
                  if (!length) {
                    return;
                  }
                  n += n < 0 ? length : 0;
                  return isIndex(n, length) ? array[n] : undefined$1;
                }
                function baseOrderBy(collection, iteratees, orders) {
                  if (iteratees.length) {
                    iteratees = arrayMap(iteratees, function (iteratee2) {
                      if (isArray(iteratee2)) {
                        return function (value) {
                          return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                        };
                      }
                      return iteratee2;
                    });
                  } else {
                    iteratees = [identity];
                  }
                  var index = -1;
                  iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                  var result2 = baseMap(collection, function (value, key, collection2) {
                    var criteria = arrayMap(iteratees, function (iteratee2) {
                      return iteratee2(value);
                    });
                    return {
                      "criteria": criteria,
                      "index": ++index,
                      "value": value
                    };
                  });
                  return baseSortBy(result2, function (object, other) {
                    return compareMultiple(object, other, orders);
                  });
                }
                function basePick(object, paths) {
                  return basePickBy(object, paths, function (value, path) {
                    return hasIn(object, path);
                  });
                }
                function basePickBy(object, paths, predicate) {
                  var index = -1,
                    length = paths.length,
                    result2 = {};
                  while (++index < length) {
                    var path = paths[index],
                      value = baseGet(object, path);
                    if (predicate(value, path)) {
                      baseSet(result2, castPath(path, object), value);
                    }
                  }
                  return result2;
                }
                function basePropertyDeep(path) {
                  return function (object) {
                    return baseGet(object, path);
                  };
                }
                function basePullAll(array, values2, iteratee2, comparator) {
                  var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf,
                    index = -1,
                    length = values2.length,
                    seen = array;
                  if (array === values2) {
                    values2 = copyArray(values2);
                  }
                  if (iteratee2) {
                    seen = arrayMap(array, baseUnary(iteratee2));
                  }
                  while (++index < length) {
                    var fromIndex = 0,
                      value = values2[index],
                      computed = iteratee2 ? iteratee2(value) : value;
                    while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                      if (seen !== array) {
                        splice.call(seen, fromIndex, 1);
                      }
                      splice.call(array, fromIndex, 1);
                    }
                  }
                  return array;
                }
                function basePullAt(array, indexes) {
                  var length = array ? indexes.length : 0,
                    lastIndex = length - 1;
                  while (length--) {
                    var index = indexes[length];
                    if (length == lastIndex || index !== previous) {
                      var previous = index;
                      if (isIndex(index)) {
                        splice.call(array, index, 1);
                      } else {
                        baseUnset(array, index);
                      }
                    }
                  }
                  return array;
                }
                function baseRandom(lower, upper) {
                  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
                }
                function baseRange(start, end, step, fromRight) {
                  var index = -1,
                    length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                    result2 = Array2(length);
                  while (length--) {
                    result2[fromRight ? length : ++index] = start;
                    start += step;
                  }
                  return result2;
                }
                function baseRepeat(string, n) {
                  var result2 = "";
                  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                    return result2;
                  }
                  do {
                    if (n % 2) {
                      result2 += string;
                    }
                    n = nativeFloor(n / 2);
                    if (n) {
                      string += string;
                    }
                  } while (n);
                  return result2;
                }
                function baseRest(func, start) {
                  return setToString(overRest(func, start, identity), func + "");
                }
                function baseSample(collection) {
                  return arraySample(values(collection));
                }
                function baseSampleSize(collection, n) {
                  var array = values(collection);
                  return shuffleSelf(array, baseClamp(n, 0, array.length));
                }
                function baseSet(object, path, value, customizer) {
                  if (!isObject(object)) {
                    return object;
                  }
                  path = castPath(path, object);
                  var index = -1,
                    length = path.length,
                    lastIndex = length - 1,
                    nested = object;
                  while (nested != null && ++index < length) {
                    var key = toKey(path[index]),
                      newValue = value;
                    if (key === "__proto__" || key === "constructor" || key === "prototype") {
                      return object;
                    }
                    if (index != lastIndex) {
                      var objValue = nested[key];
                      newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
                      if (newValue === undefined$1) {
                        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                      }
                    }
                    assignValue(nested, key, newValue);
                    nested = nested[key];
                  }
                  return object;
                }
                var baseSetData = !metaMap ? identity : function (func, data) {
                  metaMap.set(func, data);
                  return func;
                };
                var baseSetToString = !defineProperty ? identity : function (func, string) {
                  return defineProperty(func, "toString", {
                    "configurable": true,
                    "enumerable": false,
                    "value": constant(string),
                    "writable": true
                  });
                };
                function baseShuffle(collection) {
                  return shuffleSelf(values(collection));
                }
                function baseSlice(array, start, end) {
                  var index = -1,
                    length = array.length;
                  if (start < 0) {
                    start = -start > length ? 0 : length + start;
                  }
                  end = end > length ? length : end;
                  if (end < 0) {
                    end += length;
                  }
                  length = start > end ? 0 : end - start >>> 0;
                  start >>>= 0;
                  var result2 = Array2(length);
                  while (++index < length) {
                    result2[index] = array[index + start];
                  }
                  return result2;
                }
                function baseSome(collection, predicate) {
                  var result2;
                  baseEach(collection, function (value, index, collection2) {
                    result2 = predicate(value, index, collection2);
                    return !result2;
                  });
                  return !!result2;
                }
                function baseSortedIndex(array, value, retHighest) {
                  var low = 0,
                    high = array == null ? low : array.length;
                  if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                    while (low < high) {
                      var mid = low + high >>> 1,
                        computed = array[mid];
                      if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                        low = mid + 1;
                      } else {
                        high = mid;
                      }
                    }
                    return high;
                  }
                  return baseSortedIndexBy(array, value, identity, retHighest);
                }
                function baseSortedIndexBy(array, value, iteratee2, retHighest) {
                  var low = 0,
                    high = array == null ? 0 : array.length;
                  if (high === 0) {
                    return 0;
                  }
                  value = iteratee2(value);
                  var valIsNaN = value !== value,
                    valIsNull = value === null,
                    valIsSymbol = isSymbol(value),
                    valIsUndefined = value === undefined$1;
                  while (low < high) {
                    var mid = nativeFloor((low + high) / 2),
                      computed = iteratee2(array[mid]),
                      othIsDefined = computed !== undefined$1,
                      othIsNull = computed === null,
                      othIsReflexive = computed === computed,
                      othIsSymbol = isSymbol(computed);
                    if (valIsNaN) {
                      var setLow = retHighest || othIsReflexive;
                    } else if (valIsUndefined) {
                      setLow = othIsReflexive && (retHighest || othIsDefined);
                    } else if (valIsNull) {
                      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                    } else if (valIsSymbol) {
                      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                    } else if (othIsNull || othIsSymbol) {
                      setLow = false;
                    } else {
                      setLow = retHighest ? computed <= value : computed < value;
                    }
                    if (setLow) {
                      low = mid + 1;
                    } else {
                      high = mid;
                    }
                  }
                  return nativeMin(high, MAX_ARRAY_INDEX);
                }
                function baseSortedUniq(array, iteratee2) {
                  var index = -1,
                    length = array.length,
                    resIndex = 0,
                    result2 = [];
                  while (++index < length) {
                    var value = array[index],
                      computed = iteratee2 ? iteratee2(value) : value;
                    if (!index || !eq(computed, seen)) {
                      var seen = computed;
                      result2[resIndex++] = value === 0 ? 0 : value;
                    }
                  }
                  return result2;
                }
                function baseToNumber(value) {
                  if (typeof value == "number") {
                    return value;
                  }
                  if (isSymbol(value)) {
                    return NAN;
                  }
                  return +value;
                }
                function baseToString(value) {
                  if (typeof value == "string") {
                    return value;
                  }
                  if (isArray(value)) {
                    return arrayMap(value, baseToString) + "";
                  }
                  if (isSymbol(value)) {
                    return symbolToString ? symbolToString.call(value) : "";
                  }
                  var result2 = value + "";
                  return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
                }
                function baseUniq(array, iteratee2, comparator) {
                  var index = -1,
                    includes2 = arrayIncludes,
                    length = array.length,
                    isCommon = true,
                    result2 = [],
                    seen = result2;
                  if (comparator) {
                    isCommon = false;
                    includes2 = arrayIncludesWith;
                  } else if (length >= LARGE_ARRAY_SIZE) {
                    var set2 = iteratee2 ? null : createSet(array);
                    if (set2) {
                      return setToArray(set2);
                    }
                    isCommon = false;
                    includes2 = cacheHas;
                    seen = new SetCache();
                  } else {
                    seen = iteratee2 ? [] : result2;
                  }
                  outer: while (++index < length) {
                    var value = array[index],
                      computed = iteratee2 ? iteratee2(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var seenIndex = seen.length;
                      while (seenIndex--) {
                        if (seen[seenIndex] === computed) {
                          continue outer;
                        }
                      }
                      if (iteratee2) {
                        seen.push(computed);
                      }
                      result2.push(value);
                    } else if (!includes2(seen, computed, comparator)) {
                      if (seen !== result2) {
                        seen.push(computed);
                      }
                      result2.push(value);
                    }
                  }
                  return result2;
                }
                function baseUnset(object, path) {
                  path = castPath(path, object);
                  object = parent(object, path);
                  return object == null || delete object[toKey(last(path))];
                }
                function baseUpdate(object, path, updater, customizer) {
                  return baseSet(object, path, updater(baseGet(object, path)), customizer);
                }
                function baseWhile(array, predicate, isDrop, fromRight) {
                  var length = array.length,
                    index = fromRight ? length : -1;
                  while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
                  return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
                }
                function baseWrapperValue(value, actions) {
                  var result2 = value;
                  if (result2 instanceof LazyWrapper) {
                    result2 = result2.value();
                  }
                  return arrayReduce(actions, function (result3, action) {
                    return action.func.apply(action.thisArg, arrayPush([result3], action.args));
                  }, result2);
                }
                function baseXor(arrays, iteratee2, comparator) {
                  var length = arrays.length;
                  if (length < 2) {
                    return length ? baseUniq(arrays[0]) : [];
                  }
                  var index = -1,
                    result2 = Array2(length);
                  while (++index < length) {
                    var array = arrays[index],
                      othIndex = -1;
                    while (++othIndex < length) {
                      if (othIndex != index) {
                        result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                      }
                    }
                  }
                  return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
                }
                function baseZipObject(props, values2, assignFunc) {
                  var index = -1,
                    length = props.length,
                    valsLength = values2.length,
                    result2 = {};
                  while (++index < length) {
                    var value = index < valsLength ? values2[index] : undefined$1;
                    assignFunc(result2, props[index], value);
                  }
                  return result2;
                }
                function castArrayLikeObject(value) {
                  return isArrayLikeObject(value) ? value : [];
                }
                function castFunction(value) {
                  return typeof value == "function" ? value : identity;
                }
                function castPath(value, object) {
                  if (isArray(value)) {
                    return value;
                  }
                  return isKey(value, object) ? [value] : stringToPath(toString(value));
                }
                var castRest = baseRest;
                function castSlice(array, start, end) {
                  var length = array.length;
                  end = end === undefined$1 ? length : end;
                  return !start && end >= length ? array : baseSlice(array, start, end);
                }
                var clearTimeout = ctxClearTimeout || function (id) {
                  return root.clearTimeout(id);
                };
                function cloneBuffer(buffer, isDeep) {
                  if (isDeep) {
                    return buffer.slice();
                  }
                  var length = buffer.length,
                    result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                  buffer.copy(result2);
                  return result2;
                }
                function cloneArrayBuffer(arrayBuffer) {
                  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
                  new Uint8Array(result2).set(new Uint8Array(arrayBuffer));
                  return result2;
                }
                function cloneDataView(dataView, isDeep) {
                  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                }
                function cloneRegExp(regexp) {
                  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                  result2.lastIndex = regexp.lastIndex;
                  return result2;
                }
                function cloneSymbol(symbol) {
                  return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
                }
                function cloneTypedArray(typedArray, isDeep) {
                  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                }
                function compareAscending(value, other) {
                  if (value !== other) {
                    var valIsDefined = value !== undefined$1,
                      valIsNull = value === null,
                      valIsReflexive = value === value,
                      valIsSymbol = isSymbol(value);
                    var othIsDefined = other !== undefined$1,
                      othIsNull = other === null,
                      othIsReflexive = other === other,
                      othIsSymbol = isSymbol(other);
                    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                      return 1;
                    }
                    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                      return -1;
                    }
                  }
                  return 0;
                }
                function compareMultiple(object, other, orders) {
                  var index = -1,
                    objCriteria = object.criteria,
                    othCriteria = other.criteria,
                    length = objCriteria.length,
                    ordersLength = orders.length;
                  while (++index < length) {
                    var result2 = compareAscending(objCriteria[index], othCriteria[index]);
                    if (result2) {
                      if (index >= ordersLength) {
                        return result2;
                      }
                      var order = orders[index];
                      return result2 * (order == "desc" ? -1 : 1);
                    }
                  }
                  return object.index - other.index;
                }
                function composeArgs(args, partials, holders, isCurried) {
                  var argsIndex = -1,
                    argsLength = args.length,
                    holdersLength = holders.length,
                    leftIndex = -1,
                    leftLength = partials.length,
                    rangeLength = nativeMax(argsLength - holdersLength, 0),
                    result2 = Array2(leftLength + rangeLength),
                    isUncurried = !isCurried;
                  while (++leftIndex < leftLength) {
                    result2[leftIndex] = partials[leftIndex];
                  }
                  while (++argsIndex < holdersLength) {
                    if (isUncurried || argsIndex < argsLength) {
                      result2[holders[argsIndex]] = args[argsIndex];
                    }
                  }
                  while (rangeLength--) {
                    result2[leftIndex++] = args[argsIndex++];
                  }
                  return result2;
                }
                function composeArgsRight(args, partials, holders, isCurried) {
                  var argsIndex = -1,
                    argsLength = args.length,
                    holdersIndex = -1,
                    holdersLength = holders.length,
                    rightIndex = -1,
                    rightLength = partials.length,
                    rangeLength = nativeMax(argsLength - holdersLength, 0),
                    result2 = Array2(rangeLength + rightLength),
                    isUncurried = !isCurried;
                  while (++argsIndex < rangeLength) {
                    result2[argsIndex] = args[argsIndex];
                  }
                  var offset = argsIndex;
                  while (++rightIndex < rightLength) {
                    result2[offset + rightIndex] = partials[rightIndex];
                  }
                  while (++holdersIndex < holdersLength) {
                    if (isUncurried || argsIndex < argsLength) {
                      result2[offset + holders[holdersIndex]] = args[argsIndex++];
                    }
                  }
                  return result2;
                }
                function copyArray(source, array) {
                  var index = -1,
                    length = source.length;
                  array || (array = Array2(length));
                  while (++index < length) {
                    array[index] = source[index];
                  }
                  return array;
                }
                function copyObject(source, props, object, customizer) {
                  var isNew = !object;
                  object || (object = {});
                  var index = -1,
                    length = props.length;
                  while (++index < length) {
                    var key = props[index];
                    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
                    if (newValue === undefined$1) {
                      newValue = source[key];
                    }
                    if (isNew) {
                      baseAssignValue(object, key, newValue);
                    } else {
                      assignValue(object, key, newValue);
                    }
                  }
                  return object;
                }
                function copySymbols(source, object) {
                  return copyObject(source, getSymbols(source), object);
                }
                function copySymbolsIn(source, object) {
                  return copyObject(source, getSymbolsIn(source), object);
                }
                function createAggregator(setter, initializer) {
                  return function (collection, iteratee2) {
                    var func = isArray(collection) ? arrayAggregator : baseAggregator,
                      accumulator = initializer ? initializer() : {};
                    return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
                  };
                }
                function createAssigner(assigner) {
                  return baseRest(function (object, sources) {
                    var index = -1,
                      length = sources.length,
                      customizer = length > 1 ? sources[length - 1] : undefined$1,
                      guard = length > 2 ? sources[2] : undefined$1;
                    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
                    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                      customizer = length < 3 ? undefined$1 : customizer;
                      length = 1;
                    }
                    object = Object2(object);
                    while (++index < length) {
                      var source = sources[index];
                      if (source) {
                        assigner(object, source, index, customizer);
                      }
                    }
                    return object;
                  });
                }
                function createBaseEach(eachFunc, fromRight) {
                  return function (collection, iteratee2) {
                    if (collection == null) {
                      return collection;
                    }
                    if (!isArrayLike(collection)) {
                      return eachFunc(collection, iteratee2);
                    }
                    var length = collection.length,
                      index = fromRight ? length : -1,
                      iterable = Object2(collection);
                    while (fromRight ? index-- : ++index < length) {
                      if (iteratee2(iterable[index], index, iterable) === false) {
                        break;
                      }
                    }
                    return collection;
                  };
                }
                function createBaseFor(fromRight) {
                  return function (object, iteratee2, keysFunc) {
                    var index = -1,
                      iterable = Object2(object),
                      props = keysFunc(object),
                      length = props.length;
                    while (length--) {
                      var key = props[fromRight ? length : ++index];
                      if (iteratee2(iterable[key], key, iterable) === false) {
                        break;
                      }
                    }
                    return object;
                  };
                }
                function createBind(func, bitmask, thisArg) {
                  var isBind = bitmask & WRAP_BIND_FLAG,
                    Ctor = createCtor(func);
                  function wrapper() {
                    var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                    return fn.apply(isBind ? thisArg : this, arguments);
                  }
                  return wrapper;
                }
                function createCaseFirst(methodName) {
                  return function (string) {
                    string = toString(string);
                    var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
                    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                    return chr[methodName]() + trailing;
                  };
                }
                function createCompounder(callback) {
                  return function (string) {
                    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
                  };
                }
                function createCtor(Ctor) {
                  return function () {
                    var args = arguments;
                    switch (args.length) {
                      case 0:
                        return new Ctor();
                      case 1:
                        return new Ctor(args[0]);
                      case 2:
                        return new Ctor(args[0], args[1]);
                      case 3:
                        return new Ctor(args[0], args[1], args[2]);
                      case 4:
                        return new Ctor(args[0], args[1], args[2], args[3]);
                      case 5:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                      case 6:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                      case 7:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                    }
                    var thisBinding = baseCreate(Ctor.prototype),
                      result2 = Ctor.apply(thisBinding, args);
                    return isObject(result2) ? result2 : thisBinding;
                  };
                }
                function createCurry(func, bitmask, arity) {
                  var Ctor = createCtor(func);
                  function wrapper() {
                    var length = arguments.length,
                      args = Array2(length),
                      index = length,
                      placeholder = getHolder(wrapper);
                    while (index--) {
                      args[index] = arguments[index];
                    }
                    var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                    length -= holders.length;
                    if (length < arity) {
                      return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length);
                    }
                    var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                    return apply(fn, this, args);
                  }
                  return wrapper;
                }
                function createFind(findIndexFunc) {
                  return function (collection, predicate, fromIndex) {
                    var iterable = Object2(collection);
                    if (!isArrayLike(collection)) {
                      var iteratee2 = getIteratee(predicate, 3);
                      collection = keys(collection);
                      predicate = function (key) {
                        return iteratee2(iterable[key], key, iterable);
                      };
                    }
                    var index = findIndexFunc(collection, predicate, fromIndex);
                    return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
                  };
                }
                function createFlow(fromRight) {
                  return flatRest(function (funcs) {
                    var length = funcs.length,
                      index = length,
                      prereq = LodashWrapper.prototype.thru;
                    if (fromRight) {
                      funcs.reverse();
                    }
                    while (index--) {
                      var func = funcs[index];
                      if (typeof func != "function") {
                        throw new TypeError(FUNC_ERROR_TEXT);
                      }
                      if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                        var wrapper = new LodashWrapper([], true);
                      }
                    }
                    index = wrapper ? index : length;
                    while (++index < length) {
                      func = funcs[index];
                      var funcName = getFuncName(func),
                        data = funcName == "wrapper" ? getData(func) : undefined$1;
                      if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                      } else {
                        wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                      }
                    }
                    return function () {
                      var args = arguments,
                        value = args[0];
                      if (wrapper && args.length == 1 && isArray(value)) {
                        return wrapper.plant(value).value();
                      }
                      var index2 = 0,
                        result2 = length ? funcs[index2].apply(this, args) : value;
                      while (++index2 < length) {
                        result2 = funcs[index2].call(this, result2);
                      }
                      return result2;
                    };
                  });
                }
                function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
                  var isAry = bitmask & WRAP_ARY_FLAG,
                    isBind = bitmask & WRAP_BIND_FLAG,
                    isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
                    isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
                    isFlip = bitmask & WRAP_FLIP_FLAG,
                    Ctor = isBindKey ? undefined$1 : createCtor(func);
                  function wrapper() {
                    var length = arguments.length,
                      args = Array2(length),
                      index = length;
                    while (index--) {
                      args[index] = arguments[index];
                    }
                    if (isCurried) {
                      var placeholder = getHolder(wrapper),
                        holdersCount = countHolders(args, placeholder);
                    }
                    if (partials) {
                      args = composeArgs(args, partials, holders, isCurried);
                    }
                    if (partialsRight) {
                      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                    }
                    length -= holdersCount;
                    if (isCurried && length < arity) {
                      var newHolders = replaceHolders(args, placeholder);
                      return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
                    }
                    var thisBinding = isBind ? thisArg : this,
                      fn = isBindKey ? thisBinding[func] : func;
                    length = args.length;
                    if (argPos) {
                      args = reorder(args, argPos);
                    } else if (isFlip && length > 1) {
                      args.reverse();
                    }
                    if (isAry && ary2 < length) {
                      args.length = ary2;
                    }
                    if (this && this !== root && this instanceof wrapper) {
                      fn = Ctor || createCtor(fn);
                    }
                    return fn.apply(thisBinding, args);
                  }
                  return wrapper;
                }
                function createInverter(setter, toIteratee) {
                  return function (object, iteratee2) {
                    return baseInverter(object, setter, toIteratee(iteratee2), {});
                  };
                }
                function createMathOperation(operator, defaultValue) {
                  return function (value, other) {
                    var result2;
                    if (value === undefined$1 && other === undefined$1) {
                      return defaultValue;
                    }
                    if (value !== undefined$1) {
                      result2 = value;
                    }
                    if (other !== undefined$1) {
                      if (result2 === undefined$1) {
                        return other;
                      }
                      if (typeof value == "string" || typeof other == "string") {
                        value = baseToString(value);
                        other = baseToString(other);
                      } else {
                        value = baseToNumber(value);
                        other = baseToNumber(other);
                      }
                      result2 = operator(value, other);
                    }
                    return result2;
                  };
                }
                function createOver(arrayFunc) {
                  return flatRest(function (iteratees) {
                    iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                    return baseRest(function (args) {
                      var thisArg = this;
                      return arrayFunc(iteratees, function (iteratee2) {
                        return apply(iteratee2, thisArg, args);
                      });
                    });
                  });
                }
                function createPadding(length, chars) {
                  chars = chars === undefined$1 ? " " : baseToString(chars);
                  var charsLength = chars.length;
                  if (charsLength < 2) {
                    return charsLength ? baseRepeat(chars, length) : chars;
                  }
                  var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                  return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
                }
                function createPartial(func, bitmask, thisArg, partials) {
                  var isBind = bitmask & WRAP_BIND_FLAG,
                    Ctor = createCtor(func);
                  function wrapper() {
                    var argsIndex = -1,
                      argsLength = arguments.length,
                      leftIndex = -1,
                      leftLength = partials.length,
                      args = Array2(leftLength + argsLength),
                      fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                    while (++leftIndex < leftLength) {
                      args[leftIndex] = partials[leftIndex];
                    }
                    while (argsLength--) {
                      args[leftIndex++] = arguments[++argsIndex];
                    }
                    return apply(fn, isBind ? thisArg : this, args);
                  }
                  return wrapper;
                }
                function createRange(fromRight) {
                  return function (start, end, step) {
                    if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                      end = step = undefined$1;
                    }
                    start = toFinite(start);
                    if (end === undefined$1) {
                      end = start;
                      start = 0;
                    } else {
                      end = toFinite(end);
                    }
                    step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
                    return baseRange(start, end, step, fromRight);
                  };
                }
                function createRelationalOperation(operator) {
                  return function (value, other) {
                    if (!(typeof value == "string" && typeof other == "string")) {
                      value = toNumber(value);
                      other = toNumber(other);
                    }
                    return operator(value, other);
                  };
                }
                function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
                  var isCurry = bitmask & WRAP_CURRY_FLAG,
                    newHolders = isCurry ? holders : undefined$1,
                    newHoldersRight = isCurry ? undefined$1 : holders,
                    newPartials = isCurry ? partials : undefined$1,
                    newPartialsRight = isCurry ? undefined$1 : partials;
                  bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                    bitmask &= -4;
                  }
                  var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary2, arity];
                  var result2 = wrapFunc.apply(undefined$1, newData);
                  if (isLaziable(func)) {
                    setData(result2, newData);
                  }
                  result2.placeholder = placeholder;
                  return setWrapToString(result2, func, bitmask);
                }
                function createRound(methodName) {
                  var func = Math[methodName];
                  return function (number, precision) {
                    number = toNumber(number);
                    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                    if (precision && nativeIsFinite(number)) {
                      var pair = (toString(number) + "e").split("e"),
                        value = func(pair[0] + "e" + (+pair[1] + precision));
                      pair = (toString(value) + "e").split("e");
                      return +(pair[0] + "e" + (+pair[1] - precision));
                    }
                    return func(number);
                  };
                }
                var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values2) {
                  return new Set(values2);
                };
                function createToPairs(keysFunc) {
                  return function (object) {
                    var tag = getTag(object);
                    if (tag == mapTag) {
                      return mapToArray(object);
                    }
                    if (tag == setTag) {
                      return setToPairs(object);
                    }
                    return baseToPairs(object, keysFunc(object));
                  };
                }
                function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
                  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                  if (!isBindKey && typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  var length = partials ? partials.length : 0;
                  if (!length) {
                    bitmask &= -97;
                    partials = holders = undefined$1;
                  }
                  ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
                  arity = arity === undefined$1 ? arity : toInteger(arity);
                  length -= holders ? holders.length : 0;
                  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                    var partialsRight = partials,
                      holdersRight = holders;
                    partials = holders = undefined$1;
                  }
                  var data = isBindKey ? undefined$1 : getData(func);
                  var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity];
                  if (data) {
                    mergeData(newData, data);
                  }
                  func = newData[0];
                  bitmask = newData[1];
                  thisArg = newData[2];
                  partials = newData[3];
                  holders = newData[4];
                  arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
                  if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                    bitmask &= -25;
                  }
                  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                    var result2 = createBind(func, bitmask, thisArg);
                  } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                    result2 = createCurry(func, bitmask, arity);
                  } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                    result2 = createPartial(func, bitmask, thisArg, partials);
                  } else {
                    result2 = createHybrid.apply(undefined$1, newData);
                  }
                  var setter = data ? baseSetData : setData;
                  return setWrapToString(setter(result2, newData), func, bitmask);
                }
                function customDefaultsAssignIn(objValue, srcValue, key, object) {
                  if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                    return srcValue;
                  }
                  return objValue;
                }
                function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                  if (isObject(objValue) && isObject(srcValue)) {
                    stack.set(srcValue, objValue);
                    baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
                    stack["delete"](srcValue);
                  }
                  return objValue;
                }
                function customOmitClone(value) {
                  return isPlainObject(value) ? undefined$1 : value;
                }
                function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                    arrLength = array.length,
                    othLength = other.length;
                  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                    return false;
                  }
                  var arrStacked = stack.get(array);
                  var othStacked = stack.get(other);
                  if (arrStacked && othStacked) {
                    return arrStacked == other && othStacked == array;
                  }
                  var index = -1,
                    result2 = true,
                    seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
                  stack.set(array, other);
                  stack.set(other, array);
                  while (++index < arrLength) {
                    var arrValue = array[index],
                      othValue = other[index];
                    if (customizer) {
                      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                    }
                    if (compared !== undefined$1) {
                      if (compared) {
                        continue;
                      }
                      result2 = false;
                      break;
                    }
                    if (seen) {
                      if (!arraySome(other, function (othValue2, othIndex) {
                        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                          return seen.push(othIndex);
                        }
                      })) {
                        result2 = false;
                        break;
                      }
                    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                      result2 = false;
                      break;
                    }
                  }
                  stack["delete"](array);
                  stack["delete"](other);
                  return result2;
                }
                function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                  switch (tag) {
                    case dataViewTag:
                      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                        return false;
                      }
                      object = object.buffer;
                      other = other.buffer;
                    case arrayBufferTag:
                      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                        return false;
                      }
                      return true;
                    case boolTag:
                    case dateTag:
                    case numberTag:
                      return eq(+object, +other);
                    case errorTag:
                      return object.name == other.name && object.message == other.message;
                    case regexpTag:
                    case stringTag:
                      return object == other + "";
                    case mapTag:
                      var convert = mapToArray;
                    case setTag:
                      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                      convert || (convert = setToArray);
                      if (object.size != other.size && !isPartial) {
                        return false;
                      }
                      var stacked = stack.get(object);
                      if (stacked) {
                        return stacked == other;
                      }
                      bitmask |= COMPARE_UNORDERED_FLAG;
                      stack.set(object, other);
                      var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                      stack["delete"](object);
                      return result2;
                    case symbolTag:
                      if (symbolValueOf) {
                        return symbolValueOf.call(object) == symbolValueOf.call(other);
                      }
                  }
                  return false;
                }
                function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                    objProps = getAllKeys(object),
                    objLength = objProps.length,
                    othProps = getAllKeys(other),
                    othLength = othProps.length;
                  if (objLength != othLength && !isPartial) {
                    return false;
                  }
                  var index = objLength;
                  while (index--) {
                    var key = objProps[index];
                    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                      return false;
                    }
                  }
                  var objStacked = stack.get(object);
                  var othStacked = stack.get(other);
                  if (objStacked && othStacked) {
                    return objStacked == other && othStacked == object;
                  }
                  var result2 = true;
                  stack.set(object, other);
                  stack.set(other, object);
                  var skipCtor = isPartial;
                  while (++index < objLength) {
                    key = objProps[index];
                    var objValue = object[key],
                      othValue = other[key];
                    if (customizer) {
                      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                    }
                    if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                      result2 = false;
                      break;
                    }
                    skipCtor || (skipCtor = key == "constructor");
                  }
                  if (result2 && !skipCtor) {
                    var objCtor = object.constructor,
                      othCtor = other.constructor;
                    if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                      result2 = false;
                    }
                  }
                  stack["delete"](object);
                  stack["delete"](other);
                  return result2;
                }
                function flatRest(func) {
                  return setToString(overRest(func, undefined$1, flatten), func + "");
                }
                function getAllKeys(object) {
                  return baseGetAllKeys(object, keys, getSymbols);
                }
                function getAllKeysIn(object) {
                  return baseGetAllKeys(object, keysIn, getSymbolsIn);
                }
                var getData = !metaMap ? noop : function (func) {
                  return metaMap.get(func);
                };
                function getFuncName(func) {
                  var result2 = func.name + "",
                    array = realNames[result2],
                    length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
                  while (length--) {
                    var data = array[length],
                      otherFunc = data.func;
                    if (otherFunc == null || otherFunc == func) {
                      return data.name;
                    }
                  }
                  return result2;
                }
                function getHolder(func) {
                  var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
                  return object.placeholder;
                }
                function getIteratee() {
                  var result2 = lodash.iteratee || iteratee;
                  result2 = result2 === iteratee ? baseIteratee : result2;
                  return arguments.length ? result2(arguments[0], arguments[1]) : result2;
                }
                function getMapData(map2, key) {
                  var data = map2.__data__;
                  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
                }
                function getMatchData(object) {
                  var result2 = keys(object),
                    length = result2.length;
                  while (length--) {
                    var key = result2[length],
                      value = object[key];
                    result2[length] = [key, value, isStrictComparable(value)];
                  }
                  return result2;
                }
                function getNative(object, key) {
                  var value = getValue(object, key);
                  return baseIsNative(value) ? value : undefined$1;
                }
                function getRawTag(value) {
                  var isOwn = hasOwnProperty.call(value, symToStringTag),
                    tag = value[symToStringTag];
                  try {
                    value[symToStringTag] = undefined$1;
                    var unmasked = true;
                  } catch (e) {}
                  var result2 = nativeObjectToString.call(value);
                  if (unmasked) {
                    if (isOwn) {
                      value[symToStringTag] = tag;
                    } else {
                      delete value[symToStringTag];
                    }
                  }
                  return result2;
                }
                var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
                  if (object == null) {
                    return [];
                  }
                  object = Object2(object);
                  return arrayFilter(nativeGetSymbols(object), function (symbol) {
                    return propertyIsEnumerable.call(object, symbol);
                  });
                };
                var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
                  var result2 = [];
                  while (object) {
                    arrayPush(result2, getSymbols(object));
                    object = getPrototype(object);
                  }
                  return result2;
                };
                var getTag = baseGetTag;
                if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
                  getTag = function (value) {
                    var result2 = baseGetTag(value),
                      Ctor = result2 == objectTag ? value.constructor : undefined$1,
                      ctorString = Ctor ? toSource(Ctor) : "";
                    if (ctorString) {
                      switch (ctorString) {
                        case dataViewCtorString:
                          return dataViewTag;
                        case mapCtorString:
                          return mapTag;
                        case promiseCtorString:
                          return promiseTag;
                        case setCtorString:
                          return setTag;
                        case weakMapCtorString:
                          return weakMapTag;
                      }
                    }
                    return result2;
                  };
                }
                function getView(start, end, transforms) {
                  var index = -1,
                    length = transforms.length;
                  while (++index < length) {
                    var data = transforms[index],
                      size2 = data.size;
                    switch (data.type) {
                      case "drop":
                        start += size2;
                        break;
                      case "dropRight":
                        end -= size2;
                        break;
                      case "take":
                        end = nativeMin(end, start + size2);
                        break;
                      case "takeRight":
                        start = nativeMax(start, end - size2);
                        break;
                    }
                  }
                  return {
                    "start": start,
                    "end": end
                  };
                }
                function getWrapDetails(source) {
                  var match = source.match(reWrapDetails);
                  return match ? match[1].split(reSplitDetails) : [];
                }
                function hasPath(object, path, hasFunc) {
                  path = castPath(path, object);
                  var index = -1,
                    length = path.length,
                    result2 = false;
                  while (++index < length) {
                    var key = toKey(path[index]);
                    if (!(result2 = object != null && hasFunc(object, key))) {
                      break;
                    }
                    object = object[key];
                  }
                  if (result2 || ++index != length) {
                    return result2;
                  }
                  length = object == null ? 0 : object.length;
                  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
                }
                function initCloneArray(array) {
                  var length = array.length,
                    result2 = new array.constructor(length);
                  if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                    result2.index = array.index;
                    result2.input = array.input;
                  }
                  return result2;
                }
                function initCloneObject(object) {
                  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
                }
                function initCloneByTag(object, tag, isDeep) {
                  var Ctor = object.constructor;
                  switch (tag) {
                    case arrayBufferTag:
                      return cloneArrayBuffer(object);
                    case boolTag:
                    case dateTag:
                      return new Ctor(+object);
                    case dataViewTag:
                      return cloneDataView(object, isDeep);
                    case float32Tag:
                    case float64Tag:
                    case int8Tag:
                    case int16Tag:
                    case int32Tag:
                    case uint8Tag:
                    case uint8ClampedTag:
                    case uint16Tag:
                    case uint32Tag:
                      return cloneTypedArray(object, isDeep);
                    case mapTag:
                      return new Ctor();
                    case numberTag:
                    case stringTag:
                      return new Ctor(object);
                    case regexpTag:
                      return cloneRegExp(object);
                    case setTag:
                      return new Ctor();
                    case symbolTag:
                      return cloneSymbol(object);
                  }
                }
                function insertWrapDetails(source, details) {
                  var length = details.length;
                  if (!length) {
                    return source;
                  }
                  var lastIndex = length - 1;
                  details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
                  details = details.join(length > 2 ? ", " : " ");
                  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
                }
                function isFlattenable(value) {
                  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
                }
                function isIndex(value, length) {
                  var type = typeof value;
                  length = length == null ? MAX_SAFE_INTEGER : length;
                  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
                }
                function isIterateeCall(value, index, object) {
                  if (!isObject(object)) {
                    return false;
                  }
                  var type = typeof index;
                  if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
                    return eq(object[index], value);
                  }
                  return false;
                }
                function isKey(value, object) {
                  if (isArray(value)) {
                    return false;
                  }
                  var type = typeof value;
                  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
                    return true;
                  }
                  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
                }
                function isKeyable(value) {
                  var type = typeof value;
                  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
                }
                function isLaziable(func) {
                  var funcName = getFuncName(func),
                    other = lodash[funcName];
                  if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
                    return false;
                  }
                  if (func === other) {
                    return true;
                  }
                  var data = getData(other);
                  return !!data && func === data[0];
                }
                function isMasked(func) {
                  return !!maskSrcKey && maskSrcKey in func;
                }
                var isMaskable = coreJsData ? isFunction : stubFalse;
                function isPrototype(value) {
                  var Ctor = value && value.constructor,
                    proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                  return value === proto;
                }
                function isStrictComparable(value) {
                  return value === value && !isObject(value);
                }
                function matchesStrictComparable(key, srcValue) {
                  return function (object) {
                    if (object == null) {
                      return false;
                    }
                    return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
                  };
                }
                function memoizeCapped(func) {
                  var result2 = memoize(func, function (key) {
                    if (cache.size === MAX_MEMOIZE_SIZE) {
                      cache.clear();
                    }
                    return key;
                  });
                  var cache = result2.cache;
                  return result2;
                }
                function mergeData(data, source) {
                  var bitmask = data[1],
                    srcBitmask = source[1],
                    newBitmask = bitmask | srcBitmask,
                    isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                  var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                  if (!(isCommon || isCombo)) {
                    return data;
                  }
                  if (srcBitmask & WRAP_BIND_FLAG) {
                    data[2] = source[2];
                    newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                  }
                  var value = source[3];
                  if (value) {
                    var partials = data[3];
                    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                  }
                  value = source[5];
                  if (value) {
                    partials = data[5];
                    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                  }
                  value = source[7];
                  if (value) {
                    data[7] = value;
                  }
                  if (srcBitmask & WRAP_ARY_FLAG) {
                    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                  }
                  if (data[9] == null) {
                    data[9] = source[9];
                  }
                  data[0] = source[0];
                  data[1] = newBitmask;
                  return data;
                }
                function nativeKeysIn(object) {
                  var result2 = [];
                  if (object != null) {
                    for (var key in Object2(object)) {
                      result2.push(key);
                    }
                  }
                  return result2;
                }
                function objectToString(value) {
                  return nativeObjectToString.call(value);
                }
                function overRest(func, start, transform2) {
                  start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
                  return function () {
                    var args = arguments,
                      index = -1,
                      length = nativeMax(args.length - start, 0),
                      array = Array2(length);
                    while (++index < length) {
                      array[index] = args[start + index];
                    }
                    index = -1;
                    var otherArgs = Array2(start + 1);
                    while (++index < start) {
                      otherArgs[index] = args[index];
                    }
                    otherArgs[start] = transform2(array);
                    return apply(func, this, otherArgs);
                  };
                }
                function parent(object, path) {
                  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
                }
                function reorder(array, indexes) {
                  var arrLength = array.length,
                    length = nativeMin(indexes.length, arrLength),
                    oldArray = copyArray(array);
                  while (length--) {
                    var index = indexes[length];
                    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
                  }
                  return array;
                }
                function safeGet(object, key) {
                  if (key === "constructor" && typeof object[key] === "function") {
                    return;
                  }
                  if (key == "__proto__") {
                    return;
                  }
                  return object[key];
                }
                var setData = shortOut(baseSetData);
                var setTimeout = ctxSetTimeout || function (func, wait) {
                  return root.setTimeout(func, wait);
                };
                var setToString = shortOut(baseSetToString);
                function setWrapToString(wrapper, reference, bitmask) {
                  var source = reference + "";
                  return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
                }
                function shortOut(func) {
                  var count = 0,
                    lastCalled = 0;
                  return function () {
                    var stamp = nativeNow(),
                      remaining = HOT_SPAN - (stamp - lastCalled);
                    lastCalled = stamp;
                    if (remaining > 0) {
                      if (++count >= HOT_COUNT) {
                        return arguments[0];
                      }
                    } else {
                      count = 0;
                    }
                    return func.apply(undefined$1, arguments);
                  };
                }
                function shuffleSelf(array, size2) {
                  var index = -1,
                    length = array.length,
                    lastIndex = length - 1;
                  size2 = size2 === undefined$1 ? length : size2;
                  while (++index < size2) {
                    var rand = baseRandom(index, lastIndex),
                      value = array[rand];
                    array[rand] = array[index];
                    array[index] = value;
                  }
                  array.length = size2;
                  return array;
                }
                var stringToPath = memoizeCapped(function (string) {
                  var result2 = [];
                  if (string.charCodeAt(0) === 46) {
                    result2.push("");
                  }
                  string.replace(rePropName, function (match, number, quote, subString) {
                    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
                  });
                  return result2;
                });
                function toKey(value) {
                  if (typeof value == "string" || isSymbol(value)) {
                    return value;
                  }
                  var result2 = value + "";
                  return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
                }
                function toSource(func) {
                  if (func != null) {
                    try {
                      return funcToString.call(func);
                    } catch (e) {}
                    try {
                      return func + "";
                    } catch (e) {}
                  }
                  return "";
                }
                function updateWrapDetails(details, bitmask) {
                  arrayEach(wrapFlags, function (pair) {
                    var value = "_." + pair[0];
                    if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                      details.push(value);
                    }
                  });
                  return details.sort();
                }
                function wrapperClone(wrapper) {
                  if (wrapper instanceof LazyWrapper) {
                    return wrapper.clone();
                  }
                  var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                  result2.__actions__ = copyArray(wrapper.__actions__);
                  result2.__index__ = wrapper.__index__;
                  result2.__values__ = wrapper.__values__;
                  return result2;
                }
                function chunk(array, size2, guard) {
                  if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
                    size2 = 1;
                  } else {
                    size2 = nativeMax(toInteger(size2), 0);
                  }
                  var length = array == null ? 0 : array.length;
                  if (!length || size2 < 1) {
                    return [];
                  }
                  var index = 0,
                    resIndex = 0,
                    result2 = Array2(nativeCeil(length / size2));
                  while (index < length) {
                    result2[resIndex++] = baseSlice(array, index, index += size2);
                  }
                  return result2;
                }
                function compact(array) {
                  var index = -1,
                    length = array == null ? 0 : array.length,
                    resIndex = 0,
                    result2 = [];
                  while (++index < length) {
                    var value = array[index];
                    if (value) {
                      result2[resIndex++] = value;
                    }
                  }
                  return result2;
                }
                function concat() {
                  var length = arguments.length;
                  if (!length) {
                    return [];
                  }
                  var args = Array2(length - 1),
                    array = arguments[0],
                    index = length;
                  while (index--) {
                    args[index - 1] = arguments[index];
                  }
                  return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
                }
                var difference = baseRest(function (array, values2) {
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
                });
                var differenceBy = baseRest(function (array, values2) {
                  var iteratee2 = last(values2);
                  if (isArrayLikeObject(iteratee2)) {
                    iteratee2 = undefined$1;
                  }
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
                });
                var differenceWith = baseRest(function (array, values2) {
                  var comparator = last(values2);
                  if (isArrayLikeObject(comparator)) {
                    comparator = undefined$1;
                  }
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
                });
                function drop(array, n, guard) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  n = guard || n === undefined$1 ? 1 : toInteger(n);
                  return baseSlice(array, n < 0 ? 0 : n, length);
                }
                function dropRight(array, n, guard) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  n = guard || n === undefined$1 ? 1 : toInteger(n);
                  n = length - n;
                  return baseSlice(array, 0, n < 0 ? 0 : n);
                }
                function dropRightWhile(array, predicate) {
                  return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
                }
                function dropWhile(array, predicate) {
                  return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
                }
                function fill(array, value, start, end) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                    start = 0;
                    end = length;
                  }
                  return baseFill(array, value, start, end);
                }
                function findIndex(array, predicate, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = fromIndex == null ? 0 : toInteger(fromIndex);
                  if (index < 0) {
                    index = nativeMax(length + index, 0);
                  }
                  return baseFindIndex(array, getIteratee(predicate, 3), index);
                }
                function findLastIndex(array, predicate, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = length - 1;
                  if (fromIndex !== undefined$1) {
                    index = toInteger(fromIndex);
                    index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                  }
                  return baseFindIndex(array, getIteratee(predicate, 3), index, true);
                }
                function flatten(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseFlatten(array, 1) : [];
                }
                function flattenDeep(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseFlatten(array, INFINITY) : [];
                }
                function flattenDepth(array, depth) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  depth = depth === undefined$1 ? 1 : toInteger(depth);
                  return baseFlatten(array, depth);
                }
                function fromPairs(pairs) {
                  var index = -1,
                    length = pairs == null ? 0 : pairs.length,
                    result2 = {};
                  while (++index < length) {
                    var pair = pairs[index];
                    result2[pair[0]] = pair[1];
                  }
                  return result2;
                }
                function head(array) {
                  return array && array.length ? array[0] : undefined$1;
                }
                function indexOf(array, value, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = fromIndex == null ? 0 : toInteger(fromIndex);
                  if (index < 0) {
                    index = nativeMax(length + index, 0);
                  }
                  return baseIndexOf(array, value, index);
                }
                function initial(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseSlice(array, 0, -1) : [];
                }
                var intersection = baseRest(function (arrays) {
                  var mapped = arrayMap(arrays, castArrayLikeObject);
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
                });
                var intersectionBy = baseRest(function (arrays) {
                  var iteratee2 = last(arrays),
                    mapped = arrayMap(arrays, castArrayLikeObject);
                  if (iteratee2 === last(mapped)) {
                    iteratee2 = undefined$1;
                  } else {
                    mapped.pop();
                  }
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
                });
                var intersectionWith = baseRest(function (arrays) {
                  var comparator = last(arrays),
                    mapped = arrayMap(arrays, castArrayLikeObject);
                  comparator = typeof comparator == "function" ? comparator : undefined$1;
                  if (comparator) {
                    mapped.pop();
                  }
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
                });
                function join(array, separator) {
                  return array == null ? "" : nativeJoin.call(array, separator);
                }
                function last(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? array[length - 1] : undefined$1;
                }
                function lastIndexOf(array, value, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = length;
                  if (fromIndex !== undefined$1) {
                    index = toInteger(fromIndex);
                    index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                  }
                  return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
                }
                function nth(array, n) {
                  return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
                }
                var pull = baseRest(pullAll);
                function pullAll(array, values2) {
                  return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
                }
                function pullAllBy(array, values2, iteratee2) {
                  return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
                }
                function pullAllWith(array, values2, comparator) {
                  return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
                }
                var pullAt = flatRest(function (array, indexes) {
                  var length = array == null ? 0 : array.length,
                    result2 = baseAt(array, indexes);
                  basePullAt(array, arrayMap(indexes, function (index) {
                    return isIndex(index, length) ? +index : index;
                  }).sort(compareAscending));
                  return result2;
                });
                function remove(array, predicate) {
                  var result2 = [];
                  if (!(array && array.length)) {
                    return result2;
                  }
                  var index = -1,
                    indexes = [],
                    length = array.length;
                  predicate = getIteratee(predicate, 3);
                  while (++index < length) {
                    var value = array[index];
                    if (predicate(value, index, array)) {
                      result2.push(value);
                      indexes.push(index);
                    }
                  }
                  basePullAt(array, indexes);
                  return result2;
                }
                function reverse(array) {
                  return array == null ? array : nativeReverse.call(array);
                }
                function slice(array, start, end) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                    start = 0;
                    end = length;
                  } else {
                    start = start == null ? 0 : toInteger(start);
                    end = end === undefined$1 ? length : toInteger(end);
                  }
                  return baseSlice(array, start, end);
                }
                function sortedIndex(array, value) {
                  return baseSortedIndex(array, value);
                }
                function sortedIndexBy(array, value, iteratee2) {
                  return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
                }
                function sortedIndexOf(array, value) {
                  var length = array == null ? 0 : array.length;
                  if (length) {
                    var index = baseSortedIndex(array, value);
                    if (index < length && eq(array[index], value)) {
                      return index;
                    }
                  }
                  return -1;
                }
                function sortedLastIndex(array, value) {
                  return baseSortedIndex(array, value, true);
                }
                function sortedLastIndexBy(array, value, iteratee2) {
                  return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
                }
                function sortedLastIndexOf(array, value) {
                  var length = array == null ? 0 : array.length;
                  if (length) {
                    var index = baseSortedIndex(array, value, true) - 1;
                    if (eq(array[index], value)) {
                      return index;
                    }
                  }
                  return -1;
                }
                function sortedUniq(array) {
                  return array && array.length ? baseSortedUniq(array) : [];
                }
                function sortedUniqBy(array, iteratee2) {
                  return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
                }
                function tail(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseSlice(array, 1, length) : [];
                }
                function take(array, n, guard) {
                  if (!(array && array.length)) {
                    return [];
                  }
                  n = guard || n === undefined$1 ? 1 : toInteger(n);
                  return baseSlice(array, 0, n < 0 ? 0 : n);
                }
                function takeRight(array, n, guard) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  n = guard || n === undefined$1 ? 1 : toInteger(n);
                  n = length - n;
                  return baseSlice(array, n < 0 ? 0 : n, length);
                }
                function takeRightWhile(array, predicate) {
                  return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
                }
                function takeWhile(array, predicate) {
                  return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
                }
                var union = baseRest(function (arrays) {
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                });
                var unionBy = baseRest(function (arrays) {
                  var iteratee2 = last(arrays);
                  if (isArrayLikeObject(iteratee2)) {
                    iteratee2 = undefined$1;
                  }
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
                });
                var unionWith = baseRest(function (arrays) {
                  var comparator = last(arrays);
                  comparator = typeof comparator == "function" ? comparator : undefined$1;
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
                });
                function uniq(array) {
                  return array && array.length ? baseUniq(array) : [];
                }
                function uniqBy(array, iteratee2) {
                  return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
                }
                function uniqWith(array, comparator) {
                  comparator = typeof comparator == "function" ? comparator : undefined$1;
                  return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
                }
                function unzip(array) {
                  if (!(array && array.length)) {
                    return [];
                  }
                  var length = 0;
                  array = arrayFilter(array, function (group) {
                    if (isArrayLikeObject(group)) {
                      length = nativeMax(group.length, length);
                      return true;
                    }
                  });
                  return baseTimes(length, function (index) {
                    return arrayMap(array, baseProperty(index));
                  });
                }
                function unzipWith(array, iteratee2) {
                  if (!(array && array.length)) {
                    return [];
                  }
                  var result2 = unzip(array);
                  if (iteratee2 == null) {
                    return result2;
                  }
                  return arrayMap(result2, function (group) {
                    return apply(iteratee2, undefined$1, group);
                  });
                }
                var without = baseRest(function (array, values2) {
                  return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
                });
                var xor = baseRest(function (arrays) {
                  return baseXor(arrayFilter(arrays, isArrayLikeObject));
                });
                var xorBy = baseRest(function (arrays) {
                  var iteratee2 = last(arrays);
                  if (isArrayLikeObject(iteratee2)) {
                    iteratee2 = undefined$1;
                  }
                  return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
                });
                var xorWith = baseRest(function (arrays) {
                  var comparator = last(arrays);
                  comparator = typeof comparator == "function" ? comparator : undefined$1;
                  return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
                });
                var zip = baseRest(unzip);
                function zipObject(props, values2) {
                  return baseZipObject(props || [], values2 || [], assignValue);
                }
                function zipObjectDeep(props, values2) {
                  return baseZipObject(props || [], values2 || [], baseSet);
                }
                var zipWith = baseRest(function (arrays) {
                  var length = arrays.length,
                    iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
                  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
                  return unzipWith(arrays, iteratee2);
                });
                function chain(value) {
                  var result2 = lodash(value);
                  result2.__chain__ = true;
                  return result2;
                }
                function tap(value, interceptor) {
                  interceptor(value);
                  return value;
                }
                function thru(value, interceptor) {
                  return interceptor(value);
                }
                var wrapperAt = flatRest(function (paths) {
                  var length = paths.length,
                    start = length ? paths[0] : 0,
                    value = this.__wrapped__,
                    interceptor = function (object) {
                      return baseAt(object, paths);
                    };
                  if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                    return this.thru(interceptor);
                  }
                  value = value.slice(start, +start + (length ? 1 : 0));
                  value.__actions__.push({
                    "func": thru,
                    "args": [interceptor],
                    "thisArg": undefined$1
                  });
                  return new LodashWrapper(value, this.__chain__).thru(function (array) {
                    if (length && !array.length) {
                      array.push(undefined$1);
                    }
                    return array;
                  });
                });
                function wrapperChain() {
                  return chain(this);
                }
                function wrapperCommit() {
                  return new LodashWrapper(this.value(), this.__chain__);
                }
                function wrapperNext() {
                  if (this.__values__ === undefined$1) {
                    this.__values__ = toArray(this.value());
                  }
                  var done = this.__index__ >= this.__values__.length,
                    value = done ? undefined$1 : this.__values__[this.__index__++];
                  return {
                    "done": done,
                    "value": value
                  };
                }
                function wrapperToIterator() {
                  return this;
                }
                function wrapperPlant(value) {
                  var result2,
                    parent2 = this;
                  while (parent2 instanceof baseLodash) {
                    var clone2 = wrapperClone(parent2);
                    clone2.__index__ = 0;
                    clone2.__values__ = undefined$1;
                    if (result2) {
                      previous.__wrapped__ = clone2;
                    } else {
                      result2 = clone2;
                    }
                    var previous = clone2;
                    parent2 = parent2.__wrapped__;
                  }
                  previous.__wrapped__ = value;
                  return result2;
                }
                function wrapperReverse() {
                  var value = this.__wrapped__;
                  if (value instanceof LazyWrapper) {
                    var wrapped = value;
                    if (this.__actions__.length) {
                      wrapped = new LazyWrapper(this);
                    }
                    wrapped = wrapped.reverse();
                    wrapped.__actions__.push({
                      "func": thru,
                      "args": [reverse],
                      "thisArg": undefined$1
                    });
                    return new LodashWrapper(wrapped, this.__chain__);
                  }
                  return this.thru(reverse);
                }
                function wrapperValue() {
                  return baseWrapperValue(this.__wrapped__, this.__actions__);
                }
                var countBy = createAggregator(function (result2, value, key) {
                  if (hasOwnProperty.call(result2, key)) {
                    ++result2[key];
                  } else {
                    baseAssignValue(result2, key, 1);
                  }
                });
                function every(collection, predicate, guard) {
                  var func = isArray(collection) ? arrayEvery : baseEvery;
                  if (guard && isIterateeCall(collection, predicate, guard)) {
                    predicate = undefined$1;
                  }
                  return func(collection, getIteratee(predicate, 3));
                }
                function filter(collection, predicate) {
                  var func = isArray(collection) ? arrayFilter : baseFilter;
                  return func(collection, getIteratee(predicate, 3));
                }
                var find = createFind(findIndex);
                var findLast = createFind(findLastIndex);
                function flatMap(collection, iteratee2) {
                  return baseFlatten(map(collection, iteratee2), 1);
                }
                function flatMapDeep(collection, iteratee2) {
                  return baseFlatten(map(collection, iteratee2), INFINITY);
                }
                function flatMapDepth(collection, iteratee2, depth) {
                  depth = depth === undefined$1 ? 1 : toInteger(depth);
                  return baseFlatten(map(collection, iteratee2), depth);
                }
                function forEach(collection, iteratee2) {
                  var func = isArray(collection) ? arrayEach : baseEach;
                  return func(collection, getIteratee(iteratee2, 3));
                }
                function forEachRight(collection, iteratee2) {
                  var func = isArray(collection) ? arrayEachRight : baseEachRight;
                  return func(collection, getIteratee(iteratee2, 3));
                }
                var groupBy = createAggregator(function (result2, value, key) {
                  if (hasOwnProperty.call(result2, key)) {
                    result2[key].push(value);
                  } else {
                    baseAssignValue(result2, key, [value]);
                  }
                });
                function includes(collection, value, fromIndex, guard) {
                  collection = isArrayLike(collection) ? collection : values(collection);
                  fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                  var length = collection.length;
                  if (fromIndex < 0) {
                    fromIndex = nativeMax(length + fromIndex, 0);
                  }
                  return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
                }
                var invokeMap = baseRest(function (collection, path, args) {
                  var index = -1,
                    isFunc = typeof path == "function",
                    result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                  baseEach(collection, function (value) {
                    result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                  });
                  return result2;
                });
                var keyBy = createAggregator(function (result2, value, key) {
                  baseAssignValue(result2, key, value);
                });
                function map(collection, iteratee2) {
                  var func = isArray(collection) ? arrayMap : baseMap;
                  return func(collection, getIteratee(iteratee2, 3));
                }
                function orderBy(collection, iteratees, orders, guard) {
                  if (collection == null) {
                    return [];
                  }
                  if (!isArray(iteratees)) {
                    iteratees = iteratees == null ? [] : [iteratees];
                  }
                  orders = guard ? undefined$1 : orders;
                  if (!isArray(orders)) {
                    orders = orders == null ? [] : [orders];
                  }
                  return baseOrderBy(collection, iteratees, orders);
                }
                var partition = createAggregator(function (result2, value, key) {
                  result2[key ? 0 : 1].push(value);
                }, function () {
                  return [[], []];
                });
                function reduce(collection, iteratee2, accumulator) {
                  var func = isArray(collection) ? arrayReduce : baseReduce,
                    initAccum = arguments.length < 3;
                  return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
                }
                function reduceRight(collection, iteratee2, accumulator) {
                  var func = isArray(collection) ? arrayReduceRight : baseReduce,
                    initAccum = arguments.length < 3;
                  return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
                }
                function reject(collection, predicate) {
                  var func = isArray(collection) ? arrayFilter : baseFilter;
                  return func(collection, negate(getIteratee(predicate, 3)));
                }
                function sample(collection) {
                  var func = isArray(collection) ? arraySample : baseSample;
                  return func(collection);
                }
                function sampleSize(collection, n, guard) {
                  if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
                    n = 1;
                  } else {
                    n = toInteger(n);
                  }
                  var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                  return func(collection, n);
                }
                function shuffle(collection) {
                  var func = isArray(collection) ? arrayShuffle : baseShuffle;
                  return func(collection);
                }
                function size(collection) {
                  if (collection == null) {
                    return 0;
                  }
                  if (isArrayLike(collection)) {
                    return isString(collection) ? stringSize(collection) : collection.length;
                  }
                  var tag = getTag(collection);
                  if (tag == mapTag || tag == setTag) {
                    return collection.size;
                  }
                  return baseKeys(collection).length;
                }
                function some(collection, predicate, guard) {
                  var func = isArray(collection) ? arraySome : baseSome;
                  if (guard && isIterateeCall(collection, predicate, guard)) {
                    predicate = undefined$1;
                  }
                  return func(collection, getIteratee(predicate, 3));
                }
                var sortBy = baseRest(function (collection, iteratees) {
                  if (collection == null) {
                    return [];
                  }
                  var length = iteratees.length;
                  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                    iteratees = [];
                  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                    iteratees = [iteratees[0]];
                  }
                  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                });
                var now = ctxNow || function () {
                  return root.Date.now();
                };
                function after(n, func) {
                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  n = toInteger(n);
                  return function () {
                    if (--n < 1) {
                      return func.apply(this, arguments);
                    }
                  };
                }
                function ary(func, n, guard) {
                  n = guard ? undefined$1 : n;
                  n = func && n == null ? func.length : n;
                  return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
                }
                function before(n, func) {
                  var result2;
                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  n = toInteger(n);
                  return function () {
                    if (--n > 0) {
                      result2 = func.apply(this, arguments);
                    }
                    if (n <= 1) {
                      func = undefined$1;
                    }
                    return result2;
                  };
                }
                var bind = baseRest(function (func, thisArg, partials) {
                  var bitmask = WRAP_BIND_FLAG;
                  if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bind));
                    bitmask |= WRAP_PARTIAL_FLAG;
                  }
                  return createWrap(func, bitmask, thisArg, partials, holders);
                });
                var bindKey = baseRest(function (object, key, partials) {
                  var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                  if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bindKey));
                    bitmask |= WRAP_PARTIAL_FLAG;
                  }
                  return createWrap(key, bitmask, object, partials, holders);
                });
                function curry(func, arity, guard) {
                  arity = guard ? undefined$1 : arity;
                  var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
                  result2.placeholder = curry.placeholder;
                  return result2;
                }
                function curryRight(func, arity, guard) {
                  arity = guard ? undefined$1 : arity;
                  var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
                  result2.placeholder = curryRight.placeholder;
                  return result2;
                }
                function debounce(func, wait, options) {
                  var lastArgs,
                    lastThis,
                    maxWait,
                    result2,
                    timerId,
                    lastCallTime,
                    lastInvokeTime = 0,
                    leading = false,
                    maxing = false,
                    trailing = true;
                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  wait = toNumber(wait) || 0;
                  if (isObject(options)) {
                    leading = !!options.leading;
                    maxing = "maxWait" in options;
                    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                    trailing = "trailing" in options ? !!options.trailing : trailing;
                  }
                  function invokeFunc(time) {
                    var args = lastArgs,
                      thisArg = lastThis;
                    lastArgs = lastThis = undefined$1;
                    lastInvokeTime = time;
                    result2 = func.apply(thisArg, args);
                    return result2;
                  }
                  function leadingEdge(time) {
                    lastInvokeTime = time;
                    timerId = setTimeout(timerExpired, wait);
                    return leading ? invokeFunc(time) : result2;
                  }
                  function remainingWait(time) {
                    var timeSinceLastCall = time - lastCallTime,
                      timeSinceLastInvoke = time - lastInvokeTime,
                      timeWaiting = wait - timeSinceLastCall;
                    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                  }
                  function shouldInvoke(time) {
                    var timeSinceLastCall = time - lastCallTime,
                      timeSinceLastInvoke = time - lastInvokeTime;
                    return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                  }
                  function timerExpired() {
                    var time = now();
                    if (shouldInvoke(time)) {
                      return trailingEdge(time);
                    }
                    timerId = setTimeout(timerExpired, remainingWait(time));
                  }
                  function trailingEdge(time) {
                    timerId = undefined$1;
                    if (trailing && lastArgs) {
                      return invokeFunc(time);
                    }
                    lastArgs = lastThis = undefined$1;
                    return result2;
                  }
                  function cancel() {
                    if (timerId !== undefined$1) {
                      clearTimeout(timerId);
                    }
                    lastInvokeTime = 0;
                    lastArgs = lastCallTime = lastThis = timerId = undefined$1;
                  }
                  function flush() {
                    return timerId === undefined$1 ? result2 : trailingEdge(now());
                  }
                  function debounced() {
                    var time = now(),
                      isInvoking = shouldInvoke(time);
                    lastArgs = arguments;
                    lastThis = this;
                    lastCallTime = time;
                    if (isInvoking) {
                      if (timerId === undefined$1) {
                        return leadingEdge(lastCallTime);
                      }
                      if (maxing) {
                        clearTimeout(timerId);
                        timerId = setTimeout(timerExpired, wait);
                        return invokeFunc(lastCallTime);
                      }
                    }
                    if (timerId === undefined$1) {
                      timerId = setTimeout(timerExpired, wait);
                    }
                    return result2;
                  }
                  debounced.cancel = cancel;
                  debounced.flush = flush;
                  return debounced;
                }
                var defer = baseRest(function (func, args) {
                  return baseDelay(func, 1, args);
                });
                var delay = baseRest(function (func, wait, args) {
                  return baseDelay(func, toNumber(wait) || 0, args);
                });
                function flip(func) {
                  return createWrap(func, WRAP_FLIP_FLAG);
                }
                function memoize(func, resolver) {
                  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  var memoized = function () {
                    var args = arguments,
                      key = resolver ? resolver.apply(this, args) : args[0],
                      cache = memoized.cache;
                    if (cache.has(key)) {
                      return cache.get(key);
                    }
                    var result2 = func.apply(this, args);
                    memoized.cache = cache.set(key, result2) || cache;
                    return result2;
                  };
                  memoized.cache = new (memoize.Cache || MapCache)();
                  return memoized;
                }
                memoize.Cache = MapCache;
                function negate(predicate) {
                  if (typeof predicate != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  return function () {
                    var args = arguments;
                    switch (args.length) {
                      case 0:
                        return !predicate.call(this);
                      case 1:
                        return !predicate.call(this, args[0]);
                      case 2:
                        return !predicate.call(this, args[0], args[1]);
                      case 3:
                        return !predicate.call(this, args[0], args[1], args[2]);
                    }
                    return !predicate.apply(this, args);
                  };
                }
                function once(func) {
                  return before(2, func);
                }
                var overArgs = castRest(function (func, transforms) {
                  transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                  var funcsLength = transforms.length;
                  return baseRest(function (args) {
                    var index = -1,
                      length = nativeMin(args.length, funcsLength);
                    while (++index < length) {
                      args[index] = transforms[index].call(this, args[index]);
                    }
                    return apply(func, this, args);
                  });
                });
                var partial = baseRest(function (func, partials) {
                  var holders = replaceHolders(partials, getHolder(partial));
                  return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
                });
                var partialRight = baseRest(function (func, partials) {
                  var holders = replaceHolders(partials, getHolder(partialRight));
                  return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
                });
                var rearg = flatRest(function (func, indexes) {
                  return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
                });
                function rest(func, start) {
                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  start = start === undefined$1 ? start : toInteger(start);
                  return baseRest(func, start);
                }
                function spread(func, start) {
                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  start = start == null ? 0 : nativeMax(toInteger(start), 0);
                  return baseRest(function (args) {
                    var array = args[start],
                      otherArgs = castSlice(args, 0, start);
                    if (array) {
                      arrayPush(otherArgs, array);
                    }
                    return apply(func, this, otherArgs);
                  });
                }
                function throttle(func, wait, options) {
                  var leading = true,
                    trailing = true;
                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  if (isObject(options)) {
                    leading = "leading" in options ? !!options.leading : leading;
                    trailing = "trailing" in options ? !!options.trailing : trailing;
                  }
                  return debounce(func, wait, {
                    "leading": leading,
                    "maxWait": wait,
                    "trailing": trailing
                  });
                }
                function unary(func) {
                  return ary(func, 1);
                }
                function wrap(value, wrapper) {
                  return partial(castFunction(wrapper), value);
                }
                function castArray() {
                  if (!arguments.length) {
                    return [];
                  }
                  var value = arguments[0];
                  return isArray(value) ? value : [value];
                }
                function clone(value) {
                  return baseClone(value, CLONE_SYMBOLS_FLAG);
                }
                function cloneWith(value, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined$1;
                  return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
                }
                function cloneDeep(value) {
                  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                }
                function cloneDeepWith(value, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined$1;
                  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
                }
                function conformsTo(object, source) {
                  return source == null || baseConformsTo(object, source, keys(source));
                }
                function eq(value, other) {
                  return value === other || value !== value && other !== other;
                }
                var gt = createRelationalOperation(baseGt);
                var gte = createRelationalOperation(function (value, other) {
                  return value >= other;
                });
                var isArguments = baseIsArguments(/* @__PURE__ */function () {
                  return arguments;
                }()) ? baseIsArguments : function (value) {
                  return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
                };
                var isArray = Array2.isArray;
                var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
                function isArrayLike(value) {
                  return value != null && isLength(value.length) && !isFunction(value);
                }
                function isArrayLikeObject(value) {
                  return isObjectLike(value) && isArrayLike(value);
                }
                function isBoolean(value) {
                  return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
                }
                var isBuffer = nativeIsBuffer || stubFalse;
                var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
                function isElement(value) {
                  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
                }
                function isEmpty(value) {
                  if (value == null) {
                    return true;
                  }
                  if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                    return !value.length;
                  }
                  var tag = getTag(value);
                  if (tag == mapTag || tag == setTag) {
                    return !value.size;
                  }
                  if (isPrototype(value)) {
                    return !baseKeys(value).length;
                  }
                  for (var key in value) {
                    if (hasOwnProperty.call(value, key)) {
                      return false;
                    }
                  }
                  return true;
                }
                function isEqual(value, other) {
                  return baseIsEqual(value, other);
                }
                function isEqualWith(value, other, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined$1;
                  var result2 = customizer ? customizer(value, other) : undefined$1;
                  return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
                }
                function isError(value) {
                  if (!isObjectLike(value)) {
                    return false;
                  }
                  var tag = baseGetTag(value);
                  return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
                }
                function isFinite(value) {
                  return typeof value == "number" && nativeIsFinite(value);
                }
                function isFunction(value) {
                  if (!isObject(value)) {
                    return false;
                  }
                  var tag = baseGetTag(value);
                  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
                }
                function isInteger(value) {
                  return typeof value == "number" && value == toInteger(value);
                }
                function isLength(value) {
                  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                }
                function isObject(value) {
                  var type = typeof value;
                  return value != null && (type == "object" || type == "function");
                }
                function isObjectLike(value) {
                  return value != null && typeof value == "object";
                }
                var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
                function isMatch(object, source) {
                  return object === source || baseIsMatch(object, source, getMatchData(source));
                }
                function isMatchWith(object, source, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined$1;
                  return baseIsMatch(object, source, getMatchData(source), customizer);
                }
                function isNaN(value) {
                  return isNumber(value) && value != +value;
                }
                function isNative(value) {
                  if (isMaskable(value)) {
                    throw new Error(CORE_ERROR_TEXT);
                  }
                  return baseIsNative(value);
                }
                function isNull(value) {
                  return value === null;
                }
                function isNil(value) {
                  return value == null;
                }
                function isNumber(value) {
                  return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
                }
                function isPlainObject(value) {
                  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                    return false;
                  }
                  var proto = getPrototype(value);
                  if (proto === null) {
                    return true;
                  }
                  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
                }
                var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
                function isSafeInteger(value) {
                  return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
                }
                var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
                function isString(value) {
                  return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
                }
                function isSymbol(value) {
                  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
                }
                var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
                function isUndefined(value) {
                  return value === undefined$1;
                }
                function isWeakMap(value) {
                  return isObjectLike(value) && getTag(value) == weakMapTag;
                }
                function isWeakSet(value) {
                  return isObjectLike(value) && baseGetTag(value) == weakSetTag;
                }
                var lt = createRelationalOperation(baseLt);
                var lte = createRelationalOperation(function (value, other) {
                  return value <= other;
                });
                function toArray(value) {
                  if (!value) {
                    return [];
                  }
                  if (isArrayLike(value)) {
                    return isString(value) ? stringToArray(value) : copyArray(value);
                  }
                  if (symIterator && value[symIterator]) {
                    return iteratorToArray(value[symIterator]());
                  }
                  var tag = getTag(value),
                    func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                  return func(value);
                }
                function toFinite(value) {
                  if (!value) {
                    return value === 0 ? value : 0;
                  }
                  value = toNumber(value);
                  if (value === INFINITY || value === -INFINITY) {
                    var sign = value < 0 ? -1 : 1;
                    return sign * MAX_INTEGER;
                  }
                  return value === value ? value : 0;
                }
                function toInteger(value) {
                  var result2 = toFinite(value),
                    remainder = result2 % 1;
                  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
                }
                function toLength(value) {
                  return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
                }
                function toNumber(value) {
                  if (typeof value == "number") {
                    return value;
                  }
                  if (isSymbol(value)) {
                    return NAN;
                  }
                  if (isObject(value)) {
                    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                    value = isObject(other) ? other + "" : other;
                  }
                  if (typeof value != "string") {
                    return value === 0 ? value : +value;
                  }
                  value = baseTrim(value);
                  var isBinary = reIsBinary.test(value);
                  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
                }
                function toPlainObject(value) {
                  return copyObject(value, keysIn(value));
                }
                function toSafeInteger(value) {
                  return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
                }
                function toString(value) {
                  return value == null ? "" : baseToString(value);
                }
                var assign = createAssigner(function (object, source) {
                  if (isPrototype(source) || isArrayLike(source)) {
                    copyObject(source, keys(source), object);
                    return;
                  }
                  for (var key in source) {
                    if (hasOwnProperty.call(source, key)) {
                      assignValue(object, key, source[key]);
                    }
                  }
                });
                var assignIn = createAssigner(function (object, source) {
                  copyObject(source, keysIn(source), object);
                });
                var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
                  copyObject(source, keysIn(source), object, customizer);
                });
                var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
                  copyObject(source, keys(source), object, customizer);
                });
                var at = flatRest(baseAt);
                function create(prototype, properties) {
                  var result2 = baseCreate(prototype);
                  return properties == null ? result2 : baseAssign(result2, properties);
                }
                var defaults = baseRest(function (object, sources) {
                  object = Object2(object);
                  var index = -1;
                  var length = sources.length;
                  var guard = length > 2 ? sources[2] : undefined$1;
                  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    length = 1;
                  }
                  while (++index < length) {
                    var source = sources[index];
                    var props = keysIn(source);
                    var propsIndex = -1;
                    var propsLength = props.length;
                    while (++propsIndex < propsLength) {
                      var key = props[propsIndex];
                      var value = object[key];
                      if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                        object[key] = source[key];
                      }
                    }
                  }
                  return object;
                });
                var defaultsDeep = baseRest(function (args) {
                  args.push(undefined$1, customDefaultsMerge);
                  return apply(mergeWith, undefined$1, args);
                });
                function findKey(object, predicate) {
                  return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
                }
                function findLastKey(object, predicate) {
                  return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
                }
                function forIn(object, iteratee2) {
                  return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
                }
                function forInRight(object, iteratee2) {
                  return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
                }
                function forOwn(object, iteratee2) {
                  return object && baseForOwn(object, getIteratee(iteratee2, 3));
                }
                function forOwnRight(object, iteratee2) {
                  return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
                }
                function functions(object) {
                  return object == null ? [] : baseFunctions(object, keys(object));
                }
                function functionsIn(object) {
                  return object == null ? [] : baseFunctions(object, keysIn(object));
                }
                function get(object, path, defaultValue) {
                  var result2 = object == null ? undefined$1 : baseGet(object, path);
                  return result2 === undefined$1 ? defaultValue : result2;
                }
                function has(object, path) {
                  return object != null && hasPath(object, path, baseHas);
                }
                function hasIn(object, path) {
                  return object != null && hasPath(object, path, baseHasIn);
                }
                var invert = createInverter(function (result2, value, key) {
                  if (value != null && typeof value.toString != "function") {
                    value = nativeObjectToString.call(value);
                  }
                  result2[value] = key;
                }, constant(identity));
                var invertBy = createInverter(function (result2, value, key) {
                  if (value != null && typeof value.toString != "function") {
                    value = nativeObjectToString.call(value);
                  }
                  if (hasOwnProperty.call(result2, value)) {
                    result2[value].push(key);
                  } else {
                    result2[value] = [key];
                  }
                }, getIteratee);
                var invoke = baseRest(baseInvoke);
                function keys(object) {
                  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                }
                function keysIn(object) {
                  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
                }
                function mapKeys(object, iteratee2) {
                  var result2 = {};
                  iteratee2 = getIteratee(iteratee2, 3);
                  baseForOwn(object, function (value, key, object2) {
                    baseAssignValue(result2, iteratee2(value, key, object2), value);
                  });
                  return result2;
                }
                function mapValues(object, iteratee2) {
                  var result2 = {};
                  iteratee2 = getIteratee(iteratee2, 3);
                  baseForOwn(object, function (value, key, object2) {
                    baseAssignValue(result2, key, iteratee2(value, key, object2));
                  });
                  return result2;
                }
                var merge = createAssigner(function (object, source, srcIndex) {
                  baseMerge(object, source, srcIndex);
                });
                var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
                  baseMerge(object, source, srcIndex, customizer);
                });
                var omit = flatRest(function (object, paths) {
                  var result2 = {};
                  if (object == null) {
                    return result2;
                  }
                  var isDeep = false;
                  paths = arrayMap(paths, function (path) {
                    path = castPath(path, object);
                    isDeep || (isDeep = path.length > 1);
                    return path;
                  });
                  copyObject(object, getAllKeysIn(object), result2);
                  if (isDeep) {
                    result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                  }
                  var length = paths.length;
                  while (length--) {
                    baseUnset(result2, paths[length]);
                  }
                  return result2;
                });
                function omitBy(object, predicate) {
                  return pickBy(object, negate(getIteratee(predicate)));
                }
                var pick = flatRest(function (object, paths) {
                  return object == null ? {} : basePick(object, paths);
                });
                function pickBy(object, predicate) {
                  if (object == null) {
                    return {};
                  }
                  var props = arrayMap(getAllKeysIn(object), function (prop) {
                    return [prop];
                  });
                  predicate = getIteratee(predicate);
                  return basePickBy(object, props, function (value, path) {
                    return predicate(value, path[0]);
                  });
                }
                function result(object, path, defaultValue) {
                  path = castPath(path, object);
                  var index = -1,
                    length = path.length;
                  if (!length) {
                    length = 1;
                    object = undefined$1;
                  }
                  while (++index < length) {
                    var value = object == null ? undefined$1 : object[toKey(path[index])];
                    if (value === undefined$1) {
                      index = length;
                      value = defaultValue;
                    }
                    object = isFunction(value) ? value.call(object) : value;
                  }
                  return object;
                }
                function set(object, path, value) {
                  return object == null ? object : baseSet(object, path, value);
                }
                function setWith(object, path, value, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined$1;
                  return object == null ? object : baseSet(object, path, value, customizer);
                }
                var toPairs = createToPairs(keys);
                var toPairsIn = createToPairs(keysIn);
                function transform(object, iteratee2, accumulator) {
                  var isArr = isArray(object),
                    isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                  iteratee2 = getIteratee(iteratee2, 4);
                  if (accumulator == null) {
                    var Ctor = object && object.constructor;
                    if (isArrLike) {
                      accumulator = isArr ? new Ctor() : [];
                    } else if (isObject(object)) {
                      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                    } else {
                      accumulator = {};
                    }
                  }
                  (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object2) {
                    return iteratee2(accumulator, value, index, object2);
                  });
                  return accumulator;
                }
                function unset(object, path) {
                  return object == null ? true : baseUnset(object, path);
                }
                function update(object, path, updater) {
                  return object == null ? object : baseUpdate(object, path, castFunction(updater));
                }
                function updateWith(object, path, updater, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined$1;
                  return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
                }
                function values(object) {
                  return object == null ? [] : baseValues(object, keys(object));
                }
                function valuesIn(object) {
                  return object == null ? [] : baseValues(object, keysIn(object));
                }
                function clamp(number, lower, upper) {
                  if (upper === undefined$1) {
                    upper = lower;
                    lower = undefined$1;
                  }
                  if (upper !== undefined$1) {
                    upper = toNumber(upper);
                    upper = upper === upper ? upper : 0;
                  }
                  if (lower !== undefined$1) {
                    lower = toNumber(lower);
                    lower = lower === lower ? lower : 0;
                  }
                  return baseClamp(toNumber(number), lower, upper);
                }
                function inRange(number, start, end) {
                  start = toFinite(start);
                  if (end === undefined$1) {
                    end = start;
                    start = 0;
                  } else {
                    end = toFinite(end);
                  }
                  number = toNumber(number);
                  return baseInRange(number, start, end);
                }
                function random(lower, upper, floating) {
                  if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
                    upper = floating = undefined$1;
                  }
                  if (floating === undefined$1) {
                    if (typeof upper == "boolean") {
                      floating = upper;
                      upper = undefined$1;
                    } else if (typeof lower == "boolean") {
                      floating = lower;
                      lower = undefined$1;
                    }
                  }
                  if (lower === undefined$1 && upper === undefined$1) {
                    lower = 0;
                    upper = 1;
                  } else {
                    lower = toFinite(lower);
                    if (upper === undefined$1) {
                      upper = lower;
                      lower = 0;
                    } else {
                      upper = toFinite(upper);
                    }
                  }
                  if (lower > upper) {
                    var temp = lower;
                    lower = upper;
                    upper = temp;
                  }
                  if (floating || lower % 1 || upper % 1) {
                    var rand = nativeRandom();
                    return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
                  }
                  return baseRandom(lower, upper);
                }
                var camelCase = createCompounder(function (result2, word, index) {
                  word = word.toLowerCase();
                  return result2 + (index ? capitalize(word) : word);
                });
                function capitalize(string) {
                  return upperFirst(toString(string).toLowerCase());
                }
                function deburr(string) {
                  string = toString(string);
                  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
                }
                function endsWith(string, target, position) {
                  string = toString(string);
                  target = baseToString(target);
                  var length = string.length;
                  position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
                  var end = position;
                  position -= target.length;
                  return position >= 0 && string.slice(position, end) == target;
                }
                function escape(string) {
                  string = toString(string);
                  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
                }
                function escapeRegExp(string) {
                  string = toString(string);
                  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
                }
                var kebabCase = createCompounder(function (result2, word, index) {
                  return result2 + (index ? "-" : "") + word.toLowerCase();
                });
                var lowerCase = createCompounder(function (result2, word, index) {
                  return result2 + (index ? " " : "") + word.toLowerCase();
                });
                var lowerFirst = createCaseFirst("toLowerCase");
                function pad(string, length, chars) {
                  string = toString(string);
                  length = toInteger(length);
                  var strLength = length ? stringSize(string) : 0;
                  if (!length || strLength >= length) {
                    return string;
                  }
                  var mid = (length - strLength) / 2;
                  return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
                }
                function padEnd(string, length, chars) {
                  string = toString(string);
                  length = toInteger(length);
                  var strLength = length ? stringSize(string) : 0;
                  return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
                }
                function padStart(string, length, chars) {
                  string = toString(string);
                  length = toInteger(length);
                  var strLength = length ? stringSize(string) : 0;
                  return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
                }
                function parseInt2(string, radix, guard) {
                  if (guard || radix == null) {
                    radix = 0;
                  } else if (radix) {
                    radix = +radix;
                  }
                  return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
                }
                function repeat(string, n, guard) {
                  if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
                    n = 1;
                  } else {
                    n = toInteger(n);
                  }
                  return baseRepeat(toString(string), n);
                }
                function replace() {
                  var args = arguments,
                    string = toString(args[0]);
                  return args.length < 3 ? string : string.replace(args[1], args[2]);
                }
                var snakeCase = createCompounder(function (result2, word, index) {
                  return result2 + (index ? "_" : "") + word.toLowerCase();
                });
                function split(string, separator, limit) {
                  if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
                    separator = limit = undefined$1;
                  }
                  limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
                  if (!limit) {
                    return [];
                  }
                  string = toString(string);
                  if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                    separator = baseToString(separator);
                    if (!separator && hasUnicode(string)) {
                      return castSlice(stringToArray(string), 0, limit);
                    }
                  }
                  return string.split(separator, limit);
                }
                var startCase = createCompounder(function (result2, word, index) {
                  return result2 + (index ? " " : "") + upperFirst(word);
                });
                function startsWith(string, target, position) {
                  string = toString(string);
                  position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
                  target = baseToString(target);
                  return string.slice(position, position + target.length) == target;
                }
                function template(string, options, guard) {
                  var settings = lodash.templateSettings;
                  if (guard && isIterateeCall(string, options, guard)) {
                    options = undefined$1;
                  }
                  string = toString(string);
                  options = assignInWith({}, options, settings, customDefaultsAssignIn);
                  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
                    importsKeys = keys(imports),
                    importsValues = baseValues(imports, importsKeys);
                  var isEscaping,
                    isEvaluating,
                    index = 0,
                    interpolate = options.interpolate || reNoMatch,
                    source = "__p += '";
                  var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
                  var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                  string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                    interpolateValue || (interpolateValue = esTemplateValue);
                    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                    if (escapeValue) {
                      isEscaping = true;
                      source += "' +\n__e(" + escapeValue + ") +\n'";
                    }
                    if (evaluateValue) {
                      isEvaluating = true;
                      source += "';\n" + evaluateValue + ";\n__p += '";
                    }
                    if (interpolateValue) {
                      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                    }
                    index = offset + match.length;
                    return match;
                  });
                  source += "';\n";
                  var variable = hasOwnProperty.call(options, "variable") && options.variable;
                  if (!variable) {
                    source = "with (obj) {\n" + source + "\n}\n";
                  } else if (reForbiddenIdentifierChars.test(variable)) {
                    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
                  }
                  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                  var result2 = attempt(function () {
                    return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
                  });
                  result2.source = source;
                  if (isError(result2)) {
                    throw result2;
                  }
                  return result2;
                }
                function toLower(value) {
                  return toString(value).toLowerCase();
                }
                function toUpper(value) {
                  return toString(value).toUpperCase();
                }
                function trim(string, chars, guard) {
                  string = toString(string);
                  if (string && (guard || chars === undefined$1)) {
                    return baseTrim(string);
                  }
                  if (!string || !(chars = baseToString(chars))) {
                    return string;
                  }
                  var strSymbols = stringToArray(string),
                    chrSymbols = stringToArray(chars),
                    start = charsStartIndex(strSymbols, chrSymbols),
                    end = charsEndIndex(strSymbols, chrSymbols) + 1;
                  return castSlice(strSymbols, start, end).join("");
                }
                function trimEnd(string, chars, guard) {
                  string = toString(string);
                  if (string && (guard || chars === undefined$1)) {
                    return string.slice(0, trimmedEndIndex(string) + 1);
                  }
                  if (!string || !(chars = baseToString(chars))) {
                    return string;
                  }
                  var strSymbols = stringToArray(string),
                    end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                  return castSlice(strSymbols, 0, end).join("");
                }
                function trimStart(string, chars, guard) {
                  string = toString(string);
                  if (string && (guard || chars === undefined$1)) {
                    return string.replace(reTrimStart, "");
                  }
                  if (!string || !(chars = baseToString(chars))) {
                    return string;
                  }
                  var strSymbols = stringToArray(string),
                    start = charsStartIndex(strSymbols, stringToArray(chars));
                  return castSlice(strSymbols, start).join("");
                }
                function truncate(string, options) {
                  var length = DEFAULT_TRUNC_LENGTH,
                    omission = DEFAULT_TRUNC_OMISSION;
                  if (isObject(options)) {
                    var separator = "separator" in options ? options.separator : separator;
                    length = "length" in options ? toInteger(options.length) : length;
                    omission = "omission" in options ? baseToString(options.omission) : omission;
                  }
                  string = toString(string);
                  var strLength = string.length;
                  if (hasUnicode(string)) {
                    var strSymbols = stringToArray(string);
                    strLength = strSymbols.length;
                  }
                  if (length >= strLength) {
                    return string;
                  }
                  var end = length - stringSize(omission);
                  if (end < 1) {
                    return omission;
                  }
                  var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                  if (separator === undefined$1) {
                    return result2 + omission;
                  }
                  if (strSymbols) {
                    end += result2.length - end;
                  }
                  if (isRegExp(separator)) {
                    if (string.slice(end).search(separator)) {
                      var match,
                        substring = result2;
                      if (!separator.global) {
                        separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                      }
                      separator.lastIndex = 0;
                      while (match = separator.exec(substring)) {
                        var newEnd = match.index;
                      }
                      result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
                    }
                  } else if (string.indexOf(baseToString(separator), end) != end) {
                    var index = result2.lastIndexOf(separator);
                    if (index > -1) {
                      result2 = result2.slice(0, index);
                    }
                  }
                  return result2 + omission;
                }
                function unescape(string) {
                  string = toString(string);
                  return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
                }
                var upperCase = createCompounder(function (result2, word, index) {
                  return result2 + (index ? " " : "") + word.toUpperCase();
                });
                var upperFirst = createCaseFirst("toUpperCase");
                function words(string, pattern, guard) {
                  string = toString(string);
                  pattern = guard ? undefined$1 : pattern;
                  if (pattern === undefined$1) {
                    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                  }
                  return string.match(pattern) || [];
                }
                var attempt = baseRest(function (func, args) {
                  try {
                    return apply(func, undefined$1, args);
                  } catch (e) {
                    return isError(e) ? e : new Error(e);
                  }
                });
                var bindAll = flatRest(function (object, methodNames) {
                  arrayEach(methodNames, function (key) {
                    key = toKey(key);
                    baseAssignValue(object, key, bind(object[key], object));
                  });
                  return object;
                });
                function cond(pairs) {
                  var length = pairs == null ? 0 : pairs.length,
                    toIteratee = getIteratee();
                  pairs = !length ? [] : arrayMap(pairs, function (pair) {
                    if (typeof pair[1] != "function") {
                      throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    return [toIteratee(pair[0]), pair[1]];
                  });
                  return baseRest(function (args) {
                    var index = -1;
                    while (++index < length) {
                      var pair = pairs[index];
                      if (apply(pair[0], this, args)) {
                        return apply(pair[1], this, args);
                      }
                    }
                  });
                }
                function conforms(source) {
                  return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
                }
                function constant(value) {
                  return function () {
                    return value;
                  };
                }
                function defaultTo(value, defaultValue) {
                  return value == null || value !== value ? defaultValue : value;
                }
                var flow = createFlow();
                var flowRight = createFlow(true);
                function identity(value) {
                  return value;
                }
                function iteratee(func) {
                  return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
                }
                function matches(source) {
                  return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
                }
                function matchesProperty(path, srcValue) {
                  return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
                }
                var method = baseRest(function (path, args) {
                  return function (object) {
                    return baseInvoke(object, path, args);
                  };
                });
                var methodOf = baseRest(function (object, args) {
                  return function (path) {
                    return baseInvoke(object, path, args);
                  };
                });
                function mixin(object, source, options) {
                  var props = keys(source),
                    methodNames = baseFunctions(source, props);
                  if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                    options = source;
                    source = object;
                    object = this;
                    methodNames = baseFunctions(source, keys(source));
                  }
                  var chain2 = !(isObject(options) && "chain" in options) || !!options.chain,
                    isFunc = isFunction(object);
                  arrayEach(methodNames, function (methodName) {
                    var func = source[methodName];
                    object[methodName] = func;
                    if (isFunc) {
                      object.prototype[methodName] = function () {
                        var chainAll = this.__chain__;
                        if (chain2 || chainAll) {
                          var result2 = object(this.__wrapped__),
                            actions = result2.__actions__ = copyArray(this.__actions__);
                          actions.push({
                            "func": func,
                            "args": arguments,
                            "thisArg": object
                          });
                          result2.__chain__ = chainAll;
                          return result2;
                        }
                        return func.apply(object, arrayPush([this.value()], arguments));
                      };
                    }
                  });
                  return object;
                }
                function noConflict() {
                  if (root._ === this) {
                    root._ = oldDash;
                  }
                  return this;
                }
                function noop() {}
                function nthArg(n) {
                  n = toInteger(n);
                  return baseRest(function (args) {
                    return baseNth(args, n);
                  });
                }
                var over = createOver(arrayMap);
                var overEvery = createOver(arrayEvery);
                var overSome = createOver(arraySome);
                function property(path) {
                  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                }
                function propertyOf(object) {
                  return function (path) {
                    return object == null ? undefined$1 : baseGet(object, path);
                  };
                }
                var range = createRange();
                var rangeRight = createRange(true);
                function stubArray() {
                  return [];
                }
                function stubFalse() {
                  return false;
                }
                function stubObject() {
                  return {};
                }
                function stubString() {
                  return "";
                }
                function stubTrue() {
                  return true;
                }
                function times(n, iteratee2) {
                  n = toInteger(n);
                  if (n < 1 || n > MAX_SAFE_INTEGER) {
                    return [];
                  }
                  var index = MAX_ARRAY_LENGTH,
                    length = nativeMin(n, MAX_ARRAY_LENGTH);
                  iteratee2 = getIteratee(iteratee2);
                  n -= MAX_ARRAY_LENGTH;
                  var result2 = baseTimes(length, iteratee2);
                  while (++index < n) {
                    iteratee2(index);
                  }
                  return result2;
                }
                function toPath(value) {
                  if (isArray(value)) {
                    return arrayMap(value, toKey);
                  }
                  return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
                }
                function uniqueId(prefix) {
                  var id = ++idCounter;
                  return toString(prefix) + id;
                }
                var add = createMathOperation(function (augend, addend) {
                  return augend + addend;
                }, 0);
                var ceil = createRound("ceil");
                var divide = createMathOperation(function (dividend, divisor) {
                  return dividend / divisor;
                }, 1);
                var floor = createRound("floor");
                function max(array) {
                  return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
                }
                function maxBy(array, iteratee2) {
                  return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
                }
                function mean(array) {
                  return baseMean(array, identity);
                }
                function meanBy(array, iteratee2) {
                  return baseMean(array, getIteratee(iteratee2, 2));
                }
                function min(array) {
                  return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
                }
                function minBy(array, iteratee2) {
                  return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
                }
                var multiply = createMathOperation(function (multiplier, multiplicand) {
                  return multiplier * multiplicand;
                }, 1);
                var round = createRound("round");
                var subtract = createMathOperation(function (minuend, subtrahend) {
                  return minuend - subtrahend;
                }, 0);
                function sum(array) {
                  return array && array.length ? baseSum(array, identity) : 0;
                }
                function sumBy(array, iteratee2) {
                  return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
                }
                lodash.after = after;
                lodash.ary = ary;
                lodash.assign = assign;
                lodash.assignIn = assignIn;
                lodash.assignInWith = assignInWith;
                lodash.assignWith = assignWith;
                lodash.at = at;
                lodash.before = before;
                lodash.bind = bind;
                lodash.bindAll = bindAll;
                lodash.bindKey = bindKey;
                lodash.castArray = castArray;
                lodash.chain = chain;
                lodash.chunk = chunk;
                lodash.compact = compact;
                lodash.concat = concat;
                lodash.cond = cond;
                lodash.conforms = conforms;
                lodash.constant = constant;
                lodash.countBy = countBy;
                lodash.create = create;
                lodash.curry = curry;
                lodash.curryRight = curryRight;
                lodash.debounce = debounce;
                lodash.defaults = defaults;
                lodash.defaultsDeep = defaultsDeep;
                lodash.defer = defer;
                lodash.delay = delay;
                lodash.difference = difference;
                lodash.differenceBy = differenceBy;
                lodash.differenceWith = differenceWith;
                lodash.drop = drop;
                lodash.dropRight = dropRight;
                lodash.dropRightWhile = dropRightWhile;
                lodash.dropWhile = dropWhile;
                lodash.fill = fill;
                lodash.filter = filter;
                lodash.flatMap = flatMap;
                lodash.flatMapDeep = flatMapDeep;
                lodash.flatMapDepth = flatMapDepth;
                lodash.flatten = flatten;
                lodash.flattenDeep = flattenDeep;
                lodash.flattenDepth = flattenDepth;
                lodash.flip = flip;
                lodash.flow = flow;
                lodash.flowRight = flowRight;
                lodash.fromPairs = fromPairs;
                lodash.functions = functions;
                lodash.functionsIn = functionsIn;
                lodash.groupBy = groupBy;
                lodash.initial = initial;
                lodash.intersection = intersection;
                lodash.intersectionBy = intersectionBy;
                lodash.intersectionWith = intersectionWith;
                lodash.invert = invert;
                lodash.invertBy = invertBy;
                lodash.invokeMap = invokeMap;
                lodash.iteratee = iteratee;
                lodash.keyBy = keyBy;
                lodash.keys = keys;
                lodash.keysIn = keysIn;
                lodash.map = map;
                lodash.mapKeys = mapKeys;
                lodash.mapValues = mapValues;
                lodash.matches = matches;
                lodash.matchesProperty = matchesProperty;
                lodash.memoize = memoize;
                lodash.merge = merge;
                lodash.mergeWith = mergeWith;
                lodash.method = method;
                lodash.methodOf = methodOf;
                lodash.mixin = mixin;
                lodash.negate = negate;
                lodash.nthArg = nthArg;
                lodash.omit = omit;
                lodash.omitBy = omitBy;
                lodash.once = once;
                lodash.orderBy = orderBy;
                lodash.over = over;
                lodash.overArgs = overArgs;
                lodash.overEvery = overEvery;
                lodash.overSome = overSome;
                lodash.partial = partial;
                lodash.partialRight = partialRight;
                lodash.partition = partition;
                lodash.pick = pick;
                lodash.pickBy = pickBy;
                lodash.property = property;
                lodash.propertyOf = propertyOf;
                lodash.pull = pull;
                lodash.pullAll = pullAll;
                lodash.pullAllBy = pullAllBy;
                lodash.pullAllWith = pullAllWith;
                lodash.pullAt = pullAt;
                lodash.range = range;
                lodash.rangeRight = rangeRight;
                lodash.rearg = rearg;
                lodash.reject = reject;
                lodash.remove = remove;
                lodash.rest = rest;
                lodash.reverse = reverse;
                lodash.sampleSize = sampleSize;
                lodash.set = set;
                lodash.setWith = setWith;
                lodash.shuffle = shuffle;
                lodash.slice = slice;
                lodash.sortBy = sortBy;
                lodash.sortedUniq = sortedUniq;
                lodash.sortedUniqBy = sortedUniqBy;
                lodash.split = split;
                lodash.spread = spread;
                lodash.tail = tail;
                lodash.take = take;
                lodash.takeRight = takeRight;
                lodash.takeRightWhile = takeRightWhile;
                lodash.takeWhile = takeWhile;
                lodash.tap = tap;
                lodash.throttle = throttle;
                lodash.thru = thru;
                lodash.toArray = toArray;
                lodash.toPairs = toPairs;
                lodash.toPairsIn = toPairsIn;
                lodash.toPath = toPath;
                lodash.toPlainObject = toPlainObject;
                lodash.transform = transform;
                lodash.unary = unary;
                lodash.union = union;
                lodash.unionBy = unionBy;
                lodash.unionWith = unionWith;
                lodash.uniq = uniq;
                lodash.uniqBy = uniqBy;
                lodash.uniqWith = uniqWith;
                lodash.unset = unset;
                lodash.unzip = unzip;
                lodash.unzipWith = unzipWith;
                lodash.update = update;
                lodash.updateWith = updateWith;
                lodash.values = values;
                lodash.valuesIn = valuesIn;
                lodash.without = without;
                lodash.words = words;
                lodash.wrap = wrap;
                lodash.xor = xor;
                lodash.xorBy = xorBy;
                lodash.xorWith = xorWith;
                lodash.zip = zip;
                lodash.zipObject = zipObject;
                lodash.zipObjectDeep = zipObjectDeep;
                lodash.zipWith = zipWith;
                lodash.entries = toPairs;
                lodash.entriesIn = toPairsIn;
                lodash.extend = assignIn;
                lodash.extendWith = assignInWith;
                mixin(lodash, lodash);
                lodash.add = add;
                lodash.attempt = attempt;
                lodash.camelCase = camelCase;
                lodash.capitalize = capitalize;
                lodash.ceil = ceil;
                lodash.clamp = clamp;
                lodash.clone = clone;
                lodash.cloneDeep = cloneDeep;
                lodash.cloneDeepWith = cloneDeepWith;
                lodash.cloneWith = cloneWith;
                lodash.conformsTo = conformsTo;
                lodash.deburr = deburr;
                lodash.defaultTo = defaultTo;
                lodash.divide = divide;
                lodash.endsWith = endsWith;
                lodash.eq = eq;
                lodash.escape = escape;
                lodash.escapeRegExp = escapeRegExp;
                lodash.every = every;
                lodash.find = find;
                lodash.findIndex = findIndex;
                lodash.findKey = findKey;
                lodash.findLast = findLast;
                lodash.findLastIndex = findLastIndex;
                lodash.findLastKey = findLastKey;
                lodash.floor = floor;
                lodash.forEach = forEach;
                lodash.forEachRight = forEachRight;
                lodash.forIn = forIn;
                lodash.forInRight = forInRight;
                lodash.forOwn = forOwn;
                lodash.forOwnRight = forOwnRight;
                lodash.get = get;
                lodash.gt = gt;
                lodash.gte = gte;
                lodash.has = has;
                lodash.hasIn = hasIn;
                lodash.head = head;
                lodash.identity = identity;
                lodash.includes = includes;
                lodash.indexOf = indexOf;
                lodash.inRange = inRange;
                lodash.invoke = invoke;
                lodash.isArguments = isArguments;
                lodash.isArray = isArray;
                lodash.isArrayBuffer = isArrayBuffer;
                lodash.isArrayLike = isArrayLike;
                lodash.isArrayLikeObject = isArrayLikeObject;
                lodash.isBoolean = isBoolean;
                lodash.isBuffer = isBuffer;
                lodash.isDate = isDate;
                lodash.isElement = isElement;
                lodash.isEmpty = isEmpty;
                lodash.isEqual = isEqual;
                lodash.isEqualWith = isEqualWith;
                lodash.isError = isError;
                lodash.isFinite = isFinite;
                lodash.isFunction = isFunction;
                lodash.isInteger = isInteger;
                lodash.isLength = isLength;
                lodash.isMap = isMap;
                lodash.isMatch = isMatch;
                lodash.isMatchWith = isMatchWith;
                lodash.isNaN = isNaN;
                lodash.isNative = isNative;
                lodash.isNil = isNil;
                lodash.isNull = isNull;
                lodash.isNumber = isNumber;
                lodash.isObject = isObject;
                lodash.isObjectLike = isObjectLike;
                lodash.isPlainObject = isPlainObject;
                lodash.isRegExp = isRegExp;
                lodash.isSafeInteger = isSafeInteger;
                lodash.isSet = isSet;
                lodash.isString = isString;
                lodash.isSymbol = isSymbol;
                lodash.isTypedArray = isTypedArray;
                lodash.isUndefined = isUndefined;
                lodash.isWeakMap = isWeakMap;
                lodash.isWeakSet = isWeakSet;
                lodash.join = join;
                lodash.kebabCase = kebabCase;
                lodash.last = last;
                lodash.lastIndexOf = lastIndexOf;
                lodash.lowerCase = lowerCase;
                lodash.lowerFirst = lowerFirst;
                lodash.lt = lt;
                lodash.lte = lte;
                lodash.max = max;
                lodash.maxBy = maxBy;
                lodash.mean = mean;
                lodash.meanBy = meanBy;
                lodash.min = min;
                lodash.minBy = minBy;
                lodash.stubArray = stubArray;
                lodash.stubFalse = stubFalse;
                lodash.stubObject = stubObject;
                lodash.stubString = stubString;
                lodash.stubTrue = stubTrue;
                lodash.multiply = multiply;
                lodash.nth = nth;
                lodash.noConflict = noConflict;
                lodash.noop = noop;
                lodash.now = now;
                lodash.pad = pad;
                lodash.padEnd = padEnd;
                lodash.padStart = padStart;
                lodash.parseInt = parseInt2;
                lodash.random = random;
                lodash.reduce = reduce;
                lodash.reduceRight = reduceRight;
                lodash.repeat = repeat;
                lodash.replace = replace;
                lodash.result = result;
                lodash.round = round;
                lodash.runInContext = runInContext2;
                lodash.sample = sample;
                lodash.size = size;
                lodash.snakeCase = snakeCase;
                lodash.some = some;
                lodash.sortedIndex = sortedIndex;
                lodash.sortedIndexBy = sortedIndexBy;
                lodash.sortedIndexOf = sortedIndexOf;
                lodash.sortedLastIndex = sortedLastIndex;
                lodash.sortedLastIndexBy = sortedLastIndexBy;
                lodash.sortedLastIndexOf = sortedLastIndexOf;
                lodash.startCase = startCase;
                lodash.startsWith = startsWith;
                lodash.subtract = subtract;
                lodash.sum = sum;
                lodash.sumBy = sumBy;
                lodash.template = template;
                lodash.times = times;
                lodash.toFinite = toFinite;
                lodash.toInteger = toInteger;
                lodash.toLength = toLength;
                lodash.toLower = toLower;
                lodash.toNumber = toNumber;
                lodash.toSafeInteger = toSafeInteger;
                lodash.toString = toString;
                lodash.toUpper = toUpper;
                lodash.trim = trim;
                lodash.trimEnd = trimEnd;
                lodash.trimStart = trimStart;
                lodash.truncate = truncate;
                lodash.unescape = unescape;
                lodash.uniqueId = uniqueId;
                lodash.upperCase = upperCase;
                lodash.upperFirst = upperFirst;
                lodash.each = forEach;
                lodash.eachRight = forEachRight;
                lodash.first = head;
                mixin(lodash, function () {
                  var source = {};
                  baseForOwn(lodash, function (func, methodName) {
                    if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                      source[methodName] = func;
                    }
                  });
                  return source;
                }(), {
                  "chain": false
                });
                lodash.VERSION = VERSION;
                arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (methodName) {
                  lodash[methodName].placeholder = lodash;
                });
                arrayEach(["drop", "take"], function (methodName, index) {
                  LazyWrapper.prototype[methodName] = function (n) {
                    n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
                    var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                    if (result2.__filtered__) {
                      result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
                    } else {
                      result2.__views__.push({
                        "size": nativeMin(n, MAX_ARRAY_LENGTH),
                        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                      });
                    }
                    return result2;
                  };
                  LazyWrapper.prototype[methodName + "Right"] = function (n) {
                    return this.reverse()[methodName](n).reverse();
                  };
                });
                arrayEach(["filter", "map", "takeWhile"], function (methodName, index) {
                  var type = index + 1,
                    isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                  LazyWrapper.prototype[methodName] = function (iteratee2) {
                    var result2 = this.clone();
                    result2.__iteratees__.push({
                      "iteratee": getIteratee(iteratee2, 3),
                      "type": type
                    });
                    result2.__filtered__ = result2.__filtered__ || isFilter;
                    return result2;
                  };
                });
                arrayEach(["head", "last"], function (methodName, index) {
                  var takeName = "take" + (index ? "Right" : "");
                  LazyWrapper.prototype[methodName] = function () {
                    return this[takeName](1).value()[0];
                  };
                });
                arrayEach(["initial", "tail"], function (methodName, index) {
                  var dropName = "drop" + (index ? "" : "Right");
                  LazyWrapper.prototype[methodName] = function () {
                    return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                  };
                });
                LazyWrapper.prototype.compact = function () {
                  return this.filter(identity);
                };
                LazyWrapper.prototype.find = function (predicate) {
                  return this.filter(predicate).head();
                };
                LazyWrapper.prototype.findLast = function (predicate) {
                  return this.reverse().find(predicate);
                };
                LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
                  if (typeof path == "function") {
                    return new LazyWrapper(this);
                  }
                  return this.map(function (value) {
                    return baseInvoke(value, path, args);
                  });
                });
                LazyWrapper.prototype.reject = function (predicate) {
                  return this.filter(negate(getIteratee(predicate)));
                };
                LazyWrapper.prototype.slice = function (start, end) {
                  start = toInteger(start);
                  var result2 = this;
                  if (result2.__filtered__ && (start > 0 || end < 0)) {
                    return new LazyWrapper(result2);
                  }
                  if (start < 0) {
                    result2 = result2.takeRight(-start);
                  } else if (start) {
                    result2 = result2.drop(start);
                  }
                  if (end !== undefined$1) {
                    end = toInteger(end);
                    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
                  }
                  return result2;
                };
                LazyWrapper.prototype.takeRightWhile = function (predicate) {
                  return this.reverse().takeWhile(predicate).reverse();
                };
                LazyWrapper.prototype.toArray = function () {
                  return this.take(MAX_ARRAY_LENGTH);
                };
                baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
                    isTaker = /^(?:head|last)$/.test(methodName),
                    lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName],
                    retUnwrapped = isTaker || /^find/.test(methodName);
                  if (!lodashFunc) {
                    return;
                  }
                  lodash.prototype[methodName] = function () {
                    var value = this.__wrapped__,
                      args = isTaker ? [1] : arguments,
                      isLazy = value instanceof LazyWrapper,
                      iteratee2 = args[0],
                      useLazy = isLazy || isArray(value);
                    var interceptor = function (value2) {
                      var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                      return isTaker && chainAll ? result3[0] : result3;
                    };
                    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                      isLazy = useLazy = false;
                    }
                    var chainAll = this.__chain__,
                      isHybrid = !!this.__actions__.length,
                      isUnwrapped = retUnwrapped && !chainAll,
                      onlyLazy = isLazy && !isHybrid;
                    if (!retUnwrapped && useLazy) {
                      value = onlyLazy ? value : new LazyWrapper(this);
                      var result2 = func.apply(value, args);
                      result2.__actions__.push({
                        "func": thru,
                        "args": [interceptor],
                        "thisArg": undefined$1
                      });
                      return new LodashWrapper(result2, chainAll);
                    }
                    if (isUnwrapped && onlyLazy) {
                      return func.apply(this, args);
                    }
                    result2 = this.thru(interceptor);
                    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
                  };
                });
                arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function (methodName) {
                  var func = arrayProto[methodName],
                    chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru",
                    retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                  lodash.prototype[methodName] = function () {
                    var args = arguments;
                    if (retUnwrapped && !this.__chain__) {
                      var value = this.value();
                      return func.apply(isArray(value) ? value : [], args);
                    }
                    return this[chainName](function (value2) {
                      return func.apply(isArray(value2) ? value2 : [], args);
                    });
                  };
                });
                baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                  var lodashFunc = lodash[methodName];
                  if (lodashFunc) {
                    var key = lodashFunc.name + "";
                    if (!hasOwnProperty.call(realNames, key)) {
                      realNames[key] = [];
                    }
                    realNames[key].push({
                      "name": methodName,
                      "func": lodashFunc
                    });
                  }
                });
                realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
                  "name": "wrapper",
                  "func": undefined$1
                }];
                LazyWrapper.prototype.clone = lazyClone;
                LazyWrapper.prototype.reverse = lazyReverse;
                LazyWrapper.prototype.value = lazyValue;
                lodash.prototype.at = wrapperAt;
                lodash.prototype.chain = wrapperChain;
                lodash.prototype.commit = wrapperCommit;
                lodash.prototype.next = wrapperNext;
                lodash.prototype.plant = wrapperPlant;
                lodash.prototype.reverse = wrapperReverse;
                lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
                lodash.prototype.first = lodash.prototype.head;
                if (symIterator) {
                  lodash.prototype[symIterator] = wrapperToIterator;
                }
                return lodash;
              };
              var _ = runInContext();
              if (freeModule) {
                (freeModule.exports = _)._ = _;
                freeExports._ = _;
              } else {
                root._ = _;
              }
            }).call(lodash);
          })(lodash$1, lodash$1.exports);
          return lodash$1.exports;
        }
        requireLodash();
        var immutable$1 = {
          exports: {}
        };
        var immutable = immutable$1.exports;
        var hasRequiredImmutable;
        function requireImmutable() {
          if (hasRequiredImmutable) return immutable$1.exports;
          hasRequiredImmutable = 1;
          (function (module, exports) {
            (function (global, factory) {
              module.exports = factory();
            })(immutable, function () {
              var SLICE$0 = Array.prototype.slice;
              function createClass(ctor, superClass) {
                if (superClass) {
                  ctor.prototype = Object.create(superClass.prototype);
                }
                ctor.prototype.constructor = ctor;
              }
              function Iterable(value) {
                return isIterable(value) ? value : Seq(value);
              }
              createClass(KeyedIterable, Iterable);
              function KeyedIterable(value) {
                return isKeyed(value) ? value : KeyedSeq(value);
              }
              createClass(IndexedIterable, Iterable);
              function IndexedIterable(value) {
                return isIndexed(value) ? value : IndexedSeq(value);
              }
              createClass(SetIterable, Iterable);
              function SetIterable(value) {
                return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
              }
              function isIterable(maybeIterable) {
                return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
              }
              function isKeyed(maybeKeyed) {
                return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
              }
              function isIndexed(maybeIndexed) {
                return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
              }
              function isAssociative(maybeAssociative) {
                return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
              }
              function isOrdered(maybeOrdered) {
                return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
              }
              Iterable.isIterable = isIterable;
              Iterable.isKeyed = isKeyed;
              Iterable.isIndexed = isIndexed;
              Iterable.isAssociative = isAssociative;
              Iterable.isOrdered = isOrdered;
              Iterable.Keyed = KeyedIterable;
              Iterable.Indexed = IndexedIterable;
              Iterable.Set = SetIterable;
              var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
              var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
              var IS_INDEXED_SENTINEL = "@@__IMMUTABLE_INDEXED__@@";
              var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
              var DELETE = "delete";
              var SHIFT = 5;
              var SIZE = 1 << SHIFT;
              var MASK = SIZE - 1;
              var NOT_SET = {};
              var CHANGE_LENGTH = {
                value: false
              };
              var DID_ALTER = {
                value: false
              };
              function MakeRef(ref) {
                ref.value = false;
                return ref;
              }
              function SetRef(ref) {
                ref && (ref.value = true);
              }
              function OwnerID() {}
              function arrCopy(arr, offset) {
                offset = offset || 0;
                var len = Math.max(0, arr.length - offset);
                var newArr = new Array(len);
                for (var ii = 0; ii < len; ii++) {
                  newArr[ii] = arr[ii + offset];
                }
                return newArr;
              }
              function ensureSize(iter) {
                if (iter.size === void 0) {
                  iter.size = iter.__iterate(returnTrue);
                }
                return iter.size;
              }
              function wrapIndex(iter, index) {
                if (typeof index !== "number") {
                  var uint32Index = index >>> 0;
                  if ("" + uint32Index !== index || uint32Index === 4294967295) {
                    return NaN;
                  }
                  index = uint32Index;
                }
                return index < 0 ? ensureSize(iter) + index : index;
              }
              function returnTrue() {
                return true;
              }
              function wholeSlice(begin, end, size) {
                return (begin === 0 || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
              }
              function resolveBegin(begin, size) {
                return resolveIndex(begin, size, 0);
              }
              function resolveEnd(end, size) {
                return resolveIndex(end, size, size);
              }
              function resolveIndex(index, size, defaultIndex) {
                return index === void 0 ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === void 0 ? index : Math.min(size, index);
              }
              var ITERATE_KEYS = 0;
              var ITERATE_VALUES = 1;
              var ITERATE_ENTRIES = 2;
              var REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
              var FAUX_ITERATOR_SYMBOL = "@@iterator";
              var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
              function Iterator(next) {
                this.next = next;
              }
              Iterator.prototype.toString = function () {
                return "[Iterator]";
              };
              Iterator.KEYS = ITERATE_KEYS;
              Iterator.VALUES = ITERATE_VALUES;
              Iterator.ENTRIES = ITERATE_ENTRIES;
              Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
                return this.toString();
              };
              Iterator.prototype[ITERATOR_SYMBOL] = function () {
                return this;
              };
              function iteratorValue(type, k, v, iteratorResult) {
                var value = type === 0 ? k : type === 1 ? v : [k, v];
                iteratorResult ? iteratorResult.value = value : iteratorResult = {
                  value,
                  done: false
                };
                return iteratorResult;
              }
              function iteratorDone() {
                return {
                  value: void 0,
                  done: true
                };
              }
              function hasIterator(maybeIterable) {
                return !!getIteratorFn(maybeIterable);
              }
              function isIterator(maybeIterator) {
                return maybeIterator && typeof maybeIterator.next === "function";
              }
              function getIterator(iterable) {
                var iteratorFn = getIteratorFn(iterable);
                return iteratorFn && iteratorFn.call(iterable);
              }
              function getIteratorFn(iterable) {
                var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
                if (typeof iteratorFn === "function") {
                  return iteratorFn;
                }
              }
              function isArrayLike(value) {
                return value && typeof value.length === "number";
              }
              createClass(Seq, Iterable);
              function Seq(value) {
                return value === null || value === void 0 ? emptySequence() : isIterable(value) ? value.toSeq() : seqFromValue(value);
              }
              Seq.of = function () {
                return Seq(arguments);
              };
              Seq.prototype.toSeq = function () {
                return this;
              };
              Seq.prototype.toString = function () {
                return this.__toString("Seq {", "}");
              };
              Seq.prototype.cacheResult = function () {
                if (!this._cache && this.__iterateUncached) {
                  this._cache = this.entrySeq().toArray();
                  this.size = this._cache.length;
                }
                return this;
              };
              Seq.prototype.__iterate = function (fn, reverse) {
                return seqIterate(this, fn, reverse, true);
              };
              Seq.prototype.__iterator = function (type, reverse) {
                return seqIterator(this, type, reverse, true);
              };
              createClass(KeyedSeq, Seq);
              function KeyedSeq(value) {
                return value === null || value === void 0 ? emptySequence().toKeyedSeq() : isIterable(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue(value);
              }
              KeyedSeq.prototype.toKeyedSeq = function () {
                return this;
              };
              createClass(IndexedSeq, Seq);
              function IndexedSeq(value) {
                return value === null || value === void 0 ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
              }
              IndexedSeq.of = function () {
                return IndexedSeq(arguments);
              };
              IndexedSeq.prototype.toIndexedSeq = function () {
                return this;
              };
              IndexedSeq.prototype.toString = function () {
                return this.__toString("Seq [", "]");
              };
              IndexedSeq.prototype.__iterate = function (fn, reverse) {
                return seqIterate(this, fn, reverse, false);
              };
              IndexedSeq.prototype.__iterator = function (type, reverse) {
                return seqIterator(this, type, reverse, false);
              };
              createClass(SetSeq, Seq);
              function SetSeq(value) {
                return (value === null || value === void 0 ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();
              }
              SetSeq.of = function () {
                return SetSeq(arguments);
              };
              SetSeq.prototype.toSetSeq = function () {
                return this;
              };
              Seq.isSeq = isSeq;
              Seq.Keyed = KeyedSeq;
              Seq.Set = SetSeq;
              Seq.Indexed = IndexedSeq;
              var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
              Seq.prototype[IS_SEQ_SENTINEL] = true;
              createClass(ArraySeq, IndexedSeq);
              function ArraySeq(array) {
                this._array = array;
                this.size = array.length;
              }
              ArraySeq.prototype.get = function (index, notSetValue) {
                return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
              };
              ArraySeq.prototype.__iterate = function (fn, reverse) {
                var array = this._array;
                var maxIndex = array.length - 1;
                for (var ii = 0; ii <= maxIndex; ii++) {
                  if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
                    return ii + 1;
                  }
                }
                return ii;
              };
              ArraySeq.prototype.__iterator = function (type, reverse) {
                var array = this._array;
                var maxIndex = array.length - 1;
                var ii = 0;
                return new Iterator(function () {
                  return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++]);
                });
              };
              createClass(ObjectSeq, KeyedSeq);
              function ObjectSeq(object) {
                var keys = Object.keys(object);
                this._object = object;
                this._keys = keys;
                this.size = keys.length;
              }
              ObjectSeq.prototype.get = function (key, notSetValue) {
                if (notSetValue !== void 0 && !this.has(key)) {
                  return notSetValue;
                }
                return this._object[key];
              };
              ObjectSeq.prototype.has = function (key) {
                return this._object.hasOwnProperty(key);
              };
              ObjectSeq.prototype.__iterate = function (fn, reverse) {
                var object = this._object;
                var keys = this._keys;
                var maxIndex = keys.length - 1;
                for (var ii = 0; ii <= maxIndex; ii++) {
                  var key = keys[reverse ? maxIndex - ii : ii];
                  if (fn(object[key], key, this) === false) {
                    return ii + 1;
                  }
                }
                return ii;
              };
              ObjectSeq.prototype.__iterator = function (type, reverse) {
                var object = this._object;
                var keys = this._keys;
                var maxIndex = keys.length - 1;
                var ii = 0;
                return new Iterator(function () {
                  var key = keys[reverse ? maxIndex - ii : ii];
                  return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, key, object[key]);
                });
              };
              ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
              createClass(IterableSeq, IndexedSeq);
              function IterableSeq(iterable) {
                this._iterable = iterable;
                this.size = iterable.length || iterable.size;
              }
              IterableSeq.prototype.__iterateUncached = function (fn, reverse) {
                if (reverse) {
                  return this.cacheResult().__iterate(fn, reverse);
                }
                var iterable = this._iterable;
                var iterator = getIterator(iterable);
                var iterations = 0;
                if (isIterator(iterator)) {
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (fn(step.value, iterations++, this) === false) {
                      break;
                    }
                  }
                }
                return iterations;
              };
              IterableSeq.prototype.__iteratorUncached = function (type, reverse) {
                if (reverse) {
                  return this.cacheResult().__iterator(type, reverse);
                }
                var iterable = this._iterable;
                var iterator = getIterator(iterable);
                if (!isIterator(iterator)) {
                  return new Iterator(iteratorDone);
                }
                var iterations = 0;
                return new Iterator(function () {
                  var step = iterator.next();
                  return step.done ? step : iteratorValue(type, iterations++, step.value);
                });
              };
              createClass(IteratorSeq, IndexedSeq);
              function IteratorSeq(iterator) {
                this._iterator = iterator;
                this._iteratorCache = [];
              }
              IteratorSeq.prototype.__iterateUncached = function (fn, reverse) {
                if (reverse) {
                  return this.cacheResult().__iterate(fn, reverse);
                }
                var iterator = this._iterator;
                var cache = this._iteratorCache;
                var iterations = 0;
                while (iterations < cache.length) {
                  if (fn(cache[iterations], iterations++, this) === false) {
                    return iterations;
                  }
                }
                var step;
                while (!(step = iterator.next()).done) {
                  var val = step.value;
                  cache[iterations] = val;
                  if (fn(val, iterations++, this) === false) {
                    break;
                  }
                }
                return iterations;
              };
              IteratorSeq.prototype.__iteratorUncached = function (type, reverse) {
                if (reverse) {
                  return this.cacheResult().__iterator(type, reverse);
                }
                var iterator = this._iterator;
                var cache = this._iteratorCache;
                var iterations = 0;
                return new Iterator(function () {
                  if (iterations >= cache.length) {
                    var step = iterator.next();
                    if (step.done) {
                      return step;
                    }
                    cache[iterations] = step.value;
                  }
                  return iteratorValue(type, iterations, cache[iterations++]);
                });
              };
              function isSeq(maybeSeq) {
                return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
              }
              var EMPTY_SEQ;
              function emptySequence() {
                return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
              }
              function keyedSeqFromValue(value) {
                var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === "object" ? new ObjectSeq(value) : void 0;
                if (!seq) {
                  throw new TypeError("Expected Array or iterable object of [k, v] entries, or keyed object: " + value);
                }
                return seq;
              }
              function indexedSeqFromValue(value) {
                var seq = maybeIndexedSeqFromValue(value);
                if (!seq) {
                  throw new TypeError("Expected Array or iterable object of values: " + value);
                }
                return seq;
              }
              function seqFromValue(value) {
                var seq = maybeIndexedSeqFromValue(value) || typeof value === "object" && new ObjectSeq(value);
                if (!seq) {
                  throw new TypeError("Expected Array or iterable object of values, or keyed object: " + value);
                }
                return seq;
              }
              function maybeIndexedSeqFromValue(value) {
                return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : void 0;
              }
              function seqIterate(seq, fn, reverse, useKeys) {
                var cache = seq._cache;
                if (cache) {
                  var maxIndex = cache.length - 1;
                  for (var ii = 0; ii <= maxIndex; ii++) {
                    var entry = cache[reverse ? maxIndex - ii : ii];
                    if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
                      return ii + 1;
                    }
                  }
                  return ii;
                }
                return seq.__iterateUncached(fn, reverse);
              }
              function seqIterator(seq, type, reverse, useKeys) {
                var cache = seq._cache;
                if (cache) {
                  var maxIndex = cache.length - 1;
                  var ii = 0;
                  return new Iterator(function () {
                    var entry = cache[reverse ? maxIndex - ii : ii];
                    return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
                  });
                }
                return seq.__iteratorUncached(type, reverse);
              }
              function fromJS(json, converter) {
                return converter ? fromJSWith(converter, json, "", {
                  "": json
                }) : fromJSDefault(json);
              }
              function fromJSWith(converter, json, key, parentJSON) {
                if (Array.isArray(json)) {
                  return converter.call(parentJSON, key, IndexedSeq(json).map(function (v, k) {
                    return fromJSWith(converter, v, k, json);
                  }));
                }
                if (isPlainObj(json)) {
                  return converter.call(parentJSON, key, KeyedSeq(json).map(function (v, k) {
                    return fromJSWith(converter, v, k, json);
                  }));
                }
                return json;
              }
              function fromJSDefault(json) {
                if (Array.isArray(json)) {
                  return IndexedSeq(json).map(fromJSDefault).toList();
                }
                if (isPlainObj(json)) {
                  return KeyedSeq(json).map(fromJSDefault).toMap();
                }
                return json;
              }
              function isPlainObj(value) {
                return value && (value.constructor === Object || value.constructor === void 0);
              }
              function is(valueA, valueB) {
                if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
                  return true;
                }
                if (!valueA || !valueB) {
                  return false;
                }
                if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
                  valueA = valueA.valueOf();
                  valueB = valueB.valueOf();
                  if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
                    return true;
                  }
                  if (!valueA || !valueB) {
                    return false;
                  }
                }
                if (typeof valueA.equals === "function" && typeof valueB.equals === "function" && valueA.equals(valueB)) {
                  return true;
                }
                return false;
              }
              function deepEqual(a, b) {
                if (a === b) {
                  return true;
                }
                if (!isIterable(b) || a.size !== void 0 && b.size !== void 0 && a.size !== b.size || a.__hash !== void 0 && b.__hash !== void 0 && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
                  return false;
                }
                if (a.size === 0 && b.size === 0) {
                  return true;
                }
                var notAssociative = !isAssociative(a);
                if (isOrdered(a)) {
                  var entries = a.entries();
                  return b.every(function (v, k) {
                    var entry = entries.next().value;
                    return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
                  }) && entries.next().done;
                }
                var flipped = false;
                if (a.size === void 0) {
                  if (b.size === void 0) {
                    if (typeof a.cacheResult === "function") {
                      a.cacheResult();
                    }
                  } else {
                    flipped = true;
                    var _ = a;
                    a = b;
                    b = _;
                  }
                }
                var allEqual = true;
                var bSize = b.__iterate(function (v, k) {
                  if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
                    allEqual = false;
                    return false;
                  }
                });
                return allEqual && a.size === bSize;
              }
              createClass(Repeat, IndexedSeq);
              function Repeat(value, times) {
                if (!(this instanceof Repeat)) {
                  return new Repeat(value, times);
                }
                this._value = value;
                this.size = times === void 0 ? Infinity : Math.max(0, times);
                if (this.size === 0) {
                  if (EMPTY_REPEAT) {
                    return EMPTY_REPEAT;
                  }
                  EMPTY_REPEAT = this;
                }
              }
              Repeat.prototype.toString = function () {
                if (this.size === 0) {
                  return "Repeat []";
                }
                return "Repeat [ " + this._value + " " + this.size + " times ]";
              };
              Repeat.prototype.get = function (index, notSetValue) {
                return this.has(index) ? this._value : notSetValue;
              };
              Repeat.prototype.includes = function (searchValue) {
                return is(this._value, searchValue);
              };
              Repeat.prototype.slice = function (begin, end) {
                var size = this.size;
                return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
              };
              Repeat.prototype.reverse = function () {
                return this;
              };
              Repeat.prototype.indexOf = function (searchValue) {
                if (is(this._value, searchValue)) {
                  return 0;
                }
                return -1;
              };
              Repeat.prototype.lastIndexOf = function (searchValue) {
                if (is(this._value, searchValue)) {
                  return this.size;
                }
                return -1;
              };
              Repeat.prototype.__iterate = function (fn, reverse) {
                for (var ii = 0; ii < this.size; ii++) {
                  if (fn(this._value, ii, this) === false) {
                    return ii + 1;
                  }
                }
                return ii;
              };
              Repeat.prototype.__iterator = function (type, reverse) {
                var this$0 = this;
                var ii = 0;
                return new Iterator(function () {
                  return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone();
                });
              };
              Repeat.prototype.equals = function (other) {
                return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);
              };
              var EMPTY_REPEAT;
              function invariant(condition, error) {
                if (!condition) throw new Error(error);
              }
              createClass(Range, IndexedSeq);
              function Range(start, end, step) {
                if (!(this instanceof Range)) {
                  return new Range(start, end, step);
                }
                invariant(step !== 0, "Cannot step a Range by 0");
                start = start || 0;
                if (end === void 0) {
                  end = Infinity;
                }
                step = step === void 0 ? 1 : Math.abs(step);
                if (end < start) {
                  step = -step;
                }
                this._start = start;
                this._end = end;
                this._step = step;
                this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
                if (this.size === 0) {
                  if (EMPTY_RANGE) {
                    return EMPTY_RANGE;
                  }
                  EMPTY_RANGE = this;
                }
              }
              Range.prototype.toString = function () {
                if (this.size === 0) {
                  return "Range []";
                }
                return "Range [ " + this._start + "..." + this._end + (this._step > 1 ? " by " + this._step : "") + " ]";
              };
              Range.prototype.get = function (index, notSetValue) {
                return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
              };
              Range.prototype.includes = function (searchValue) {
                var possibleIndex = (searchValue - this._start) / this._step;
                return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
              };
              Range.prototype.slice = function (begin, end) {
                if (wholeSlice(begin, end, this.size)) {
                  return this;
                }
                begin = resolveBegin(begin, this.size);
                end = resolveEnd(end, this.size);
                if (end <= begin) {
                  return new Range(0, 0);
                }
                return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
              };
              Range.prototype.indexOf = function (searchValue) {
                var offsetValue = searchValue - this._start;
                if (offsetValue % this._step === 0) {
                  var index = offsetValue / this._step;
                  if (index >= 0 && index < this.size) {
                    return index;
                  }
                }
                return -1;
              };
              Range.prototype.lastIndexOf = function (searchValue) {
                return this.indexOf(searchValue);
              };
              Range.prototype.__iterate = function (fn, reverse) {
                var maxIndex = this.size - 1;
                var step = this._step;
                var value = reverse ? this._start + maxIndex * step : this._start;
                for (var ii = 0; ii <= maxIndex; ii++) {
                  if (fn(value, ii, this) === false) {
                    return ii + 1;
                  }
                  value += reverse ? -step : step;
                }
                return ii;
              };
              Range.prototype.__iterator = function (type, reverse) {
                var maxIndex = this.size - 1;
                var step = this._step;
                var value = reverse ? this._start + maxIndex * step : this._start;
                var ii = 0;
                return new Iterator(function () {
                  var v = value;
                  value += reverse ? -step : step;
                  return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
                });
              };
              Range.prototype.equals = function (other) {
                return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
              };
              var EMPTY_RANGE;
              createClass(Collection, Iterable);
              function Collection() {
                throw TypeError("Abstract");
              }
              createClass(KeyedCollection, Collection);
              function KeyedCollection() {}
              createClass(IndexedCollection, Collection);
              function IndexedCollection() {}
              createClass(SetCollection, Collection);
              function SetCollection() {}
              Collection.Keyed = KeyedCollection;
              Collection.Indexed = IndexedCollection;
              Collection.Set = SetCollection;
              var imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul2(a, b) {
                a = a | 0;
                b = b | 0;
                var c = a & 65535;
                var d = b & 65535;
                return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0;
              };
              function smi(i32) {
                return i32 >>> 1 & 1073741824 | i32 & 3221225471;
              }
              function hash(o) {
                if (o === false || o === null || o === void 0) {
                  return 0;
                }
                if (typeof o.valueOf === "function") {
                  o = o.valueOf();
                  if (o === false || o === null || o === void 0) {
                    return 0;
                  }
                }
                if (o === true) {
                  return 1;
                }
                var type = typeof o;
                if (type === "number") {
                  var h = o | 0;
                  if (h !== o) {
                    h ^= o * 4294967295;
                  }
                  while (o > 4294967295) {
                    o /= 4294967295;
                    h ^= o;
                  }
                  return smi(h);
                }
                if (type === "string") {
                  return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
                }
                if (typeof o.hashCode === "function") {
                  return o.hashCode();
                }
                if (type === "object") {
                  return hashJSObj(o);
                }
                if (typeof o.toString === "function") {
                  return hashString(o.toString());
                }
                throw new Error("Value type " + type + " cannot be hashed.");
              }
              function cachedHashString(string) {
                var hash2 = stringHashCache[string];
                if (hash2 === void 0) {
                  hash2 = hashString(string);
                  if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
                    STRING_HASH_CACHE_SIZE = 0;
                    stringHashCache = {};
                  }
                  STRING_HASH_CACHE_SIZE++;
                  stringHashCache[string] = hash2;
                }
                return hash2;
              }
              function hashString(string) {
                var hash2 = 0;
                for (var ii = 0; ii < string.length; ii++) {
                  hash2 = 31 * hash2 + string.charCodeAt(ii) | 0;
                }
                return smi(hash2);
              }
              function hashJSObj(obj) {
                var hash2;
                if (usingWeakMap) {
                  hash2 = weakMap.get(obj);
                  if (hash2 !== void 0) {
                    return hash2;
                  }
                }
                hash2 = obj[UID_HASH_KEY];
                if (hash2 !== void 0) {
                  return hash2;
                }
                if (!canDefineProperty) {
                  hash2 = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
                  if (hash2 !== void 0) {
                    return hash2;
                  }
                  hash2 = getIENodeHash(obj);
                  if (hash2 !== void 0) {
                    return hash2;
                  }
                }
                hash2 = ++objHashUID;
                if (objHashUID & 1073741824) {
                  objHashUID = 0;
                }
                if (usingWeakMap) {
                  weakMap.set(obj, hash2);
                } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
                  throw new Error("Non-extensible objects are not allowed as keys.");
                } else if (canDefineProperty) {
                  Object.defineProperty(obj, UID_HASH_KEY, {
                    "enumerable": false,
                    "configurable": false,
                    "writable": false,
                    "value": hash2
                  });
                } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
                  obj.propertyIsEnumerable = function () {
                    return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
                  };
                  obj.propertyIsEnumerable[UID_HASH_KEY] = hash2;
                } else if (obj.nodeType !== void 0) {
                  obj[UID_HASH_KEY] = hash2;
                } else {
                  throw new Error("Unable to set a non-enumerable property on object.");
                }
                return hash2;
              }
              var isExtensible = Object.isExtensible;
              var canDefineProperty = function () {
                try {
                  Object.defineProperty({}, "@", {});
                  return true;
                } catch (e) {
                  return false;
                }
              }();
              function getIENodeHash(node) {
                if (node && node.nodeType > 0) {
                  switch (node.nodeType) {
                    case 1:
                      return node.uniqueID;
                    case 9:
                      return node.documentElement && node.documentElement.uniqueID;
                  }
                }
              }
              var usingWeakMap = typeof WeakMap === "function";
              var weakMap;
              if (usingWeakMap) {
                weakMap = /* @__PURE__ */new WeakMap();
              }
              var objHashUID = 0;
              var UID_HASH_KEY = "__immutablehash__";
              if (typeof Symbol === "function") {
                UID_HASH_KEY = Symbol(UID_HASH_KEY);
              }
              var STRING_HASH_CACHE_MIN_STRLEN = 16;
              var STRING_HASH_CACHE_MAX_SIZE = 255;
              var STRING_HASH_CACHE_SIZE = 0;
              var stringHashCache = {};
              function assertNotInfinite(size) {
                invariant(size !== Infinity, "Cannot perform this action with an infinite size.");
              }
              createClass(Map, KeyedCollection);
              function Map(value) {
                return value === null || value === void 0 ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {
                  var iter = KeyedIterable(value);
                  assertNotInfinite(iter.size);
                  iter.forEach(function (v, k) {
                    return map.set(k, v);
                  });
                });
              }
              Map.prototype.toString = function () {
                return this.__toString("Map {", "}");
              };
              Map.prototype.get = function (k, notSetValue) {
                return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
              };
              Map.prototype.set = function (k, v) {
                return updateMap(this, k, v);
              };
              Map.prototype.setIn = function (keyPath, v) {
                return this.updateIn(keyPath, NOT_SET, function () {
                  return v;
                });
              };
              Map.prototype.remove = function (k) {
                return updateMap(this, k, NOT_SET);
              };
              Map.prototype.deleteIn = function (keyPath) {
                return this.updateIn(keyPath, function () {
                  return NOT_SET;
                });
              };
              Map.prototype.update = function (k, notSetValue, updater) {
                return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
              };
              Map.prototype.updateIn = function (keyPath, notSetValue, updater) {
                if (!updater) {
                  updater = notSetValue;
                  notSetValue = void 0;
                }
                var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);
                return updatedValue === NOT_SET ? void 0 : updatedValue;
              };
              Map.prototype.clear = function () {
                if (this.size === 0) {
                  return this;
                }
                if (this.__ownerID) {
                  this.size = 0;
                  this._root = null;
                  this.__hash = void 0;
                  this.__altered = true;
                  return this;
                }
                return emptyMap();
              };
              Map.prototype.merge = function () {
                return mergeIntoMapWith(this, void 0, arguments);
              };
              Map.prototype.mergeWith = function (merger) {
                var iters = SLICE$0.call(arguments, 1);
                return mergeIntoMapWith(this, merger, iters);
              };
              Map.prototype.mergeIn = function (keyPath) {
                var iters = SLICE$0.call(arguments, 1);
                return this.updateIn(keyPath, emptyMap(), function (m) {
                  return typeof m.merge === "function" ? m.merge.apply(m, iters) : iters[iters.length - 1];
                });
              };
              Map.prototype.mergeDeep = function () {
                return mergeIntoMapWith(this, deepMerger, arguments);
              };
              Map.prototype.mergeDeepWith = function (merger) {
                var iters = SLICE$0.call(arguments, 1);
                return mergeIntoMapWith(this, deepMergerWith(merger), iters);
              };
              Map.prototype.mergeDeepIn = function (keyPath) {
                var iters = SLICE$0.call(arguments, 1);
                return this.updateIn(keyPath, emptyMap(), function (m) {
                  return typeof m.mergeDeep === "function" ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];
                });
              };
              Map.prototype.sort = function (comparator) {
                return OrderedMap(sortFactory(this, comparator));
              };
              Map.prototype.sortBy = function (mapper, comparator) {
                return OrderedMap(sortFactory(this, comparator, mapper));
              };
              Map.prototype.withMutations = function (fn) {
                var mutable = this.asMutable();
                fn(mutable);
                return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
              };
              Map.prototype.asMutable = function () {
                return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
              };
              Map.prototype.asImmutable = function () {
                return this.__ensureOwner();
              };
              Map.prototype.wasAltered = function () {
                return this.__altered;
              };
              Map.prototype.__iterator = function (type, reverse) {
                return new MapIterator(this, type, reverse);
              };
              Map.prototype.__iterate = function (fn, reverse) {
                var this$0 = this;
                var iterations = 0;
                this._root && this._root.iterate(function (entry) {
                  iterations++;
                  return fn(entry[1], entry[0], this$0);
                }, reverse);
                return iterations;
              };
              Map.prototype.__ensureOwner = function (ownerID) {
                if (ownerID === this.__ownerID) {
                  return this;
                }
                if (!ownerID) {
                  this.__ownerID = ownerID;
                  this.__altered = false;
                  return this;
                }
                return makeMap(this.size, this._root, ownerID, this.__hash);
              };
              function isMap(maybeMap) {
                return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
              }
              Map.isMap = isMap;
              var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
              var MapPrototype = Map.prototype;
              MapPrototype[IS_MAP_SENTINEL] = true;
              MapPrototype[DELETE] = MapPrototype.remove;
              MapPrototype.removeIn = MapPrototype.deleteIn;
              function ArrayMapNode(ownerID, entries) {
                this.ownerID = ownerID;
                this.entries = entries;
              }
              ArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
                var entries = this.entries;
                for (var ii = 0, len = entries.length; ii < len; ii++) {
                  if (is(key, entries[ii][0])) {
                    return entries[ii][1];
                  }
                }
                return notSetValue;
              };
              ArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
                var removed = value === NOT_SET;
                var entries = this.entries;
                var idx = 0;
                for (var len = entries.length; idx < len; idx++) {
                  if (is(key, entries[idx][0])) {
                    break;
                  }
                }
                var exists = idx < len;
                if (exists ? entries[idx][1] === value : removed) {
                  return this;
                }
                SetRef(didAlter);
                (removed || !exists) && SetRef(didChangeSize);
                if (removed && entries.length === 1) {
                  return;
                }
                if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
                  return createNodes(ownerID, entries, key, value);
                }
                var isEditable = ownerID && ownerID === this.ownerID;
                var newEntries = isEditable ? entries : arrCopy(entries);
                if (exists) {
                  if (removed) {
                    idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
                  } else {
                    newEntries[idx] = [key, value];
                  }
                } else {
                  newEntries.push([key, value]);
                }
                if (isEditable) {
                  this.entries = newEntries;
                  return this;
                }
                return new ArrayMapNode(ownerID, newEntries);
              };
              function BitmapIndexedNode(ownerID, bitmap, nodes) {
                this.ownerID = ownerID;
                this.bitmap = bitmap;
                this.nodes = nodes;
              }
              BitmapIndexedNode.prototype.get = function (shift, keyHash, key, notSetValue) {
                if (keyHash === void 0) {
                  keyHash = hash(key);
                }
                var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
                var bitmap = this.bitmap;
                return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
              };
              BitmapIndexedNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
                if (keyHash === void 0) {
                  keyHash = hash(key);
                }
                var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
                var bit = 1 << keyHashFrag;
                var bitmap = this.bitmap;
                var exists = (bitmap & bit) !== 0;
                if (!exists && value === NOT_SET) {
                  return this;
                }
                var idx = popCount(bitmap & bit - 1);
                var nodes = this.nodes;
                var node = exists ? nodes[idx] : void 0;
                var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
                if (newNode === node) {
                  return this;
                }
                if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
                  return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
                }
                if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
                  return nodes[idx ^ 1];
                }
                if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
                  return newNode;
                }
                var isEditable = ownerID && ownerID === this.ownerID;
                var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
                var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
                if (isEditable) {
                  this.bitmap = newBitmap;
                  this.nodes = newNodes;
                  return this;
                }
                return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
              };
              function HashArrayMapNode(ownerID, count, nodes) {
                this.ownerID = ownerID;
                this.count = count;
                this.nodes = nodes;
              }
              HashArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
                if (keyHash === void 0) {
                  keyHash = hash(key);
                }
                var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
                var node = this.nodes[idx];
                return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
              };
              HashArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
                if (keyHash === void 0) {
                  keyHash = hash(key);
                }
                var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
                var removed = value === NOT_SET;
                var nodes = this.nodes;
                var node = nodes[idx];
                if (removed && !node) {
                  return this;
                }
                var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
                if (newNode === node) {
                  return this;
                }
                var newCount = this.count;
                if (!node) {
                  newCount++;
                } else if (!newNode) {
                  newCount--;
                  if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
                    return packNodes(ownerID, nodes, newCount, idx);
                  }
                }
                var isEditable = ownerID && ownerID === this.ownerID;
                var newNodes = setIn(nodes, idx, newNode, isEditable);
                if (isEditable) {
                  this.count = newCount;
                  this.nodes = newNodes;
                  return this;
                }
                return new HashArrayMapNode(ownerID, newCount, newNodes);
              };
              function HashCollisionNode(ownerID, keyHash, entries) {
                this.ownerID = ownerID;
                this.keyHash = keyHash;
                this.entries = entries;
              }
              HashCollisionNode.prototype.get = function (shift, keyHash, key, notSetValue) {
                var entries = this.entries;
                for (var ii = 0, len = entries.length; ii < len; ii++) {
                  if (is(key, entries[ii][0])) {
                    return entries[ii][1];
                  }
                }
                return notSetValue;
              };
              HashCollisionNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
                if (keyHash === void 0) {
                  keyHash = hash(key);
                }
                var removed = value === NOT_SET;
                if (keyHash !== this.keyHash) {
                  if (removed) {
                    return this;
                  }
                  SetRef(didAlter);
                  SetRef(didChangeSize);
                  return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
                }
                var entries = this.entries;
                var idx = 0;
                for (var len = entries.length; idx < len; idx++) {
                  if (is(key, entries[idx][0])) {
                    break;
                  }
                }
                var exists = idx < len;
                if (exists ? entries[idx][1] === value : removed) {
                  return this;
                }
                SetRef(didAlter);
                (removed || !exists) && SetRef(didChangeSize);
                if (removed && len === 2) {
                  return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
                }
                var isEditable = ownerID && ownerID === this.ownerID;
                var newEntries = isEditable ? entries : arrCopy(entries);
                if (exists) {
                  if (removed) {
                    idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
                  } else {
                    newEntries[idx] = [key, value];
                  }
                } else {
                  newEntries.push([key, value]);
                }
                if (isEditable) {
                  this.entries = newEntries;
                  return this;
                }
                return new HashCollisionNode(ownerID, this.keyHash, newEntries);
              };
              function ValueNode(ownerID, keyHash, entry) {
                this.ownerID = ownerID;
                this.keyHash = keyHash;
                this.entry = entry;
              }
              ValueNode.prototype.get = function (shift, keyHash, key, notSetValue) {
                return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
              };
              ValueNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
                var removed = value === NOT_SET;
                var keyMatch = is(key, this.entry[0]);
                if (keyMatch ? value === this.entry[1] : removed) {
                  return this;
                }
                SetRef(didAlter);
                if (removed) {
                  SetRef(didChangeSize);
                  return;
                }
                if (keyMatch) {
                  if (ownerID && ownerID === this.ownerID) {
                    this.entry[1] = value;
                    return this;
                  }
                  return new ValueNode(ownerID, this.keyHash, [key, value]);
                }
                SetRef(didChangeSize);
                return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
              };
              ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
                var entries = this.entries;
                for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
                  if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
                    return false;
                  }
                }
              };
              BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
                var nodes = this.nodes;
                for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
                  var node = nodes[reverse ? maxIndex - ii : ii];
                  if (node && node.iterate(fn, reverse) === false) {
                    return false;
                  }
                }
              };
              ValueNode.prototype.iterate = function (fn, reverse) {
                return fn(this.entry);
              };
              createClass(MapIterator, Iterator);
              function MapIterator(map, type, reverse) {
                this._type = type;
                this._reverse = reverse;
                this._stack = map._root && mapIteratorFrame(map._root);
              }
              MapIterator.prototype.next = function () {
                var type = this._type;
                var stack = this._stack;
                while (stack) {
                  var node = stack.node;
                  var index = stack.index++;
                  var maxIndex;
                  if (node.entry) {
                    if (index === 0) {
                      return mapIteratorValue(type, node.entry);
                    }
                  } else if (node.entries) {
                    maxIndex = node.entries.length - 1;
                    if (index <= maxIndex) {
                      return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
                    }
                  } else {
                    maxIndex = node.nodes.length - 1;
                    if (index <= maxIndex) {
                      var subNode = node.nodes[this._reverse ? maxIndex - index : index];
                      if (subNode) {
                        if (subNode.entry) {
                          return mapIteratorValue(type, subNode.entry);
                        }
                        stack = this._stack = mapIteratorFrame(subNode, stack);
                      }
                      continue;
                    }
                  }
                  stack = this._stack = this._stack.__prev;
                }
                return iteratorDone();
              };
              function mapIteratorValue(type, entry) {
                return iteratorValue(type, entry[0], entry[1]);
              }
              function mapIteratorFrame(node, prev) {
                return {
                  node,
                  index: 0,
                  __prev: prev
                };
              }
              function makeMap(size, root, ownerID, hash2) {
                var map = Object.create(MapPrototype);
                map.size = size;
                map._root = root;
                map.__ownerID = ownerID;
                map.__hash = hash2;
                map.__altered = false;
                return map;
              }
              var EMPTY_MAP;
              function emptyMap() {
                return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
              }
              function updateMap(map, k, v) {
                var newRoot;
                var newSize;
                if (!map._root) {
                  if (v === NOT_SET) {
                    return map;
                  }
                  newSize = 1;
                  newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
                } else {
                  var didChangeSize = MakeRef(CHANGE_LENGTH);
                  var didAlter = MakeRef(DID_ALTER);
                  newRoot = updateNode(map._root, map.__ownerID, 0, void 0, k, v, didChangeSize, didAlter);
                  if (!didAlter.value) {
                    return map;
                  }
                  newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
                }
                if (map.__ownerID) {
                  map.size = newSize;
                  map._root = newRoot;
                  map.__hash = void 0;
                  map.__altered = true;
                  return map;
                }
                return newRoot ? makeMap(newSize, newRoot) : emptyMap();
              }
              function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
                if (!node) {
                  if (value === NOT_SET) {
                    return node;
                  }
                  SetRef(didAlter);
                  SetRef(didChangeSize);
                  return new ValueNode(ownerID, keyHash, [key, value]);
                }
                return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
              }
              function isLeafNode(node) {
                return node.constructor === ValueNode || node.constructor === HashCollisionNode;
              }
              function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
                if (node.keyHash === keyHash) {
                  return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
                }
                var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
                var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
                var newNode;
                var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
                return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
              }
              function createNodes(ownerID, entries, key, value) {
                if (!ownerID) {
                  ownerID = new OwnerID();
                }
                var node = new ValueNode(ownerID, hash(key), [key, value]);
                for (var ii = 0; ii < entries.length; ii++) {
                  var entry = entries[ii];
                  node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
                }
                return node;
              }
              function packNodes(ownerID, nodes, count, excluding) {
                var bitmap = 0;
                var packedII = 0;
                var packedNodes = new Array(count);
                for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
                  var node = nodes[ii];
                  if (node !== void 0 && ii !== excluding) {
                    bitmap |= bit;
                    packedNodes[packedII++] = node;
                  }
                }
                return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
              }
              function expandNodes(ownerID, nodes, bitmap, including, node) {
                var count = 0;
                var expandedNodes = new Array(SIZE);
                for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
                  expandedNodes[ii] = bitmap & 1 ? nodes[count++] : void 0;
                }
                expandedNodes[including] = node;
                return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
              }
              function mergeIntoMapWith(map, merger, iterables) {
                var iters = [];
                for (var ii = 0; ii < iterables.length; ii++) {
                  var value = iterables[ii];
                  var iter = KeyedIterable(value);
                  if (!isIterable(value)) {
                    iter = iter.map(function (v) {
                      return fromJS(v);
                    });
                  }
                  iters.push(iter);
                }
                return mergeIntoCollectionWith(map, merger, iters);
              }
              function deepMerger(existing, value, key) {
                return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is(existing, value) ? existing : value;
              }
              function deepMergerWith(merger) {
                return function (existing, value, key) {
                  if (existing && existing.mergeDeepWith && isIterable(value)) {
                    return existing.mergeDeepWith(merger, value);
                  }
                  var nextValue = merger(existing, value, key);
                  return is(existing, nextValue) ? existing : nextValue;
                };
              }
              function mergeIntoCollectionWith(collection, merger, iters) {
                iters = iters.filter(function (x) {
                  return x.size !== 0;
                });
                if (iters.length === 0) {
                  return collection;
                }
                if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
                  return collection.constructor(iters[0]);
                }
                return collection.withMutations(function (collection2) {
                  var mergeIntoMap = merger ? function (value, key) {
                    collection2.update(key, NOT_SET, function (existing) {
                      return existing === NOT_SET ? value : merger(existing, value, key);
                    });
                  } : function (value, key) {
                    collection2.set(key, value);
                  };
                  for (var ii = 0; ii < iters.length; ii++) {
                    iters[ii].forEach(mergeIntoMap);
                  }
                });
              }
              function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
                var isNotSet = existing === NOT_SET;
                var step = keyPathIter.next();
                if (step.done) {
                  var existingValue = isNotSet ? notSetValue : existing;
                  var newValue = updater(existingValue);
                  return newValue === existingValue ? existing : newValue;
                }
                invariant(isNotSet || existing && existing.set, "invalid keyPath");
                var key = step.value;
                var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
                var nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);
                return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
              }
              function popCount(x) {
                x = x - (x >> 1 & 1431655765);
                x = (x & 858993459) + (x >> 2 & 858993459);
                x = x + (x >> 4) & 252645135;
                x = x + (x >> 8);
                x = x + (x >> 16);
                return x & 127;
              }
              function setIn(array, idx, val, canEdit) {
                var newArray = canEdit ? array : arrCopy(array);
                newArray[idx] = val;
                return newArray;
              }
              function spliceIn(array, idx, val, canEdit) {
                var newLen = array.length + 1;
                if (canEdit && idx + 1 === newLen) {
                  array[idx] = val;
                  return array;
                }
                var newArray = new Array(newLen);
                var after = 0;
                for (var ii = 0; ii < newLen; ii++) {
                  if (ii === idx) {
                    newArray[ii] = val;
                    after = -1;
                  } else {
                    newArray[ii] = array[ii + after];
                  }
                }
                return newArray;
              }
              function spliceOut(array, idx, canEdit) {
                var newLen = array.length - 1;
                if (canEdit && idx === newLen) {
                  array.pop();
                  return array;
                }
                var newArray = new Array(newLen);
                var after = 0;
                for (var ii = 0; ii < newLen; ii++) {
                  if (ii === idx) {
                    after = 1;
                  }
                  newArray[ii] = array[ii + after];
                }
                return newArray;
              }
              var MAX_ARRAY_MAP_SIZE = SIZE / 4;
              var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
              var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
              createClass(List, IndexedCollection);
              function List(value) {
                var empty = emptyList();
                if (value === null || value === void 0) {
                  return empty;
                }
                if (isList(value)) {
                  return value;
                }
                var iter = IndexedIterable(value);
                var size = iter.size;
                if (size === 0) {
                  return empty;
                }
                assertNotInfinite(size);
                if (size > 0 && size < SIZE) {
                  return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
                }
                return empty.withMutations(function (list) {
                  list.setSize(size);
                  iter.forEach(function (v, i) {
                    return list.set(i, v);
                  });
                });
              }
              List.of = function () {
                return this(arguments);
              };
              List.prototype.toString = function () {
                return this.__toString("List [", "]");
              };
              List.prototype.get = function (index, notSetValue) {
                index = wrapIndex(this, index);
                if (index >= 0 && index < this.size) {
                  index += this._origin;
                  var node = listNodeFor(this, index);
                  return node && node.array[index & MASK];
                }
                return notSetValue;
              };
              List.prototype.set = function (index, value) {
                return updateList(this, index, value);
              };
              List.prototype.remove = function (index) {
                return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
              };
              List.prototype.insert = function (index, value) {
                return this.splice(index, 0, value);
              };
              List.prototype.clear = function () {
                if (this.size === 0) {
                  return this;
                }
                if (this.__ownerID) {
                  this.size = this._origin = this._capacity = 0;
                  this._level = SHIFT;
                  this._root = this._tail = null;
                  this.__hash = void 0;
                  this.__altered = true;
                  return this;
                }
                return emptyList();
              };
              List.prototype.push = function () {
                var values = arguments;
                var oldSize = this.size;
                return this.withMutations(function (list) {
                  setListBounds(list, 0, oldSize + values.length);
                  for (var ii = 0; ii < values.length; ii++) {
                    list.set(oldSize + ii, values[ii]);
                  }
                });
              };
              List.prototype.pop = function () {
                return setListBounds(this, 0, -1);
              };
              List.prototype.unshift = function () {
                var values = arguments;
                return this.withMutations(function (list) {
                  setListBounds(list, -values.length);
                  for (var ii = 0; ii < values.length; ii++) {
                    list.set(ii, values[ii]);
                  }
                });
              };
              List.prototype.shift = function () {
                return setListBounds(this, 1);
              };
              List.prototype.merge = function () {
                return mergeIntoListWith(this, void 0, arguments);
              };
              List.prototype.mergeWith = function (merger) {
                var iters = SLICE$0.call(arguments, 1);
                return mergeIntoListWith(this, merger, iters);
              };
              List.prototype.mergeDeep = function () {
                return mergeIntoListWith(this, deepMerger, arguments);
              };
              List.prototype.mergeDeepWith = function (merger) {
                var iters = SLICE$0.call(arguments, 1);
                return mergeIntoListWith(this, deepMergerWith(merger), iters);
              };
              List.prototype.setSize = function (size) {
                return setListBounds(this, 0, size);
              };
              List.prototype.slice = function (begin, end) {
                var size = this.size;
                if (wholeSlice(begin, end, size)) {
                  return this;
                }
                return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
              };
              List.prototype.__iterator = function (type, reverse) {
                var index = 0;
                var values = iterateList(this, reverse);
                return new Iterator(function () {
                  var value = values();
                  return value === DONE ? iteratorDone() : iteratorValue(type, index++, value);
                });
              };
              List.prototype.__iterate = function (fn, reverse) {
                var index = 0;
                var values = iterateList(this, reverse);
                var value;
                while ((value = values()) !== DONE) {
                  if (fn(value, index++, this) === false) {
                    break;
                  }
                }
                return index;
              };
              List.prototype.__ensureOwner = function (ownerID) {
                if (ownerID === this.__ownerID) {
                  return this;
                }
                if (!ownerID) {
                  this.__ownerID = ownerID;
                  return this;
                }
                return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
              };
              function isList(maybeList) {
                return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
              }
              List.isList = isList;
              var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
              var ListPrototype = List.prototype;
              ListPrototype[IS_LIST_SENTINEL] = true;
              ListPrototype[DELETE] = ListPrototype.remove;
              ListPrototype.setIn = MapPrototype.setIn;
              ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
              ListPrototype.update = MapPrototype.update;
              ListPrototype.updateIn = MapPrototype.updateIn;
              ListPrototype.mergeIn = MapPrototype.mergeIn;
              ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
              ListPrototype.withMutations = MapPrototype.withMutations;
              ListPrototype.asMutable = MapPrototype.asMutable;
              ListPrototype.asImmutable = MapPrototype.asImmutable;
              ListPrototype.wasAltered = MapPrototype.wasAltered;
              function VNode(array, ownerID) {
                this.array = array;
                this.ownerID = ownerID;
              }
              VNode.prototype.removeBefore = function (ownerID, level, index) {
                if (index === level ? 1 << level : this.array.length === 0) {
                  return this;
                }
                var originIndex = index >>> level & MASK;
                if (originIndex >= this.array.length) {
                  return new VNode([], ownerID);
                }
                var removingFirst = originIndex === 0;
                var newChild;
                if (level > 0) {
                  var oldChild = this.array[originIndex];
                  newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
                  if (newChild === oldChild && removingFirst) {
                    return this;
                  }
                }
                if (removingFirst && !newChild) {
                  return this;
                }
                var editable = editableVNode(this, ownerID);
                if (!removingFirst) {
                  for (var ii = 0; ii < originIndex; ii++) {
                    editable.array[ii] = void 0;
                  }
                }
                if (newChild) {
                  editable.array[originIndex] = newChild;
                }
                return editable;
              };
              VNode.prototype.removeAfter = function (ownerID, level, index) {
                if (index === (level ? 1 << level : 0) || this.array.length === 0) {
                  return this;
                }
                var sizeIndex = index - 1 >>> level & MASK;
                if (sizeIndex >= this.array.length) {
                  return this;
                }
                var newChild;
                if (level > 0) {
                  var oldChild = this.array[sizeIndex];
                  newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
                  if (newChild === oldChild && sizeIndex === this.array.length - 1) {
                    return this;
                  }
                }
                var editable = editableVNode(this, ownerID);
                editable.array.splice(sizeIndex + 1);
                if (newChild) {
                  editable.array[sizeIndex] = newChild;
                }
                return editable;
              };
              var DONE = {};
              function iterateList(list, reverse) {
                var left = list._origin;
                var right = list._capacity;
                var tailPos = getTailOffset(right);
                var tail = list._tail;
                return iterateNodeOrLeaf(list._root, list._level, 0);
                function iterateNodeOrLeaf(node, level, offset) {
                  return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
                }
                function iterateLeaf(node, offset) {
                  var array = offset === tailPos ? tail && tail.array : node && node.array;
                  var from = offset > left ? 0 : left - offset;
                  var to = right - offset;
                  if (to > SIZE) {
                    to = SIZE;
                  }
                  return function () {
                    if (from === to) {
                      return DONE;
                    }
                    var idx = reverse ? --to : from++;
                    return array && array[idx];
                  };
                }
                function iterateNode(node, level, offset) {
                  var values;
                  var array = node && node.array;
                  var from = offset > left ? 0 : left - offset >> level;
                  var to = (right - offset >> level) + 1;
                  if (to > SIZE) {
                    to = SIZE;
                  }
                  return function () {
                    do {
                      if (values) {
                        var value = values();
                        if (value !== DONE) {
                          return value;
                        }
                        values = null;
                      }
                      if (from === to) {
                        return DONE;
                      }
                      var idx = reverse ? --to : from++;
                      values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
                    } while (true);
                  };
                }
              }
              function makeList(origin, capacity, level, root, tail, ownerID, hash2) {
                var list = Object.create(ListPrototype);
                list.size = capacity - origin;
                list._origin = origin;
                list._capacity = capacity;
                list._level = level;
                list._root = root;
                list._tail = tail;
                list.__ownerID = ownerID;
                list.__hash = hash2;
                list.__altered = false;
                return list;
              }
              var EMPTY_LIST;
              function emptyList() {
                return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
              }
              function updateList(list, index, value) {
                index = wrapIndex(list, index);
                if (index !== index) {
                  return list;
                }
                if (index >= list.size || index < 0) {
                  return list.withMutations(function (list2) {
                    index < 0 ? setListBounds(list2, index).set(0, value) : setListBounds(list2, 0, index + 1).set(index, value);
                  });
                }
                index += list._origin;
                var newTail = list._tail;
                var newRoot = list._root;
                var didAlter = MakeRef(DID_ALTER);
                if (index >= getTailOffset(list._capacity)) {
                  newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
                } else {
                  newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
                }
                if (!didAlter.value) {
                  return list;
                }
                if (list.__ownerID) {
                  list._root = newRoot;
                  list._tail = newTail;
                  list.__hash = void 0;
                  list.__altered = true;
                  return list;
                }
                return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
              }
              function updateVNode(node, ownerID, level, index, value, didAlter) {
                var idx = index >>> level & MASK;
                var nodeHas = node && idx < node.array.length;
                if (!nodeHas && value === void 0) {
                  return node;
                }
                var newNode;
                if (level > 0) {
                  var lowerNode = node && node.array[idx];
                  var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
                  if (newLowerNode === lowerNode) {
                    return node;
                  }
                  newNode = editableVNode(node, ownerID);
                  newNode.array[idx] = newLowerNode;
                  return newNode;
                }
                if (nodeHas && node.array[idx] === value) {
                  return node;
                }
                SetRef(didAlter);
                newNode = editableVNode(node, ownerID);
                if (value === void 0 && idx === newNode.array.length - 1) {
                  newNode.array.pop();
                } else {
                  newNode.array[idx] = value;
                }
                return newNode;
              }
              function editableVNode(node, ownerID) {
                if (ownerID && node && ownerID === node.ownerID) {
                  return node;
                }
                return new VNode(node ? node.array.slice() : [], ownerID);
              }
              function listNodeFor(list, rawIndex) {
                if (rawIndex >= getTailOffset(list._capacity)) {
                  return list._tail;
                }
                if (rawIndex < 1 << list._level + SHIFT) {
                  var node = list._root;
                  var level = list._level;
                  while (node && level > 0) {
                    node = node.array[rawIndex >>> level & MASK];
                    level -= SHIFT;
                  }
                  return node;
                }
              }
              function setListBounds(list, begin, end) {
                if (begin !== void 0) {
                  begin = begin | 0;
                }
                if (end !== void 0) {
                  end = end | 0;
                }
                var owner = list.__ownerID || new OwnerID();
                var oldOrigin = list._origin;
                var oldCapacity = list._capacity;
                var newOrigin = oldOrigin + begin;
                var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
                if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
                  return list;
                }
                if (newOrigin >= newCapacity) {
                  return list.clear();
                }
                var newLevel = list._level;
                var newRoot = list._root;
                var offsetShift = 0;
                while (newOrigin + offsetShift < 0) {
                  newRoot = new VNode(newRoot && newRoot.array.length ? [void 0, newRoot] : [], owner);
                  newLevel += SHIFT;
                  offsetShift += 1 << newLevel;
                }
                if (offsetShift) {
                  newOrigin += offsetShift;
                  oldOrigin += offsetShift;
                  newCapacity += offsetShift;
                  oldCapacity += offsetShift;
                }
                var oldTailOffset = getTailOffset(oldCapacity);
                var newTailOffset = getTailOffset(newCapacity);
                while (newTailOffset >= 1 << newLevel + SHIFT) {
                  newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
                  newLevel += SHIFT;
                }
                var oldTail = list._tail;
                var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
                if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
                  newRoot = editableVNode(newRoot, owner);
                  var node = newRoot;
                  for (var level = newLevel; level > SHIFT; level -= SHIFT) {
                    var idx = oldTailOffset >>> level & MASK;
                    node = node.array[idx] = editableVNode(node.array[idx], owner);
                  }
                  node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
                }
                if (newCapacity < oldCapacity) {
                  newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
                }
                if (newOrigin >= newTailOffset) {
                  newOrigin -= newTailOffset;
                  newCapacity -= newTailOffset;
                  newLevel = SHIFT;
                  newRoot = null;
                  newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
                } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
                  offsetShift = 0;
                  while (newRoot) {
                    var beginIndex = newOrigin >>> newLevel & MASK;
                    if (beginIndex !== newTailOffset >>> newLevel & MASK) {
                      break;
                    }
                    if (beginIndex) {
                      offsetShift += (1 << newLevel) * beginIndex;
                    }
                    newLevel -= SHIFT;
                    newRoot = newRoot.array[beginIndex];
                  }
                  if (newRoot && newOrigin > oldOrigin) {
                    newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
                  }
                  if (newRoot && newTailOffset < oldTailOffset) {
                    newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
                  }
                  if (offsetShift) {
                    newOrigin -= offsetShift;
                    newCapacity -= offsetShift;
                  }
                }
                if (list.__ownerID) {
                  list.size = newCapacity - newOrigin;
                  list._origin = newOrigin;
                  list._capacity = newCapacity;
                  list._level = newLevel;
                  list._root = newRoot;
                  list._tail = newTail;
                  list.__hash = void 0;
                  list.__altered = true;
                  return list;
                }
                return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
              }
              function mergeIntoListWith(list, merger, iterables) {
                var iters = [];
                var maxSize = 0;
                for (var ii = 0; ii < iterables.length; ii++) {
                  var value = iterables[ii];
                  var iter = IndexedIterable(value);
                  if (iter.size > maxSize) {
                    maxSize = iter.size;
                  }
                  if (!isIterable(value)) {
                    iter = iter.map(function (v) {
                      return fromJS(v);
                    });
                  }
                  iters.push(iter);
                }
                if (maxSize > list.size) {
                  list = list.setSize(maxSize);
                }
                return mergeIntoCollectionWith(list, merger, iters);
              }
              function getTailOffset(size) {
                return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
              }
              createClass(OrderedMap, Map);
              function OrderedMap(value) {
                return value === null || value === void 0 ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
                  var iter = KeyedIterable(value);
                  assertNotInfinite(iter.size);
                  iter.forEach(function (v, k) {
                    return map.set(k, v);
                  });
                });
              }
              OrderedMap.of = function () {
                return this(arguments);
              };
              OrderedMap.prototype.toString = function () {
                return this.__toString("OrderedMap {", "}");
              };
              OrderedMap.prototype.get = function (k, notSetValue) {
                var index = this._map.get(k);
                return index !== void 0 ? this._list.get(index)[1] : notSetValue;
              };
              OrderedMap.prototype.clear = function () {
                if (this.size === 0) {
                  return this;
                }
                if (this.__ownerID) {
                  this.size = 0;
                  this._map.clear();
                  this._list.clear();
                  return this;
                }
                return emptyOrderedMap();
              };
              OrderedMap.prototype.set = function (k, v) {
                return updateOrderedMap(this, k, v);
              };
              OrderedMap.prototype.remove = function (k) {
                return updateOrderedMap(this, k, NOT_SET);
              };
              OrderedMap.prototype.wasAltered = function () {
                return this._map.wasAltered() || this._list.wasAltered();
              };
              OrderedMap.prototype.__iterate = function (fn, reverse) {
                var this$0 = this;
                return this._list.__iterate(function (entry) {
                  return entry && fn(entry[1], entry[0], this$0);
                }, reverse);
              };
              OrderedMap.prototype.__iterator = function (type, reverse) {
                return this._list.fromEntrySeq().__iterator(type, reverse);
              };
              OrderedMap.prototype.__ensureOwner = function (ownerID) {
                if (ownerID === this.__ownerID) {
                  return this;
                }
                var newMap = this._map.__ensureOwner(ownerID);
                var newList = this._list.__ensureOwner(ownerID);
                if (!ownerID) {
                  this.__ownerID = ownerID;
                  this._map = newMap;
                  this._list = newList;
                  return this;
                }
                return makeOrderedMap(newMap, newList, ownerID, this.__hash);
              };
              function isOrderedMap(maybeOrderedMap) {
                return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
              }
              OrderedMap.isOrderedMap = isOrderedMap;
              OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
              OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
              function makeOrderedMap(map, list, ownerID, hash2) {
                var omap = Object.create(OrderedMap.prototype);
                omap.size = map ? map.size : 0;
                omap._map = map;
                omap._list = list;
                omap.__ownerID = ownerID;
                omap.__hash = hash2;
                return omap;
              }
              var EMPTY_ORDERED_MAP;
              function emptyOrderedMap() {
                return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
              }
              function updateOrderedMap(omap, k, v) {
                var map = omap._map;
                var list = omap._list;
                var i = map.get(k);
                var has = i !== void 0;
                var newMap;
                var newList;
                if (v === NOT_SET) {
                  if (!has) {
                    return omap;
                  }
                  if (list.size >= SIZE && list.size >= map.size * 2) {
                    newList = list.filter(function (entry, idx) {
                      return entry !== void 0 && i !== idx;
                    });
                    newMap = newList.toKeyedSeq().map(function (entry) {
                      return entry[0];
                    }).flip().toMap();
                    if (omap.__ownerID) {
                      newMap.__ownerID = newList.__ownerID = omap.__ownerID;
                    }
                  } else {
                    newMap = map.remove(k);
                    newList = i === list.size - 1 ? list.pop() : list.set(i, void 0);
                  }
                } else {
                  if (has) {
                    if (v === list.get(i)[1]) {
                      return omap;
                    }
                    newMap = map;
                    newList = list.set(i, [k, v]);
                  } else {
                    newMap = map.set(k, list.size);
                    newList = list.set(list.size, [k, v]);
                  }
                }
                if (omap.__ownerID) {
                  omap.size = newMap.size;
                  omap._map = newMap;
                  omap._list = newList;
                  omap.__hash = void 0;
                  return omap;
                }
                return makeOrderedMap(newMap, newList);
              }
              createClass(ToKeyedSequence, KeyedSeq);
              function ToKeyedSequence(indexed, useKeys) {
                this._iter = indexed;
                this._useKeys = useKeys;
                this.size = indexed.size;
              }
              ToKeyedSequence.prototype.get = function (key, notSetValue) {
                return this._iter.get(key, notSetValue);
              };
              ToKeyedSequence.prototype.has = function (key) {
                return this._iter.has(key);
              };
              ToKeyedSequence.prototype.valueSeq = function () {
                return this._iter.valueSeq();
              };
              ToKeyedSequence.prototype.reverse = function () {
                var this$0 = this;
                var reversedSequence = reverseFactory(this, true);
                if (!this._useKeys) {
                  reversedSequence.valueSeq = function () {
                    return this$0._iter.toSeq().reverse();
                  };
                }
                return reversedSequence;
              };
              ToKeyedSequence.prototype.map = function (mapper, context) {
                var this$0 = this;
                var mappedSequence = mapFactory(this, mapper, context);
                if (!this._useKeys) {
                  mappedSequence.valueSeq = function () {
                    return this$0._iter.toSeq().map(mapper, context);
                  };
                }
                return mappedSequence;
              };
              ToKeyedSequence.prototype.__iterate = function (fn, reverse) {
                var this$0 = this;
                var ii;
                return this._iter.__iterate(this._useKeys ? function (v, k) {
                  return fn(v, k, this$0);
                } : (ii = reverse ? resolveSize(this) : 0, function (v) {
                  return fn(v, reverse ? --ii : ii++, this$0);
                }), reverse);
              };
              ToKeyedSequence.prototype.__iterator = function (type, reverse) {
                if (this._useKeys) {
                  return this._iter.__iterator(type, reverse);
                }
                var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
                var ii = reverse ? resolveSize(this) : 0;
                return new Iterator(function () {
                  var step = iterator.next();
                  return step.done ? step : iteratorValue(type, reverse ? --ii : ii++, step.value, step);
                });
              };
              ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
              createClass(ToIndexedSequence, IndexedSeq);
              function ToIndexedSequence(iter) {
                this._iter = iter;
                this.size = iter.size;
              }
              ToIndexedSequence.prototype.includes = function (value) {
                return this._iter.includes(value);
              };
              ToIndexedSequence.prototype.__iterate = function (fn, reverse) {
                var this$0 = this;
                var iterations = 0;
                return this._iter.__iterate(function (v) {
                  return fn(v, iterations++, this$0);
                }, reverse);
              };
              ToIndexedSequence.prototype.__iterator = function (type, reverse) {
                var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
                var iterations = 0;
                return new Iterator(function () {
                  var step = iterator.next();
                  return step.done ? step : iteratorValue(type, iterations++, step.value, step);
                });
              };
              createClass(ToSetSequence, SetSeq);
              function ToSetSequence(iter) {
                this._iter = iter;
                this.size = iter.size;
              }
              ToSetSequence.prototype.has = function (key) {
                return this._iter.includes(key);
              };
              ToSetSequence.prototype.__iterate = function (fn, reverse) {
                var this$0 = this;
                return this._iter.__iterate(function (v) {
                  return fn(v, v, this$0);
                }, reverse);
              };
              ToSetSequence.prototype.__iterator = function (type, reverse) {
                var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
                return new Iterator(function () {
                  var step = iterator.next();
                  return step.done ? step : iteratorValue(type, step.value, step.value, step);
                });
              };
              createClass(FromEntriesSequence, KeyedSeq);
              function FromEntriesSequence(entries) {
                this._iter = entries;
                this.size = entries.size;
              }
              FromEntriesSequence.prototype.entrySeq = function () {
                return this._iter.toSeq();
              };
              FromEntriesSequence.prototype.__iterate = function (fn, reverse) {
                var this$0 = this;
                return this._iter.__iterate(function (entry) {
                  if (entry) {
                    validateEntry(entry);
                    var indexedIterable = isIterable(entry);
                    return fn(indexedIterable ? entry.get(1) : entry[1], indexedIterable ? entry.get(0) : entry[0], this$0);
                  }
                }, reverse);
              };
              FromEntriesSequence.prototype.__iterator = function (type, reverse) {
                var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
                return new Iterator(function () {
                  while (true) {
                    var step = iterator.next();
                    if (step.done) {
                      return step;
                    }
                    var entry = step.value;
                    if (entry) {
                      validateEntry(entry);
                      var indexedIterable = isIterable(entry);
                      return iteratorValue(type, indexedIterable ? entry.get(0) : entry[0], indexedIterable ? entry.get(1) : entry[1], step);
                    }
                  }
                });
              };
              ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
              function flipFactory(iterable) {
                var flipSequence = makeSequence(iterable);
                flipSequence._iter = iterable;
                flipSequence.size = iterable.size;
                flipSequence.flip = function () {
                  return iterable;
                };
                flipSequence.reverse = function () {
                  var reversedSequence = iterable.reverse.apply(this);
                  reversedSequence.flip = function () {
                    return iterable.reverse();
                  };
                  return reversedSequence;
                };
                flipSequence.has = function (key) {
                  return iterable.includes(key);
                };
                flipSequence.includes = function (key) {
                  return iterable.has(key);
                };
                flipSequence.cacheResult = cacheResultThrough;
                flipSequence.__iterateUncached = function (fn, reverse) {
                  var this$0 = this;
                  return iterable.__iterate(function (v, k) {
                    return fn(k, v, this$0) !== false;
                  }, reverse);
                };
                flipSequence.__iteratorUncached = function (type, reverse) {
                  if (type === ITERATE_ENTRIES) {
                    var iterator = iterable.__iterator(type, reverse);
                    return new Iterator(function () {
                      var step = iterator.next();
                      if (!step.done) {
                        var k = step.value[0];
                        step.value[0] = step.value[1];
                        step.value[1] = k;
                      }
                      return step;
                    });
                  }
                  return iterable.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
                };
                return flipSequence;
              }
              function mapFactory(iterable, mapper, context) {
                var mappedSequence = makeSequence(iterable);
                mappedSequence.size = iterable.size;
                mappedSequence.has = function (key) {
                  return iterable.has(key);
                };
                mappedSequence.get = function (key, notSetValue) {
                  var v = iterable.get(key, NOT_SET);
                  return v === NOT_SET ? notSetValue : mapper.call(context, v, key, iterable);
                };
                mappedSequence.__iterateUncached = function (fn, reverse) {
                  var this$0 = this;
                  return iterable.__iterate(function (v, k, c) {
                    return fn(mapper.call(context, v, k, c), k, this$0) !== false;
                  }, reverse);
                };
                mappedSequence.__iteratorUncached = function (type, reverse) {
                  var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
                  return new Iterator(function () {
                    var step = iterator.next();
                    if (step.done) {
                      return step;
                    }
                    var entry = step.value;
                    var key = entry[0];
                    return iteratorValue(type, key, mapper.call(context, entry[1], key, iterable), step);
                  });
                };
                return mappedSequence;
              }
              function reverseFactory(iterable, useKeys) {
                var reversedSequence = makeSequence(iterable);
                reversedSequence._iter = iterable;
                reversedSequence.size = iterable.size;
                reversedSequence.reverse = function () {
                  return iterable;
                };
                if (iterable.flip) {
                  reversedSequence.flip = function () {
                    var flipSequence = flipFactory(iterable);
                    flipSequence.reverse = function () {
                      return iterable.flip();
                    };
                    return flipSequence;
                  };
                }
                reversedSequence.get = function (key, notSetValue) {
                  return iterable.get(useKeys ? key : -1 - key, notSetValue);
                };
                reversedSequence.has = function (key) {
                  return iterable.has(useKeys ? key : -1 - key);
                };
                reversedSequence.includes = function (value) {
                  return iterable.includes(value);
                };
                reversedSequence.cacheResult = cacheResultThrough;
                reversedSequence.__iterate = function (fn, reverse) {
                  var this$0 = this;
                  return iterable.__iterate(function (v, k) {
                    return fn(v, k, this$0);
                  }, !reverse);
                };
                reversedSequence.__iterator = function (type, reverse) {
                  return iterable.__iterator(type, !reverse);
                };
                return reversedSequence;
              }
              function filterFactory(iterable, predicate, context, useKeys) {
                var filterSequence = makeSequence(iterable);
                if (useKeys) {
                  filterSequence.has = function (key) {
                    var v = iterable.get(key, NOT_SET);
                    return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
                  };
                  filterSequence.get = function (key, notSetValue) {
                    var v = iterable.get(key, NOT_SET);
                    return v !== NOT_SET && predicate.call(context, v, key, iterable) ? v : notSetValue;
                  };
                }
                filterSequence.__iterateUncached = function (fn, reverse) {
                  var this$0 = this;
                  var iterations = 0;
                  iterable.__iterate(function (v, k, c) {
                    if (predicate.call(context, v, k, c)) {
                      iterations++;
                      return fn(v, useKeys ? k : iterations - 1, this$0);
                    }
                  }, reverse);
                  return iterations;
                };
                filterSequence.__iteratorUncached = function (type, reverse) {
                  var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
                  var iterations = 0;
                  return new Iterator(function () {
                    while (true) {
                      var step = iterator.next();
                      if (step.done) {
                        return step;
                      }
                      var entry = step.value;
                      var key = entry[0];
                      var value = entry[1];
                      if (predicate.call(context, value, key, iterable)) {
                        return iteratorValue(type, useKeys ? key : iterations++, value, step);
                      }
                    }
                  });
                };
                return filterSequence;
              }
              function countByFactory(iterable, grouper, context) {
                var groups = Map().asMutable();
                iterable.__iterate(function (v, k) {
                  groups.update(grouper.call(context, v, k, iterable), 0, function (a) {
                    return a + 1;
                  });
                });
                return groups.asImmutable();
              }
              function groupByFactory(iterable, grouper, context) {
                var isKeyedIter = isKeyed(iterable);
                var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
                iterable.__iterate(function (v, k) {
                  groups.update(grouper.call(context, v, k, iterable), function (a) {
                    return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
                  });
                });
                var coerce = iterableClass(iterable);
                return groups.map(function (arr) {
                  return reify(iterable, coerce(arr));
                });
              }
              function sliceFactory(iterable, begin, end, useKeys) {
                var originalSize = iterable.size;
                if (begin !== void 0) {
                  begin = begin | 0;
                }
                if (end !== void 0) {
                  end = end | 0;
                }
                if (wholeSlice(begin, end, originalSize)) {
                  return iterable;
                }
                var resolvedBegin = resolveBegin(begin, originalSize);
                var resolvedEnd = resolveEnd(end, originalSize);
                if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
                  return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
                }
                var resolvedSize = resolvedEnd - resolvedBegin;
                var sliceSize;
                if (resolvedSize === resolvedSize) {
                  sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
                }
                var sliceSeq = makeSequence(iterable);
                sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || void 0;
                if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
                  sliceSeq.get = function (index, notSetValue) {
                    index = wrapIndex(this, index);
                    return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
                  };
                }
                sliceSeq.__iterateUncached = function (fn, reverse) {
                  var this$0 = this;
                  if (sliceSize === 0) {
                    return 0;
                  }
                  if (reverse) {
                    return this.cacheResult().__iterate(fn, reverse);
                  }
                  var skipped = 0;
                  var isSkipping = true;
                  var iterations = 0;
                  iterable.__iterate(function (v, k) {
                    if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
                      iterations++;
                      return fn(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;
                    }
                  });
                  return iterations;
                };
                sliceSeq.__iteratorUncached = function (type, reverse) {
                  if (sliceSize !== 0 && reverse) {
                    return this.cacheResult().__iterator(type, reverse);
                  }
                  var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
                  var skipped = 0;
                  var iterations = 0;
                  return new Iterator(function () {
                    while (skipped++ < resolvedBegin) {
                      iterator.next();
                    }
                    if (++iterations > sliceSize) {
                      return iteratorDone();
                    }
                    var step = iterator.next();
                    if (useKeys || type === ITERATE_VALUES) {
                      return step;
                    } else if (type === ITERATE_KEYS) {
                      return iteratorValue(type, iterations - 1, void 0, step);
                    } else {
                      return iteratorValue(type, iterations - 1, step.value[1], step);
                    }
                  });
                };
                return sliceSeq;
              }
              function takeWhileFactory(iterable, predicate, context) {
                var takeSequence = makeSequence(iterable);
                takeSequence.__iterateUncached = function (fn, reverse) {
                  var this$0 = this;
                  if (reverse) {
                    return this.cacheResult().__iterate(fn, reverse);
                  }
                  var iterations = 0;
                  iterable.__iterate(function (v, k, c) {
                    return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);
                  });
                  return iterations;
                };
                takeSequence.__iteratorUncached = function (type, reverse) {
                  var this$0 = this;
                  if (reverse) {
                    return this.cacheResult().__iterator(type, reverse);
                  }
                  var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
                  var iterating = true;
                  return new Iterator(function () {
                    if (!iterating) {
                      return iteratorDone();
                    }
                    var step = iterator.next();
                    if (step.done) {
                      return step;
                    }
                    var entry = step.value;
                    var k = entry[0];
                    var v = entry[1];
                    if (!predicate.call(context, v, k, this$0)) {
                      iterating = false;
                      return iteratorDone();
                    }
                    return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
                  });
                };
                return takeSequence;
              }
              function skipWhileFactory(iterable, predicate, context, useKeys) {
                var skipSequence = makeSequence(iterable);
                skipSequence.__iterateUncached = function (fn, reverse) {
                  var this$0 = this;
                  if (reverse) {
                    return this.cacheResult().__iterate(fn, reverse);
                  }
                  var isSkipping = true;
                  var iterations = 0;
                  iterable.__iterate(function (v, k, c) {
                    if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
                      iterations++;
                      return fn(v, useKeys ? k : iterations - 1, this$0);
                    }
                  });
                  return iterations;
                };
                skipSequence.__iteratorUncached = function (type, reverse) {
                  var this$0 = this;
                  if (reverse) {
                    return this.cacheResult().__iterator(type, reverse);
                  }
                  var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
                  var skipping = true;
                  var iterations = 0;
                  return new Iterator(function () {
                    var step, k, v;
                    do {
                      step = iterator.next();
                      if (step.done) {
                        if (useKeys || type === ITERATE_VALUES) {
                          return step;
                        } else if (type === ITERATE_KEYS) {
                          return iteratorValue(type, iterations++, void 0, step);
                        } else {
                          return iteratorValue(type, iterations++, step.value[1], step);
                        }
                      }
                      var entry = step.value;
                      k = entry[0];
                      v = entry[1];
                      skipping && (skipping = predicate.call(context, v, k, this$0));
                    } while (skipping);
                    return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
                  });
                };
                return skipSequence;
              }
              function concatFactory(iterable, values) {
                var isKeyedIterable = isKeyed(iterable);
                var iters = [iterable].concat(values).map(function (v) {
                  if (!isIterable(v)) {
                    v = isKeyedIterable ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
                  } else if (isKeyedIterable) {
                    v = KeyedIterable(v);
                  }
                  return v;
                }).filter(function (v) {
                  return v.size !== 0;
                });
                if (iters.length === 0) {
                  return iterable;
                }
                if (iters.length === 1) {
                  var singleton = iters[0];
                  if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) {
                    return singleton;
                  }
                }
                var concatSeq = new ArraySeq(iters);
                if (isKeyedIterable) {
                  concatSeq = concatSeq.toKeyedSeq();
                } else if (!isIndexed(iterable)) {
                  concatSeq = concatSeq.toSetSeq();
                }
                concatSeq = concatSeq.flatten(true);
                concatSeq.size = iters.reduce(function (sum, seq) {
                  if (sum !== void 0) {
                    var size = seq.size;
                    if (size !== void 0) {
                      return sum + size;
                    }
                  }
                }, 0);
                return concatSeq;
              }
              function flattenFactory(iterable, depth, useKeys) {
                var flatSequence = makeSequence(iterable);
                flatSequence.__iterateUncached = function (fn, reverse) {
                  var iterations = 0;
                  var stopped = false;
                  function flatDeep(iter, currentDepth) {
                    var this$0 = this;
                    iter.__iterate(function (v, k) {
                      if ((!depth || currentDepth < depth) && isIterable(v)) {
                        flatDeep(v, currentDepth + 1);
                      } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
                        stopped = true;
                      }
                      return !stopped;
                    }, reverse);
                  }
                  flatDeep(iterable, 0);
                  return iterations;
                };
                flatSequence.__iteratorUncached = function (type, reverse) {
                  var iterator = iterable.__iterator(type, reverse);
                  var stack = [];
                  var iterations = 0;
                  return new Iterator(function () {
                    while (iterator) {
                      var step = iterator.next();
                      if (step.done !== false) {
                        iterator = stack.pop();
                        continue;
                      }
                      var v = step.value;
                      if (type === ITERATE_ENTRIES) {
                        v = v[1];
                      }
                      if ((!depth || stack.length < depth) && isIterable(v)) {
                        stack.push(iterator);
                        iterator = v.__iterator(type, reverse);
                      } else {
                        return useKeys ? step : iteratorValue(type, iterations++, v, step);
                      }
                    }
                    return iteratorDone();
                  });
                };
                return flatSequence;
              }
              function flatMapFactory(iterable, mapper, context) {
                var coerce = iterableClass(iterable);
                return iterable.toSeq().map(function (v, k) {
                  return coerce(mapper.call(context, v, k, iterable));
                }).flatten(true);
              }
              function interposeFactory(iterable, separator) {
                var interposedSequence = makeSequence(iterable);
                interposedSequence.size = iterable.size && iterable.size * 2 - 1;
                interposedSequence.__iterateUncached = function (fn, reverse) {
                  var this$0 = this;
                  var iterations = 0;
                  iterable.__iterate(function (v, k) {
                    return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v, iterations++, this$0) !== false;
                  }, reverse);
                  return iterations;
                };
                interposedSequence.__iteratorUncached = function (type, reverse) {
                  var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
                  var iterations = 0;
                  var step;
                  return new Iterator(function () {
                    if (!step || iterations % 2) {
                      step = iterator.next();
                      if (step.done) {
                        return step;
                      }
                    }
                    return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
                  });
                };
                return interposedSequence;
              }
              function sortFactory(iterable, comparator, mapper) {
                if (!comparator) {
                  comparator = defaultComparator;
                }
                var isKeyedIterable = isKeyed(iterable);
                var index = 0;
                var entries = iterable.toSeq().map(function (v, k) {
                  return [k, v, index++, mapper ? mapper(v, k, iterable) : v];
                }).toArray();
                entries.sort(function (a, b) {
                  return comparator(a[3], b[3]) || a[2] - b[2];
                }).forEach(isKeyedIterable ? function (v, i) {
                  entries[i].length = 2;
                } : function (v, i) {
                  entries[i] = v[1];
                });
                return isKeyedIterable ? KeyedSeq(entries) : isIndexed(iterable) ? IndexedSeq(entries) : SetSeq(entries);
              }
              function maxFactory(iterable, comparator, mapper) {
                if (!comparator) {
                  comparator = defaultComparator;
                }
                if (mapper) {
                  var entry = iterable.toSeq().map(function (v, k) {
                    return [v, mapper(v, k, iterable)];
                  }).reduce(function (a, b) {
                    return maxCompare(comparator, a[1], b[1]) ? b : a;
                  });
                  return entry && entry[0];
                } else {
                  return iterable.reduce(function (a, b) {
                    return maxCompare(comparator, a, b) ? b : a;
                  });
                }
              }
              function maxCompare(comparator, a, b) {
                var comp = comparator(b, a);
                return comp === 0 && b !== a && (b === void 0 || b === null || b !== b) || comp > 0;
              }
              function zipWithFactory(keyIter, zipper, iters) {
                var zipSequence = makeSequence(keyIter);
                zipSequence.size = new ArraySeq(iters).map(function (i) {
                  return i.size;
                }).min();
                zipSequence.__iterate = function (fn, reverse) {
                  var iterator = this.__iterator(ITERATE_VALUES, reverse);
                  var step;
                  var iterations = 0;
                  while (!(step = iterator.next()).done) {
                    if (fn(step.value, iterations++, this) === false) {
                      break;
                    }
                  }
                  return iterations;
                };
                zipSequence.__iteratorUncached = function (type, reverse) {
                  var iterators = iters.map(function (i) {
                    return i = Iterable(i), getIterator(reverse ? i.reverse() : i);
                  });
                  var iterations = 0;
                  var isDone = false;
                  return new Iterator(function () {
                    var steps;
                    if (!isDone) {
                      steps = iterators.map(function (i) {
                        return i.next();
                      });
                      isDone = steps.some(function (s) {
                        return s.done;
                      });
                    }
                    if (isDone) {
                      return iteratorDone();
                    }
                    return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
                      return s.value;
                    })));
                  });
                };
                return zipSequence;
              }
              function reify(iter, seq) {
                return isSeq(iter) ? seq : iter.constructor(seq);
              }
              function validateEntry(entry) {
                if (entry !== Object(entry)) {
                  throw new TypeError("Expected [K, V] tuple: " + entry);
                }
              }
              function resolveSize(iter) {
                assertNotInfinite(iter.size);
                return ensureSize(iter);
              }
              function iterableClass(iterable) {
                return isKeyed(iterable) ? KeyedIterable : isIndexed(iterable) ? IndexedIterable : SetIterable;
              }
              function makeSequence(iterable) {
                return Object.create((isKeyed(iterable) ? KeyedSeq : isIndexed(iterable) ? IndexedSeq : SetSeq).prototype);
              }
              function cacheResultThrough() {
                if (this._iter.cacheResult) {
                  this._iter.cacheResult();
                  this.size = this._iter.size;
                  return this;
                } else {
                  return Seq.prototype.cacheResult.call(this);
                }
              }
              function defaultComparator(a, b) {
                return a > b ? 1 : a < b ? -1 : 0;
              }
              function forceIterator(keyPath) {
                var iter = getIterator(keyPath);
                if (!iter) {
                  if (!isArrayLike(keyPath)) {
                    throw new TypeError("Expected iterable or array-like: " + keyPath);
                  }
                  iter = getIterator(Iterable(keyPath));
                }
                return iter;
              }
              createClass(Record, KeyedCollection);
              function Record(defaultValues, name) {
                var hasInitialized;
                var RecordType = function Record2(values) {
                  if (values instanceof RecordType) {
                    return values;
                  }
                  if (!(this instanceof RecordType)) {
                    return new RecordType(values);
                  }
                  if (!hasInitialized) {
                    hasInitialized = true;
                    var keys = Object.keys(defaultValues);
                    setProps(RecordTypePrototype, keys);
                    RecordTypePrototype.size = keys.length;
                    RecordTypePrototype._name = name;
                    RecordTypePrototype._keys = keys;
                    RecordTypePrototype._defaultValues = defaultValues;
                  }
                  this._map = Map(values);
                };
                var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
                RecordTypePrototype.constructor = RecordType;
                return RecordType;
              }
              Record.prototype.toString = function () {
                return this.__toString(recordName(this) + " {", "}");
              };
              Record.prototype.has = function (k) {
                return this._defaultValues.hasOwnProperty(k);
              };
              Record.prototype.get = function (k, notSetValue) {
                if (!this.has(k)) {
                  return notSetValue;
                }
                var defaultVal = this._defaultValues[k];
                return this._map ? this._map.get(k, defaultVal) : defaultVal;
              };
              Record.prototype.clear = function () {
                if (this.__ownerID) {
                  this._map && this._map.clear();
                  return this;
                }
                var RecordType = this.constructor;
                return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
              };
              Record.prototype.set = function (k, v) {
                if (!this.has(k)) {
                  throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
                }
                var newMap = this._map && this._map.set(k, v);
                if (this.__ownerID || newMap === this._map) {
                  return this;
                }
                return makeRecord(this, newMap);
              };
              Record.prototype.remove = function (k) {
                if (!this.has(k)) {
                  return this;
                }
                var newMap = this._map && this._map.remove(k);
                if (this.__ownerID || newMap === this._map) {
                  return this;
                }
                return makeRecord(this, newMap);
              };
              Record.prototype.wasAltered = function () {
                return this._map.wasAltered();
              };
              Record.prototype.__iterator = function (type, reverse) {
                var this$0 = this;
                return KeyedIterable(this._defaultValues).map(function (_, k) {
                  return this$0.get(k);
                }).__iterator(type, reverse);
              };
              Record.prototype.__iterate = function (fn, reverse) {
                var this$0 = this;
                return KeyedIterable(this._defaultValues).map(function (_, k) {
                  return this$0.get(k);
                }).__iterate(fn, reverse);
              };
              Record.prototype.__ensureOwner = function (ownerID) {
                if (ownerID === this.__ownerID) {
                  return this;
                }
                var newMap = this._map && this._map.__ensureOwner(ownerID);
                if (!ownerID) {
                  this.__ownerID = ownerID;
                  this._map = newMap;
                  return this;
                }
                return makeRecord(this, newMap, ownerID);
              };
              var RecordPrototype = Record.prototype;
              RecordPrototype[DELETE] = RecordPrototype.remove;
              RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
              RecordPrototype.merge = MapPrototype.merge;
              RecordPrototype.mergeWith = MapPrototype.mergeWith;
              RecordPrototype.mergeIn = MapPrototype.mergeIn;
              RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
              RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
              RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
              RecordPrototype.setIn = MapPrototype.setIn;
              RecordPrototype.update = MapPrototype.update;
              RecordPrototype.updateIn = MapPrototype.updateIn;
              RecordPrototype.withMutations = MapPrototype.withMutations;
              RecordPrototype.asMutable = MapPrototype.asMutable;
              RecordPrototype.asImmutable = MapPrototype.asImmutable;
              function makeRecord(likeRecord, map, ownerID) {
                var record = Object.create(Object.getPrototypeOf(likeRecord));
                record._map = map;
                record.__ownerID = ownerID;
                return record;
              }
              function recordName(record) {
                return record._name || record.constructor.name || "Record";
              }
              function setProps(prototype, names) {
                try {
                  names.forEach(setProp.bind(void 0, prototype));
                } catch (error) {}
              }
              function setProp(prototype, name) {
                Object.defineProperty(prototype, name, {
                  get: function () {
                    return this.get(name);
                  },
                  set: function (value) {
                    invariant(this.__ownerID, "Cannot set on an immutable record.");
                    this.set(name, value);
                  }
                });
              }
              createClass(Set, SetCollection);
              function Set(value) {
                return value === null || value === void 0 ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
                  var iter = SetIterable(value);
                  assertNotInfinite(iter.size);
                  iter.forEach(function (v) {
                    return set.add(v);
                  });
                });
              }
              Set.of = function () {
                return this(arguments);
              };
              Set.fromKeys = function (value) {
                return this(KeyedIterable(value).keySeq());
              };
              Set.prototype.toString = function () {
                return this.__toString("Set {", "}");
              };
              Set.prototype.has = function (value) {
                return this._map.has(value);
              };
              Set.prototype.add = function (value) {
                return updateSet(this, this._map.set(value, true));
              };
              Set.prototype.remove = function (value) {
                return updateSet(this, this._map.remove(value));
              };
              Set.prototype.clear = function () {
                return updateSet(this, this._map.clear());
              };
              Set.prototype.union = function () {
                var iters = SLICE$0.call(arguments, 0);
                iters = iters.filter(function (x) {
                  return x.size !== 0;
                });
                if (iters.length === 0) {
                  return this;
                }
                if (this.size === 0 && !this.__ownerID && iters.length === 1) {
                  return this.constructor(iters[0]);
                }
                return this.withMutations(function (set) {
                  for (var ii = 0; ii < iters.length; ii++) {
                    SetIterable(iters[ii]).forEach(function (value) {
                      return set.add(value);
                    });
                  }
                });
              };
              Set.prototype.intersect = function () {
                var iters = SLICE$0.call(arguments, 0);
                if (iters.length === 0) {
                  return this;
                }
                iters = iters.map(function (iter) {
                  return SetIterable(iter);
                });
                var originalSet = this;
                return this.withMutations(function (set) {
                  originalSet.forEach(function (value) {
                    if (!iters.every(function (iter) {
                      return iter.includes(value);
                    })) {
                      set.remove(value);
                    }
                  });
                });
              };
              Set.prototype.subtract = function () {
                var iters = SLICE$0.call(arguments, 0);
                if (iters.length === 0) {
                  return this;
                }
                iters = iters.map(function (iter) {
                  return SetIterable(iter);
                });
                var originalSet = this;
                return this.withMutations(function (set) {
                  originalSet.forEach(function (value) {
                    if (iters.some(function (iter) {
                      return iter.includes(value);
                    })) {
                      set.remove(value);
                    }
                  });
                });
              };
              Set.prototype.merge = function () {
                return this.union.apply(this, arguments);
              };
              Set.prototype.mergeWith = function (merger) {
                var iters = SLICE$0.call(arguments, 1);
                return this.union.apply(this, iters);
              };
              Set.prototype.sort = function (comparator) {
                return OrderedSet(sortFactory(this, comparator));
              };
              Set.prototype.sortBy = function (mapper, comparator) {
                return OrderedSet(sortFactory(this, comparator, mapper));
              };
              Set.prototype.wasAltered = function () {
                return this._map.wasAltered();
              };
              Set.prototype.__iterate = function (fn, reverse) {
                var this$0 = this;
                return this._map.__iterate(function (_, k) {
                  return fn(k, k, this$0);
                }, reverse);
              };
              Set.prototype.__iterator = function (type, reverse) {
                return this._map.map(function (_, k) {
                  return k;
                }).__iterator(type, reverse);
              };
              Set.prototype.__ensureOwner = function (ownerID) {
                if (ownerID === this.__ownerID) {
                  return this;
                }
                var newMap = this._map.__ensureOwner(ownerID);
                if (!ownerID) {
                  this.__ownerID = ownerID;
                  this._map = newMap;
                  return this;
                }
                return this.__make(newMap, ownerID);
              };
              function isSet(maybeSet) {
                return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
              }
              Set.isSet = isSet;
              var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
              var SetPrototype = Set.prototype;
              SetPrototype[IS_SET_SENTINEL] = true;
              SetPrototype[DELETE] = SetPrototype.remove;
              SetPrototype.mergeDeep = SetPrototype.merge;
              SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
              SetPrototype.withMutations = MapPrototype.withMutations;
              SetPrototype.asMutable = MapPrototype.asMutable;
              SetPrototype.asImmutable = MapPrototype.asImmutable;
              SetPrototype.__empty = emptySet;
              SetPrototype.__make = makeSet;
              function updateSet(set, newMap) {
                if (set.__ownerID) {
                  set.size = newMap.size;
                  set._map = newMap;
                  return set;
                }
                return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
              }
              function makeSet(map, ownerID) {
                var set = Object.create(SetPrototype);
                set.size = map ? map.size : 0;
                set._map = map;
                set.__ownerID = ownerID;
                return set;
              }
              var EMPTY_SET;
              function emptySet() {
                return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
              }
              createClass(OrderedSet, Set);
              function OrderedSet(value) {
                return value === null || value === void 0 ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
                  var iter = SetIterable(value);
                  assertNotInfinite(iter.size);
                  iter.forEach(function (v) {
                    return set.add(v);
                  });
                });
              }
              OrderedSet.of = function () {
                return this(arguments);
              };
              OrderedSet.fromKeys = function (value) {
                return this(KeyedIterable(value).keySeq());
              };
              OrderedSet.prototype.toString = function () {
                return this.__toString("OrderedSet {", "}");
              };
              function isOrderedSet(maybeOrderedSet) {
                return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
              }
              OrderedSet.isOrderedSet = isOrderedSet;
              var OrderedSetPrototype = OrderedSet.prototype;
              OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
              OrderedSetPrototype.__empty = emptyOrderedSet;
              OrderedSetPrototype.__make = makeOrderedSet;
              function makeOrderedSet(map, ownerID) {
                var set = Object.create(OrderedSetPrototype);
                set.size = map ? map.size : 0;
                set._map = map;
                set.__ownerID = ownerID;
                return set;
              }
              var EMPTY_ORDERED_SET;
              function emptyOrderedSet() {
                return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
              }
              createClass(Stack, IndexedCollection);
              function Stack(value) {
                return value === null || value === void 0 ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);
              }
              Stack.of = function () {
                return this(arguments);
              };
              Stack.prototype.toString = function () {
                return this.__toString("Stack [", "]");
              };
              Stack.prototype.get = function (index, notSetValue) {
                var head = this._head;
                index = wrapIndex(this, index);
                while (head && index--) {
                  head = head.next;
                }
                return head ? head.value : notSetValue;
              };
              Stack.prototype.peek = function () {
                return this._head && this._head.value;
              };
              Stack.prototype.push = function () {
                if (arguments.length === 0) {
                  return this;
                }
                var newSize = this.size + arguments.length;
                var head = this._head;
                for (var ii = arguments.length - 1; ii >= 0; ii--) {
                  head = {
                    value: arguments[ii],
                    next: head
                  };
                }
                if (this.__ownerID) {
                  this.size = newSize;
                  this._head = head;
                  this.__hash = void 0;
                  this.__altered = true;
                  return this;
                }
                return makeStack(newSize, head);
              };
              Stack.prototype.pushAll = function (iter) {
                iter = IndexedIterable(iter);
                if (iter.size === 0) {
                  return this;
                }
                assertNotInfinite(iter.size);
                var newSize = this.size;
                var head = this._head;
                iter.reverse().forEach(function (value) {
                  newSize++;
                  head = {
                    value,
                    next: head
                  };
                });
                if (this.__ownerID) {
                  this.size = newSize;
                  this._head = head;
                  this.__hash = void 0;
                  this.__altered = true;
                  return this;
                }
                return makeStack(newSize, head);
              };
              Stack.prototype.pop = function () {
                return this.slice(1);
              };
              Stack.prototype.unshift = function () {
                return this.push.apply(this, arguments);
              };
              Stack.prototype.unshiftAll = function (iter) {
                return this.pushAll(iter);
              };
              Stack.prototype.shift = function () {
                return this.pop.apply(this, arguments);
              };
              Stack.prototype.clear = function () {
                if (this.size === 0) {
                  return this;
                }
                if (this.__ownerID) {
                  this.size = 0;
                  this._head = void 0;
                  this.__hash = void 0;
                  this.__altered = true;
                  return this;
                }
                return emptyStack();
              };
              Stack.prototype.slice = function (begin, end) {
                if (wholeSlice(begin, end, this.size)) {
                  return this;
                }
                var resolvedBegin = resolveBegin(begin, this.size);
                var resolvedEnd = resolveEnd(end, this.size);
                if (resolvedEnd !== this.size) {
                  return IndexedCollection.prototype.slice.call(this, begin, end);
                }
                var newSize = this.size - resolvedBegin;
                var head = this._head;
                while (resolvedBegin--) {
                  head = head.next;
                }
                if (this.__ownerID) {
                  this.size = newSize;
                  this._head = head;
                  this.__hash = void 0;
                  this.__altered = true;
                  return this;
                }
                return makeStack(newSize, head);
              };
              Stack.prototype.__ensureOwner = function (ownerID) {
                if (ownerID === this.__ownerID) {
                  return this;
                }
                if (!ownerID) {
                  this.__ownerID = ownerID;
                  this.__altered = false;
                  return this;
                }
                return makeStack(this.size, this._head, ownerID, this.__hash);
              };
              Stack.prototype.__iterate = function (fn, reverse) {
                if (reverse) {
                  return this.reverse().__iterate(fn);
                }
                var iterations = 0;
                var node = this._head;
                while (node) {
                  if (fn(node.value, iterations++, this) === false) {
                    break;
                  }
                  node = node.next;
                }
                return iterations;
              };
              Stack.prototype.__iterator = function (type, reverse) {
                if (reverse) {
                  return this.reverse().__iterator(type);
                }
                var iterations = 0;
                var node = this._head;
                return new Iterator(function () {
                  if (node) {
                    var value = node.value;
                    node = node.next;
                    return iteratorValue(type, iterations++, value);
                  }
                  return iteratorDone();
                });
              };
              function isStack(maybeStack) {
                return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
              }
              Stack.isStack = isStack;
              var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
              var StackPrototype = Stack.prototype;
              StackPrototype[IS_STACK_SENTINEL] = true;
              StackPrototype.withMutations = MapPrototype.withMutations;
              StackPrototype.asMutable = MapPrototype.asMutable;
              StackPrototype.asImmutable = MapPrototype.asImmutable;
              StackPrototype.wasAltered = MapPrototype.wasAltered;
              function makeStack(size, head, ownerID, hash2) {
                var map = Object.create(StackPrototype);
                map.size = size;
                map._head = head;
                map.__ownerID = ownerID;
                map.__hash = hash2;
                map.__altered = false;
                return map;
              }
              var EMPTY_STACK;
              function emptyStack() {
                return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
              }
              function mixin(ctor, methods) {
                var keyCopier = function (key) {
                  ctor.prototype[key] = methods[key];
                };
                Object.keys(methods).forEach(keyCopier);
                Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
                return ctor;
              }
              Iterable.Iterator = Iterator;
              mixin(Iterable, {
                // ### Conversion to other types
                toArray: function () {
                  assertNotInfinite(this.size);
                  var array = new Array(this.size || 0);
                  this.valueSeq().__iterate(function (v, i) {
                    array[i] = v;
                  });
                  return array;
                },
                toIndexedSeq: function () {
                  return new ToIndexedSequence(this);
                },
                toJS: function () {
                  return this.toSeq().map(function (value) {
                    return value && typeof value.toJS === "function" ? value.toJS() : value;
                  }).__toJS();
                },
                toJSON: function () {
                  return this.toSeq().map(function (value) {
                    return value && typeof value.toJSON === "function" ? value.toJSON() : value;
                  }).__toJS();
                },
                toKeyedSeq: function () {
                  return new ToKeyedSequence(this, true);
                },
                toMap: function () {
                  return Map(this.toKeyedSeq());
                },
                toObject: function () {
                  assertNotInfinite(this.size);
                  var object = {};
                  this.__iterate(function (v, k) {
                    object[k] = v;
                  });
                  return object;
                },
                toOrderedMap: function () {
                  return OrderedMap(this.toKeyedSeq());
                },
                toOrderedSet: function () {
                  return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
                },
                toSet: function () {
                  return Set(isKeyed(this) ? this.valueSeq() : this);
                },
                toSetSeq: function () {
                  return new ToSetSequence(this);
                },
                toSeq: function () {
                  return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
                },
                toStack: function () {
                  return Stack(isKeyed(this) ? this.valueSeq() : this);
                },
                toList: function () {
                  return List(isKeyed(this) ? this.valueSeq() : this);
                },
                // ### Common JavaScript methods and properties
                toString: function () {
                  return "[Iterable]";
                },
                __toString: function (head, tail) {
                  if (this.size === 0) {
                    return head + tail;
                  }
                  return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
                },
                // ### ES6 Collection methods (ES6 Array and Map)
                concat: function () {
                  var values = SLICE$0.call(arguments, 0);
                  return reify(this, concatFactory(this, values));
                },
                includes: function (searchValue) {
                  return this.some(function (value) {
                    return is(value, searchValue);
                  });
                },
                entries: function () {
                  return this.__iterator(ITERATE_ENTRIES);
                },
                every: function (predicate, context) {
                  assertNotInfinite(this.size);
                  var returnValue = true;
                  this.__iterate(function (v, k, c) {
                    if (!predicate.call(context, v, k, c)) {
                      returnValue = false;
                      return false;
                    }
                  });
                  return returnValue;
                },
                filter: function (predicate, context) {
                  return reify(this, filterFactory(this, predicate, context, true));
                },
                find: function (predicate, context, notSetValue) {
                  var entry = this.findEntry(predicate, context);
                  return entry ? entry[1] : notSetValue;
                },
                findEntry: function (predicate, context) {
                  var found;
                  this.__iterate(function (v, k, c) {
                    if (predicate.call(context, v, k, c)) {
                      found = [k, v];
                      return false;
                    }
                  });
                  return found;
                },
                findLastEntry: function (predicate, context) {
                  return this.toSeq().reverse().findEntry(predicate, context);
                },
                forEach: function (sideEffect, context) {
                  assertNotInfinite(this.size);
                  return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
                },
                join: function (separator) {
                  assertNotInfinite(this.size);
                  separator = separator !== void 0 ? "" + separator : ",";
                  var joined = "";
                  var isFirst = true;
                  this.__iterate(function (v) {
                    isFirst ? isFirst = false : joined += separator;
                    joined += v !== null && v !== void 0 ? v.toString() : "";
                  });
                  return joined;
                },
                keys: function () {
                  return this.__iterator(ITERATE_KEYS);
                },
                map: function (mapper, context) {
                  return reify(this, mapFactory(this, mapper, context));
                },
                reduce: function (reducer, initialReduction, context) {
                  assertNotInfinite(this.size);
                  var reduction;
                  var useFirst;
                  if (arguments.length < 2) {
                    useFirst = true;
                  } else {
                    reduction = initialReduction;
                  }
                  this.__iterate(function (v, k, c) {
                    if (useFirst) {
                      useFirst = false;
                      reduction = v;
                    } else {
                      reduction = reducer.call(context, reduction, v, k, c);
                    }
                  });
                  return reduction;
                },
                reduceRight: function (reducer, initialReduction, context) {
                  var reversed = this.toKeyedSeq().reverse();
                  return reversed.reduce.apply(reversed, arguments);
                },
                reverse: function () {
                  return reify(this, reverseFactory(this, true));
                },
                slice: function (begin, end) {
                  return reify(this, sliceFactory(this, begin, end, true));
                },
                some: function (predicate, context) {
                  return !this.every(not(predicate), context);
                },
                sort: function (comparator) {
                  return reify(this, sortFactory(this, comparator));
                },
                values: function () {
                  return this.__iterator(ITERATE_VALUES);
                },
                // ### More sequential methods
                butLast: function () {
                  return this.slice(0, -1);
                },
                isEmpty: function () {
                  return this.size !== void 0 ? this.size === 0 : !this.some(function () {
                    return true;
                  });
                },
                count: function (predicate, context) {
                  return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
                },
                countBy: function (grouper, context) {
                  return countByFactory(this, grouper, context);
                },
                equals: function (other) {
                  return deepEqual(this, other);
                },
                entrySeq: function () {
                  var iterable = this;
                  if (iterable._cache) {
                    return new ArraySeq(iterable._cache);
                  }
                  var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
                  entriesSequence.fromEntrySeq = function () {
                    return iterable.toSeq();
                  };
                  return entriesSequence;
                },
                filterNot: function (predicate, context) {
                  return this.filter(not(predicate), context);
                },
                findLast: function (predicate, context, notSetValue) {
                  return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
                },
                first: function () {
                  return this.find(returnTrue);
                },
                flatMap: function (mapper, context) {
                  return reify(this, flatMapFactory(this, mapper, context));
                },
                flatten: function (depth) {
                  return reify(this, flattenFactory(this, depth, true));
                },
                fromEntrySeq: function () {
                  return new FromEntriesSequence(this);
                },
                get: function (searchKey, notSetValue) {
                  return this.find(function (_, key) {
                    return is(key, searchKey);
                  }, void 0, notSetValue);
                },
                getIn: function (searchKeyPath, notSetValue) {
                  var nested = this;
                  var iter = forceIterator(searchKeyPath);
                  var step;
                  while (!(step = iter.next()).done) {
                    var key = step.value;
                    nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
                    if (nested === NOT_SET) {
                      return notSetValue;
                    }
                  }
                  return nested;
                },
                groupBy: function (grouper, context) {
                  return groupByFactory(this, grouper, context);
                },
                has: function (searchKey) {
                  return this.get(searchKey, NOT_SET) !== NOT_SET;
                },
                hasIn: function (searchKeyPath) {
                  return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
                },
                isSubset: function (iter) {
                  iter = typeof iter.includes === "function" ? iter : Iterable(iter);
                  return this.every(function (value) {
                    return iter.includes(value);
                  });
                },
                isSuperset: function (iter) {
                  iter = typeof iter.isSubset === "function" ? iter : Iterable(iter);
                  return iter.isSubset(this);
                },
                keySeq: function () {
                  return this.toSeq().map(keyMapper).toIndexedSeq();
                },
                last: function () {
                  return this.toSeq().reverse().first();
                },
                max: function (comparator) {
                  return maxFactory(this, comparator);
                },
                maxBy: function (mapper, comparator) {
                  return maxFactory(this, comparator, mapper);
                },
                min: function (comparator) {
                  return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
                },
                minBy: function (mapper, comparator) {
                  return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
                },
                rest: function () {
                  return this.slice(1);
                },
                skip: function (amount) {
                  return this.slice(Math.max(0, amount));
                },
                skipLast: function (amount) {
                  return reify(this, this.toSeq().reverse().skip(amount).reverse());
                },
                skipWhile: function (predicate, context) {
                  return reify(this, skipWhileFactory(this, predicate, context, true));
                },
                skipUntil: function (predicate, context) {
                  return this.skipWhile(not(predicate), context);
                },
                sortBy: function (mapper, comparator) {
                  return reify(this, sortFactory(this, comparator, mapper));
                },
                take: function (amount) {
                  return this.slice(0, Math.max(0, amount));
                },
                takeLast: function (amount) {
                  return reify(this, this.toSeq().reverse().take(amount).reverse());
                },
                takeWhile: function (predicate, context) {
                  return reify(this, takeWhileFactory(this, predicate, context));
                },
                takeUntil: function (predicate, context) {
                  return this.takeWhile(not(predicate), context);
                },
                valueSeq: function () {
                  return this.toIndexedSeq();
                },
                // ### Hashable Object
                hashCode: function () {
                  return this.__hash || (this.__hash = hashIterable(this));
                }
                // ### Internal
                // abstract __iterate(fn, reverse)
                // abstract __iterator(type, reverse)
              });
              var IterablePrototype = Iterable.prototype;
              IterablePrototype[IS_ITERABLE_SENTINEL] = true;
              IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
              IterablePrototype.__toJS = IterablePrototype.toArray;
              IterablePrototype.__toStringMapper = quoteString;
              IterablePrototype.inspect = IterablePrototype.toSource = function () {
                return this.toString();
              };
              IterablePrototype.chain = IterablePrototype.flatMap;
              IterablePrototype.contains = IterablePrototype.includes;
              (function () {
                try {
                  Object.defineProperty(IterablePrototype, "length", {
                    get: function () {
                      if (!Iterable.noLengthWarning) {
                        var stack;
                        try {
                          throw new Error();
                        } catch (error) {
                          stack = error.stack;
                        }
                        if (stack.indexOf("_wrapObject") === -1) {
                          console && console.warn && console.warn("iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. " + stack);
                          return this.size;
                        }
                      }
                    }
                  });
                } catch (e) {}
              })();
              mixin(KeyedIterable, {
                // ### More sequential methods
                flip: function () {
                  return reify(this, flipFactory(this));
                },
                findKey: function (predicate, context) {
                  var entry = this.findEntry(predicate, context);
                  return entry && entry[0];
                },
                findLastKey: function (predicate, context) {
                  return this.toSeq().reverse().findKey(predicate, context);
                },
                keyOf: function (searchValue) {
                  return this.findKey(function (value) {
                    return is(value, searchValue);
                  });
                },
                lastKeyOf: function (searchValue) {
                  return this.findLastKey(function (value) {
                    return is(value, searchValue);
                  });
                },
                mapEntries: function (mapper, context) {
                  var this$0 = this;
                  var iterations = 0;
                  return reify(this, this.toSeq().map(function (v, k) {
                    return mapper.call(context, [k, v], iterations++, this$0);
                  }).fromEntrySeq());
                },
                mapKeys: function (mapper, context) {
                  var this$0 = this;
                  return reify(this, this.toSeq().flip().map(function (k, v) {
                    return mapper.call(context, k, v, this$0);
                  }).flip());
                }
              });
              var KeyedIterablePrototype = KeyedIterable.prototype;
              KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
              KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
              KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
              KeyedIterablePrototype.__toStringMapper = function (v, k) {
                return JSON.stringify(k) + ": " + quoteString(v);
              };
              mixin(IndexedIterable, {
                // ### Conversion to other types
                toKeyedSeq: function () {
                  return new ToKeyedSequence(this, false);
                },
                // ### ES6 Collection methods (ES6 Array and Map)
                filter: function (predicate, context) {
                  return reify(this, filterFactory(this, predicate, context, false));
                },
                findIndex: function (predicate, context) {
                  var entry = this.findEntry(predicate, context);
                  return entry ? entry[0] : -1;
                },
                indexOf: function (searchValue) {
                  var key = this.toKeyedSeq().keyOf(searchValue);
                  return key === void 0 ? -1 : key;
                },
                lastIndexOf: function (searchValue) {
                  var key = this.toKeyedSeq().reverse().keyOf(searchValue);
                  return key === void 0 ? -1 : key;
                },
                reverse: function () {
                  return reify(this, reverseFactory(this, false));
                },
                slice: function (begin, end) {
                  return reify(this, sliceFactory(this, begin, end, false));
                },
                splice: function (index, removeNum) {
                  var numArgs = arguments.length;
                  removeNum = Math.max(removeNum | 0, 0);
                  if (numArgs === 0 || numArgs === 2 && !removeNum) {
                    return this;
                  }
                  index = resolveBegin(index, index < 0 ? this.count() : this.size);
                  var spliced = this.slice(0, index);
                  return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
                },
                // ### More collection methods
                findLastIndex: function (predicate, context) {
                  var key = this.toKeyedSeq().findLastKey(predicate, context);
                  return key === void 0 ? -1 : key;
                },
                first: function () {
                  return this.get(0);
                },
                flatten: function (depth) {
                  return reify(this, flattenFactory(this, depth, false));
                },
                get: function (index, notSetValue) {
                  index = wrapIndex(this, index);
                  return index < 0 || this.size === Infinity || this.size !== void 0 && index > this.size ? notSetValue : this.find(function (_, key) {
                    return key === index;
                  }, void 0, notSetValue);
                },
                has: function (index) {
                  index = wrapIndex(this, index);
                  return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
                },
                interpose: function (separator) {
                  return reify(this, interposeFactory(this, separator));
                },
                interleave: function () {
                  var iterables = [this].concat(arrCopy(arguments));
                  var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
                  var interleaved = zipped.flatten(true);
                  if (zipped.size) {
                    interleaved.size = zipped.size * iterables.length;
                  }
                  return reify(this, interleaved);
                },
                last: function () {
                  return this.get(-1);
                },
                skipWhile: function (predicate, context) {
                  return reify(this, skipWhileFactory(this, predicate, context, false));
                },
                zip: function () {
                  var iterables = [this].concat(arrCopy(arguments));
                  return reify(this, zipWithFactory(this, defaultZipper, iterables));
                },
                zipWith: function (zipper) {
                  var iterables = arrCopy(arguments);
                  iterables[0] = this;
                  return reify(this, zipWithFactory(this, zipper, iterables));
                }
              });
              IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
              IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
              mixin(SetIterable, {
                // ### ES6 Collection methods (ES6 Array and Map)
                get: function (value, notSetValue) {
                  return this.has(value) ? value : notSetValue;
                },
                includes: function (value) {
                  return this.has(value);
                },
                // ### More sequential methods
                keySeq: function () {
                  return this.valueSeq();
                }
              });
              SetIterable.prototype.has = IterablePrototype.includes;
              mixin(KeyedSeq, KeyedIterable.prototype);
              mixin(IndexedSeq, IndexedIterable.prototype);
              mixin(SetSeq, SetIterable.prototype);
              mixin(KeyedCollection, KeyedIterable.prototype);
              mixin(IndexedCollection, IndexedIterable.prototype);
              mixin(SetCollection, SetIterable.prototype);
              function keyMapper(v, k) {
                return k;
              }
              function entryMapper(v, k) {
                return [k, v];
              }
              function not(predicate) {
                return function () {
                  return !predicate.apply(this, arguments);
                };
              }
              function neg(predicate) {
                return function () {
                  return -predicate.apply(this, arguments);
                };
              }
              function quoteString(value) {
                return typeof value === "string" ? JSON.stringify(value) : value;
              }
              function defaultZipper() {
                return arrCopy(arguments);
              }
              function defaultNegComparator(a, b) {
                return a < b ? 1 : a > b ? -1 : 0;
              }
              function hashIterable(iterable) {
                if (iterable.size === Infinity) {
                  return 0;
                }
                var ordered = isOrdered(iterable);
                var keyed = isKeyed(iterable);
                var h = ordered ? 1 : 0;
                var size = iterable.__iterate(keyed ? ordered ? function (v, k) {
                  h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
                } : function (v, k) {
                  h = h + hashMerge(hash(v), hash(k)) | 0;
                } : ordered ? function (v) {
                  h = 31 * h + hash(v) | 0;
                } : function (v) {
                  h = h + hash(v) | 0;
                });
                return murmurHashOfSize(size, h);
              }
              function murmurHashOfSize(size, h) {
                h = imul(h, 3432918353);
                h = imul(h << 15 | h >>> -15, 461845907);
                h = imul(h << 13 | h >>> -13, 5);
                h = (h + 3864292196 | 0) ^ size;
                h = imul(h ^ h >>> 16, 2246822507);
                h = imul(h ^ h >>> 13, 3266489909);
                h = smi(h ^ h >>> 16);
                return h;
              }
              function hashMerge(a, b) {
                return a ^ b + 2654435769 + (a << 6) + (a >> 2) | 0;
              }
              var Immutable = {
                Iterable,
                Seq,
                Collection,
                Map,
                OrderedMap,
                List,
                Stack,
                Set,
                OrderedSet,
                Record,
                Range,
                Repeat,
                is,
                fromJS
              };
              return Immutable;
            });
          })(immutable$1);
          return immutable$1.exports;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var BlockMapBuilder_1;
        var hasRequiredBlockMapBuilder;
        function requireBlockMapBuilder() {
          if (hasRequiredBlockMapBuilder) return BlockMapBuilder_1;
          hasRequiredBlockMapBuilder = 1;
          var Immutable = requireImmutable();
          var OrderedMap = Immutable.OrderedMap;
          var BlockMapBuilder = {
            createFromArray: function createFromArray(blocks) {
              return OrderedMap(blocks.map(function (block) {
                return [block.getKey(), block];
              }));
            }
          };
          BlockMapBuilder_1 = BlockMapBuilder;
          return BlockMapBuilder_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var CharacterMetadata_1;
        var hasRequiredCharacterMetadata;
        function requireCharacterMetadata() {
          if (hasRequiredCharacterMetadata) return CharacterMetadata_1;
          hasRequiredCharacterMetadata = 1;
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var _require = requireImmutable(),
            Map = _require.Map,
            OrderedSet = _require.OrderedSet,
            Record = _require.Record; // Immutable.map is typed such that the value for every key in the map
          // must be the same type

          var EMPTY_SET = OrderedSet();
          var defaultRecord = {
            style: EMPTY_SET,
            entity: null
          };
          var CharacterMetadataRecord = Record(defaultRecord);
          var CharacterMetadata = /*#__PURE__*/function (_CharacterMetadataRec) {
            _inheritsLoose(CharacterMetadata, _CharacterMetadataRec);
            function CharacterMetadata() {
              return _CharacterMetadataRec.apply(this, arguments) || this;
            }
            var _proto = CharacterMetadata.prototype;
            _proto.getStyle = function getStyle() {
              return this.get('style');
            };
            _proto.getEntity = function getEntity() {
              return this.get('entity');
            };
            _proto.hasStyle = function hasStyle(style) {
              return this.getStyle().includes(style);
            };
            CharacterMetadata.applyStyle = function applyStyle(record, style) {
              var withStyle = record.set('style', record.getStyle().add(style));
              return CharacterMetadata.create(withStyle);
            };
            CharacterMetadata.removeStyle = function removeStyle(record, style) {
              var withoutStyle = record.set('style', record.getStyle().remove(style));
              return CharacterMetadata.create(withoutStyle);
            };
            CharacterMetadata.applyEntity = function applyEntity(record, entityKey) {
              var withEntity = record.getEntity() === entityKey ? record : record.set('entity', entityKey);
              return CharacterMetadata.create(withEntity);
            }
            /**
             * Use this function instead of the `CharacterMetadata` constructor.
             * Since most content generally uses only a very small number of
             * style/entity permutations, we can reuse these objects as often as
             * possible.
             */;
            CharacterMetadata.create = function create(config) {
              if (!config) {
                return EMPTY;
              }
              var defaultConfig = {
                style: EMPTY_SET,
                entity: null
              }; // Fill in unspecified properties, if necessary.

              var configMap = Map(defaultConfig).merge(config);
              var existing = pool.get(configMap);
              if (existing) {
                return existing;
              }
              var newCharacter = new CharacterMetadata(configMap);
              pool = pool.set(configMap, newCharacter);
              return newCharacter;
            };
            CharacterMetadata.fromJS = function fromJS(_ref) {
              var style = _ref.style,
                entity = _ref.entity;
              return new CharacterMetadata({
                style: Array.isArray(style) ? OrderedSet(style) : style,
                entity: Array.isArray(entity) ? OrderedSet(entity) : entity
              });
            };
            return CharacterMetadata;
          }(CharacterMetadataRecord);
          var EMPTY = new CharacterMetadata();
          var pool = Map([[Map(defaultRecord), EMPTY]]);
          CharacterMetadata.EMPTY = EMPTY;
          CharacterMetadata_1 = CharacterMetadata;
          return CharacterMetadata_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var findRangesImmutable_1;
        var hasRequiredFindRangesImmutable;
        function requireFindRangesImmutable() {
          if (hasRequiredFindRangesImmutable) return findRangesImmutable_1;
          hasRequiredFindRangesImmutable = 1;

          /**
           * Search through an array to find contiguous stretches of elements that
           * match a specified filter function.
           *
           * When ranges are found, execute a specified `found` function to supply
           * the values to the caller.
           */
          function findRangesImmutable(haystack, areEqualFn, filterFn, foundFn) {
            if (!haystack.size) {
              return;
            }
            var cursor = 0;
            haystack.reduce(function (value, nextValue, nextIndex) {
              if (!areEqualFn(value, nextValue)) {
                if (filterFn(value)) {
                  foundFn(cursor, nextIndex);
                }
                cursor = nextIndex;
              }
              return nextValue;
            });
            filterFn(haystack.last()) && foundFn(cursor, haystack.count());
          }
          findRangesImmutable_1 = findRangesImmutable;
          return findRangesImmutable_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var ContentBlock_1;
        var hasRequiredContentBlock;
        function requireContentBlock() {
          if (hasRequiredContentBlock) return ContentBlock_1;
          hasRequiredContentBlock = 1;
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var CharacterMetadata = requireCharacterMetadata();
          var findRangesImmutable = requireFindRangesImmutable();
          var Immutable = requireImmutable();
          var List = Immutable.List,
            Map = Immutable.Map,
            OrderedSet = Immutable.OrderedSet,
            Record = Immutable.Record,
            Repeat = Immutable.Repeat;
          var EMPTY_SET = OrderedSet();
          var defaultRecord = {
            key: '',
            type: 'unstyled',
            text: '',
            characterList: List(),
            depth: 0,
            data: Map()
          };
          var ContentBlockRecord = Record(defaultRecord);
          var decorateCharacterList = function decorateCharacterList(config) {
            if (!config) {
              return config;
            }
            var characterList = config.characterList,
              text = config.text;
            if (text && !characterList) {
              config.characterList = List(Repeat(CharacterMetadata.EMPTY, text.length));
            }
            return config;
          };
          var ContentBlock = /*#__PURE__*/function (_ContentBlockRecord) {
            _inheritsLoose(ContentBlock, _ContentBlockRecord);
            function ContentBlock(config) {
              return _ContentBlockRecord.call(this, decorateCharacterList(config)) || this;
            }
            var _proto = ContentBlock.prototype;
            _proto.getKey = function getKey() {
              return this.get('key');
            };
            _proto.getType = function getType() {
              return this.get('type');
            };
            _proto.getText = function getText() {
              return this.get('text');
            };
            _proto.getCharacterList = function getCharacterList() {
              return this.get('characterList');
            };
            _proto.getLength = function getLength() {
              return this.getText().length;
            };
            _proto.getDepth = function getDepth() {
              return this.get('depth');
            };
            _proto.getData = function getData() {
              return this.get('data');
            };
            _proto.getInlineStyleAt = function getInlineStyleAt(offset) {
              var character = this.getCharacterList().get(offset);
              return character ? character.getStyle() : EMPTY_SET;
            };
            _proto.getEntityAt = function getEntityAt(offset) {
              var character = this.getCharacterList().get(offset);
              return character ? character.getEntity() : null;
            }
            /**
             * Execute a callback for every contiguous range of styles within the block.
             */;
            _proto.findStyleRanges = function findStyleRanges(filterFn, callback) {
              findRangesImmutable(this.getCharacterList(), haveEqualStyle, filterFn, callback);
            }
            /**
             * Execute a callback for every contiguous range of entities within the block.
             */;
            _proto.findEntityRanges = function findEntityRanges(filterFn, callback) {
              findRangesImmutable(this.getCharacterList(), haveEqualEntity, filterFn, callback);
            };
            return ContentBlock;
          }(ContentBlockRecord);
          function haveEqualStyle(charA, charB) {
            return charA.getStyle() === charB.getStyle();
          }
          function haveEqualEntity(charA, charB) {
            return charA.getEntity() === charB.getEntity();
          }
          ContentBlock_1 = ContentBlock;
          return ContentBlock_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         *
         * This file is a fork of ContentBlock adding support for nesting references by
         * providing links to children, parent, prevSibling, and nextSibling.
         *
         * This is unstable and not part of the public API and should not be used by
         * production systems. This file may be update/removed without notice.
         */

        var ContentBlockNode_1;
        var hasRequiredContentBlockNode;
        function requireContentBlockNode() {
          if (hasRequiredContentBlockNode) return ContentBlockNode_1;
          hasRequiredContentBlockNode = 1;
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var CharacterMetadata = requireCharacterMetadata();
          var findRangesImmutable = requireFindRangesImmutable();
          var Immutable = requireImmutable();
          var List = Immutable.List,
            Map = Immutable.Map,
            OrderedSet = Immutable.OrderedSet,
            Record = Immutable.Record,
            Repeat = Immutable.Repeat;
          var EMPTY_SET = OrderedSet();
          var defaultRecord = {
            parent: null,
            characterList: List(),
            data: Map(),
            depth: 0,
            key: '',
            text: '',
            type: 'unstyled',
            children: List(),
            prevSibling: null,
            nextSibling: null
          };
          var haveEqualStyle = function haveEqualStyle(charA, charB) {
            return charA.getStyle() === charB.getStyle();
          };
          var haveEqualEntity = function haveEqualEntity(charA, charB) {
            return charA.getEntity() === charB.getEntity();
          };
          var decorateCharacterList = function decorateCharacterList(config) {
            if (!config) {
              return config;
            }
            var characterList = config.characterList,
              text = config.text;
            if (text && !characterList) {
              config.characterList = List(Repeat(CharacterMetadata.EMPTY, text.length));
            }
            return config;
          };
          var ContentBlockNode = /*#__PURE__*/function (_ref) {
            _inheritsLoose(ContentBlockNode, _ref);
            function ContentBlockNode() {
              var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultRecord;

              /* eslint-disable-next-line constructor-super */
              return _ref.call(this, decorateCharacterList(props)) || this;
            }
            var _proto = ContentBlockNode.prototype;
            _proto.getKey = function getKey() {
              return this.get('key');
            };
            _proto.getType = function getType() {
              return this.get('type');
            };
            _proto.getText = function getText() {
              return this.get('text');
            };
            _proto.getCharacterList = function getCharacterList() {
              return this.get('characterList');
            };
            _proto.getLength = function getLength() {
              return this.getText().length;
            };
            _proto.getDepth = function getDepth() {
              return this.get('depth');
            };
            _proto.getData = function getData() {
              return this.get('data');
            };
            _proto.getInlineStyleAt = function getInlineStyleAt(offset) {
              var character = this.getCharacterList().get(offset);
              return character ? character.getStyle() : EMPTY_SET;
            };
            _proto.getEntityAt = function getEntityAt(offset) {
              var character = this.getCharacterList().get(offset);
              return character ? character.getEntity() : null;
            };
            _proto.getChildKeys = function getChildKeys() {
              return this.get('children');
            };
            _proto.getParentKey = function getParentKey() {
              return this.get('parent');
            };
            _proto.getPrevSiblingKey = function getPrevSiblingKey() {
              return this.get('prevSibling');
            };
            _proto.getNextSiblingKey = function getNextSiblingKey() {
              return this.get('nextSibling');
            };
            _proto.findStyleRanges = function findStyleRanges(filterFn, callback) {
              findRangesImmutable(this.getCharacterList(), haveEqualStyle, filterFn, callback);
            };
            _proto.findEntityRanges = function findEntityRanges(filterFn, callback) {
              findRangesImmutable(this.getCharacterList(), haveEqualEntity, filterFn, callback);
            };
            return ContentBlockNode;
          }(Record(defaultRecord));
          ContentBlockNode_1 = ContentBlockNode;
          return ContentBlockNode_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var ContentStateInlineStyle_1;
        var hasRequiredContentStateInlineStyle;
        function requireContentStateInlineStyle() {
          if (hasRequiredContentStateInlineStyle) return ContentStateInlineStyle_1;
          hasRequiredContentStateInlineStyle = 1;
          var CharacterMetadata = requireCharacterMetadata();
          var _require = requireImmutable(),
            Map = _require.Map;
          var ContentStateInlineStyle = {
            add: function add(contentState, selectionState, inlineStyle) {
              return modifyInlineStyle(contentState, selectionState, inlineStyle, true);
            },
            remove: function remove(contentState, selectionState, inlineStyle) {
              return modifyInlineStyle(contentState, selectionState, inlineStyle, false);
            }
          };
          function modifyInlineStyle(contentState, selectionState, inlineStyle, addOrRemove) {
            var blockMap = contentState.getBlockMap();
            var startKey = selectionState.getStartKey();
            var startOffset = selectionState.getStartOffset();
            var endKey = selectionState.getEndKey();
            var endOffset = selectionState.getEndOffset();
            var newBlocks = blockMap.skipUntil(function (_, k) {
              return k === startKey;
            }).takeUntil(function (_, k) {
              return k === endKey;
            }).concat(Map([[endKey, blockMap.get(endKey)]])).map(function (block, blockKey) {
              var sliceStart;
              var sliceEnd;
              if (startKey === endKey) {
                sliceStart = startOffset;
                sliceEnd = endOffset;
              } else {
                sliceStart = blockKey === startKey ? startOffset : 0;
                sliceEnd = blockKey === endKey ? endOffset : block.getLength();
              }
              var chars = block.getCharacterList();
              var current;
              while (sliceStart < sliceEnd) {
                current = chars.get(sliceStart);
                chars = chars.set(sliceStart, addOrRemove ? CharacterMetadata.applyStyle(current, inlineStyle) : CharacterMetadata.removeStyle(current, inlineStyle));
                sliceStart++;
              }
              return block.set('characterList', chars);
            });
            return contentState.merge({
              blockMap: blockMap.merge(newBlocks),
              selectionBefore: selectionState,
              selectionAfter: selectionState
            });
          }
          ContentStateInlineStyle_1 = ContentStateInlineStyle;
          return ContentStateInlineStyle_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var applyEntityToContentBlock_1;
        var hasRequiredApplyEntityToContentBlock;
        function requireApplyEntityToContentBlock() {
          if (hasRequiredApplyEntityToContentBlock) return applyEntityToContentBlock_1;
          hasRequiredApplyEntityToContentBlock = 1;
          var CharacterMetadata = requireCharacterMetadata();
          function applyEntityToContentBlock(contentBlock, startArg, end, entityKey) {
            var start = startArg;
            var characterList = contentBlock.getCharacterList();
            while (start < end) {
              characterList = characterList.set(start, CharacterMetadata.applyEntity(characterList.get(start), entityKey));
              start++;
            }
            return contentBlock.set('characterList', characterList);
          }
          applyEntityToContentBlock_1 = applyEntityToContentBlock;
          return applyEntityToContentBlock_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var applyEntityToContentState_1;
        var hasRequiredApplyEntityToContentState;
        function requireApplyEntityToContentState() {
          if (hasRequiredApplyEntityToContentState) return applyEntityToContentState_1;
          hasRequiredApplyEntityToContentState = 1;
          var applyEntityToContentBlock = requireApplyEntityToContentBlock();
          var Immutable = requireImmutable();
          function applyEntityToContentState(contentState, selectionState, entityKey) {
            var blockMap = contentState.getBlockMap();
            var startKey = selectionState.getStartKey();
            var startOffset = selectionState.getStartOffset();
            var endKey = selectionState.getEndKey();
            var endOffset = selectionState.getEndOffset();
            var newBlocks = blockMap.skipUntil(function (_, k) {
              return k === startKey;
            }).takeUntil(function (_, k) {
              return k === endKey;
            }).toOrderedMap().merge(Immutable.OrderedMap([[endKey, blockMap.get(endKey)]])).map(function (block, blockKey) {
              var sliceStart = blockKey === startKey ? startOffset : 0;
              var sliceEnd = blockKey === endKey ? endOffset : block.getLength();
              return applyEntityToContentBlock(block, sliceStart, sliceEnd, entityKey);
            });
            return contentState.merge({
              blockMap: blockMap.merge(newBlocks),
              selectionBefore: selectionState,
              selectionAfter: selectionState
            });
          }
          applyEntityToContentState_1 = applyEntityToContentState;
          return applyEntityToContentState_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DraftEntitySegments_1;
        var hasRequiredDraftEntitySegments;
        function requireDraftEntitySegments() {
          if (hasRequiredDraftEntitySegments) return DraftEntitySegments_1;
          hasRequiredDraftEntitySegments = 1;

          /**
           * Identify the range to delete from a segmented entity.
           *
           * Rules:
           *
           *  Example: 'John F. Kennedy'
           *
           *   - Deletion from within any non-whitespace (i.e. ['John', 'F.', 'Kennedy'])
           *     will return the range of that text.
           *
           *       'John F. Kennedy' -> 'John F.'
           *                  ^
           *
           *   - Forward deletion of whitespace will remove the following section:
           *
           *       'John F. Kennedy' -> 'John Kennedy'
           *            ^
           *
           *   - Backward deletion of whitespace will remove the previous section:
           *
           *       'John F. Kennedy' -> 'F. Kennedy'
           *            ^
           */
          var DraftEntitySegments = {
            getRemovalRange: function getRemovalRange(selectionStart, selectionEnd, text, entityStart, direction) {
              var segments = text.split(' ');
              segments = segments.map(function (/*string*/
              segment, /*number*/
              ii) {
                if (direction === 'forward') {
                  if (ii > 0) {
                    return ' ' + segment;
                  }
                } else if (ii < segments.length - 1) {
                  return segment + ' ';
                }
                return segment;
              });
              var segmentStart = entityStart;
              var segmentEnd;
              var segment;
              var removalStart = null;
              var removalEnd = null;
              for (var jj = 0; jj < segments.length; jj++) {
                segment = segments[jj];
                segmentEnd = segmentStart + segment.length; // Our selection overlaps this segment.

                if (selectionStart < segmentEnd && segmentStart < selectionEnd) {
                  if (removalStart !== null) {
                    removalEnd = segmentEnd;
                  } else {
                    removalStart = segmentStart;
                    removalEnd = segmentEnd;
                  }
                } else if (removalStart !== null) {
                  break;
                }
                segmentStart = segmentEnd;
              }
              var entityEnd = entityStart + text.length;
              var atStart = removalStart === entityStart;
              var atEnd = removalEnd === entityEnd;
              if (!atStart && atEnd || atStart && !atEnd) {
                if (direction === 'forward') {
                  if (removalEnd !== entityEnd) {
                    removalEnd++;
                  }
                } else if (removalStart !== entityStart) {
                  removalStart--;
                }
              }
              return {
                start: removalStart,
                end: removalEnd
              };
            }
          };
          DraftEntitySegments_1 = DraftEntitySegments;
          return DraftEntitySegments_1;
        }
        var invariant_1;
        var hasRequiredInvariant;
        function requireInvariant() {
          if (hasRequiredInvariant) return invariant_1;
          hasRequiredInvariant = 1;
          function invariant(condition, format) {
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            if (!condition) {
              var error;
              if (format === void 0) {
                error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
              } else {
                var argIndex = 0;
                error = new Error(format.replace(/%s/g, function () {
                  return String(args[argIndex++]);
                }));
                error.name = "Invariant Violation";
              }
              error.framesToPop = 1;
              throw error;
            }
          }
          invariant_1 = invariant;
          return invariant_1;
        }
        var getRangesForDraftEntity_1;
        var hasRequiredGetRangesForDraftEntity;
        function requireGetRangesForDraftEntity() {
          if (hasRequiredGetRangesForDraftEntity) return getRangesForDraftEntity_1;
          hasRequiredGetRangesForDraftEntity = 1;
          var invariant = requireInvariant();
          function getRangesForDraftEntity(block, key) {
            var ranges = [];
            block.findEntityRanges(function (c) {
              return c.getEntity() === key;
            }, function (start, end) {
              ranges.push({
                start,
                end
              });
            });
            !!!ranges.length ? invariant(false) : void 0;
            return ranges;
          }
          getRangesForDraftEntity_1 = getRangesForDraftEntity;
          return getRangesForDraftEntity_1;
        }
        var getCharacterRemovalRange_1;
        var hasRequiredGetCharacterRemovalRange;
        function requireGetCharacterRemovalRange() {
          if (hasRequiredGetCharacterRemovalRange) return getCharacterRemovalRange_1;
          hasRequiredGetCharacterRemovalRange = 1;
          var DraftEntitySegments = requireDraftEntitySegments();
          var getRangesForDraftEntity = requireGetRangesForDraftEntity();
          var invariant = requireInvariant();
          function getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {
            var start = selectionState.getStartOffset();
            var end = selectionState.getEndOffset();
            var startEntityKey = startBlock.getEntityAt(start);
            var endEntityKey = endBlock.getEntityAt(end - 1);
            if (!startEntityKey && !endEntityKey) {
              return selectionState;
            }
            var newSelectionState = selectionState;
            if (startEntityKey && startEntityKey === endEntityKey) {
              newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);
            } else if (startEntityKey && endEntityKey) {
              var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);
              var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);
              newSelectionState = newSelectionState.merge({
                anchorOffset: startSelectionState.getAnchorOffset(),
                focusOffset: endSelectionState.getFocusOffset(),
                isBackward: false
              });
            } else if (startEntityKey) {
              var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);
              newSelectionState = newSelectionState.merge({
                anchorOffset: _startSelectionState.getStartOffset(),
                isBackward: false
              });
            } else if (endEntityKey) {
              var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);
              newSelectionState = newSelectionState.merge({
                focusOffset: _endSelectionState.getEndOffset(),
                isBackward: false
              });
            }
            return newSelectionState;
          }
          function getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {
            var start = selectionState.getStartOffset();
            var end = selectionState.getEndOffset();
            var entity = entityMap.__get(entityKey);
            var mutability = entity.getMutability();
            var sideToConsider = isEntityAtStart ? start : end;
            if (mutability === "MUTABLE") {
              return selectionState;
            }
            var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {
              return sideToConsider <= range.end && sideToConsider >= range.start;
            });
            !(entityRanges.length == 1) ? invariant(false) : void 0;
            var entityRange = entityRanges[0];
            if (mutability === "IMMUTABLE") {
              return selectionState.merge({
                anchorOffset: entityRange.start,
                focusOffset: entityRange.end,
                isBackward: false
              });
            }
            if (!isEntireSelectionWithinEntity) {
              if (isEntityAtStart) {
                end = entityRange.end;
              } else {
                start = entityRange.start;
              }
            }
            var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);
            return selectionState.merge({
              anchorOffset: removalRange.start,
              focusOffset: removalRange.end,
              isBackward: false
            });
          }
          getCharacterRemovalRange_1 = getCharacterRemovalRange;
          return getCharacterRemovalRange_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var generateRandomKey_1;
        var hasRequiredGenerateRandomKey;
        function requireGenerateRandomKey() {
          if (hasRequiredGenerateRandomKey) return generateRandomKey_1;
          hasRequiredGenerateRandomKey = 1;
          var seenKeys = {};
          var MULTIPLIER = Math.pow(2, 24);
          function generateRandomKey() {
            var key;
            while (key === undefined || seenKeys.hasOwnProperty(key) || !isNaN(+key)) {
              key = Math.floor(Math.random() * MULTIPLIER).toString(32);
            }
            seenKeys[key] = true;
            return key;
          }
          generateRandomKey_1 = generateRandomKey;
          return generateRandomKey_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var randomizeBlockMapKeys_1;
        var hasRequiredRandomizeBlockMapKeys;
        function requireRandomizeBlockMapKeys() {
          if (hasRequiredRandomizeBlockMapKeys) return randomizeBlockMapKeys_1;
          hasRequiredRandomizeBlockMapKeys = 1;
          var ContentBlockNode = requireContentBlockNode();
          var generateRandomKey = requireGenerateRandomKey();
          var Immutable = requireImmutable();
          var OrderedMap = Immutable.OrderedMap;
          var randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys(blockMap) {
            var newKeysRef = {}; // we keep track of root blocks in order to update subsequent sibling links

            var lastRootBlock;
            return OrderedMap(blockMap.withMutations(function (blockMapState) {
              blockMapState.forEach(function (block, index) {
                var oldKey = block.getKey();
                var nextKey = block.getNextSiblingKey();
                var prevKey = block.getPrevSiblingKey();
                var childrenKeys = block.getChildKeys();
                var parentKey = block.getParentKey(); // new key that we will use to build linking

                var key = generateRandomKey(); // we will add it here to re-use it later

                newKeysRef[oldKey] = key;
                if (nextKey) {
                  var nextBlock = blockMapState.get(nextKey);
                  if (nextBlock) {
                    blockMapState.setIn([nextKey, 'prevSibling'], key);
                  } else {
                    // this can happen when generating random keys for fragments
                    blockMapState.setIn([oldKey, 'nextSibling'], null);
                  }
                }
                if (prevKey) {
                  var prevBlock = blockMapState.get(prevKey);
                  if (prevBlock) {
                    blockMapState.setIn([prevKey, 'nextSibling'], key);
                  } else {
                    // this can happen when generating random keys for fragments
                    blockMapState.setIn([oldKey, 'prevSibling'], null);
                  }
                }
                if (parentKey && blockMapState.get(parentKey)) {
                  var parentBlock = blockMapState.get(parentKey);
                  var parentChildrenList = parentBlock.getChildKeys();
                  blockMapState.setIn([parentKey, 'children'], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));
                } else {
                  // blocks will then be treated as root block nodes
                  blockMapState.setIn([oldKey, 'parent'], null);
                  if (lastRootBlock) {
                    blockMapState.setIn([lastRootBlock.getKey(), 'nextSibling'], key);
                    blockMapState.setIn([oldKey, 'prevSibling'], newKeysRef[lastRootBlock.getKey()]);
                  }
                  lastRootBlock = blockMapState.get(oldKey);
                }
                childrenKeys.forEach(function (childKey) {
                  var childBlock = blockMapState.get(childKey);
                  if (childBlock) {
                    blockMapState.setIn([childKey, 'parent'], key);
                  } else {
                    blockMapState.setIn([oldKey, 'children'], block.getChildKeys().filter(function (child) {
                      return child !== childKey;
                    }));
                  }
                });
              });
            }).toArray().map(function (block) {
              return [newKeysRef[block.getKey()], block.set('key', newKeysRef[block.getKey()])];
            }));
          };
          var randomizeContentBlockKeys = function randomizeContentBlockKeys(blockMap) {
            return OrderedMap(blockMap.toArray().map(function (block) {
              var key = generateRandomKey();
              return [key, block.set('key', key)];
            }));
          };
          var randomizeBlockMapKeys = function randomizeBlockMapKeys(blockMap) {
            var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;
            if (!isTreeBasedBlockMap) {
              return randomizeContentBlockKeys(blockMap);
            }
            return randomizeContentBlockNodeKeys(blockMap);
          };
          randomizeBlockMapKeys_1 = randomizeBlockMapKeys;
          return randomizeBlockMapKeys_1;
        }
        var removeEntitiesAtEdges_1;
        var hasRequiredRemoveEntitiesAtEdges;
        function requireRemoveEntitiesAtEdges() {
          if (hasRequiredRemoveEntitiesAtEdges) return removeEntitiesAtEdges_1;
          hasRequiredRemoveEntitiesAtEdges = 1;
          var CharacterMetadata = requireCharacterMetadata();
          var findRangesImmutable = requireFindRangesImmutable();
          var invariant = requireInvariant();
          function removeEntitiesAtEdges(contentState, selectionState) {
            var blockMap = contentState.getBlockMap();
            var entityMap = contentState.getEntityMap();
            var updatedBlocks = {};
            var startKey = selectionState.getStartKey();
            var startOffset = selectionState.getStartOffset();
            var startBlock = blockMap.get(startKey);
            var updatedStart = removeForBlock(entityMap, startBlock, startOffset);
            if (updatedStart !== startBlock) {
              updatedBlocks[startKey] = updatedStart;
            }
            var endKey = selectionState.getEndKey();
            var endOffset = selectionState.getEndOffset();
            var endBlock = blockMap.get(endKey);
            if (startKey === endKey) {
              endBlock = updatedStart;
            }
            var updatedEnd = removeForBlock(entityMap, endBlock, endOffset);
            if (updatedEnd !== endBlock) {
              updatedBlocks[endKey] = updatedEnd;
            }
            if (!Object.keys(updatedBlocks).length) {
              return contentState.set("selectionAfter", selectionState);
            }
            return contentState.merge({
              blockMap: blockMap.merge(updatedBlocks),
              selectionAfter: selectionState
            });
          }
          function getRemovalRange(characters, entityKey, offset) {
            var removalRange;
            findRangesImmutable(characters,
            // the list to iterate through
            function (a, b) {
              return a.getEntity() === b.getEntity();
            },
            // 'isEqual' callback
            function (element) {
              return element.getEntity() === entityKey;
            },
            // 'filter' callback
            function (start, end) {
              if (start <= offset && end >= offset) {
                removalRange = {
                  start,
                  end
                };
              }
            });
            !(typeof removalRange === "object") ? invariant(false) : void 0;
            return removalRange;
          }
          function removeForBlock(entityMap, block, offset) {
            var chars = block.getCharacterList();
            var charBefore = offset > 0 ? chars.get(offset - 1) : void 0;
            var charAfter = offset < chars.count() ? chars.get(offset) : void 0;
            var entityBeforeCursor = charBefore ? charBefore.getEntity() : void 0;
            var entityAfterCursor = charAfter ? charAfter.getEntity() : void 0;
            if (entityAfterCursor && entityAfterCursor === entityBeforeCursor) {
              var entity = entityMap.__get(entityAfterCursor);
              if (entity.getMutability() !== "MUTABLE") {
                var _getRemovalRange = getRemovalRange(chars, entityAfterCursor, offset),
                  start = _getRemovalRange.start,
                  end = _getRemovalRange.end;
                var current;
                while (start < end) {
                  current = chars.get(start);
                  chars = chars.set(start, CharacterMetadata.applyEntity(current, null));
                  start++;
                }
                return block.set("characterList", chars);
              }
            }
            return block;
          }
          removeEntitiesAtEdges_1 = removeEntitiesAtEdges;
          return removeEntitiesAtEdges_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var getContentStateFragment_1;
        var hasRequiredGetContentStateFragment;
        function requireGetContentStateFragment() {
          if (hasRequiredGetContentStateFragment) return getContentStateFragment_1;
          hasRequiredGetContentStateFragment = 1;
          var randomizeBlockMapKeys = requireRandomizeBlockMapKeys();
          var removeEntitiesAtEdges = requireRemoveEntitiesAtEdges();
          var getContentStateFragment = function getContentStateFragment(contentState, selectionState) {
            var startKey = selectionState.getStartKey();
            var startOffset = selectionState.getStartOffset();
            var endKey = selectionState.getEndKey();
            var endOffset = selectionState.getEndOffset(); // Edge entities should be stripped to ensure that we don't preserve
            // invalid partial entities when the fragment is reused. We do, however,
            // preserve entities that are entirely within the selection range.

            var contentWithoutEdgeEntities = removeEntitiesAtEdges(contentState, selectionState);
            var blockMap = contentWithoutEdgeEntities.getBlockMap();
            var blockKeys = blockMap.keySeq();
            var startIndex = blockKeys.indexOf(startKey);
            var endIndex = blockKeys.indexOf(endKey) + 1;
            return randomizeBlockMapKeys(blockMap.slice(startIndex, endIndex).map(function (block, blockKey) {
              var text = block.getText();
              var chars = block.getCharacterList();
              if (startKey === endKey) {
                return block.merge({
                  text: text.slice(startOffset, endOffset),
                  characterList: chars.slice(startOffset, endOffset)
                });
              }
              if (blockKey === startKey) {
                return block.merge({
                  text: text.slice(startOffset),
                  characterList: chars.slice(startOffset)
                });
              }
              if (blockKey === endKey) {
                return block.merge({
                  text: text.slice(0, endOffset),
                  characterList: chars.slice(0, endOffset)
                });
              }
              return block;
            }));
          };
          getContentStateFragment_1 = getContentStateFragment;
          return getContentStateFragment_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var insertIntoList_1;
        var hasRequiredInsertIntoList;
        function requireInsertIntoList() {
          if (hasRequiredInsertIntoList) return insertIntoList_1;
          hasRequiredInsertIntoList = 1;

          /**
           * Maintain persistence for target list when appending and prepending.
           */
          function insertIntoList(targetListArg, toInsert, offset) {
            var targetList = targetListArg;
            if (offset === targetList.count()) {
              toInsert.forEach(function (c) {
                targetList = targetList.push(c);
              });
            } else if (offset === 0) {
              toInsert.reverse().forEach(function (c) {
                targetList = targetList.unshift(c);
              });
            } else {
              var head = targetList.slice(0, offset);
              var tail = targetList.slice(offset);
              targetList = head.concat(toInsert, tail).toList();
            }
            return targetList;
          }
          insertIntoList_1 = insertIntoList;
          return insertIntoList_1;
        }
        var insertFragmentIntoContentState_1;
        var hasRequiredInsertFragmentIntoContentState;
        function requireInsertFragmentIntoContentState() {
          if (hasRequiredInsertFragmentIntoContentState) return insertFragmentIntoContentState_1;
          hasRequiredInsertFragmentIntoContentState = 1;
          var BlockMapBuilder = requireBlockMapBuilder();
          var ContentBlockNode = requireContentBlockNode();
          var Immutable = requireImmutable();
          var insertIntoList = requireInsertIntoList();
          var invariant = requireInvariant();
          var randomizeBlockMapKeys = requireRandomizeBlockMapKeys();
          var List = Immutable.List;
          var updateExistingBlock = function updateExistingBlock2(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {
            var mergeBlockData = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : "REPLACE_WITH_NEW_DATA";
            var targetBlock = blockMap.get(targetKey);
            var text = targetBlock.getText();
            var chars = targetBlock.getCharacterList();
            var finalKey = targetKey;
            var finalOffset = targetOffset + fragmentBlock.getText().length;
            var data = null;
            switch (mergeBlockData) {
              case "MERGE_OLD_DATA_TO_NEW_DATA":
                data = fragmentBlock.getData().merge(targetBlock.getData());
                break;
              case "REPLACE_WITH_NEW_DATA":
                data = fragmentBlock.getData();
                break;
            }
            var type = targetBlock.getType();
            if (text && type === "unstyled") {
              type = fragmentBlock.getType();
            }
            var newBlock = targetBlock.merge({
              text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),
              characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),
              type,
              data
            });
            return contentState.merge({
              blockMap: blockMap.set(targetKey, newBlock),
              selectionBefore: selectionState,
              selectionAfter: selectionState.merge({
                anchorKey: finalKey,
                anchorOffset: finalOffset,
                focusKey: finalKey,
                focusOffset: finalOffset,
                isBackward: false
              })
            });
          };
          var updateHead = function updateHead2(block, targetOffset, fragment) {
            var text = block.getText();
            var chars = block.getCharacterList();
            var headText = text.slice(0, targetOffset);
            var headCharacters = chars.slice(0, targetOffset);
            var appendToHead = fragment.first();
            return block.merge({
              text: headText + appendToHead.getText(),
              characterList: headCharacters.concat(appendToHead.getCharacterList()),
              type: headText ? block.getType() : appendToHead.getType(),
              data: appendToHead.getData()
            });
          };
          var updateTail = function updateTail2(block, targetOffset, fragment) {
            var text = block.getText();
            var chars = block.getCharacterList();
            var blockSize = text.length;
            var tailText = text.slice(targetOffset, blockSize);
            var tailCharacters = chars.slice(targetOffset, blockSize);
            var prependToTail = fragment.last();
            return prependToTail.merge({
              text: prependToTail.getText() + tailText,
              characterList: prependToTail.getCharacterList().concat(tailCharacters),
              data: prependToTail.getData()
            });
          };
          var getRootBlocks = function getRootBlocks2(block, blockMap) {
            var headKey = block.getKey();
            var rootBlock = block;
            var rootBlocks = [];
            if (blockMap.get(headKey)) {
              rootBlocks.push(headKey);
            }
            while (rootBlock && rootBlock.getNextSiblingKey()) {
              var lastSiblingKey = rootBlock.getNextSiblingKey();
              if (!lastSiblingKey) {
                break;
              }
              rootBlocks.push(lastSiblingKey);
              rootBlock = blockMap.get(lastSiblingKey);
            }
            return rootBlocks;
          };
          var updateBlockMapLinks = function updateBlockMapLinks2(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {
            return blockMap.withMutations(function (blockMapState) {
              var targetKey = targetBlock.getKey();
              var headKey = fragmentHeadBlock.getKey();
              var targetNextKey = targetBlock.getNextSiblingKey();
              var targetParentKey = targetBlock.getParentKey();
              var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);
              var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];
              if (blockMapState.get(headKey)) {
                blockMapState.setIn([targetKey, "nextSibling"], headKey);
                blockMapState.setIn([headKey, "prevSibling"], targetKey);
              } else {
                blockMapState.setIn([targetKey, "nextSibling"], fragmentHeadBlock.getNextSiblingKey());
                blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), "prevSibling"], targetKey);
              }
              blockMapState.setIn([lastRootFragmentBlockKey, "nextSibling"], targetNextKey);
              if (targetNextKey) {
                blockMapState.setIn([targetNextKey, "prevSibling"], lastRootFragmentBlockKey);
              }
              fragmentRootBlocks.forEach(function (blockKey) {
                return blockMapState.setIn([blockKey, "parent"], targetParentKey);
              });
              if (targetParentKey) {
                var targetParent = blockMap.get(targetParentKey);
                var originalTargetParentChildKeys = targetParent.getChildKeys();
                var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);
                var insertionIndex = targetBlockIndex + 1;
                var newChildrenKeysArray = originalTargetParentChildKeys.toArray();
                newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));
                blockMapState.setIn([targetParentKey, "children"], List(newChildrenKeysArray));
              }
            });
          };
          var insertFragment = function insertFragment2(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {
            var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;
            var newBlockArr = [];
            var fragmentSize = fragment.size;
            var target = blockMap.get(targetKey);
            var head = fragment.first();
            var tail = fragment.last();
            var finalOffset = tail.getLength();
            var finalKey = tail.getKey();
            var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());
            blockMap.forEach(function (block, blockKey) {
              if (blockKey !== targetKey) {
                newBlockArr.push(block);
                return;
              }
              if (shouldNotUpdateFromFragmentBlock) {
                newBlockArr.push(block);
              } else {
                newBlockArr.push(updateHead(block, targetOffset, fragment));
              }
              fragment.slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {
                return newBlockArr.push(fragmentBlock);
              });
              newBlockArr.push(updateTail(block, targetOffset, fragment));
            });
            var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);
            if (isTreeBasedBlockMap) {
              updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);
            }
            return contentState.merge({
              blockMap: updatedBlockMap,
              selectionBefore: selectionState,
              selectionAfter: selectionState.merge({
                anchorKey: finalKey,
                anchorOffset: finalOffset,
                focusKey: finalKey,
                focusOffset: finalOffset,
                isBackward: false
              })
            });
          };
          var insertFragmentIntoContentState = function insertFragmentIntoContentState2(contentState, selectionState, fragmentBlockMap) {
            var mergeBlockData = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "REPLACE_WITH_NEW_DATA";
            !selectionState.isCollapsed() ? invariant(false) : void 0;
            var blockMap = contentState.getBlockMap();
            var fragment = randomizeBlockMapKeys(fragmentBlockMap);
            var targetKey = selectionState.getStartKey();
            var targetOffset = selectionState.getStartOffset();
            var targetBlock = blockMap.get(targetKey);
            if (targetBlock instanceof ContentBlockNode) {
              !targetBlock.getChildKeys().isEmpty() ? invariant(false) : void 0;
            }
            if (fragment.size === 1) {
              return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset, mergeBlockData);
            }
            return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);
          };
          insertFragmentIntoContentState_1 = insertFragmentIntoContentState;
          return insertFragmentIntoContentState_1;
        }
        var insertTextIntoContentState_1;
        var hasRequiredInsertTextIntoContentState;
        function requireInsertTextIntoContentState() {
          if (hasRequiredInsertTextIntoContentState) return insertTextIntoContentState_1;
          hasRequiredInsertTextIntoContentState = 1;
          var Immutable = requireImmutable();
          var insertIntoList = requireInsertIntoList();
          var invariant = requireInvariant();
          var Repeat = Immutable.Repeat;
          function insertTextIntoContentState(contentState, selectionState, text, characterMetadata) {
            !selectionState.isCollapsed() ? invariant(false) : void 0;
            var len = null;
            if (text != null) {
              len = text.length;
            }
            if (len == null || len === 0) {
              return contentState;
            }
            var blockMap = contentState.getBlockMap();
            var key = selectionState.getStartKey();
            var offset = selectionState.getStartOffset();
            var block = blockMap.get(key);
            var blockText = block.getText();
            var newBlock = block.merge({
              text: blockText.slice(0, offset) + text + blockText.slice(offset, block.getLength()),
              characterList: insertIntoList(block.getCharacterList(), Repeat(characterMetadata, len).toList(), offset)
            });
            var newOffset = offset + len;
            return contentState.merge({
              blockMap: blockMap.set(key, newBlock),
              selectionAfter: selectionState.merge({
                anchorOffset: newOffset,
                focusOffset: newOffset
              })
            });
          }
          insertTextIntoContentState_1 = insertTextIntoContentState;
          return insertTextIntoContentState_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var modifyBlockForContentState_1;
        var hasRequiredModifyBlockForContentState;
        function requireModifyBlockForContentState() {
          if (hasRequiredModifyBlockForContentState) return modifyBlockForContentState_1;
          hasRequiredModifyBlockForContentState = 1;
          var Immutable = requireImmutable();
          var Map = Immutable.Map;
          function modifyBlockForContentState(contentState, selectionState, operation) {
            var startKey = selectionState.getStartKey();
            var endKey = selectionState.getEndKey();
            var blockMap = contentState.getBlockMap();
            var newBlocks = blockMap.toSeq().skipUntil(function (_, k) {
              return k === startKey;
            }).takeUntil(function (_, k) {
              return k === endKey;
            }).concat(Map([[endKey, blockMap.get(endKey)]])).map(operation);
            return contentState.merge({
              blockMap: blockMap.merge(newBlocks),
              selectionBefore: selectionState,
              selectionAfter: selectionState
            });
          }
          modifyBlockForContentState_1 = modifyBlockForContentState;
          return modifyBlockForContentState_1;
        }
        var getNextDelimiterBlockKey_1;
        var hasRequiredGetNextDelimiterBlockKey;
        function requireGetNextDelimiterBlockKey() {
          if (hasRequiredGetNextDelimiterBlockKey) return getNextDelimiterBlockKey_1;
          hasRequiredGetNextDelimiterBlockKey = 1;

          /**
           * Copyright (c) Facebook, Inc. and its affiliates.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @format
           * 
           * @emails oncall+draft_js
           *
           * This is unstable and not part of the public API and should not be used by
           * production systems. This file may be update/removed without notice.
           */
          var ContentBlockNode = requireContentBlockNode();
          var getNextDelimiterBlockKey = function getNextDelimiterBlockKey(block, blockMap) {
            var isExperimentalTreeBlock = block instanceof ContentBlockNode;
            if (!isExperimentalTreeBlock) {
              return null;
            }
            var nextSiblingKey = block.getNextSiblingKey();
            if (nextSiblingKey) {
              return nextSiblingKey;
            }
            var parent = block.getParentKey();
            if (!parent) {
              return null;
            }
            var nextNonDescendantBlock = blockMap.get(parent);
            while (nextNonDescendantBlock && !nextNonDescendantBlock.getNextSiblingKey()) {
              var parentKey = nextNonDescendantBlock.getParentKey();
              nextNonDescendantBlock = parentKey ? blockMap.get(parentKey) : null;
            }
            if (!nextNonDescendantBlock) {
              return null;
            }
            return nextNonDescendantBlock.getNextSiblingKey();
          };
          getNextDelimiterBlockKey_1 = getNextDelimiterBlockKey;
          return getNextDelimiterBlockKey_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var removeRangeFromContentState_1;
        var hasRequiredRemoveRangeFromContentState;
        function requireRemoveRangeFromContentState() {
          if (hasRequiredRemoveRangeFromContentState) return removeRangeFromContentState_1;
          hasRequiredRemoveRangeFromContentState = 1;
          var ContentBlockNode = requireContentBlockNode();
          var getNextDelimiterBlockKey = requireGetNextDelimiterBlockKey();
          var Immutable = requireImmutable();
          Immutable.List;
          var Map = Immutable.Map;
          var transformBlock = function transformBlock(key, blockMap, func) {
            if (!key) {
              return;
            }
            var block = blockMap.get(key);
            if (!block) {
              return;
            }
            blockMap.set(key, func(block));
          };
          /**
           * Ancestors needs to be preserved when there are non selected
           * children to make sure we do not leave any orphans behind
           */

          var getAncestorsKeys = function getAncestorsKeys(blockKey, blockMap) {
            var parents = [];
            if (!blockKey) {
              return parents;
            }
            var blockNode = blockMap.get(blockKey);
            while (blockNode && blockNode.getParentKey()) {
              var parentKey = blockNode.getParentKey();
              if (parentKey) {
                parents.push(parentKey);
              }
              blockNode = parentKey ? blockMap.get(parentKey) : null;
            }
            return parents;
          };
          /**
           * Get all next delimiter keys until we hit a root delimiter and return
           * an array of key references
           */

          var getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys(block, blockMap) {
            var nextDelimiters = [];
            if (!block) {
              return nextDelimiters;
            }
            var nextDelimiter = getNextDelimiterBlockKey(block, blockMap);
            while (nextDelimiter && blockMap.get(nextDelimiter)) {
              var _block = blockMap.get(nextDelimiter);
              nextDelimiters.push(nextDelimiter); // we do not need to keep checking all root node siblings, just the first occurance

              nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey(_block, blockMap) : null;
            }
            return nextDelimiters;
          };
          var getNextValidSibling = function getNextValidSibling(block, blockMap, originalBlockMap) {
            if (!block) {
              return null;
            } // note that we need to make sure we refer to the original block since this
            // function is called within a withMutations

            var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();
            while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {
              nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;
            }
            return nextValidSiblingKey;
          };
          var getPrevValidSibling = function getPrevValidSibling(block, blockMap, originalBlockMap) {
            if (!block) {
              return null;
            } // note that we need to make sure we refer to the original block since this
            // function is called within a withMutations

            var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();
            while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {
              prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;
            }
            return prevValidSiblingKey;
          };
          var updateBlockMapLinks = function updateBlockMapLinks(blockMap, startBlock, endBlock, originalBlockMap) {
            return blockMap.withMutations(function (blocks) {
              // update start block if its retained
              transformBlock(startBlock.getKey(), blocks, function (block) {
                return block.merge({
                  nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
                  prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
                });
              }); // update endblock if its retained

              transformBlock(endBlock.getKey(), blocks, function (block) {
                return block.merge({
                  nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
                  prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
                });
              }); // update start block parent ancestors

              getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function (parentKey) {
                return transformBlock(parentKey, blocks, function (block) {
                  return block.merge({
                    children: block.getChildKeys().filter(function (key) {
                      return blocks.get(key);
                    }),
                    nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
                    prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
                  });
                });
              }); // update start block next - can only happen if startBlock == endBlock

              transformBlock(startBlock.getNextSiblingKey(), blocks, function (block) {
                return block.merge({
                  prevSibling: startBlock.getPrevSiblingKey()
                });
              }); // update start block prev

              transformBlock(startBlock.getPrevSiblingKey(), blocks, function (block) {
                return block.merge({
                  nextSibling: getNextValidSibling(block, blocks, originalBlockMap)
                });
              }); // update end block next

              transformBlock(endBlock.getNextSiblingKey(), blocks, function (block) {
                return block.merge({
                  prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
                });
              }); // update end block prev

              transformBlock(endBlock.getPrevSiblingKey(), blocks, function (block) {
                return block.merge({
                  nextSibling: endBlock.getNextSiblingKey()
                });
              }); // update end block parent ancestors

              getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function (parentKey) {
                transformBlock(parentKey, blocks, function (block) {
                  return block.merge({
                    children: block.getChildKeys().filter(function (key) {
                      return blocks.get(key);
                    }),
                    nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
                    prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
                  });
                });
              }); // update next delimiters all the way to a root delimiter

              getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function (delimiterKey) {
                return transformBlock(delimiterKey, blocks, function (block) {
                  return block.merge({
                    nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
                    prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
                  });
                });
              }); // if parent (startBlock) was deleted

              if (blockMap.get(startBlock.getKey()) == null && blockMap.get(endBlock.getKey()) != null && endBlock.getParentKey() === startBlock.getKey() && endBlock.getPrevSiblingKey() == null) {
                var prevSiblingKey = startBlock.getPrevSiblingKey(); // endBlock becomes next sibling of parent's prevSibling

                transformBlock(endBlock.getKey(), blocks, function (block) {
                  return block.merge({
                    prevSibling: prevSiblingKey
                  });
                });
                transformBlock(prevSiblingKey, blocks, function (block) {
                  return block.merge({
                    nextSibling: endBlock.getKey()
                  });
                }); // Update parent for previous parent's children, and children for that parent

                var prevSibling = prevSiblingKey ? blockMap.get(prevSiblingKey) : null;
                var newParentKey = prevSibling ? prevSibling.getParentKey() : null;
                startBlock.getChildKeys().forEach(function (childKey) {
                  transformBlock(childKey, blocks, function (block) {
                    return block.merge({
                      parent: newParentKey // set to null if there is no parent
                    });
                  });
                });
                if (newParentKey != null) {
                  var newParent = blockMap.get(newParentKey);
                  transformBlock(newParentKey, blocks, function (block) {
                    return block.merge({
                      children: newParent.getChildKeys().concat(startBlock.getChildKeys())
                    });
                  });
                } // last child of deleted parent should point to next sibling

                transformBlock(startBlock.getChildKeys().find(function (key) {
                  var block = blockMap.get(key);
                  return block.getNextSiblingKey() === null;
                }), blocks, function (block) {
                  return block.merge({
                    nextSibling: startBlock.getNextSiblingKey()
                  });
                });
              }
            });
          };
          var removeRangeFromContentState = function removeRangeFromContentState(contentState, selectionState) {
            if (selectionState.isCollapsed()) {
              return contentState;
            }
            var blockMap = contentState.getBlockMap();
            var startKey = selectionState.getStartKey();
            var startOffset = selectionState.getStartOffset();
            var endKey = selectionState.getEndKey();
            var endOffset = selectionState.getEndOffset();
            var startBlock = blockMap.get(startKey);
            var endBlock = blockMap.get(endKey); // we assume that ContentBlockNode and ContentBlocks are not mixed together

            var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode; // used to retain blocks that should not be deleted to avoid orphan children

            var parentAncestors = [];
            if (isExperimentalTreeBlock) {
              var endBlockchildrenKeys = endBlock.getChildKeys();
              var endBlockAncestors = getAncestorsKeys(endKey, blockMap); // endBlock has unselected siblings so we can not remove its ancestors parents

              if (endBlock.getNextSiblingKey()) {
                parentAncestors = parentAncestors.concat(endBlockAncestors);
              } // endBlock has children so can not remove this block or any of its ancestors

              if (!endBlockchildrenKeys.isEmpty()) {
                parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));
              } // we need to retain all ancestors of the next delimiter block

              parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock, blockMap), blockMap));
            }
            var characterList;
            if (startBlock === endBlock) {
              characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);
            } else {
              characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));
            }
            var modifiedStart = startBlock.merge({
              text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),
              characterList: characterList
            }); // If cursor (collapsed) is at the start of the first child, delete parent
            // instead of child

            var shouldDeleteParent = isExperimentalTreeBlock && startOffset === 0 && endOffset === 0 && endBlock.getParentKey() === startKey && endBlock.getPrevSiblingKey() == null;
            var newBlocks = shouldDeleteParent ? Map([[startKey, null]]) : blockMap.toSeq().skipUntil(function (_, k) {
              return k === startKey;
            }).takeUntil(function (_, k) {
              return k === endKey;
            }).filter(function (_, k) {
              return parentAncestors.indexOf(k) === -1;
            }).concat(Map([[endKey, null]])).map(function (_, k) {
              return k === startKey ? modifiedStart : null;
            });
            var updatedBlockMap = blockMap.merge(newBlocks).filter(function (block) {
              return !!block;
            }); // Only update tree block pointers if the range is across blocks

            if (isExperimentalTreeBlock && startBlock !== endBlock) {
              updatedBlockMap = updateBlockMapLinks(updatedBlockMap, startBlock, endBlock, blockMap);
            }
            return contentState.merge({
              blockMap: updatedBlockMap,
              selectionBefore: selectionState,
              selectionAfter: selectionState.merge({
                anchorKey: startKey,
                anchorOffset: startOffset,
                focusKey: startKey,
                focusOffset: startOffset,
                isBackward: false
              })
            });
          };
          /**
           * Maintain persistence for target list when removing characters on the
           * head and tail of the character list.
           */

          var removeFromList = function removeFromList(targetList, startOffset, endOffset) {
            if (startOffset === 0) {
              while (startOffset < endOffset) {
                targetList = targetList.shift();
                startOffset++;
              }
            } else if (endOffset === targetList.count()) {
              while (endOffset > startOffset) {
                targetList = targetList.pop();
                endOffset--;
              }
            } else {
              var head = targetList.slice(0, startOffset);
              var tail = targetList.slice(endOffset);
              targetList = head.concat(tail).toList();
            }
            return targetList;
          };
          removeRangeFromContentState_1 = removeRangeFromContentState;
          return removeRangeFromContentState_1;
        }
        var splitBlockInContentState_1;
        var hasRequiredSplitBlockInContentState;
        function requireSplitBlockInContentState() {
          if (hasRequiredSplitBlockInContentState) return splitBlockInContentState_1;
          hasRequiredSplitBlockInContentState = 1;
          var ContentBlockNode = requireContentBlockNode();
          var generateRandomKey = requireGenerateRandomKey();
          var Immutable = requireImmutable();
          var invariant = requireInvariant();
          var modifyBlockForContentState = requireModifyBlockForContentState();
          var List = Immutable.List,
            Map = Immutable.Map;
          var transformBlock = function transformBlock2(key, blockMap, func) {
            if (!key) {
              return;
            }
            var block = blockMap.get(key);
            if (!block) {
              return;
            }
            blockMap.set(key, func(block));
          };
          var updateBlockMapLinks = function updateBlockMapLinks2(blockMap, originalBlock, belowBlock) {
            return blockMap.withMutations(function (blocks) {
              var originalBlockKey = originalBlock.getKey();
              var belowBlockKey = belowBlock.getKey();
              transformBlock(originalBlock.getParentKey(), blocks, function (block) {
                var parentChildrenList = block.getChildKeys();
                var insertionIndex = parentChildrenList.indexOf(originalBlockKey) + 1;
                var newChildrenArray = parentChildrenList.toArray();
                newChildrenArray.splice(insertionIndex, 0, belowBlockKey);
                return block.merge({
                  children: List(newChildrenArray)
                });
              });
              transformBlock(originalBlock.getNextSiblingKey(), blocks, function (block) {
                return block.merge({
                  prevSibling: belowBlockKey
                });
              });
              transformBlock(originalBlockKey, blocks, function (block) {
                return block.merge({
                  nextSibling: belowBlockKey
                });
              });
              transformBlock(belowBlockKey, blocks, function (block) {
                return block.merge({
                  prevSibling: originalBlockKey
                });
              });
            });
          };
          var splitBlockInContentState = function splitBlockInContentState2(contentState, selectionState) {
            !selectionState.isCollapsed() ? invariant(false) : void 0;
            var key = selectionState.getAnchorKey();
            var blockMap = contentState.getBlockMap();
            var blockToSplit = blockMap.get(key);
            var text = blockToSplit.getText();
            if (!text) {
              var blockType = blockToSplit.getType();
              if (blockType === "unordered-list-item" || blockType === "ordered-list-item") {
                return modifyBlockForContentState(contentState, selectionState, function (block) {
                  return block.merge({
                    type: "unstyled",
                    depth: 0
                  });
                });
              }
            }
            var offset = selectionState.getAnchorOffset();
            var chars = blockToSplit.getCharacterList();
            var keyBelow = generateRandomKey();
            var isExperimentalTreeBlock = blockToSplit instanceof ContentBlockNode;
            var blockAbove = blockToSplit.merge({
              text: text.slice(0, offset),
              characterList: chars.slice(0, offset)
            });
            var blockBelow = blockAbove.merge({
              key: keyBelow,
              text: text.slice(offset),
              characterList: chars.slice(offset),
              data: Map()
            });
            var blocksBefore = blockMap.toSeq().takeUntil(function (v) {
              return v === blockToSplit;
            });
            var blocksAfter = blockMap.toSeq().skipUntil(function (v) {
              return v === blockToSplit;
            }).rest();
            var newBlocks = blocksBefore.concat([[key, blockAbove], [keyBelow, blockBelow]], blocksAfter).toOrderedMap();
            if (isExperimentalTreeBlock) {
              !blockToSplit.getChildKeys().isEmpty() ? invariant(false) : void 0;
              newBlocks = updateBlockMapLinks(newBlocks, blockAbove, blockBelow);
            }
            return contentState.merge({
              blockMap: newBlocks,
              selectionBefore: selectionState,
              selectionAfter: selectionState.merge({
                anchorKey: keyBelow,
                anchorOffset: 0,
                focusKey: keyBelow,
                focusOffset: 0,
                isBackward: false
              })
            });
          };
          splitBlockInContentState_1 = splitBlockInContentState;
          return splitBlockInContentState_1;
        }
        var DraftModifier_1;
        var hasRequiredDraftModifier;
        function requireDraftModifier() {
          if (hasRequiredDraftModifier) return DraftModifier_1;
          hasRequiredDraftModifier = 1;
          var CharacterMetadata = requireCharacterMetadata();
          var ContentStateInlineStyle = requireContentStateInlineStyle();
          var applyEntityToContentState = requireApplyEntityToContentState();
          var getCharacterRemovalRange = requireGetCharacterRemovalRange();
          var getContentStateFragment = requireGetContentStateFragment();
          var Immutable = requireImmutable();
          var insertFragmentIntoContentState = requireInsertFragmentIntoContentState();
          var insertTextIntoContentState = requireInsertTextIntoContentState();
          var invariant = requireInvariant();
          var modifyBlockForContentState = requireModifyBlockForContentState();
          var removeEntitiesAtEdges = requireRemoveEntitiesAtEdges();
          var removeRangeFromContentState = requireRemoveRangeFromContentState();
          var splitBlockInContentState = requireSplitBlockInContentState();
          var OrderedSet = Immutable.OrderedSet;
          var DraftModifier = {
            replaceText: function replaceText(contentState, rangeToReplace, text, inlineStyle, entityKey) {
              var withoutEntities = removeEntitiesAtEdges(contentState, rangeToReplace);
              var withoutText = removeRangeFromContentState(withoutEntities, rangeToReplace);
              var character = CharacterMetadata.create({
                style: inlineStyle || OrderedSet(),
                entity: entityKey || null
              });
              return insertTextIntoContentState(withoutText, withoutText.getSelectionAfter(), text, character);
            },
            insertText: function insertText(contentState, targetRange, text, inlineStyle, entityKey) {
              !targetRange.isCollapsed() ? invariant(false) : void 0;
              return DraftModifier.replaceText(contentState, targetRange, text, inlineStyle, entityKey);
            },
            moveText: function moveText(contentState, removalRange, targetRange) {
              var movedFragment = getContentStateFragment(contentState, removalRange);
              var afterRemoval = DraftModifier.removeRange(contentState, removalRange, "backward");
              return DraftModifier.replaceWithFragment(afterRemoval, targetRange, movedFragment);
            },
            replaceWithFragment: function replaceWithFragment(contentState, targetRange, fragment) {
              var mergeBlockData2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "REPLACE_WITH_NEW_DATA";
              var withoutEntities = removeEntitiesAtEdges(contentState, targetRange);
              var withoutText = removeRangeFromContentState(withoutEntities, targetRange);
              return insertFragmentIntoContentState(withoutText, withoutText.getSelectionAfter(), fragment, mergeBlockData2);
            },
            removeRange: function removeRange(contentState, rangeToRemove, removalDirection) {
              var startKey, endKey, startBlock, endBlock;
              if (rangeToRemove.getIsBackward()) {
                rangeToRemove = rangeToRemove.merge({
                  anchorKey: rangeToRemove.getFocusKey(),
                  anchorOffset: rangeToRemove.getFocusOffset(),
                  focusKey: rangeToRemove.getAnchorKey(),
                  focusOffset: rangeToRemove.getAnchorOffset(),
                  isBackward: false
                });
              }
              startKey = rangeToRemove.getAnchorKey();
              endKey = rangeToRemove.getFocusKey();
              startBlock = contentState.getBlockForKey(startKey);
              endBlock = contentState.getBlockForKey(endKey);
              var startOffset = rangeToRemove.getStartOffset();
              var endOffset = rangeToRemove.getEndOffset();
              var startEntityKey = startBlock.getEntityAt(startOffset);
              var endEntityKey = endBlock.getEntityAt(endOffset - 1);
              if (startKey === endKey) {
                if (startEntityKey && startEntityKey === endEntityKey) {
                  var adjustedRemovalRange = getCharacterRemovalRange(contentState.getEntityMap(), startBlock, endBlock, rangeToRemove, removalDirection);
                  return removeRangeFromContentState(contentState, adjustedRemovalRange);
                }
              }
              var withoutEntities = removeEntitiesAtEdges(contentState, rangeToRemove);
              return removeRangeFromContentState(withoutEntities, rangeToRemove);
            },
            splitBlock: function splitBlock(contentState, selectionState) {
              var withoutEntities = removeEntitiesAtEdges(contentState, selectionState);
              var withoutText = removeRangeFromContentState(withoutEntities, selectionState);
              return splitBlockInContentState(withoutText, withoutText.getSelectionAfter());
            },
            applyInlineStyle: function applyInlineStyle(contentState, selectionState, inlineStyle) {
              return ContentStateInlineStyle.add(contentState, selectionState, inlineStyle);
            },
            removeInlineStyle: function removeInlineStyle(contentState, selectionState, inlineStyle) {
              return ContentStateInlineStyle.remove(contentState, selectionState, inlineStyle);
            },
            setBlockType: function setBlockType(contentState, selectionState, blockType) {
              return modifyBlockForContentState(contentState, selectionState, function (block) {
                return block.merge({
                  type: blockType,
                  depth: 0
                });
              });
            },
            setBlockData: function setBlockData(contentState, selectionState, blockData) {
              return modifyBlockForContentState(contentState, selectionState, function (block) {
                return block.merge({
                  data: blockData
                });
              });
            },
            mergeBlockData: function mergeBlockData(contentState, selectionState, blockData) {
              return modifyBlockForContentState(contentState, selectionState, function (block) {
                return block.merge({
                  data: block.getData().merge(blockData)
                });
              });
            },
            applyEntity: function applyEntity(contentState, selectionState, entityKey) {
              var withoutEntities = removeEntitiesAtEdges(contentState, selectionState);
              return applyEntityToContentState(withoutEntities, selectionState, entityKey);
            }
          };
          DraftModifier_1 = DraftModifier;
          return DraftModifier_1;
        }
        var getOwnObjectValues_1;
        var hasRequiredGetOwnObjectValues;
        function requireGetOwnObjectValues() {
          if (hasRequiredGetOwnObjectValues) return getOwnObjectValues_1;
          hasRequiredGetOwnObjectValues = 1;

          /**
           * Copyright 2004-present Facebook. All Rights Reserved.
           *
           * 
           * @typechecks
           * @format
           */

          /**
           * Retrieve an object's own values as an array. If you want the values in the
           * protoype chain, too, use getObjectValuesIncludingPrototype.
           *
           * If you are looking for a function that creates an Array instance based
           * on an "Array-like" object, use createArrayFrom instead.
           *
           * @param {object} obj An object.
           * @return {array}     The object's values.
           */
          function getOwnObjectValues(obj) {
            return Object.keys(obj).map(function (key) {
              return obj[key];
            });
          }
          getOwnObjectValues_1 = getOwnObjectValues;
          return getOwnObjectValues_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var BlockTree_1;
        var hasRequiredBlockTree;
        function requireBlockTree() {
          if (hasRequiredBlockTree) return BlockTree_1;
          hasRequiredBlockTree = 1;
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _objectWithoutPropertiesLoose(source, excluded) {
            if (source == null) return {};
            var target = {};
            var sourceKeys = Object.keys(source);
            var key, i;
            for (i = 0; i < sourceKeys.length; i++) {
              key = sourceKeys[i];
              if (excluded.indexOf(key) >= 0) continue;
              target[key] = source[key];
            }
            return target;
          }
          var findRangesImmutable = requireFindRangesImmutable();
          var getOwnObjectValues = requireGetOwnObjectValues();
          var Immutable = requireImmutable();
          var List = Immutable.List,
            Repeat = Immutable.Repeat,
            Record = Immutable.Record;
          var returnTrue = function returnTrue() {
            return true;
          };
          var defaultLeafRange = {
            start: null,
            end: null
          };
          var LeafRange = Record(defaultLeafRange);
          var defaultDecoratorRange = {
            start: null,
            end: null,
            decoratorKey: null,
            leaves: null
          };
          var DecoratorRange = Record(defaultDecoratorRange);
          var BlockTree = {
            /**
             * Generate a block tree for a given ContentBlock/decorator pair.
             */
            generate: function generate(contentState, block, decorator) {
              var textLength = block.getLength();
              if (!textLength) {
                return List.of(new DecoratorRange({
                  start: 0,
                  end: 0,
                  decoratorKey: null,
                  leaves: List.of(new LeafRange({
                    start: 0,
                    end: 0
                  }))
                }));
              }
              var leafSets = [];
              var decorations = decorator ? decorator.getDecorations(block, contentState) : List(Repeat(null, textLength));
              var chars = block.getCharacterList();
              findRangesImmutable(decorations, areEqual, returnTrue, function (start, end) {
                leafSets.push(new DecoratorRange({
                  start: start,
                  end: end,
                  decoratorKey: decorations.get(start),
                  leaves: generateLeaves(chars.slice(start, end).toList(), start)
                }));
              });
              return List(leafSets);
            },
            fromJS: function fromJS(_ref) {
              var leaves = _ref.leaves,
                other = _objectWithoutPropertiesLoose(_ref, ["leaves"]);
              return new DecoratorRange(_objectSpread({}, other, {
                leaves: leaves != null ? List(Array.isArray(leaves) ? leaves : getOwnObjectValues(leaves)).map(function (leaf) {
                  return LeafRange(leaf);
                }) : null
              }));
            }
          };
          /**
           * Generate LeafRange records for a given character list.
           */

          function generateLeaves(characters, offset) {
            var leaves = [];
            var inlineStyles = characters.map(function (c) {
              return c.getStyle();
            }).toList();
            findRangesImmutable(inlineStyles, areEqual, returnTrue, function (start, end) {
              leaves.push(new LeafRange({
                start: start + offset,
                end: end + offset
              }));
            });
            return List(leaves);
          }
          function areEqual(a, b) {
            return a === b;
          }
          BlockTree_1 = BlockTree;
          return BlockTree_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @legacyServerCallableInstance
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DraftEntityInstance_1;
        var hasRequiredDraftEntityInstance;
        function requireDraftEntityInstance() {
          if (hasRequiredDraftEntityInstance) return DraftEntityInstance_1;
          hasRequiredDraftEntityInstance = 1;
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var Immutable = requireImmutable();
          var Record = Immutable.Record;
          var DraftEntityInstanceRecord = Record({
            type: 'TOKEN',
            mutability: 'IMMUTABLE',
            data: Object
          });
          /**
           * An instance of a document entity, consisting of a `type` and relevant
           * `data`, metadata about the entity.
           *
           * For instance, a "link" entity might provide a URI, and a "mention"
           * entity might provide the mentioned user's ID. These pieces of data
           * may be used when rendering the entity as part of a ContentBlock DOM
           * representation. For a link, the data would be used as an href for
           * the rendered anchor. For a mention, the ID could be used to retrieve
           * a hovercard.
           */

          var DraftEntityInstance = /*#__PURE__*/function (_DraftEntityInstanceR) {
            _inheritsLoose(DraftEntityInstance, _DraftEntityInstanceR);
            function DraftEntityInstance() {
              return _DraftEntityInstanceR.apply(this, arguments) || this;
            }
            var _proto = DraftEntityInstance.prototype;
            _proto.getType = function getType() {
              return this.get('type');
            };
            _proto.getMutability = function getMutability() {
              return this.get('mutability');
            };
            _proto.getData = function getData() {
              return this.get('data');
            };
            return DraftEntityInstance;
          }(DraftEntityInstanceRecord);
          DraftEntityInstance_1 = DraftEntityInstance;
          return DraftEntityInstance_1;
        }
        var uuid_1;
        var hasRequiredUuid;
        function requireUuid() {
          if (hasRequiredUuid) return uuid_1;
          hasRequiredUuid = 1;

          /**
           * Copyright 2004-present Facebook. All Rights Reserved.
           *
           * @typechecks
           * 
           * @format
           */

          /*eslint-disable no-bitwise */

          /**
           * Based on the rfc4122-compliant solution posted at
           * http://stackoverflow.com/questions/105034
           */
          function uuid() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
              var r = Math.random() * 16 | 0;
              var v = c == 'x' ? r : r & 0x3 | 0x8;
              return v.toString(16);
            });
          }
          uuid_1 = uuid;
          return uuid_1;
        }
        var DraftEntity_1;
        var hasRequiredDraftEntity;
        function requireDraftEntity() {
          if (hasRequiredDraftEntity) return DraftEntity_1;
          hasRequiredDraftEntity = 1;
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === "function") {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var DraftEntityInstance = requireDraftEntityInstance();
          var Immutable = requireImmutable();
          var invariant = requireInvariant();
          var uuid = requireUuid();
          var Map = Immutable.Map;
          var instances = Map();
          var instanceKey = uuid();
          function logWarning(oldMethodCall, newMethodCall) {
            console.warn("WARNING: " + oldMethodCall + ' will be deprecated soon!\nPlease use "' + newMethodCall + '" instead.');
          }
          var DraftEntity = {
            /**
             * WARNING: This method will be deprecated soon!
             * Please use 'contentState.getLastCreatedEntityKey' instead.
             * ---
             * Get the random key string from whatever entity was last created.
             * We need this to support the new API, as part of transitioning to put Entity
             * storage in contentState.
             */
            getLastCreatedEntityKey: function getLastCreatedEntityKey() {
              logWarning("DraftEntity.getLastCreatedEntityKey", "contentState.getLastCreatedEntityKey");
              return DraftEntity.__getLastCreatedEntityKey();
            },
            /**
             * WARNING: This method will be deprecated soon!
             * Please use 'contentState.createEntity' instead.
             * ---
             * Create a DraftEntityInstance and store it for later retrieval.
             *
             * A random key string will be generated and returned. This key may
             * be used to track the entity's usage in a ContentBlock, and for
             * retrieving data about the entity at render time.
             */
            create: function create(type, mutability, data) {
              logWarning("DraftEntity.create", "contentState.createEntity");
              return DraftEntity.__create(type, mutability, data);
            },
            /**
             * WARNING: This method will be deprecated soon!
             * Please use 'contentState.addEntity' instead.
             * ---
             * Add an existing DraftEntityInstance to the DraftEntity map. This is
             * useful when restoring instances from the server.
             */
            add: function add(instance) {
              logWarning("DraftEntity.add", "contentState.addEntity");
              return DraftEntity.__add(instance);
            },
            /**
             * WARNING: This method will be deprecated soon!
             * Please use 'contentState.getEntity' instead.
             * ---
             * Retrieve the entity corresponding to the supplied key string.
             */
            get: function get(key) {
              logWarning("DraftEntity.get", "contentState.getEntity");
              return DraftEntity.__get(key);
            },
            /**
             * Get all the entities in the content state.
             */
            __getAll: function __getAll() {
              return instances;
            },
            /**
             * Load the entity map with the given set of entities.
             */
            __loadWithEntities: function __loadWithEntities(entities) {
              instances = entities;
              instanceKey = uuid();
            },
            /**
             * WARNING: This method will be deprecated soon!
             * Please use 'contentState.mergeEntityData' instead.
             * ---
             * Entity instances are immutable. If you need to update the data for an
             * instance, this method will merge your data updates and return a new
             * instance.
             */
            mergeData: function mergeData(key, toMerge) {
              logWarning("DraftEntity.mergeData", "contentState.mergeEntityData");
              return DraftEntity.__mergeData(key, toMerge);
            },
            /**
             * WARNING: This method will be deprecated soon!
             * Please use 'contentState.replaceEntityData' instead.
             * ---
             * Completely replace the data for a given instance.
             */
            replaceData: function replaceData(key, newData) {
              logWarning("DraftEntity.replaceData", "contentState.replaceEntityData");
              return DraftEntity.__replaceData(key, newData);
            },
            // ***********************************WARNING******************************
            // --- the above public API will be deprecated in the next version of Draft!
            // The methods below this line are private - don't call them directly.
            /**
             * Get the random key string from whatever entity was last created.
             * We need this to support the new API, as part of transitioning to put Entity
             * storage in contentState.
             */
            __getLastCreatedEntityKey: function __getLastCreatedEntityKey() {
              return instanceKey;
            },
            /**
             * Create a DraftEntityInstance and store it for later retrieval.
             *
             * A random key string will be generated and returned. This key may
             * be used to track the entity's usage in a ContentBlock, and for
             * retrieving data about the entity at render time.
             */
            __create: function __create(type, mutability, data) {
              return DraftEntity.__add(new DraftEntityInstance({
                type,
                mutability,
                data: data || {}
              }));
            },
            /**
             * Add an existing DraftEntityInstance to the DraftEntity map. This is
             * useful when restoring instances from the server.
             */
            __add: function __add(instance) {
              instanceKey = uuid();
              instances = instances.set(instanceKey, instance);
              return instanceKey;
            },
            /**
             * Retrieve the entity corresponding to the supplied key string.
             */
            __get: function __get(key) {
              var instance = instances.get(key);
              !!!instance ? invariant(false) : void 0;
              return instance;
            },
            /**
             * Entity instances are immutable. If you need to update the data for an
             * instance, this method will merge your data updates and return a new
             * instance.
             */
            __mergeData: function __mergeData(key, toMerge) {
              var instance = DraftEntity.__get(key);
              var newData = _objectSpread({}, instance.getData(), toMerge);
              var newInstance = instance.set("data", newData);
              instances = instances.set(key, newInstance);
              return newInstance;
            },
            /**
             * Completely replace the data for a given instance.
             */
            __replaceData: function __replaceData(key, newData) {
              var instance = DraftEntity.__get(key);
              var newInstance = instance.set("data", newData);
              instances = instances.set(key, newInstance);
              return newInstance;
            }
          };
          DraftEntity_1 = DraftEntity;
          return DraftEntity_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var SelectionState_1;
        var hasRequiredSelectionState;
        function requireSelectionState() {
          if (hasRequiredSelectionState) return SelectionState_1;
          hasRequiredSelectionState = 1;
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var Immutable = requireImmutable();
          var Record = Immutable.Record;
          var defaultRecord = {
            anchorKey: '',
            anchorOffset: 0,
            focusKey: '',
            focusOffset: 0,
            isBackward: false,
            hasFocus: false
          };
          /* $FlowFixMe[unclear-type] This comment suppresses an error found when
           * automatically adding a type annotation with the codemod Komodo/Annotate_
           * exports. To see the error delete this comment and run Flow. */

          var SelectionStateRecord = Record(defaultRecord);
          var SelectionState = /*#__PURE__*/function (_SelectionStateRecord) {
            _inheritsLoose(SelectionState, _SelectionStateRecord);
            function SelectionState() {
              return _SelectionStateRecord.apply(this, arguments) || this;
            }
            var _proto = SelectionState.prototype;
            _proto.serialize = function serialize() {
              return 'Anchor: ' + this.getAnchorKey() + ':' + this.getAnchorOffset() + ', ' + 'Focus: ' + this.getFocusKey() + ':' + this.getFocusOffset() + ', ' + 'Is Backward: ' + String(this.getIsBackward()) + ', ' + 'Has Focus: ' + String(this.getHasFocus());
            };
            _proto.getAnchorKey = function getAnchorKey() {
              return this.get('anchorKey');
            };
            _proto.getAnchorOffset = function getAnchorOffset() {
              return this.get('anchorOffset');
            };
            _proto.getFocusKey = function getFocusKey() {
              return this.get('focusKey');
            };
            _proto.getFocusOffset = function getFocusOffset() {
              return this.get('focusOffset');
            };
            _proto.getIsBackward = function getIsBackward() {
              return this.get('isBackward');
            };
            _proto.getHasFocus = function getHasFocus() {
              return this.get('hasFocus');
            }
            /**
             * Return whether the specified range overlaps with an edge of the
             * SelectionState.
             */;
            _proto.hasEdgeWithin = function hasEdgeWithin(blockKey, start, end) {
              var anchorKey = this.getAnchorKey();
              var focusKey = this.getFocusKey();
              if (anchorKey === focusKey && anchorKey === blockKey) {
                var selectionStart = this.getStartOffset();
                var selectionEnd = this.getEndOffset();
                return start <= selectionStart && selectionStart <= end ||
                // selectionStart is between start and end, or
                start <= selectionEnd && selectionEnd <= end // selectionEnd is between start and end
                ;
              }
              if (blockKey !== anchorKey && blockKey !== focusKey) {
                return false;
              }
              var offsetToCheck = blockKey === anchorKey ? this.getAnchorOffset() : this.getFocusOffset();
              return start <= offsetToCheck && end >= offsetToCheck;
            };
            _proto.isCollapsed = function isCollapsed() {
              return this.getAnchorKey() === this.getFocusKey() && this.getAnchorOffset() === this.getFocusOffset();
            };
            _proto.getStartKey = function getStartKey() {
              return this.getIsBackward() ? this.getFocusKey() : this.getAnchorKey();
            };
            _proto.getStartOffset = function getStartOffset() {
              return this.getIsBackward() ? this.getFocusOffset() : this.getAnchorOffset();
            };
            _proto.getEndKey = function getEndKey() {
              return this.getIsBackward() ? this.getAnchorKey() : this.getFocusKey();
            };
            _proto.getEndOffset = function getEndOffset() {
              return this.getIsBackward() ? this.getAnchorOffset() : this.getFocusOffset();
            };
            SelectionState.createEmpty = function createEmpty(key) {
              return new SelectionState({
                anchorKey: key,
                anchorOffset: 0,
                focusKey: key,
                focusOffset: 0,
                isBackward: false,
                hasFocus: false
              });
            };
            return SelectionState;
          }(SelectionStateRecord);
          SelectionState_1 = SelectionState;
          return SelectionState_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         */

        var gkx;
        var hasRequiredGkx;
        function requireGkx() {
          if (hasRequiredGkx) return gkx;
          hasRequiredGkx = 1;
          gkx = function (name) {
            if (typeof window !== 'undefined' && window.__DRAFT_GKX) {
              return !!window.__DRAFT_GKX[name];
            }
            return false;
          };
          return gkx;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var sanitizeDraftText_1;
        var hasRequiredSanitizeDraftText;
        function requireSanitizeDraftText() {
          if (hasRequiredSanitizeDraftText) return sanitizeDraftText_1;
          hasRequiredSanitizeDraftText = 1;
          var REGEX_BLOCK_DELIMITER = new RegExp('\r', 'g');
          function sanitizeDraftText(input) {
            return input.replace(REGEX_BLOCK_DELIMITER, '');
          }
          sanitizeDraftText_1 = sanitizeDraftText;
          return sanitizeDraftText_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var ContentState_1;
        var hasRequiredContentState;
        function requireContentState() {
          if (hasRequiredContentState) return ContentState_1;
          hasRequiredContentState = 1;
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var BlockMapBuilder = requireBlockMapBuilder();
          var CharacterMetadata = requireCharacterMetadata();
          var ContentBlock = requireContentBlock();
          var ContentBlockNode = requireContentBlockNode();
          var DraftEntity = requireDraftEntity();
          var SelectionState = requireSelectionState();
          var generateRandomKey = requireGenerateRandomKey();
          var getOwnObjectValues = requireGetOwnObjectValues();
          var gkx = requireGkx();
          var Immutable = requireImmutable();
          var sanitizeDraftText = requireSanitizeDraftText();
          var List = Immutable.List,
            Record = Immutable.Record,
            Repeat = Immutable.Repeat,
            ImmutableMap = Immutable.Map,
            OrderedMap = Immutable.OrderedMap;
          var defaultRecord = {
            entityMap: null,
            blockMap: null,
            selectionBefore: null,
            selectionAfter: null
          };
          var ContentStateRecord = Record(defaultRecord);
          /* $FlowFixMe[signature-verification-failure] Supressing a `signature-
           * verification-failure` error here. TODO: T65949050 Clean up the branch for
           * this GK */

          var ContentBlockNodeRecord = gkx('draft_tree_data_support') ? ContentBlockNode : ContentBlock;
          var ContentState = /*#__PURE__*/function (_ContentStateRecord) {
            _inheritsLoose(ContentState, _ContentStateRecord);
            function ContentState() {
              return _ContentStateRecord.apply(this, arguments) || this;
            }
            var _proto = ContentState.prototype;
            _proto.getEntityMap = function getEntityMap() {
              // TODO: update this when we fully remove DraftEntity
              return DraftEntity;
            };
            _proto.getBlockMap = function getBlockMap() {
              return this.get('blockMap');
            };
            _proto.getSelectionBefore = function getSelectionBefore() {
              return this.get('selectionBefore');
            };
            _proto.getSelectionAfter = function getSelectionAfter() {
              return this.get('selectionAfter');
            };
            _proto.getBlockForKey = function getBlockForKey(key) {
              var block = this.getBlockMap().get(key);
              return block;
            };
            _proto.getKeyBefore = function getKeyBefore(key) {
              return this.getBlockMap().reverse().keySeq().skipUntil(function (v) {
                return v === key;
              }).skip(1).first();
            };
            _proto.getKeyAfter = function getKeyAfter(key) {
              return this.getBlockMap().keySeq().skipUntil(function (v) {
                return v === key;
              }).skip(1).first();
            };
            _proto.getBlockAfter = function getBlockAfter(key) {
              return this.getBlockMap().skipUntil(function (_, k) {
                return k === key;
              }).skip(1).first();
            };
            _proto.getBlockBefore = function getBlockBefore(key) {
              return this.getBlockMap().reverse().skipUntil(function (_, k) {
                return k === key;
              }).skip(1).first();
            };
            _proto.getBlocksAsArray = function getBlocksAsArray() {
              return this.getBlockMap().toArray();
            };
            _proto.getFirstBlock = function getFirstBlock() {
              return this.getBlockMap().first();
            };
            _proto.getLastBlock = function getLastBlock() {
              return this.getBlockMap().last();
            };
            _proto.getPlainText = function getPlainText(delimiter) {
              return this.getBlockMap().map(function (block) {
                return block ? block.getText() : '';
              }).join(delimiter || '\n');
            };
            _proto.getLastCreatedEntityKey = function getLastCreatedEntityKey() {
              // TODO: update this when we fully remove DraftEntity
              return DraftEntity.__getLastCreatedEntityKey();
            };
            _proto.hasText = function hasText() {
              var blockMap = this.getBlockMap();
              return blockMap.size > 1 ||
              // make sure that there are no zero width space chars
              escape(blockMap.first().getText()).replace(/%u200B/g, '').length > 0;
            };
            _proto.createEntity = function createEntity(type, mutability, data) {
              // TODO: update this when we fully remove DraftEntity
              DraftEntity.__create(type, mutability, data);
              return this;
            };
            _proto.mergeEntityData = function mergeEntityData(key, toMerge) {
              // TODO: update this when we fully remove DraftEntity
              DraftEntity.__mergeData(key, toMerge);
              return this;
            };
            _proto.replaceEntityData = function replaceEntityData(key, newData) {
              // TODO: update this when we fully remove DraftEntity
              DraftEntity.__replaceData(key, newData);
              return this;
            };
            _proto.addEntity = function addEntity(instance) {
              // TODO: update this when we fully remove DraftEntity
              DraftEntity.__add(instance);
              return this;
            };
            _proto.getEntity = function getEntity(key) {
              // TODO: update this when we fully remove DraftEntity
              return DraftEntity.__get(key);
            };
            _proto.getAllEntities = function getAllEntities() {
              return DraftEntity.__getAll();
            };
            _proto.loadWithEntities = function loadWithEntities(entities) {
              return DraftEntity.__loadWithEntities(entities);
            };
            ContentState.createFromBlockArray = function createFromBlockArray(
            // TODO: update flow type when we completely deprecate the old entity API
            blocks, entityMap) {
              // TODO: remove this when we completely deprecate the old entity API
              var theBlocks = Array.isArray(blocks) ? blocks : blocks.contentBlocks;
              var blockMap = BlockMapBuilder.createFromArray(theBlocks);
              var selectionState = blockMap.isEmpty() ? new SelectionState() : SelectionState.createEmpty(blockMap.first().getKey());
              return new ContentState({
                blockMap: blockMap,
                entityMap: entityMap || DraftEntity,
                selectionBefore: selectionState,
                selectionAfter: selectionState
              });
            };
            ContentState.createFromText = function createFromText(text) {
              var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /\r\n?|\n/g;
              var strings = text.split(delimiter);
              var blocks = strings.map(function (block) {
                block = sanitizeDraftText(block);
                return new ContentBlockNodeRecord({
                  key: generateRandomKey(),
                  text: block,
                  type: 'unstyled',
                  characterList: List(Repeat(CharacterMetadata.EMPTY, block.length))
                });
              });
              return ContentState.createFromBlockArray(blocks);
            };
            ContentState.fromJS = function fromJS(state) {
              return new ContentState(_objectSpread({}, state, {
                blockMap: OrderedMap(state.blockMap).map(ContentState.createContentBlockFromJS),
                selectionBefore: new SelectionState(state.selectionBefore),
                selectionAfter: new SelectionState(state.selectionAfter)
              }));
            };
            ContentState.createContentBlockFromJS = function createContentBlockFromJS(block) {
              var characterList = block.characterList;
              return new ContentBlockNodeRecord(_objectSpread({}, block, {
                data: ImmutableMap(block.data),
                characterList: characterList != null ? List((Array.isArray(characterList) ? characterList : getOwnObjectValues(characterList)).map(function (c) {
                  return CharacterMetadata.fromJS(c);
                })) : undefined
              }));
            };
            return ContentState;
          }(ContentStateRecord);
          ContentState_1 = ContentState;
          return ContentState_1;
        }
        var UnicodeBidiDirection_1;
        var hasRequiredUnicodeBidiDirection;
        function requireUnicodeBidiDirection() {
          if (hasRequiredUnicodeBidiDirection) return UnicodeBidiDirection_1;
          hasRequiredUnicodeBidiDirection = 1;
          var invariant = requireInvariant();
          var NEUTRAL = "NEUTRAL";
          var LTR = "LTR";
          var RTL = "RTL";
          var globalDir = null;
          function isStrong(dir) {
            return dir === LTR || dir === RTL;
          }
          function getHTMLDir(dir) {
            !isStrong(dir) ? invariant(false) : void 0;
            return dir === LTR ? "ltr" : "rtl";
          }
          function getHTMLDirIfDifferent(dir, otherDir) {
            !isStrong(dir) ? invariant(false) : void 0;
            !isStrong(otherDir) ? invariant(false) : void 0;
            return dir === otherDir ? null : getHTMLDir(dir);
          }
          function setGlobalDir(dir) {
            globalDir = dir;
          }
          function initGlobalDir() {
            setGlobalDir(LTR);
          }
          function getGlobalDir() {
            if (!globalDir) {
              this.initGlobalDir();
            }
            !globalDir ? invariant(false) : void 0;
            return globalDir;
          }
          var UnicodeBidiDirection = {
            // Values
            NEUTRAL,
            LTR,
            RTL,
            // Helpers
            isStrong,
            getHTMLDir,
            getHTMLDirIfDifferent,
            // Global Direction
            setGlobalDir,
            initGlobalDir,
            getGlobalDir
          };
          UnicodeBidiDirection_1 = UnicodeBidiDirection;
          return UnicodeBidiDirection_1;
        }
        var UnicodeBidi_1;
        var hasRequiredUnicodeBidi;
        function requireUnicodeBidi() {
          if (hasRequiredUnicodeBidi) return UnicodeBidi_1;
          hasRequiredUnicodeBidi = 1;
          var UnicodeBidiDirection = requireUnicodeBidiDirection();
          var invariant = requireInvariant();
          var RANGE_BY_BIDI_TYPE = {
            L: "A-Za-z-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
            R: "----------------------",
            AL: "------------------------------"
          };
          var REGEX_STRONG = new RegExp("[" + RANGE_BY_BIDI_TYPE.L + RANGE_BY_BIDI_TYPE.R + RANGE_BY_BIDI_TYPE.AL + "]");
          var REGEX_RTL = new RegExp("[" + RANGE_BY_BIDI_TYPE.R + RANGE_BY_BIDI_TYPE.AL + "]");
          function firstStrongChar(str) {
            var match = REGEX_STRONG.exec(str);
            return match == null ? null : match[0];
          }
          function firstStrongCharDir(str) {
            var strongChar = firstStrongChar(str);
            if (strongChar == null) {
              return UnicodeBidiDirection.NEUTRAL;
            }
            return REGEX_RTL.exec(strongChar) ? UnicodeBidiDirection.RTL : UnicodeBidiDirection.LTR;
          }
          function resolveBlockDir(str, fallback) {
            fallback = fallback || UnicodeBidiDirection.NEUTRAL;
            if (!str.length) {
              return fallback;
            }
            var blockDir = firstStrongCharDir(str);
            return blockDir === UnicodeBidiDirection.NEUTRAL ? fallback : blockDir;
          }
          function getDirection(str, strongFallback) {
            if (!strongFallback) {
              strongFallback = UnicodeBidiDirection.getGlobalDir();
            }
            !UnicodeBidiDirection.isStrong(strongFallback) ? invariant(false) : void 0;
            return resolveBlockDir(str, strongFallback);
          }
          function isDirectionLTR(str, strongFallback) {
            return getDirection(str, strongFallback) === UnicodeBidiDirection.LTR;
          }
          function isDirectionRTL(str, strongFallback) {
            return getDirection(str, strongFallback) === UnicodeBidiDirection.RTL;
          }
          var UnicodeBidi = {
            firstStrongChar,
            firstStrongCharDir,
            resolveBlockDir,
            getDirection,
            isDirectionLTR,
            isDirectionRTL
          };
          UnicodeBidi_1 = UnicodeBidi;
          return UnicodeBidi_1;
        }
        var UnicodeBidiService_1;
        var hasRequiredUnicodeBidiService;
        function requireUnicodeBidiService() {
          if (hasRequiredUnicodeBidiService) return UnicodeBidiService_1;
          hasRequiredUnicodeBidiService = 1;
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var UnicodeBidi = requireUnicodeBidi();
          var UnicodeBidiDirection = requireUnicodeBidiDirection();
          var invariant = requireInvariant();
          var UnicodeBidiService = /* @__PURE__ */function () {
            function UnicodeBidiService2(defaultDir) {
              _defineProperty(this, "_defaultDir", void 0);
              _defineProperty(this, "_lastDir", void 0);
              if (!defaultDir) {
                defaultDir = UnicodeBidiDirection.getGlobalDir();
              } else {
                !UnicodeBidiDirection.isStrong(defaultDir) ? invariant(false) : void 0;
              }
              this._defaultDir = defaultDir;
              this.reset();
            }
            var _proto = UnicodeBidiService2.prototype;
            _proto.reset = function reset() {
              this._lastDir = this._defaultDir;
            };
            _proto.getDirection = function getDirection(str) {
              this._lastDir = UnicodeBidi.getDirection(str, this._lastDir);
              return this._lastDir;
            };
            return UnicodeBidiService2;
          }();
          UnicodeBidiService_1 = UnicodeBidiService;
          return UnicodeBidiService_1;
        }
        var nullthrows_1;
        var hasRequiredNullthrows;
        function requireNullthrows() {
          if (hasRequiredNullthrows) return nullthrows_1;
          hasRequiredNullthrows = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * 
           */
          var nullthrows = function nullthrows(x) {
            if (x != null) {
              return x;
            }
            throw new Error("Got unexpected null or undefined");
          };
          nullthrows_1 = nullthrows;
          return nullthrows_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var EditorBidiService_1;
        var hasRequiredEditorBidiService;
        function requireEditorBidiService() {
          if (hasRequiredEditorBidiService) return EditorBidiService_1;
          hasRequiredEditorBidiService = 1;
          var UnicodeBidiService = requireUnicodeBidiService();
          var Immutable = requireImmutable();
          var nullthrows = requireNullthrows();
          var OrderedMap = Immutable.OrderedMap;
          var bidiService;
          var EditorBidiService = {
            getDirectionMap: function getDirectionMap(content, prevBidiMap) {
              if (!bidiService) {
                bidiService = new UnicodeBidiService();
              } else {
                bidiService.reset();
              }
              var blockMap = content.getBlockMap();
              var nextBidi = blockMap.valueSeq().map(function (block) {
                return nullthrows(bidiService).getDirection(block.getText());
              });
              var bidiMap = OrderedMap(blockMap.keySeq().zip(nextBidi));
              if (prevBidiMap != null && Immutable.is(prevBidiMap, bidiMap)) {
                return prevBidiMap;
              }
              return bidiMap;
            }
          };
          EditorBidiService_1 = EditorBidiService;
          return EditorBidiService_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var EditorState_1;
        var hasRequiredEditorState;
        function requireEditorState() {
          if (hasRequiredEditorState) return EditorState_1;
          hasRequiredEditorState = 1;
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var BlockTree = requireBlockTree();
          var ContentState = requireContentState();
          var EditorBidiService = requireEditorBidiService();
          var SelectionState = requireSelectionState();
          var Immutable = requireImmutable();
          var OrderedSet = Immutable.OrderedSet,
            Record = Immutable.Record,
            Stack = Immutable.Stack,
            OrderedMap = Immutable.OrderedMap,
            List = Immutable.List; // When configuring an editor, the user can chose to provide or not provide
          // basically all keys. `currentContent` varies, so this type doesn't include it.
          // (See the types defined below.)

          var defaultRecord = {
            allowUndo: true,
            currentContent: null,
            decorator: null,
            directionMap: null,
            forceSelection: false,
            inCompositionMode: false,
            inlineStyleOverride: null,
            lastChangeType: null,
            nativelyRenderedContent: null,
            redoStack: Stack(),
            selection: null,
            treeMap: null,
            undoStack: Stack()
          };
          var EditorStateRecord = Record(defaultRecord);
          var EditorState = /*#__PURE__*/function () {
            EditorState.createEmpty = function createEmpty(decorator) {
              return this.createWithText('', decorator);
            };
            EditorState.createWithText = function createWithText(text, decorator) {
              return EditorState.createWithContent(ContentState.createFromText(text), decorator);
            };
            EditorState.createWithContent = function createWithContent(contentState, decorator) {
              if (contentState.getBlockMap().count() === 0) {
                return EditorState.createEmpty(decorator);
              }
              var firstKey = contentState.getBlockMap().first().getKey();
              return EditorState.create({
                currentContent: contentState,
                undoStack: Stack(),
                redoStack: Stack(),
                decorator: decorator || null,
                selection: SelectionState.createEmpty(firstKey)
              });
            };
            EditorState.create = function create(config) {
              var currentContent = config.currentContent,
                decorator = config.decorator;
              var recordConfig = _objectSpread({}, config, {
                treeMap: generateNewTreeMap(currentContent, decorator),
                directionMap: EditorBidiService.getDirectionMap(currentContent)
              });
              return new EditorState(new EditorStateRecord(recordConfig));
            };
            EditorState.fromJS = function fromJS(config) {
              return new EditorState(new EditorStateRecord(_objectSpread({}, config, {
                directionMap: config.directionMap != null ? OrderedMap(config.directionMap) : config.directionMap,
                inlineStyleOverride: config.inlineStyleOverride != null ? OrderedSet(config.inlineStyleOverride) : config.inlineStyleOverride,
                nativelyRenderedContent: config.nativelyRenderedContent != null ? ContentState.fromJS(config.nativelyRenderedContent) : config.nativelyRenderedContent,
                redoStack: config.redoStack != null ? Stack(config.redoStack.map(function (v) {
                  return ContentState.fromJS(v);
                })) : config.redoStack,
                selection: config.selection != null ? new SelectionState(config.selection) : config.selection,
                treeMap: config.treeMap != null ? OrderedMap(config.treeMap).map(function (v) {
                  return List(v).map(function (v) {
                    return BlockTree.fromJS(v);
                  });
                }) : config.treeMap,
                undoStack: config.undoStack != null ? Stack(config.undoStack.map(function (v) {
                  return ContentState.fromJS(v);
                })) : config.undoStack,
                currentContent: ContentState.fromJS(config.currentContent)
              })));
            };
            EditorState.set = function set(editorState, put) {
              var map = editorState.getImmutable().withMutations(function (state) {
                var existingDecorator = state.get('decorator');
                var decorator = existingDecorator;
                if (put.decorator === null) {
                  decorator = null;
                } else if (put.decorator) {
                  decorator = put.decorator;
                }
                var newContent = put.currentContent || editorState.getCurrentContent();
                if (decorator !== existingDecorator) {
                  var treeMap = state.get('treeMap');
                  var newTreeMap;
                  if (decorator && existingDecorator) {
                    newTreeMap = regenerateTreeForNewDecorator(newContent, newContent.getBlockMap(), treeMap, decorator, existingDecorator);
                  } else {
                    newTreeMap = generateNewTreeMap(newContent, decorator);
                  }
                  state.merge({
                    decorator: decorator,
                    treeMap: newTreeMap,
                    nativelyRenderedContent: null
                  });
                  return;
                }
                var existingContent = editorState.getCurrentContent();
                if (newContent !== existingContent) {
                  state.set('treeMap', regenerateTreeForNewBlocks(editorState, newContent.getBlockMap(), newContent.getEntityMap(), decorator));
                }
                state.merge(put);
              });
              return new EditorState(map);
            };
            var _proto = EditorState.prototype;
            _proto.toJS = function toJS() {
              return this.getImmutable().toJS();
            };
            _proto.getAllowUndo = function getAllowUndo() {
              return this.getImmutable().get('allowUndo');
            };
            _proto.getCurrentContent = function getCurrentContent() {
              return this.getImmutable().get('currentContent');
            };
            _proto.getUndoStack = function getUndoStack() {
              return this.getImmutable().get('undoStack');
            };
            _proto.getRedoStack = function getRedoStack() {
              return this.getImmutable().get('redoStack');
            };
            _proto.getSelection = function getSelection() {
              return this.getImmutable().get('selection');
            };
            _proto.getDecorator = function getDecorator() {
              return this.getImmutable().get('decorator');
            };
            _proto.isInCompositionMode = function isInCompositionMode() {
              return this.getImmutable().get('inCompositionMode');
            };
            _proto.mustForceSelection = function mustForceSelection() {
              return this.getImmutable().get('forceSelection');
            };
            _proto.getNativelyRenderedContent = function getNativelyRenderedContent() {
              return this.getImmutable().get('nativelyRenderedContent');
            };
            _proto.getLastChangeType = function getLastChangeType() {
              return this.getImmutable().get('lastChangeType');
            }
            /**
             * While editing, the user may apply inline style commands with a collapsed
             * cursor, intending to type text that adopts the specified style. In this
             * case, we track the specified style as an "override" that takes precedence
             * over the inline style of the text adjacent to the cursor.
             *
             * If null, there is no override in place.
             */;
            _proto.getInlineStyleOverride = function getInlineStyleOverride() {
              return this.getImmutable().get('inlineStyleOverride');
            };
            EditorState.setInlineStyleOverride = function setInlineStyleOverride(editorState, inlineStyleOverride) {
              return EditorState.set(editorState, {
                inlineStyleOverride: inlineStyleOverride
              });
            }
            /**
             * Get the appropriate inline style for the editor state. If an
             * override is in place, use it. Otherwise, the current style is
             * based on the location of the selection state.
             */;
            _proto.getCurrentInlineStyle = function getCurrentInlineStyle() {
              var override = this.getInlineStyleOverride();
              if (override != null) {
                return override;
              }
              var content = this.getCurrentContent();
              var selection = this.getSelection();
              if (selection.isCollapsed()) {
                return getInlineStyleForCollapsedSelection(content, selection);
              }
              return getInlineStyleForNonCollapsedSelection(content, selection);
            };
            _proto.getBlockTree = function getBlockTree(blockKey) {
              return this.getImmutable().getIn(['treeMap', blockKey]);
            };
            _proto.isSelectionAtStartOfContent = function isSelectionAtStartOfContent() {
              var firstKey = this.getCurrentContent().getBlockMap().first().getKey();
              return this.getSelection().hasEdgeWithin(firstKey, 0, 0);
            };
            _proto.isSelectionAtEndOfContent = function isSelectionAtEndOfContent() {
              var content = this.getCurrentContent();
              var blockMap = content.getBlockMap();
              var last = blockMap.last();
              var end = last.getLength();
              return this.getSelection().hasEdgeWithin(last.getKey(), end, end);
            };
            _proto.getDirectionMap = function getDirectionMap() {
              return this.getImmutable().get('directionMap');
            }
            /**
             * Incorporate native DOM selection changes into the EditorState. This
             * method can be used when we simply want to accept whatever the DOM
             * has given us to represent selection, and we do not need to re-render
             * the editor.
             *
             * To forcibly move the DOM selection, see `EditorState.forceSelection`.
             */;
            EditorState.acceptSelection = function acceptSelection(editorState, selection) {
              return updateSelection(editorState, selection, false);
            }
            /**
             * At times, we need to force the DOM selection to be where we
             * need it to be. This can occur when the anchor or focus nodes
             * are non-text nodes, for instance. In this case, we want to trigger
             * a re-render of the editor, which in turn forces selection into
             * the correct place in the DOM. The `forceSelection` method
             * accomplishes this.
             *
             * This method should be used in cases where you need to explicitly
             * move the DOM selection from one place to another without a change
             * in ContentState.
             */;
            EditorState.forceSelection = function forceSelection(editorState, selection) {
              if (!selection.getHasFocus()) {
                selection = selection.set('hasFocus', true);
              }
              return updateSelection(editorState, selection, true);
            }
            /**
             * Move selection to the end of the editor without forcing focus.
             */;
            EditorState.moveSelectionToEnd = function moveSelectionToEnd(editorState) {
              var content = editorState.getCurrentContent();
              var lastBlock = content.getLastBlock();
              var lastKey = lastBlock.getKey();
              var length = lastBlock.getLength();
              return EditorState.acceptSelection(editorState, new SelectionState({
                anchorKey: lastKey,
                anchorOffset: length,
                focusKey: lastKey,
                focusOffset: length,
                isBackward: false
              }));
            }
            /**
             * Force focus to the end of the editor. This is useful in scenarios
             * where we want to programmatically focus the input and it makes sense
             * to allow the user to continue working seamlessly.
             */;
            EditorState.moveFocusToEnd = function moveFocusToEnd(editorState) {
              var afterSelectionMove = EditorState.moveSelectionToEnd(editorState);
              return EditorState.forceSelection(afterSelectionMove, afterSelectionMove.getSelection());
            }
            /**
             * Push the current ContentState onto the undo stack if it should be
             * considered a boundary state, and set the provided ContentState as the
             * new current content.
             */;
            EditorState.push = function push(editorState, contentState, changeType) {
              var forceSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
              if (editorState.getCurrentContent() === contentState) {
                return editorState;
              }
              var directionMap = EditorBidiService.getDirectionMap(contentState, editorState.getDirectionMap());
              if (!editorState.getAllowUndo()) {
                return EditorState.set(editorState, {
                  currentContent: contentState,
                  directionMap: directionMap,
                  lastChangeType: changeType,
                  selection: contentState.getSelectionAfter(),
                  forceSelection: forceSelection,
                  inlineStyleOverride: null
                });
              }
              var selection = editorState.getSelection();
              var currentContent = editorState.getCurrentContent();
              var undoStack = editorState.getUndoStack();
              var newContent = contentState;
              if (selection !== currentContent.getSelectionAfter() || mustBecomeBoundary(editorState, changeType)) {
                undoStack = undoStack.push(currentContent);
                newContent = newContent.set('selectionBefore', selection);
              } else if (changeType === 'insert-characters' || changeType === 'backspace-character' || changeType === 'delete-character') {
                // Preserve the previous selection.
                newContent = newContent.set('selectionBefore', currentContent.getSelectionBefore());
              }
              var inlineStyleOverride = editorState.getInlineStyleOverride(); // Don't discard inline style overrides for the following change types:

              var overrideChangeTypes = ['adjust-depth', 'change-block-type', 'split-block'];
              if (overrideChangeTypes.indexOf(changeType) === -1) {
                inlineStyleOverride = null;
              }
              var editorStateChanges = {
                currentContent: newContent,
                directionMap: directionMap,
                undoStack: undoStack,
                redoStack: Stack(),
                lastChangeType: changeType,
                selection: contentState.getSelectionAfter(),
                forceSelection: forceSelection,
                inlineStyleOverride: inlineStyleOverride
              };
              return EditorState.set(editorState, editorStateChanges);
            }
            /**
             * Make the top ContentState in the undo stack the new current content and
             * push the current content onto the redo stack.
             */;
            EditorState.undo = function undo(editorState) {
              if (!editorState.getAllowUndo()) {
                return editorState;
              }
              var undoStack = editorState.getUndoStack();
              var newCurrentContent = undoStack.peek();
              if (!newCurrentContent) {
                return editorState;
              }
              var currentContent = editorState.getCurrentContent();
              var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());
              return EditorState.set(editorState, {
                currentContent: newCurrentContent,
                directionMap: directionMap,
                undoStack: undoStack.shift(),
                redoStack: editorState.getRedoStack().push(currentContent),
                forceSelection: true,
                inlineStyleOverride: null,
                lastChangeType: 'undo',
                nativelyRenderedContent: null,
                selection: currentContent.getSelectionBefore()
              });
            }
            /**
             * Make the top ContentState in the redo stack the new current content and
             * push the current content onto the undo stack.
             */;
            EditorState.redo = function redo(editorState) {
              if (!editorState.getAllowUndo()) {
                return editorState;
              }
              var redoStack = editorState.getRedoStack();
              var newCurrentContent = redoStack.peek();
              if (!newCurrentContent) {
                return editorState;
              }
              var currentContent = editorState.getCurrentContent();
              var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());
              return EditorState.set(editorState, {
                currentContent: newCurrentContent,
                directionMap: directionMap,
                undoStack: editorState.getUndoStack().push(currentContent),
                redoStack: redoStack.shift(),
                forceSelection: true,
                inlineStyleOverride: null,
                lastChangeType: 'redo',
                nativelyRenderedContent: null,
                selection: newCurrentContent.getSelectionAfter()
              });
            }
            /**
             * Not for public consumption.
             */;
            function EditorState(immutable) {
              _defineProperty(this, "_immutable", void 0);
              this._immutable = immutable;
            }
            /**
             * Not for public consumption.
             */

            _proto.getImmutable = function getImmutable() {
              return this._immutable;
            };
            return EditorState;
          }();
          /**
           * Set the supplied SelectionState as the new current selection, and set
           * the `force` flag to trigger manual selection placement by the view.
           */

          function updateSelection(editorState, selection, forceSelection) {
            return EditorState.set(editorState, {
              selection: selection,
              forceSelection: forceSelection,
              nativelyRenderedContent: null,
              inlineStyleOverride: null
            });
          }
          /**
           * Regenerate the entire tree map for a given ContentState and decorator.
           * Returns an OrderedMap that maps all available ContentBlock objects.
           */

          function generateNewTreeMap(contentState, decorator) {
            return contentState.getBlockMap().map(function (block) {
              return BlockTree.generate(contentState, block, decorator);
            }).toOrderedMap();
          }
          /**
           * Regenerate tree map objects for all ContentBlocks that have changed
           * between the current editorState and newContent. Returns an OrderedMap
           * with only changed regenerated tree map objects.
           */

          function regenerateTreeForNewBlocks(editorState, newBlockMap, newEntityMap, decorator) {
            var contentState = editorState.getCurrentContent().set('entityMap', newEntityMap);
            var prevBlockMap = contentState.getBlockMap();
            var prevTreeMap = editorState.getImmutable().get('treeMap');
            return prevTreeMap.merge(newBlockMap.toSeq().filter(function (block, key) {
              return block !== prevBlockMap.get(key);
            }).map(function (block) {
              return BlockTree.generate(contentState, block, decorator);
            }));
          }
          /**
           * Generate tree map objects for a new decorator object, preserving any
           * decorations that are unchanged from the previous decorator.
           *
           * Note that in order for this to perform optimally, decoration Lists for
           * decorators should be preserved when possible to allow for direct immutable
           * List comparison.
           */

          function regenerateTreeForNewDecorator(content, blockMap, previousTreeMap, decorator, existingDecorator) {
            return previousTreeMap.merge(blockMap.toSeq().filter(function (block) {
              return decorator.getDecorations(block, content) !== existingDecorator.getDecorations(block, content);
            }).map(function (block) {
              return BlockTree.generate(content, block, decorator);
            }));
          }
          /**
           * Return whether a change should be considered a boundary state, given
           * the previous change type. Allows us to discard potential boundary states
           * during standard typing or deletion behavior.
           */

          function mustBecomeBoundary(editorState, changeType) {
            var lastChangeType = editorState.getLastChangeType();
            return changeType !== lastChangeType || changeType !== 'insert-characters' && changeType !== 'backspace-character' && changeType !== 'delete-character';
          }
          function getInlineStyleForCollapsedSelection(content, selection) {
            var startKey = selection.getStartKey();
            var startOffset = selection.getStartOffset();
            var startBlock = content.getBlockForKey(startKey); // If the cursor is not at the start of the block, look backward to
            // preserve the style of the preceding character.

            if (startOffset > 0) {
              return startBlock.getInlineStyleAt(startOffset - 1);
            } // The caret is at position zero in this block. If the block has any
            // text at all, use the style of the first character.

            if (startBlock.getLength()) {
              return startBlock.getInlineStyleAt(0);
            } // Otherwise, look upward in the document to find the closest character.

            return lookUpwardForInlineStyle(content, startKey);
          }
          function getInlineStyleForNonCollapsedSelection(content, selection) {
            var startKey = selection.getStartKey();
            var startOffset = selection.getStartOffset();
            var startBlock = content.getBlockForKey(startKey); // If there is a character just inside the selection, use its style.

            if (startOffset < startBlock.getLength()) {
              return startBlock.getInlineStyleAt(startOffset);
            } // Check if the selection at the end of a non-empty block. Use the last
            // style in the block.

            if (startOffset > 0) {
              return startBlock.getInlineStyleAt(startOffset - 1);
            } // Otherwise, look upward in the document to find the closest character.

            return lookUpwardForInlineStyle(content, startKey);
          }
          function lookUpwardForInlineStyle(content, fromKey) {
            var lastNonEmpty = content.getBlockMap().reverse().skipUntil(function (_, k) {
              return k === fromKey;
            }).skip(1).skipUntil(function (block, _) {
              return block.getLength();
            }).first();
            if (lastNonEmpty) {
              return lastNonEmpty.getInlineStyleAt(lastNonEmpty.getLength() - 1);
            }
            return OrderedSet();
          }
          EditorState_1 = EditorState;
          return EditorState_1;
        }
        var moveBlockInContentState_1;
        var hasRequiredMoveBlockInContentState;
        function requireMoveBlockInContentState() {
          if (hasRequiredMoveBlockInContentState) return moveBlockInContentState_1;
          hasRequiredMoveBlockInContentState = 1;
          var ContentBlockNode = requireContentBlockNode();
          var getNextDelimiterBlockKey = requireGetNextDelimiterBlockKey();
          var Immutable = requireImmutable();
          var invariant = requireInvariant();
          var OrderedMap = Immutable.OrderedMap,
            List = Immutable.List;
          var transformBlock = function transformBlock2(key, blockMap, func) {
            if (!key) {
              return;
            }
            var block = blockMap.get(key);
            if (!block) {
              return;
            }
            blockMap.set(key, func(block));
          };
          var updateBlockMapLinks = function updateBlockMapLinks2(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {
            if (!isExperimentalTreeBlock) {
              return blockMap;
            }
            var isInsertedAfterTarget = insertionMode === "after";
            var originalBlockKey = originalBlockToBeMoved.getKey();
            var originalTargetKey = originalTargetBlock.getKey();
            var originalParentKey = originalBlockToBeMoved.getParentKey();
            var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();
            var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();
            var newParentKey = originalTargetBlock.getParentKey();
            var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;
            var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();
            return blockMap.withMutations(function (blocks) {
              transformBlock(originalParentKey, blocks, function (block) {
                var parentChildrenList = block.getChildKeys();
                return block.merge({
                  children: parentChildrenList["delete"](parentChildrenList.indexOf(originalBlockKey))
                });
              });
              transformBlock(originalPrevSiblingKey, blocks, function (block) {
                return block.merge({
                  nextSibling: originalNextSiblingKey
                });
              });
              transformBlock(originalNextSiblingKey, blocks, function (block) {
                return block.merge({
                  prevSibling: originalPrevSiblingKey
                });
              });
              transformBlock(newNextSiblingKey, blocks, function (block) {
                return block.merge({
                  prevSibling: originalBlockKey
                });
              });
              transformBlock(newPrevSiblingKey, blocks, function (block) {
                return block.merge({
                  nextSibling: originalBlockKey
                });
              });
              transformBlock(newParentKey, blocks, function (block) {
                var newParentChildrenList = block.getChildKeys();
                var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);
                var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;
                var newChildrenArray = newParentChildrenList.toArray();
                newChildrenArray.splice(insertionIndex, 0, originalBlockKey);
                return block.merge({
                  children: List(newChildrenArray)
                });
              });
              transformBlock(originalBlockKey, blocks, function (block) {
                return block.merge({
                  nextSibling: newNextSiblingKey,
                  prevSibling: newPrevSiblingKey,
                  parent: newParentKey
                });
              });
            });
          };
          var moveBlockInContentState = function moveBlockInContentState2(contentState, blockToBeMoved, targetBlock, insertionMode) {
            !(insertionMode !== "replace") ? invariant(false) : void 0;
            var targetKey = targetBlock.getKey();
            var blockKey = blockToBeMoved.getKey();
            !(blockKey !== targetKey) ? invariant(false) : void 0;
            var blockMap = contentState.getBlockMap();
            var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;
            var blocksToBeMoved = [blockToBeMoved];
            var blockMapWithoutBlocksToBeMoved = blockMap["delete"](blockKey);
            if (isExperimentalTreeBlock) {
              blocksToBeMoved = [];
              blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {
                var nextSiblingKey = blockToBeMoved.getNextSiblingKey();
                var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);
                blocks.toSeq().skipUntil(function (block) {
                  return block.getKey() === blockKey;
                }).takeWhile(function (block) {
                  var key = block.getKey();
                  var isBlockToBeMoved = key === blockKey;
                  var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;
                  var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);
                  return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);
                }).forEach(function (block) {
                  blocksToBeMoved.push(block);
                  blocks["delete"](block.getKey());
                });
              });
            }
            var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {
              return v === targetBlock;
            });
            var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {
              return v === targetBlock;
            }).skip(1);
            var slicedBlocks = blocksToBeMoved.map(function (block) {
              return [block.getKey(), block];
            });
            var newBlocks = OrderedMap();
            if (insertionMode === "before") {
              var blockBefore = contentState.getBlockBefore(targetKey);
              !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? invariant(false) : void 0;
              newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();
            } else if (insertionMode === "after") {
              var blockAfter = contentState.getBlockAfter(targetKey);
              !(!blockAfter || blockAfter.getKey() !== blockKey) ? invariant(false) : void 0;
              newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();
            }
            return contentState.merge({
              blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),
              selectionBefore: contentState.getSelectionAfter(),
              selectionAfter: contentState.getSelectionAfter().merge({
                anchorKey: blockKey,
                focusKey: blockKey
              })
            });
          };
          moveBlockInContentState_1 = moveBlockInContentState;
          return moveBlockInContentState_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var AtomicBlockUtils_1;
        var hasRequiredAtomicBlockUtils;
        function requireAtomicBlockUtils() {
          if (hasRequiredAtomicBlockUtils) return AtomicBlockUtils_1;
          hasRequiredAtomicBlockUtils = 1;
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var BlockMapBuilder = requireBlockMapBuilder();
          var CharacterMetadata = requireCharacterMetadata();
          var ContentBlock = requireContentBlock();
          var ContentBlockNode = requireContentBlockNode();
          var DraftModifier = requireDraftModifier();
          var EditorState = requireEditorState();
          var generateRandomKey = requireGenerateRandomKey();
          var gkx = requireGkx();
          var Immutable = requireImmutable();
          var moveBlockInContentState = requireMoveBlockInContentState();
          var experimentalTreeDataSupport = gkx('draft_tree_data_support');
          var ContentBlockRecord = experimentalTreeDataSupport ? ContentBlockNode : ContentBlock;
          var List = Immutable.List,
            Repeat = Immutable.Repeat;
          var AtomicBlockUtils = {
            insertAtomicBlock: function insertAtomicBlock(editorState, entityKey, character) {
              var contentState = editorState.getCurrentContent();
              var selectionState = editorState.getSelection();
              var afterRemoval = DraftModifier.removeRange(contentState, selectionState, 'backward');
              var targetSelection = afterRemoval.getSelectionAfter();
              var afterSplit = DraftModifier.splitBlock(afterRemoval, targetSelection);
              var insertionTarget = afterSplit.getSelectionAfter();
              var asAtomicBlock = DraftModifier.setBlockType(afterSplit, insertionTarget, 'atomic');
              var charData = CharacterMetadata.create({
                entity: entityKey
              });
              var atomicBlockConfig = {
                key: generateRandomKey(),
                type: 'atomic',
                text: character,
                characterList: List(Repeat(charData, character.length))
              };
              var atomicDividerBlockConfig = {
                key: generateRandomKey(),
                type: 'unstyled'
              };
              if (experimentalTreeDataSupport) {
                atomicBlockConfig = _objectSpread({}, atomicBlockConfig, {
                  nextSibling: atomicDividerBlockConfig.key
                });
                atomicDividerBlockConfig = _objectSpread({}, atomicDividerBlockConfig, {
                  prevSibling: atomicBlockConfig.key
                });
              }
              var fragmentArray = [new ContentBlockRecord(atomicBlockConfig), new ContentBlockRecord(atomicDividerBlockConfig)];
              var fragment = BlockMapBuilder.createFromArray(fragmentArray);
              var withAtomicBlock = DraftModifier.replaceWithFragment(asAtomicBlock, insertionTarget, fragment);
              var newContent = withAtomicBlock.merge({
                selectionBefore: selectionState,
                selectionAfter: withAtomicBlock.getSelectionAfter().set('hasFocus', true)
              });
              return EditorState.push(editorState, newContent, 'insert-fragment');
            },
            moveAtomicBlock: function moveAtomicBlock(editorState, atomicBlock, targetRange, insertionMode) {
              var contentState = editorState.getCurrentContent();
              var selectionState = editorState.getSelection();
              var withMovedAtomicBlock;
              if (insertionMode === 'before' || insertionMode === 'after') {
                var targetBlock = contentState.getBlockForKey(insertionMode === 'before' ? targetRange.getStartKey() : targetRange.getEndKey());
                withMovedAtomicBlock = moveBlockInContentState(contentState, atomicBlock, targetBlock, insertionMode);
              } else {
                var afterRemoval = DraftModifier.removeRange(contentState, targetRange, 'backward');
                var selectionAfterRemoval = afterRemoval.getSelectionAfter();
                var _targetBlock = afterRemoval.getBlockForKey(selectionAfterRemoval.getFocusKey());
                if (selectionAfterRemoval.getStartOffset() === 0) {
                  withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, 'before');
                } else if (selectionAfterRemoval.getEndOffset() === _targetBlock.getLength()) {
                  withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, 'after');
                } else {
                  var afterSplit = DraftModifier.splitBlock(afterRemoval, selectionAfterRemoval);
                  var selectionAfterSplit = afterSplit.getSelectionAfter();
                  var _targetBlock2 = afterSplit.getBlockForKey(selectionAfterSplit.getFocusKey());
                  withMovedAtomicBlock = moveBlockInContentState(afterSplit, atomicBlock, _targetBlock2, 'before');
                }
              }
              var newContent = withMovedAtomicBlock.merge({
                selectionBefore: selectionState,
                selectionAfter: withMovedAtomicBlock.getSelectionAfter().set('hasFocus', true)
              });
              return EditorState.push(editorState, newContent, 'move-block');
            }
          };
          AtomicBlockUtils_1 = AtomicBlockUtils;
          return AtomicBlockUtils_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var CompositeDraftDecorator_1;
        var hasRequiredCompositeDraftDecorator;
        function requireCompositeDraftDecorator() {
          if (hasRequiredCompositeDraftDecorator) return CompositeDraftDecorator_1;
          hasRequiredCompositeDraftDecorator = 1;
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var Immutable = requireImmutable();
          var List = Immutable.List;
          var DELIMITER = '.';
          /**
           * A CompositeDraftDecorator traverses through a list of DraftDecorator
           * instances to identify sections of a ContentBlock that should be rendered
           * in a "decorated" manner. For example, hashtags, mentions, and links may
           * be intended to stand out visually, be rendered as anchors, etc.
           *
           * The list of decorators supplied to the constructor will be used in the
           * order they are provided. This allows the caller to specify a priority for
           * string matching, in case of match collisions among decorators.
           *
           * For instance, I may have a link with a `#` in its text. Though this section
           * of text may match our hashtag decorator, it should not be treated as a
           * hashtag. I should therefore list my link DraftDecorator
           * before my hashtag DraftDecorator when constructing this composite
           * decorator instance.
           *
           * Thus, when a collision like this is encountered, the earlier match is
           * preserved and the new match is discarded.
           */

          var CompositeDraftDecorator = /*#__PURE__*/function () {
            function CompositeDraftDecorator(decorators) {
              _defineProperty(this, "_decorators", void 0);

              // Copy the decorator array, since we use this array order to determine
              // precedence of decoration matching. If the array is mutated externally,
              // we don't want to be affected here.
              this._decorators = decorators.slice();
            }
            var _proto = CompositeDraftDecorator.prototype;
            _proto.getDecorations = function getDecorations(block, contentState) {
              var decorations = Array(block.getText().length).fill(null);
              this._decorators.forEach(function (/*object*/
              decorator, /*number*/
              ii) {
                var counter = 0;
                var strategy = decorator.strategy;
                var callback = function callback(/*number*/
                start, /*number*/
                end) {
                  // Find out if any of our matching range is already occupied
                  // by another decorator. If so, discard the match. Otherwise, store
                  // the component key for rendering.
                  if (canOccupySlice(decorations, start, end)) {
                    occupySlice(decorations, start, end, ii + DELIMITER + counter);
                    counter++;
                  }
                };
                strategy(block, callback, contentState);
              });
              return List(decorations);
            };
            _proto.getComponentForKey = function getComponentForKey(key) {
              var componentKey = parseInt(key.split(DELIMITER)[0], 10);
              return this._decorators[componentKey].component;
            };
            _proto.getPropsForKey = function getPropsForKey(key) {
              var componentKey = parseInt(key.split(DELIMITER)[0], 10);
              return this._decorators[componentKey].props;
            };
            return CompositeDraftDecorator;
          }();
          /**
           * Determine whether we can occupy the specified slice of the decorations
           * array.
           */

          function canOccupySlice(decorations, start, end) {
            for (var ii = start; ii < end; ii++) {
              if (decorations[ii] != null) {
                return false;
              }
            }
            return true;
          }
          /**
           * Splice the specified component into our decoration array at the desired
           * range.
           */

          function occupySlice(targetArr, start, end, componentKey) {
            for (var ii = start; ii < end; ii++) {
              targetArr[ii] = componentKey;
            }
          }
          CompositeDraftDecorator_1 = CompositeDraftDecorator;
          return CompositeDraftDecorator_1;
        }
        var cx_1;
        var hasRequiredCx;
        function requireCx() {
          if (hasRequiredCx) return cx_1;
          hasRequiredCx = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           */

          /**
           * This function is used to mark string literals representing CSS class names
           * so that they can be transformed statically. This allows for modularization
           * and minification of CSS class names.
           *
           * In static_upstream, this function is actually implemented, but it should
           * eventually be replaced with something more descriptive, and the transform
           * that is used in the main stack should be ported for use elsewhere.
           *
           * @param string|object className to modularize, or an object of key/values.
           *                      In the object case, the values are conditions that
           *                      determine if the className keys should be included.
           * @param [string ...]  Variable list of classNames in the string case.
           * @return string       Renderable space-separated CSS className.
           */
          function cx(classNames) {
            if (typeof classNames == 'object') {
              return Object.keys(classNames).filter(function (className) {
                return classNames[className];
              }).map(replace).join(' ');
            }
            return Array.prototype.map.call(arguments, replace).join(' ');
          }
          function replace(str) {
            return str.replace(/\//g, '-');
          }
          cx_1 = cx;
          return cx_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DefaultDraftBlockRenderMap_1;
        var hasRequiredDefaultDraftBlockRenderMap;
        function requireDefaultDraftBlockRenderMap() {
          if (hasRequiredDefaultDraftBlockRenderMap) return DefaultDraftBlockRenderMap_1;
          hasRequiredDefaultDraftBlockRenderMap = 1;
          var React = requireReact();
          var cx = requireCx();
          var _require = requireImmutable(),
            Map = _require.Map;
          var UL_WRAP = React.createElement("ul", {
            className: cx('public/DraftStyleDefault/ul')
          });
          var OL_WRAP = React.createElement("ol", {
            className: cx('public/DraftStyleDefault/ol')
          });
          var PRE_WRAP = React.createElement("pre", {
            className: cx('public/DraftStyleDefault/pre')
          });
          var DefaultDraftBlockRenderMap = Map({
            'header-one': {
              element: 'h1'
            },
            'header-two': {
              element: 'h2'
            },
            'header-three': {
              element: 'h3'
            },
            'header-four': {
              element: 'h4'
            },
            'header-five': {
              element: 'h5'
            },
            'header-six': {
              element: 'h6'
            },
            section: {
              element: 'section'
            },
            article: {
              element: 'article'
            },
            'unordered-list-item': {
              element: 'li',
              wrapper: UL_WRAP
            },
            'ordered-list-item': {
              element: 'li',
              wrapper: OL_WRAP
            },
            blockquote: {
              element: 'blockquote'
            },
            atomic: {
              element: 'figure'
            },
            'code-block': {
              element: 'pre',
              wrapper: PRE_WRAP
            },
            unstyled: {
              element: 'div',
              aliasedElements: ['p']
            }
          });
          DefaultDraftBlockRenderMap_1 = DefaultDraftBlockRenderMap;
          return DefaultDraftBlockRenderMap_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DefaultDraftInlineStyle;
        var hasRequiredDefaultDraftInlineStyle;
        function requireDefaultDraftInlineStyle() {
          if (hasRequiredDefaultDraftInlineStyle) return DefaultDraftInlineStyle;
          hasRequiredDefaultDraftInlineStyle = 1;
          DefaultDraftInlineStyle = {
            BOLD: {
              fontWeight: 'bold'
            },
            CODE: {
              fontFamily: 'monospace',
              wordWrap: 'break-word'
            },
            ITALIC: {
              fontStyle: 'italic'
            },
            STRIKETHROUGH: {
              textDecoration: 'line-through'
            },
            UNDERLINE: {
              textDecoration: 'underline'
            }
          };
          return DefaultDraftInlineStyle;
        }

        /*
        object-assign
        (c) Sindre Sorhus
        @license MIT
        */

        var objectAssign;
        var hasRequiredObjectAssign;
        function requireObjectAssign() {
          if (hasRequiredObjectAssign) return objectAssign;
          hasRequiredObjectAssign = 1;
          /* eslint-disable no-unused-vars */
          var getOwnPropertySymbols = Object.getOwnPropertySymbols;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var propIsEnumerable = Object.prototype.propertyIsEnumerable;
          function toObject(val) {
            if (val === null || val === undefined) {
              throw new TypeError('Object.assign cannot be called with null or undefined');
            }
            return Object(val);
          }
          function shouldUseNative() {
            try {
              if (!Object.assign) {
                return false;
              }

              // Detect buggy property enumeration order in older V8 versions.

              // https://bugs.chromium.org/p/v8/issues/detail?id=4118
              var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
              test1[5] = 'de';
              if (Object.getOwnPropertyNames(test1)[0] === '5') {
                return false;
              }

              // https://bugs.chromium.org/p/v8/issues/detail?id=3056
              var test2 = {};
              for (var i = 0; i < 10; i++) {
                test2['_' + String.fromCharCode(i)] = i;
              }
              var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
                return test2[n];
              });
              if (order2.join('') !== '0123456789') {
                return false;
              }

              // https://bugs.chromium.org/p/v8/issues/detail?id=3056
              var test3 = {};
              'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
                test3[letter] = letter;
              });
              if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
                return false;
              }
              return true;
            } catch (err) {
              // We don't expect any of the above to throw, but better to be safe.
              return false;
            }
          }
          objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
            var from;
            var to = toObject(target);
            var symbols;
            for (var s = 1; s < arguments.length; s++) {
              from = Object(arguments[s]);
              for (var key in from) {
                if (hasOwnProperty.call(from, key)) {
                  to[key] = from[key];
                }
              }
              if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from);
                for (var i = 0; i < symbols.length; i++) {
                  if (propIsEnumerable.call(from, symbols[i])) {
                    to[symbols[i]] = from[symbols[i]];
                  }
                }
              }
            }
            return to;
          };
          return objectAssign;
        }
        var uaParser$1 = {
          exports: {}
        };
        var uaParser = uaParser$1.exports;
        var hasRequiredUaParser;
        function requireUaParser() {
          if (hasRequiredUaParser) return uaParser$1.exports;
          hasRequiredUaParser = 1;
          (function (module, exports) {
            (function (window2, undefined$1) {
              var LIBVERSION = "0.7.41",
                EMPTY = "",
                UNKNOWN = "?",
                FUNC_TYPE = "function",
                UNDEF_TYPE = "undefined",
                OBJ_TYPE = "object",
                STR_TYPE = "string",
                MAJOR = "major",
                MODEL = "model",
                NAME = "name",
                TYPE = "type",
                VENDOR = "vendor",
                VERSION = "version",
                ARCHITECTURE = "architecture",
                CONSOLE = "console",
                MOBILE = "mobile",
                TABLET = "tablet",
                SMARTTV = "smarttv",
                WEARABLE = "wearable",
                EMBEDDED = "embedded",
                UA_MAX_LENGTH = 500;
              var AMAZON = "Amazon",
                APPLE = "Apple",
                ASUS = "ASUS",
                BLACKBERRY = "BlackBerry",
                BROWSER = "Browser",
                CHROME = "Chrome",
                EDGE = "Edge",
                FIREFOX = "Firefox",
                GOOGLE = "Google",
                HONOR = "Honor",
                HUAWEI = "Huawei",
                LENOVO = "Lenovo",
                LG = "LG",
                MICROSOFT = "Microsoft",
                MOTOROLA = "Motorola",
                NVIDIA = "Nvidia",
                ONEPLUS = "OnePlus",
                OPERA = "Opera",
                OPPO = "OPPO",
                SAMSUNG = "Samsung",
                SHARP = "Sharp",
                SONY = "Sony",
                XIAOMI = "Xiaomi",
                ZEBRA = "Zebra",
                FACEBOOK = "Facebook",
                CHROMIUM_OS = "Chromium OS",
                MAC_OS = "Mac OS",
                SUFFIX_BROWSER = " Browser";
              var extend = function (regexes2, extensions) {
                  var mergedRegexes = {};
                  for (var i in regexes2) {
                    if (extensions[i] && extensions[i].length % 2 === 0) {
                      mergedRegexes[i] = extensions[i].concat(regexes2[i]);
                    } else {
                      mergedRegexes[i] = regexes2[i];
                    }
                  }
                  return mergedRegexes;
                },
                enumerize = function (arr) {
                  var enums = {};
                  for (var i = 0; i < arr.length; i++) {
                    enums[arr[i].toUpperCase()] = arr[i];
                  }
                  return enums;
                },
                has = function (str1, str2) {
                  return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
                },
                lowerize = function (str) {
                  return str.toLowerCase();
                },
                majorize = function (version) {
                  return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined$1;
                },
                trim = function (str, len) {
                  if (typeof str === STR_TYPE) {
                    str = str.replace(/^\s\s*/, EMPTY);
                    return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
                  }
                };
              var rgxMapper = function (ua, arrays) {
                  var i = 0,
                    j,
                    k,
                    p,
                    q,
                    matches,
                    match;
                  while (i < arrays.length && !matches) {
                    var regex = arrays[i],
                      props = arrays[i + 1];
                    j = k = 0;
                    while (j < regex.length && !matches) {
                      if (!regex[j]) {
                        break;
                      }
                      matches = regex[j++].exec(ua);
                      if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                          match = matches[++k];
                          q = props[p];
                          if (typeof q === OBJ_TYPE && q.length > 0) {
                            if (q.length === 2) {
                              if (typeof q[1] == FUNC_TYPE) {
                                this[q[0]] = q[1].call(this, match);
                              } else {
                                this[q[0]] = q[1];
                              }
                            } else if (q.length === 3) {
                              if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;
                              } else {
                                this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;
                              }
                            } else if (q.length === 4) {
                              this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;
                            }
                          } else {
                            this[q] = match ? match : undefined$1;
                          }
                        }
                      }
                    }
                    i += 2;
                  }
                },
                strMapper = function (str, map) {
                  for (var i in map) {
                    if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                      for (var j = 0; j < map[i].length; j++) {
                        if (has(map[i][j], str)) {
                          return i === UNKNOWN ? undefined$1 : i;
                        }
                      }
                    } else if (has(map[i], str)) {
                      return i === UNKNOWN ? undefined$1 : i;
                    }
                  }
                  return map.hasOwnProperty("*") ? map["*"] : str;
                };
              var oldSafariMap = {
                  "1.0": "/8",
                  "1.2": "/1",
                  "1.3": "/3",
                  "2.0": "/412",
                  "2.0.2": "/416",
                  "2.0.3": "/417",
                  "2.0.4": "/419",
                  "?": "/"
                },
                windowsVersionMap = {
                  "ME": "4.90",
                  "NT 3.11": "NT3.51",
                  "NT 4.0": "NT4.0",
                  "2000": "NT 5.0",
                  "XP": ["NT 5.1", "NT 5.2"],
                  "Vista": "NT 6.0",
                  "7": "NT 6.1",
                  "8": "NT 6.2",
                  "8.1": "NT 6.3",
                  "10": ["NT 6.4", "NT 10.0"],
                  "RT": "ARM"
                };
              var regexes = {
                browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i
                // Chrome for Android/iOS
                ], [VERSION, [NAME, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i
                // Microsoft Edge
                ], [VERSION, [NAME, "Edge"]], [
                // Presto based
                /(opera mini)\/([-\w\.]+)/i,
                // Opera Mini
                /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
                // Opera Mobi/Tablet
                /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
                // Opera
                ], [NAME, VERSION], [/opios[\/ ]+([\w\.]+)/i
                // Opera mini on iphone >= 8.0
                ], [VERSION, [NAME, OPERA + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i
                // Opera GX
                ], [VERSION, [NAME, OPERA + " GX"]], [/\bopr\/([\w\.]+)/i
                // Opera Webkit
                ], [VERSION, [NAME, OPERA]], [
                // Mixed
                /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
                // Baidu
                ], [VERSION, [NAME, "Baidu"]], [/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i
                // Maxthon
                ], [VERSION, [NAME, "Maxthon"]], [/(kindle)\/([\w\.]+)/i,
                // Kindle
                /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,
                // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
                // Trident based
                /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,
                // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet
                /(?:ms|\()(ie) ([\w\.]+)/i,
                // Internet Explorer
                // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
                /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i,
                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon
                /(heytap|ovi|115)browser\/([\d\.]+)/i,
                // HeyTap/Ovi/115
                /(weibo)__([\d\.]+)/i
                // Weibo
                ], [NAME, VERSION], [/quark(?:pc)?\/([-\w\.]+)/i
                // Quark
                ], [VERSION, [NAME, "Quark"]], [/\bddg\/([\w\.]+)/i
                // DuckDuckGo
                ], [VERSION, [NAME, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
                // UCBrowser
                ], [VERSION, [NAME, "UC" + BROWSER]], [/microm.+\bqbcore\/([\w\.]+)/i,
                // WeChat Desktop for Windows Built-in Browser
                /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i
                // WeChat
                ], [VERSION, [NAME, "WeChat"]], [/konqueror\/([\w\.]+)/i
                // Konqueror
                ], [VERSION, [NAME, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
                // IE11
                ], [VERSION, [NAME, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i
                // Yandex
                ], [VERSION, [NAME, "Yandex"]], [/slbrowser\/([\w\.]+)/i
                // Smart Lenovo Browser
                ], [VERSION, [NAME, "Smart Lenovo " + BROWSER]], [/(avast|avg)\/([\w\.]+)/i
                // Avast/AVG Secure Browser
                ], [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION], [/\bfocus\/([\w\.]+)/i
                // Firefox Focus
                ], [VERSION, [NAME, FIREFOX + " Focus"]], [/\bopt\/([\w\.]+)/i
                // Opera Touch
                ], [VERSION, [NAME, OPERA + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i
                // Coc Coc Browser
                ], [VERSION, [NAME, "Coc Coc"]], [/dolfin\/([\w\.]+)/i
                // Dolphin
                ], [VERSION, [NAME, "Dolphin"]], [/coast\/([\w\.]+)/i
                // Opera Coast
                ], [VERSION, [NAME, OPERA + " Coast"]], [/miuibrowser\/([\w\.]+)/i
                // MIUI Browser
                ], [VERSION, [NAME, "MIUI" + SUFFIX_BROWSER]], [/fxios\/([\w\.-]+)/i
                // Firefox for iOS
                ], [VERSION, [NAME, FIREFOX]], [/\bqihoobrowser\/?([\w\.]*)/i
                // 360
                ], [VERSION, [NAME, "360"]], [/\b(qq)\/([\w\.]+)/i
                // QQ
                ], [[NAME, /(.+)/, "$1Browser"], VERSION], [/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i], [[NAME, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION], [
                // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
                /samsungbrowser\/([\w\.]+)/i
                // Samsung Internet
                ], [VERSION, [NAME, SAMSUNG + " Internet"]], [/metasr[\/ ]?([\d\.]+)/i
                // Sogou Explorer
                ], [VERSION, [NAME, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i
                // Sogou Mobile
                ], [[NAME, "Sogou Mobile"], VERSION], [/(electron)\/([\w\.]+) safari/i,
                // Electron-based App
                /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
                // Tesla
                /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i
                // QQ/2345
                ], [NAME, VERSION], [/(lbbrowser|rekonq)/i,
                // LieBao Browser/Rekonq
                /\[(linkedin)app\]/i
                // LinkedIn App for iOS & Android
                ], [NAME], [/ome\/([\w\.]+) \w* ?(iron) saf/i,
                // Iron
                /ome\/([\w\.]+).+qihu (360)[es]e/i
                // 360
                ], [VERSION, NAME], [
                // WebView
                /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
                // Facebook App for iOS & Android
                ], [[NAME, FACEBOOK], VERSION], [/(Klarna)\/([\w\.]+)/i,
                // Klarna Shopping Browser for iOS & Android
                /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
                // Kakao App
                /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
                // Naver InApp
                /(daum)apps[\/ ]([\w\.]+)/i,
                // Daum App
                /safari (line)\/([\w\.]+)/i,
                // Line App for iOS
                /\b(line)\/([\w\.]+)\/iab/i,
                // Line App for Android
                /(alipay)client\/([\w\.]+)/i,
                // Alipay
                /(twitter)(?:and| f.+e\/([\w\.]+))/i,
                // Twitter
                /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
                // Chromium/Instagram/Snapchat
                ], [NAME, VERSION], [/\bgsa\/([\w\.]+) .*safari\//i
                // Google Search Appliance on iOS
                ], [VERSION, [NAME, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
                // TikTok
                ], [VERSION, [NAME, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i
                // Chrome Headless
                ], [VERSION, [NAME, CHROME + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i
                // Chrome WebView
                ], [[NAME, CHROME + " WebView"], VERSION], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
                // Android Browser
                ], [VERSION, [NAME, "Android " + BROWSER]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
                // Chrome/OmniWeb/Arora/Tizen/Nokia
                ], [NAME, VERSION], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
                // Mobile Safari
                ], [VERSION, [NAME, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
                // Safari & Safari Mobile
                ], [VERSION, NAME], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
                // Safari < 3.0
                ], [NAME, [VERSION, strMapper, oldSafariMap]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION], [
                // Gecko based
                /(navigator|netscape\d?)\/([-\w\.]+)/i
                // Netscape
                ], [[NAME, "Netscape"], VERSION], [/(wolvic|librewolf)\/([\w\.]+)/i
                // Wolvic/LibreWolf
                ], [NAME, VERSION], [/mobile vr; rv:([\w\.]+)\).+firefox/i
                // Firefox Reality
                ], [VERSION, [NAME, FIREFOX + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i,
                // Flow
                /(swiftfox)/i,
                // Swiftfox
                /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
                /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
                /(firefox)\/([\w\.]+)/i,
                // Other Firefox-based
                /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
                // Mozilla
                // Other
                /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser/Ladybird
                /\b(links) \(([\w\.]+)/i
                // Links
                ], [NAME, [VERSION, /_/g, "."]], [/(cobalt)\/([\w\.]+)/i
                // Cobalt
                ], [NAME, [VERSION, /master.|lts./, ""]]],
                cpu: [[/\b((amd|x|x86[-_]?|wow|win)64)\b/i
                // AMD64 (x64)
                ], [[ARCHITECTURE, "amd64"]], [/(ia32(?=;))/i,
                // IA32 (quicktime)
                /\b((i[346]|x)86)(pc)?\b/i
                // IA32 (x86)
                ], [[ARCHITECTURE, "ia32"]], [/\b(aarch64|arm(v?[89]e?l?|_?64))\b/i
                // ARM64
                ], [[ARCHITECTURE, "arm64"]], [/\b(arm(v[67])?ht?n?[fl]p?)\b/i
                // ARMHF
                ], [[ARCHITECTURE, "armhf"]], [
                // PocketPC mistakenly identified as PowerPC
                /( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i], [[ARCHITECTURE, "arm"]], [/((ppc|powerpc)(64)?)( mac|;|\))/i
                // PowerPC
                ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [/ sun4\w[;\)]/i
                // SPARC
                ], [[ARCHITECTURE, "sparc"]], [/\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i
                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
                ], [[ARCHITECTURE, lowerize]]],
                device: [[
                //////////////////////////
                // MOBILES & TABLETS
                /////////////////////////
                // Samsung
                /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]((?!sm-[lr])[-\w]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [
                // Apple
                /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
                // iPod/iPhone
                ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [/\((ipad);[-\w\),; ]+apple/i,
                // iPad
                /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/(macintosh);/i], [MODEL, [VENDOR, APPLE]], [
                // Sharp
                /\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [
                // Honor
                /\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i], [MODEL, [VENDOR, HONOR], [TYPE, TABLET]], [/honor([-\w ]+)[;\)]/i], [MODEL, [VENDOR, HONOR], [TYPE, MOBILE]], [
                // Huawei
                /\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [
                // Xiaomi
                /oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i, /\b((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i
                // Mi Pad tablets
                ], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
                // Xiaomi POCO
                /\b; (\w+) build\/hm\1/i,
                // Xiaomi Hongmi 'numeric' models
                /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
                // Xiaomi Hongmi
                /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
                // Xiaomi Redmi
                /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
                // Xiaomi Redmi 'numeric' models
                /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i,
                // Xiaomi Mi
                / ([\w ]+) miui\/v?\d/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]], [
                // OPPO
                /; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [MODEL, [VENDOR, OPPO], [TYPE, MOBILE]], [/\b(opd2(\d{3}a?))(?: bui|\))/i], [MODEL, [VENDOR, strMapper, {
                  "OnePlus": ["304", "403", "203"],
                  "*": OPPO
                }], [TYPE, TABLET]], [
                // Vivo
                /vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]], [
                // Realme
                /\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]], [
                // Motorola
                /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto(?! 360)[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [
                // LG
                /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv|watch)\w+)/i, /\blg-?([\d\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [
                // Lenovo
                /(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i, /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i], [MODEL, [VENDOR, LENOVO], [TYPE, TABLET]], [
                // Nokia
                /(nokia) (t[12][01])/i], [VENDOR, MODEL, [TYPE, TABLET]], [/(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i, /nokia[-_ ]?(([-\w\. ]*))/i], [[MODEL, /_/g, " "], [TYPE, MOBILE], [VENDOR, "Nokia"]], [
                // Google
                /(pixel (c|tablet))\b/i
                // Google Pixel C/Tablet
                ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
                // Google Pixel
                ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [
                // Sony
                /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]], [
                // OnePlus
                / (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [MODEL, [VENDOR, ONEPLUS], [TYPE, MOBILE]], [
                // Amazon
                /(alexa)webm/i, /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,
                // Kindle Fire without Silk / Echo Show
                /(kf[a-z]+)( bui|\)).+silk\//i
                // Kindle Fire HD
                ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
                // Fire Phone
                ], [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]], [
                // BlackBerry
                /(playbook);[-\w\),; ]+(rim)/i
                // BlackBerry PlayBook
                ], [MODEL, VENDOR, [TYPE, TABLET]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i
                // BlackBerry 10
                ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [
                // Asus
                /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [
                // HTC
                /(nexus 9)/i
                // HTC Nexus 9
                ], [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
                // HTC
                // ZTE
                /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
                // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
                ], [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]], [
                // TCL
                /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i], [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]], [
                // itel
                /(itel) ((\w+))/i], [[VENDOR, lowerize], MODEL, [TYPE, strMapper, {
                  "tablet": ["p10001l", "w7001"],
                  "*": "mobile"
                }]], [
                // Acer
                /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]], [
                // Meizu
                /droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]], [
                // Ulefone
                /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]], [
                // Energizer
                /; (energy ?\w+)(?: bui|\))/i, /; energizer ([\w ]+)(?: bui|\))/i], [MODEL, [VENDOR, "Energizer"], [TYPE, MOBILE]], [
                // Cat
                /; cat (b35);/i, /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i], [MODEL, [VENDOR, "Cat"], [TYPE, MOBILE]], [
                // Smartfren
                /((?:new )?andromax[\w- ]+)(?: bui|\))/i], [MODEL, [VENDOR, "Smartfren"], [TYPE, MOBILE]], [
                // Nothing
                /droid.+; (a(?:015|06[35]|142p?))/i], [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]], [
                // Archos
                /; (x67 5g|tikeasy \w+|ac[1789]\d\w+)( b|\))/i, /archos ?(5|gamepad2?|([\w ]*[t1789]|hello) ?\d+[\w ]*)( b|\))/i], [MODEL, [VENDOR, "Archos"], [TYPE, TABLET]], [/archos ([\w ]+)( b|\))/i, /; (ac[3-6]\d\w{2,8})( b|\))/i], [MODEL, [VENDOR, "Archos"], [TYPE, MOBILE]], [
                // MIXED
                /(imo) (tab \w+)/i,
                // IMO
                /(infinix) (x1101b?)/i
                // Infinix XPad
                ], [VENDOR, MODEL, [TYPE, TABLET]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Infinix/Tecno/Micromax/Advan
                /; (hmd|imo) ([\w ]+?)(?: bui|\))/i,
                // HMD/IMO
                /(hp) ([\w ]+\w)/i,
                // HP iPAQ
                /(microsoft); (lumia[\w ]+)/i,
                // Microsoft Lumia
                /(lenovo)[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i,
                // Lenovo
                /(oppo) ?([\w ]+) bui/i
                // OPPO
                ], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kobo)\s(ereader|touch)/i,
                // Kobo
                /(hp).+(touchpad(?!.+tablet)|tablet)/i,
                // HP TouchPad
                /(kindle)\/([\w\.]+)/i,
                // Kindle
                /(nook)[\w ]+build\/(\w+)/i,
                // Nook
                /(dell) (strea[kpr\d ]*[\dko])/i,
                // Dell Streak
                /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
                // Le Pan Tablets
                /(trinity)[- ]*(t\d{3}) bui/i,
                // Trinity Tablets
                /(gigaset)[- ]+(q\w{1,9}) bui/i,
                // Gigaset Tablets
                /(vodafone) ([\w ]+)(?:\)| bui)/i
                // Vodafone
                ], [VENDOR, MODEL, [TYPE, TABLET]], [/(surface duo)/i
                // Surface Duo
                ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i
                // Fairphone
                ], [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]], [/(u304aa)/i
                // AT&T
                ], [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]], [/\bsie-(\w*)/i
                // Siemens
                ], [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]], [/\b(rct\w+) b/i
                // RCA Tablets
                ], [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]], [/\b(venue[\d ]{2,7}) b/i
                // Dell Venue Tablets
                ], [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]], [/\b(q(?:mv|ta)\w+) b/i
                // Verizon Tablet
                ], [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
                // Barnes & Noble Tablet
                ], [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]], [/\b(tm\d{3}\w+) b/i], [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]], [/\b(k88) b/i
                // ZTE K Series Tablet
                ], [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]], [/\b(nx\d{3}j) b/i
                // ZTE Nubia
                ], [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]], [/\b(gen\d{3}) b.+49h/i
                // Swiss GEN Mobile
                ], [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]], [/\b(zur\d{3}) b/i
                // Swiss ZUR Tablet
                ], [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]], [/\b((zeki)?tb.*\b) b/i
                // Zeki Tablets
                ], [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i
                // Dragon Touch Tablet
                ], [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]], [/\b(ns-?\w{0,9}) b/i
                // Insignia Tablets
                ], [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]], [/\b((nxa|next)-?\w{0,9}) b/i
                // NextBook Tablets
                ], [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
                // Voice Xtreme Phones
                ], [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]], [/\b(lvtel\-)?(v1[12]) b/i
                // LvTel Phones
                ], [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]], [/\b(ph-1) /i
                // Essential PH-1
                ], [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]], [/\b(v(100md|700na|7011|917g).*\b) b/i
                // Envizen Tablets
                ], [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]], [/\b(trio[-\w\. ]+) b/i
                // MachSpeed Tablets
                ], [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]], [/\btu_(1491) b/i
                // Rotor Tablets
                ], [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]], [/((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i
                // Nvidia Tablets
                ], [MODEL, [VENDOR, NVIDIA], [TYPE, TABLET]], [/(sprint) (\w+)/i
                // Sprint Phones
                ], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kin\.[onetw]{3})/i
                // Microsoft Kin
                ], [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
                // Zebra
                ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [
                ///////////////////
                // SMARTTVS
                ///////////////////
                /smart-tv.+(samsung)/i
                // Samsung
                ], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
                // LG SmartTV
                ], [[VENDOR, LG], [TYPE, SMARTTV]], [/(apple) ?tv/i
                // Apple TV
                ], [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]], [/crkey/i
                // Google Chromecast
                ], [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/droid.+aft(\w+)( bui|\))/i
                // Fire TV
                ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [/(shield \w+ tv)/i
                // Nvidia Shield TV
                ], [MODEL, [VENDOR, NVIDIA], [TYPE, SMARTTV]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i
                // Sharp
                ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]], [/(bravia[\w ]+)( bui|\))/i
                // Sony
                ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [/(mi(tv|box)-?\w+) bui/i
                // Xiaomi
                ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [/Hbbtv.*(technisat) (.*);/i
                // TechniSAT
                ], [VENDOR, MODEL, [TYPE, SMARTTV]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
                // Roku
                /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
                // HbbTV devices
                ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [
                // SmartTV from Unidentified Vendors
                /droid.+; ([\w- ]+) (?:android tv|smart[- ]?tv)/i], [MODEL, [TYPE, SMARTTV]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[TYPE, SMARTTV]], [
                ///////////////////
                // CONSOLES
                ///////////////////
                /(ouya)/i,
                // Ouya
                /(nintendo) ([wids3utch]+)/i
                // Nintendo
                ], [VENDOR, MODEL, [TYPE, CONSOLE]], [/droid.+; (shield)( bui|\))/i
                // Nvidia Portable
                ], [MODEL, [VENDOR, NVIDIA], [TYPE, CONSOLE]], [/(playstation \w+)/i
                // Playstation
                ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i
                // Microsoft Xbox
                ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [
                ///////////////////
                // WEARABLES
                ///////////////////
                /\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i
                // Samsung Galaxy Watch
                ], [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]], [/((pebble))app/i,
                // Pebble
                /(asus|google|lg|oppo) ((pixel |zen)?watch[\w ]*)( bui|\))/i
                // Asus ZenWatch / LG Watch / Pixel Watch
                ], [VENDOR, MODEL, [TYPE, WEARABLE]], [/(ow(?:19|20)?we?[1-3]{1,3})/i
                // Oppo Watch
                ], [MODEL, [VENDOR, OPPO], [TYPE, WEARABLE]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
                // Apple Watch
                ], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [/(opwwe\d{3})/i
                // OnePlus Watch
                ], [MODEL, [VENDOR, ONEPLUS], [TYPE, WEARABLE]], [/(moto 360)/i
                // Motorola 360
                ], [MODEL, [VENDOR, MOTOROLA], [TYPE, WEARABLE]], [/(smartwatch 3)/i
                // Sony SmartWatch
                ], [MODEL, [VENDOR, SONY], [TYPE, WEARABLE]], [/(g watch r)/i
                // LG G Watch R
                ], [MODEL, [VENDOR, LG], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [
                ///////////////////
                // XR
                ///////////////////
                /droid.+; (glass) \d/i
                // Google Glass
                ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/(pico) (4|neo3(?: link|pro)?)/i
                // Pico
                ], [VENDOR, MODEL, [TYPE, WEARABLE]], [/; (quest( \d| pro)?)/i
                // Oculus Quest
                ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [
                ///////////////////
                // EMBEDDED
                ///////////////////
                /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
                // Tesla
                ], [VENDOR, [TYPE, EMBEDDED]], [/(aeobc)\b/i
                // Echo Dot
                ], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [/(homepod).+mac os/i
                // Apple HomePod
                ], [MODEL, [VENDOR, APPLE], [TYPE, EMBEDDED]], [/windows iot/i], [[TYPE, EMBEDDED]], [
                ////////////////////
                // MIXED (GENERIC)
                ///////////////////
                /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
                // Android Phones from Unidentified Vendors
                ], [MODEL, [TYPE, MOBILE]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
                // Android Tablets from Unidentified Vendors
                ], [MODEL, [TYPE, TABLET]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
                // Unidentifiable Tablet
                ], [[TYPE, TABLET]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
                // Unidentifiable Mobile
                ], [[TYPE, MOBILE]], [/droid .+?; ([\w\. -]+)( bui|\))/i
                // Generic Android Device
                ], [MODEL, [VENDOR, "Generic"]]],
                engine: [[/windows.+ edge\/([\w\.]+)/i
                // EdgeHTML
                ], [VERSION, [NAME, EDGE + "HTML"]], [/(arkweb)\/([\w\.]+)/i
                // ArkWeb
                ], [NAME, VERSION], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
                // Blink
                ], [VERSION, [NAME, "Blink"]], [/(presto)\/([\w\.]+)/i,
                // Presto
                /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,
                // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo
                /ekioh(flow)\/([\w\.]+)/i,
                // Flow
                /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
                // KHTML/Tasman/Links
                /(icab)[\/ ]([23]\.[\d\.]+)/i,
                // iCab
                /\b(libweb)/i
                // LibWeb
                ], [NAME, VERSION], [/ladybird\//i], [[NAME, "LibWeb"]], [/rv\:([\w\.]{1,9})\b.+(gecko)/i
                // Gecko
                ], [VERSION, NAME]],
                os: [[
                // Windows
                /microsoft (windows) (vista|xp)/i
                // Windows (iTunes)
                ], [NAME, VERSION], [/(windows (?:phone(?: os)?|mobile|iot))[\/ ]?([\d\.\w ]*)/i
                // Windows Phone
                ], [NAME, [VERSION, strMapper, windowsVersionMap]], [/windows nt 6\.2; (arm)/i,
                // Windows RT
                /windows[\/ ]([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[VERSION, strMapper, windowsVersionMap], [NAME, "Windows"]], [
                // iOS/macOS
                /[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i,
                // iOS
                /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[VERSION, /_/g, "."], [NAME, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i
                // Mac OS
                ], [[NAME, MAC_OS], [VERSION, /_/g, "."]], [
                // Mobile OSes
                /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
                // Android-x86/HarmonyOS
                ], [VERSION, NAME], [/(ubuntu) ([\w\.]+) like android/i
                // Ubuntu Touch
                ], [[NAME, /(.+)/, "$1 Touch"], VERSION], [
                // Android/Blackberry/WebOS/QNX/Bada/RIM/KaiOS/Maemo/MeeGo/S40/Sailfish OS/OpenHarmony/Tizen
                /(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen|webos)\w*[-\/; ]?([\d\.]*)/i], [NAME, VERSION], [/\(bb(10);/i
                // BlackBerry 10
                ], [VERSION, [NAME, BLACKBERRY]], [/(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i
                // Symbian
                ], [VERSION, [NAME, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
                // Firefox OS
                ], [VERSION, [NAME, FIREFOX + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
                // WebOS
                ], [VERSION, [NAME, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
                // watchOS
                ], [VERSION, [NAME, "watchOS"]], [
                // Google Chromecast
                /crkey\/([\d\.]+)/i
                // Google Chromecast
                ], [VERSION, [NAME, CHROME + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
                // Chromium OS
                ], [[NAME, CHROMIUM_OS], VERSION], [
                // Smart TVs
                /panasonic;(viera)/i,
                // Panasonic Viera
                /(netrange)mmh/i,
                // Netrange
                /(nettv)\/(\d+\.[\w\.]+)/i,
                // NetTV
                // Console
                /(nintendo|playstation) ([wids345portablevuch]+)/i,
                // Nintendo/Playstation
                /(xbox); +xbox ([^\);]+)/i,
                // Microsoft Xbox (360, One, X, S, Series X, Series S)
                // Other
                /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
                // Joli/Palm
                /(mint)[\/\(\) ]?(\w*)/i,
                // Mint
                /(mageia|vectorlinux)[; ]/i,
                // Mageia/VectorLinux
                /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
                /(hurd|linux)(?: arm\w*| x86\w*| ?)([\w\.]*)/i,
                // Hurd/Linux
                /(gnu) ?([\w\.]*)/i,
                // GNU
                /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
                // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
                /(haiku) (\w+)/i
                // Haiku
                ], [NAME, VERSION], [/(sunos) ?([\w\.\d]*)/i
                // Solaris
                ], [[NAME, "Solaris"], VERSION], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
                // Solaris
                /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
                // AIX
                /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
                // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
                /(unix) ?([\w\.]*)/i
                // UNIX
                ], [NAME, VERSION]]
              };
              var UAParser = function (ua, extensions) {
                if (typeof ua === OBJ_TYPE) {
                  extensions = ua;
                  ua = undefined$1;
                }
                if (!(this instanceof UAParser)) {
                  return new UAParser(ua, extensions).getResult();
                }
                var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined$1;
                var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
                var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined$1;
                var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
                var _isSelfNav = _navigator && _navigator.userAgent == _ua;
                this.getBrowser = function () {
                  var _browser = {};
                  _browser[NAME] = undefined$1;
                  _browser[VERSION] = undefined$1;
                  rgxMapper.call(_browser, _ua, _rgxmap.browser);
                  _browser[MAJOR] = majorize(_browser[VERSION]);
                  if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
                    _browser[NAME] = "Brave";
                  }
                  return _browser;
                };
                this.getCPU = function () {
                  var _cpu = {};
                  _cpu[ARCHITECTURE] = undefined$1;
                  rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
                  return _cpu;
                };
                this.getDevice = function () {
                  var _device = {};
                  _device[VENDOR] = undefined$1;
                  _device[MODEL] = undefined$1;
                  _device[TYPE] = undefined$1;
                  rgxMapper.call(_device, _ua, _rgxmap.device);
                  if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
                    _device[TYPE] = MOBILE;
                  }
                  if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
                    _device[MODEL] = "iPad";
                    _device[TYPE] = TABLET;
                  }
                  return _device;
                };
                this.getEngine = function () {
                  var _engine = {};
                  _engine[NAME] = undefined$1;
                  _engine[VERSION] = undefined$1;
                  rgxMapper.call(_engine, _ua, _rgxmap.engine);
                  return _engine;
                };
                this.getOS = function () {
                  var _os = {};
                  _os[NAME] = undefined$1;
                  _os[VERSION] = undefined$1;
                  rgxMapper.call(_os, _ua, _rgxmap.os);
                  if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != "Unknown") {
                    _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
                  }
                  return _os;
                };
                this.getResult = function () {
                  return {
                    ua: this.getUA(),
                    browser: this.getBrowser(),
                    engine: this.getEngine(),
                    os: this.getOS(),
                    device: this.getDevice(),
                    cpu: this.getCPU()
                  };
                };
                this.getUA = function () {
                  return _ua;
                };
                this.setUA = function (ua2) {
                  _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;
                  return this;
                };
                this.setUA(_ua);
                return this;
              };
              UAParser.VERSION = LIBVERSION;
              UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
              UAParser.CPU = enumerize([ARCHITECTURE]);
              UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
              UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
              {
                if (module.exports) {
                  exports = module.exports = UAParser;
                }
                exports.UAParser = UAParser;
              }
              var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
              if ($ && !$.ua) {
                var parser = new UAParser();
                $.ua = parser.getResult();
                $.ua.get = function () {
                  return parser.getUA();
                };
                $.ua.set = function (ua) {
                  parser.setUA(ua);
                  var result = parser.getResult();
                  for (var prop in result) {
                    $.ua[prop] = result[prop];
                  }
                };
              }
            })(typeof window === "object" ? window : uaParser);
          })(uaParser$1, uaParser$1.exports);
          return uaParser$1.exports;
        }

        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         */

        var UserAgentData;
        var hasRequiredUserAgentData;
        function requireUserAgentData() {
          if (hasRequiredUserAgentData) return UserAgentData;
          hasRequiredUserAgentData = 1;
          var UAParser = requireUaParser();
          var UNKNOWN = 'Unknown';
          var PLATFORM_MAP = {
            'Mac OS': 'Mac OS X'
          };
          /**
           * Convert from UAParser platform name to what we expect.
           */

          function convertPlatformName(name) {
            return PLATFORM_MAP[name] || name;
          }
          /**
           * Get the version number in parts. This is very naive. We actually get major
           * version as a part of UAParser already, which is generally good enough, but
           * let's get the minor just in case.
           */

          function getBrowserVersion(version) {
            if (!version) {
              return {
                major: '',
                minor: ''
              };
            }
            var parts = version.split('.');
            return {
              major: parts[0],
              minor: parts[1]
            };
          }
          /**
           * Get the UA data fom UAParser and then convert it to the format we're
           * expecting for our APIS.
           */

          var parser = new UAParser();
          var results = parser.getResult(); // Do some conversion first.

          var browserVersionData = getBrowserVersion(results.browser.version);
          var uaData = {
            browserArchitecture: results.cpu.architecture || UNKNOWN,
            browserFullVersion: results.browser.version || UNKNOWN,
            browserMinorVersion: browserVersionData.minor || UNKNOWN,
            browserName: results.browser.name || UNKNOWN,
            browserVersion: results.browser.major || UNKNOWN,
            deviceName: results.device.model || UNKNOWN,
            engineName: results.engine.name || UNKNOWN,
            engineVersion: results.engine.version || UNKNOWN,
            platformArchitecture: results.cpu.architecture || UNKNOWN,
            platformName: convertPlatformName(results.os.name) || UNKNOWN,
            platformVersion: results.os.version || UNKNOWN,
            platformFullVersion: results.os.version || UNKNOWN
          };
          UserAgentData = uaData;
          return UserAgentData;
        }
        var VersionRange_1;
        var hasRequiredVersionRange;
        function requireVersionRange() {
          if (hasRequiredVersionRange) return VersionRange_1;
          hasRequiredVersionRange = 1;
          var invariant = requireInvariant();
          var componentRegex = /\./;
          var orRegex = /\|\|/;
          var rangeRegex = /\s+\-\s+/;
          var modifierRegex = /^(<=|<|=|>=|~>|~|>|)?\s*(.+)/;
          var numericRegex = /^(\d*)(.*)/;
          function checkOrExpression(range, version) {
            var expressions = range.split(orRegex);
            if (expressions.length > 1) {
              return expressions.some(function (range2) {
                return VersionRange.contains(range2, version);
              });
            } else {
              range = expressions[0].trim();
              return checkRangeExpression(range, version);
            }
          }
          function checkRangeExpression(range, version) {
            var expressions = range.split(rangeRegex);
            !(expressions.length > 0 && expressions.length <= 2) ? invariant(false) : void 0;
            if (expressions.length === 1) {
              return checkSimpleExpression(expressions[0], version);
            } else {
              var startVersion = expressions[0],
                endVersion = expressions[1];
              !(isSimpleVersion(startVersion) && isSimpleVersion(endVersion)) ? invariant(false) : void 0;
              return checkSimpleExpression(">=" + startVersion, version) && checkSimpleExpression("<=" + endVersion, version);
            }
          }
          function checkSimpleExpression(range, version) {
            range = range.trim();
            if (range === "") {
              return true;
            }
            var versionComponents = version.split(componentRegex);
            var _getModifierAndCompon = getModifierAndComponents(range),
              modifier = _getModifierAndCompon.modifier,
              rangeComponents = _getModifierAndCompon.rangeComponents;
            switch (modifier) {
              case "<":
                return checkLessThan(versionComponents, rangeComponents);
              case "<=":
                return checkLessThanOrEqual(versionComponents, rangeComponents);
              case ">=":
                return checkGreaterThanOrEqual(versionComponents, rangeComponents);
              case ">":
                return checkGreaterThan(versionComponents, rangeComponents);
              case "~":
              case "~>":
                return checkApproximateVersion(versionComponents, rangeComponents);
              default:
                return checkEqual(versionComponents, rangeComponents);
            }
          }
          function checkLessThan(a, b) {
            return compareComponents(a, b) === -1;
          }
          function checkLessThanOrEqual(a, b) {
            var result = compareComponents(a, b);
            return result === -1 || result === 0;
          }
          function checkEqual(a, b) {
            return compareComponents(a, b) === 0;
          }
          function checkGreaterThanOrEqual(a, b) {
            var result = compareComponents(a, b);
            return result === 1 || result === 0;
          }
          function checkGreaterThan(a, b) {
            return compareComponents(a, b) === 1;
          }
          function checkApproximateVersion(a, b) {
            var lowerBound = b.slice();
            var upperBound = b.slice();
            if (upperBound.length > 1) {
              upperBound.pop();
            }
            var lastIndex = upperBound.length - 1;
            var numeric = parseInt(upperBound[lastIndex], 10);
            if (isNumber(numeric)) {
              upperBound[lastIndex] = numeric + 1 + "";
            }
            return checkGreaterThanOrEqual(a, lowerBound) && checkLessThan(a, upperBound);
          }
          function getModifierAndComponents(range) {
            var rangeComponents = range.split(componentRegex);
            var matches = rangeComponents[0].match(modifierRegex);
            !matches ? invariant(false) : void 0;
            return {
              modifier: matches[1],
              rangeComponents: [matches[2]].concat(rangeComponents.slice(1))
            };
          }
          function isNumber(number) {
            return !isNaN(number) && isFinite(number);
          }
          function isSimpleVersion(range) {
            return !getModifierAndComponents(range).modifier;
          }
          function zeroPad(array, length) {
            for (var i = array.length; i < length; i++) {
              array[i] = "0";
            }
          }
          function normalizeVersions(a, b) {
            a = a.slice();
            b = b.slice();
            zeroPad(a, b.length);
            for (var i = 0; i < b.length; i++) {
              var matches = b[i].match(/^[x*]$/i);
              if (matches) {
                b[i] = a[i] = "0";
                if (matches[0] === "*" && i === b.length - 1) {
                  for (var j = i; j < a.length; j++) {
                    a[j] = "0";
                  }
                }
              }
            }
            zeroPad(b, a.length);
            return [a, b];
          }
          function compareNumeric(a, b) {
            var aPrefix = a.match(numericRegex)[1];
            var bPrefix = b.match(numericRegex)[1];
            var aNumeric = parseInt(aPrefix, 10);
            var bNumeric = parseInt(bPrefix, 10);
            if (isNumber(aNumeric) && isNumber(bNumeric) && aNumeric !== bNumeric) {
              return compare(aNumeric, bNumeric);
            } else {
              return compare(a, b);
            }
          }
          function compare(a, b) {
            !(typeof a === typeof b) ? invariant(false) : void 0;
            if (a > b) {
              return 1;
            } else if (a < b) {
              return -1;
            } else {
              return 0;
            }
          }
          function compareComponents(a, b) {
            var _normalizeVersions = normalizeVersions(a, b),
              aNormalized = _normalizeVersions[0],
              bNormalized = _normalizeVersions[1];
            for (var i = 0; i < bNormalized.length; i++) {
              var result = compareNumeric(aNormalized[i], bNormalized[i]);
              if (result) {
                return result;
              }
            }
            return 0;
          }
          var VersionRange = {
            /**
             * Checks whether `version` satisfies the `range` specification.
             *
             * We support a subset of the expressions defined in
             * https://www.npmjs.org/doc/misc/semver.html:
             *
             *    version   Must match version exactly
             *    =version  Same as just version
             *    >version  Must be greater than version
             *    >=version Must be greater than or equal to version
             *    <version  Must be less than version
             *    <=version Must be less than or equal to version
             *    ~version  Must be at least version, but less than the next significant
             *              revision above version:
             *              "~1.2.3" is equivalent to ">= 1.2.3 and < 1.3"
             *    ~>version Equivalent to ~version
             *    1.2.x     Must match "1.2.x", where "x" is a wildcard that matches
             *              anything
             *    1.2.*     Similar to "1.2.x", but "*" in the trailing position is a
             *              "greedy" wildcard, so will match any number of additional
             *              components:
             *              "1.2.*" will match "1.2.1", "1.2.1.1", "1.2.1.1.1" etc
             *    *         Any version
             *    ""        (Empty string) Same as *
             *    v1 - v2   Equivalent to ">= v1 and <= v2"
             *    r1 || r2  Passes if either r1 or r2 are satisfied
             *
             * @param {string} range
             * @param {string} version
             * @returns {boolean}
             */
            contains: function contains(range, version) {
              return checkOrExpression(range.trim(), version.trim());
            }
          };
          VersionRange_1 = VersionRange;
          return VersionRange_1;
        }

        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         */

        var mapObject_1;
        var hasRequiredMapObject;
        function requireMapObject() {
          if (hasRequiredMapObject) return mapObject_1;
          hasRequiredMapObject = 1;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          /**
           * Executes the provided `callback` once for each enumerable own property in the
           * object and constructs a new object from the results. The `callback` is
           * invoked with three arguments:
           *
           *  - the property value
           *  - the property name
           *  - the object being traversed
           *
           * Properties that are added after the call to `mapObject` will not be visited
           * by `callback`. If the values of existing properties are changed, the value
           * passed to `callback` will be the value at the time `mapObject` visits them.
           * Properties that are deleted before being visited are not visited.
           *
           * @grep function objectMap()
           * @grep function objMap()
           *
           * @param {?object} object
           * @param {function} callback
           * @param {*} context
           * @return {?object}
           */

          function mapObject(object, callback, context) {
            if (!object) {
              return null;
            }
            var result = {};
            for (var name in object) {
              if (hasOwnProperty.call(object, name)) {
                result[name] = callback.call(context, object[name], name, object);
              }
            }
            return result;
          }
          mapObject_1 = mapObject;
          return mapObject_1;
        }

        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * 
         * @typechecks static-only
         */

        var memoizeStringOnly_1;
        var hasRequiredMemoizeStringOnly;
        function requireMemoizeStringOnly() {
          if (hasRequiredMemoizeStringOnly) return memoizeStringOnly_1;
          hasRequiredMemoizeStringOnly = 1;
          /**
           * Memoizes the return value of a function that accepts one string argument.
           */

          function memoizeStringOnly(callback) {
            var cache = {};
            return function (string) {
              if (!cache.hasOwnProperty(string)) {
                cache[string] = callback.call(this, string);
              }
              return cache[string];
            };
          }
          memoizeStringOnly_1 = memoizeStringOnly;
          return memoizeStringOnly_1;
        }

        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         */

        var UserAgent_1;
        var hasRequiredUserAgent;
        function requireUserAgent() {
          if (hasRequiredUserAgent) return UserAgent_1;
          hasRequiredUserAgent = 1;
          var UserAgentData = requireUserAgentData();
          var VersionRange = requireVersionRange();
          var mapObject = requireMapObject();
          var memoizeStringOnly = requireMemoizeStringOnly();
          /**
           * Checks to see whether `name` and `version` satisfy `query`.
           *
           * @param {string} name Name of the browser, device, engine or platform
           * @param {?string} version Version of the browser, engine or platform
           * @param {string} query Query of form "Name [range expression]"
           * @param {?function} normalizer Optional pre-processor for range expression
           * @return {boolean}
           */

          function compare(name, version, query, normalizer) {
            // check for exact match with no version
            if (name === query) {
              return true;
            } // check for non-matching names

            if (!query.startsWith(name)) {
              return false;
            } // full comparison with version

            var range = query.slice(name.length);
            if (version) {
              range = normalizer ? normalizer(range) : range;
              return VersionRange.contains(range, version);
            }
            return false;
          }
          /**
           * Normalizes `version` by stripping any "NT" prefix, but only on the Windows
           * platform.
           *
           * Mimics the stripping performed by the `UserAgentWindowsPlatform` PHP class.
           *
           * @param {string} version
           * @return {string}
           */

          function normalizePlatformVersion(version) {
            if (UserAgentData.platformName === 'Windows') {
              return version.replace(/^\s*NT/, '');
            }
            return version;
          }
          /**
           * Provides client-side access to the authoritative PHP-generated User Agent
           * information supplied by the server.
           */

          var UserAgent = {
            /**
             * Check if the User Agent browser matches `query`.
             *
             * `query` should be a string like "Chrome" or "Chrome > 33".
             *
             * Valid browser names include:
             *
             * - ACCESS NetFront
             * - AOL
             * - Amazon Silk
             * - Android
             * - BlackBerry
             * - BlackBerry PlayBook
             * - Chrome
             * - Chrome for iOS
             * - Chrome frame
             * - Facebook PHP SDK
             * - Facebook for iOS
             * - Firefox
             * - IE
             * - IE Mobile
             * - Mobile Safari
             * - Motorola Internet Browser
             * - Nokia
             * - Openwave Mobile Browser
             * - Opera
             * - Opera Mini
             * - Opera Mobile
             * - Safari
             * - UIWebView
             * - Unknown
             * - webOS
             * - etc...
             *
             * An authoritative list can be found in the PHP `BrowserDetector` class and
             * related classes in the same file (see calls to `new UserAgentBrowser` here:
             * https://fburl.com/50728104).
             *
             * @note Function results are memoized
             *
             * @param {string} query Query of the form "Name [range expression]"
             * @return {boolean}
             */
            isBrowser: function isBrowser(query) {
              return compare(UserAgentData.browserName, UserAgentData.browserFullVersion, query);
            },
            /**
             * Check if the User Agent browser uses a 32 or 64 bit architecture.
             *
             * @note Function results are memoized
             *
             * @param {string} query Query of the form "32" or "64".
             * @return {boolean}
             */
            isBrowserArchitecture: function isBrowserArchitecture(query) {
              return compare(UserAgentData.browserArchitecture, null, query);
            },
            /**
             * Check if the User Agent device matches `query`.
             *
             * `query` should be a string like "iPhone" or "iPad".
             *
             * Valid device names include:
             *
             * - Kindle
             * - Kindle Fire
             * - Unknown
             * - iPad
             * - iPhone
             * - iPod
             * - etc...
             *
             * An authoritative list can be found in the PHP `DeviceDetector` class and
             * related classes in the same file (see calls to `new UserAgentDevice` here:
             * https://fburl.com/50728332).
             *
             * @note Function results are memoized
             *
             * @param {string} query Query of the form "Name"
             * @return {boolean}
             */
            isDevice: function isDevice(query) {
              return compare(UserAgentData.deviceName, null, query);
            },
            /**
             * Check if the User Agent rendering engine matches `query`.
             *
             * `query` should be a string like "WebKit" or "WebKit >= 537".
             *
             * Valid engine names include:
             *
             * - Gecko
             * - Presto
             * - Trident
             * - WebKit
             * - etc...
             *
             * An authoritative list can be found in the PHP `RenderingEngineDetector`
             * class related classes in the same file (see calls to `new
             * UserAgentRenderingEngine` here: https://fburl.com/50728617).
             *
             * @note Function results are memoized
             *
             * @param {string} query Query of the form "Name [range expression]"
             * @return {boolean}
             */
            isEngine: function isEngine(query) {
              return compare(UserAgentData.engineName, UserAgentData.engineVersion, query);
            },
            /**
             * Check if the User Agent platform matches `query`.
             *
             * `query` should be a string like "Windows" or "iOS 5 - 6".
             *
             * Valid platform names include:
             *
             * - Android
             * - BlackBerry OS
             * - Java ME
             * - Linux
             * - Mac OS X
             * - Mac OS X Calendar
             * - Mac OS X Internet Account
             * - Symbian
             * - SymbianOS
             * - Windows
             * - Windows Mobile
             * - Windows Phone
             * - iOS
             * - iOS Facebook Integration Account
             * - iOS Facebook Social Sharing UI
             * - webOS
             * - Chrome OS
             * - etc...
             *
             * An authoritative list can be found in the PHP `PlatformDetector` class and
             * related classes in the same file (see calls to `new UserAgentPlatform`
             * here: https://fburl.com/50729226).
             *
             * @note Function results are memoized
             *
             * @param {string} query Query of the form "Name [range expression]"
             * @return {boolean}
             */
            isPlatform: function isPlatform(query) {
              return compare(UserAgentData.platformName, UserAgentData.platformFullVersion, query, normalizePlatformVersion);
            },
            /**
             * Check if the User Agent platform is a 32 or 64 bit architecture.
             *
             * @note Function results are memoized
             *
             * @param {string} query Query of the form "32" or "64".
             * @return {boolean}
             */
            isPlatformArchitecture: function isPlatformArchitecture(query) {
              return compare(UserAgentData.platformArchitecture, null, query);
            }
          };
          UserAgent_1 = mapObject(UserAgent, memoizeStringOnly);
          return UserAgent_1;
        }
        var getCorrectDocumentFromNode_1;
        var hasRequiredGetCorrectDocumentFromNode;
        function requireGetCorrectDocumentFromNode() {
          if (hasRequiredGetCorrectDocumentFromNode) return getCorrectDocumentFromNode_1;
          hasRequiredGetCorrectDocumentFromNode = 1;

          /**
           * Copyright (c) Facebook, Inc. and its affiliates.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @format
           * 
           * @emails oncall+draft_js
           */
          function getCorrectDocumentFromNode(node) {
            if (!node || !node.ownerDocument) {
              return document;
            }
            return node.ownerDocument;
          }
          getCorrectDocumentFromNode_1 = getCorrectDocumentFromNode;
          return getCorrectDocumentFromNode_1;
        }
        var isElement_1;
        var hasRequiredIsElement;
        function requireIsElement() {
          if (hasRequiredIsElement) return isElement_1;
          hasRequiredIsElement = 1;

          /**
           * Copyright (c) Facebook, Inc. and its affiliates.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @format
           * 
           * @emails oncall+draft_js
           */
          function isElement(node) {
            if (!node || !node.ownerDocument) {
              return false;
            }
            return node.nodeType === Node.ELEMENT_NODE;
          }
          isElement_1 = isElement;
          return isElement_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var getSelectionOffsetKeyForNode_1;
        var hasRequiredGetSelectionOffsetKeyForNode;
        function requireGetSelectionOffsetKeyForNode() {
          if (hasRequiredGetSelectionOffsetKeyForNode) return getSelectionOffsetKeyForNode_1;
          hasRequiredGetSelectionOffsetKeyForNode = 1;
          /**
           * Get offset key from a node or it's child nodes. Return the first offset key
           * found on the DOM tree of given node.
           */

          var isElement = requireIsElement();
          function getSelectionOffsetKeyForNode(node) {
            if (isElement(node)) {
              var castedNode = node;
              var offsetKey = castedNode.getAttribute('data-offset-key');
              if (offsetKey) {
                return offsetKey;
              }
              for (var ii = 0; ii < castedNode.childNodes.length; ii++) {
                var childOffsetKey = getSelectionOffsetKeyForNode(castedNode.childNodes[ii]);
                if (childOffsetKey) {
                  return childOffsetKey;
                }
              }
            }
            return null;
          }
          getSelectionOffsetKeyForNode_1 = getSelectionOffsetKeyForNode;
          return getSelectionOffsetKeyForNode_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var findAncestorOffsetKey_1;
        var hasRequiredFindAncestorOffsetKey;
        function requireFindAncestorOffsetKey() {
          if (hasRequiredFindAncestorOffsetKey) return findAncestorOffsetKey_1;
          hasRequiredFindAncestorOffsetKey = 1;
          var getCorrectDocumentFromNode = requireGetCorrectDocumentFromNode();
          var getSelectionOffsetKeyForNode = requireGetSelectionOffsetKeyForNode();
          /**
           * Get the key from the node's nearest offset-aware ancestor.
           */

          function findAncestorOffsetKey(node) {
            var searchNode = node;
            while (searchNode && searchNode !== getCorrectDocumentFromNode(node).documentElement) {
              var key = getSelectionOffsetKeyForNode(searchNode);
              if (key != null) {
                return key;
              }
              searchNode = searchNode.parentNode;
            }
            return null;
          }
          findAncestorOffsetKey_1 = findAncestorOffsetKey;
          return findAncestorOffsetKey_1;
        }
        var getWindowForNode_1;
        var hasRequiredGetWindowForNode;
        function requireGetWindowForNode() {
          if (hasRequiredGetWindowForNode) return getWindowForNode_1;
          hasRequiredGetWindowForNode = 1;

          /**
           * Copyright (c) Facebook, Inc. and its affiliates.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @format
           * 
           * @emails oncall+draft_js
           */
          function getWindowForNode(node) {
            if (!node || !node.ownerDocument || !node.ownerDocument.defaultView) {
              return window;
            }
            return node.ownerDocument.defaultView;
          }
          getWindowForNode_1 = getWindowForNode;
          return getWindowForNode_1;
        }
        var DOMObserver_1;
        var hasRequiredDOMObserver;
        function requireDOMObserver() {
          if (hasRequiredDOMObserver) return DOMObserver_1;
          hasRequiredDOMObserver = 1;
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var UserAgent = requireUserAgent();
          var findAncestorOffsetKey = requireFindAncestorOffsetKey();
          var getWindowForNode = requireGetWindowForNode();
          var Immutable = requireImmutable();
          var invariant = requireInvariant();
          var nullthrows = requireNullthrows();
          var Map = Immutable.Map;
          var DOM_OBSERVER_OPTIONS = {
            subtree: true,
            characterData: true,
            childList: true,
            characterDataOldValue: false,
            attributes: false
          };
          var USE_CHAR_DATA = UserAgent.isBrowser("IE <= 11");
          var DOMObserver = /* @__PURE__ */function () {
            function DOMObserver2(container) {
              var _this = this;
              _defineProperty(this, "observer", void 0);
              _defineProperty(this, "container", void 0);
              _defineProperty(this, "mutations", void 0);
              _defineProperty(this, "onCharData", void 0);
              this.container = container;
              this.mutations = Map();
              var containerWindow = getWindowForNode(container);
              if (containerWindow.MutationObserver && !USE_CHAR_DATA) {
                this.observer = new containerWindow.MutationObserver(function (mutations) {
                  return _this.registerMutations(mutations);
                });
              } else {
                this.onCharData = function (e) {
                  !(e.target instanceof Node) ? invariant(false) : void 0;
                  _this.registerMutation({
                    type: "characterData",
                    target: e.target
                  });
                };
              }
            }
            var _proto = DOMObserver2.prototype;
            _proto.start = function start() {
              if (this.observer) {
                this.observer.observe(this.container, DOM_OBSERVER_OPTIONS);
              } else {
                this.container.addEventListener("DOMCharacterDataModified", this.onCharData);
              }
            };
            _proto.stopAndFlushMutations = function stopAndFlushMutations() {
              var observer = this.observer;
              if (observer) {
                this.registerMutations(observer.takeRecords());
                observer.disconnect();
              } else {
                this.container.removeEventListener("DOMCharacterDataModified", this.onCharData);
              }
              var mutations = this.mutations;
              this.mutations = Map();
              return mutations;
            };
            _proto.registerMutations = function registerMutations(mutations) {
              for (var i = 0; i < mutations.length; i++) {
                this.registerMutation(mutations[i]);
              }
            };
            _proto.getMutationTextContent = function getMutationTextContent(mutation) {
              var type = mutation.type,
                target = mutation.target,
                removedNodes = mutation.removedNodes;
              if (type === "characterData") {
                if (target.textContent !== "") {
                  if (USE_CHAR_DATA) {
                    return target.textContent.replace("\n", "");
                  }
                  return target.textContent;
                }
              } else if (type === "childList") {
                if (removedNodes && removedNodes.length) {
                  return "";
                } else if (target.textContent !== "") {
                  return target.textContent;
                }
              }
              return null;
            };
            _proto.registerMutation = function registerMutation(mutation) {
              var textContent = this.getMutationTextContent(mutation);
              if (textContent != null) {
                var offsetKey = nullthrows(findAncestorOffsetKey(mutation.target));
                this.mutations = this.mutations.set(offsetKey, textContent);
              }
            };
            return DOMObserver2;
          }();
          DOMObserver_1 = DOMObserver;
          return DOMObserver_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DraftOffsetKey_1;
        var hasRequiredDraftOffsetKey;
        function requireDraftOffsetKey() {
          if (hasRequiredDraftOffsetKey) return DraftOffsetKey_1;
          hasRequiredDraftOffsetKey = 1;
          var KEY_DELIMITER = '-';
          var DraftOffsetKey = {
            encode: function encode(blockKey, decoratorKey, leafKey) {
              return blockKey + KEY_DELIMITER + decoratorKey + KEY_DELIMITER + leafKey;
            },
            decode: function decode(offsetKey) {
              // Extracts the last two parts of offsetKey and captures the rest in blockKeyParts
              var _offsetKey$split$reve = offsetKey.split(KEY_DELIMITER).reverse(),
                leafKey = _offsetKey$split$reve[0],
                decoratorKey = _offsetKey$split$reve[1],
                blockKeyParts = _offsetKey$split$reve.slice(2);
              return {
                // Recomposes the parts of blockKey after reversing them
                blockKey: blockKeyParts.reverse().join(KEY_DELIMITER),
                decoratorKey: parseInt(decoratorKey, 10),
                leafKey: parseInt(leafKey, 10)
              };
            }
          };
          DraftOffsetKey_1 = DraftOffsetKey;
          return DraftOffsetKey_1;
        }
        var Keys;
        var hasRequiredKeys;
        function requireKeys() {
          if (hasRequiredKeys) return Keys;
          hasRequiredKeys = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           */
          Keys = {
            BACKSPACE: 8,
            TAB: 9,
            RETURN: 13,
            ALT: 18,
            ESC: 27,
            SPACE: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            DELETE: 46,
            COMMA: 188,
            PERIOD: 190,
            A: 65,
            Z: 90,
            ZERO: 48,
            NUMPAD_0: 96,
            NUMPAD_9: 105
          };
          return Keys;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         */

        var DraftJsDebugLogging;
        var hasRequiredDraftJsDebugLogging;
        function requireDraftJsDebugLogging() {
          if (hasRequiredDraftJsDebugLogging) return DraftJsDebugLogging;
          hasRequiredDraftJsDebugLogging = 1;
          DraftJsDebugLogging = {
            logBlockedSelectionEvent: function logBlockedSelectionEvent() {
              return null;
            },
            logSelectionStateFailure: function logSelectionStateFailure() {
              return null;
            }
          };
          return DraftJsDebugLogging;
        }
        var isHTMLElement_1;
        var hasRequiredIsHTMLElement;
        function requireIsHTMLElement() {
          if (hasRequiredIsHTMLElement) return isHTMLElement_1;
          hasRequiredIsHTMLElement = 1;

          /**
           * Copyright (c) Facebook, Inc. and its affiliates.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @format
           * 
           * @emails oncall+draft_js
           */
          function isHTMLElement(node) {
            if (!node || !node.ownerDocument) {
              return false;
            }
            if (!node.ownerDocument.defaultView) {
              return node instanceof HTMLElement;
            }
            if (node instanceof node.ownerDocument.defaultView.HTMLElement) {
              return true;
            }
            return false;
          }
          isHTMLElement_1 = isHTMLElement;
          return isHTMLElement_1;
        }
        var getContentEditableContainer_1;
        var hasRequiredGetContentEditableContainer;
        function requireGetContentEditableContainer() {
          if (hasRequiredGetContentEditableContainer) return getContentEditableContainer_1;
          hasRequiredGetContentEditableContainer = 1;
          var invariant = requireInvariant();
          var isHTMLElement = requireIsHTMLElement();
          function getContentEditableContainer(editor) {
            var editorNode = editor.editorContainer;
            !editorNode ? invariant(false) : void 0;
            !isHTMLElement(editorNode.firstChild) ? invariant(false) : void 0;
            var htmlElement = editorNode.firstChild;
            return htmlElement;
          }
          getContentEditableContainer_1 = getContentEditableContainer;
          return getContentEditableContainer_1;
        }
        var getUpdatedSelectionState_1;
        var hasRequiredGetUpdatedSelectionState;
        function requireGetUpdatedSelectionState() {
          if (hasRequiredGetUpdatedSelectionState) return getUpdatedSelectionState_1;
          hasRequiredGetUpdatedSelectionState = 1;
          var DraftOffsetKey = requireDraftOffsetKey();
          var nullthrows = requireNullthrows();
          function getUpdatedSelectionState(editorState, anchorKey, anchorOffset, focusKey, focusOffset) {
            var selection = nullthrows(editorState.getSelection());
            if (!anchorKey || !focusKey) {
              return selection;
            }
            var anchorPath = DraftOffsetKey.decode(anchorKey);
            var anchorBlockKey = anchorPath.blockKey;
            var anchorLeafBlockTree = editorState.getBlockTree(anchorBlockKey);
            var anchorLeaf = anchorLeafBlockTree && anchorLeafBlockTree.getIn([anchorPath.decoratorKey, "leaves", anchorPath.leafKey]);
            var focusPath = DraftOffsetKey.decode(focusKey);
            var focusBlockKey = focusPath.blockKey;
            var focusLeafBlockTree = editorState.getBlockTree(focusBlockKey);
            var focusLeaf = focusLeafBlockTree && focusLeafBlockTree.getIn([focusPath.decoratorKey, "leaves", focusPath.leafKey]);
            if (!anchorLeaf || !focusLeaf) {
              return selection;
            }
            var anchorLeafStart = anchorLeaf.get("start");
            var focusLeafStart = focusLeaf.get("start");
            var anchorBlockOffset = anchorLeaf ? anchorLeafStart + anchorOffset : null;
            var focusBlockOffset = focusLeaf ? focusLeafStart + focusOffset : null;
            var areEqual = selection.getAnchorKey() === anchorBlockKey && selection.getAnchorOffset() === anchorBlockOffset && selection.getFocusKey() === focusBlockKey && selection.getFocusOffset() === focusBlockOffset;
            if (areEqual) {
              return selection;
            }
            var isBackward = false;
            if (anchorBlockKey === focusBlockKey) {
              var anchorLeafEnd = anchorLeaf.get("end");
              var focusLeafEnd = focusLeaf.get("end");
              if (focusLeafStart === anchorLeafStart && focusLeafEnd === anchorLeafEnd) {
                isBackward = focusOffset < anchorOffset;
              } else {
                isBackward = focusLeafStart < anchorLeafStart;
              }
            } else {
              var startKey = editorState.getCurrentContent().getBlockMap().keySeq().skipUntil(function (v) {
                return v === anchorBlockKey || v === focusBlockKey;
              }).first();
              isBackward = startKey === focusBlockKey;
            }
            return selection.merge({
              anchorKey: anchorBlockKey,
              anchorOffset: anchorBlockOffset,
              focusKey: focusBlockKey,
              focusOffset: focusBlockOffset,
              isBackward
            });
          }
          getUpdatedSelectionState_1 = getUpdatedSelectionState;
          return getUpdatedSelectionState_1;
        }
        var getDraftEditorSelectionWithNodes_1;
        var hasRequiredGetDraftEditorSelectionWithNodes;
        function requireGetDraftEditorSelectionWithNodes() {
          if (hasRequiredGetDraftEditorSelectionWithNodes) return getDraftEditorSelectionWithNodes_1;
          hasRequiredGetDraftEditorSelectionWithNodes = 1;
          var findAncestorOffsetKey = requireFindAncestorOffsetKey();
          var getSelectionOffsetKeyForNode = requireGetSelectionOffsetKeyForNode();
          var getUpdatedSelectionState = requireGetUpdatedSelectionState();
          var invariant = requireInvariant();
          var isElement = requireIsElement();
          var nullthrows = requireNullthrows();
          function getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {
            var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;
            var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE;
            if (anchorIsTextNode && focusIsTextNode) {
              return {
                selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),
                needsRecovery: false
              };
            }
            var anchorPoint = null;
            var focusPoint = null;
            var needsRecovery = true;
            if (anchorIsTextNode) {
              anchorPoint = {
                key: nullthrows(findAncestorOffsetKey(anchorNode)),
                offset: anchorOffset
              };
              focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);
            } else if (focusIsTextNode) {
              focusPoint = {
                key: nullthrows(findAncestorOffsetKey(focusNode)),
                offset: focusOffset
              };
              anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);
            } else {
              anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);
              focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);
              if (anchorNode === focusNode && anchorOffset === focusOffset) {
                needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== "BR";
              }
            }
            return {
              selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),
              needsRecovery
            };
          }
          function getFirstLeaf(node) {
            while (node.firstChild && (
            // data-blocks has no offset
            isElement(node.firstChild) && node.firstChild.getAttribute("data-blocks") === "true" || getSelectionOffsetKeyForNode(node.firstChild))) {
              node = node.firstChild;
            }
            return node;
          }
          function getLastLeaf(node) {
            while (node.lastChild && (
            // data-blocks has no offset
            isElement(node.lastChild) && node.lastChild.getAttribute("data-blocks") === "true" || getSelectionOffsetKeyForNode(node.lastChild))) {
              node = node.lastChild;
            }
            return node;
          }
          function getPointForNonTextNode(editorRoot, startNode, childOffset) {
            var node = startNode;
            var offsetKey = findAncestorOffsetKey(node);
            !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? invariant(false) : void 0;
            if (editorRoot === node) {
              node = node.firstChild;
              !isElement(node) ? invariant(false) : void 0;
              var castedNode = node;
              node = castedNode;
              !(node.getAttribute("data-contents") === "true") ? invariant(false) : void 0;
              if (childOffset > 0) {
                childOffset = node.childNodes.length;
              }
            }
            if (childOffset === 0) {
              var key = null;
              if (offsetKey != null) {
                key = offsetKey;
              } else {
                var firstLeaf = getFirstLeaf(node);
                key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));
              }
              return {
                key,
                offset: 0
              };
            }
            var nodeBeforeCursor = node.childNodes[childOffset - 1];
            var leafKey = null;
            var textLength = null;
            if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {
              leafKey = nullthrows(offsetKey);
              textLength = getTextContentLength(nodeBeforeCursor);
            } else {
              var lastLeaf = getLastLeaf(nodeBeforeCursor);
              leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));
              textLength = getTextContentLength(lastLeaf);
            }
            return {
              key: leafKey,
              offset: textLength
            };
          }
          function getTextContentLength(node) {
            var textContent = node.textContent;
            return textContent === "\n" ? 0 : textContent.length;
          }
          getDraftEditorSelectionWithNodes_1 = getDraftEditorSelectionWithNodes;
          return getDraftEditorSelectionWithNodes_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var getDraftEditorSelection_1;
        var hasRequiredGetDraftEditorSelection;
        function requireGetDraftEditorSelection() {
          if (hasRequiredGetDraftEditorSelection) return getDraftEditorSelection_1;
          hasRequiredGetDraftEditorSelection = 1;
          var getDraftEditorSelectionWithNodes = requireGetDraftEditorSelectionWithNodes();
          /**
           * Convert the current selection range to an anchor/focus pair of offset keys
           * and values that can be interpreted by components.
           */

          function getDraftEditorSelection(editorState, root) {
            var selection = root.ownerDocument.defaultView.getSelection();
            var anchorNode = selection.anchorNode,
              anchorOffset = selection.anchorOffset,
              focusNode = selection.focusNode,
              focusOffset = selection.focusOffset,
              rangeCount = selection.rangeCount;
            if (
            // No active selection.
            rangeCount === 0 ||
            // No selection, ever. As in, the user hasn't selected anything since
            // opening the document.
            anchorNode == null || focusNode == null) {
              return {
                selectionState: editorState.getSelection().set('hasFocus', false),
                needsRecovery: false
              };
            }
            return getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset);
          }
          getDraftEditorSelection_1 = getDraftEditorSelection;
          return getDraftEditorSelection_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var editOnSelect_1;
        var hasRequiredEditOnSelect;
        function requireEditOnSelect() {
          if (hasRequiredEditOnSelect) return editOnSelect_1;
          hasRequiredEditOnSelect = 1;
          var DraftJsDebugLogging = requireDraftJsDebugLogging();
          var EditorState = requireEditorState();
          var getContentEditableContainer = requireGetContentEditableContainer();
          var getDraftEditorSelection = requireGetDraftEditorSelection();
          function editOnSelect(editor) {
            if (editor._blockSelectEvents || editor._latestEditorState !== editor.props.editorState) {
              if (editor._blockSelectEvents) {
                var _editorState = editor.props.editorState;
                var selectionState = _editorState.getSelection();
                DraftJsDebugLogging.logBlockedSelectionEvent({
                  // For now I don't think we need any other info
                  anonymizedDom: 'N/A',
                  extraParams: JSON.stringify({
                    stacktrace: new Error().stack
                  }),
                  selectionState: JSON.stringify(selectionState.toJS())
                });
              }
              return;
            }
            var editorState = editor.props.editorState;
            var documentSelection = getDraftEditorSelection(editorState, getContentEditableContainer(editor));
            var updatedSelectionState = documentSelection.selectionState;
            if (updatedSelectionState !== editorState.getSelection()) {
              if (documentSelection.needsRecovery) {
                editorState = EditorState.forceSelection(editorState, updatedSelectionState);
              } else {
                editorState = EditorState.acceptSelection(editorState, updatedSelectionState);
              }
              editor.update(editorState);
            }
          }
          editOnSelect_1 = editOnSelect;
          return editOnSelect_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * Provides utilities for handling draftjs keys.
         *
         * @emails oncall+draft_js
         * 
         * @format
         */

        var draftKeyUtils;
        var hasRequiredDraftKeyUtils;
        function requireDraftKeyUtils() {
          if (hasRequiredDraftKeyUtils) return draftKeyUtils;
          hasRequiredDraftKeyUtils = 1;
          function notEmptyKey(key) {
            return key != null && key != '';
          }
          draftKeyUtils = {
            notEmptyKey: notEmptyKey
          };
          return draftKeyUtils;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var getEntityKeyForSelection_1;
        var hasRequiredGetEntityKeyForSelection;
        function requireGetEntityKeyForSelection() {
          if (hasRequiredGetEntityKeyForSelection) return getEntityKeyForSelection_1;
          hasRequiredGetEntityKeyForSelection = 1;
          var _require = requireDraftKeyUtils(),
            notEmptyKey = _require.notEmptyKey;
          /**
           * Return the entity key that should be used when inserting text for the
           * specified target selection, only if the entity is `MUTABLE`. `IMMUTABLE`
           * and `SEGMENTED` entities should not be used for insertion behavior.
           */

          function getEntityKeyForSelection(contentState, targetSelection) {
            var entityKey;
            if (targetSelection.isCollapsed()) {
              var key = targetSelection.getAnchorKey();
              var offset = targetSelection.getAnchorOffset();
              if (offset > 0) {
                entityKey = contentState.getBlockForKey(key).getEntityAt(offset - 1);
                if (entityKey !== contentState.getBlockForKey(key).getEntityAt(offset)) {
                  return null;
                }
                return filterKey(contentState.getEntityMap(), entityKey);
              }
              return null;
            }
            var startKey = targetSelection.getStartKey();
            var startOffset = targetSelection.getStartOffset();
            var startBlock = contentState.getBlockForKey(startKey);
            entityKey = startOffset === startBlock.getLength() ? null : startBlock.getEntityAt(startOffset);
            return filterKey(contentState.getEntityMap(), entityKey);
          }
          /**
           * Determine whether an entity key corresponds to a `MUTABLE` entity. If so,
           * return it. If not, return null.
           */

          function filterKey(entityMap, entityKey) {
            if (notEmptyKey(entityKey)) {
              var entity = entityMap.__get(entityKey);
              return entity.getMutability() === 'MUTABLE' ? entityKey : null;
            }
            return null;
          }
          getEntityKeyForSelection_1 = getEntityKeyForSelection;
          return getEntityKeyForSelection_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DraftEditorCompositionHandler_1;
        var hasRequiredDraftEditorCompositionHandler;
        function requireDraftEditorCompositionHandler() {
          if (hasRequiredDraftEditorCompositionHandler) return DraftEditorCompositionHandler_1;
          hasRequiredDraftEditorCompositionHandler = 1;
          var DOMObserver = requireDOMObserver();
          var DraftModifier = requireDraftModifier();
          var DraftOffsetKey = requireDraftOffsetKey();
          var EditorState = requireEditorState();
          var Keys = requireKeys();
          var UserAgent = requireUserAgent();
          var editOnSelect = requireEditOnSelect();
          var getContentEditableContainer = requireGetContentEditableContainer();
          var getDraftEditorSelection = requireGetDraftEditorSelection();
          var getEntityKeyForSelection = requireGetEntityKeyForSelection();
          var nullthrows = requireNullthrows();
          var isIE = UserAgent.isBrowser('IE');
          /**
           * Millisecond delay to allow `compositionstart` to fire again upon
           * `compositionend`.
           *
           * This is used for Korean input to ensure that typing can continue without
           * the editor trying to render too quickly. More specifically, Safari 7.1+
           * triggers `compositionstart` a little slower than Chrome/FF, which
           * leads to composed characters being resolved and re-render occurring
           * sooner than we want.
           */

          var RESOLVE_DELAY = 20;
          /**
           * A handful of variables used to track the current composition and its
           * resolution status. These exist at the module level because it is not
           * possible to have compositions occurring in multiple editors simultaneously,
           * and it simplifies state management with respect to the DraftEditor component.
           */

          var resolved = false;
          var stillComposing = false;
          var domObserver = null;
          function startDOMObserver(editor) {
            if (!domObserver) {
              domObserver = new DOMObserver(getContentEditableContainer(editor));
              domObserver.start();
            }
          }
          var DraftEditorCompositionHandler = {
            /**
             * A `compositionstart` event has fired while we're still in composition
             * mode. Continue the current composition session to prevent a re-render.
             */
            onCompositionStart: function onCompositionStart(editor) {
              stillComposing = true;
              startDOMObserver(editor);
            },
            /**
             * Attempt to end the current composition session.
             *
             * Defer handling because browser will still insert the chars into active
             * element after `compositionend`. If a `compositionstart` event fires
             * before `resolveComposition` executes, our composition session will
             * continue.
             *
             * The `resolved` flag is useful because certain IME interfaces fire the
             * `compositionend` event multiple times, thus queueing up multiple attempts
             * at handling the composition. Since handling the same composition event
             * twice could break the DOM, we only use the first event. Example: Arabic
             * Google Input Tools on Windows 8.1 fires `compositionend` three times.
             */
            onCompositionEnd: function onCompositionEnd(editor) {
              resolved = false;
              stillComposing = false;
              setTimeout(function () {
                if (!resolved) {
                  DraftEditorCompositionHandler.resolveComposition(editor);
                }
              }, RESOLVE_DELAY);
            },
            onSelect: editOnSelect,
            /**
             * In Safari, keydown events may fire when committing compositions. If
             * the arrow keys are used to commit, prevent default so that the cursor
             * doesn't move, otherwise it will jump back noticeably on re-render.
             */
            onKeyDown: function onKeyDown(editor, e) {
              if (!stillComposing) {
                // If a keydown event is received after compositionend but before the
                // 20ms timer expires (ex: type option-E then backspace, or type A then
                // backspace in 2-Set Korean), we should immediately resolve the
                // composition and reinterpret the key press in edit mode.
                DraftEditorCompositionHandler.resolveComposition(editor);
                editor._onKeyDown(e);
                return;
              }
              if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {
                e.preventDefault();
              }
            },
            /**
             * Keypress events may fire when committing compositions. In Firefox,
             * pressing RETURN commits the composition and inserts extra newline
             * characters that we do not want. `preventDefault` allows the composition
             * to be committed while preventing the extra characters.
             */
            onKeyPress: function onKeyPress(_editor, e) {
              if (e.which === Keys.RETURN) {
                e.preventDefault();
              }
            },
            /**
             * Attempt to insert composed characters into the document.
             *
             * If we are still in a composition session, do nothing. Otherwise, insert
             * the characters into the document and terminate the composition session.
             *
             * If no characters were composed -- for instance, the user
             * deleted all composed characters and committed nothing new --
             * force a re-render. We also re-render when the composition occurs
             * at the beginning of a leaf, to ensure that if the browser has
             * created a new text node for the composition, we will discard it.
             *
             * Resetting innerHTML will move focus to the beginning of the editor,
             * so we update to force it back to the correct place.
             */
            resolveComposition: function resolveComposition(editor) {
              if (stillComposing) {
                return;
              }
              var mutations = nullthrows(domObserver).stopAndFlushMutations();
              domObserver = null;
              resolved = true;
              var editorState = EditorState.set(editor._latestEditorState, {
                inCompositionMode: false
              });
              editor.exitCurrentMode();
              if (!mutations.size) {
                editor.update(editorState);
                return;
              } // TODO, check if Facebook still needs this flag or if it could be removed.
              // Since there can be multiple mutations providing a `composedChars` doesn't
              // apply well on this new model.
              // if (
              //   gkx('draft_handlebeforeinput_composed_text') &&
              //   editor.props.handleBeforeInput &&
              //   isEventHandled(
              //     editor.props.handleBeforeInput(
              //       composedChars,
              //       editorState,
              //       event.timeStamp,
              //     ),
              //   )
              // ) {
              //   return;
              // }

              var contentState = editorState.getCurrentContent();
              mutations.forEach(function (composedChars, offsetKey) {
                var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey),
                  blockKey = _DraftOffsetKey$decod.blockKey,
                  decoratorKey = _DraftOffsetKey$decod.decoratorKey,
                  leafKey = _DraftOffsetKey$decod.leafKey;
                var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]),
                  start = _editorState$getBlock.start,
                  end = _editorState$getBlock.end;
                var replacementRange = editorState.getSelection().merge({
                  anchorKey: blockKey,
                  focusKey: blockKey,
                  anchorOffset: start,
                  focusOffset: end,
                  isBackward: false
                });
                var entityKey = getEntityKeyForSelection(contentState, replacementRange);
                var currentStyle = contentState.getBlockForKey(blockKey).getInlineStyleAt(start);
                contentState = DraftModifier.replaceText(contentState, replacementRange, composedChars, currentStyle, entityKey); // We need to update the editorState so the leaf node ranges are properly
                // updated and multiple mutations are correctly applied.

                editorState = EditorState.set(editorState, {
                  currentContent: contentState
                });
              }); // When we apply the text changes to the ContentState, the selection always
              // goes to the end of the field, but it should just stay where it is
              // after compositionEnd.

              var documentSelection = getDraftEditorSelection(editorState, getContentEditableContainer(editor));
              var compositionEndSelectionState = documentSelection.selectionState;
              editor.restoreEditorDOM(); // See:
              // - https://github.com/facebook/draft-js/issues/2093
              // - https://github.com/facebook/draft-js/pull/2094
              // Apply this fix only in IE for now. We can test it in
              // other browsers in the future to ensure no regressions

              var editorStateWithUpdatedSelection = isIE ? EditorState.forceSelection(editorState, compositionEndSelectionState) : EditorState.acceptSelection(editorState, compositionEndSelectionState);
              editor.update(EditorState.push(editorStateWithUpdatedSelection, contentState, 'insert-characters'));
            }
          };
          DraftEditorCompositionHandler_1 = DraftEditorCompositionHandler;
          return DraftEditorCompositionHandler_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         *
         * This is unstable and not part of the public API and should not be used by
         * production systems. This file may be update/removed without notice.
         */

        var DraftEditorDecoratedLeaves_react;
        var hasRequiredDraftEditorDecoratedLeaves_react;
        function requireDraftEditorDecoratedLeaves_react() {
          if (hasRequiredDraftEditorDecoratedLeaves_react) return DraftEditorDecoratedLeaves_react;
          hasRequiredDraftEditorDecoratedLeaves_react = 1;
          var _assign = requireObjectAssign();
          function _extends() {
            _extends = _assign || function (target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            return _extends.apply(this, arguments);
          }
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var DraftOffsetKey = requireDraftOffsetKey();
          var React = requireReact();
          var UnicodeBidi = requireUnicodeBidi();
          var UnicodeBidiDirection = requireUnicodeBidiDirection();
          var DraftEditorDecoratedLeaves = /*#__PURE__*/function (_React$Component) {
            _inheritsLoose(DraftEditorDecoratedLeaves, _React$Component);
            function DraftEditorDecoratedLeaves() {
              return _React$Component.apply(this, arguments) || this;
            }
            var _proto = DraftEditorDecoratedLeaves.prototype;
            _proto.render = function render() {
              var _this$props = this.props,
                block = _this$props.block,
                children = _this$props.children,
                contentState = _this$props.contentState,
                decorator = _this$props.decorator,
                decoratorKey = _this$props.decoratorKey,
                direction = _this$props.direction,
                leafSet = _this$props.leafSet,
                text = _this$props.text;
              var blockKey = block.getKey();
              var leavesForLeafSet = leafSet.get('leaves');
              var DecoratorComponent = decorator.getComponentForKey(decoratorKey);
              var decoratorProps = decorator.getPropsForKey(decoratorKey);
              var decoratorOffsetKey = DraftOffsetKey.encode(blockKey, parseInt(decoratorKey, 10), 0);
              var decoratedText = text.slice(leavesForLeafSet.first().get('start'), leavesForLeafSet.last().get('end')); // Resetting dir to the same value on a child node makes Chrome/Firefox
              // confused on cursor movement. See http://jsfiddle.net/d157kLck/3/

              var dir = UnicodeBidiDirection.getHTMLDirIfDifferent(UnicodeBidi.getDirection(decoratedText), direction);
              return React.createElement(DecoratorComponent, _extends({}, decoratorProps, {
                contentState: contentState,
                decoratedText: decoratedText,
                dir: dir,
                key: decoratorOffsetKey,
                entityKey: block.getEntityAt(leafSet.get('start')),
                offsetKey: decoratorOffsetKey
              }), children);
            };
            return DraftEditorDecoratedLeaves;
          }(React.Component);
          DraftEditorDecoratedLeaves_react = DraftEditorDecoratedLeaves;
          return DraftEditorDecoratedLeaves_react;
        }
        var DraftEditorTextNode_react;
        var hasRequiredDraftEditorTextNode_react;
        function requireDraftEditorTextNode_react() {
          if (hasRequiredDraftEditorTextNode_react) return DraftEditorTextNode_react;
          hasRequiredDraftEditorTextNode_react = 1;
          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self;
          }
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var React = requireReact();
          var UserAgent = requireUserAgent();
          var invariant = requireInvariant();
          var isElement = requireIsElement();
          var useNewlineChar = UserAgent.isBrowser("IE <= 11");
          function isNewline(node) {
            return useNewlineChar ? node.textContent === "\n" : node.tagName === "BR";
          }
          var NEWLINE_A = function NEWLINE_A2(ref) {
            return useNewlineChar ? React.createElement("span", {
              key: "A",
              "data-text": "true",
              ref
            }, "\n") : React.createElement("br", {
              key: "A",
              "data-text": "true",
              ref
            });
          };
          var NEWLINE_B = function NEWLINE_B2(ref) {
            return useNewlineChar ? React.createElement("span", {
              key: "B",
              "data-text": "true",
              ref
            }, "\n") : React.createElement("br", {
              key: "B",
              "data-text": "true",
              ref
            });
          };
          var DraftEditorTextNode = /* @__PURE__ */function (_React$Component) {
            _inheritsLoose(DraftEditorTextNode2, _React$Component);
            function DraftEditorTextNode2(props) {
              var _this;
              _this = _React$Component.call(this, props) || this;
              _defineProperty(_assertThisInitialized(_this), "_forceFlag", void 0);
              _defineProperty(_assertThisInitialized(_this), "_node", void 0);
              _this._forceFlag = false;
              return _this;
            }
            var _proto = DraftEditorTextNode2.prototype;
            _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
              var node = this._node;
              var shouldBeNewline = nextProps.children === "";
              !isElement(node) ? invariant(false) : void 0;
              var elementNode = node;
              if (shouldBeNewline) {
                return !isNewline(elementNode);
              }
              return elementNode.textContent !== nextProps.children;
            };
            _proto.componentDidMount = function componentDidMount() {
              this._forceFlag = !this._forceFlag;
            };
            _proto.componentDidUpdate = function componentDidUpdate() {
              this._forceFlag = !this._forceFlag;
            };
            _proto.render = function render() {
              var _this2 = this;
              if (this.props.children === "") {
                return this._forceFlag ? NEWLINE_A(function (ref) {
                  return _this2._node = ref;
                }) : NEWLINE_B(function (ref) {
                  return _this2._node = ref;
                });
              }
              return React.createElement("span", {
                key: this._forceFlag ? "A" : "B",
                "data-text": "true",
                ref: function ref(_ref) {
                  return _this2._node = _ref;
                }
              }, this.props.children);
            };
            return DraftEditorTextNode2;
          }(React.Component);
          DraftEditorTextNode_react = DraftEditorTextNode;
          return DraftEditorTextNode_react;
        }
        var isHTMLBRElement_1;
        var hasRequiredIsHTMLBRElement;
        function requireIsHTMLBRElement() {
          if (hasRequiredIsHTMLBRElement) return isHTMLBRElement_1;
          hasRequiredIsHTMLBRElement = 1;

          /**
           * Copyright (c) Facebook, Inc. and its affiliates.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @format
           * 
           * @emails oncall+draft_js
           */
          var isElement = requireIsElement();
          function isHTMLBRElement(node) {
            if (!node || !node.ownerDocument) {
              return false;
            }
            return isElement(node) && node.nodeName === 'BR';
          }
          isHTMLBRElement_1 = isHTMLBRElement;
          return isHTMLBRElement_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         */

        var DraftEffects;
        var hasRequiredDraftEffects;
        function requireDraftEffects() {
          if (hasRequiredDraftEffects) return DraftEffects;
          hasRequiredDraftEffects = 1;
          DraftEffects = {
            initODS: function initODS() {},
            handleExtensionCausedError: function handleExtensionCausedError() {}
          };
          return DraftEffects;
        }
        var isNode_1;
        var hasRequiredIsNode;
        function requireIsNode() {
          if (hasRequiredIsNode) return isNode_1;
          hasRequiredIsNode = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */

          /**
           * @param {*} object The object to check.
           * @return {boolean} Whether or not the object is a DOM node.
           */
          function isNode(object) {
            var doc = object ? object.ownerDocument || object : document;
            var defaultView = doc.defaultView || window;
            return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
          }
          isNode_1 = isNode;
          return isNode_1;
        }
        var isTextNode_1;
        var hasRequiredIsTextNode;
        function requireIsTextNode() {
          if (hasRequiredIsTextNode) return isTextNode_1;
          hasRequiredIsTextNode = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */
          var isNode = requireIsNode();
          /**
           * @param {*} object The object to check.
           * @return {boolean} Whether or not the object is a DOM text node.
           */

          function isTextNode(object) {
            return isNode(object) && object.nodeType == 3;
          }
          isTextNode_1 = isTextNode;
          return isTextNode_1;
        }
        var containsNode_1;
        var hasRequiredContainsNode;
        function requireContainsNode() {
          if (hasRequiredContainsNode) return containsNode_1;
          hasRequiredContainsNode = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * 
           */
          var isTextNode = requireIsTextNode();
          /*eslint-disable no-bitwise */

          /**
           * Checks if a given DOM node contains or is another DOM node.
           */

          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ('contains' in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }
          containsNode_1 = containsNode;
          return containsNode_1;
        }
        var getActiveElement_1;
        var hasRequiredGetActiveElement;
        function requireGetActiveElement() {
          if (hasRequiredGetActiveElement) return getActiveElement_1;
          hasRequiredGetActiveElement = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */

          /* eslint-disable fb-www/typeof-undefined */

          /**
           * Same as document.activeElement but wraps in a try-catch block. In IE it is
           * not safe to call document.activeElement if there is nothing focused.
           *
           * The activeElement will be null only if the document or document body is not
           * yet defined.
           *
           * @param {?DOMDocument} doc Defaults to current document.
           * @return {?DOMElement}
           */
          function getActiveElement(doc) /*?DOMElement*/
          {
            doc = doc || (typeof document !== 'undefined' ? document : undefined);
            if (typeof doc === 'undefined') {
              return null;
            }
            try {
              return doc.activeElement || doc.body;
            } catch (e) {
              return doc.body;
            }
          }
          getActiveElement_1 = getActiveElement;
          return getActiveElement_1;
        }
        var setDraftEditorSelection_1;
        var hasRequiredSetDraftEditorSelection;
        function requireSetDraftEditorSelection() {
          if (hasRequiredSetDraftEditorSelection) return setDraftEditorSelection_1;
          hasRequiredSetDraftEditorSelection = 1;
          var DraftEffects = requireDraftEffects();
          var DraftJsDebugLogging = requireDraftJsDebugLogging();
          var UserAgent = requireUserAgent();
          var containsNode = requireContainsNode();
          var getActiveElement = requireGetActiveElement();
          var getCorrectDocumentFromNode = requireGetCorrectDocumentFromNode();
          var invariant = requireInvariant();
          var isElement = requireIsElement();
          var isIE = UserAgent.isBrowser("IE");
          function getAnonymizedDOM(node, getNodeLabels) {
            if (!node) {
              return "[empty]";
            }
            var anonymized = anonymizeTextWithin(node, getNodeLabels);
            if (anonymized.nodeType === Node.TEXT_NODE) {
              return anonymized.textContent;
            }
            !isElement(anonymized) ? invariant(false) : void 0;
            var castedElement = anonymized;
            return castedElement.outerHTML;
          }
          function anonymizeTextWithin(node, getNodeLabels) {
            var labels = getNodeLabels !== void 0 ? getNodeLabels(node) : [];
            if (node.nodeType === Node.TEXT_NODE) {
              var length = node.textContent.length;
              return getCorrectDocumentFromNode(node).createTextNode("[text " + length + (labels.length ? " | " + labels.join(", ") : "") + "]");
            }
            var clone = node.cloneNode();
            if (clone.nodeType === 1 && labels.length) {
              clone.setAttribute("data-labels", labels.join(", "));
            }
            var childNodes = node.childNodes;
            for (var ii = 0; ii < childNodes.length; ii++) {
              clone.appendChild(anonymizeTextWithin(childNodes[ii], getNodeLabels));
            }
            return clone;
          }
          function getAnonymizedEditorDOM(node, getNodeLabels) {
            var currentNode = node;
            var castedNode = currentNode;
            while (currentNode) {
              if (isElement(currentNode) && castedNode.hasAttribute("contenteditable")) {
                return getAnonymizedDOM(currentNode, getNodeLabels);
              } else {
                currentNode = currentNode.parentNode;
                castedNode = currentNode;
              }
            }
            return "Could not find contentEditable parent of node";
          }
          function getNodeLength(node) {
            return node.nodeValue === null ? node.childNodes.length : node.nodeValue.length;
          }
          function setDraftEditorSelection(selectionState, node, blockKey, nodeStart, nodeEnd) {
            var documentObject = getCorrectDocumentFromNode(node);
            if (!containsNode(documentObject.documentElement, node)) {
              return;
            }
            var selection = documentObject.defaultView.getSelection();
            var anchorKey = selectionState.getAnchorKey();
            var anchorOffset = selectionState.getAnchorOffset();
            var focusKey = selectionState.getFocusKey();
            var focusOffset = selectionState.getFocusOffset();
            var isBackward = selectionState.getIsBackward();
            if (!selection.extend && isBackward) {
              var tempKey = anchorKey;
              var tempOffset = anchorOffset;
              anchorKey = focusKey;
              anchorOffset = focusOffset;
              focusKey = tempKey;
              focusOffset = tempOffset;
              isBackward = false;
            }
            var hasAnchor = anchorKey === blockKey && nodeStart <= anchorOffset && nodeEnd >= anchorOffset;
            var hasFocus = focusKey === blockKey && nodeStart <= focusOffset && nodeEnd >= focusOffset;
            if (hasAnchor && hasFocus) {
              selection.removeAllRanges();
              addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
              addFocusToSelection(selection, node, focusOffset - nodeStart, selectionState);
              return;
            }
            if (!isBackward) {
              if (hasAnchor) {
                selection.removeAllRanges();
                addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
              }
              if (hasFocus) {
                addFocusToSelection(selection, node, focusOffset - nodeStart, selectionState);
              }
            } else {
              if (hasFocus) {
                selection.removeAllRanges();
                addPointToSelection(selection, node, focusOffset - nodeStart, selectionState);
              }
              if (hasAnchor) {
                var storedFocusNode = selection.focusNode;
                var storedFocusOffset = selection.focusOffset;
                selection.removeAllRanges();
                addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
                addFocusToSelection(selection, storedFocusNode, storedFocusOffset, selectionState);
              }
            }
          }
          function addFocusToSelection(selection, node, offset, selectionState) {
            var activeElement = getActiveElement();
            var extend = selection.extend;
            if (extend && node != null && containsNode(activeElement, node)) {
              if (offset > getNodeLength(node)) {
                DraftJsDebugLogging.logSelectionStateFailure({
                  anonymizedDom: getAnonymizedEditorDOM(node),
                  extraParams: JSON.stringify({
                    offset
                  }),
                  selectionState: JSON.stringify(selectionState.toJS())
                });
              }
              var nodeWasFocus = node === selection.focusNode;
              try {
                if (selection.rangeCount > 0 && selection.extend) {
                  selection.extend(node, offset);
                }
              } catch (e) {
                DraftJsDebugLogging.logSelectionStateFailure({
                  anonymizedDom: getAnonymizedEditorDOM(node, function (n) {
                    var labels = [];
                    if (n === activeElement) {
                      labels.push("active element");
                    }
                    if (n === selection.anchorNode) {
                      labels.push("selection anchor node");
                    }
                    if (n === selection.focusNode) {
                      labels.push("selection focus node");
                    }
                    return labels;
                  }),
                  extraParams: JSON.stringify({
                    activeElementName: activeElement ? activeElement.nodeName : null,
                    nodeIsFocus: node === selection.focusNode,
                    nodeWasFocus,
                    selectionRangeCount: selection.rangeCount,
                    selectionAnchorNodeName: selection.anchorNode ? selection.anchorNode.nodeName : null,
                    selectionAnchorOffset: selection.anchorOffset,
                    selectionFocusNodeName: selection.focusNode ? selection.focusNode.nodeName : null,
                    selectionFocusOffset: selection.focusOffset,
                    message: e ? "" + e : null,
                    offset
                  }, null, 2),
                  selectionState: JSON.stringify(selectionState.toJS(), null, 2)
                });
                throw e;
              }
            } else {
              if (node && selection.rangeCount > 0) {
                var range = selection.getRangeAt(0);
                range.setEnd(node, offset);
                selection.addRange(range.cloneRange());
              }
            }
          }
          function addPointToSelection(selection, node, offset, selectionState) {
            var range = getCorrectDocumentFromNode(node).createRange();
            if (offset > getNodeLength(node)) {
              DraftJsDebugLogging.logSelectionStateFailure({
                anonymizedDom: getAnonymizedEditorDOM(node),
                extraParams: JSON.stringify({
                  offset
                }),
                selectionState: JSON.stringify(selectionState.toJS())
              });
              DraftEffects.handleExtensionCausedError();
            }
            range.setStart(node, offset);
            if (isIE) {
              try {
                selection.addRange(range);
              } catch (e) {}
            } else {
              selection.addRange(range);
            }
          }
          setDraftEditorSelection_1 = {
            setDraftEditorSelection,
            addFocusToSelection
          };
          return setDraftEditorSelection_1;
        }
        var DraftEditorLeaf_react;
        var hasRequiredDraftEditorLeaf_react;
        function requireDraftEditorLeaf_react() {
          if (hasRequiredDraftEditorLeaf_react) return DraftEditorLeaf_react;
          hasRequiredDraftEditorLeaf_react = 1;
          var _assign = requireObjectAssign();
          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self;
          }
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var DraftEditorTextNode = requireDraftEditorTextNode_react();
          var React = requireReact();
          var invariant = requireInvariant();
          var isHTMLBRElement = requireIsHTMLBRElement();
          var setDraftEditorSelection = requireSetDraftEditorSelection().setDraftEditorSelection;
          var DraftEditorLeaf = /* @__PURE__ */function (_React$Component) {
            _inheritsLoose(DraftEditorLeaf2, _React$Component);
            function DraftEditorLeaf2() {
              var _this;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
              _defineProperty(_assertThisInitialized(_this), "leaf", void 0);
              return _this;
            }
            var _proto = DraftEditorLeaf2.prototype;
            _proto._setSelection = function _setSelection() {
              var selection = this.props.selection;
              if (selection == null || !selection.getHasFocus()) {
                return;
              }
              var _this$props = this.props,
                block = _this$props.block,
                start = _this$props.start,
                text = _this$props.text;
              var blockKey = block.getKey();
              var end = start + text.length;
              if (!selection.hasEdgeWithin(blockKey, start, end)) {
                return;
              }
              var node = this.leaf;
              !node ? invariant(false) : void 0;
              var child = node.firstChild;
              !child ? invariant(false) : void 0;
              var targetNode;
              if (child.nodeType === Node.TEXT_NODE) {
                targetNode = child;
              } else if (isHTMLBRElement(child)) {
                targetNode = node;
              } else {
                targetNode = child.firstChild;
                !targetNode ? invariant(false) : void 0;
              }
              setDraftEditorSelection(selection, targetNode, blockKey, start, end);
            };
            _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
              var leafNode = this.leaf;
              !leafNode ? invariant(false) : void 0;
              var shouldUpdate = leafNode.textContent !== nextProps.text || nextProps.styleSet !== this.props.styleSet || nextProps.forceSelection;
              return shouldUpdate;
            };
            _proto.componentDidUpdate = function componentDidUpdate() {
              this._setSelection();
            };
            _proto.componentDidMount = function componentDidMount() {
              this._setSelection();
            };
            _proto.render = function render() {
              var _this2 = this;
              var block = this.props.block;
              var text = this.props.text;
              if (text.endsWith("\n") && this.props.isLast) {
                text += "\n";
              }
              var _this$props2 = this.props,
                customStyleMap = _this$props2.customStyleMap,
                customStyleFn = _this$props2.customStyleFn,
                offsetKey = _this$props2.offsetKey,
                styleSet = _this$props2.styleSet;
              var styleObj = styleSet.reduce(function (map, styleName) {
                var mergedStyles = {};
                var style = customStyleMap[styleName];
                if (style !== void 0 && map.textDecoration !== style.textDecoration) {
                  mergedStyles.textDecoration = [map.textDecoration, style.textDecoration].join(" ").trim();
                }
                return _assign(map, style, mergedStyles);
              }, {});
              if (customStyleFn) {
                var newStyles = customStyleFn(styleSet, block);
                styleObj = _assign(styleObj, newStyles);
              }
              return React.createElement("span", {
                "data-offset-key": offsetKey,
                ref: function ref(_ref) {
                  return _this2.leaf = _ref;
                },
                style: styleObj
              }, React.createElement(DraftEditorTextNode, null, text));
            };
            return DraftEditorLeaf2;
          }(React.Component);
          DraftEditorLeaf_react = DraftEditorLeaf;
          return DraftEditorLeaf_react;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         *
         * This is unstable and not part of the public API and should not be used by
         * production systems. This file may be update/removed without notice.
         */

        var DraftEditorNode_react;
        var hasRequiredDraftEditorNode_react;
        function requireDraftEditorNode_react() {
          if (hasRequiredDraftEditorNode_react) return DraftEditorNode_react;
          hasRequiredDraftEditorNode_react = 1;
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var DraftEditorDecoratedLeaves = requireDraftEditorDecoratedLeaves_react();
          var DraftEditorLeaf = requireDraftEditorLeaf_react();
          var DraftOffsetKey = requireDraftOffsetKey();
          var Immutable = requireImmutable();
          var React = requireReact();
          var cx = requireCx();
          Immutable.List;
          var DraftEditorNode = /*#__PURE__*/function (_React$Component) {
            _inheritsLoose(DraftEditorNode, _React$Component);
            function DraftEditorNode() {
              return _React$Component.apply(this, arguments) || this;
            }
            var _proto = DraftEditorNode.prototype;
            _proto.render = function render() {
              var _this$props = this.props,
                block = _this$props.block,
                contentState = _this$props.contentState,
                customStyleFn = _this$props.customStyleFn,
                customStyleMap = _this$props.customStyleMap,
                decorator = _this$props.decorator,
                direction = _this$props.direction,
                forceSelection = _this$props.forceSelection,
                hasSelection = _this$props.hasSelection,
                selection = _this$props.selection,
                tree = _this$props.tree;
              var blockKey = block.getKey();
              var text = block.getText();
              var lastLeafSet = tree.size - 1;
              var children = this.props.children || tree.map(function (leafSet, ii) {
                var decoratorKey = leafSet.get('decoratorKey');
                var leavesForLeafSet = leafSet.get('leaves');
                var lastLeaf = leavesForLeafSet.size - 1;
                var Leaves = leavesForLeafSet.map(function (leaf, jj) {
                  var offsetKey = DraftOffsetKey.encode(blockKey, ii, jj);
                  var start = leaf.get('start');
                  var end = leaf.get('end');
                  return React.createElement(DraftEditorLeaf, {
                    key: offsetKey,
                    offsetKey: offsetKey,
                    block: block,
                    start: start,
                    selection: hasSelection ? selection : null,
                    forceSelection: forceSelection,
                    text: text.slice(start, end),
                    styleSet: block.getInlineStyleAt(start),
                    customStyleMap: customStyleMap,
                    customStyleFn: customStyleFn,
                    isLast: decoratorKey === lastLeafSet && jj === lastLeaf
                  });
                }).toArray();
                if (!decoratorKey || !decorator) {
                  return Leaves;
                }
                return React.createElement(DraftEditorDecoratedLeaves, {
                  block: block,
                  children: Leaves,
                  contentState: contentState,
                  decorator: decorator,
                  decoratorKey: decoratorKey,
                  direction: direction,
                  leafSet: leafSet,
                  text: text,
                  key: ii
                });
              }).toArray();
              return React.createElement("div", {
                "data-offset-key": DraftOffsetKey.encode(blockKey, 0, 0),
                className: cx({
                  'public/DraftStyleDefault/block': true,
                  'public/DraftStyleDefault/ltr': direction === 'LTR',
                  'public/DraftStyleDefault/rtl': direction === 'RTL'
                })
              }, children);
            };
            return DraftEditorNode;
          }(React.Component);
          DraftEditorNode_react = DraftEditorNode;
          return DraftEditorNode_react;
        }
        var Scroll_1;
        var hasRequiredScroll;
        function requireScroll() {
          if (hasRequiredScroll) return Scroll_1;
          hasRequiredScroll = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           */

          /**
           * @param {DOMElement} element
           * @param {DOMDocument} doc
           * @return {boolean}
           */
          function _isViewportScrollElement(element, doc) {
            return !!doc && (element === doc.documentElement || element === doc.body);
          }
          /**
           * Scroll Module. This class contains 4 simple static functions
           * to be used to access Element.scrollTop/scrollLeft properties.
           * To solve the inconsistencies between browsers when either
           * document.body or document.documentElement is supplied,
           * below logic will be used to alleviate the issue:
           *
           * 1. If 'element' is either 'document.body' or 'document.documentElement,
           *    get whichever element's 'scroll{Top,Left}' is larger.
           * 2. If 'element' is either 'document.body' or 'document.documentElement',
           *    set the 'scroll{Top,Left}' on both elements.
           */

          var Scroll = {
            /**
             * @param {DOMElement} element
             * @return {number}
             */
            getTop: function getTop(element) {
              var doc = element.ownerDocument;
              return _isViewportScrollElement(element, doc) ?
              // In practice, they will either both have the same value,
              // or one will be zero and the other will be the scroll position
              // of the viewport. So we can use `X || Y` instead of `Math.max(X, Y)`
              doc.body.scrollTop || doc.documentElement.scrollTop : element.scrollTop;
            },
            /**
             * @param {DOMElement} element
             * @param {number} newTop
             */
            setTop: function setTop(element, newTop) {
              var doc = element.ownerDocument;
              if (_isViewportScrollElement(element, doc)) {
                doc.body.scrollTop = doc.documentElement.scrollTop = newTop;
              } else {
                element.scrollTop = newTop;
              }
            },
            /**
             * @param {DOMElement} element
             * @return {number}
             */
            getLeft: function getLeft(element) {
              var doc = element.ownerDocument;
              return _isViewportScrollElement(element, doc) ? doc.body.scrollLeft || doc.documentElement.scrollLeft : element.scrollLeft;
            },
            /**
             * @param {DOMElement} element
             * @param {number} newLeft
             */
            setLeft: function setLeft(element, newLeft) {
              var doc = element.ownerDocument;
              if (_isViewportScrollElement(element, doc)) {
                doc.body.scrollLeft = doc.documentElement.scrollLeft = newLeft;
              } else {
                element.scrollLeft = newLeft;
              }
            }
          };
          Scroll_1 = Scroll;
          return Scroll_1;
        }
        var camelize_1;
        var hasRequiredCamelize;
        function requireCamelize() {
          if (hasRequiredCamelize) return camelize_1;
          hasRequiredCamelize = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */
          var _hyphenPattern = /-(.)/g;
          /**
           * Camelcases a hyphenated string, for example:
           *
           *   > camelize('background-color')
           *   < "backgroundColor"
           *
           * @param {string} string
           * @return {string}
           */

          function camelize(string) {
            return string.replace(_hyphenPattern, function (_, character) {
              return character.toUpperCase();
            });
          }
          camelize_1 = camelize;
          return camelize_1;
        }
        var hyphenate_1;
        var hasRequiredHyphenate;
        function requireHyphenate() {
          if (hasRequiredHyphenate) return hyphenate_1;
          hasRequiredHyphenate = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */
          var _uppercasePattern = /([A-Z])/g;
          /**
           * Hyphenates a camelcased string, for example:
           *
           *   > hyphenate('backgroundColor')
           *   < "background-color"
           *
           * For CSS style names, use `hyphenateStyleName` instead which works properly
           * with all vendor prefixes, including `ms`.
           *
           * @param {string} string
           * @return {string}
           */

          function hyphenate(string) {
            return string.replace(_uppercasePattern, '-$1').toLowerCase();
          }
          hyphenate_1 = hyphenate;
          return hyphenate_1;
        }
        var getStyleProperty_1;
        var hasRequiredGetStyleProperty;
        function requireGetStyleProperty() {
          if (hasRequiredGetStyleProperty) return getStyleProperty_1;
          hasRequiredGetStyleProperty = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */
          var camelize = requireCamelize();
          var hyphenate = requireHyphenate();
          function asString(value) /*?string*/
          {
            return value == null ? value : String(value);
          }
          function getStyleProperty(/*DOMNode*/
          node, /*string*/
          name) /*?string*/
          {
            var computedStyle; // W3C Standard

            if (window.getComputedStyle) {
              // In certain cases such as within an iframe in FF3, this returns null.
              computedStyle = window.getComputedStyle(node, null);
              if (computedStyle) {
                return asString(computedStyle.getPropertyValue(hyphenate(name)));
              }
            } // Safari

            if (document.defaultView && document.defaultView.getComputedStyle) {
              computedStyle = document.defaultView.getComputedStyle(node, null); // A Safari bug causes this to return null for `display: none` elements.

              if (computedStyle) {
                return asString(computedStyle.getPropertyValue(hyphenate(name)));
              }
              if (name === 'display') {
                return 'none';
              }
            } // Internet Explorer

            if (node.currentStyle) {
              if (name === 'float') {
                return asString(node.currentStyle.cssFloat || node.currentStyle.styleFloat);
              }
              return asString(node.currentStyle[camelize(name)]);
            }
            return asString(node.style && node.style[camelize(name)]);
          }
          getStyleProperty_1 = getStyleProperty;
          return getStyleProperty_1;
        }
        var Style_1;
        var hasRequiredStyle;
        function requireStyle() {
          if (hasRequiredStyle) return Style_1;
          hasRequiredStyle = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */
          var getStyleProperty = requireGetStyleProperty();
          /**
           * @param {DOMNode} element [description]
           * @param {string} name Overflow style property name.
           * @return {boolean} True if the supplied ndoe is scrollable.
           */

          function _isNodeScrollable(element, name) {
            var overflow = Style.get(element, name);
            return overflow === 'auto' || overflow === 'scroll';
          }
          /**
           * Utilities for querying and mutating style properties.
           */

          var Style = {
            /**
             * Gets the style property for the supplied node. This will return either the
             * computed style, if available, or the declared style.
             *
             * @param {DOMNode} node
             * @param {string} name Style property name.
             * @return {?string} Style property value.
             */
            get: getStyleProperty,
            /**
             * Determines the nearest ancestor of a node that is scrollable.
             *
             * NOTE: This can be expensive if used repeatedly or on a node nested deeply.
             *
             * @param {?DOMNode} node Node from which to start searching.
             * @return {?DOMWindow|DOMElement} Scroll parent of the supplied node.
             */
            getScrollParent: function getScrollParent(node) {
              if (!node) {
                return null;
              }
              var ownerDocument = node.ownerDocument;
              while (node && node !== ownerDocument.body) {
                if (_isNodeScrollable(node, 'overflow') || _isNodeScrollable(node, 'overflowY') || _isNodeScrollable(node, 'overflowX')) {
                  return node;
                }
                node = node.parentNode;
              }
              return ownerDocument.defaultView || ownerDocument.parentWindow;
            }
          };
          Style_1 = Style;
          return Style_1;
        }
        var getElementRect_1;
        var hasRequiredGetElementRect;
        function requireGetElementRect() {
          if (hasRequiredGetElementRect) return getElementRect_1;
          hasRequiredGetElementRect = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */
          var containsNode = requireContainsNode();
          /**
           * Gets an element's bounding rect in pixels relative to the viewport.
           *
           * @param {DOMElement} elem
           * @return {object}
           */

          function getElementRect(elem) {
            var docElem = elem.ownerDocument.documentElement; // FF 2, Safari 3 and Opera 9.5- do not support getBoundingClientRect().
            // IE9- will throw if the element is not in the document.

            if (!('getBoundingClientRect' in elem) || !containsNode(docElem, elem)) {
              return {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
              };
            } // Subtracts clientTop/Left because IE8- added a 2px border to the
            // <html> element (see http://fburl.com/1493213). IE 7 in
            // Quicksmode does not report clientLeft/clientTop so there
            // will be an unaccounted offset of 2px when in quirksmode

            var rect = elem.getBoundingClientRect();
            return {
              left: Math.round(rect.left) - docElem.clientLeft,
              right: Math.round(rect.right) - docElem.clientLeft,
              top: Math.round(rect.top) - docElem.clientTop,
              bottom: Math.round(rect.bottom) - docElem.clientTop
            };
          }
          getElementRect_1 = getElementRect;
          return getElementRect_1;
        }
        var getElementPosition_1;
        var hasRequiredGetElementPosition;
        function requireGetElementPosition() {
          if (hasRequiredGetElementPosition) return getElementPosition_1;
          hasRequiredGetElementPosition = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */
          var getElementRect = requireGetElementRect();
          /**
           * Gets an element's position in pixels relative to the viewport. The returned
           * object represents the position of the element's top left corner.
           *
           * @param {DOMElement} element
           * @return {object}
           */

          function getElementPosition(element) {
            var rect = getElementRect(element);
            return {
              x: rect.left,
              y: rect.top,
              width: rect.right - rect.left,
              height: rect.bottom - rect.top
            };
          }
          getElementPosition_1 = getElementPosition;
          return getElementPosition_1;
        }

        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @typechecks
         */

        var getDocumentScrollElement_1;
        var hasRequiredGetDocumentScrollElement;
        function requireGetDocumentScrollElement() {
          if (hasRequiredGetDocumentScrollElement) return getDocumentScrollElement_1;
          hasRequiredGetDocumentScrollElement = 1;
          var isWebkit = typeof navigator !== 'undefined' && navigator.userAgent.indexOf('AppleWebKit') > -1;
          /**
           * Gets the element with the document scroll properties such as `scrollLeft` and
           * `scrollHeight`. This may differ across different browsers.
           *
           * NOTE: The return value can be null if the DOM is not yet ready.
           *
           * @param {?DOMDocument} doc Defaults to current document.
           * @return {?DOMElement}
           */

          function getDocumentScrollElement(doc) {
            doc = doc || document;
            if (doc.scrollingElement) {
              return doc.scrollingElement;
            }
            return !isWebkit && doc.compatMode === 'CSS1Compat' ? doc.documentElement : doc.body;
          }
          getDocumentScrollElement_1 = getDocumentScrollElement;
          return getDocumentScrollElement_1;
        }

        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @typechecks
         */

        var getUnboundedScrollPosition_1;
        var hasRequiredGetUnboundedScrollPosition;
        function requireGetUnboundedScrollPosition() {
          if (hasRequiredGetUnboundedScrollPosition) return getUnboundedScrollPosition_1;
          hasRequiredGetUnboundedScrollPosition = 1;
          /**
           * Gets the scroll position of the supplied element or window.
           *
           * The return values are unbounded, unlike `getScrollPosition`. This means they
           * may be negative or exceed the element boundaries (which is possible using
           * inertial scrolling).
           *
           * @param {DOMWindow|DOMElement} scrollable
           * @return {object} Map with `x` and `y` keys.
           */

          function getUnboundedScrollPosition(scrollable) {
            if (scrollable.Window && scrollable instanceof scrollable.Window) {
              return {
                x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
                y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
              };
            }
            return {
              x: scrollable.scrollLeft,
              y: scrollable.scrollTop
            };
          }
          getUnboundedScrollPosition_1 = getUnboundedScrollPosition;
          return getUnboundedScrollPosition_1;
        }

        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @typechecks
         */

        var getScrollPosition_1;
        var hasRequiredGetScrollPosition;
        function requireGetScrollPosition() {
          if (hasRequiredGetScrollPosition) return getScrollPosition_1;
          hasRequiredGetScrollPosition = 1;
          var getDocumentScrollElement = requireGetDocumentScrollElement();
          var getUnboundedScrollPosition = requireGetUnboundedScrollPosition();
          /**
           * Gets the scroll position of the supplied element or window.
           *
           * The return values are bounded. This means that if the scroll position is
           * negative or exceeds the element boundaries (which is possible using inertial
           * scrolling), you will get zero or the maximum scroll position, respectively.
           *
           * If you need the unbound scroll position, use `getUnboundedScrollPosition`.
           *
           * @param {DOMWindow|DOMElement} scrollable
           * @return {object} Map with `x` and `y` keys.
           */

          function getScrollPosition(scrollable) {
            var documentScrollElement = getDocumentScrollElement(scrollable.ownerDocument || scrollable.document);
            if (scrollable.Window && scrollable instanceof scrollable.Window) {
              scrollable = documentScrollElement;
            }
            var scrollPosition = getUnboundedScrollPosition(scrollable);
            var viewport = scrollable === documentScrollElement ? scrollable.ownerDocument.documentElement : scrollable;
            var xMax = scrollable.scrollWidth - viewport.clientWidth;
            var yMax = scrollable.scrollHeight - viewport.clientHeight;
            scrollPosition.x = Math.max(0, Math.min(scrollPosition.x, xMax));
            scrollPosition.y = Math.max(0, Math.min(scrollPosition.y, yMax));
            return scrollPosition;
          }
          getScrollPosition_1 = getScrollPosition;
          return getScrollPosition_1;
        }
        var getViewportDimensions_1;
        var hasRequiredGetViewportDimensions;
        function requireGetViewportDimensions() {
          if (hasRequiredGetViewportDimensions) return getViewportDimensions_1;
          hasRequiredGetViewportDimensions = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * 
           * @typechecks
           */
          function getViewportWidth() {
            var width;
            if (document.documentElement) {
              width = document.documentElement.clientWidth;
            }
            if (!width && document.body) {
              width = document.body.clientWidth;
            }
            return width || 0;
          }
          function getViewportHeight() {
            var height;
            if (document.documentElement) {
              height = document.documentElement.clientHeight;
            }
            if (!height && document.body) {
              height = document.body.clientHeight;
            }
            return height || 0;
          }
          /**
           * Gets the viewport dimensions including any scrollbars.
           */

          function getViewportDimensions() {
            return {
              width: window.innerWidth || getViewportWidth(),
              height: window.innerHeight || getViewportHeight()
            };
          }
          /**
           * Gets the viewport dimensions excluding any scrollbars.
           */

          getViewportDimensions.withoutScrollbars = function () {
            return {
              width: getViewportWidth(),
              height: getViewportHeight()
            };
          };
          getViewportDimensions_1 = getViewportDimensions;
          return getViewportDimensions_1;
        }
        var DraftEditorBlockNode_react;
        var hasRequiredDraftEditorBlockNode_react;
        function requireDraftEditorBlockNode_react() {
          if (hasRequiredDraftEditorBlockNode_react) return DraftEditorBlockNode_react;
          hasRequiredDraftEditorBlockNode_react = 1;
          var _assign = requireObjectAssign();
          function _extends() {
            _extends = _assign || function (target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            return _extends.apply(this, arguments);
          }
          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self;
          }
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === "function") {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var DraftEditorNode = requireDraftEditorNode_react();
          var DraftOffsetKey = requireDraftOffsetKey();
          var React = requireReact();
          var Scroll = requireScroll();
          var Style = requireStyle();
          var getElementPosition = requireGetElementPosition();
          var getScrollPosition = requireGetScrollPosition();
          var getViewportDimensions = requireGetViewportDimensions();
          var Immutable = requireImmutable();
          var invariant = requireInvariant();
          var isHTMLElement = requireIsHTMLElement();
          var SCROLL_BUFFER = 10;
          Immutable.List;
          var isBlockOnSelectionEdge = function isBlockOnSelectionEdge2(selection, key) {
            return selection.getAnchorKey() === key || selection.getFocusKey() === key;
          };
          var shouldNotAddWrapperElement = function shouldNotAddWrapperElement2(block, contentState) {
            var nextSiblingKey = block.getNextSiblingKey();
            return nextSiblingKey ? contentState.getBlockForKey(nextSiblingKey).getType() === block.getType() : false;
          };
          var applyWrapperElementToSiblings = function applyWrapperElementToSiblings2(wrapperTemplate, Element, nodes) {
            var wrappedSiblings = [];
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = nodes.reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var sibling = _step.value;
                if (sibling.type !== Element) {
                  break;
                }
                wrappedSiblings.push(sibling);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            nodes.splice(nodes.indexOf(wrappedSiblings[0]), wrappedSiblings.length + 1);
            var childrenIs = wrappedSiblings.reverse();
            var key = childrenIs[0].key;
            nodes.push(React.cloneElement(wrapperTemplate, {
              key: "".concat(key, "-wrap"),
              "data-offset-key": DraftOffsetKey.encode(key, 0, 0)
            }, childrenIs));
            return nodes;
          };
          var getDraftRenderConfig = function getDraftRenderConfig2(block, blockRenderMap) {
            var configForType = blockRenderMap.get(block.getType()) || blockRenderMap.get("unstyled");
            var wrapperTemplate = configForType.wrapper;
            var Element = configForType.element || blockRenderMap.get("unstyled").element;
            return {
              Element,
              wrapperTemplate
            };
          };
          var getCustomRenderConfig = function getCustomRenderConfig2(block, blockRendererFn) {
            var customRenderer = blockRendererFn(block);
            if (!customRenderer) {
              return {};
            }
            var CustomComponent = customRenderer.component,
              customProps = customRenderer.props,
              customEditable = customRenderer.editable;
            return {
              CustomComponent,
              customProps,
              customEditable
            };
          };
          var getElementPropsConfig = function getElementPropsConfig2(block, editorKey, offsetKey, blockStyleFn, customConfig, ref) {
            var elementProps = {
              "data-block": true,
              "data-editor": editorKey,
              "data-offset-key": offsetKey,
              key: block.getKey(),
              ref
            };
            var customClass = blockStyleFn(block);
            if (customClass) {
              elementProps.className = customClass;
            }
            if (customConfig.customEditable !== void 0) {
              elementProps = _objectSpread({}, elementProps, {
                contentEditable: customConfig.customEditable,
                suppressContentEditableWarning: true
              });
            }
            return elementProps;
          };
          var DraftEditorBlockNode = /* @__PURE__ */function (_React$Component) {
            _inheritsLoose(DraftEditorBlockNode2, _React$Component);
            function DraftEditorBlockNode2() {
              var _this;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
              _defineProperty(_assertThisInitialized(_this), "wrapperRef", React.createRef());
              return _this;
            }
            var _proto = DraftEditorBlockNode2.prototype;
            _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
              var _this$props = this.props,
                block = _this$props.block,
                direction = _this$props.direction,
                tree = _this$props.tree;
              var isContainerNode = !block.getChildKeys().isEmpty();
              var blockHasChanged = block !== nextProps.block || tree !== nextProps.tree || direction !== nextProps.direction || isBlockOnSelectionEdge(nextProps.selection, nextProps.block.getKey()) && nextProps.forceSelection;
              return isContainerNode || blockHasChanged;
            };
            _proto.componentDidMount = function componentDidMount() {
              var selection = this.props.selection;
              var endKey = selection.getEndKey();
              if (!selection.getHasFocus() || endKey !== this.props.block.getKey()) {
                return;
              }
              var blockNode = this.wrapperRef.current;
              if (!blockNode) {
                return;
              }
              var scrollParent = Style.getScrollParent(blockNode);
              var scrollPosition = getScrollPosition(scrollParent);
              var scrollDelta;
              if (scrollParent === window) {
                var nodePosition = getElementPosition(blockNode);
                var nodeBottom = nodePosition.y + nodePosition.height;
                var viewportHeight = getViewportDimensions().height;
                scrollDelta = nodeBottom - viewportHeight;
                if (scrollDelta > 0) {
                  window.scrollTo(scrollPosition.x, scrollPosition.y + scrollDelta + SCROLL_BUFFER);
                }
              } else {
                !isHTMLElement(blockNode) ? invariant(false) : void 0;
                var htmlBlockNode = blockNode;
                var blockBottom = htmlBlockNode.offsetHeight + htmlBlockNode.offsetTop;
                var scrollBottom = scrollParent.offsetHeight + scrollPosition.y;
                scrollDelta = blockBottom - scrollBottom;
                if (scrollDelta > 0) {
                  Scroll.setTop(scrollParent, Scroll.getTop(scrollParent) + scrollDelta + SCROLL_BUFFER);
                }
              }
            };
            _proto.render = function render() {
              var _this2 = this;
              var _this$props2 = this.props,
                block = _this$props2.block,
                blockRenderMap = _this$props2.blockRenderMap,
                blockRendererFn = _this$props2.blockRendererFn,
                blockStyleFn = _this$props2.blockStyleFn,
                contentState = _this$props2.contentState,
                decorator = _this$props2.decorator,
                editorKey = _this$props2.editorKey,
                editorState = _this$props2.editorState,
                customStyleFn = _this$props2.customStyleFn,
                customStyleMap = _this$props2.customStyleMap,
                direction = _this$props2.direction,
                forceSelection = _this$props2.forceSelection,
                selection = _this$props2.selection,
                tree = _this$props2.tree;
              var children = null;
              if (block.children.size) {
                children = block.children.reduce(function (acc, key) {
                  var offsetKey2 = DraftOffsetKey.encode(key, 0, 0);
                  var child = contentState.getBlockForKey(key);
                  var customConfig2 = getCustomRenderConfig(child, blockRendererFn);
                  var Component2 = customConfig2.CustomComponent || DraftEditorBlockNode2;
                  var _getDraftRenderConfig = getDraftRenderConfig(child, blockRenderMap),
                    Element2 = _getDraftRenderConfig.Element,
                    wrapperTemplate = _getDraftRenderConfig.wrapperTemplate;
                  var elementProps2 = getElementPropsConfig(child, editorKey, offsetKey2, blockStyleFn, customConfig2, null);
                  var childProps = _objectSpread({}, _this2.props, {
                    tree: editorState.getBlockTree(key),
                    blockProps: customConfig2.customProps,
                    offsetKey: offsetKey2,
                    block: child
                  });
                  acc.push(React.createElement(Element2, elementProps2, React.createElement(Component2, childProps)));
                  if (!wrapperTemplate || shouldNotAddWrapperElement(child, contentState)) {
                    return acc;
                  }
                  applyWrapperElementToSiblings(wrapperTemplate, Element2, acc);
                  return acc;
                }, []);
              }
              var blockKey = block.getKey();
              var offsetKey = DraftOffsetKey.encode(blockKey, 0, 0);
              var customConfig = getCustomRenderConfig(block, blockRendererFn);
              var Component = customConfig.CustomComponent;
              var blockNode = Component != null ? React.createElement(Component, _extends({}, this.props, {
                tree: editorState.getBlockTree(blockKey),
                blockProps: customConfig.customProps,
                offsetKey,
                block
              })) : React.createElement(DraftEditorNode, {
                block,
                children,
                contentState,
                customStyleFn,
                customStyleMap,
                decorator,
                direction,
                forceSelection,
                hasSelection: isBlockOnSelectionEdge(selection, blockKey),
                selection,
                tree
              });
              if (block.getParentKey()) {
                return blockNode;
              }
              var _getDraftRenderConfig2 = getDraftRenderConfig(block, blockRenderMap),
                Element = _getDraftRenderConfig2.Element;
              var elementProps = getElementPropsConfig(block, editorKey, offsetKey, blockStyleFn, customConfig, this.wrapperRef);
              return React.createElement(Element, elementProps, blockNode);
            };
            return DraftEditorBlockNode2;
          }(React.Component);
          DraftEditorBlockNode_react = DraftEditorBlockNode;
          return DraftEditorBlockNode_react;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         *
         * This file is a fork of DraftEditorContents.react.js for tree nodes
         *
         * This is unstable and not part of the public API and should not be used by
         * production systems. This file may be update/removed without notice.
         */

        var DraftEditorContentsExperimental_react;
        var hasRequiredDraftEditorContentsExperimental_react;
        function requireDraftEditorContentsExperimental_react() {
          if (hasRequiredDraftEditorContentsExperimental_react) return DraftEditorContentsExperimental_react;
          hasRequiredDraftEditorContentsExperimental_react = 1;
          var _assign = requireObjectAssign();
          function _extends() {
            _extends = _assign || function (target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            return _extends.apply(this, arguments);
          }
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var DraftEditorBlockNode = requireDraftEditorBlockNode_react();
          var DraftOffsetKey = requireDraftOffsetKey();
          var React = requireReact();
          var nullthrows = requireNullthrows();

          /**
           * `DraftEditorContents` is the container component for all block components
           * rendered for a `DraftEditor`. It is optimized to aggressively avoid
           * re-rendering blocks whenever possible.
           *
           * This component is separate from `DraftEditor` because certain props
           * (for instance, ARIA props) must be allowed to update without affecting
           * the contents of the editor.
           */
          var DraftEditorContentsExperimental = /*#__PURE__*/function (_React$Component) {
            _inheritsLoose(DraftEditorContentsExperimental, _React$Component);
            function DraftEditorContentsExperimental() {
              return _React$Component.apply(this, arguments) || this;
            }
            var _proto = DraftEditorContentsExperimental.prototype;
            _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
              var prevEditorState = this.props.editorState;
              var nextEditorState = nextProps.editorState;
              var prevDirectionMap = prevEditorState.getDirectionMap();
              var nextDirectionMap = nextEditorState.getDirectionMap(); // Text direction has changed for one or more blocks. We must re-render.

              if (prevDirectionMap !== nextDirectionMap) {
                return true;
              }
              var didHaveFocus = prevEditorState.getSelection().getHasFocus();
              var nowHasFocus = nextEditorState.getSelection().getHasFocus();
              if (didHaveFocus !== nowHasFocus) {
                return true;
              }
              var nextNativeContent = nextEditorState.getNativelyRenderedContent();
              var wasComposing = prevEditorState.isInCompositionMode();
              var nowComposing = nextEditorState.isInCompositionMode(); // If the state is unchanged or we're currently rendering a natively
              // rendered state, there's nothing new to be done.

              if (prevEditorState === nextEditorState || nextNativeContent !== null && nextEditorState.getCurrentContent() === nextNativeContent || wasComposing && nowComposing) {
                return false;
              }
              var prevContent = prevEditorState.getCurrentContent();
              var nextContent = nextEditorState.getCurrentContent();
              var prevDecorator = prevEditorState.getDecorator();
              var nextDecorator = nextEditorState.getDecorator();
              return wasComposing !== nowComposing || prevContent !== nextContent || prevDecorator !== nextDecorator || nextEditorState.mustForceSelection();
            };
            _proto.render = function render() {
              var _this$props = this.props,
                blockRenderMap = _this$props.blockRenderMap,
                blockRendererFn = _this$props.blockRendererFn,
                blockStyleFn = _this$props.blockStyleFn,
                customStyleMap = _this$props.customStyleMap,
                customStyleFn = _this$props.customStyleFn,
                editorState = _this$props.editorState,
                editorKey = _this$props.editorKey,
                textDirectionality = _this$props.textDirectionality;
              var content = editorState.getCurrentContent();
              var selection = editorState.getSelection();
              var forceSelection = editorState.mustForceSelection();
              var decorator = editorState.getDecorator();
              var directionMap = nullthrows(editorState.getDirectionMap());
              var blocksAsArray = content.getBlocksAsArray();
              var rootBlock = blocksAsArray[0];
              var processedBlocks = [];
              var nodeBlock = rootBlock;
              while (nodeBlock) {
                var blockKey = nodeBlock.getKey();
                var blockProps = {
                  blockRenderMap: blockRenderMap,
                  blockRendererFn: blockRendererFn,
                  blockStyleFn: blockStyleFn,
                  contentState: content,
                  customStyleFn: customStyleFn,
                  customStyleMap: customStyleMap,
                  decorator: decorator,
                  editorKey: editorKey,
                  editorState: editorState,
                  forceSelection: forceSelection,
                  selection: selection,
                  block: nodeBlock,
                  direction: textDirectionality ? textDirectionality : directionMap.get(blockKey),
                  tree: editorState.getBlockTree(blockKey)
                };
                var configForType = blockRenderMap.get(nodeBlock.getType()) || blockRenderMap.get('unstyled');
                var wrapperTemplate = configForType.wrapper;
                processedBlocks.push({
                  /* $FlowFixMe[incompatible-type] (>=0.112.0 site=www,mobile) This
                   * comment suppresses an error found when Flow v0.112 was deployed. To
                   * see the error delete this comment and run Flow. */
                  block: React.createElement(DraftEditorBlockNode, _extends({
                    key: blockKey
                  }, blockProps)),
                  wrapperTemplate: wrapperTemplate,
                  key: blockKey,
                  offsetKey: DraftOffsetKey.encode(blockKey, 0, 0)
                });
                var nextBlockKey = nodeBlock.getNextSiblingKey();
                nodeBlock = nextBlockKey ? content.getBlockForKey(nextBlockKey) : null;
              } // Group contiguous runs of blocks that have the same wrapperTemplate

              var outputBlocks = [];
              for (var ii = 0; ii < processedBlocks.length;) {
                var info = processedBlocks[ii];
                if (info.wrapperTemplate) {
                  var blocks = [];
                  do {
                    blocks.push(processedBlocks[ii].block);
                    ii++;
                  } while (ii < processedBlocks.length && processedBlocks[ii].wrapperTemplate === info.wrapperTemplate);
                  var wrapperElement = React.cloneElement(info.wrapperTemplate, {
                    key: info.key + '-wrap',
                    'data-offset-key': info.offsetKey
                  }, blocks);
                  outputBlocks.push(wrapperElement);
                } else {
                  outputBlocks.push(info.block);
                  ii++;
                }
              }
              return React.createElement("div", {
                "data-contents": "true"
              }, outputBlocks);
            };
            return DraftEditorContentsExperimental;
          }(React.Component);
          DraftEditorContentsExperimental_react = DraftEditorContentsExperimental;
          return DraftEditorContentsExperimental_react;
        }
        var DraftEditorBlock_react;
        var hasRequiredDraftEditorBlock_react;
        function requireDraftEditorBlock_react() {
          if (hasRequiredDraftEditorBlock_react) return DraftEditorBlock_react;
          hasRequiredDraftEditorBlock_react = 1;
          var _assign = requireObjectAssign();
          function _extends() {
            _extends = _assign || function (target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            return _extends.apply(this, arguments);
          }
          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self;
          }
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var DraftEditorLeaf = requireDraftEditorLeaf_react();
          var DraftOffsetKey = requireDraftOffsetKey();
          var React = requireReact();
          var Scroll = requireScroll();
          var Style = requireStyle();
          var UnicodeBidi = requireUnicodeBidi();
          var UnicodeBidiDirection = requireUnicodeBidiDirection();
          var cx = requireCx();
          var getElementPosition = requireGetElementPosition();
          var getScrollPosition = requireGetScrollPosition();
          var getViewportDimensions = requireGetViewportDimensions();
          var invariant = requireInvariant();
          var isHTMLElement = requireIsHTMLElement();
          var nullthrows = requireNullthrows();
          var SCROLL_BUFFER = 10;
          var isBlockOnSelectionEdge = function isBlockOnSelectionEdge2(selection, key) {
            return selection.getAnchorKey() === key || selection.getFocusKey() === key;
          };
          var DraftEditorBlock = /* @__PURE__ */function (_React$Component) {
            _inheritsLoose(DraftEditorBlock2, _React$Component);
            function DraftEditorBlock2() {
              var _this;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
              _defineProperty(_assertThisInitialized(_this), "_node", void 0);
              return _this;
            }
            var _proto = DraftEditorBlock2.prototype;
            _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
              return this.props.block !== nextProps.block || this.props.tree !== nextProps.tree || this.props.direction !== nextProps.direction || isBlockOnSelectionEdge(nextProps.selection, nextProps.block.getKey()) && nextProps.forceSelection;
            };
            _proto.componentDidMount = function componentDidMount() {
              if (this.props.preventScroll) {
                return;
              }
              var selection = this.props.selection;
              var endKey = selection.getEndKey();
              if (!selection.getHasFocus() || endKey !== this.props.block.getKey()) {
                return;
              }
              var blockNode = this._node;
              if (blockNode == null) {
                return;
              }
              var scrollParent = Style.getScrollParent(blockNode);
              var scrollPosition = getScrollPosition(scrollParent);
              var scrollDelta;
              if (scrollParent === window) {
                var nodePosition = getElementPosition(blockNode);
                var nodeBottom = nodePosition.y + nodePosition.height;
                var viewportHeight = getViewportDimensions().height;
                scrollDelta = nodeBottom - viewportHeight;
                if (scrollDelta > 0) {
                  window.scrollTo(scrollPosition.x, scrollPosition.y + scrollDelta + SCROLL_BUFFER);
                }
              } else {
                !isHTMLElement(blockNode) ? invariant(false) : void 0;
                var blockBottom = blockNode.offsetHeight + blockNode.offsetTop;
                var pOffset = scrollParent.offsetTop + scrollParent.offsetHeight;
                var scrollBottom = pOffset + scrollPosition.y;
                scrollDelta = blockBottom - scrollBottom;
                if (scrollDelta > 0) {
                  Scroll.setTop(scrollParent, Scroll.getTop(scrollParent) + scrollDelta + SCROLL_BUFFER);
                }
              }
            };
            _proto._renderChildren = function _renderChildren() {
              var _this2 = this;
              var block = this.props.block;
              var blockKey = block.getKey();
              var text = block.getText();
              var lastLeafSet = this.props.tree.size - 1;
              var hasSelection = isBlockOnSelectionEdge(this.props.selection, blockKey);
              return this.props.tree.map(function (leafSet, ii) {
                var leavesForLeafSet = leafSet.get("leaves");
                if (leavesForLeafSet.size === 0) {
                  return null;
                }
                var lastLeaf = leavesForLeafSet.size - 1;
                var leaves = leavesForLeafSet.map(function (leaf, jj) {
                  var offsetKey = DraftOffsetKey.encode(blockKey, ii, jj);
                  var start2 = leaf.get("start");
                  var end2 = leaf.get("end");
                  return React.createElement(DraftEditorLeaf, {
                    key: offsetKey,
                    offsetKey,
                    block,
                    start: start2,
                    selection: hasSelection ? _this2.props.selection : null,
                    forceSelection: _this2.props.forceSelection,
                    text: text.slice(start2, end2),
                    styleSet: block.getInlineStyleAt(start2),
                    customStyleMap: _this2.props.customStyleMap,
                    customStyleFn: _this2.props.customStyleFn,
                    isLast: ii === lastLeafSet && jj === lastLeaf
                  });
                }).toArray();
                var decoratorKey = leafSet.get("decoratorKey");
                if (decoratorKey == null) {
                  return leaves;
                }
                if (!_this2.props.decorator) {
                  return leaves;
                }
                var decorator = nullthrows(_this2.props.decorator);
                var DecoratorComponent = decorator.getComponentForKey(decoratorKey);
                if (!DecoratorComponent) {
                  return leaves;
                }
                var decoratorProps = decorator.getPropsForKey(decoratorKey);
                var decoratorOffsetKey = DraftOffsetKey.encode(blockKey, ii, 0);
                var start = leavesForLeafSet.first().get("start");
                var end = leavesForLeafSet.last().get("end");
                var decoratedText = text.slice(start, end);
                var entityKey = block.getEntityAt(leafSet.get("start"));
                var dir = UnicodeBidiDirection.getHTMLDirIfDifferent(UnicodeBidi.getDirection(decoratedText), _this2.props.direction);
                var commonProps = {
                  contentState: _this2.props.contentState,
                  decoratedText,
                  dir,
                  start,
                  end,
                  blockKey,
                  entityKey,
                  offsetKey: decoratorOffsetKey
                };
                return React.createElement(DecoratorComponent, _extends({}, decoratorProps, commonProps, {
                  key: decoratorOffsetKey
                }), leaves);
              }).toArray();
            };
            _proto.render = function render() {
              var _this3 = this;
              var _this$props = this.props,
                direction = _this$props.direction,
                offsetKey = _this$props.offsetKey;
              var className = cx({
                "public/DraftStyleDefault/block": true,
                "public/DraftStyleDefault/ltr": direction === "LTR",
                "public/DraftStyleDefault/rtl": direction === "RTL"
              });
              return React.createElement("div", {
                "data-offset-key": offsetKey,
                className,
                ref: function ref(_ref) {
                  return _this3._node = _ref;
                }
              }, this._renderChildren());
            };
            return DraftEditorBlock2;
          }(React.Component);
          DraftEditorBlock_react = DraftEditorBlock;
          return DraftEditorBlock_react;
        }

        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * 
         * @typechecks static-only
         */

        var joinClasses_1;
        var hasRequiredJoinClasses;
        function requireJoinClasses() {
          if (hasRequiredJoinClasses) return joinClasses_1;
          hasRequiredJoinClasses = 1;
          /**
           * Combines multiple className strings into one.
           */

          function joinClasses(className) {
            var newClassName = className || '';
            var argLength = arguments.length;
            if (argLength > 1) {
              for (var index = 1; index < argLength; index++) {
                var nextClass = arguments[index];
                if (nextClass) {
                  newClassName = (newClassName ? newClassName + ' ' : '') + nextClass;
                }
              }
            }
            return newClassName;
          }
          joinClasses_1 = joinClasses;
          return joinClasses_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DraftEditorContentsCore_react;
        var hasRequiredDraftEditorContentsCore_react;
        function requireDraftEditorContentsCore_react() {
          if (hasRequiredDraftEditorContentsCore_react) return DraftEditorContentsCore_react;
          hasRequiredDraftEditorContentsCore_react = 1;
          var _assign = requireObjectAssign();
          function _extends() {
            _extends = _assign || function (target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            return _extends.apply(this, arguments);
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var DraftEditorBlock = requireDraftEditorBlock_react();
          var DraftOffsetKey = requireDraftOffsetKey();
          var React = requireReact();
          var cx = requireCx();
          var joinClasses = requireJoinClasses();
          var nullthrows = requireNullthrows();

          /**
           * Provide default styling for list items. This way, lists will be styled with
           * proper counters and indentation even if the caller does not specify
           * their own styling at all. If more than five levels of nesting are needed,
           * the necessary CSS classes can be provided via `blockStyleFn` configuration.
           */
          var getListItemClasses = function getListItemClasses(type, depth, shouldResetCount, direction) {
            return cx({
              'public/DraftStyleDefault/unorderedListItem': type === 'unordered-list-item',
              'public/DraftStyleDefault/orderedListItem': type === 'ordered-list-item',
              'public/DraftStyleDefault/reset': shouldResetCount,
              'public/DraftStyleDefault/depth0': depth === 0,
              'public/DraftStyleDefault/depth1': depth === 1,
              'public/DraftStyleDefault/depth2': depth === 2,
              'public/DraftStyleDefault/depth3': depth === 3,
              'public/DraftStyleDefault/depth4': depth >= 4,
              'public/DraftStyleDefault/listLTR': direction === 'LTR',
              'public/DraftStyleDefault/listRTL': direction === 'RTL'
            });
          };
          /**
           * `DraftEditorContents` is the container component for all block components
           * rendered for a `DraftEditor`. It is optimized to aggressively avoid
           * re-rendering blocks whenever possible.
           *
           * This component is separate from `DraftEditor` because certain props
           * (for instance, ARIA props) must be allowed to update without affecting
           * the contents of the editor.
           */

          var DraftEditorContents = /*#__PURE__*/function (_React$Component) {
            _inheritsLoose(DraftEditorContents, _React$Component);
            function DraftEditorContents() {
              return _React$Component.apply(this, arguments) || this;
            }
            var _proto = DraftEditorContents.prototype;
            _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
              var prevEditorState = this.props.editorState;
              var nextEditorState = nextProps.editorState;
              var prevDirectionMap = prevEditorState.getDirectionMap();
              var nextDirectionMap = nextEditorState.getDirectionMap(); // Text direction has changed for one or more blocks. We must re-render.

              if (prevDirectionMap !== nextDirectionMap) {
                return true;
              }
              var didHaveFocus = prevEditorState.getSelection().getHasFocus();
              var nowHasFocus = nextEditorState.getSelection().getHasFocus();
              if (didHaveFocus !== nowHasFocus) {
                return true;
              }
              var nextNativeContent = nextEditorState.getNativelyRenderedContent();
              var wasComposing = prevEditorState.isInCompositionMode();
              var nowComposing = nextEditorState.isInCompositionMode(); // If the state is unchanged or we're currently rendering a natively
              // rendered state, there's nothing new to be done.

              if (prevEditorState === nextEditorState || nextNativeContent !== null && nextEditorState.getCurrentContent() === nextNativeContent || wasComposing && nowComposing) {
                return false;
              }
              var prevContent = prevEditorState.getCurrentContent();
              var nextContent = nextEditorState.getCurrentContent();
              var prevDecorator = prevEditorState.getDecorator();
              var nextDecorator = nextEditorState.getDecorator();
              return wasComposing !== nowComposing || prevContent !== nextContent || prevDecorator !== nextDecorator || nextEditorState.mustForceSelection();
            };
            _proto.render = function render() {
              var _this$props = this.props,
                blockRenderMap = _this$props.blockRenderMap,
                blockRendererFn = _this$props.blockRendererFn,
                blockStyleFn = _this$props.blockStyleFn,
                customStyleMap = _this$props.customStyleMap,
                customStyleFn = _this$props.customStyleFn,
                editorState = _this$props.editorState,
                editorKey = _this$props.editorKey,
                preventScroll = _this$props.preventScroll,
                textDirectionality = _this$props.textDirectionality;
              var content = editorState.getCurrentContent();
              var selection = editorState.getSelection();
              var forceSelection = editorState.mustForceSelection();
              var decorator = editorState.getDecorator();
              var directionMap = nullthrows(editorState.getDirectionMap());
              var blocksAsArray = content.getBlocksAsArray();
              var processedBlocks = [];
              var currentDepth = null;
              var lastWrapperTemplate = null;
              for (var ii = 0; ii < blocksAsArray.length; ii++) {
                var _block = blocksAsArray[ii];
                var key = _block.getKey();
                var blockType = _block.getType();
                var customRenderer = blockRendererFn(_block);
                var CustomComponent = void 0,
                  customProps = void 0,
                  customEditable = void 0;
                if (customRenderer) {
                  CustomComponent = customRenderer.component;
                  customProps = customRenderer.props;
                  customEditable = customRenderer.editable;
                }
                var direction = textDirectionality ? textDirectionality : directionMap.get(key);
                var offsetKey = DraftOffsetKey.encode(key, 0, 0);
                var componentProps = {
                  contentState: content,
                  block: _block,
                  blockProps: customProps,
                  blockStyleFn: blockStyleFn,
                  customStyleMap: customStyleMap,
                  customStyleFn: customStyleFn,
                  decorator: decorator,
                  direction: direction,
                  forceSelection: forceSelection,
                  offsetKey: offsetKey,
                  preventScroll: preventScroll,
                  selection: selection,
                  tree: editorState.getBlockTree(key)
                };
                var configForType = blockRenderMap.get(blockType) || blockRenderMap.get('unstyled');
                var wrapperTemplate = configForType.wrapper;
                var Element = configForType.element || blockRenderMap.get('unstyled').element;
                var depth = _block.getDepth();
                var _className = '';
                if (blockStyleFn) {
                  _className = blockStyleFn(_block);
                } // List items are special snowflakes, since we handle nesting and
                // counters manually.

                if (Element === 'li') {
                  var shouldResetCount = lastWrapperTemplate !== wrapperTemplate || currentDepth === null || depth > currentDepth;
                  _className = joinClasses(_className, getListItemClasses(blockType, depth, shouldResetCount, direction));
                }
                var Component = CustomComponent || DraftEditorBlock;
                var childProps = {
                  className: _className,
                  'data-block': true,
                  'data-editor': editorKey,
                  'data-offset-key': offsetKey,
                  key: key
                };
                if (customEditable !== undefined) {
                  childProps = _objectSpread({}, childProps, {
                    contentEditable: customEditable,
                    suppressContentEditableWarning: true
                  });
                }
                var child = React.createElement(Element, childProps,
                /* $FlowFixMe[incompatible-type] (>=0.112.0 site=www,mobile) This
                 * comment suppresses an error found when Flow v0.112 was deployed. To
                 * see the error delete this comment and run Flow. */
                React.createElement(Component, _extends({}, componentProps, {
                  key: key
                })));
                processedBlocks.push({
                  block: child,
                  wrapperTemplate: wrapperTemplate,
                  key: key,
                  offsetKey: offsetKey
                });
                if (wrapperTemplate) {
                  currentDepth = _block.getDepth();
                } else {
                  currentDepth = null;
                }
                lastWrapperTemplate = wrapperTemplate;
              } // Group contiguous runs of blocks that have the same wrapperTemplate

              var outputBlocks = [];
              for (var _ii = 0; _ii < processedBlocks.length;) {
                var info = processedBlocks[_ii];
                if (info.wrapperTemplate) {
                  var blocks = [];
                  do {
                    blocks.push(processedBlocks[_ii].block);
                    _ii++;
                  } while (_ii < processedBlocks.length && processedBlocks[_ii].wrapperTemplate === info.wrapperTemplate);
                  var wrapperElement = React.cloneElement(info.wrapperTemplate, {
                    key: info.key + '-wrap',
                    'data-offset-key': info.offsetKey
                  }, blocks);
                  outputBlocks.push(wrapperElement);
                } else {
                  outputBlocks.push(info.block);
                  _ii++;
                }
              }
              return React.createElement("div", {
                "data-contents": "true"
              }, outputBlocks);
            };
            return DraftEditorContents;
          }(React.Component);
          DraftEditorContentsCore_react = DraftEditorContents;
          return DraftEditorContentsCore_react;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         */

        var DraftEditorContents_react;
        var hasRequiredDraftEditorContents_react;
        function requireDraftEditorContents_react() {
          if (hasRequiredDraftEditorContents_react) return DraftEditorContents_react;
          hasRequiredDraftEditorContents_react = 1;
          var gkx = requireGkx();
          var experimentalTreeDataSupport = gkx('draft_tree_data_support');
          DraftEditorContents_react = experimentalTreeDataSupport ? requireDraftEditorContentsExperimental_react() : requireDraftEditorContentsCore_react();
          return DraftEditorContents_react;
        }
        var PhotosMimeType_1;
        var hasRequiredPhotosMimeType;
        function requirePhotosMimeType() {
          if (hasRequiredPhotosMimeType) return PhotosMimeType_1;
          hasRequiredPhotosMimeType = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           */
          var PhotosMimeType = {
            isImage: function isImage(mimeString) {
              return getParts(mimeString)[0] === 'image';
            },
            isJpeg: function isJpeg(mimeString) {
              var parts = getParts(mimeString);
              return PhotosMimeType.isImage(mimeString) && (
              // see http://fburl.com/10972194
              parts[1] === 'jpeg' || parts[1] === 'pjpeg');
            }
          };
          function getParts(mimeString) {
            return mimeString.split('/');
          }
          PhotosMimeType_1 = PhotosMimeType;
          return PhotosMimeType_1;
        }
        var createArrayFromMixed_1;
        var hasRequiredCreateArrayFromMixed;
        function requireCreateArrayFromMixed() {
          if (hasRequiredCreateArrayFromMixed) return createArrayFromMixed_1;
          hasRequiredCreateArrayFromMixed = 1;
          var invariant = requireInvariant();
          function toArray(obj) {
            var length = obj.length;
            !(!Array.isArray(obj) && (typeof obj === "object" || typeof obj === "function")) ? invariant(false) : void 0;
            !(typeof length === "number") ? invariant(false) : void 0;
            !(length === 0 || length - 1 in obj) ? invariant(false) : void 0;
            !(typeof obj.callee !== "function") ? invariant(false) : void 0;
            if (obj.hasOwnProperty) {
              try {
                return Array.prototype.slice.call(obj);
              } catch (e) {}
            }
            var ret = Array(length);
            for (var ii = 0; ii < length; ii++) {
              ret[ii] = obj[ii];
            }
            return ret;
          }
          function hasArrayNature(obj) {
            return (
              // not null/false
              !!obj && (
              // arrays are objects, NodeLists are functions in Safari
              typeof obj == "object" || typeof obj == "function") &&
              // quacks like an array
              "length" in obj &&
              // not window
              !("setInterval" in obj) &&
              // no DOM node should be considered an array-like
              // a 'select' element has 'length' and 'item' properties on IE8
              typeof obj.nodeType != "number" && (
              // a real array
              Array.isArray(obj) ||
              // arguments
              "callee" in obj ||
              // HTMLCollection/NodeList
              "item" in obj)
            );
          }
          function createArrayFromMixed(obj) {
            if (!hasArrayNature(obj)) {
              return [obj];
            } else if (Array.isArray(obj)) {
              return obj.slice();
            } else {
              return toArray(obj);
            }
          }
          createArrayFromMixed_1 = createArrayFromMixed;
          return createArrayFromMixed_1;
        }
        var emptyFunction_1;
        var hasRequiredEmptyFunction;
        function requireEmptyFunction() {
          if (hasRequiredEmptyFunction) return emptyFunction_1;
          hasRequiredEmptyFunction = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * 
           */
          function makeEmptyFunction(arg) {
            return function () {
              return arg;
            };
          }
          /**
           * This function accepts and discards inputs; it has no side effects. This is
           * primarily useful idiomatically for overridable function endpoints which
           * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
           */

          var emptyFunction = function emptyFunction() {};
          emptyFunction.thatReturns = makeEmptyFunction;
          emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
          emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
          emptyFunction.thatReturnsNull = makeEmptyFunction(null);
          emptyFunction.thatReturnsThis = function () {
            return this;
          };
          emptyFunction.thatReturnsArgument = function (arg) {
            return arg;
          };
          emptyFunction_1 = emptyFunction;
          return emptyFunction_1;
        }
        var DataTransfer_1;
        var hasRequiredDataTransfer;
        function requireDataTransfer() {
          if (hasRequiredDataTransfer) return DataTransfer_1;
          hasRequiredDataTransfer = 1;

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */
          var PhotosMimeType = requirePhotosMimeType();
          var createArrayFromMixed = requireCreateArrayFromMixed();
          var emptyFunction = requireEmptyFunction();
          var CR_LF_REGEX = new RegExp("\r\n", 'g');
          var LF_ONLY = "\n";
          var RICH_TEXT_TYPES = {
            'text/rtf': 1,
            'text/html': 1
          };
          /**
           * If DataTransferItem is a file then return the Blob of data.
           *
           * @param {object} item
           * @return {?blob}
           */

          function getFileFromDataTransfer(item) {
            if (item.kind == 'file') {
              return item.getAsFile();
            }
          }
          var DataTransfer = /*#__PURE__*/
          function () {
            /**
             * @param {object} data
             */
            function DataTransfer(data) {
              this.data = data; // Types could be DOMStringList or array

              this.types = data.types ? createArrayFromMixed(data.types) : [];
            }
            /**
             * Is this likely to be a rich text data transfer?
             *
             * @return {boolean}
             */

            var _proto = DataTransfer.prototype;
            _proto.isRichText = function isRichText() {
              // If HTML is available, treat this data as rich text. This way, we avoid
              // using a pasted image if it is packaged with HTML -- this may occur with
              // pastes from MS Word, for example.  However this is only rich text if
              // there's accompanying text.
              if (this.getHTML() && this.getText()) {
                return true;
              } // When an image is copied from a preview window, you end up with two
              // DataTransferItems one of which is a file's metadata as text.  Skip those.

              if (this.isImage()) {
                return false;
              }
              return this.types.some(function (type) {
                return RICH_TEXT_TYPES[type];
              });
            };
            /**
             * Get raw text.
             *
             * @return {?string}
             */

            _proto.getText = function getText() {
              var text;
              if (this.data.getData) {
                if (!this.types.length) {
                  text = this.data.getData('Text');
                } else if (this.types.indexOf('text/plain') != -1) {
                  text = this.data.getData('text/plain');
                }
              }
              return text ? text.replace(CR_LF_REGEX, LF_ONLY) : null;
            };
            /**
             * Get HTML paste data
             *
             * @return {?string}
             */

            _proto.getHTML = function getHTML() {
              if (this.data.getData) {
                if (!this.types.length) {
                  return this.data.getData('Text');
                } else if (this.types.indexOf('text/html') != -1) {
                  return this.data.getData('text/html');
                }
              }
            };
            /**
             * Is this a link data transfer?
             *
             * @return {boolean}
             */

            _proto.isLink = function isLink() {
              return this.types.some(function (type) {
                return type.indexOf('Url') != -1 || type.indexOf('text/uri-list') != -1 || type.indexOf('text/x-moz-url');
              });
            };
            /**
             * Get a link url.
             *
             * @return {?string}
             */

            _proto.getLink = function getLink() {
              if (this.data.getData) {
                if (this.types.indexOf('text/x-moz-url') != -1) {
                  var url = this.data.getData('text/x-moz-url').split('\n');
                  return url[0];
                }
                return this.types.indexOf('text/uri-list') != -1 ? this.data.getData('text/uri-list') : this.data.getData('url');
              }
              return null;
            };
            /**
             * Is this an image data transfer?
             *
             * @return {boolean}
             */

            _proto.isImage = function isImage() {
              var isImage = this.types.some(function (type) {
                // Firefox will have a type of application/x-moz-file for images during
                // dragging
                return type.indexOf('application/x-moz-file') != -1;
              });
              if (isImage) {
                return true;
              }
              var items = this.getFiles();
              for (var i = 0; i < items.length; i++) {
                var type = items[i].type;
                if (!PhotosMimeType.isImage(type)) {
                  return false;
                }
              }
              return true;
            };
            _proto.getCount = function getCount() {
              if (this.data.hasOwnProperty('items')) {
                return this.data.items.length;
              } else if (this.data.hasOwnProperty('mozItemCount')) {
                return this.data.mozItemCount;
              } else if (this.data.files) {
                return this.data.files.length;
              }
              return null;
            };
            /**
             * Get files.
             *
             * @return {array}
             */

            _proto.getFiles = function getFiles() {
              if (this.data.items) {
                // createArrayFromMixed doesn't properly handle DataTransferItemLists.
                return Array.prototype.slice.call(this.data.items).map(getFileFromDataTransfer).filter(emptyFunction.thatReturnsArgument);
              } else if (this.data.files) {
                return Array.prototype.slice.call(this.data.files);
              } else {
                return [];
              }
            };
            /**
             * Are there any files to fetch?
             *
             * @return {boolean}
             */

            _proto.hasFiles = function hasFiles() {
              return this.getFiles().length > 0;
            };
            return DataTransfer;
          }();
          DataTransfer_1 = DataTransfer;
          return DataTransfer_1;
        }
        var getTextContentFromFiles_1;
        var hasRequiredGetTextContentFromFiles;
        function requireGetTextContentFromFiles() {
          if (hasRequiredGetTextContentFromFiles) return getTextContentFromFiles_1;
          hasRequiredGetTextContentFromFiles = 1;
          var invariant = requireInvariant();
          var TEXT_CLIPPING_REGEX = /\.textClipping$/;
          var TEXT_TYPES = {
            "text/plain": true,
            "text/html": true,
            "text/rtf": true
          };
          var TEXT_SIZE_UPPER_BOUND = 5e3;
          function getTextContentFromFiles(files, callback) {
            var readCount = 0;
            var results = [];
            files.forEach(function (file) {
              readFile(file, function (text) {
                readCount++;
                text && results.push(text.slice(0, TEXT_SIZE_UPPER_BOUND));
                if (readCount == files.length) {
                  callback(results.join("\r"));
                }
              });
            });
          }
          function readFile(file, callback) {
            if (!globalThis.FileReader || file.type && !(file.type in TEXT_TYPES)) {
              callback("");
              return;
            }
            if (file.type === "") {
              var _contents = "";
              if (TEXT_CLIPPING_REGEX.test(file.name)) {
                _contents = file.name.replace(TEXT_CLIPPING_REGEX, "");
              }
              callback(_contents);
              return;
            }
            var reader = new FileReader();
            reader.onload = function () {
              var result = reader.result;
              !(typeof result === "string") ? invariant(false) : void 0;
              callback(result);
            };
            reader.onerror = function () {
              callback("");
            };
            reader.readAsText(file);
          }
          getTextContentFromFiles_1 = getTextContentFromFiles;
          return getTextContentFromFiles_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var isEventHandled_1;
        var hasRequiredIsEventHandled;
        function requireIsEventHandled() {
          if (hasRequiredIsEventHandled) return isEventHandled_1;
          hasRequiredIsEventHandled = 1;

          /**
           * Utility method for determining whether or not the value returned
           * from a handler indicates that it was handled.
           */
          function isEventHandled(value) {
            return value === 'handled' || value === true;
          }
          isEventHandled_1 = isEventHandled;
          return isEventHandled_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DraftEditorDragHandler_1;
        var hasRequiredDraftEditorDragHandler;
        function requireDraftEditorDragHandler() {
          if (hasRequiredDraftEditorDragHandler) return DraftEditorDragHandler_1;
          hasRequiredDraftEditorDragHandler = 1;
          var DataTransfer = requireDataTransfer();
          var DraftModifier = requireDraftModifier();
          var EditorState = requireEditorState();
          var findAncestorOffsetKey = requireFindAncestorOffsetKey();
          var getCorrectDocumentFromNode = requireGetCorrectDocumentFromNode();
          var getTextContentFromFiles = requireGetTextContentFromFiles();
          var getUpdatedSelectionState = requireGetUpdatedSelectionState();
          var getWindowForNode = requireGetWindowForNode();
          var isEventHandled = requireIsEventHandled();
          var nullthrows = requireNullthrows();
          /**
           * Get a SelectionState for the supplied mouse event.
           */

          function getSelectionForEvent(event, editorState) {
            var node = null;
            var offset = null;
            var eventTargetDocument = getCorrectDocumentFromNode(event.currentTarget);
            /* $FlowFixMe[prop-missing] (>=0.68.0 site=www,mobile) This comment
             * suppresses an error found when Flow v0.68 was deployed. To see the error
             * delete this comment and run Flow. */

            if (typeof eventTargetDocument.caretRangeFromPoint === 'function') {
              /* $FlowFixMe[incompatible-use] (>=0.68.0 site=www,mobile) This comment
               * suppresses an error found when Flow v0.68 was deployed. To see the error
               * delete this comment and run Flow. */
              var dropRange = eventTargetDocument.caretRangeFromPoint(event.x, event.y);
              node = dropRange.startContainer;
              offset = dropRange.startOffset;
            } else if (event.rangeParent) {
              node = event.rangeParent;
              offset = event.rangeOffset;
            } else {
              return null;
            }
            node = nullthrows(node);
            offset = nullthrows(offset);
            var offsetKey = nullthrows(findAncestorOffsetKey(node));
            return getUpdatedSelectionState(editorState, offsetKey, offset, offsetKey, offset);
          }
          var DraftEditorDragHandler = {
            /**
             * Drag originating from input terminated.
             */
            onDragEnd: function onDragEnd(editor) {
              editor.exitCurrentMode();
              endDrag(editor);
            },
            /**
             * Handle data being dropped.
             */
            onDrop: function onDrop(editor, e) {
              var data = new DataTransfer(e.nativeEvent.dataTransfer);
              var editorState = editor._latestEditorState;
              var dropSelection = getSelectionForEvent(e.nativeEvent, editorState);
              e.preventDefault();
              editor._dragCount = 0;
              editor.exitCurrentMode();
              if (dropSelection == null) {
                return;
              }
              var files = data.getFiles();
              if (files.length > 0) {
                if (editor.props.handleDroppedFiles && isEventHandled(editor.props.handleDroppedFiles(dropSelection, files))) {
                  return;
                }
                /* $FlowFixMe[incompatible-call] This comment suppresses an error found
                 * DataTransfer was typed. getFiles() returns an array of <Files extends
                 * Blob>, not Blob */

                getTextContentFromFiles(files, function (fileText) {
                  fileText && editor.update(insertTextAtSelection(editorState, dropSelection, fileText));
                });
                return;
              }
              var dragType = editor._internalDrag ? 'internal' : 'external';
              if (editor.props.handleDrop && isEventHandled(editor.props.handleDrop(dropSelection, data, dragType))) ;else if (editor._internalDrag) {
                editor.update(moveText(editorState, dropSelection));
              } else {
                editor.update(insertTextAtSelection(editorState, dropSelection, data.getText()));
              }
              endDrag(editor);
            }
          };
          function endDrag(editor) {
            editor._internalDrag = false; // Fix issue #1383
            // Prior to React v16.5.0 onDrop breaks onSelect event:
            // https://github.com/facebook/react/issues/11379.
            // Dispatching a mouseup event on DOM node will make it go back to normal.

            var editorNode = editor.editorContainer;
            if (editorNode) {
              var mouseUpEvent = new MouseEvent('mouseup', {
                view: getWindowForNode(editorNode),
                bubbles: true,
                cancelable: true
              });
              editorNode.dispatchEvent(mouseUpEvent);
            }
          }
          function moveText(editorState, targetSelection) {
            var newContentState = DraftModifier.moveText(editorState.getCurrentContent(), editorState.getSelection(), targetSelection);
            return EditorState.push(editorState, newContentState, 'insert-fragment');
          }
          /**
           * Insert text at a specified selection.
           */

          function insertTextAtSelection(editorState, selection, text) {
            var newContentState = DraftModifier.insertText(editorState.getCurrentContent(), selection, text, editorState.getCurrentInlineStyle());
            return EditorState.push(editorState, newContentState, 'insert-fragment');
          }
          DraftEditorDragHandler_1 = DraftEditorDragHandler;
          return DraftEditorDragHandler_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var isSelectionAtLeafStart_1;
        var hasRequiredIsSelectionAtLeafStart;
        function requireIsSelectionAtLeafStart() {
          if (hasRequiredIsSelectionAtLeafStart) return isSelectionAtLeafStart_1;
          hasRequiredIsSelectionAtLeafStart = 1;
          function isSelectionAtLeafStart(editorState) {
            var selection = editorState.getSelection();
            var anchorKey = selection.getAnchorKey();
            var blockTree = editorState.getBlockTree(anchorKey);
            var offset = selection.getStartOffset();
            var isAtStart = false;
            blockTree.some(function (leafSet) {
              if (offset === leafSet.get('start')) {
                isAtStart = true;
                return true;
              }
              if (offset < leafSet.get('end')) {
                return leafSet.get('leaves').some(function (leaf) {
                  var leafStart = leaf.get('start');
                  if (offset === leafStart) {
                    isAtStart = true;
                    return true;
                  }
                  return false;
                });
              }
              return false;
            });
            return isAtStart;
          }
          isSelectionAtLeafStart_1 = isSelectionAtLeafStart;
          return isSelectionAtLeafStart_1;
        }
        var setImmediate$2 = {};
        var hasRequiredSetImmediate$1;
        function requireSetImmediate$1() {
          if (hasRequiredSetImmediate$1) return setImmediate$2;
          hasRequiredSetImmediate$1 = 1;
          (function (global2, undefined$1) {
            if (global2.setImmediate) {
              return;
            }
            var nextHandle = 1;
            var tasksByHandle = {};
            var currentlyRunningATask = false;
            var doc = global2.document;
            var registerImmediate;
            function setImmediate(callback) {
              if (typeof callback !== "function") {
                callback = new Function("" + callback);
              }
              var args = new Array(arguments.length - 1);
              for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i + 1];
              }
              var task = {
                callback,
                args
              };
              tasksByHandle[nextHandle] = task;
              registerImmediate(nextHandle);
              return nextHandle++;
            }
            function clearImmediate(handle) {
              delete tasksByHandle[handle];
            }
            function run(task) {
              var callback = task.callback;
              var args = task.args;
              switch (args.length) {
                case 0:
                  callback();
                  break;
                case 1:
                  callback(args[0]);
                  break;
                case 2:
                  callback(args[0], args[1]);
                  break;
                case 3:
                  callback(args[0], args[1], args[2]);
                  break;
                default:
                  callback.apply(undefined$1, args);
                  break;
              }
            }
            function runIfPresent(handle) {
              if (currentlyRunningATask) {
                setTimeout(runIfPresent, 0, handle);
              } else {
                var task = tasksByHandle[handle];
                if (task) {
                  currentlyRunningATask = true;
                  try {
                    run(task);
                  } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                  }
                }
              }
            }
            function installNextTickImplementation() {
              registerImmediate = function (handle) {
                process.nextTick(function () {
                  runIfPresent(handle);
                });
              };
            }
            function canUsePostMessage() {
              if (global2.postMessage && !global2.importScripts) {
                var postMessageIsAsynchronous = true;
                var oldOnMessage = global2.onmessage;
                global2.onmessage = function () {
                  postMessageIsAsynchronous = false;
                };
                global2.postMessage("", "*");
                global2.onmessage = oldOnMessage;
                return postMessageIsAsynchronous;
              }
            }
            function installPostMessageImplementation() {
              var messagePrefix = "setImmediate$" + Math.random() + "$";
              var onGlobalMessage = function (event) {
                if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                  runIfPresent(+event.data.slice(messagePrefix.length));
                }
              };
              if (global2.addEventListener) {
                global2.addEventListener("message", onGlobalMessage, false);
              } else {
                global2.attachEvent("onmessage", onGlobalMessage);
              }
              registerImmediate = function (handle) {
                global2.postMessage(messagePrefix + handle, "*");
              };
            }
            function installMessageChannelImplementation() {
              var channel = new MessageChannel();
              channel.port1.onmessage = function (event) {
                var handle = event.data;
                runIfPresent(handle);
              };
              registerImmediate = function (handle) {
                channel.port2.postMessage(handle);
              };
            }
            function installReadyStateChangeImplementation() {
              var html = doc.documentElement;
              registerImmediate = function (handle) {
                var script = doc.createElement("script");
                script.onreadystatechange = function () {
                  runIfPresent(handle);
                  script.onreadystatechange = null;
                  html.removeChild(script);
                  script = null;
                };
                html.appendChild(script);
              };
            }
            function installSetTimeoutImplementation() {
              registerImmediate = function (handle) {
                setTimeout(runIfPresent, 0, handle);
              };
            }
            var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
            attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
            if ({}.toString.call(global2.process) === "[object process]") {
              installNextTickImplementation();
            } else if (canUsePostMessage()) {
              installPostMessageImplementation();
            } else if (global2.MessageChannel) {
              installMessageChannelImplementation();
            } else if (doc && "onreadystatechange" in doc.createElement("script")) {
              installReadyStateChangeImplementation();
            } else {
              installSetTimeoutImplementation();
            }
            attachTo.setImmediate = setImmediate;
            attachTo.clearImmediate = clearImmediate;
          })(typeof self === "undefined" ? typeof globalThis === "undefined" ? setImmediate$2 : globalThis : self);
          return setImmediate$2;
        }
        var setImmediate$1;
        var hasRequiredSetImmediate;
        function requireSetImmediate() {
          if (hasRequiredSetImmediate) return setImmediate$1;
          hasRequiredSetImmediate = 1;
          requireSetImmediate$1();
          setImmediate$1 = globalThis.setImmediate;
          return setImmediate$1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var editOnBeforeInput_1;
        var hasRequiredEditOnBeforeInput;
        function requireEditOnBeforeInput() {
          if (hasRequiredEditOnBeforeInput) return editOnBeforeInput_1;
          hasRequiredEditOnBeforeInput = 1;
          var DraftModifier = requireDraftModifier();
          var EditorState = requireEditorState();
          var UserAgent = requireUserAgent();
          var getEntityKeyForSelection = requireGetEntityKeyForSelection();
          var isEventHandled = requireIsEventHandled();
          var isSelectionAtLeafStart = requireIsSelectionAtLeafStart();
          var nullthrows = requireNullthrows();
          var setImmediate = requireSetImmediate(); // When nothing is focused, Firefox regards two characters, `'` and `/`, as
          // commands that should open and focus the "quickfind" search bar. This should
          // *never* happen while a contenteditable is focused, but as of v28, it
          // sometimes does, even when the keypress event target is the contenteditable.
          // This breaks the input. Special case these characters to ensure that when
          // they are typed, we prevent default on the event to make sure not to
          // trigger quickfind.

          var FF_QUICKFIND_CHAR = "'";
          var FF_QUICKFIND_LINK_CHAR = '/';
          var isFirefox = UserAgent.isBrowser('Firefox');
          function mustPreventDefaultForCharacter(character) {
            return isFirefox && (character == FF_QUICKFIND_CHAR || character == FF_QUICKFIND_LINK_CHAR);
          }
          /**
           * Replace the current selection with the specified text string, with the
           * inline style and entity key applied to the newly inserted text.
           */

          function replaceText(editorState, text, inlineStyle, entityKey, forceSelection) {
            var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), text, inlineStyle, entityKey);
            return EditorState.push(editorState, contentState, 'insert-characters', forceSelection);
          }
          /**
           * When `onBeforeInput` executes, the browser is attempting to insert a
           * character into the editor. Apply this character data to the document,
           * allowing native insertion if possible.
           *
           * Native insertion is encouraged in order to limit re-rendering and to
           * preserve spellcheck highlighting, which disappears or flashes if re-render
           * occurs on the relevant text nodes.
           */

          function editOnBeforeInput(editor, e) {
            if (editor._pendingStateFromBeforeInput !== undefined) {
              editor.update(editor._pendingStateFromBeforeInput);
              editor._pendingStateFromBeforeInput = undefined;
            }
            var editorState = editor._latestEditorState;
            var chars = e.data; // In some cases (ex: IE ideographic space insertion) no character data
            // is provided. There's nothing to do when this happens.

            if (!chars) {
              return;
            } // Allow the top-level component to handle the insertion manually. This is
            // useful when triggering interesting behaviors for a character insertion,
            // Simple examples: replacing a raw text ':)' with a smile emoji or image
            // decorator, or setting a block to be a list item after typing '- ' at the
            // start of the block.

            if (editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(chars, editorState, e.timeStamp))) {
              e.preventDefault();
              return;
            } // If selection is collapsed, conditionally allow native behavior. This
            // reduces re-renders and preserves spellcheck highlighting. If the selection
            // is not collapsed, we will re-render.

            var selection = editorState.getSelection();
            var selectionStart = selection.getStartOffset();
            var anchorKey = selection.getAnchorKey();
            if (!selection.isCollapsed()) {
              e.preventDefault();
              editor.update(replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()), true));
              return;
            }
            var newEditorState = replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()), false); // Bunch of different cases follow where we need to prevent native insertion.

            var mustPreventNative = false;
            if (!mustPreventNative) {
              // Browsers tend to insert text in weird places in the DOM when typing at
              // the start of a leaf, so we'll handle it ourselves.
              mustPreventNative = isSelectionAtLeafStart(editor._latestCommittedEditorState);
            }
            if (!mustPreventNative) {
              // Let's say we have a decorator that highlights hashtags. In many cases
              // we need to prevent native behavior and rerender ourselves --
              // particularly, any case *except* where the inserted characters end up
              // anywhere except exactly where you put them.
              //
              // Using [] to denote a decorated leaf, some examples:
              //
              // 1. 'hi #' and append 'f'
              // desired rendering: 'hi [#f]'
              // native rendering would be: 'hi #f' (incorrect)
              //
              // 2. 'x [#foo]' and insert '#' before 'f'
              // desired rendering: 'x #[#foo]'
              // native rendering would be: 'x [##foo]' (incorrect)
              //
              // 3. '[#foobar]' and insert ' ' between 'foo' and 'bar'
              // desired rendering: '[#foo] bar'
              // native rendering would be: '[#foo bar]' (incorrect)
              //
              // 4. '[#foo]' and delete '#' [won't use this beforeinput codepath though]
              // desired rendering: 'foo'
              // native rendering would be: '[foo]' (incorrect)
              //
              // 5. '[#foo]' and append 'b'
              // desired rendering: '[#foob]'
              // native rendering would be: '[#foob]'
              // (native insertion here would be ok for decorators like simple spans,
              // but not more complex decorators. To be safe, we need to prevent it.)
              //
              // It is safe to allow native insertion if and only if the full list of
              // decorator ranges matches what we expect native insertion to give, and
              // the range lengths have not changed. We don't need to compare the content
              // because the only possible mutation to consider here is inserting plain
              // text and decorators can't affect text content.
              var oldBlockTree = editorState.getBlockTree(anchorKey);
              var newBlockTree = newEditorState.getBlockTree(anchorKey);
              mustPreventNative = oldBlockTree.size !== newBlockTree.size || oldBlockTree.zip(newBlockTree).some(function (_ref) {
                var oldLeafSet = _ref[0],
                  newLeafSet = _ref[1];
                // selectionStart is guaranteed to be selectionEnd here
                var oldStart = oldLeafSet.get('start');
                var adjustedStart = oldStart + (oldStart >= selectionStart ? chars.length : 0);
                var oldEnd = oldLeafSet.get('end');
                var adjustedEnd = oldEnd + (oldEnd >= selectionStart ? chars.length : 0);
                var newStart = newLeafSet.get('start');
                var newEnd = newLeafSet.get('end');
                var newDecoratorKey = newLeafSet.get('decoratorKey');
                return (
                  // Different decorators
                  oldLeafSet.get('decoratorKey') !== newDecoratorKey ||
                  // Different number of inline styles
                  oldLeafSet.get('leaves').size !== newLeafSet.get('leaves').size ||
                  // Different effective decorator position
                  adjustedStart !== newStart || adjustedEnd !== newEnd ||
                  // Decorator already existed and its length changed
                  newDecoratorKey != null && newEnd - newStart !== oldEnd - oldStart
                );
              });
            }
            if (!mustPreventNative) {
              mustPreventNative = mustPreventDefaultForCharacter(chars);
            }
            if (!mustPreventNative) {
              mustPreventNative = nullthrows(newEditorState.getDirectionMap()).get(anchorKey) !== nullthrows(editorState.getDirectionMap()).get(anchorKey);
            }
            if (mustPreventNative) {
              e.preventDefault();
              newEditorState = EditorState.set(newEditorState, {
                forceSelection: true
              });
              editor.update(newEditorState);
              return;
            } // We made it all the way! Let the browser do its thing and insert the char.

            newEditorState = EditorState.set(newEditorState, {
              nativelyRenderedContent: newEditorState.getCurrentContent()
            }); // The native event is allowed to occur. To allow user onChange handlers to
            // change the inserted text, we wait until the text is actually inserted
            // before we actually update our state. That way when we rerender, the text
            // we see in the DOM will already have been inserted properly.

            editor._pendingStateFromBeforeInput = newEditorState;
            setImmediate(function () {
              if (editor._pendingStateFromBeforeInput !== undefined) {
                editor.update(editor._pendingStateFromBeforeInput);
                editor._pendingStateFromBeforeInput = undefined;
              }
            });
          }
          editOnBeforeInput_1 = editOnBeforeInput;
          return editOnBeforeInput_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var editOnBlur_1;
        var hasRequiredEditOnBlur;
        function requireEditOnBlur() {
          if (hasRequiredEditOnBlur) return editOnBlur_1;
          hasRequiredEditOnBlur = 1;
          var EditorState = requireEditorState();
          var containsNode = requireContainsNode();
          var getActiveElement = requireGetActiveElement();
          function editOnBlur(editor, e) {
            // In a contentEditable element, when you select a range and then click
            // another active element, this does trigger a `blur` event but will not
            // remove the DOM selection from the contenteditable.
            // This is consistent across all browsers, but we prefer that the editor
            // behave like a textarea, where a `blur` event clears the DOM selection.
            // We therefore force the issue to be certain, checking whether the active
            // element is `body` to force it when blurring occurs within the window (as
            // opposed to clicking to another tab or window).
            var ownerDocument = e.currentTarget.ownerDocument;
            if (
            // This ESLint rule conflicts with `sketchy-null-bool` flow check
            // eslint-disable-next-line no-extra-boolean-cast
            !Boolean(editor.props.preserveSelectionOnBlur) && getActiveElement(ownerDocument) === ownerDocument.body) {
              var _selection = ownerDocument.defaultView.getSelection();
              var editorNode = editor.editor;
              if (_selection.rangeCount === 1 && containsNode(editorNode, _selection.anchorNode) && containsNode(editorNode, _selection.focusNode)) {
                _selection.removeAllRanges();
              }
            }
            var editorState = editor._latestEditorState;
            var currentSelection = editorState.getSelection();
            if (!currentSelection.getHasFocus()) {
              return;
            }
            var selection = currentSelection.set('hasFocus', false);
            editor.props.onBlur && editor.props.onBlur(e);
            editor.update(EditorState.acceptSelection(editorState, selection));
          }
          editOnBlur_1 = editOnBlur;
          return editOnBlur_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var editOnCompositionStart_1;
        var hasRequiredEditOnCompositionStart;
        function requireEditOnCompositionStart() {
          if (hasRequiredEditOnCompositionStart) return editOnCompositionStart_1;
          hasRequiredEditOnCompositionStart = 1;
          var EditorState = requireEditorState();
          /**
           * The user has begun using an IME input system. Switching to `composite` mode
           * allows handling composition input and disables other edit behavior.
           */

          function editOnCompositionStart(editor, e) {
            editor.setMode('composite');
            editor.update(EditorState.set(editor._latestEditorState, {
              inCompositionMode: true
            })); // Allow composition handler to interpret the compositionstart event

            editor._onCompositionStart(e);
          }
          editOnCompositionStart_1 = editOnCompositionStart;
          return editOnCompositionStart_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var getFragmentFromSelection_1;
        var hasRequiredGetFragmentFromSelection;
        function requireGetFragmentFromSelection() {
          if (hasRequiredGetFragmentFromSelection) return getFragmentFromSelection_1;
          hasRequiredGetFragmentFromSelection = 1;
          var getContentStateFragment = requireGetContentStateFragment();
          function getFragmentFromSelection(editorState) {
            var selectionState = editorState.getSelection();
            if (selectionState.isCollapsed()) {
              return null;
            }
            return getContentStateFragment(editorState.getCurrentContent(), selectionState);
          }
          getFragmentFromSelection_1 = getFragmentFromSelection;
          return getFragmentFromSelection_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var editOnCopy_1;
        var hasRequiredEditOnCopy;
        function requireEditOnCopy() {
          if (hasRequiredEditOnCopy) return editOnCopy_1;
          hasRequiredEditOnCopy = 1;
          var getFragmentFromSelection = requireGetFragmentFromSelection();
          /**
           * If we have a selection, create a ContentState fragment and store
           * it in our internal clipboard. Subsequent paste events will use this
           * fragment if no external clipboard data is supplied.
           */

          function editOnCopy(editor, e) {
            var editorState = editor._latestEditorState;
            var selection = editorState.getSelection(); // No selection, so there's nothing to copy.

            if (selection.isCollapsed()) {
              e.preventDefault();
              return;
            }
            editor.setClipboard(getFragmentFromSelection(editor._latestEditorState));
          }
          editOnCopy_1 = editOnCopy;
          return editOnCopy_1;
        }
        var isInstanceOfNode_1;
        var hasRequiredIsInstanceOfNode;
        function requireIsInstanceOfNode() {
          if (hasRequiredIsInstanceOfNode) return isInstanceOfNode_1;
          hasRequiredIsInstanceOfNode = 1;

          /**
           * Copyright (c) Facebook, Inc. and its affiliates.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @format
           * 
           * @emails oncall+draft_js
           */
          function isInstanceOfNode(target) {
            // we changed the name because of having duplicate module provider (fbjs)
            if (!target || !('ownerDocument' in target)) {
              return false;
            }
            if ('ownerDocument' in target) {
              var node = target;
              if (!node.ownerDocument.defaultView) {
                return node instanceof Node;
              }
              if (node instanceof node.ownerDocument.defaultView.Node) {
                return true;
              }
            }
            return false;
          }
          isInstanceOfNode_1 = isInstanceOfNode;
          return isInstanceOfNode_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var editOnCut_1;
        var hasRequiredEditOnCut;
        function requireEditOnCut() {
          if (hasRequiredEditOnCut) return editOnCut_1;
          hasRequiredEditOnCut = 1;
          var DraftModifier = requireDraftModifier();
          var EditorState = requireEditorState();
          var Style = requireStyle();
          var getFragmentFromSelection = requireGetFragmentFromSelection();
          var getScrollPosition = requireGetScrollPosition();
          var isNode = requireIsInstanceOfNode();
          /**
           * On `cut` events, native behavior is allowed to occur so that the system
           * clipboard is set properly. This means that we need to take steps to recover
           * the editor DOM state after the `cut` has occurred in order to maintain
           * control of the component.
           *
           * In addition, we can keep a copy of the removed fragment, including all
           * styles and entities, for use as an internal paste.
           */

          function editOnCut(editor, e) {
            var editorState = editor._latestEditorState;
            var selection = editorState.getSelection();
            var element = e.target;
            var scrollPosition; // No selection, so there's nothing to cut.

            if (selection.isCollapsed()) {
              e.preventDefault();
              return;
            } // Track the current scroll position so that it can be forced back in place
            // after the editor regains control of the DOM.

            if (isNode(element)) {
              var node = element;
              scrollPosition = getScrollPosition(Style.getScrollParent(node));
            }
            var fragment = getFragmentFromSelection(editorState);
            editor.setClipboard(fragment); // Set `cut` mode to disable all event handling temporarily.

            editor.setMode('cut'); // Let native `cut` behavior occur, then recover control.

            setTimeout(function () {
              editor.restoreEditorDOM(scrollPosition);
              editor.exitCurrentMode();
              editor.update(removeFragment(editorState));
            }, 0);
          }
          function removeFragment(editorState) {
            var newContent = DraftModifier.removeRange(editorState.getCurrentContent(), editorState.getSelection(), 'forward');
            return EditorState.push(editorState, newContent, 'remove-range');
          }
          editOnCut_1 = editOnCut;
          return editOnCut_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var editOnDragOver_1;
        var hasRequiredEditOnDragOver;
        function requireEditOnDragOver() {
          if (hasRequiredEditOnDragOver) return editOnDragOver_1;
          hasRequiredEditOnDragOver = 1;

          /**
           * Drag behavior has begun from outside the editor element.
           */
          function editOnDragOver(editor, e) {
            editor.setMode('drag');
            e.preventDefault();
          }
          editOnDragOver_1 = editOnDragOver;
          return editOnDragOver_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var editOnDragStart_1;
        var hasRequiredEditOnDragStart;
        function requireEditOnDragStart() {
          if (hasRequiredEditOnDragStart) return editOnDragStart_1;
          hasRequiredEditOnDragStart = 1;

          /**
           * A `dragstart` event has begun within the text editor component.
           */
          function editOnDragStart(editor) {
            editor._internalDrag = true;
            editor.setMode('drag');
          }
          editOnDragStart_1 = editOnDragStart;
          return editOnDragStart_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var editOnFocus_1;
        var hasRequiredEditOnFocus;
        function requireEditOnFocus() {
          if (hasRequiredEditOnFocus) return editOnFocus_1;
          hasRequiredEditOnFocus = 1;
          var EditorState = requireEditorState();
          var UserAgent = requireUserAgent();
          function editOnFocus(editor, e) {
            var editorState = editor._latestEditorState;
            var currentSelection = editorState.getSelection();
            if (currentSelection.getHasFocus()) {
              return;
            }
            var selection = currentSelection.set('hasFocus', true);
            editor.props.onFocus && editor.props.onFocus(e); // When the tab containing this text editor is hidden and the user does a
            // find-in-page in a _different_ tab, Chrome on Mac likes to forget what the
            // selection was right after sending this focus event and (if you let it)
            // moves the cursor back to the beginning of the editor, so we force the
            // selection here instead of simply accepting it in order to preserve the
            // old cursor position. See https://crbug.com/540004.
            // But it looks like this is fixed in Chrome 60.0.3081.0.
            // Other browsers also don't have this bug, so we prefer to acceptSelection
            // when possible, to ensure that unfocusing and refocusing a Draft editor
            // doesn't preserve the selection, matching how textareas work.

            if (UserAgent.isBrowser('Chrome < 60.0.3081.0')) {
              editor.update(EditorState.forceSelection(editorState, selection));
            } else {
              editor.update(EditorState.acceptSelection(editorState, selection));
            }
          }
          editOnFocus_1 = editOnFocus;
          return editOnFocus_1;
        }
        var UnicodeUtils_1;
        var hasRequiredUnicodeUtils;
        function requireUnicodeUtils() {
          if (hasRequiredUnicodeUtils) return UnicodeUtils_1;
          hasRequiredUnicodeUtils = 1;
          var invariant = requireInvariant();
          var SURROGATE_HIGH_START = 55296;
          var SURROGATE_HIGH_END = 56319;
          var SURROGATE_LOW_START = 56320;
          var SURROGATE_LOW_END = 57343;
          var SURROGATE_UNITS_REGEX = /[\uD800-\uDFFF]/;
          function isCodeUnitInSurrogateRange(codeUnit) {
            return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;
          }
          function isSurrogatePair(str, index) {
            !(0 <= index && index < str.length) ? invariant(false) : void 0;
            if (index + 1 === str.length) {
              return false;
            }
            var first = str.charCodeAt(index);
            var second = str.charCodeAt(index + 1);
            return SURROGATE_HIGH_START <= first && first <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;
          }
          function hasSurrogateUnit(str) {
            return SURROGATE_UNITS_REGEX.test(str);
          }
          function getUTF16Length(str, pos) {
            return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));
          }
          function strlen(str) {
            if (!hasSurrogateUnit(str)) {
              return str.length;
            }
            var len = 0;
            for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {
              len++;
            }
            return len;
          }
          function substr(str, start, length) {
            start = start || 0;
            length = length === void 0 ? Infinity : length || 0;
            if (!hasSurrogateUnit(str)) {
              return str.substr(start, length);
            }
            var size = str.length;
            if (size <= 0 || start > size || length <= 0) {
              return "";
            }
            var posA = 0;
            if (start > 0) {
              for (; start > 0 && posA < size; start--) {
                posA += getUTF16Length(str, posA);
              }
              if (posA >= size) {
                return "";
              }
            } else if (start < 0) {
              for (posA = size; start < 0 && 0 < posA; start++) {
                posA -= getUTF16Length(str, posA - 1);
              }
              if (posA < 0) {
                posA = 0;
              }
            }
            var posB = size;
            if (length < size) {
              for (posB = posA; length > 0 && posB < size; length--) {
                posB += getUTF16Length(str, posB);
              }
            }
            return str.substring(posA, posB);
          }
          function substring(str, start, end) {
            start = start || 0;
            end = end === void 0 ? Infinity : end || 0;
            if (start < 0) {
              start = 0;
            }
            if (end < 0) {
              end = 0;
            }
            var length = Math.abs(end - start);
            start = start < end ? start : end;
            return substr(str, start, length);
          }
          function getCodePoints(str) {
            var codePoints = [];
            for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {
              codePoints.push(str.codePointAt(pos));
            }
            return codePoints;
          }
          var UnicodeUtils = {
            getCodePoints,
            getUTF16Length,
            hasSurrogateUnit,
            isCodeUnitInSurrogateRange,
            isSurrogatePair,
            strlen,
            substring,
            substr
          };
          UnicodeUtils_1 = UnicodeUtils;
          return UnicodeUtils_1;
        }
        var warning_1;
        var hasRequiredWarning;
        function requireWarning() {
          if (hasRequiredWarning) return warning_1;
          hasRequiredWarning = 1;
          var emptyFunction = requireEmptyFunction();
          var warning = emptyFunction;
          warning_1 = warning;
          return warning_1;
        }
        var moveSelectionBackward_1;
        var hasRequiredMoveSelectionBackward;
        function requireMoveSelectionBackward() {
          if (hasRequiredMoveSelectionBackward) return moveSelectionBackward_1;
          hasRequiredMoveSelectionBackward = 1;
          requireWarning();
          function moveSelectionBackward(editorState, maxDistance) {
            var selection = editorState.getSelection();
            var content = editorState.getCurrentContent();
            var key = selection.getStartKey();
            var offset = selection.getStartOffset();
            var focusKey = key;
            var focusOffset = 0;
            if (maxDistance > offset) {
              var keyBefore = content.getKeyBefore(key);
              if (keyBefore == null) {
                focusKey = key;
              } else {
                focusKey = keyBefore;
                var blockBefore = content.getBlockForKey(keyBefore);
                focusOffset = blockBefore.getText().length;
              }
            } else {
              focusOffset = offset - maxDistance;
            }
            return selection.merge({
              focusKey,
              focusOffset,
              isBackward: true
            });
          }
          moveSelectionBackward_1 = moveSelectionBackward;
          return moveSelectionBackward_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var removeTextWithStrategy_1;
        var hasRequiredRemoveTextWithStrategy;
        function requireRemoveTextWithStrategy() {
          if (hasRequiredRemoveTextWithStrategy) return removeTextWithStrategy_1;
          hasRequiredRemoveTextWithStrategy = 1;
          var DraftModifier = requireDraftModifier();
          var gkx = requireGkx();
          var experimentalTreeDataSupport = gkx('draft_tree_data_support');
          /**
           * For a collapsed selection state, remove text based on the specified strategy.
           * If the selection state is not collapsed, remove the entire selected range.
           */

          function removeTextWithStrategy(editorState, strategy, direction) {
            var selection = editorState.getSelection();
            var content = editorState.getCurrentContent();
            var target = selection;
            var anchorKey = selection.getAnchorKey();
            var focusKey = selection.getFocusKey();
            var anchorBlock = content.getBlockForKey(anchorKey);
            if (experimentalTreeDataSupport) {
              if (direction === 'forward') {
                if (anchorKey !== focusKey) {
                  // For now we ignore forward delete across blocks,
                  // if there is demand for this we will implement it.
                  return content;
                }
              }
            }
            if (selection.isCollapsed()) {
              if (direction === 'forward') {
                if (editorState.isSelectionAtEndOfContent()) {
                  return content;
                }
                if (experimentalTreeDataSupport) {
                  var isAtEndOfBlock = selection.getAnchorOffset() === content.getBlockForKey(anchorKey).getLength();
                  if (isAtEndOfBlock) {
                    var anchorBlockSibling = content.getBlockForKey(anchorBlock.nextSibling);
                    if (!anchorBlockSibling || anchorBlockSibling.getLength() === 0) {
                      // For now we ignore forward delete at the end of a block,
                      // if there is demand for this we will implement it.
                      return content;
                    }
                  }
                }
              } else if (editorState.isSelectionAtStartOfContent()) {
                return content;
              }
              target = strategy(editorState);
              if (target === selection) {
                return content;
              }
            }
            return DraftModifier.removeRange(content, target, direction);
          }
          removeTextWithStrategy_1 = removeTextWithStrategy;
          return removeTextWithStrategy_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var keyCommandPlainBackspace_1;
        var hasRequiredKeyCommandPlainBackspace;
        function requireKeyCommandPlainBackspace() {
          if (hasRequiredKeyCommandPlainBackspace) return keyCommandPlainBackspace_1;
          hasRequiredKeyCommandPlainBackspace = 1;
          var EditorState = requireEditorState();
          var UnicodeUtils = requireUnicodeUtils();
          var moveSelectionBackward = requireMoveSelectionBackward();
          var removeTextWithStrategy = requireRemoveTextWithStrategy();
          /**
           * Remove the selected range. If the cursor is collapsed, remove the preceding
           * character. This operation is Unicode-aware, so removing a single character
           * will remove a surrogate pair properly as well.
           */

          function keyCommandPlainBackspace(editorState) {
            var afterRemoval = removeTextWithStrategy(editorState, function (strategyState) {
              var selection = strategyState.getSelection();
              var content = strategyState.getCurrentContent();
              var key = selection.getAnchorKey();
              var offset = selection.getAnchorOffset();
              var charBehind = content.getBlockForKey(key).getText()[offset - 1];
              return moveSelectionBackward(strategyState, charBehind ? UnicodeUtils.getUTF16Length(charBehind, 0) : 1);
            }, 'backward');
            if (afterRemoval === editorState.getCurrentContent()) {
              return editorState;
            }
            var selection = editorState.getSelection();
            return EditorState.push(editorState, afterRemoval.set('selectionBefore', selection), selection.isCollapsed() ? 'backspace-character' : 'remove-range');
          }
          keyCommandPlainBackspace_1 = keyCommandPlainBackspace;
          return keyCommandPlainBackspace_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var editOnInput_1;
        var hasRequiredEditOnInput;
        function requireEditOnInput() {
          if (hasRequiredEditOnInput) return editOnInput_1;
          hasRequiredEditOnInput = 1;
          var DraftModifier = requireDraftModifier();
          var DraftOffsetKey = requireDraftOffsetKey();
          var EditorState = requireEditorState();
          var UserAgent = requireUserAgent();
          var _require = requireDraftKeyUtils(),
            notEmptyKey = _require.notEmptyKey;
          var findAncestorOffsetKey = requireFindAncestorOffsetKey();
          var keyCommandPlainBackspace = requireKeyCommandPlainBackspace();
          var nullthrows = requireNullthrows();
          var isGecko = UserAgent.isEngine('Gecko');
          var DOUBLE_NEWLINE = '\n\n';
          function onInputType(inputType, editorState) {
            switch (inputType) {
              case 'deleteContentBackward':
                return keyCommandPlainBackspace(editorState);
            }
            return editorState;
          }
          /**
           * This function serves two purposes
           *
           * 1. To update the editorState and call onChange method with the new
           * editorState. This editorState is calculated in editOnBeforeInput but the
           * onChange method is not called with the new state until this method does it.
           * It is done to handle a specific case where certain character inputs might
           * be replaced with something else. E.g. snippets ('rc' might be replaced
           * with boilerplate code for react component). More information on the
           * exact problem can be found here -
           * https://github.com/facebook/draft-js/commit/07892ba479bd4dfc6afd1e0ed179aaf51cd138b1
           *
           * 2. intended to handle spellcheck and autocorrect changes,
           * which occur in the DOM natively without any opportunity to observe or
           * interpret the changes before they occur.
           *
           * The `input` event fires in contentEditable elements reliably for non-IE
           * browsers, immediately after changes occur to the editor DOM. Since our other
           * handlers override or otherwise handle cover other varieties of text input,
           * the DOM state should match the model in all controlled input cases. Thus,
           * when an `input` change leads to a DOM/model mismatch, the change should be
           * due to a spellcheck change, and we can incorporate it into our model.
           */

          function editOnInput(editor, e) {
            if (editor._pendingStateFromBeforeInput !== undefined) {
              editor.update(editor._pendingStateFromBeforeInput);
              editor._pendingStateFromBeforeInput = undefined;
            } // at this point editor is not null for sure (after input)

            var castedEditorElement = editor.editor;
            var domSelection = castedEditorElement.ownerDocument.defaultView.getSelection();
            var anchorNode = domSelection.anchorNode,
              isCollapsed = domSelection.isCollapsed;
            var isNotTextOrElementNode = (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.TEXT_NODE && (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.ELEMENT_NODE;
            if (anchorNode == null || isNotTextOrElementNode) {
              // TODO: (t16149272) figure out context for this change
              return;
            }
            if (anchorNode.nodeType === Node.TEXT_NODE && (anchorNode.previousSibling !== null || anchorNode.nextSibling !== null)) {
              // When typing at the beginning of a visual line, Chrome splits the text
              // nodes into two. Why? No one knows. This commit is suspicious:
              // https://chromium.googlesource.com/chromium/src/+/a3b600981286b135632371477f902214c55a1724
              // To work around, we'll merge the sibling text nodes back into this one.
              var span = anchorNode.parentNode;
              if (span == null) {
                // Handle null-parent case.
                return;
              }
              anchorNode.nodeValue = span.textContent;
              for (var child = span.firstChild; child != null; child = child.nextSibling) {
                if (child !== anchorNode) {
                  span.removeChild(child);
                }
              }
            }
            var domText = anchorNode.textContent;
            var editorState = editor._latestEditorState;
            var offsetKey = nullthrows(findAncestorOffsetKey(anchorNode));
            var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey),
              blockKey = _DraftOffsetKey$decod.blockKey,
              decoratorKey = _DraftOffsetKey$decod.decoratorKey,
              leafKey = _DraftOffsetKey$decod.leafKey;
            var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]),
              start = _editorState$getBlock.start,
              end = _editorState$getBlock.end;
            var content = editorState.getCurrentContent();
            var block = content.getBlockForKey(blockKey);
            var modelText = block.getText().slice(start, end); // Special-case soft newlines here. If the DOM text ends in a soft newline,
            // we will have manually inserted an extra soft newline in DraftEditorLeaf.
            // We want to remove this extra newline for the purpose of our comparison
            // of DOM and model text.

            if (domText.endsWith(DOUBLE_NEWLINE)) {
              domText = domText.slice(0, -1);
            } // No change -- the DOM is up to date. Nothing to do here.

            if (domText === modelText) {
              // This can be buggy for some Android keyboards because they don't fire
              // standard onkeydown/pressed events and only fired editOnInput
              // so domText is already changed by the browser and ends up being equal
              // to modelText unexpectedly.
              // Newest versions of Android support the dom-inputevent-inputtype
              // and we can use the `inputType` to properly apply the state changes.

              /* $FlowFixMe[prop-missing] inputType is only defined on a draft of a
               * standard. https://w3c.github.io/input-events/#dom-inputevent-inputtype
               */
              var inputType = e.nativeEvent.inputType;
              if (inputType) {
                var newEditorState = onInputType(inputType, editorState);
                if (newEditorState !== editorState) {
                  editor.restoreEditorDOM();
                  editor.update(newEditorState);
                  return;
                }
              }
              return;
            }
            var selection = editorState.getSelection(); // We'll replace the entire leaf with the text content of the target.

            var targetRange = selection.merge({
              anchorOffset: start,
              focusOffset: end,
              isBackward: false
            });
            var entityKey = block.getEntityAt(start);
            var entity = notEmptyKey(entityKey) ? content.getEntity(entityKey) : null;
            var entityType = entity != null ? entity.getMutability() : null;
            var preserveEntity = entityType === 'MUTABLE'; // Immutable or segmented entities cannot properly be handled by the
            // default browser undo, so we have to use a different change type to
            // force using our internal undo method instead of falling through to the
            // native browser undo.

            var changeType = preserveEntity ? 'spellcheck-change' : 'apply-entity';
            var newContent = DraftModifier.replaceText(content, targetRange, domText, block.getInlineStyleAt(start), preserveEntity ? block.getEntityAt(start) : null);
            var anchorOffset, focusOffset, startOffset, endOffset;
            if (isGecko) {
              // Firefox selection does not change while the context menu is open, so
              // we preserve the anchor and focus values of the DOM selection.
              anchorOffset = domSelection.anchorOffset;
              focusOffset = domSelection.focusOffset;
              startOffset = start + Math.min(anchorOffset, focusOffset);
              endOffset = startOffset + Math.abs(anchorOffset - focusOffset);
              anchorOffset = startOffset;
              focusOffset = endOffset;
            } else {
              // Browsers other than Firefox may adjust DOM selection while the context
              // menu is open, and Safari autocorrect is prone to providing an inaccurate
              // DOM selection. Don't trust it. Instead, use our existing SelectionState
              // and adjust it based on the number of characters changed during the
              // mutation.
              var charDelta = domText.length - modelText.length;
              startOffset = selection.getStartOffset();
              endOffset = selection.getEndOffset();
              anchorOffset = isCollapsed ? endOffset + charDelta : startOffset;
              focusOffset = endOffset + charDelta;
            } // Segmented entities are completely or partially removed when their
            // text content changes. For this case we do not want any text to be selected
            // after the change, so we are not merging the selection.

            var contentWithAdjustedDOMSelection = newContent.merge({
              selectionBefore: content.getSelectionAfter(),
              selectionAfter: selection.merge({
                anchorOffset: anchorOffset,
                focusOffset: focusOffset
              })
            });
            editor.update(EditorState.push(editorState, contentWithAdjustedDOMSelection, changeType));
          }
          editOnInput_1 = editOnInput;
          return editOnInput_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var isSoftNewlineEvent_1;
        var hasRequiredIsSoftNewlineEvent;
        function requireIsSoftNewlineEvent() {
          if (hasRequiredIsSoftNewlineEvent) return isSoftNewlineEvent_1;
          hasRequiredIsSoftNewlineEvent = 1;
          var Keys = requireKeys();
          function isSoftNewlineEvent(e) {
            return e.which === Keys.RETURN && (e.getModifierState('Shift') || e.getModifierState('Alt') || e.getModifierState('Control'));
          }
          isSoftNewlineEvent_1 = isSoftNewlineEvent;
          return isSoftNewlineEvent_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var KeyBindingUtil_1;
        var hasRequiredKeyBindingUtil;
        function requireKeyBindingUtil() {
          if (hasRequiredKeyBindingUtil) return KeyBindingUtil_1;
          hasRequiredKeyBindingUtil = 1;
          var UserAgent = requireUserAgent();
          var isSoftNewlineEvent = requireIsSoftNewlineEvent();
          var isOSX = UserAgent.isPlatform('Mac OS X');
          var KeyBindingUtil = {
            /**
             * Check whether the ctrlKey modifier is *not* being used in conjunction with
             * the altKey modifier. If they are combined, the result is an `altGraph`
             * key modifier, which should not be handled by this set of key bindings.
             */
            isCtrlKeyCommand: function isCtrlKeyCommand(e) {
              return !!e.ctrlKey && !e.altKey;
            },
            isOptionKeyCommand: function isOptionKeyCommand(e) {
              return isOSX && e.altKey;
            },
            usesMacOSHeuristics: function usesMacOSHeuristics() {
              return isOSX;
            },
            hasCommandModifier: function hasCommandModifier(e) {
              return isOSX ? !!e.metaKey && !e.altKey : KeyBindingUtil.isCtrlKeyCommand(e);
            },
            isSoftNewlineEvent: isSoftNewlineEvent
          };
          KeyBindingUtil_1 = KeyBindingUtil;
          return KeyBindingUtil_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var SecondaryClipboard_1;
        var hasRequiredSecondaryClipboard;
        function requireSecondaryClipboard() {
          if (hasRequiredSecondaryClipboard) return SecondaryClipboard_1;
          hasRequiredSecondaryClipboard = 1;
          var DraftModifier = requireDraftModifier();
          var EditorState = requireEditorState();
          var getContentStateFragment = requireGetContentStateFragment();
          var nullthrows = requireNullthrows();
          var clipboard = null;
          /**
           * Some systems offer a "secondary" clipboard to allow quick internal cut
           * and paste behavior. For instance, Ctrl+K (cut) and Ctrl+Y (paste).
           */

          var SecondaryClipboard = {
            cut: function cut(editorState) {
              var content = editorState.getCurrentContent();
              var selection = editorState.getSelection();
              var targetRange = null;
              if (selection.isCollapsed()) {
                var anchorKey = selection.getAnchorKey();
                var blockEnd = content.getBlockForKey(anchorKey).getLength();
                if (blockEnd === selection.getAnchorOffset()) {
                  var keyAfter = content.getKeyAfter(anchorKey);
                  if (keyAfter == null) {
                    return editorState;
                  }
                  targetRange = selection.set('focusKey', keyAfter).set('focusOffset', 0);
                } else {
                  targetRange = selection.set('focusOffset', blockEnd);
                }
              } else {
                targetRange = selection;
              }
              targetRange = nullthrows(targetRange); // TODO: This should actually append to the current state when doing
              // successive ^K commands without any other cursor movement

              clipboard = getContentStateFragment(content, targetRange);
              var afterRemoval = DraftModifier.removeRange(content, targetRange, 'forward');
              if (afterRemoval === content) {
                return editorState;
              }
              return EditorState.push(editorState, afterRemoval, 'remove-range');
            },
            paste: function paste(editorState) {
              if (!clipboard) {
                return editorState;
              }
              var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), clipboard);
              return EditorState.push(editorState, newContent, 'insert-fragment');
            }
          };
          SecondaryClipboard_1 = SecondaryClipboard;
          return SecondaryClipboard_1;
        }
        var getRangeClientRects_1;
        var hasRequiredGetRangeClientRects;
        function requireGetRangeClientRects() {
          if (hasRequiredGetRangeClientRects) return getRangeClientRects_1;
          hasRequiredGetRangeClientRects = 1;
          var UserAgent = requireUserAgent();
          var invariant = requireInvariant();
          var isChrome = UserAgent.isBrowser("Chrome");
          function getRangeClientRectsChrome(range) {
            var tempRange = range.cloneRange();
            var clientRects = [];
            for (var ancestor = range.endContainer; ancestor != null; ancestor = ancestor.parentNode) {
              var atCommonAncestor = ancestor === range.commonAncestorContainer;
              if (atCommonAncestor) {
                tempRange.setStart(range.startContainer, range.startOffset);
              } else {
                tempRange.setStart(tempRange.endContainer, 0);
              }
              var rects = Array.from(tempRange.getClientRects());
              clientRects.push(rects);
              if (atCommonAncestor) {
                var _ref;
                clientRects.reverse();
                return (_ref = []).concat.apply(_ref, clientRects);
              }
              tempRange.setEndBefore(ancestor);
            }
            invariant(false);
          }
          var getRangeClientRects = isChrome ? getRangeClientRectsChrome : function (range) {
            return Array.from(range.getClientRects());
          };
          getRangeClientRects_1 = getRangeClientRects;
          return getRangeClientRects_1;
        }
        var expandRangeToStartOfLine_1;
        var hasRequiredExpandRangeToStartOfLine;
        function requireExpandRangeToStartOfLine() {
          if (hasRequiredExpandRangeToStartOfLine) return expandRangeToStartOfLine_1;
          hasRequiredExpandRangeToStartOfLine = 1;
          var UnicodeUtils = requireUnicodeUtils();
          var getCorrectDocumentFromNode = requireGetCorrectDocumentFromNode();
          var getRangeClientRects = requireGetRangeClientRects();
          var invariant = requireInvariant();
          function getLineHeightPx(element) {
            var computed = getComputedStyle(element);
            var correctDocument = getCorrectDocumentFromNode(element);
            var div = correctDocument.createElement("div");
            div.style.fontFamily = computed.fontFamily;
            div.style.fontSize = computed.fontSize;
            div.style.fontStyle = computed.fontStyle;
            div.style.fontWeight = computed.fontWeight;
            div.style.lineHeight = computed.lineHeight;
            div.style.position = "absolute";
            div.textContent = "M";
            var documentBody = correctDocument.body;
            !documentBody ? invariant(false) : void 0;
            documentBody.appendChild(div);
            var rect = div.getBoundingClientRect();
            documentBody.removeChild(div);
            return rect.height;
          }
          function areRectsOnOneLine(rects, lineHeight) {
            var minTop = Infinity;
            var minBottom = Infinity;
            var maxTop = -Infinity;
            var maxBottom = -Infinity;
            for (var ii = 0; ii < rects.length; ii++) {
              var rect = rects[ii];
              if (rect.width === 0 || rect.width === 1) {
                continue;
              }
              minTop = Math.min(minTop, rect.top);
              minBottom = Math.min(minBottom, rect.bottom);
              maxTop = Math.max(maxTop, rect.top);
              maxBottom = Math.max(maxBottom, rect.bottom);
            }
            return maxTop <= minBottom && maxTop - minTop < lineHeight && maxBottom - minBottom < lineHeight;
          }
          function getNodeLength(node) {
            switch (node.nodeType) {
              case Node.DOCUMENT_TYPE_NODE:
                return 0;
              case Node.TEXT_NODE:
              case Node.PROCESSING_INSTRUCTION_NODE:
              case Node.COMMENT_NODE:
                return node.length;
              default:
                return node.childNodes.length;
            }
          }
          function expandRangeToStartOfLine(range) {
            !range.collapsed ? invariant(false) : void 0;
            range = range.cloneRange();
            var containingElement = range.startContainer;
            if (containingElement.nodeType !== 1) {
              containingElement = containingElement.parentNode;
            }
            var lineHeight = getLineHeightPx(containingElement);
            var bestContainer = range.endContainer;
            var bestOffset = range.endOffset;
            range.setStart(range.startContainer, 0);
            while (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {
              bestContainer = range.startContainer;
              bestOffset = range.startOffset;
              !bestContainer.parentNode ? invariant(false) : void 0;
              range.setStartBefore(bestContainer);
              if (bestContainer.nodeType === 1 && getComputedStyle(bestContainer).display !== "inline") {
                break;
              }
            }
            var currentContainer = bestContainer;
            var maxIndexToConsider = bestOffset - 1;
            do {
              var nodeValue = currentContainer.nodeValue;
              var ii = maxIndexToConsider;
              for (; ii >= 0; ii--) {
                if (nodeValue != null && ii > 0 && UnicodeUtils.isSurrogatePair(nodeValue, ii - 1)) {
                  continue;
                }
                range.setStart(currentContainer, ii);
                if (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {
                  bestContainer = currentContainer;
                  bestOffset = ii;
                } else {
                  break;
                }
              }
              if (ii === -1 || currentContainer.childNodes.length === 0) {
                break;
              }
              currentContainer = currentContainer.childNodes[ii];
              maxIndexToConsider = getNodeLength(currentContainer);
            } while (true);
            range.setStart(bestContainer, bestOffset);
            return range;
          }
          expandRangeToStartOfLine_1 = expandRangeToStartOfLine;
          return expandRangeToStartOfLine_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var keyCommandBackspaceToStartOfLine_1;
        var hasRequiredKeyCommandBackspaceToStartOfLine;
        function requireKeyCommandBackspaceToStartOfLine() {
          if (hasRequiredKeyCommandBackspaceToStartOfLine) return keyCommandBackspaceToStartOfLine_1;
          hasRequiredKeyCommandBackspaceToStartOfLine = 1;
          var EditorState = requireEditorState();
          var expandRangeToStartOfLine = requireExpandRangeToStartOfLine();
          var getDraftEditorSelectionWithNodes = requireGetDraftEditorSelectionWithNodes();
          var moveSelectionBackward = requireMoveSelectionBackward();
          var removeTextWithStrategy = requireRemoveTextWithStrategy();
          function keyCommandBackspaceToStartOfLine(editorState, e) {
            var afterRemoval = removeTextWithStrategy(editorState, function (strategyState) {
              var selection = strategyState.getSelection();
              if (selection.isCollapsed() && selection.getAnchorOffset() === 0) {
                return moveSelectionBackward(strategyState, 1);
              }
              var ownerDocument = e.currentTarget.ownerDocument;
              var domSelection = ownerDocument.defaultView.getSelection(); // getRangeAt can technically throw if there's no selection, but we know
              // there is one here because text editor has focus (the cursor is a
              // selection of length 0). Therefore, we don't need to wrap this in a
              // try-catch block.

              var range = domSelection.getRangeAt(0);
              range = expandRangeToStartOfLine(range);
              return getDraftEditorSelectionWithNodes(strategyState, null, range.endContainer, range.endOffset, range.startContainer, range.startOffset).selectionState;
            }, 'backward');
            if (afterRemoval === editorState.getCurrentContent()) {
              return editorState;
            }
            return EditorState.push(editorState, afterRemoval, 'remove-range');
          }
          keyCommandBackspaceToStartOfLine_1 = keyCommandBackspaceToStartOfLine;
          return keyCommandBackspaceToStartOfLine_1;
        }

        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @typechecks
         * @stub
         * 
         */

        var TokenizeUtil;
        var hasRequiredTokenizeUtil;
        function requireTokenizeUtil() {
          if (hasRequiredTokenizeUtil) return TokenizeUtil;
          hasRequiredTokenizeUtil = 1;
          //             is latin supplement punctuation except fractions and superscript
          //             numbers
          // \u2010-\u2027\u2030-\u205e
          //             is punctuation from the general punctuation block:
          //             weird quotes, commas, bullets, dashes, etc.
          // \u30fb\u3001\u3002\u3008-\u3011\u3014-\u301f
          //             is CJK punctuation
          // \uff1a-\uff1f\uff01-\uff0f\uff3b-\uff40\uff5b-\uff65
          //             is some full-width/half-width punctuation
          // \u2E2E\u061f\u066a-\u066c\u061b\u060c\u060d\uFD3e\uFD3F
          //             is some Arabic punctuation marks
          // \u1801\u0964\u104a\u104b
          //             is misc. other language punctuation marks

          var PUNCTUATION = '[.,+*?$|#{}()\'\\^\\-\\[\\]\\\\\\/!@%"~=<>_:;' + "\u30FB\u3001\u3002\u3008-\u3011\u3014-\u301F\uFF1A-\uFF1F\uFF01-\uFF0F" + "\uFF3B-\uFF40\uFF5B-\uFF65\u2E2E\u061F\u066A-\u066C\u061B\u060C\u060D" + "\uFD3E\uFD3F\u1801\u0964\u104A\u104B\u2010-\u2027\u2030-\u205E" + "\xA1-\xB1\xB4-\xB8\xBA\xBB\xBF]";
          TokenizeUtil = {
            getPunctuation: function getPunctuation() {
              return PUNCTUATION;
            }
          };
          return TokenizeUtil;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DraftRemovableWord_1;
        var hasRequiredDraftRemovableWord;
        function requireDraftRemovableWord() {
          if (hasRequiredDraftRemovableWord) return DraftRemovableWord_1;
          hasRequiredDraftRemovableWord = 1;
          var TokenizeUtil = requireTokenizeUtil();
          var punctuation = TokenizeUtil.getPunctuation(); // The apostrophe and curly single quotes behave in a curious way: when
          // surrounded on both sides by word characters, they behave as word chars; when
          // either neighbor is punctuation or an end of the string, they behave as
          // punctuation.

          var CHAMELEON_CHARS = "['\u2018\u2019]"; // Remove the underscore, which should count as part of the removable word. The
          // "chameleon chars" also count as punctuation in this regex.

          var WHITESPACE_AND_PUNCTUATION = '\\s|(?![_])' + punctuation;
          var DELETE_STRING = '^' + '(?:' + WHITESPACE_AND_PUNCTUATION + ')*' + '(?:' + CHAMELEON_CHARS + '|(?!' + WHITESPACE_AND_PUNCTUATION + ').)*' + '(?:(?!' + WHITESPACE_AND_PUNCTUATION + ').)';
          var DELETE_REGEX = new RegExp(DELETE_STRING);
          var BACKSPACE_STRING = '(?:(?!' + WHITESPACE_AND_PUNCTUATION + ').)' + '(?:' + CHAMELEON_CHARS + '|(?!' + WHITESPACE_AND_PUNCTUATION + ').)*' + '(?:' + WHITESPACE_AND_PUNCTUATION + ')*' + '$';
          var BACKSPACE_REGEX = new RegExp(BACKSPACE_STRING);
          function getRemovableWord(text, isBackward) {
            var matches = isBackward ? BACKSPACE_REGEX.exec(text) : DELETE_REGEX.exec(text);
            return matches ? matches[0] : text;
          }
          var DraftRemovableWord = {
            getBackward: function getBackward(text) {
              return getRemovableWord(text, true);
            },
            getForward: function getForward(text) {
              return getRemovableWord(text, false);
            }
          };
          DraftRemovableWord_1 = DraftRemovableWord;
          return DraftRemovableWord_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var keyCommandBackspaceWord_1;
        var hasRequiredKeyCommandBackspaceWord;
        function requireKeyCommandBackspaceWord() {
          if (hasRequiredKeyCommandBackspaceWord) return keyCommandBackspaceWord_1;
          hasRequiredKeyCommandBackspaceWord = 1;
          var DraftRemovableWord = requireDraftRemovableWord();
          var EditorState = requireEditorState();
          var moveSelectionBackward = requireMoveSelectionBackward();
          var removeTextWithStrategy = requireRemoveTextWithStrategy();
          /**
           * Delete the word that is left of the cursor, as well as any spaces or
           * punctuation after the word.
           */

          function keyCommandBackspaceWord(editorState) {
            var afterRemoval = removeTextWithStrategy(editorState, function (strategyState) {
              var selection = strategyState.getSelection();
              var offset = selection.getStartOffset(); // If there are no words before the cursor, remove the preceding newline.

              if (offset === 0) {
                return moveSelectionBackward(strategyState, 1);
              }
              var key = selection.getStartKey();
              var content = strategyState.getCurrentContent();
              var text = content.getBlockForKey(key).getText().slice(0, offset);
              var toRemove = DraftRemovableWord.getBackward(text);
              return moveSelectionBackward(strategyState, toRemove.length || 1);
            }, 'backward');
            if (afterRemoval === editorState.getCurrentContent()) {
              return editorState;
            }
            return EditorState.push(editorState, afterRemoval, 'remove-range');
          }
          keyCommandBackspaceWord_1 = keyCommandBackspaceWord;
          return keyCommandBackspaceWord_1;
        }
        var moveSelectionForward_1;
        var hasRequiredMoveSelectionForward;
        function requireMoveSelectionForward() {
          if (hasRequiredMoveSelectionForward) return moveSelectionForward_1;
          hasRequiredMoveSelectionForward = 1;
          requireWarning();
          function moveSelectionForward(editorState, maxDistance) {
            var selection = editorState.getSelection();
            var key = selection.getStartKey();
            var offset = selection.getStartOffset();
            var content = editorState.getCurrentContent();
            var focusKey = key;
            var focusOffset;
            var block = content.getBlockForKey(key);
            if (maxDistance > block.getText().length - offset) {
              focusKey = content.getKeyAfter(key);
              focusOffset = 0;
            } else {
              focusOffset = offset + maxDistance;
            }
            return selection.merge({
              focusKey,
              focusOffset
            });
          }
          moveSelectionForward_1 = moveSelectionForward;
          return moveSelectionForward_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var keyCommandDeleteWord_1;
        var hasRequiredKeyCommandDeleteWord;
        function requireKeyCommandDeleteWord() {
          if (hasRequiredKeyCommandDeleteWord) return keyCommandDeleteWord_1;
          hasRequiredKeyCommandDeleteWord = 1;
          var DraftRemovableWord = requireDraftRemovableWord();
          var EditorState = requireEditorState();
          var moveSelectionForward = requireMoveSelectionForward();
          var removeTextWithStrategy = requireRemoveTextWithStrategy();
          /**
           * Delete the word that is right of the cursor, as well as any spaces or
           * punctuation before the word.
           */

          function keyCommandDeleteWord(editorState) {
            var afterRemoval = removeTextWithStrategy(editorState, function (strategyState) {
              var selection = strategyState.getSelection();
              var offset = selection.getStartOffset();
              var key = selection.getStartKey();
              var content = strategyState.getCurrentContent();
              var text = content.getBlockForKey(key).getText().slice(offset);
              var toRemove = DraftRemovableWord.getForward(text); // If there are no words in front of the cursor, remove the newline.

              return moveSelectionForward(strategyState, toRemove.length || 1);
            }, 'forward');
            if (afterRemoval === editorState.getCurrentContent()) {
              return editorState;
            }
            return EditorState.push(editorState, afterRemoval, 'remove-range');
          }
          keyCommandDeleteWord_1 = keyCommandDeleteWord;
          return keyCommandDeleteWord_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var keyCommandInsertNewline_1;
        var hasRequiredKeyCommandInsertNewline;
        function requireKeyCommandInsertNewline() {
          if (hasRequiredKeyCommandInsertNewline) return keyCommandInsertNewline_1;
          hasRequiredKeyCommandInsertNewline = 1;
          var DraftModifier = requireDraftModifier();
          var EditorState = requireEditorState();
          function keyCommandInsertNewline(editorState) {
            var contentState = DraftModifier.splitBlock(editorState.getCurrentContent(), editorState.getSelection());
            return EditorState.push(editorState, contentState, 'split-block');
          }
          keyCommandInsertNewline_1 = keyCommandInsertNewline;
          return keyCommandInsertNewline_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var keyCommandMoveSelectionToEndOfBlock_1;
        var hasRequiredKeyCommandMoveSelectionToEndOfBlock;
        function requireKeyCommandMoveSelectionToEndOfBlock() {
          if (hasRequiredKeyCommandMoveSelectionToEndOfBlock) return keyCommandMoveSelectionToEndOfBlock_1;
          hasRequiredKeyCommandMoveSelectionToEndOfBlock = 1;
          var EditorState = requireEditorState();
          /**
           * See comment for `moveSelectionToStartOfBlock`.
           */

          function keyCommandMoveSelectionToEndOfBlock(editorState) {
            var selection = editorState.getSelection();
            var endKey = selection.getEndKey();
            var content = editorState.getCurrentContent();
            var textLength = content.getBlockForKey(endKey).getLength();
            return EditorState.set(editorState, {
              selection: selection.merge({
                anchorKey: endKey,
                anchorOffset: textLength,
                focusKey: endKey,
                focusOffset: textLength,
                isBackward: false
              }),
              forceSelection: true
            });
          }
          keyCommandMoveSelectionToEndOfBlock_1 = keyCommandMoveSelectionToEndOfBlock;
          return keyCommandMoveSelectionToEndOfBlock_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var keyCommandMoveSelectionToStartOfBlock_1;
        var hasRequiredKeyCommandMoveSelectionToStartOfBlock;
        function requireKeyCommandMoveSelectionToStartOfBlock() {
          if (hasRequiredKeyCommandMoveSelectionToStartOfBlock) return keyCommandMoveSelectionToStartOfBlock_1;
          hasRequiredKeyCommandMoveSelectionToStartOfBlock = 1;
          var EditorState = requireEditorState();
          /**
           * Collapse selection at the start of the first selected block. This is used
           * for Firefox versions that attempt to navigate forward/backward instead of
           * moving the cursor. Other browsers are able to move the cursor natively.
           */

          function keyCommandMoveSelectionToStartOfBlock(editorState) {
            var selection = editorState.getSelection();
            var startKey = selection.getStartKey();
            return EditorState.set(editorState, {
              selection: selection.merge({
                anchorKey: startKey,
                anchorOffset: 0,
                focusKey: startKey,
                focusOffset: 0,
                isBackward: false
              }),
              forceSelection: true
            });
          }
          keyCommandMoveSelectionToStartOfBlock_1 = keyCommandMoveSelectionToStartOfBlock;
          return keyCommandMoveSelectionToStartOfBlock_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var keyCommandPlainDelete_1;
        var hasRequiredKeyCommandPlainDelete;
        function requireKeyCommandPlainDelete() {
          if (hasRequiredKeyCommandPlainDelete) return keyCommandPlainDelete_1;
          hasRequiredKeyCommandPlainDelete = 1;
          var EditorState = requireEditorState();
          var UnicodeUtils = requireUnicodeUtils();
          var moveSelectionForward = requireMoveSelectionForward();
          var removeTextWithStrategy = requireRemoveTextWithStrategy();
          /**
           * Remove the selected range. If the cursor is collapsed, remove the following
           * character. This operation is Unicode-aware, so removing a single character
           * will remove a surrogate pair properly as well.
           */

          function keyCommandPlainDelete(editorState) {
            var afterRemoval = removeTextWithStrategy(editorState, function (strategyState) {
              var selection = strategyState.getSelection();
              var content = strategyState.getCurrentContent();
              var key = selection.getAnchorKey();
              var offset = selection.getAnchorOffset();
              var charAhead = content.getBlockForKey(key).getText()[offset];
              return moveSelectionForward(strategyState, charAhead ? UnicodeUtils.getUTF16Length(charAhead, 0) : 1);
            }, 'forward');
            if (afterRemoval === editorState.getCurrentContent()) {
              return editorState;
            }
            var selection = editorState.getSelection();
            return EditorState.push(editorState, afterRemoval.set('selectionBefore', selection), selection.isCollapsed() ? 'delete-character' : 'remove-range');
          }
          keyCommandPlainDelete_1 = keyCommandPlainDelete;
          return keyCommandPlainDelete_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var keyCommandTransposeCharacters_1;
        var hasRequiredKeyCommandTransposeCharacters;
        function requireKeyCommandTransposeCharacters() {
          if (hasRequiredKeyCommandTransposeCharacters) return keyCommandTransposeCharacters_1;
          hasRequiredKeyCommandTransposeCharacters = 1;
          var DraftModifier = requireDraftModifier();
          var EditorState = requireEditorState();
          var getContentStateFragment = requireGetContentStateFragment();
          /**
           * Transpose the characters on either side of a collapsed cursor, or
           * if the cursor is at the end of the block, transpose the last two
           * characters.
           */

          function keyCommandTransposeCharacters(editorState) {
            var selection = editorState.getSelection();
            if (!selection.isCollapsed()) {
              return editorState;
            }
            var offset = selection.getAnchorOffset();
            if (offset === 0) {
              return editorState;
            }
            var blockKey = selection.getAnchorKey();
            var content = editorState.getCurrentContent();
            var block = content.getBlockForKey(blockKey);
            var length = block.getLength(); // Nothing to transpose if there aren't two characters.

            if (length <= 1) {
              return editorState;
            }
            var removalRange;
            var finalSelection;
            if (offset === length) {
              // The cursor is at the end of the block. Swap the last two characters.
              removalRange = selection.set('anchorOffset', offset - 1);
              finalSelection = selection;
            } else {
              removalRange = selection.set('focusOffset', offset + 1);
              finalSelection = removalRange.set('anchorOffset', offset + 1);
            } // Extract the character to move as a fragment. This preserves its
            // styling and entity, if any.

            var movedFragment = getContentStateFragment(content, removalRange);
            var afterRemoval = DraftModifier.removeRange(content, removalRange, 'backward'); // After the removal, the insertion target is one character back.

            var selectionAfter = afterRemoval.getSelectionAfter();
            var targetOffset = selectionAfter.getAnchorOffset() - 1;
            var targetRange = selectionAfter.merge({
              anchorOffset: targetOffset,
              focusOffset: targetOffset
            });
            var afterInsert = DraftModifier.replaceWithFragment(afterRemoval, targetRange, movedFragment);
            var newEditorState = EditorState.push(editorState, afterInsert, 'insert-fragment');
            return EditorState.acceptSelection(newEditorState, finalSelection);
          }
          keyCommandTransposeCharacters_1 = keyCommandTransposeCharacters;
          return keyCommandTransposeCharacters_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var keyCommandUndo_1;
        var hasRequiredKeyCommandUndo;
        function requireKeyCommandUndo() {
          if (hasRequiredKeyCommandUndo) return keyCommandUndo_1;
          hasRequiredKeyCommandUndo = 1;
          var EditorState = requireEditorState();
          function keyCommandUndo(e, editorState, updateFn) {
            var undoneState = EditorState.undo(editorState); // If the last change to occur was a spellcheck change, allow the undo
            // event to fall through to the browser. This allows the browser to record
            // the unwanted change, which should soon lead it to learn not to suggest
            // the correction again.

            if (editorState.getLastChangeType() === 'spellcheck-change') {
              var nativelyRenderedContent = undoneState.getCurrentContent();
              updateFn(EditorState.set(undoneState, {
                nativelyRenderedContent: nativelyRenderedContent
              }));
              return;
            } // Otheriwse, manage the undo behavior manually.

            e.preventDefault();
            if (!editorState.getNativelyRenderedContent()) {
              updateFn(undoneState);
              return;
            } // Trigger a re-render with the current content state to ensure that the
            // component tree has up-to-date props for comparison.

            updateFn(EditorState.set(editorState, {
              nativelyRenderedContent: null
            })); // Wait to ensure that the re-render has occurred before performing
            // the undo action.

            setTimeout(function () {
              updateFn(undoneState);
            }, 0);
          }
          keyCommandUndo_1 = keyCommandUndo;
          return keyCommandUndo_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var editOnKeyDown_1;
        var hasRequiredEditOnKeyDown;
        function requireEditOnKeyDown() {
          if (hasRequiredEditOnKeyDown) return editOnKeyDown_1;
          hasRequiredEditOnKeyDown = 1;
          var DraftModifier = requireDraftModifier();
          var EditorState = requireEditorState();
          var KeyBindingUtil = requireKeyBindingUtil();
          var Keys = requireKeys();
          var SecondaryClipboard = requireSecondaryClipboard();
          var UserAgent = requireUserAgent();
          var isEventHandled = requireIsEventHandled();
          var keyCommandBackspaceToStartOfLine = requireKeyCommandBackspaceToStartOfLine();
          var keyCommandBackspaceWord = requireKeyCommandBackspaceWord();
          var keyCommandDeleteWord = requireKeyCommandDeleteWord();
          var keyCommandInsertNewline = requireKeyCommandInsertNewline();
          var keyCommandMoveSelectionToEndOfBlock = requireKeyCommandMoveSelectionToEndOfBlock();
          var keyCommandMoveSelectionToStartOfBlock = requireKeyCommandMoveSelectionToStartOfBlock();
          var keyCommandPlainBackspace = requireKeyCommandPlainBackspace();
          var keyCommandPlainDelete = requireKeyCommandPlainDelete();
          var keyCommandTransposeCharacters = requireKeyCommandTransposeCharacters();
          var keyCommandUndo = requireKeyCommandUndo();
          var isOptionKeyCommand = KeyBindingUtil.isOptionKeyCommand;
          var isChrome = UserAgent.isBrowser('Chrome');
          /**
           * Map a `DraftEditorCommand` command value to a corresponding function.
           */

          function onKeyCommand(command, editorState, e) {
            switch (command) {
              case 'redo':
                return EditorState.redo(editorState);
              case 'delete':
                return keyCommandPlainDelete(editorState);
              case 'delete-word':
                return keyCommandDeleteWord(editorState);
              case 'backspace':
                return keyCommandPlainBackspace(editorState);
              case 'backspace-word':
                return keyCommandBackspaceWord(editorState);
              case 'backspace-to-start-of-line':
                return keyCommandBackspaceToStartOfLine(editorState, e);
              case 'split-block':
                return keyCommandInsertNewline(editorState);
              case 'transpose-characters':
                return keyCommandTransposeCharacters(editorState);
              case 'move-selection-to-start-of-block':
                return keyCommandMoveSelectionToStartOfBlock(editorState);
              case 'move-selection-to-end-of-block':
                return keyCommandMoveSelectionToEndOfBlock(editorState);
              case 'secondary-cut':
                return SecondaryClipboard.cut(editorState);
              case 'secondary-paste':
                return SecondaryClipboard.paste(editorState);
              default:
                return editorState;
            }
          }
          /**
           * Intercept keydown behavior to handle keys and commands manually, if desired.
           *
           * Keydown combinations may be mapped to `DraftCommand` values, which may
           * correspond to command functions that modify the editor or its contents.
           *
           * See `getDefaultKeyBinding` for defaults. Alternatively, the top-level
           * component may provide a custom mapping via the `keyBindingFn` prop.
           */

          function editOnKeyDown(editor, e) {
            var keyCode = e.which;
            var editorState = editor._latestEditorState;
            function callDeprecatedHandler(handlerName) {
              var deprecatedHandler = editor.props[handlerName];
              if (deprecatedHandler) {
                deprecatedHandler(e);
                return true;
              } else {
                return false;
              }
            }
            switch (keyCode) {
              case Keys.RETURN:
                e.preventDefault(); // The top-level component may manually handle newline insertion. If
                // no special handling is performed, fall through to command handling.

                if (editor.props.handleReturn && isEventHandled(editor.props.handleReturn(e, editorState))) {
                  return;
                }
                break;
              case Keys.ESC:
                e.preventDefault();
                if (callDeprecatedHandler('onEscape')) {
                  return;
                }
                break;
              case Keys.TAB:
                if (callDeprecatedHandler('onTab')) {
                  return;
                }
                break;
              case Keys.UP:
                if (callDeprecatedHandler('onUpArrow')) {
                  return;
                }
                break;
              case Keys.RIGHT:
                if (callDeprecatedHandler('onRightArrow')) {
                  return;
                }
                break;
              case Keys.DOWN:
                if (callDeprecatedHandler('onDownArrow')) {
                  return;
                }
                break;
              case Keys.LEFT:
                if (callDeprecatedHandler('onLeftArrow')) {
                  return;
                }
                break;
              case Keys.SPACE:
                // Prevent Chrome on OSX behavior where option + space scrolls.
                if (isChrome && isOptionKeyCommand(e)) {
                  e.preventDefault();
                }
            }
            var command = editor.props.keyBindingFn(e); // If no command is specified, allow keydown event to continue.

            if (command == null || command === '') {
              if (keyCode === Keys.SPACE && isChrome && isOptionKeyCommand(e)) {
                // The default keydown event has already been prevented in order to stop
                // Chrome from scrolling. Insert a nbsp into the editor as OSX would for
                // other browsers.
                var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), "\xA0");
                editor.update(EditorState.push(editorState, contentState, 'insert-characters'));
              }
              return;
            }
            if (command === 'undo') {
              // Since undo requires some special updating behavior to keep the editor
              // in sync, handle it separately.
              keyCommandUndo(e, editorState, editor.update);
              return;
            } // At this point, we know that we're handling a command of some kind, so
            // we don't want to insert a character following the keydown.

            e.preventDefault(); // Allow components higher up the tree to handle the command first.

            if (editor.props.handleKeyCommand && isEventHandled(editor.props.handleKeyCommand(command, editorState, e.timeStamp))) {
              return;
            }
            var newState = onKeyCommand(command, editorState, e);
            if (newState !== editorState) {
              editor.update(newState);
            }
          }
          editOnKeyDown_1 = editOnKeyDown;
          return editOnKeyDown_1;
        }

        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * 
         */

        var URI_1;
        var hasRequiredURI;
        function requireURI() {
          if (hasRequiredURI) return URI_1;
          hasRequiredURI = 1;
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var URI = /*#__PURE__*/
          function () {
            function URI(uri) {
              _defineProperty(this, "_uri", void 0);
              this._uri = uri;
            }
            var _proto = URI.prototype;
            _proto.toString = function toString() {
              return this._uri;
            };
            return URI;
          }();
          URI_1 = URI;
          return URI_1;
        }
        var getSafeBodyFromHTML_1;
        var hasRequiredGetSafeBodyFromHTML;
        function requireGetSafeBodyFromHTML() {
          if (hasRequiredGetSafeBodyFromHTML) return getSafeBodyFromHTML_1;
          hasRequiredGetSafeBodyFromHTML = 1;
          var UserAgent = requireUserAgent();
          var invariant = requireInvariant();
          var isOldIE = UserAgent.isBrowser("IE <= 9");
          function getSafeBodyFromHTML(html) {
            var doc;
            var root = null;
            if (!isOldIE && document.implementation && document.implementation.createHTMLDocument) {
              doc = document.implementation.createHTMLDocument("foo");
              !doc.documentElement ? invariant(false) : void 0;
              doc.documentElement.innerHTML = html;
              root = doc.getElementsByTagName("body")[0];
            }
            return root;
          }
          getSafeBodyFromHTML_1 = getSafeBodyFromHTML;
          return getSafeBodyFromHTML_1;
        }
        var isHTMLAnchorElement_1;
        var hasRequiredIsHTMLAnchorElement;
        function requireIsHTMLAnchorElement() {
          if (hasRequiredIsHTMLAnchorElement) return isHTMLAnchorElement_1;
          hasRequiredIsHTMLAnchorElement = 1;

          /**
           * Copyright (c) Facebook, Inc. and its affiliates.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @format
           * 
           * @emails oncall+draft_js
           */
          var isElement = requireIsElement();
          function isHTMLAnchorElement(node) {
            if (!node || !node.ownerDocument) {
              return false;
            }
            return isElement(node) && node.nodeName === 'A';
          }
          isHTMLAnchorElement_1 = isHTMLAnchorElement;
          return isHTMLAnchorElement_1;
        }
        var isHTMLImageElement_1;
        var hasRequiredIsHTMLImageElement;
        function requireIsHTMLImageElement() {
          if (hasRequiredIsHTMLImageElement) return isHTMLImageElement_1;
          hasRequiredIsHTMLImageElement = 1;

          /**
           * Copyright (c) Facebook, Inc. and its affiliates.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @format
           * 
           * @emails oncall+draft_js
           */
          var isElement = requireIsElement();
          function isHTMLImageElement(node) {
            if (!node || !node.ownerDocument) {
              return false;
            }
            return isElement(node) && node.nodeName === 'IMG';
          }
          isHTMLImageElement_1 = isHTMLImageElement;
          return isHTMLImageElement_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var convertFromHTMLToContentBlocks_1;
        var hasRequiredConvertFromHTMLToContentBlocks;
        function requireConvertFromHTMLToContentBlocks() {
          if (hasRequiredConvertFromHTMLToContentBlocks) return convertFromHTMLToContentBlocks_1;
          hasRequiredConvertFromHTMLToContentBlocks = 1;
          var _knownListItemDepthCl;
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var CharacterMetadata = requireCharacterMetadata();
          var ContentBlock = requireContentBlock();
          var ContentBlockNode = requireContentBlockNode();
          var DefaultDraftBlockRenderMap = requireDefaultDraftBlockRenderMap();
          var DraftEntity = requireDraftEntity();
          var URI = requireURI();
          var cx = requireCx();
          var generateRandomKey = requireGenerateRandomKey();
          var getSafeBodyFromHTML = requireGetSafeBodyFromHTML();
          var gkx = requireGkx();
          var _require = requireImmutable(),
            List = _require.List,
            Map = _require.Map,
            OrderedSet = _require.OrderedSet;
          var isHTMLAnchorElement = requireIsHTMLAnchorElement();
          var isHTMLBRElement = requireIsHTMLBRElement();
          var isHTMLElement = requireIsHTMLElement();
          var isHTMLImageElement = requireIsHTMLImageElement();
          var experimentalTreeDataSupport = gkx('draft_tree_data_support');
          var NBSP = '&nbsp;';
          var SPACE = ' '; // used for replacing characters in HTML

          var REGEX_CR = new RegExp('\r', 'g');
          var REGEX_LF = new RegExp('\n', 'g');
          var REGEX_LEADING_LF = new RegExp('^\n', 'g');
          var REGEX_NBSP = new RegExp(NBSP, 'g');
          var REGEX_CARRIAGE = new RegExp('&#13;?', 'g');
          var REGEX_ZWS = new RegExp('&#8203;?', 'g'); // https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight

          var boldValues = ['bold', 'bolder', '500', '600', '700', '800', '900'];
          var notBoldValues = ['light', 'lighter', 'normal', '100', '200', '300', '400'];
          var anchorAttr = ['className', 'href', 'rel', 'target', 'title'];
          var imgAttr = ['alt', 'className', 'height', 'src', 'width'];
          var knownListItemDepthClasses = (_knownListItemDepthCl = {}, _defineProperty(_knownListItemDepthCl, cx('public/DraftStyleDefault/depth0'), 0), _defineProperty(_knownListItemDepthCl, cx('public/DraftStyleDefault/depth1'), 1), _defineProperty(_knownListItemDepthCl, cx('public/DraftStyleDefault/depth2'), 2), _defineProperty(_knownListItemDepthCl, cx('public/DraftStyleDefault/depth3'), 3), _defineProperty(_knownListItemDepthCl, cx('public/DraftStyleDefault/depth4'), 4), _knownListItemDepthCl);
          var HTMLTagToRawInlineStyleMap = Map({
            b: 'BOLD',
            code: 'CODE',
            del: 'STRIKETHROUGH',
            em: 'ITALIC',
            i: 'ITALIC',
            s: 'STRIKETHROUGH',
            strike: 'STRIKETHROUGH',
            strong: 'BOLD',
            u: 'UNDERLINE',
            mark: 'HIGHLIGHT'
          });

          /**
           * Build a mapping from HTML tags to draftjs block types
           * out of a BlockRenderMap.
           *
           * The BlockTypeMap for the default BlockRenderMap looks like this:
           *   Map({
           *     h1: 'header-one',
           *     h2: 'header-two',
           *     h3: 'header-three',
           *     h4: 'header-four',
           *     h5: 'header-five',
           *     h6: 'header-six',
           *     blockquote: 'blockquote',
           *     figure: 'atomic',
           *     pre: ['code-block'],
           *     div: 'unstyled',
           *     p: 'unstyled',
           *     li: ['ordered-list-item', 'unordered-list-item'],
           *   })
           */
          var buildBlockTypeMap = function buildBlockTypeMap(blockRenderMap) {
            var blockTypeMap = {};
            blockRenderMap.mapKeys(function (blockType, desc) {
              var elements = [desc.element];
              if (desc.aliasedElements !== undefined) {
                elements.push.apply(elements, desc.aliasedElements);
              }
              elements.forEach(function (element) {
                if (blockTypeMap[element] === undefined) {
                  blockTypeMap[element] = blockType;
                } else if (typeof blockTypeMap[element] === 'string') {
                  blockTypeMap[element] = [blockTypeMap[element], blockType];
                } else {
                  blockTypeMap[element].push(blockType);
                }
              });
            });
            return Map(blockTypeMap);
          };
          var detectInlineStyle = function detectInlineStyle(node) {
            if (isHTMLElement(node)) {
              var element = node; // Currently only used to detect preformatted inline code

              if (element.style.fontFamily.includes('monospace')) {
                return 'CODE';
              }
            }
            return null;
          };
          /**
           * If we're pasting from one DraftEditor to another we can check to see if
           * existing list item depth classes are being used and preserve this style
           */

          var getListItemDepth = function getListItemDepth(node) {
            var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            Object.keys(knownListItemDepthClasses).some(function (depthClass) {
              if (node.classList.contains(depthClass)) {
                depth = knownListItemDepthClasses[depthClass];
              }
            });
            return depth;
          };
          /**
           * Return true if the provided HTML Element can be used to build a
           * Draftjs-compatible link.
           */

          var isValidAnchor = function isValidAnchor(node) {
            if (!isHTMLAnchorElement(node)) {
              return false;
            }
            var anchorNode = node;
            if (!anchorNode.href || anchorNode.protocol !== 'http:' && anchorNode.protocol !== 'https:' && anchorNode.protocol !== 'mailto:' && anchorNode.protocol !== 'tel:') {
              return false;
            }
            try {
              // Just checking whether we can actually create a URI
              var _ = new URI(anchorNode.href);
              return true; // We need our catch statements to have arguments, else
              // UglifyJS (which we use for our OSS builds) will crash.
              // eslint-disable-next-line fb-www/no-unused-catch-bindings
            } catch (_) {
              return false;
            }
          };
          /**
           * Return true if the provided HTML Element can be used to build a
           * Draftjs-compatible image.
           */

          var isValidImage = function isValidImage(node) {
            if (!isHTMLImageElement(node)) {
              return false;
            }
            var imageNode = node;
            return !!(imageNode.attributes.getNamedItem('src') && imageNode.attributes.getNamedItem('src').value);
          };
          /**
           * Try to guess the inline style of an HTML element based on its css
           * styles (font-weight, font-style and text-decoration).
           */

          var styleFromNodeAttributes = function styleFromNodeAttributes(node, style) {
            if (!isHTMLElement(node)) {
              return style;
            }
            var htmlElement = node;
            var fontWeight = htmlElement.style.fontWeight;
            var fontStyle = htmlElement.style.fontStyle;
            var textDecoration = htmlElement.style.textDecoration;
            return style.withMutations(function (style) {
              if (boldValues.indexOf(fontWeight) >= 0) {
                style.add('BOLD');
              } else if (notBoldValues.indexOf(fontWeight) >= 0) {
                style.remove('BOLD');
              }
              if (fontStyle === 'italic') {
                style.add('ITALIC');
              } else if (fontStyle === 'normal') {
                style.remove('ITALIC');
              }
              if (textDecoration === 'underline') {
                style.add('UNDERLINE');
              }
              if (textDecoration === 'line-through') {
                style.add('STRIKETHROUGH');
              }
              if (textDecoration === 'none') {
                style.remove('UNDERLINE');
                style.remove('STRIKETHROUGH');
              }
            });
          };
          /**
           * Determine if a nodeName is a list type, 'ul' or 'ol'
           */

          var isListNode = function isListNode(nodeName) {
            return nodeName === 'ul' || nodeName === 'ol';
          };
          /**
           *  ContentBlockConfig is a mutable data structure that holds all
           *  the information required to build a ContentBlock and an array of
           *  all the child nodes (childConfigs).
           *  It is being used a temporary data structure by the
           *  ContentBlocksBuilder class.
           */

          /**
           * ContentBlocksBuilder builds a list of ContentBlocks and an Entity Map
           * out of one (or several) HTMLElement(s).
           *
           * The algorithm has two passes: first it builds a tree of ContentBlockConfigs
           * by walking through the HTML nodes and their children, then it walks the
           * ContentBlockConfigs tree to compute parents/siblings and create
           * the actual ContentBlocks.
           *
           * Typical usage is:
           *     new ContentBlocksBuilder()
           *        .addDOMNode(someHTMLNode)
           *        .addDOMNode(someOtherHTMLNode)
           *       .getContentBlocks();
           *
           */
          var ContentBlocksBuilder = /*#__PURE__*/function () {
            // Most of the method in the class depend on the state of the content builder
            // (i.e. currentBlockType, currentDepth, currentEntity etc.). Though it may
            // be confusing at first, it made the code simpler than the alternative which
            // is to pass those values around in every call.
            // The following attributes are used to accumulate text and styles
            // as we are walking the HTML node tree.
            // Describes the future ContentState as a tree of content blocks
            // The content blocks generated from the blockConfigs
            // Entity map use to store links and images found in the HTML nodes
            // Map HTML tags to draftjs block types and disambiguation function
            function ContentBlocksBuilder(blockTypeMap, disambiguate) {
              _defineProperty(this, "characterList", List());
              _defineProperty(this, "currentBlockType", 'unstyled');
              _defineProperty(this, "currentDepth", 0);
              _defineProperty(this, "currentEntity", null);
              _defineProperty(this, "currentText", '');
              _defineProperty(this, "wrapper", null);
              _defineProperty(this, "blockConfigs", []);
              _defineProperty(this, "contentBlocks", []);
              _defineProperty(this, "entityMap", DraftEntity);
              _defineProperty(this, "blockTypeMap", void 0);
              _defineProperty(this, "disambiguate", void 0);
              this.clear();
              this.blockTypeMap = blockTypeMap;
              this.disambiguate = disambiguate;
            }
            /**
             * Clear the internal state of the ContentBlocksBuilder
             */

            var _proto = ContentBlocksBuilder.prototype;
            _proto.clear = function clear() {
              this.characterList = List();
              this.blockConfigs = [];
              this.currentBlockType = 'unstyled';
              this.currentDepth = 0;
              this.currentEntity = null;
              this.currentText = '';
              this.entityMap = DraftEntity;
              this.wrapper = null;
              this.contentBlocks = [];
            }
            /**
             * Add an HTMLElement to the ContentBlocksBuilder
             */;
            _proto.addDOMNode = function addDOMNode(node) {
              var _this$blockConfigs;
              this.contentBlocks = [];
              this.currentDepth = 0; // Converts the HTML node to block config

              (_this$blockConfigs = this.blockConfigs).push.apply(_this$blockConfigs, this._toBlockConfigs([node], OrderedSet())); // There might be some left over text in the builder's
              // internal state, if so make a ContentBlock out of it.

              this._trimCurrentText();
              if (this.currentText !== '') {
                this.blockConfigs.push(this._makeBlockConfig());
              } // for chaining

              return this;
            }
            /**
             * Return the ContentBlocks and the EntityMap that corresponds
             * to the previously added HTML nodes.
             */;
            _proto.getContentBlocks = function getContentBlocks() {
              if (this.contentBlocks.length === 0) {
                if (experimentalTreeDataSupport) {
                  this._toContentBlocks(this.blockConfigs);
                } else {
                  this._toFlatContentBlocks(this.blockConfigs);
                }
              }
              return {
                contentBlocks: this.contentBlocks,
                entityMap: this.entityMap
              };
            } // ***********************************WARNING******************************
            // The methods below this line are private - don't call them directly.

            /**
             * Generate a new ContentBlockConfig out of the current internal state
             * of the builder, then clears the internal state.
             */;
            _proto._makeBlockConfig = function _makeBlockConfig() {
              var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var key = config.key || generateRandomKey();
              var block = _objectSpread({
                key: key,
                type: this.currentBlockType,
                text: this.currentText,
                characterList: this.characterList,
                depth: this.currentDepth,
                parent: null,
                children: List(),
                prevSibling: null,
                nextSibling: null,
                childConfigs: []
              }, config);
              this.characterList = List();
              this.currentBlockType = 'unstyled';
              this.currentText = '';
              return block;
            }
            /**
             * Converts an array of HTML elements to a multi-root tree of content
             * block configs. Some text content may be left in the builders internal
             * state to enable chaining sucessive calls.
             */;
            _proto._toBlockConfigs = function _toBlockConfigs(nodes, style) {
              var blockConfigs = [];
              for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                var nodeName = node.nodeName.toLowerCase();
                if (nodeName === 'body' || isListNode(nodeName)) {
                  // body, ol and ul are 'block' type nodes so create a block config
                  // with the text accumulated so far (if any)
                  this._trimCurrentText();
                  if (this.currentText !== '') {
                    blockConfigs.push(this._makeBlockConfig());
                  } // body, ol and ul nodes are ignored, but their children are inlined in
                  // the parent block config.

                  var wasCurrentDepth = this.currentDepth;
                  var wasWrapper = this.wrapper;
                  if (isListNode(nodeName)) {
                    this.wrapper = nodeName;
                    if (isListNode(wasWrapper)) {
                      this.currentDepth++;
                    }
                  }
                  blockConfigs.push.apply(blockConfigs, this._toBlockConfigs(Array.from(node.childNodes), style));
                  this.currentDepth = wasCurrentDepth;
                  this.wrapper = wasWrapper;
                  continue;
                }
                var blockType = this.blockTypeMap.get(nodeName);
                if (blockType !== undefined) {
                  // 'block' type node means we need to create a block config
                  // with the text accumulated so far (if any)
                  this._trimCurrentText();
                  if (this.currentText !== '') {
                    blockConfigs.push(this._makeBlockConfig());
                  }
                  var _wasCurrentDepth = this.currentDepth;
                  var _wasWrapper = this.wrapper;
                  this.wrapper = nodeName === 'pre' ? 'pre' : this.wrapper;
                  if (typeof blockType !== 'string') {
                    blockType = this.disambiguate(nodeName, this.wrapper) || blockType[0] || 'unstyled';
                  }
                  if (!experimentalTreeDataSupport && isHTMLElement(node) && (blockType === 'unordered-list-item' || blockType === 'ordered-list-item')) {
                    var htmlElement = node;
                    this.currentDepth = getListItemDepth(htmlElement, this.currentDepth);
                  }
                  var key = generateRandomKey();
                  var childConfigs = this._toBlockConfigs(Array.from(node.childNodes), style);
                  this._trimCurrentText();
                  blockConfigs.push(this._makeBlockConfig({
                    key: key,
                    childConfigs: childConfigs,
                    type: blockType
                  }));
                  this.currentDepth = _wasCurrentDepth;
                  this.wrapper = _wasWrapper;
                  continue;
                }
                if (nodeName === '#text') {
                  this._addTextNode(node, style);
                  continue;
                }
                if (nodeName === 'br') {
                  this._addBreakNode(node, style);
                  continue;
                }
                if (isValidImage(node)) {
                  this._addImgNode(node, style);
                  continue;
                }
                if (isValidAnchor(node)) {
                  this._addAnchorNode(node, blockConfigs, style);
                  continue;
                }
                var newStyle = style;
                if (HTMLTagToRawInlineStyleMap.has(nodeName)) {
                  newStyle = newStyle.add(HTMLTagToRawInlineStyleMap.get(nodeName));
                }
                newStyle = styleFromNodeAttributes(node, newStyle);
                var inlineStyle = detectInlineStyle(node);
                if (inlineStyle != null) {
                  newStyle = newStyle.add(inlineStyle);
                }
                blockConfigs.push.apply(blockConfigs, this._toBlockConfigs(Array.from(node.childNodes), newStyle));
              }
              return blockConfigs;
            }
            /**
             * Append a string of text to the internal buffer.
             */;
            _proto._appendText = function _appendText(text, style) {
              var _this$characterList;
              this.currentText += text;
              var characterMetadata = CharacterMetadata.create({
                style: style,
                entity: this.currentEntity
              });
              this.characterList = (_this$characterList = this.characterList).push.apply(_this$characterList, Array(text.length).fill(characterMetadata));
            }
            /**
             * Trim the text in the internal buffer.
             */;
            _proto._trimCurrentText = function _trimCurrentText() {
              var l = this.currentText.length;
              var begin = l - this.currentText.trimLeft().length;
              var end = this.currentText.trimRight().length; // We should not trim whitespaces for which an entity is defined.

              var entity = this.characterList.findEntry(function (characterMetadata) {
                return characterMetadata.getEntity() !== null;
              });
              begin = entity !== undefined ? Math.min(begin, entity[0]) : begin;
              entity = this.characterList.reverse().findEntry(function (characterMetadata) {
                return characterMetadata.getEntity() !== null;
              });
              end = entity !== undefined ? Math.max(end, l - entity[0]) : end;
              if (begin > end) {
                this.currentText = '';
                this.characterList = List();
              } else {
                this.currentText = this.currentText.slice(begin, end);
                this.characterList = this.characterList.slice(begin, end);
              }
            }
            /**
             * Add the content of an HTML text node to the internal state
             */;
            _proto._addTextNode = function _addTextNode(node, style) {
              var text = node.textContent;
              var trimmedText = text.trim(); // If we are not in a pre block and the trimmed content is empty,
              // normalize to a single space.

              if (trimmedText === '' && this.wrapper !== 'pre') {
                text = ' ';
              }
              if (this.wrapper !== 'pre') {
                // Trim leading line feed, which is invisible in HTML
                text = text.replace(REGEX_LEADING_LF, ''); // Can't use empty string because MSWord

                text = text.replace(REGEX_LF, SPACE);
              }
              this._appendText(text, style);
            };
            _proto._addBreakNode = function _addBreakNode(node, style) {
              if (!isHTMLBRElement(node)) {
                return;
              }
              this._appendText('\n', style);
            }
            /**
             * Add the content of an HTML img node to the internal state
             */;
            _proto._addImgNode = function _addImgNode(node, style) {
              if (!isHTMLImageElement(node)) {
                return;
              }
              var image = node;
              var entityConfig = {};
              imgAttr.forEach(function (attr) {
                var imageAttribute = image.getAttribute(attr);
                if (imageAttribute) {
                  entityConfig[attr] = imageAttribute;
                }
              }); // TODO: T15530363 update this when we remove DraftEntity entirely

              this.currentEntity = this.entityMap.__create('IMAGE', 'IMMUTABLE', entityConfig); // The child text node cannot just have a space or return as content (since
              // we strip those out), unless the image is for presentation only.
              // See https://github.com/facebook/draft-js/issues/231 for some context.

              if (gkx('draftjs_fix_paste_for_img')) {
                if (image.getAttribute('role') !== 'presentation') {
                  this._appendText("\uD83D\uDCF7", style);
                }
              } else {
                this._appendText("\uD83D\uDCF7", style);
              }
              this.currentEntity = null;
            }
            /**
             * Add the content of an HTML 'a' node to the internal state. Child nodes
             * (if any) are converted to Block Configs and appended to the provided
             * blockConfig array.
             */;
            _proto._addAnchorNode = function _addAnchorNode(node, blockConfigs, style) {
              // The check has already been made by isValidAnchor but
              // we have to do it again to keep flow happy.
              if (!isHTMLAnchorElement(node)) {
                return;
              }
              var anchor = node;
              var entityConfig = {};
              anchorAttr.forEach(function (attr) {
                var anchorAttribute = anchor.getAttribute(attr);
                if (anchorAttribute) {
                  entityConfig[attr] = anchorAttribute;
                }
              });
              entityConfig.url = new URI(anchor.href).toString(); // TODO: T15530363 update this when we remove DraftEntity completely

              this.currentEntity = this.entityMap.__create('LINK', 'MUTABLE', entityConfig || {});
              blockConfigs.push.apply(blockConfigs, this._toBlockConfigs(Array.from(node.childNodes), style));
              this.currentEntity = null;
            }
            /**
             * Walk the BlockConfig tree, compute parent/children/siblings,
             * and generate the corresponding ContentBlockNode
             */;
            _proto._toContentBlocks = function _toContentBlocks(blockConfigs) {
              var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              var l = blockConfigs.length - 1;
              for (var i = 0; i <= l; i++) {
                var config = blockConfigs[i];
                config.parent = parent;
                config.prevSibling = i > 0 ? blockConfigs[i - 1].key : null;
                config.nextSibling = i < l ? blockConfigs[i + 1].key : null;
                config.children = List(config.childConfigs.map(function (child) {
                  return child.key;
                }));
                this.contentBlocks.push(new ContentBlockNode(_objectSpread({}, config)));
                this._toContentBlocks(config.childConfigs, config.key);
              }
            }
            /**
             * Remove 'useless' container nodes from the block config hierarchy, by
             * replacing them with their children.
             */;
            _proto._hoistContainersInBlockConfigs = function _hoistContainersInBlockConfigs(blockConfigs) {
              var _this = this;
              var hoisted = List(blockConfigs).flatMap(function (blockConfig) {
                // Don't mess with useful blocks
                if (blockConfig.type !== 'unstyled' || blockConfig.text !== '') {
                  return [blockConfig];
                }
                return _this._hoistContainersInBlockConfigs(blockConfig.childConfigs);
              });
              return hoisted;
            } // ***********************************************************************
            // The two methods below are used for backward compatibility when
            // experimentalTreeDataSupport is disabled.

            /**
             * Same as _toContentBlocks but replaces nested blocks by their
             * text content.
             */;
            _proto._toFlatContentBlocks = function _toFlatContentBlocks(blockConfigs) {
              var _this2 = this;
              var cleanConfigs = this._hoistContainersInBlockConfigs(blockConfigs);
              cleanConfigs.forEach(function (config) {
                var _this2$_extractTextFr = _this2._extractTextFromBlockConfigs(config.childConfigs),
                  text = _this2$_extractTextFr.text,
                  characterList = _this2$_extractTextFr.characterList;
                _this2.contentBlocks.push(new ContentBlock(_objectSpread({}, config, {
                  text: config.text + text,
                  characterList: config.characterList.concat(characterList)
                })));
              });
            }
            /**
             * Extract the text and the associated inline styles form an
             * array of content block configs.
             */;
            _proto._extractTextFromBlockConfigs = function _extractTextFromBlockConfigs(blockConfigs) {
              var l = blockConfigs.length - 1;
              var text = '';
              var characterList = List();
              for (var i = 0; i <= l; i++) {
                var config = blockConfigs[i];
                text += config.text;
                characterList = characterList.concat(config.characterList);
                if (text !== '' && config.type !== 'unstyled') {
                  text += '\n';
                  characterList = characterList.push(characterList.last());
                }
                var children = this._extractTextFromBlockConfigs(config.childConfigs);
                text += children.text;
                characterList = characterList.concat(children.characterList);
              }
              return {
                text: text,
                characterList: characterList
              };
            };
            return ContentBlocksBuilder;
          }();
          /**
           * Converts an HTML string to an array of ContentBlocks and an EntityMap
           * suitable to initialize the internal state of a Draftjs component.
           */

          var convertFromHTMLToContentBlocks = function convertFromHTMLToContentBlocks(html) {
            var DOMBuilder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getSafeBodyFromHTML;
            var blockRenderMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultDraftBlockRenderMap;
            // Be ABSOLUTELY SURE that the dom builder you pass here won't execute
            // arbitrary code in whatever environment you're running this in. For an
            // example of how we try to do this in-browser, see getSafeBodyFromHTML.
            // Remove funky characters from the HTML string
            html = html.trim().replace(REGEX_CR, '').replace(REGEX_NBSP, SPACE).replace(REGEX_CARRIAGE, '').replace(REGEX_ZWS, ''); // Build a DOM tree out of the HTML string

            var safeBody = DOMBuilder(html);
            if (!safeBody) {
              return null;
            } // Build a BlockTypeMap out of the BlockRenderMap

            var blockTypeMap = buildBlockTypeMap(blockRenderMap); // Select the proper block type for the cases where the blockRenderMap
            // uses multiple block types for the same html tag.

            var disambiguate = function disambiguate(tag, wrapper) {
              if (tag === 'li') {
                return wrapper === 'ol' ? 'ordered-list-item' : 'unordered-list-item';
              }
              return null;
            };
            return new ContentBlocksBuilder(blockTypeMap, disambiguate).addDOMNode(safeBody).getContentBlocks();
          };
          convertFromHTMLToContentBlocks_1 = convertFromHTMLToContentBlocks;
          return convertFromHTMLToContentBlocks_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DraftPasteProcessor_1;
        var hasRequiredDraftPasteProcessor;
        function requireDraftPasteProcessor() {
          if (hasRequiredDraftPasteProcessor) return DraftPasteProcessor_1;
          hasRequiredDraftPasteProcessor = 1;
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var ContentBlock = requireContentBlock();
          var ContentBlockNode = requireContentBlockNode();
          var convertFromHTMLToContentBlocks = requireConvertFromHTMLToContentBlocks();
          var generateRandomKey = requireGenerateRandomKey();
          var getSafeBodyFromHTML = requireGetSafeBodyFromHTML();
          var gkx = requireGkx();
          var Immutable = requireImmutable();
          var sanitizeDraftText = requireSanitizeDraftText();
          var List = Immutable.List,
            Repeat = Immutable.Repeat;
          var experimentalTreeDataSupport = gkx('draft_tree_data_support');
          var ContentBlockRecord = experimentalTreeDataSupport ? ContentBlockNode : ContentBlock;
          var DraftPasteProcessor = {
            processHTML: function processHTML(html, blockRenderMap) {
              return convertFromHTMLToContentBlocks(html, getSafeBodyFromHTML, blockRenderMap);
            },
            processText: function processText(textBlocks, character, type) {
              return textBlocks.reduce(function (acc, textLine, index) {
                textLine = sanitizeDraftText(textLine);
                var key = generateRandomKey();
                var blockNodeConfig = {
                  key: key,
                  type: type,
                  text: textLine,
                  characterList: List(Repeat(character, textLine.length))
                }; // next block updates previous block

                if (experimentalTreeDataSupport && index !== 0) {
                  var prevSiblingIndex = index - 1; // update previous block

                  var previousBlock = acc[prevSiblingIndex] = acc[prevSiblingIndex].merge({
                    nextSibling: key
                  });
                  blockNodeConfig = _objectSpread({}, blockNodeConfig, {
                    prevSibling: previousBlock.getKey()
                  });
                }
                acc.push(new ContentBlockRecord(blockNodeConfig));
                return acc;
              }, []);
            }
          };
          DraftPasteProcessor_1 = DraftPasteProcessor;
          return DraftPasteProcessor_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var adjustBlockDepthForContentState_1;
        var hasRequiredAdjustBlockDepthForContentState;
        function requireAdjustBlockDepthForContentState() {
          if (hasRequiredAdjustBlockDepthForContentState) return adjustBlockDepthForContentState_1;
          hasRequiredAdjustBlockDepthForContentState = 1;
          function adjustBlockDepthForContentState(contentState, selectionState, adjustment, maxDepth) {
            var startKey = selectionState.getStartKey();
            var endKey = selectionState.getEndKey();
            var blockMap = contentState.getBlockMap();
            var blocks = blockMap.toSeq().skipUntil(function (_, k) {
              return k === startKey;
            }).takeUntil(function (_, k) {
              return k === endKey;
            }).concat([[endKey, blockMap.get(endKey)]]).map(function (block) {
              var depth = block.getDepth() + adjustment;
              depth = Math.max(0, Math.min(depth, maxDepth));
              return block.set('depth', depth);
            });
            blockMap = blockMap.merge(blocks);
            return contentState.merge({
              blockMap: blockMap,
              selectionBefore: selectionState,
              selectionAfter: selectionState
            });
          }
          adjustBlockDepthForContentState_1 = adjustBlockDepthForContentState;
          return adjustBlockDepthForContentState_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var RichTextEditorUtil_1;
        var hasRequiredRichTextEditorUtil;
        function requireRichTextEditorUtil() {
          if (hasRequiredRichTextEditorUtil) return RichTextEditorUtil_1;
          hasRequiredRichTextEditorUtil = 1;
          var DraftModifier = requireDraftModifier();
          var EditorState = requireEditorState();
          var adjustBlockDepthForContentState = requireAdjustBlockDepthForContentState();
          var nullthrows = requireNullthrows();
          var RichTextEditorUtil = {
            currentBlockContainsLink: function currentBlockContainsLink(editorState) {
              var selection = editorState.getSelection();
              var contentState = editorState.getCurrentContent();
              var entityMap = contentState.getEntityMap();
              return contentState.getBlockForKey(selection.getAnchorKey()).getCharacterList().slice(selection.getStartOffset(), selection.getEndOffset()).some(function (v) {
                var entity = v.getEntity();
                return !!entity && entityMap.__get(entity).getType() === 'LINK';
              });
            },
            getCurrentBlockType: function getCurrentBlockType(editorState) {
              var selection = editorState.getSelection();
              return editorState.getCurrentContent().getBlockForKey(selection.getStartKey()).getType();
            },
            getDataObjectForLinkURL: function getDataObjectForLinkURL(uri) {
              return {
                url: uri.toString()
              };
            },
            handleKeyCommand: function handleKeyCommand(editorState, command, eventTimeStamp) {
              switch (command) {
                case 'bold':
                  return RichTextEditorUtil.toggleInlineStyle(editorState, 'BOLD');
                case 'italic':
                  return RichTextEditorUtil.toggleInlineStyle(editorState, 'ITALIC');
                case 'underline':
                  return RichTextEditorUtil.toggleInlineStyle(editorState, 'UNDERLINE');
                case 'code':
                  return RichTextEditorUtil.toggleCode(editorState);
                case 'backspace':
                case 'backspace-word':
                case 'backspace-to-start-of-line':
                  return RichTextEditorUtil.onBackspace(editorState);
                case 'delete':
                case 'delete-word':
                case 'delete-to-end-of-block':
                  return RichTextEditorUtil.onDelete(editorState);
                default:
                  // they may have custom editor commands; ignore those
                  return null;
              }
            },
            insertSoftNewline: function insertSoftNewline(editorState) {
              var contentState = DraftModifier.insertText(editorState.getCurrentContent(), editorState.getSelection(), '\n', editorState.getCurrentInlineStyle(), null);
              var newEditorState = EditorState.push(editorState, contentState, 'insert-characters');
              return EditorState.forceSelection(newEditorState, contentState.getSelectionAfter());
            },
            /**
             * For collapsed selections at the start of styled blocks, backspace should
             * just remove the existing style.
             */
            onBackspace: function onBackspace(editorState) {
              var selection = editorState.getSelection();
              if (!selection.isCollapsed() || selection.getAnchorOffset() || selection.getFocusOffset()) {
                return null;
              } // First, try to remove a preceding atomic block.

              var content = editorState.getCurrentContent();
              var startKey = selection.getStartKey();
              var blockBefore = content.getBlockBefore(startKey);
              if (blockBefore && blockBefore.getType() === 'atomic') {
                var blockMap = content.getBlockMap()["delete"](blockBefore.getKey());
                var withoutAtomicBlock = content.merge({
                  blockMap: blockMap,
                  selectionAfter: selection
                });
                if (withoutAtomicBlock !== content) {
                  return EditorState.push(editorState, withoutAtomicBlock, 'remove-range');
                }
              } // If that doesn't succeed, try to remove the current block style.

              var withoutBlockStyle = RichTextEditorUtil.tryToRemoveBlockStyle(editorState);
              if (withoutBlockStyle) {
                return EditorState.push(editorState, withoutBlockStyle, 'change-block-type');
              }
              return null;
            },
            onDelete: function onDelete(editorState) {
              var selection = editorState.getSelection();
              if (!selection.isCollapsed()) {
                return null;
              }
              var content = editorState.getCurrentContent();
              var startKey = selection.getStartKey();
              var block = content.getBlockForKey(startKey);
              var length = block.getLength(); // The cursor is somewhere within the text. Behave normally.

              if (selection.getStartOffset() < length) {
                return null;
              }
              var blockAfter = content.getBlockAfter(startKey);
              if (!blockAfter || blockAfter.getType() !== 'atomic') {
                return null;
              }
              var atomicBlockTarget = selection.merge({
                focusKey: blockAfter.getKey(),
                focusOffset: blockAfter.getLength()
              });
              var withoutAtomicBlock = DraftModifier.removeRange(content, atomicBlockTarget, 'forward');
              if (withoutAtomicBlock !== content) {
                return EditorState.push(editorState, withoutAtomicBlock, 'remove-range');
              }
              return null;
            },
            onTab: function onTab(event, editorState, maxDepth) {
              var selection = editorState.getSelection();
              var key = selection.getAnchorKey();
              if (key !== selection.getFocusKey()) {
                return editorState;
              }
              var content = editorState.getCurrentContent();
              var block = content.getBlockForKey(key);
              var type = block.getType();
              if (type !== 'unordered-list-item' && type !== 'ordered-list-item') {
                return editorState;
              }
              event.preventDefault();
              var depth = block.getDepth();
              if (!event.shiftKey && depth === maxDepth) {
                return editorState;
              }
              var withAdjustment = adjustBlockDepthForContentState(content, selection, event.shiftKey ? -1 : 1, maxDepth);
              return EditorState.push(editorState, withAdjustment, 'adjust-depth');
            },
            toggleBlockType: function toggleBlockType(editorState, blockType) {
              var selection = editorState.getSelection();
              var startKey = selection.getStartKey();
              var endKey = selection.getEndKey();
              var content = editorState.getCurrentContent();
              var target = selection; // Triple-click can lead to a selection that includes offset 0 of the
              // following block. The `SelectionState` for this case is accurate, but
              // we should avoid toggling block type for the trailing block because it
              // is a confusing interaction.

              if (startKey !== endKey && selection.getEndOffset() === 0) {
                var blockBefore = nullthrows(content.getBlockBefore(endKey));
                endKey = blockBefore.getKey();
                target = target.merge({
                  anchorKey: startKey,
                  anchorOffset: selection.getStartOffset(),
                  focusKey: endKey,
                  focusOffset: blockBefore.getLength(),
                  isBackward: false
                });
              }
              var hasAtomicBlock = content.getBlockMap().skipWhile(function (_, k) {
                return k !== startKey;
              }).reverse().skipWhile(function (_, k) {
                return k !== endKey;
              }).some(function (v) {
                return v.getType() === 'atomic';
              });
              if (hasAtomicBlock) {
                return editorState;
              }
              var typeToSet = content.getBlockForKey(startKey).getType() === blockType ? 'unstyled' : blockType;
              return EditorState.push(editorState, DraftModifier.setBlockType(content, target, typeToSet), 'change-block-type');
            },
            toggleCode: function toggleCode(editorState) {
              var selection = editorState.getSelection();
              var anchorKey = selection.getAnchorKey();
              var focusKey = selection.getFocusKey();
              if (selection.isCollapsed() || anchorKey !== focusKey) {
                return RichTextEditorUtil.toggleBlockType(editorState, 'code-block');
              }
              return RichTextEditorUtil.toggleInlineStyle(editorState, 'CODE');
            },
            /**
             * Toggle the specified inline style for the selection. If the
             * user's selection is collapsed, apply or remove the style for the
             * internal state. If it is not collapsed, apply the change directly
             * to the document state.
             */
            toggleInlineStyle: function toggleInlineStyle(editorState, inlineStyle) {
              var selection = editorState.getSelection();
              var currentStyle = editorState.getCurrentInlineStyle(); // If the selection is collapsed, toggle the specified style on or off and
              // set the result as the new inline style override. This will then be
              // used as the inline style for the next character to be inserted.

              if (selection.isCollapsed()) {
                return EditorState.setInlineStyleOverride(editorState, currentStyle.has(inlineStyle) ? currentStyle.remove(inlineStyle) : currentStyle.add(inlineStyle));
              } // If characters are selected, immediately apply or remove the
              // inline style on the document state itself.

              var content = editorState.getCurrentContent();
              var newContent; // If the style is already present for the selection range, remove it.
              // Otherwise, apply it.

              if (currentStyle.has(inlineStyle)) {
                newContent = DraftModifier.removeInlineStyle(content, selection, inlineStyle);
              } else {
                newContent = DraftModifier.applyInlineStyle(content, selection, inlineStyle);
              }
              return EditorState.push(editorState, newContent, 'change-inline-style');
            },
            toggleLink: function toggleLink(editorState, targetSelection, entityKey) {
              var withoutLink = DraftModifier.applyEntity(editorState.getCurrentContent(), targetSelection, entityKey);
              return EditorState.push(editorState, withoutLink, 'apply-entity');
            },
            /**
             * When a collapsed cursor is at the start of a styled block, changes block
             * type to 'unstyled'. Returns null if selection does not meet that criteria.
             */
            tryToRemoveBlockStyle: function tryToRemoveBlockStyle(editorState) {
              var selection = editorState.getSelection();
              var offset = selection.getAnchorOffset();
              if (selection.isCollapsed() && offset === 0) {
                var key = selection.getAnchorKey();
                var content = editorState.getCurrentContent();
                var block = content.getBlockForKey(key);
                var type = block.getType();
                var blockBefore = content.getBlockBefore(key);
                if (type === 'code-block' && blockBefore && blockBefore.getType() === 'code-block' && blockBefore.getLength() !== 0) {
                  return null;
                }
                if (type !== 'unstyled') {
                  return DraftModifier.setBlockType(content, selection, 'unstyled');
                }
              }
              return null;
            }
          };
          RichTextEditorUtil_1 = RichTextEditorUtil;
          return RichTextEditorUtil_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var splitTextIntoTextBlocks_1;
        var hasRequiredSplitTextIntoTextBlocks;
        function requireSplitTextIntoTextBlocks() {
          if (hasRequiredSplitTextIntoTextBlocks) return splitTextIntoTextBlocks_1;
          hasRequiredSplitTextIntoTextBlocks = 1;
          var NEWLINE_REGEX = /\r\n?|\n/g;
          function splitTextIntoTextBlocks(text) {
            return text.split(NEWLINE_REGEX);
          }
          splitTextIntoTextBlocks_1 = splitTextIntoTextBlocks;
          return splitTextIntoTextBlocks_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var editOnPaste_1;
        var hasRequiredEditOnPaste;
        function requireEditOnPaste() {
          if (hasRequiredEditOnPaste) return editOnPaste_1;
          hasRequiredEditOnPaste = 1;
          var BlockMapBuilder = requireBlockMapBuilder();
          var CharacterMetadata = requireCharacterMetadata();
          var DataTransfer = requireDataTransfer();
          var DraftModifier = requireDraftModifier();
          var DraftPasteProcessor = requireDraftPasteProcessor();
          var EditorState = requireEditorState();
          var RichTextEditorUtil = requireRichTextEditorUtil();
          var getEntityKeyForSelection = requireGetEntityKeyForSelection();
          var getTextContentFromFiles = requireGetTextContentFromFiles();
          var isEventHandled = requireIsEventHandled();
          var splitTextIntoTextBlocks = requireSplitTextIntoTextBlocks();
          /**
           * Paste content.
           */

          function editOnPaste(editor, e) {
            e.preventDefault();
            var data = new DataTransfer(e.clipboardData); // Get files, unless this is likely to be a string the user wants inline.

            if (!data.isRichText()) {
              var files = data.getFiles();
              var defaultFileText = data.getText();
              if (files.length > 0) {
                // Allow customized paste handling for images, etc. Otherwise, fall
                // through to insert text contents into the editor.
                if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {
                  return;
                }
                /* $FlowFixMe[incompatible-call] This comment suppresses an error found
                 * DataTransfer was typed. getFiles() returns an array of <Files extends
                 * Blob>, not Blob */

                getTextContentFromFiles(files, function (/*string*/
                fileText) {
                  fileText = fileText || defaultFileText;
                  if (!fileText) {
                    return;
                  }
                  var editorState = editor._latestEditorState;
                  var blocks = splitTextIntoTextBlocks(fileText);
                  var character = CharacterMetadata.create({
                    style: editorState.getCurrentInlineStyle(),
                    entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())
                  });
                  var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);
                  var text = DraftPasteProcessor.processText(blocks, character, currentBlockType);
                  var fragment = BlockMapBuilder.createFromArray(text);
                  var withInsertedText = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);
                  editor.update(EditorState.push(editorState, withInsertedText, 'insert-fragment'));
                });
                return;
              }
            }
            var textBlocks = [];
            var text = data.getText();
            var html = data.getHTML();
            var editorState = editor._latestEditorState;
            if (editor.props.formatPastedText) {
              var _editor$props$formatP = editor.props.formatPastedText(text, html),
                formattedText = _editor$props$formatP.text,
                formattedHtml = _editor$props$formatP.html;
              text = formattedText;
              html = formattedHtml;
            }
            if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {
              return;
            }
            if (text) {
              textBlocks = splitTextIntoTextBlocks(text);
            }
            if (!editor.props.stripPastedStyles) {
              // If the text from the paste event is rich content that matches what we
              // already have on the internal clipboard, assume that we should just use
              // the clipboard fragment for the paste. This will allow us to preserve
              // styling and entities, if any are present. Note that newlines are
              // stripped during comparison -- this is because copy/paste within the
              // editor in Firefox and IE will not include empty lines. The resulting
              // paste will preserve the newlines correctly.
              var internalClipboard = editor.getClipboard();
              if (!editor.props.formatPastedText && data.isRichText() && internalClipboard) {
                var _html;
                if (
                // If the editorKey is present in the pasted HTML, it should be safe to
                // assume this is an internal paste.
                ((_html = html) === null || _html === void 0 ? void 0 : _html.indexOf(editor.getEditorKey())) !== -1 ||
                // The copy may have been made within a single block, in which case the
                // editor key won't be part of the paste. In this case, just check
                // whether the pasted text matches the internal clipboard.
                textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {
                  editor.update(insertFragment(editor._latestEditorState, internalClipboard));
                  return;
                }
              } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {
                // Safari does not properly store text/html in some cases.
                // Use the internalClipboard if present and equal to what is on
                // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.
                editor.update(insertFragment(editor._latestEditorState, internalClipboard));
                return;
              } // If there is html paste data, try to parse that.

              if (html) {
                var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);
                if (htmlFragment) {
                  var contentBlocks = htmlFragment.contentBlocks,
                    entityMap = htmlFragment.entityMap;
                  if (contentBlocks) {
                    var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);
                    editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));
                    return;
                  }
                }
              } // Otherwise, create a new fragment from our pasted text. Also
              // empty the internal clipboard, since it's no longer valid.

              editor.setClipboard(null);
            }
            if (textBlocks.length) {
              var character = CharacterMetadata.create({
                style: editorState.getCurrentInlineStyle(),
                entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())
              });
              var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);
              var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);
              var textMap = BlockMapBuilder.createFromArray(textFragment);
              editor.update(insertFragment(editor._latestEditorState, textMap));
            }
          }
          function insertFragment(editorState, fragment, entityMap) {
            var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment); // TODO: merge the entity map once we stop using DraftEntity
            // like this:
            // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);

            return EditorState.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');
          }
          function areTextBlocksAndClipboardEqual(textBlocks, blockMap) {
            return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {
              return block.getText() === textBlocks[ii];
            });
          }
          editOnPaste_1 = editOnPaste;
          return editOnPaste_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DraftEditorEditHandler_1;
        var hasRequiredDraftEditorEditHandler;
        function requireDraftEditorEditHandler() {
          if (hasRequiredDraftEditorEditHandler) return DraftEditorEditHandler_1;
          hasRequiredDraftEditorEditHandler = 1;
          var UserAgent = requireUserAgent();
          var onBeforeInput = requireEditOnBeforeInput();
          var onBlur = requireEditOnBlur();
          var onCompositionStart = requireEditOnCompositionStart();
          var onCopy = requireEditOnCopy();
          var onCut = requireEditOnCut();
          var onDragOver = requireEditOnDragOver();
          var onDragStart = requireEditOnDragStart();
          var onFocus = requireEditOnFocus();
          var onInput = requireEditOnInput();
          var onKeyDown = requireEditOnKeyDown();
          var onPaste = requireEditOnPaste();
          var onSelect = requireEditOnSelect();
          var isChrome = UserAgent.isBrowser('Chrome');
          var isFirefox = UserAgent.isBrowser('Firefox');
          var selectionHandler = isChrome || isFirefox ? onSelect : function (e) {};
          var DraftEditorEditHandler = {
            onBeforeInput: onBeforeInput,
            onBlur: onBlur,
            onCompositionStart: onCompositionStart,
            onCopy: onCopy,
            onCut: onCut,
            onDragOver: onDragOver,
            onDragStart: onDragStart,
            onFocus: onFocus,
            onInput: onInput,
            onKeyDown: onKeyDown,
            onPaste: onPaste,
            onSelect: onSelect,
            // In certain cases, contenteditable on chrome does not fire the onSelect
            // event, causing problems with cursor positioning. Therefore, the selection
            // state update handler is added to more events to ensure that the selection
            // state is always synced with the actual cursor positions.
            onMouseUp: selectionHandler,
            onKeyUp: selectionHandler
          };
          DraftEditorEditHandler_1 = DraftEditorEditHandler;
          return DraftEditorEditHandler_1;
        }
        var DraftEditorFlushControlled;
        var hasRequiredDraftEditorFlushControlled;
        function requireDraftEditorFlushControlled() {
          if (hasRequiredDraftEditorFlushControlled) return DraftEditorFlushControlled;
          hasRequiredDraftEditorFlushControlled = 1;

          /**
           * Copyright (c) Facebook, Inc. and its affiliates.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @format
           * 
           * @emails oncall+draft_js
           */
          var ReactDOMComet = requireReactDom();
          var flushControlled = ReactDOMComet.unstable_flushControlled;
          DraftEditorFlushControlled = flushControlled;
          return DraftEditorFlushControlled;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DraftEditorPlaceholder_react;
        var hasRequiredDraftEditorPlaceholder_react;
        function requireDraftEditorPlaceholder_react() {
          if (hasRequiredDraftEditorPlaceholder_react) return DraftEditorPlaceholder_react;
          hasRequiredDraftEditorPlaceholder_react = 1;
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var React = requireReact();
          var cx = requireCx();

          /**
           * This component is responsible for rendering placeholder text for the
           * `DraftEditor` component.
           *
           * Override placeholder style via CSS.
           */
          var DraftEditorPlaceholder = /*#__PURE__*/function (_React$Component) {
            _inheritsLoose(DraftEditorPlaceholder, _React$Component);
            function DraftEditorPlaceholder() {
              return _React$Component.apply(this, arguments) || this;
            }
            var _proto = DraftEditorPlaceholder.prototype;
            _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
              return this.props.text !== nextProps.text || this.props.editorState.getSelection().getHasFocus() !== nextProps.editorState.getSelection().getHasFocus();
            };
            _proto.render = function render() {
              var hasFocus = this.props.editorState.getSelection().getHasFocus();
              var className = cx({
                'public/DraftEditorPlaceholder/root': true,
                'public/DraftEditorPlaceholder/hasFocus': hasFocus
              });
              var contentStyle = {
                whiteSpace: 'pre-wrap'
              };
              return React.createElement("div", {
                className: className
              }, React.createElement("div", {
                className: cx('public/DraftEditorPlaceholder/inner'),
                id: this.props.accessibilityID,
                style: contentStyle
              }, this.props.text));
            };
            return DraftEditorPlaceholder;
          }(React.Component);
          DraftEditorPlaceholder_react = DraftEditorPlaceholder;
          return DraftEditorPlaceholder_react;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var getDefaultKeyBinding_1;
        var hasRequiredGetDefaultKeyBinding;
        function requireGetDefaultKeyBinding() {
          if (hasRequiredGetDefaultKeyBinding) return getDefaultKeyBinding_1;
          hasRequiredGetDefaultKeyBinding = 1;
          var KeyBindingUtil = requireKeyBindingUtil();
          var Keys = requireKeys();
          var UserAgent = requireUserAgent();
          var isOSX = UserAgent.isPlatform('Mac OS X'); // Firefox on OSX had a bug resulting in navigation instead of cursor movement.
          // This bug was fixed in Firefox 29. Feature detection is virtually impossible
          // so we just check the version number. See #342765.

          var shouldFixFirefoxMovement = isOSX && UserAgent.isBrowser('Firefox < 29');
          var hasCommandModifier = KeyBindingUtil.hasCommandModifier,
            isCtrlKeyCommand = KeyBindingUtil.isCtrlKeyCommand;
          function shouldRemoveWord(e) {
            return isOSX && e.altKey || isCtrlKeyCommand(e);
          }
          /**
           * Get the appropriate undo/redo command for a Z key command.
           */

          function getZCommand(e) {
            if (!hasCommandModifier(e)) {
              return null;
            }
            return e.shiftKey ? 'redo' : 'undo';
          }
          function getDeleteCommand(e) {
            // Allow default "cut" behavior for PCs on Shift + Delete.
            if (!isOSX && e.shiftKey) {
              return null;
            }
            return shouldRemoveWord(e) ? 'delete-word' : 'delete';
          }
          function getBackspaceCommand(e) {
            if (hasCommandModifier(e) && isOSX) {
              return 'backspace-to-start-of-line';
            }
            return shouldRemoveWord(e) ? 'backspace-word' : 'backspace';
          }
          /**
           * Retrieve a bound key command for the given event.
           */

          function getDefaultKeyBinding(e) {
            switch (e.keyCode) {
              case 66:
                // B
                return hasCommandModifier(e) ? 'bold' : null;
              case 68:
                // D
                return isCtrlKeyCommand(e) ? 'delete' : null;
              case 72:
                // H
                return isCtrlKeyCommand(e) ? 'backspace' : null;
              case 73:
                // I
                return hasCommandModifier(e) ? 'italic' : null;
              case 74:
                // J
                return hasCommandModifier(e) ? 'code' : null;
              case 75:
                // K
                return isOSX && isCtrlKeyCommand(e) ? 'secondary-cut' : null;
              case 77:
                // M
                return isCtrlKeyCommand(e) ? 'split-block' : null;
              case 79:
                // O
                return isCtrlKeyCommand(e) ? 'split-block' : null;
              case 84:
                // T
                return isOSX && isCtrlKeyCommand(e) ? 'transpose-characters' : null;
              case 85:
                // U
                return hasCommandModifier(e) ? 'underline' : null;
              case 87:
                // W
                return isOSX && isCtrlKeyCommand(e) ? 'backspace-word' : null;
              case 89:
                // Y
                if (isCtrlKeyCommand(e)) {
                  return isOSX ? 'secondary-paste' : 'redo';
                }
                return null;
              case 90:
                // Z
                return getZCommand(e) || null;
              case Keys.RETURN:
                return 'split-block';
              case Keys.DELETE:
                return getDeleteCommand(e);
              case Keys.BACKSPACE:
                return getBackspaceCommand(e);
              // LEFT/RIGHT handlers serve as a workaround for a Firefox bug.

              case Keys.LEFT:
                return shouldFixFirefoxMovement && hasCommandModifier(e) ? 'move-selection-to-start-of-block' : null;
              case Keys.RIGHT:
                return shouldFixFirefoxMovement && hasCommandModifier(e) ? 'move-selection-to-end-of-block' : null;
              default:
                return null;
            }
          }
          getDefaultKeyBinding_1 = getDefaultKeyBinding;
          return getDefaultKeyBinding_1;
        }
        var DraftEditor_react;
        var hasRequiredDraftEditor_react;
        function requireDraftEditor_react() {
          if (hasRequiredDraftEditor_react) return DraftEditor_react;
          hasRequiredDraftEditor_react = 1;
          var _assign = requireObjectAssign();
          function _extends() {
            _extends = _assign || function (target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            return _extends.apply(this, arguments);
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === "function") {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var DefaultDraftBlockRenderMap = requireDefaultDraftBlockRenderMap();
          var DefaultDraftInlineStyle = requireDefaultDraftInlineStyle();
          var DraftEditorCompositionHandler = requireDraftEditorCompositionHandler();
          var DraftEditorContents = requireDraftEditorContents_react();
          var DraftEditorDragHandler = requireDraftEditorDragHandler();
          var DraftEditorEditHandler = requireDraftEditorEditHandler();
          var flushControlled = requireDraftEditorFlushControlled();
          var DraftEditorPlaceholder = requireDraftEditorPlaceholder_react();
          var DraftEffects = requireDraftEffects();
          var EditorState = requireEditorState();
          var React = requireReact();
          var Scroll = requireScroll();
          var Style = requireStyle();
          var UserAgent = requireUserAgent();
          var cx = requireCx();
          var generateRandomKey = requireGenerateRandomKey();
          var getDefaultKeyBinding = requireGetDefaultKeyBinding();
          var getScrollPosition = requireGetScrollPosition();
          var gkx = requireGkx();
          var invariant = requireInvariant();
          var isHTMLElement = requireIsHTMLElement();
          var nullthrows = requireNullthrows();
          var isIE = UserAgent.isBrowser("IE");
          var allowSpellCheck = !isIE;
          var handlerMap = {
            edit: DraftEditorEditHandler,
            composite: DraftEditorCompositionHandler,
            drag: DraftEditorDragHandler,
            cut: null,
            render: null
          };
          var didInitODS = false;
          var UpdateDraftEditorFlags = /* @__PURE__ */function (_React$Component) {
            _inheritsLoose(UpdateDraftEditorFlags2, _React$Component);
            function UpdateDraftEditorFlags2() {
              return _React$Component.apply(this, arguments) || this;
            }
            var _proto = UpdateDraftEditorFlags2.prototype;
            _proto.render = function render() {
              return null;
            };
            _proto.componentDidMount = function componentDidMount() {
              this._update();
            };
            _proto.componentDidUpdate = function componentDidUpdate() {
              this._update();
            };
            _proto._update = function _update() {
              var editor = this.props.editor;
              editor._latestEditorState = this.props.editorState;
              editor._blockSelectEvents = true;
            };
            return UpdateDraftEditorFlags2;
          }(React.Component);
          var DraftEditor = /* @__PURE__ */function (_React$Component2) {
            _inheritsLoose(DraftEditor2, _React$Component2);
            function DraftEditor2(props) {
              var _this;
              _this = _React$Component2.call(this, props) || this;
              _defineProperty(_assertThisInitialized(_this), "_blockSelectEvents", void 0);
              _defineProperty(_assertThisInitialized(_this), "_clipboard", void 0);
              _defineProperty(_assertThisInitialized(_this), "_handler", void 0);
              _defineProperty(_assertThisInitialized(_this), "_dragCount", void 0);
              _defineProperty(_assertThisInitialized(_this), "_internalDrag", void 0);
              _defineProperty(_assertThisInitialized(_this), "_editorKey", void 0);
              _defineProperty(_assertThisInitialized(_this), "_placeholderAccessibilityID", void 0);
              _defineProperty(_assertThisInitialized(_this), "_latestEditorState", void 0);
              _defineProperty(_assertThisInitialized(_this), "_latestCommittedEditorState", void 0);
              _defineProperty(_assertThisInitialized(_this), "_pendingStateFromBeforeInput", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onBeforeInput", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onBlur", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onCharacterData", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onCompositionEnd", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onCompositionStart", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onCopy", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onCut", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onDragEnd", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onDragOver", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onDragStart", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onDrop", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onInput", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onFocus", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onKeyDown", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onKeyPress", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onKeyUp", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onMouseDown", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onMouseUp", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onPaste", void 0);
              _defineProperty(_assertThisInitialized(_this), "_onSelect", void 0);
              _defineProperty(_assertThisInitialized(_this), "editor", void 0);
              _defineProperty(_assertThisInitialized(_this), "editorContainer", void 0);
              _defineProperty(_assertThisInitialized(_this), "focus", void 0);
              _defineProperty(_assertThisInitialized(_this), "blur", void 0);
              _defineProperty(_assertThisInitialized(_this), "setMode", void 0);
              _defineProperty(_assertThisInitialized(_this), "exitCurrentMode", void 0);
              _defineProperty(_assertThisInitialized(_this), "restoreEditorDOM", void 0);
              _defineProperty(_assertThisInitialized(_this), "setClipboard", void 0);
              _defineProperty(_assertThisInitialized(_this), "getClipboard", void 0);
              _defineProperty(_assertThisInitialized(_this), "getEditorKey", void 0);
              _defineProperty(_assertThisInitialized(_this), "update", void 0);
              _defineProperty(_assertThisInitialized(_this), "onDragEnter", void 0);
              _defineProperty(_assertThisInitialized(_this), "onDragLeave", void 0);
              _defineProperty(_assertThisInitialized(_this), "_handleEditorContainerRef", function (node) {
                _this.editorContainer = node;
                _this.editor = node !== null ? node.firstChild : null;
              });
              _defineProperty(_assertThisInitialized(_this), "focus", function (scrollPosition) {
                var editorState = _this.props.editorState;
                var alreadyHasFocus = editorState.getSelection().getHasFocus();
                var editorNode = _this.editor;
                if (!editorNode) {
                  return;
                }
                var scrollParent = Style.getScrollParent(editorNode);
                var _ref = scrollPosition || getScrollPosition(scrollParent),
                  x = _ref.x,
                  y = _ref.y;
                !isHTMLElement(editorNode) ? invariant(false) : void 0;
                editorNode.focus();
                if (scrollParent === window) {
                  window.scrollTo(x, y);
                } else {
                  Scroll.setTop(scrollParent, y);
                }
                if (!alreadyHasFocus) {
                  _this.update(EditorState.forceSelection(editorState, editorState.getSelection()));
                }
              });
              _defineProperty(_assertThisInitialized(_this), "blur", function () {
                var editorNode = _this.editor;
                if (!editorNode) {
                  return;
                }
                !isHTMLElement(editorNode) ? invariant(false) : void 0;
                editorNode.blur();
              });
              _defineProperty(_assertThisInitialized(_this), "setMode", function (mode) {
                var _this$props = _this.props,
                  onPaste = _this$props.onPaste,
                  onCut = _this$props.onCut,
                  onCopy = _this$props.onCopy;
                var editHandler = _objectSpread({}, handlerMap.edit);
                if (onPaste) {
                  editHandler.onPaste = onPaste;
                }
                if (onCut) {
                  editHandler.onCut = onCut;
                }
                if (onCopy) {
                  editHandler.onCopy = onCopy;
                }
                var handler = _objectSpread({}, handlerMap, {
                  edit: editHandler
                });
                _this._handler = handler[mode];
              });
              _defineProperty(_assertThisInitialized(_this), "exitCurrentMode", function () {
                _this.setMode("edit");
              });
              _defineProperty(_assertThisInitialized(_this), "restoreEditorDOM", function (scrollPosition) {
                _this.setState({
                  contentsKey: _this.state.contentsKey + 1
                }, function () {
                  _this.focus(scrollPosition);
                });
              });
              _defineProperty(_assertThisInitialized(_this), "setClipboard", function (clipboard) {
                _this._clipboard = clipboard;
              });
              _defineProperty(_assertThisInitialized(_this), "getClipboard", function () {
                return _this._clipboard;
              });
              _defineProperty(_assertThisInitialized(_this), "update", function (editorState) {
                _this._latestEditorState = editorState;
                _this.props.onChange(editorState);
              });
              _defineProperty(_assertThisInitialized(_this), "onDragEnter", function () {
                _this._dragCount++;
              });
              _defineProperty(_assertThisInitialized(_this), "onDragLeave", function () {
                _this._dragCount--;
                if (_this._dragCount === 0) {
                  _this.exitCurrentMode();
                }
              });
              _this._blockSelectEvents = false;
              _this._clipboard = null;
              _this._handler = null;
              _this._dragCount = 0;
              _this._editorKey = props.editorKey || generateRandomKey();
              _this._placeholderAccessibilityID = "placeholder-" + _this._editorKey;
              _this._latestEditorState = props.editorState;
              _this._latestCommittedEditorState = props.editorState;
              _this._onBeforeInput = _this._buildHandler("onBeforeInput");
              _this._onBlur = _this._buildHandler("onBlur");
              _this._onCharacterData = _this._buildHandler("onCharacterData");
              _this._onCompositionEnd = _this._buildHandler("onCompositionEnd");
              _this._onCompositionStart = _this._buildHandler("onCompositionStart");
              _this._onCopy = _this._buildHandler("onCopy");
              _this._onCut = _this._buildHandler("onCut");
              _this._onDragEnd = _this._buildHandler("onDragEnd");
              _this._onDragOver = _this._buildHandler("onDragOver");
              _this._onDragStart = _this._buildHandler("onDragStart");
              _this._onDrop = _this._buildHandler("onDrop");
              _this._onInput = _this._buildHandler("onInput");
              _this._onFocus = _this._buildHandler("onFocus");
              _this._onKeyDown = _this._buildHandler("onKeyDown");
              _this._onKeyPress = _this._buildHandler("onKeyPress");
              _this._onKeyUp = _this._buildHandler("onKeyUp");
              _this._onMouseDown = _this._buildHandler("onMouseDown");
              _this._onMouseUp = _this._buildHandler("onMouseUp");
              _this._onPaste = _this._buildHandler("onPaste");
              _this._onSelect = _this._buildHandler("onSelect");
              _this.getEditorKey = function () {
                return _this._editorKey;
              };
              _this.state = {
                contentsKey: 0
              };
              return _this;
            }
            var _proto2 = DraftEditor2.prototype;
            _proto2._buildHandler = function _buildHandler(eventName) {
              var _this2 = this;
              return function (e) {
                if (!_this2.props.readOnly) {
                  var method = _this2._handler && _this2._handler[eventName];
                  if (method) {
                    if (flushControlled) {
                      flushControlled(function () {
                        return method(_this2, e);
                      });
                    } else {
                      method(_this2, e);
                    }
                  }
                }
              };
            };
            _proto2._showPlaceholder = function _showPlaceholder() {
              return !!this.props.placeholder && !this.props.editorState.isInCompositionMode() && !this.props.editorState.getCurrentContent().hasText();
            };
            _proto2._renderPlaceholder = function _renderPlaceholder() {
              if (this._showPlaceholder()) {
                var placeHolderProps = {
                  text: nullthrows(this.props.placeholder),
                  editorState: this.props.editorState,
                  textAlignment: this.props.textAlignment,
                  accessibilityID: this._placeholderAccessibilityID
                };
                return React.createElement(DraftEditorPlaceholder, placeHolderProps);
              }
              return null;
            };
            _proto2._renderARIADescribedBy = function _renderARIADescribedBy() {
              var describedBy = this.props.ariaDescribedBy || "";
              var placeholderID = this._showPlaceholder() ? this._placeholderAccessibilityID : "";
              return describedBy.replace("{{editor_id_placeholder}}", placeholderID) || void 0;
            };
            _proto2.render = function render() {
              var _this$props2 = this.props,
                blockRenderMap = _this$props2.blockRenderMap,
                blockRendererFn2 = _this$props2.blockRendererFn,
                blockStyleFn2 = _this$props2.blockStyleFn,
                customStyleFn = _this$props2.customStyleFn,
                customStyleMap = _this$props2.customStyleMap,
                editorState = _this$props2.editorState,
                preventScroll = _this$props2.preventScroll,
                readOnly = _this$props2.readOnly,
                textAlignment = _this$props2.textAlignment,
                textDirectionality = _this$props2.textDirectionality;
              var rootClass = cx({
                "DraftEditor/root": true,
                "DraftEditor/alignLeft": textAlignment === "left",
                "DraftEditor/alignRight": textAlignment === "right",
                "DraftEditor/alignCenter": textAlignment === "center"
              });
              var contentStyle = {
                outline: "none",
                // fix parent-draggable Safari bug. #1326
                userSelect: "text",
                WebkitUserSelect: "text",
                whiteSpace: "pre-wrap",
                wordWrap: "break-word"
              };
              var ariaRole = this.props.role || "textbox";
              var ariaExpanded = ariaRole === "combobox" ? !!this.props.ariaExpanded : null;
              var editorContentsProps = {
                blockRenderMap,
                blockRendererFn: blockRendererFn2,
                blockStyleFn: blockStyleFn2,
                customStyleMap: _objectSpread({}, DefaultDraftInlineStyle, customStyleMap),
                customStyleFn,
                editorKey: this._editorKey,
                editorState,
                preventScroll,
                textDirectionality
              };
              return React.createElement("div", {
                className: rootClass
              }, this._renderPlaceholder(), React.createElement("div", {
                className: cx("DraftEditor/editorContainer"),
                ref: this._handleEditorContainerRef
              }, React.createElement("div", {
                "aria-activedescendant": readOnly ? null : this.props.ariaActiveDescendantID,
                "aria-autocomplete": readOnly ? null : this.props.ariaAutoComplete,
                "aria-controls": readOnly ? null : this.props.ariaControls,
                "aria-describedby": this._renderARIADescribedBy(),
                "aria-expanded": readOnly ? null : ariaExpanded,
                "aria-label": this.props.ariaLabel,
                "aria-labelledby": this.props.ariaLabelledBy,
                "aria-multiline": this.props.ariaMultiline,
                "aria-owns": readOnly ? null : this.props.ariaOwneeID,
                autoCapitalize: this.props.autoCapitalize,
                autoComplete: this.props.autoComplete,
                autoCorrect: this.props.autoCorrect,
                className: cx({
                  // Chrome's built-in translation feature mutates the DOM in ways
                  // that Draft doesn't expect (ex: adding <font> tags inside
                  // DraftEditorLeaf spans) and causes problems. We add notranslate
                  // here which makes its autotranslation skip over this subtree.
                  notranslate: !readOnly,
                  "public/DraftEditor/content": true
                }),
                contentEditable: !readOnly,
                "data-testid": this.props.webDriverTestID,
                onBeforeInput: this._onBeforeInput,
                onBlur: this._onBlur,
                onCompositionEnd: this._onCompositionEnd,
                onCompositionStart: this._onCompositionStart,
                onCopy: this._onCopy,
                onCut: this._onCut,
                onDragEnd: this._onDragEnd,
                onDragEnter: this.onDragEnter,
                onDragLeave: this.onDragLeave,
                onDragOver: this._onDragOver,
                onDragStart: this._onDragStart,
                onDrop: this._onDrop,
                onFocus: this._onFocus,
                onInput: this._onInput,
                onKeyDown: this._onKeyDown,
                onKeyPress: this._onKeyPress,
                onKeyUp: this._onKeyUp,
                onMouseUp: this._onMouseUp,
                onPaste: this._onPaste,
                onSelect: this._onSelect,
                ref: this.props.editorRef,
                role: readOnly ? null : ariaRole,
                spellCheck: allowSpellCheck && this.props.spellCheck,
                style: contentStyle,
                suppressContentEditableWarning: true,
                tabIndex: this.props.tabIndex
              }, React.createElement(UpdateDraftEditorFlags, {
                editor: this,
                editorState
              }), React.createElement(DraftEditorContents, _extends({}, editorContentsProps, {
                key: "contents" + this.state.contentsKey
              })))));
            };
            _proto2.componentDidMount = function componentDidMount() {
              this._blockSelectEvents = false;
              if (!didInitODS && gkx("draft_ods_enabled")) {
                didInitODS = true;
                DraftEffects.initODS();
              }
              this.setMode("edit");
              if (isIE) {
                if (!this.editor) {
                  globalThis.execCommand("AutoUrlDetect", false, false);
                } else {
                  this.editor.ownerDocument.execCommand("AutoUrlDetect", false, false);
                }
              }
            };
            _proto2.componentDidUpdate = function componentDidUpdate() {
              this._blockSelectEvents = false;
              this._latestEditorState = this.props.editorState;
              this._latestCommittedEditorState = this.props.editorState;
            };
            return DraftEditor2;
          }(React.Component);
          _defineProperty(DraftEditor, "defaultProps", {
            ariaDescribedBy: "{{editor_id_placeholder}}",
            blockRenderMap: DefaultDraftBlockRenderMap,
            blockRendererFn: function blockRendererFn() {
              return null;
            },
            blockStyleFn: function blockStyleFn() {
              return "";
            },
            keyBindingFn: getDefaultKeyBinding,
            readOnly: false,
            spellCheck: false,
            stripPastedStyles: false
          });
          DraftEditor_react = DraftEditor;
          return DraftEditor_react;
        }
        var RawDraftContentState = {};

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var hasRequiredRawDraftContentState;
        function requireRawDraftContentState() {
          if (hasRequiredRawDraftContentState) return RawDraftContentState;
          hasRequiredRawDraftContentState = 1;
          return RawDraftContentState;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var DraftStringKey_1;
        var hasRequiredDraftStringKey;
        function requireDraftStringKey() {
          if (hasRequiredDraftStringKey) return DraftStringKey_1;
          hasRequiredDraftStringKey = 1;
          var DraftStringKey = {
            stringify: function stringify(key) {
              return '_' + String(key);
            },
            unstringify: function unstringify(key) {
              return key.slice(1);
            }
          };
          DraftStringKey_1 = DraftStringKey;
          return DraftStringKey_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var encodeEntityRanges_1;
        var hasRequiredEncodeEntityRanges;
        function requireEncodeEntityRanges() {
          if (hasRequiredEncodeEntityRanges) return encodeEntityRanges_1;
          hasRequiredEncodeEntityRanges = 1;
          var DraftStringKey = requireDraftStringKey();
          var UnicodeUtils = requireUnicodeUtils();
          var strlen = UnicodeUtils.strlen;
          /**
           * Convert to UTF-8 character counts for storage.
           */

          function encodeEntityRanges(block, storageMap) {
            var encoded = [];
            block.findEntityRanges(function (character) {
              return !!character.getEntity();
            }, function (/*number*/
            start, /*number*/
            end) {
              var text = block.getText();
              var key = block.getEntityAt(start);
              encoded.push({
                offset: strlen(text.slice(0, start)),
                length: strlen(text.slice(start, end)),
                // Encode the key as a number for range storage.
                key: Number(storageMap[DraftStringKey.stringify(key)])
              });
            });
            return encoded;
          }
          encodeEntityRanges_1 = encodeEntityRanges;
          return encodeEntityRanges_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var encodeInlineStyleRanges_1;
        var hasRequiredEncodeInlineStyleRanges;
        function requireEncodeInlineStyleRanges() {
          if (hasRequiredEncodeInlineStyleRanges) return encodeInlineStyleRanges_1;
          hasRequiredEncodeInlineStyleRanges = 1;
          var UnicodeUtils = requireUnicodeUtils();
          var findRangesImmutable = requireFindRangesImmutable();
          var areEqual = function areEqual(a, b) {
            return a === b;
          };
          var isTruthy = function isTruthy(a) {
            return !!a;
          };
          var EMPTY_ARRAY = [];
          /**
           * Helper function for getting encoded styles for each inline style. Convert
           * to UTF-8 character counts for storage.
           */

          function getEncodedInlinesForType(block, styleList, styleToEncode) {
            var ranges = []; // Obtain an array with ranges for only the specified style.

            var filteredInlines = styleList.map(function (style) {
              return style.has(styleToEncode);
            }).toList();
            findRangesImmutable(filteredInlines, areEqual,
            // We only want to keep ranges with nonzero style values.
            isTruthy, function (start, end) {
              var text = block.getText();
              ranges.push({
                offset: UnicodeUtils.strlen(text.slice(0, start)),
                length: UnicodeUtils.strlen(text.slice(start, end)),
                style: styleToEncode
              });
            });
            return ranges;
          }
          /*
           * Retrieve the encoded arrays of inline styles, with each individual style
           * treated separately.
           */

          function encodeInlineStyleRanges(block) {
            var styleList = block.getCharacterList().map(function (c) {
              return c.getStyle();
            }).toList();
            var ranges = styleList.flatten().toSet().map(function (style) {
              return getEncodedInlinesForType(block, styleList, style);
            });
            return Array.prototype.concat.apply(EMPTY_ARRAY, ranges.toJS());
          }
          encodeInlineStyleRanges_1 = encodeInlineStyleRanges;
          return encodeInlineStyleRanges_1;
        }
        var convertFromDraftStateToRaw_1;
        var hasRequiredConvertFromDraftStateToRaw;
        function requireConvertFromDraftStateToRaw() {
          if (hasRequiredConvertFromDraftStateToRaw) return convertFromDraftStateToRaw_1;
          hasRequiredConvertFromDraftStateToRaw = 1;
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === "function") {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var ContentBlock = requireContentBlock();
          var ContentBlockNode = requireContentBlockNode();
          var DraftStringKey = requireDraftStringKey();
          var encodeEntityRanges = requireEncodeEntityRanges();
          var encodeInlineStyleRanges = requireEncodeInlineStyleRanges();
          var invariant = requireInvariant();
          var createRawBlock = function createRawBlock2(block, entityStorageMap) {
            return {
              key: block.getKey(),
              text: block.getText(),
              type: block.getType(),
              depth: block.getDepth(),
              inlineStyleRanges: encodeInlineStyleRanges(block),
              entityRanges: encodeEntityRanges(block, entityStorageMap),
              data: block.getData().toObject()
            };
          };
          var insertRawBlock = function insertRawBlock2(block, entityMap, rawBlocks, blockCacheRef) {
            if (block instanceof ContentBlock) {
              rawBlocks.push(createRawBlock(block, entityMap));
              return;
            }
            !(block instanceof ContentBlockNode) ? invariant(false) : void 0;
            var parentKey = block.getParentKey();
            var rawBlock = blockCacheRef[block.getKey()] = _objectSpread({}, createRawBlock(block, entityMap), {
              children: []
            });
            if (parentKey) {
              blockCacheRef[parentKey].children.push(rawBlock);
              return;
            }
            rawBlocks.push(rawBlock);
          };
          var encodeRawBlocks = function encodeRawBlocks2(contentState, rawState) {
            var entityMap = rawState.entityMap;
            var rawBlocks = [];
            var blockCacheRef = {};
            var entityCacheRef = {};
            var entityStorageKey = 0;
            contentState.getBlockMap().forEach(function (block) {
              block.findEntityRanges(function (character) {
                return character.getEntity() !== null;
              }, function (start) {
                var entityKey = block.getEntityAt(start);
                var stringifiedEntityKey = DraftStringKey.stringify(entityKey);
                if (entityCacheRef[stringifiedEntityKey]) {
                  return;
                }
                entityCacheRef[stringifiedEntityKey] = entityKey;
                entityMap[stringifiedEntityKey] = "".concat(entityStorageKey);
                entityStorageKey++;
              });
              insertRawBlock(block, entityMap, rawBlocks, blockCacheRef);
            });
            return {
              blocks: rawBlocks,
              entityMap
            };
          };
          var encodeRawEntityMap = function encodeRawEntityMap2(contentState, rawState) {
            var blocks = rawState.blocks,
              entityMap = rawState.entityMap;
            var rawEntityMap = {};
            Object.keys(entityMap).forEach(function (key, index) {
              var entity = contentState.getEntity(DraftStringKey.unstringify(key));
              rawEntityMap[index] = {
                type: entity.getType(),
                mutability: entity.getMutability(),
                data: entity.getData()
              };
            });
            return {
              blocks,
              entityMap: rawEntityMap
            };
          };
          var convertFromDraftStateToRaw = function convertFromDraftStateToRaw2(contentState) {
            var rawDraftContentState = {
              entityMap: {},
              blocks: []
            };
            rawDraftContentState = encodeRawBlocks(contentState, rawDraftContentState);
            rawDraftContentState = encodeRawEntityMap(contentState, rawDraftContentState);
            return rawDraftContentState;
          };
          convertFromDraftStateToRaw_1 = convertFromDraftStateToRaw;
          return convertFromDraftStateToRaw_1;
        }
        var DraftTreeAdapter_1;
        var hasRequiredDraftTreeAdapter;
        function requireDraftTreeAdapter() {
          if (hasRequiredDraftTreeAdapter) return DraftTreeAdapter_1;
          hasRequiredDraftTreeAdapter = 1;
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === "function") {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var generateRandomKey = requireGenerateRandomKey();
          var invariant = requireInvariant();
          var traverseInDepthOrder = function traverseInDepthOrder2(blocks, fn) {
            var stack = [].concat(blocks).reverse();
            while (stack.length) {
              var _block = stack.pop();
              fn(_block);
              var children = _block.children;
              !Array.isArray(children) ? invariant(false) : void 0;
              stack = stack.concat([].concat(children.reverse()));
            }
          };
          var isListBlock = function isListBlock2(block) {
            if (!(block && block.type)) {
              return false;
            }
            var type = block.type;
            return type === "unordered-list-item" || type === "ordered-list-item";
          };
          var addDepthToChildren = function addDepthToChildren2(block) {
            if (Array.isArray(block.children)) {
              block.children = block.children.map(function (child) {
                return child.type === block.type ? _objectSpread({}, child, {
                  depth: (block.depth || 0) + 1
                }) : child;
              });
            }
          };
          var DraftTreeAdapter = {
            /**
             * Converts from a tree raw state back to draft raw state
             */
            fromRawTreeStateToRawState: function fromRawTreeStateToRawState(draftTreeState) {
              var blocks = draftTreeState.blocks;
              var transformedBlocks = [];
              !Array.isArray(blocks) ? invariant(false) : void 0;
              if (!Array.isArray(blocks) || !blocks.length) {
                return draftTreeState;
              }
              traverseInDepthOrder(blocks, function (block) {
                var newBlock = _objectSpread({}, block);
                if (isListBlock(block)) {
                  newBlock.depth = newBlock.depth || 0;
                  addDepthToChildren(block);
                  if (block.children != null && block.children.length > 0) {
                    return;
                  }
                }
                delete newBlock.children;
                transformedBlocks.push(newBlock);
              });
              draftTreeState.blocks = transformedBlocks;
              return _objectSpread({}, draftTreeState, {
                blocks: transformedBlocks
              });
            },
            /**
             * Converts from draft raw state to tree draft state
             */
            fromRawStateToRawTreeState: function fromRawStateToRawTreeState(draftState) {
              var transformedBlocks = [];
              var parentStack = [];
              draftState.blocks.forEach(function (block) {
                var isList = isListBlock(block);
                var depth = block.depth || 0;
                var treeBlock = _objectSpread({}, block, {
                  children: []
                });
                if (!isList) {
                  transformedBlocks.push(treeBlock);
                  return;
                }
                var lastParent = parentStack[0];
                if (lastParent == null && depth === 0) {
                  transformedBlocks.push(treeBlock);
                } else if (lastParent == null || lastParent.depth < depth - 1) {
                  var newParent = {
                    key: generateRandomKey(),
                    text: "",
                    depth: depth - 1,
                    type: block.type,
                    children: [],
                    entityRanges: [],
                    inlineStyleRanges: []
                  };
                  parentStack.unshift(newParent);
                  if (depth === 1) {
                    transformedBlocks.push(newParent);
                  } else if (lastParent != null) {
                    lastParent.children.push(newParent);
                  }
                  newParent.children.push(treeBlock);
                } else if (lastParent.depth === depth - 1) {
                  lastParent.children.push(treeBlock);
                } else {
                  while (lastParent != null && lastParent.depth >= depth) {
                    parentStack.shift();
                    lastParent = parentStack[0];
                  }
                  if (depth > 0) {
                    lastParent.children.push(treeBlock);
                  } else {
                    transformedBlocks.push(treeBlock);
                  }
                }
              });
              return _objectSpread({}, draftState, {
                blocks: transformedBlocks
              });
            }
          };
          DraftTreeAdapter_1 = DraftTreeAdapter;
          return DraftTreeAdapter_1;
        }
        var DraftTreeInvariants_1;
        var hasRequiredDraftTreeInvariants;
        function requireDraftTreeInvariants() {
          if (hasRequiredDraftTreeInvariants) return DraftTreeInvariants_1;
          hasRequiredDraftTreeInvariants = 1;
          requireWarning();
          var DraftTreeInvariants = {
            /**
             * Check if the block is valid
             */
            isValidBlock: function isValidBlock(block, blockMap) {
              var key = block.getKey();
              var parentKey = block.getParentKey();
              if (parentKey != null) {
                var parent = blockMap.get(parentKey);
                if (!parent.getChildKeys().includes(key)) {
                  return false;
                }
              }
              var children = block.getChildKeys().map(function (k) {
                return blockMap.get(k);
              });
              if (!children.every(function (c) {
                return c.getParentKey() === key;
              })) {
                return false;
              }
              var prevSiblingKey = block.getPrevSiblingKey();
              if (prevSiblingKey != null) {
                var prevSibling = blockMap.get(prevSiblingKey);
                if (prevSibling.getNextSiblingKey() !== key) {
                  return false;
                }
              }
              var nextSiblingKey = block.getNextSiblingKey();
              if (nextSiblingKey != null) {
                var nextSibling = blockMap.get(nextSiblingKey);
                if (nextSibling.getPrevSiblingKey() !== key) {
                  return false;
                }
              }
              if (nextSiblingKey !== null && prevSiblingKey !== null) {
                if (prevSiblingKey === nextSiblingKey) {
                  return false;
                }
              }
              if (block.text != "") {
                if (block.getChildKeys().size > 0) {
                  return false;
                }
              }
              return true;
            },
            /**
             * Checks that this is a connected tree on all the blocks
             * starting from the first block, traversing nextSibling and child pointers
             * should be a tree (preorder traversal - parent, then children)
             * num of connected node === number of blocks
             */
            isConnectedTree: function isConnectedTree(blockMap) {
              var eligibleFirstNodes = blockMap.toArray().filter(function (block) {
                return block.getParentKey() == null && block.getPrevSiblingKey() == null;
              });
              if (eligibleFirstNodes.length !== 1) {
                return false;
              }
              var firstNode = eligibleFirstNodes.shift();
              var nodesSeen = 0;
              var currentKey = firstNode.getKey();
              var visitedStack = [];
              while (currentKey != null) {
                var currentNode = blockMap.get(currentKey);
                var childKeys = currentNode.getChildKeys();
                var nextSiblingKey = currentNode.getNextSiblingKey();
                if (childKeys.size > 0) {
                  if (nextSiblingKey != null) {
                    visitedStack.unshift(nextSiblingKey);
                  }
                  var children = childKeys.map(function (k) {
                    return blockMap.get(k);
                  });
                  var _firstNode = children.find(function (block) {
                    return block.getPrevSiblingKey() == null;
                  });
                  if (_firstNode == null) {
                    return false;
                  }
                  currentKey = _firstNode.getKey();
                } else {
                  if (currentNode.getNextSiblingKey() != null) {
                    currentKey = currentNode.getNextSiblingKey();
                  } else {
                    currentKey = visitedStack.shift();
                  }
                }
                nodesSeen++;
              }
              if (nodesSeen !== blockMap.size) {
                return false;
              }
              return true;
            },
            /**
             * Checks that the block map is a connected tree with valid blocks
             */
            isValidTree: function isValidTree(blockMap) {
              var _this = this;
              var blocks = blockMap.toArray();
              if (!blocks.every(function (block) {
                return _this.isValidBlock(block, blockMap);
              })) {
                return false;
              }
              return this.isConnectedTree(blockMap);
            }
          };
          DraftTreeInvariants_1 = DraftTreeInvariants;
          return DraftTreeInvariants_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var createCharacterList_1;
        var hasRequiredCreateCharacterList;
        function requireCreateCharacterList() {
          if (hasRequiredCreateCharacterList) return createCharacterList_1;
          hasRequiredCreateCharacterList = 1;
          var CharacterMetadata = requireCharacterMetadata();
          var Immutable = requireImmutable();
          var List = Immutable.List;
          function createCharacterList(inlineStyles, entities) {
            var characterArray = inlineStyles.map(function (style, ii) {
              var entity = entities[ii];
              return CharacterMetadata.create({
                style: style,
                entity: entity
              });
            });
            return List(characterArray);
          }
          createCharacterList_1 = createCharacterList;
          return createCharacterList_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var decodeEntityRanges_1;
        var hasRequiredDecodeEntityRanges;
        function requireDecodeEntityRanges() {
          if (hasRequiredDecodeEntityRanges) return decodeEntityRanges_1;
          hasRequiredDecodeEntityRanges = 1;
          var UnicodeUtils = requireUnicodeUtils();
          var substr = UnicodeUtils.substr;
          /**
           * Convert to native JavaScript string lengths to determine ranges.
           */

          function decodeEntityRanges(text, ranges) {
            var entities = Array(text.length).fill(null);
            if (ranges) {
              ranges.forEach(function (range) {
                // Using Unicode-enabled substrings converted to JavaScript lengths,
                // fill the output array with entity keys.
                var start = substr(text, 0, range.offset).length;
                var end = start + substr(text, range.offset, range.length).length;
                for (var ii = start; ii < end; ii++) {
                  entities[ii] = range.key;
                }
              });
            }
            return entities;
          }
          decodeEntityRanges_1 = decodeEntityRanges;
          return decodeEntityRanges_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var decodeInlineStyleRanges_1;
        var hasRequiredDecodeInlineStyleRanges;
        function requireDecodeInlineStyleRanges() {
          if (hasRequiredDecodeInlineStyleRanges) return decodeInlineStyleRanges_1;
          hasRequiredDecodeInlineStyleRanges = 1;
          var UnicodeUtils = requireUnicodeUtils();
          var _require = requireImmutable(),
            OrderedSet = _require.OrderedSet;
          var substr = UnicodeUtils.substr;
          var EMPTY_SET = OrderedSet();
          /**
           * Convert to native JavaScript string lengths to determine ranges.
           */

          function decodeInlineStyleRanges(text, ranges) {
            var styles = Array(text.length).fill(EMPTY_SET);
            if (ranges) {
              ranges.forEach(function (range) {
                var cursor = substr(text, 0, range.offset).length;
                var end = cursor + substr(text, range.offset, range.length).length;
                while (cursor < end) {
                  styles[cursor] = styles[cursor].add(range.style);
                  cursor++;
                }
              });
            }
            return styles;
          }
          decodeInlineStyleRanges_1 = decodeInlineStyleRanges;
          return decodeInlineStyleRanges_1;
        }
        var convertFromRawToDraftState_1;
        var hasRequiredConvertFromRawToDraftState;
        function requireConvertFromRawToDraftState() {
          if (hasRequiredConvertFromRawToDraftState) return convertFromRawToDraftState_1;
          hasRequiredConvertFromRawToDraftState = 1;
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === "function") {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var ContentBlock = requireContentBlock();
          var ContentBlockNode = requireContentBlockNode();
          var ContentState = requireContentState();
          var DraftEntity = requireDraftEntity();
          var DraftTreeAdapter = requireDraftTreeAdapter();
          requireDraftTreeInvariants();
          var SelectionState = requireSelectionState();
          var createCharacterList = requireCreateCharacterList();
          var decodeEntityRanges = requireDecodeEntityRanges();
          var decodeInlineStyleRanges = requireDecodeInlineStyleRanges();
          var generateRandomKey = requireGenerateRandomKey();
          var gkx = requireGkx();
          var Immutable = requireImmutable();
          var invariant = requireInvariant();
          var experimentalTreeDataSupport = gkx("draft_tree_data_support");
          var List = Immutable.List,
            Map = Immutable.Map,
            OrderedMap = Immutable.OrderedMap;
          var decodeBlockNodeConfig = function decodeBlockNodeConfig2(block, entityMap) {
            var key = block.key,
              type = block.type,
              data = block.data,
              text = block.text,
              depth = block.depth;
            var blockNodeConfig = {
              text,
              depth: depth || 0,
              type: type || "unstyled",
              key: key || generateRandomKey(),
              data: Map(data),
              characterList: decodeCharacterList(block, entityMap)
            };
            return blockNodeConfig;
          };
          var decodeCharacterList = function decodeCharacterList2(block, entityMap) {
            var text = block.text,
              rawEntityRanges = block.entityRanges,
              rawInlineStyleRanges = block.inlineStyleRanges;
            var entityRanges = rawEntityRanges || [];
            var inlineStyleRanges = rawInlineStyleRanges || [];
            return createCharacterList(decodeInlineStyleRanges(text, inlineStyleRanges), decodeEntityRanges(text, entityRanges.filter(function (range) {
              return entityMap.hasOwnProperty(range.key);
            }).map(function (range) {
              return _objectSpread({}, range, {
                key: entityMap[range.key]
              });
            })));
          };
          var addKeyIfMissing = function addKeyIfMissing2(block) {
            return _objectSpread({}, block, {
              key: block.key || generateRandomKey()
            });
          };
          var updateNodeStack = function updateNodeStack2(stack, nodes, parentRef) {
            var nodesWithParentRef = nodes.map(function (block) {
              return _objectSpread({}, block, {
                parentRef
              });
            });
            return stack.concat(nodesWithParentRef.reverse());
          };
          var decodeContentBlockNodes = function decodeContentBlockNodes2(blocks, entityMap) {
            return blocks.map(addKeyIfMissing).reduce(function (blockMap, block, index) {
              !Array.isArray(block.children) ? invariant(false) : void 0;
              var children = block.children.map(addKeyIfMissing);
              var contentBlockNode = new ContentBlockNode(_objectSpread({}, decodeBlockNodeConfig(block, entityMap), {
                prevSibling: index === 0 ? null : blocks[index - 1].key,
                nextSibling: index === blocks.length - 1 ? null : blocks[index + 1].key,
                children: List(children.map(function (child) {
                  return child.key;
                }))
              }));
              blockMap = blockMap.set(contentBlockNode.getKey(), contentBlockNode);
              var stack = updateNodeStack([], children, contentBlockNode);
              while (stack.length > 0) {
                var node = stack.pop();
                var parentRef = node.parentRef;
                var siblings = parentRef.getChildKeys();
                var _index = siblings.indexOf(node.key);
                var isValidBlock = Array.isArray(node.children);
                if (!isValidBlock) {
                  !isValidBlock ? invariant(false) : void 0;
                  break;
                }
                var _children = node.children.map(addKeyIfMissing);
                var _contentBlockNode = new ContentBlockNode(_objectSpread({}, decodeBlockNodeConfig(node, entityMap), {
                  parent: parentRef.getKey(),
                  children: List(_children.map(function (child) {
                    return child.key;
                  })),
                  prevSibling: _index === 0 ? null : siblings.get(_index - 1),
                  nextSibling: _index === siblings.size - 1 ? null : siblings.get(_index + 1)
                }));
                blockMap = blockMap.set(_contentBlockNode.getKey(), _contentBlockNode);
                stack = updateNodeStack(stack, _children, _contentBlockNode);
              }
              return blockMap;
            }, OrderedMap());
          };
          var decodeContentBlocks = function decodeContentBlocks2(blocks, entityMap) {
            return OrderedMap(blocks.map(function (block) {
              var contentBlock = new ContentBlock(decodeBlockNodeConfig(block, entityMap));
              return [contentBlock.getKey(), contentBlock];
            }));
          };
          var decodeRawBlocks = function decodeRawBlocks2(rawState, entityMap) {
            var isTreeRawBlock = rawState.blocks.find(function (block) {
              return Array.isArray(block.children) && block.children.length > 0;
            });
            var rawBlocks = experimentalTreeDataSupport && !isTreeRawBlock ? DraftTreeAdapter.fromRawStateToRawTreeState(rawState).blocks : rawState.blocks;
            if (!experimentalTreeDataSupport) {
              return decodeContentBlocks(isTreeRawBlock ? DraftTreeAdapter.fromRawTreeStateToRawState(rawState).blocks : rawBlocks, entityMap);
            }
            var blockMap = decodeContentBlockNodes(rawBlocks, entityMap);
            return blockMap;
          };
          var decodeRawEntityMap = function decodeRawEntityMap2(rawState) {
            var rawEntityMap = rawState.entityMap;
            var entityMap = {};
            Object.keys(rawEntityMap).forEach(function (rawEntityKey) {
              var _rawEntityMap$rawEnti = rawEntityMap[rawEntityKey],
                type = _rawEntityMap$rawEnti.type,
                mutability = _rawEntityMap$rawEnti.mutability,
                data = _rawEntityMap$rawEnti.data;
              entityMap[rawEntityKey] = DraftEntity.__create(type, mutability, data || {});
            });
            return entityMap;
          };
          var convertFromRawToDraftState = function convertFromRawToDraftState2(rawState) {
            !Array.isArray(rawState.blocks) ? invariant(false) : void 0;
            var entityMap = decodeRawEntityMap(rawState);
            var blockMap = decodeRawBlocks(rawState, entityMap);
            var selectionState = blockMap.isEmpty() ? new SelectionState() : SelectionState.createEmpty(blockMap.first().getKey());
            return new ContentState({
              blockMap,
              entityMap,
              selectionBefore: selectionState,
              selectionAfter: selectionState
            });
          };
          convertFromRawToDraftState_1 = convertFromRawToDraftState;
          return convertFromRawToDraftState_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         * @emails oncall+draft_js
         */

        var getRangeBoundingClientRect_1;
        var hasRequiredGetRangeBoundingClientRect;
        function requireGetRangeBoundingClientRect() {
          if (hasRequiredGetRangeBoundingClientRect) return getRangeBoundingClientRect_1;
          hasRequiredGetRangeBoundingClientRect = 1;
          var getRangeClientRects = requireGetRangeClientRects();

          /**
           * Like range.getBoundingClientRect() but normalizes for browser bugs.
           */
          function getRangeBoundingClientRect(range) {
            // "Return a DOMRect object describing the smallest rectangle that includes
            // the first rectangle in list and all of the remaining rectangles of which
            // the height or width is not zero."
            // http://www.w3.org/TR/cssom-view/#dom-range-getboundingclientrect
            var rects = getRangeClientRects(range);
            var top = 0;
            var right = 0;
            var bottom = 0;
            var left = 0;
            if (rects.length) {
              // If the first rectangle has 0 width, we use the second, this is needed
              // because Chrome renders a 0 width rectangle when the selection contains
              // a line break.
              if (rects.length > 1 && rects[0].width === 0) {
                var _rects$ = rects[1];
                top = _rects$.top;
                right = _rects$.right;
                bottom = _rects$.bottom;
                left = _rects$.left;
              } else {
                var _rects$2 = rects[0];
                top = _rects$2.top;
                right = _rects$2.right;
                bottom = _rects$2.bottom;
                left = _rects$2.left;
              }
              for (var ii = 1; ii < rects.length; ii++) {
                var rect = rects[ii];
                if (rect.height !== 0 && rect.width !== 0) {
                  top = Math.min(top, rect.top);
                  right = Math.max(right, rect.right);
                  bottom = Math.max(bottom, rect.bottom);
                  left = Math.min(left, rect.left);
                }
              }
            }
            return {
              top: top,
              right: right,
              bottom: bottom,
              left: left,
              width: right - left,
              height: bottom - top
            };
          }
          getRangeBoundingClientRect_1 = getRangeBoundingClientRect;
          return getRangeBoundingClientRect_1;
        }
        var getVisibleSelectionRect_1;
        var hasRequiredGetVisibleSelectionRect;
        function requireGetVisibleSelectionRect() {
          if (hasRequiredGetVisibleSelectionRect) return getVisibleSelectionRect_1;
          hasRequiredGetVisibleSelectionRect = 1;
          var getRangeBoundingClientRect = requireGetRangeBoundingClientRect();
          function getVisibleSelectionRect(global) {
            var selection = global.getSelection();
            if (!selection.rangeCount) {
              return null;
            }
            var range = selection.getRangeAt(0);
            var boundingRect = getRangeBoundingClientRect(range);
            var top = boundingRect.top,
              right = boundingRect.right,
              bottom = boundingRect.bottom,
              left = boundingRect.left;
            if (top === 0 && right === 0 && bottom === 0 && left === 0) {
              return null;
            }
            return boundingRect;
          }
          getVisibleSelectionRect_1 = getVisibleSelectionRect;
          return getVisibleSelectionRect_1;
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @format
         * 
         */

        var Draft;
        var hasRequiredDraft;
        function requireDraft() {
          if (hasRequiredDraft) return Draft;
          hasRequiredDraft = 1;
          var AtomicBlockUtils = requireAtomicBlockUtils();
          var BlockMapBuilder = requireBlockMapBuilder();
          var CharacterMetadata = requireCharacterMetadata();
          var CompositeDraftDecorator = requireCompositeDraftDecorator();
          var ContentBlock = requireContentBlock();
          var ContentState = requireContentState();
          var DefaultDraftBlockRenderMap = requireDefaultDraftBlockRenderMap();
          var DefaultDraftInlineStyle = requireDefaultDraftInlineStyle();
          var DraftEditor = requireDraftEditor_react();
          var DraftEditorBlock = requireDraftEditorBlock_react();
          var DraftEntity = requireDraftEntity();
          var DraftModifier = requireDraftModifier();
          var DraftEntityInstance = requireDraftEntityInstance();
          var EditorState = requireEditorState();
          var KeyBindingUtil = requireKeyBindingUtil();
          var RawDraftContentState = requireRawDraftContentState();
          var RichTextEditorUtil = requireRichTextEditorUtil();
          var SelectionState = requireSelectionState();
          var convertFromDraftStateToRaw = requireConvertFromDraftStateToRaw();
          var convertFromRawToDraftState = requireConvertFromRawToDraftState();
          var generateRandomKey = requireGenerateRandomKey();
          var getDefaultKeyBinding = requireGetDefaultKeyBinding();
          var getVisibleSelectionRect = requireGetVisibleSelectionRect();
          var convertFromHTML = requireConvertFromHTMLToContentBlocks();
          var DraftPublic = {
            Editor: DraftEditor,
            EditorBlock: DraftEditorBlock,
            EditorState: EditorState,
            CompositeDecorator: CompositeDraftDecorator,
            Entity: DraftEntity,
            EntityInstance: DraftEntityInstance,
            BlockMapBuilder: BlockMapBuilder,
            CharacterMetadata: CharacterMetadata,
            ContentBlock: ContentBlock,
            ContentState: ContentState,
            RawDraftContentState: RawDraftContentState,
            SelectionState: SelectionState,
            AtomicBlockUtils: AtomicBlockUtils,
            KeyBindingUtil: KeyBindingUtil,
            Modifier: DraftModifier,
            RichUtils: RichTextEditorUtil,
            DefaultDraftBlockRenderMap: DefaultDraftBlockRenderMap,
            DefaultDraftInlineStyle: DefaultDraftInlineStyle,
            convertFromHTML: convertFromHTML,
            convertFromRaw: convertFromRawToDraftState,
            convertToRaw: convertFromDraftStateToRaw,
            genKey: generateRandomKey,
            getDefaultKeyBinding: getDefaultKeyBinding,
            getVisibleSelectionRect: getVisibleSelectionRect
          };
          Draft = DraftPublic;
          return Draft;
        }
        var DraftExports = exports("a7", requireDraft());
        var reactDraftWysiwyg = {
          exports: {}
        };

        /**
         * MIT License
         * 
         * Copyright (c) 2014-present, Lee Byron and other contributors.
         * 
         * Permission is hereby granted, free of charge, to any person obtaining a copy
         * of this software and associated documentation files (the "Software"), to deal
         * in the Software without restriction, including without limitation the rights
         * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
         * copies of the Software, and to permit persons to whom the Software is
         * furnished to do so, subject to the following conditions:
         * 
         * The above copyright notice and this permission notice shall be included in all
         * copies or substantial portions of the Software.
         * 
         * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
         * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
         * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
         * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
         * SOFTWARE.
         */

        var DELETE = 'delete';

        // Constants describing the size of trie nodes.
        var SHIFT = 5; // Resulted in best performance after ______?
        var SIZE = 1 << SHIFT;
        var MASK = SIZE - 1;

        // A consistent shared value representing "not set" which equals nothing other
        // than itself, and nothing that could be provided externally.
        var NOT_SET = {};

        // Boolean references, Rough equivalent of `bool &`.
        function MakeRef() {
          return {
            value: false
          };
        }
        function SetRef(ref) {
          if (ref) {
            ref.value = true;
          }
        }

        // A function which returns a value representing an "owner" for transient writes
        // to tries. The return value will only ever equal itself, and will not equal
        // the return of any subsequent call of this function.
        function OwnerID() {}
        function ensureSize(iter) {
          if (iter.size === undefined) {
            iter.size = iter.__iterate(returnTrue);
          }
          return iter.size;
        }
        function wrapIndex(iter, index) {
          // This implements "is array index" which the ECMAString spec defines as:
          //
          //     A String property name P is an array index if and only if
          //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
          //     to 2^321.
          //
          // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
          if (typeof index !== 'number') {
            var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
            if ('' + uint32Index !== index || uint32Index === 4294967295) {
              return NaN;
            }
            index = uint32Index;
          }
          return index < 0 ? ensureSize(iter) + index : index;
        }
        function returnTrue() {
          return true;
        }
        function wholeSlice(begin, end, size) {
          return (begin === 0 && !isNeg(begin) || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
        }
        function resolveBegin(begin, size) {
          return resolveIndex(begin, size, 0);
        }
        function resolveEnd(end, size) {
          return resolveIndex(end, size, size);
        }
        function resolveIndex(index, size, defaultIndex) {
          // Sanitize indices using this shorthand for ToInt32(argument)
          // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
          return index === undefined ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === undefined || size === index ? index : Math.min(size, index) | 0;
        }
        function isNeg(value) {
          // Account for -0 which is negative, but not less than 0.
          return value < 0 || value === 0 && 1 / value === -Infinity;
        }
        var IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';
        function isCollection(maybeCollection) {
          return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
        }
        var IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';
        function isKeyed(maybeKeyed) {
          return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
        }
        var IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';
        function isIndexed(maybeIndexed) {
          return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
        }
        function isAssociative(maybeAssociative) {
          return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
        }
        var Collection = function Collection(value) {
          // eslint-disable-next-line no-constructor-return
          return isCollection(value) ? value : Seq(value);
        };
        var KeyedCollection = /*@__PURE__*/function (Collection) {
          function KeyedCollection(value) {
            // eslint-disable-next-line no-constructor-return
            return isKeyed(value) ? value : KeyedSeq(value);
          }
          if (Collection) KeyedCollection.__proto__ = Collection;
          KeyedCollection.prototype = Object.create(Collection && Collection.prototype);
          KeyedCollection.prototype.constructor = KeyedCollection;
          return KeyedCollection;
        }(Collection);
        var IndexedCollection = /*@__PURE__*/function (Collection) {
          function IndexedCollection(value) {
            // eslint-disable-next-line no-constructor-return
            return isIndexed(value) ? value : IndexedSeq(value);
          }
          if (Collection) IndexedCollection.__proto__ = Collection;
          IndexedCollection.prototype = Object.create(Collection && Collection.prototype);
          IndexedCollection.prototype.constructor = IndexedCollection;
          return IndexedCollection;
        }(Collection);
        var SetCollection = /*@__PURE__*/function (Collection) {
          function SetCollection(value) {
            // eslint-disable-next-line no-constructor-return
            return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
          }
          if (Collection) SetCollection.__proto__ = Collection;
          SetCollection.prototype = Object.create(Collection && Collection.prototype);
          SetCollection.prototype.constructor = SetCollection;
          return SetCollection;
        }(Collection);
        Collection.Keyed = KeyedCollection;
        Collection.Indexed = IndexedCollection;
        Collection.Set = SetCollection;
        var IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';
        function isSeq(maybeSeq) {
          return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
        }
        var IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';
        function isRecord(maybeRecord) {
          return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
        }
        function isImmutable(maybeImmutable) {
          return isCollection(maybeImmutable) || isRecord(maybeImmutable);
        }
        var IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';
        function isOrdered(maybeOrdered) {
          return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
        }
        var ITERATE_KEYS = 0;
        var ITERATE_VALUES = 1;
        var ITERATE_ENTRIES = 2;
        var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
        var Iterator = function Iterator(next) {
          this.next = next;
        };
        Iterator.prototype.toString = function toString() {
          return '[Iterator]';
        };
        Iterator.KEYS = ITERATE_KEYS;
        Iterator.VALUES = ITERATE_VALUES;
        Iterator.ENTRIES = ITERATE_ENTRIES;
        Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
          return this.toString();
        };
        Iterator.prototype[ITERATOR_SYMBOL] = function () {
          return this;
        };
        function iteratorValue(type, k, v, iteratorResult) {
          var value = type === 0 ? k : type === 1 ? v : [k, v];
          iteratorResult ? iteratorResult.value = value : iteratorResult = {
            value: value,
            done: false
          };
          return iteratorResult;
        }
        function iteratorDone() {
          return {
            value: undefined,
            done: true
          };
        }
        function hasIterator(maybeIterable) {
          if (Array.isArray(maybeIterable)) {
            // IE11 trick as it does not support `Symbol.iterator`
            return true;
          }
          return !!getIteratorFn(maybeIterable);
        }
        function isIterator(maybeIterator) {
          return maybeIterator && typeof maybeIterator.next === 'function';
        }
        function getIterator(iterable) {
          var iteratorFn = getIteratorFn(iterable);
          return iteratorFn && iteratorFn.call(iterable);
        }
        function getIteratorFn(iterable) {
          var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === 'function') {
            return iteratorFn;
          }
        }
        function isEntriesIterable(maybeIterable) {
          var iteratorFn = getIteratorFn(maybeIterable);
          return iteratorFn && iteratorFn === maybeIterable.entries;
        }
        function isKeysIterable(maybeIterable) {
          var iteratorFn = getIteratorFn(maybeIterable);
          return iteratorFn && iteratorFn === maybeIterable.keys;
        }
        var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        function isArrayLike(value) {
          if (Array.isArray(value) || typeof value === 'string') {
            return true;
          }
          return value && typeof value === 'object' && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ?
          // Only {length: 0} is considered Array-like.
          Object.keys(value).length === 1 :
          // An object is only Array-like if it has a property where the last value
          // in the array-like may be found (which could be undefined).
          value.hasOwnProperty(value.length - 1));
        }
        var Seq = /*@__PURE__*/function (Collection) {
          function Seq(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);
          }
          if (Collection) Seq.__proto__ = Collection;
          Seq.prototype = Object.create(Collection && Collection.prototype);
          Seq.prototype.constructor = Seq;
          Seq.prototype.toSeq = function toSeq() {
            return this;
          };
          Seq.prototype.toString = function toString() {
            return this.__toString('Seq {', '}');
          };
          Seq.prototype.cacheResult = function cacheResult() {
            if (!this._cache && this.__iterateUncached) {
              this._cache = this.entrySeq().toArray();
              this.size = this._cache.length;
            }
            return this;
          };

          // abstract __iterateUncached(fn, reverse)

          Seq.prototype.__iterate = function __iterate(fn, reverse) {
            var cache = this._cache;
            if (cache) {
              var size = cache.length;
              var i = 0;
              while (i !== size) {
                var entry = cache[reverse ? size - ++i : i++];
                if (fn(entry[1], entry[0], this) === false) {
                  break;
                }
              }
              return i;
            }
            return this.__iterateUncached(fn, reverse);
          };

          // abstract __iteratorUncached(type, reverse)

          Seq.prototype.__iterator = function __iterator(type, reverse) {
            var cache = this._cache;
            if (cache) {
              var size = cache.length;
              var i = 0;
              return new Iterator(function () {
                if (i === size) {
                  return iteratorDone();
                }
                var entry = cache[reverse ? size - ++i : i++];
                return iteratorValue(type, entry[0], entry[1]);
              });
            }
            return this.__iteratorUncached(type, reverse);
          };
          return Seq;
        }(Collection);
        var KeyedSeq = /*@__PURE__*/function (Seq) {
          function KeyedSeq(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
          }
          if (Seq) KeyedSeq.__proto__ = Seq;
          KeyedSeq.prototype = Object.create(Seq && Seq.prototype);
          KeyedSeq.prototype.constructor = KeyedSeq;
          KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {
            return this;
          };
          return KeyedSeq;
        }(Seq);
        var IndexedSeq = /*@__PURE__*/function (Seq) {
          function IndexedSeq(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
          }
          if (Seq) IndexedSeq.__proto__ = Seq;
          IndexedSeq.prototype = Object.create(Seq && Seq.prototype);
          IndexedSeq.prototype.constructor = IndexedSeq;
          IndexedSeq.of = function of(/*...values*/
          ) {
            return IndexedSeq(arguments);
          };
          IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {
            return this;
          };
          IndexedSeq.prototype.toString = function toString() {
            return this.__toString('Seq [', ']');
          };
          return IndexedSeq;
        }(Seq);
        var SetSeq = /*@__PURE__*/function (Seq) {
          function SetSeq(value) {
            // eslint-disable-next-line no-constructor-return
            return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
          }
          if (Seq) SetSeq.__proto__ = Seq;
          SetSeq.prototype = Object.create(Seq && Seq.prototype);
          SetSeq.prototype.constructor = SetSeq;
          SetSeq.of = function of(/*...values*/
          ) {
            return SetSeq(arguments);
          };
          SetSeq.prototype.toSetSeq = function toSetSeq() {
            return this;
          };
          return SetSeq;
        }(Seq);
        Seq.isSeq = isSeq;
        Seq.Keyed = KeyedSeq;
        Seq.Set = SetSeq;
        Seq.Indexed = IndexedSeq;
        Seq.prototype[IS_SEQ_SYMBOL] = true;

        // #pragma Root Sequences

        var ArraySeq = /*@__PURE__*/function (IndexedSeq) {
          function ArraySeq(array) {
            this._array = array;
            this.size = array.length;
          }
          if (IndexedSeq) ArraySeq.__proto__ = IndexedSeq;
          ArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
          ArraySeq.prototype.constructor = ArraySeq;
          ArraySeq.prototype.get = function get(index, notSetValue) {
            return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
          };
          ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {
            var array = this._array;
            var size = array.length;
            var i = 0;
            while (i !== size) {
              var ii = reverse ? size - ++i : i++;
              if (fn(array[ii], ii, this) === false) {
                break;
              }
            }
            return i;
          };
          ArraySeq.prototype.__iterator = function __iterator(type, reverse) {
            var array = this._array;
            var size = array.length;
            var i = 0;
            return new Iterator(function () {
              if (i === size) {
                return iteratorDone();
              }
              var ii = reverse ? size - ++i : i++;
              return iteratorValue(type, ii, array[ii]);
            });
          };
          return ArraySeq;
        }(IndexedSeq);
        var ObjectSeq = /*@__PURE__*/function (KeyedSeq) {
          function ObjectSeq(object) {
            var keys = Object.keys(object).concat(Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []);
            this._object = object;
            this._keys = keys;
            this.size = keys.length;
          }
          if (KeyedSeq) ObjectSeq.__proto__ = KeyedSeq;
          ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
          ObjectSeq.prototype.constructor = ObjectSeq;
          ObjectSeq.prototype.get = function get(key, notSetValue) {
            if (notSetValue !== undefined && !this.has(key)) {
              return notSetValue;
            }
            return this._object[key];
          };
          ObjectSeq.prototype.has = function has(key) {
            return hasOwnProperty$1.call(this._object, key);
          };
          ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {
            var object = this._object;
            var keys = this._keys;
            var size = keys.length;
            var i = 0;
            while (i !== size) {
              var key = keys[reverse ? size - ++i : i++];
              if (fn(object[key], key, this) === false) {
                break;
              }
            }
            return i;
          };
          ObjectSeq.prototype.__iterator = function __iterator(type, reverse) {
            var object = this._object;
            var keys = this._keys;
            var size = keys.length;
            var i = 0;
            return new Iterator(function () {
              if (i === size) {
                return iteratorDone();
              }
              var key = keys[reverse ? size - ++i : i++];
              return iteratorValue(type, key, object[key]);
            });
          };
          return ObjectSeq;
        }(KeyedSeq);
        ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
        var CollectionSeq = /*@__PURE__*/function (IndexedSeq) {
          function CollectionSeq(collection) {
            this._collection = collection;
            this.size = collection.length || collection.size;
          }
          if (IndexedSeq) CollectionSeq.__proto__ = IndexedSeq;
          CollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
          CollectionSeq.prototype.constructor = CollectionSeq;
          CollectionSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var collection = this._collection;
            var iterator = getIterator(collection);
            var iterations = 0;
            if (isIterator(iterator)) {
              var step;
              while (!(step = iterator.next()).done) {
                if (fn(step.value, iterations++, this) === false) {
                  break;
                }
              }
            }
            return iterations;
          };
          CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var collection = this._collection;
            var iterator = getIterator(collection);
            if (!isIterator(iterator)) {
              return new Iterator(iteratorDone);
            }
            var iterations = 0;
            return new Iterator(function () {
              var step = iterator.next();
              return step.done ? step : iteratorValue(type, iterations++, step.value);
            });
          };
          return CollectionSeq;
        }(IndexedSeq);

        // # pragma Helper functions

        var EMPTY_SEQ;
        function emptySequence() {
          return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
        }
        function keyedSeqFromValue(value) {
          var seq = maybeIndexedSeqFromValue(value);
          if (seq) {
            return seq.fromEntrySeq();
          }
          if (typeof value === 'object') {
            return new ObjectSeq(value);
          }
          throw new TypeError('Expected Array or collection object of [k, v] entries, or keyed object: ' + value);
        }
        function indexedSeqFromValue(value) {
          var seq = maybeIndexedSeqFromValue(value);
          if (seq) {
            return seq;
          }
          throw new TypeError('Expected Array or collection object of values: ' + value);
        }
        function seqFromValue(value) {
          var seq = maybeIndexedSeqFromValue(value);
          if (seq) {
            return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;
          }
          if (typeof value === 'object') {
            return new ObjectSeq(value);
          }
          throw new TypeError('Expected Array or collection object of values, or keyed object: ' + value);
        }
        function maybeIndexedSeqFromValue(value) {
          return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;
        }
        var IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';
        function isMap(maybeMap) {
          return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
        }
        function isOrderedMap(maybeOrderedMap) {
          return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
        }
        function isValueObject(maybeValue) {
          return Boolean(maybeValue && typeof maybeValue.equals === 'function' && typeof maybeValue.hashCode === 'function');
        }

        /**
         * An extension of the "same-value" algorithm as [described for use by ES6 Map
         * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
         *
         * NaN is considered the same as NaN, however -0 and 0 are considered the same
         * value, which is different from the algorithm described by
         * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
         *
         * This is extended further to allow Objects to describe the values they
         * represent, by way of `valueOf` or `equals` (and `hashCode`).
         *
         * Note: because of this extension, the key equality of Immutable.Map and the
         * value equality of Immutable.Set will differ from ES6 Map and Set.
         *
         * ### Defining custom values
         *
         * The easiest way to describe the value an object represents is by implementing
         * `valueOf`. For example, `Date` represents a value by returning a unix
         * timestamp for `valueOf`:
         *
         *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
         *     var date2 = new Date(1234567890000);
         *     date1.valueOf(); // 1234567890000
         *     assert( date1 !== date2 );
         *     assert( Immutable.is( date1, date2 ) );
         *
         * Note: overriding `valueOf` may have other implications if you use this object
         * where JavaScript expects a primitive, such as implicit string coercion.
         *
         * For more complex types, especially collections, implementing `valueOf` may
         * not be performant. An alternative is to implement `equals` and `hashCode`.
         *
         * `equals` takes another object, presumably of similar type, and returns true
         * if it is equal. Equality is symmetrical, so the same result should be
         * returned if this and the argument are flipped.
         *
         *     assert( a.equals(b) === b.equals(a) );
         *
         * `hashCode` returns a 32bit integer number representing the object which will
         * be used to determine how to store the value object in a Map or Set. You must
         * provide both or neither methods, one must not exist without the other.
         *
         * Also, an important relationship between these methods must be upheld: if two
         * values are equal, they *must* return the same hashCode. If the values are not
         * equal, they might have the same hashCode; this is called a hash collision,
         * and while undesirable for performance reasons, it is acceptable.
         *
         *     if (a.equals(b)) {
         *       assert( a.hashCode() === b.hashCode() );
         *     }
         *
         * All Immutable collections are Value Objects: they implement `equals()`
         * and `hashCode()`.
         */
        function is(valueA, valueB) {
          if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
            return true;
          }
          if (!valueA || !valueB) {
            return false;
          }
          if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {
            valueA = valueA.valueOf();
            valueB = valueB.valueOf();
            if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
              return true;
            }
            if (!valueA || !valueB) {
              return false;
            }
          }
          return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
        }
        var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
          a |= 0; // int
          b |= 0; // int
          var c = a & 0xffff;
          var d = b & 0xffff;
          // Shift by 0 fixes the sign on the high part.
          return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
        };

        // v8 has an optimization for storing 31-bit signed numbers.
        // Values which have either 00 or 11 as the high order bits qualify.
        // This function drops the highest order bit in a signed number, maintaining
        // the sign bit.
        function smi(i32) {
          return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;
        }
        var defaultValueOf = Object.prototype.valueOf;
        function hash(o) {
          if (o == null) {
            return hashNullish(o);
          }
          if (typeof o.hashCode === 'function') {
            // Drop any high bits from accidentally long hash codes.
            return smi(o.hashCode(o));
          }
          var v = valueOf$1(o);
          if (v == null) {
            return hashNullish(v);
          }
          switch (typeof v) {
            case 'boolean':
              // The hash values for built-in constants are a 1 value for each 5-byte
              // shift region expect for the first, which encodes the value. This
              // reduces the odds of a hash collision for these common values.
              return v ? 0x42108421 : 0x42108420;
            case 'number':
              return hashNumber(v);
            case 'string':
              return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
            case 'object':
            case 'function':
              return hashJSObj(v);
            case 'symbol':
              return hashSymbol(v);
            default:
              if (typeof v.toString === 'function') {
                return hashString(v.toString());
              }
              throw new Error('Value type ' + typeof v + ' cannot be hashed.');
          }
        }
        function hashNullish(nullish) {
          return nullish === null ? 0x42108422 : /* undefined */0x42108423;
        }

        // Compress arbitrarily large numbers into smi hashes.
        function hashNumber(n) {
          if (n !== n || n === Infinity) {
            return 0;
          }
          var hash = n | 0;
          if (hash !== n) {
            hash ^= n * 0xffffffff;
          }
          while (n > 0xffffffff) {
            n /= 0xffffffff;
            hash ^= n;
          }
          return smi(hash);
        }
        function cachedHashString(string) {
          var hashed = stringHashCache[string];
          if (hashed === undefined) {
            hashed = hashString(string);
            if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
              STRING_HASH_CACHE_SIZE = 0;
              stringHashCache = {};
            }
            STRING_HASH_CACHE_SIZE++;
            stringHashCache[string] = hashed;
          }
          return hashed;
        }

        // http://jsperf.com/hashing-strings
        function hashString(string) {
          // This is the hash from JVM
          // The hash code for a string is computed as
          // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
          // where s[i] is the ith character of the string and n is the length of
          // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
          // (exclusive) by dropping high bits.
          var hashed = 0;
          for (var ii = 0; ii < string.length; ii++) {
            hashed = 31 * hashed + string.charCodeAt(ii) | 0;
          }
          return smi(hashed);
        }
        function hashSymbol(sym) {
          var hashed = symbolMap[sym];
          if (hashed !== undefined) {
            return hashed;
          }
          hashed = nextHash();
          symbolMap[sym] = hashed;
          return hashed;
        }
        function hashJSObj(obj) {
          var hashed;
          if (usingWeakMap) {
            hashed = weakMap.get(obj);
            if (hashed !== undefined) {
              return hashed;
            }
          }
          hashed = obj[UID_HASH_KEY];
          if (hashed !== undefined) {
            return hashed;
          }
          if (!canDefineProperty) {
            hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
            if (hashed !== undefined) {
              return hashed;
            }
            hashed = getIENodeHash(obj);
            if (hashed !== undefined) {
              return hashed;
            }
          }
          hashed = nextHash();
          if (usingWeakMap) {
            weakMap.set(obj, hashed);
          } else if (isExtensible !== undefined && isExtensible(obj) === false) {
            throw new Error('Non-extensible objects are not allowed as keys.');
          } else if (canDefineProperty) {
            Object.defineProperty(obj, UID_HASH_KEY, {
              enumerable: false,
              configurable: false,
              writable: false,
              value: hashed
            });
          } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
            // Since we can't define a non-enumerable property on the object
            // we'll hijack one of the less-used non-enumerable properties to
            // save our hash on it. Since this is a function it will not show up in
            // `JSON.stringify` which is what we want.
            obj.propertyIsEnumerable = function () {
              return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
            };
            obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
          } else if (obj.nodeType !== undefined) {
            // At this point we couldn't get the IE `uniqueID` to use as a hash
            // and we couldn't use a non-enumerable property to exploit the
            // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
            // itself.
            obj[UID_HASH_KEY] = hashed;
          } else {
            throw new Error('Unable to set a non-enumerable property on object.');
          }
          return hashed;
        }

        // Get references to ES5 object methods.
        var isExtensible = Object.isExtensible;

        // True if Object.defineProperty works as expected. IE8 fails this test.
        var canDefineProperty = function () {
          try {
            Object.defineProperty({}, '@', {});
            return true;
          } catch (e) {
            return false;
          }
        }();

        // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
        // and avoid memory leaks from the IE cloneNode bug.
        function getIENodeHash(node) {
          if (node && node.nodeType > 0) {
            switch (node.nodeType) {
              case 1:
                // Element
                return node.uniqueID;
              case 9:
                // Document
                return node.documentElement && node.documentElement.uniqueID;
            }
          }
        }
        function valueOf$1(obj) {
          return obj.valueOf !== defaultValueOf && typeof obj.valueOf === 'function' ? obj.valueOf(obj) : obj;
        }
        function nextHash() {
          var nextHash = ++_objHashUID;
          if (_objHashUID & 0x40000000) {
            _objHashUID = 0;
          }
          return nextHash;
        }

        // If possible, use a WeakMap.
        var usingWeakMap = typeof WeakMap === 'function';
        var weakMap;
        if (usingWeakMap) {
          weakMap = new WeakMap();
        }
        var symbolMap = Object.create(null);
        var _objHashUID = 0;
        var UID_HASH_KEY = '__immutablehash__';
        if (typeof Symbol === 'function') {
          UID_HASH_KEY = Symbol(UID_HASH_KEY);
        }
        var STRING_HASH_CACHE_MIN_STRLEN = 16;
        var STRING_HASH_CACHE_MAX_SIZE = 255;
        var STRING_HASH_CACHE_SIZE = 0;
        var stringHashCache = {};
        var ToKeyedSequence = /*@__PURE__*/function (KeyedSeq) {
          function ToKeyedSequence(indexed, useKeys) {
            this._iter = indexed;
            this._useKeys = useKeys;
            this.size = indexed.size;
          }
          if (KeyedSeq) ToKeyedSequence.__proto__ = KeyedSeq;
          ToKeyedSequence.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
          ToKeyedSequence.prototype.constructor = ToKeyedSequence;
          ToKeyedSequence.prototype.get = function get(key, notSetValue) {
            return this._iter.get(key, notSetValue);
          };
          ToKeyedSequence.prototype.has = function has(key) {
            return this._iter.has(key);
          };
          ToKeyedSequence.prototype.valueSeq = function valueSeq() {
            return this._iter.valueSeq();
          };
          ToKeyedSequence.prototype.reverse = function reverse() {
            var this$1$1 = this;
            var reversedSequence = reverseFactory(this, true);
            if (!this._useKeys) {
              reversedSequence.valueSeq = function () {
                return this$1$1._iter.toSeq().reverse();
              };
            }
            return reversedSequence;
          };
          ToKeyedSequence.prototype.map = function map(mapper, context) {
            var this$1$1 = this;
            var mappedSequence = mapFactory(this, mapper, context);
            if (!this._useKeys) {
              mappedSequence.valueSeq = function () {
                return this$1$1._iter.toSeq().map(mapper, context);
              };
            }
            return mappedSequence;
          };
          ToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._iter.__iterate(function (v, k) {
              return fn(v, k, this$1$1);
            }, reverse);
          };
          ToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {
            return this._iter.__iterator(type, reverse);
          };
          return ToKeyedSequence;
        }(KeyedSeq);
        ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
        var ToIndexedSequence = /*@__PURE__*/function (IndexedSeq) {
          function ToIndexedSequence(iter) {
            this._iter = iter;
            this.size = iter.size;
          }
          if (IndexedSeq) ToIndexedSequence.__proto__ = IndexedSeq;
          ToIndexedSequence.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
          ToIndexedSequence.prototype.constructor = ToIndexedSequence;
          ToIndexedSequence.prototype.includes = function includes(value) {
            return this._iter.includes(value);
          };
          ToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            var i = 0;
            reverse && ensureSize(this);
            return this._iter.__iterate(function (v) {
              return fn(v, reverse ? this$1$1.size - ++i : i++, this$1$1);
            }, reverse);
          };
          ToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {
            var this$1$1 = this;
            var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
            var i = 0;
            reverse && ensureSize(this);
            return new Iterator(function () {
              var step = iterator.next();
              return step.done ? step : iteratorValue(type, reverse ? this$1$1.size - ++i : i++, step.value, step);
            });
          };
          return ToIndexedSequence;
        }(IndexedSeq);
        var ToSetSequence = /*@__PURE__*/function (SetSeq) {
          function ToSetSequence(iter) {
            this._iter = iter;
            this.size = iter.size;
          }
          if (SetSeq) ToSetSequence.__proto__ = SetSeq;
          ToSetSequence.prototype = Object.create(SetSeq && SetSeq.prototype);
          ToSetSequence.prototype.constructor = ToSetSequence;
          ToSetSequence.prototype.has = function has(key) {
            return this._iter.includes(key);
          };
          ToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._iter.__iterate(function (v) {
              return fn(v, v, this$1$1);
            }, reverse);
          };
          ToSetSequence.prototype.__iterator = function __iterator(type, reverse) {
            var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
            return new Iterator(function () {
              var step = iterator.next();
              return step.done ? step : iteratorValue(type, step.value, step.value, step);
            });
          };
          return ToSetSequence;
        }(SetSeq);
        var FromEntriesSequence = /*@__PURE__*/function (KeyedSeq) {
          function FromEntriesSequence(entries) {
            this._iter = entries;
            this.size = entries.size;
          }
          if (KeyedSeq) FromEntriesSequence.__proto__ = KeyedSeq;
          FromEntriesSequence.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
          FromEntriesSequence.prototype.constructor = FromEntriesSequence;
          FromEntriesSequence.prototype.entrySeq = function entrySeq() {
            return this._iter.toSeq();
          };
          FromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._iter.__iterate(function (entry) {
              // Check if entry exists first so array access doesn't throw for holes
              // in the parent iteration.
              if (entry) {
                validateEntry(entry);
                var indexedCollection = isCollection(entry);
                return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1$1);
              }
            }, reverse);
          };
          FromEntriesSequence.prototype.__iterator = function __iterator(type, reverse) {
            var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
            return new Iterator(function () {
              while (true) {
                var step = iterator.next();
                if (step.done) {
                  return step;
                }
                var entry = step.value;
                // Check if entry exists first so array access doesn't throw for holes
                // in the parent iteration.
                if (entry) {
                  validateEntry(entry);
                  var indexedCollection = isCollection(entry);
                  return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);
                }
              }
            });
          };
          return FromEntriesSequence;
        }(KeyedSeq);
        ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
        function flipFactory(collection) {
          var flipSequence = makeSequence(collection);
          flipSequence._iter = collection;
          flipSequence.size = collection.size;
          flipSequence.flip = function () {
            return collection;
          };
          flipSequence.reverse = function () {
            var reversedSequence = collection.reverse.apply(this); // super.reverse()
            reversedSequence.flip = function () {
              return collection.reverse();
            };
            return reversedSequence;
          };
          flipSequence.has = function (key) {
            return collection.includes(key);
          };
          flipSequence.includes = function (key) {
            return collection.has(key);
          };
          flipSequence.cacheResult = cacheResultThrough;
          flipSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            return collection.__iterate(function (v, k) {
              return fn(k, v, this$1$1) !== false;
            }, reverse);
          };
          flipSequence.__iteratorUncached = function (type, reverse) {
            if (type === ITERATE_ENTRIES) {
              var iterator = collection.__iterator(type, reverse);
              return new Iterator(function () {
                var step = iterator.next();
                if (!step.done) {
                  var k = step.value[0];
                  step.value[0] = step.value[1];
                  step.value[1] = k;
                }
                return step;
              });
            }
            return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
          };
          return flipSequence;
        }
        function mapFactory(collection, mapper, context) {
          var mappedSequence = makeSequence(collection);
          mappedSequence.size = collection.size;
          mappedSequence.has = function (key) {
            return collection.has(key);
          };
          mappedSequence.get = function (key, notSetValue) {
            var v = collection.get(key, NOT_SET);
            return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);
          };
          mappedSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            return collection.__iterate(function (v, k, c) {
              return fn(mapper.call(context, v, k, c), k, this$1$1) !== false;
            }, reverse);
          };
          mappedSequence.__iteratorUncached = function (type, reverse) {
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            return new Iterator(function () {
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              var key = entry[0];
              return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);
            });
          };
          return mappedSequence;
        }
        function reverseFactory(collection, useKeys) {
          var this$1$1 = this;
          var reversedSequence = makeSequence(collection);
          reversedSequence._iter = collection;
          reversedSequence.size = collection.size;
          reversedSequence.reverse = function () {
            return collection;
          };
          if (collection.flip) {
            reversedSequence.flip = function () {
              var flipSequence = flipFactory(collection);
              flipSequence.reverse = function () {
                return collection.flip();
              };
              return flipSequence;
            };
          }
          reversedSequence.get = function (key, notSetValue) {
            return collection.get(useKeys ? key : -1 - key, notSetValue);
          };
          reversedSequence.has = function (key) {
            return collection.has(useKeys ? key : -1 - key);
          };
          reversedSequence.includes = function (value) {
            return collection.includes(value);
          };
          reversedSequence.cacheResult = cacheResultThrough;
          reversedSequence.__iterate = function (fn, reverse) {
            var this$1$1 = this;
            var i = 0;
            reverse && ensureSize(collection);
            return collection.__iterate(function (v, k) {
              return fn(v, useKeys ? k : reverse ? this$1$1.size - ++i : i++, this$1$1);
            }, !reverse);
          };
          reversedSequence.__iterator = function (type, reverse) {
            var i = 0;
            reverse && ensureSize(collection);
            var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
            return new Iterator(function () {
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              return iteratorValue(type, useKeys ? entry[0] : reverse ? this$1$1.size - ++i : i++, entry[1], step);
            });
          };
          return reversedSequence;
        }
        function filterFactory(collection, predicate, context, useKeys) {
          var filterSequence = makeSequence(collection);
          if (useKeys) {
            filterSequence.has = function (key) {
              var v = collection.get(key, NOT_SET);
              return v !== NOT_SET && !!predicate.call(context, v, key, collection);
            };
            filterSequence.get = function (key, notSetValue) {
              var v = collection.get(key, NOT_SET);
              return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;
            };
          }
          filterSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            var iterations = 0;
            collection.__iterate(function (v, k, c) {
              if (predicate.call(context, v, k, c)) {
                iterations++;
                return fn(v, useKeys ? k : iterations - 1, this$1$1);
              }
            }, reverse);
            return iterations;
          };
          filterSequence.__iteratorUncached = function (type, reverse) {
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            var iterations = 0;
            return new Iterator(function () {
              while (true) {
                var step = iterator.next();
                if (step.done) {
                  return step;
                }
                var entry = step.value;
                var key = entry[0];
                var value = entry[1];
                if (predicate.call(context, value, key, collection)) {
                  return iteratorValue(type, useKeys ? key : iterations++, value, step);
                }
              }
            });
          };
          return filterSequence;
        }
        function countByFactory(collection, grouper, context) {
          var groups = Map$1().asMutable();
          collection.__iterate(function (v, k) {
            groups.update(grouper.call(context, v, k, collection), 0, function (a) {
              return a + 1;
            });
          });
          return groups.asImmutable();
        }
        function groupByFactory(collection, grouper, context) {
          var isKeyedIter = isKeyed(collection);
          var groups = (isOrdered(collection) ? OrderedMap() : Map$1()).asMutable();
          collection.__iterate(function (v, k) {
            groups.update(grouper.call(context, v, k, collection), function (a) {
              return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
            });
          });
          var coerce = collectionClass(collection);
          return groups.map(function (arr) {
            return reify(collection, coerce(arr));
          }).asImmutable();
        }
        function partitionFactory(collection, predicate, context) {
          var isKeyedIter = isKeyed(collection);
          var groups = [[], []];
          collection.__iterate(function (v, k) {
            groups[predicate.call(context, v, k, collection) ? 1 : 0].push(isKeyedIter ? [k, v] : v);
          });
          var coerce = collectionClass(collection);
          return groups.map(function (arr) {
            return reify(collection, coerce(arr));
          });
        }
        function sliceFactory(collection, begin, end, useKeys) {
          var originalSize = collection.size;
          if (wholeSlice(begin, end, originalSize)) {
            return collection;
          }

          // begin or end can not be resolved if they were provided as negative numbers and
          // this collection's size is unknown. In that case, cache first so there is
          // a known size and these do not resolve to NaN.
          if (typeof originalSize === 'undefined' && (begin < 0 || end < 0)) {
            return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
          }
          var resolvedBegin = resolveBegin(begin, originalSize);
          var resolvedEnd = resolveEnd(end, originalSize);

          // Note: resolvedEnd is undefined when the original sequence's length is
          // unknown and this slice did not supply an end and should contain all
          // elements after resolvedBegin.
          // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
          var resolvedSize = resolvedEnd - resolvedBegin;
          var sliceSize;
          if (resolvedSize === resolvedSize) {
            sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
          }
          var sliceSeq = makeSequence(collection);

          // If collection.size is undefined, the size of the realized sliceSeq is
          // unknown at this point unless the number of items to slice is 0
          sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || undefined;
          if (!useKeys && isSeq(collection) && sliceSize >= 0) {
            sliceSeq.get = function (index, notSetValue) {
              index = wrapIndex(this, index);
              return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
            };
          }
          sliceSeq.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            if (sliceSize === 0) {
              return 0;
            }
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var skipped = 0;
            var isSkipping = true;
            var iterations = 0;
            collection.__iterate(function (v, k) {
              if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
                iterations++;
                return fn(v, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
              }
            });
            return iterations;
          };
          sliceSeq.__iteratorUncached = function (type, reverse) {
            if (sliceSize !== 0 && reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            // Don't bother instantiating parent iterator if taking 0.
            if (sliceSize === 0) {
              return new Iterator(iteratorDone);
            }
            var iterator = collection.__iterator(type, reverse);
            var skipped = 0;
            var iterations = 0;
            return new Iterator(function () {
              while (skipped++ < resolvedBegin) {
                iterator.next();
              }
              if (++iterations > sliceSize) {
                return iteratorDone();
              }
              var step = iterator.next();
              if (useKeys || type === ITERATE_VALUES || step.done) {
                return step;
              }
              if (type === ITERATE_KEYS) {
                return iteratorValue(type, iterations - 1, undefined, step);
              }
              return iteratorValue(type, iterations - 1, step.value[1], step);
            });
          };
          return sliceSeq;
        }
        function takeWhileFactory(collection, predicate, context) {
          var takeSequence = makeSequence(collection);
          takeSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var iterations = 0;
            collection.__iterate(function (v, k, c) {
              return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1);
            });
            return iterations;
          };
          takeSequence.__iteratorUncached = function (type, reverse) {
            var this$1$1 = this;
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            var iterating = true;
            return new Iterator(function () {
              if (!iterating) {
                return iteratorDone();
              }
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              var k = entry[0];
              var v = entry[1];
              if (!predicate.call(context, v, k, this$1$1)) {
                iterating = false;
                return iteratorDone();
              }
              return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
            });
          };
          return takeSequence;
        }
        function skipWhileFactory(collection, predicate, context, useKeys) {
          var skipSequence = makeSequence(collection);
          skipSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var isSkipping = true;
            var iterations = 0;
            collection.__iterate(function (v, k, c) {
              if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
                iterations++;
                return fn(v, useKeys ? k : iterations - 1, this$1$1);
              }
            });
            return iterations;
          };
          skipSequence.__iteratorUncached = function (type, reverse) {
            var this$1$1 = this;
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            var skipping = true;
            var iterations = 0;
            return new Iterator(function () {
              var step;
              var k;
              var v;
              do {
                step = iterator.next();
                if (step.done) {
                  if (useKeys || type === ITERATE_VALUES) {
                    return step;
                  }
                  if (type === ITERATE_KEYS) {
                    return iteratorValue(type, iterations++, undefined, step);
                  }
                  return iteratorValue(type, iterations++, step.value[1], step);
                }
                var entry = step.value;
                k = entry[0];
                v = entry[1];
                skipping && (skipping = predicate.call(context, v, k, this$1$1));
              } while (skipping);
              return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
            });
          };
          return skipSequence;
        }
        function concatFactory(collection, values) {
          var isKeyedCollection = isKeyed(collection);
          var iters = [collection].concat(values).map(function (v) {
            if (!isCollection(v)) {
              v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
            } else if (isKeyedCollection) {
              v = KeyedCollection(v);
            }
            return v;
          }).filter(function (v) {
            return v.size !== 0;
          });
          if (iters.length === 0) {
            return collection;
          }
          if (iters.length === 1) {
            var singleton = iters[0];
            if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
              return singleton;
            }
          }
          var concatSeq = new ArraySeq(iters);
          if (isKeyedCollection) {
            concatSeq = concatSeq.toKeyedSeq();
          } else if (!isIndexed(collection)) {
            concatSeq = concatSeq.toSetSeq();
          }
          concatSeq = concatSeq.flatten(true);
          concatSeq.size = iters.reduce(function (sum, seq) {
            if (sum !== undefined) {
              var size = seq.size;
              if (size !== undefined) {
                return sum + size;
              }
            }
          }, 0);
          return concatSeq;
        }
        function flattenFactory(collection, depth, useKeys) {
          var flatSequence = makeSequence(collection);
          flatSequence.__iterateUncached = function (fn, reverse) {
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var iterations = 0;
            var stopped = false;
            function flatDeep(iter, currentDepth) {
              iter.__iterate(function (v, k) {
                if ((!depth || currentDepth < depth) && isCollection(v)) {
                  flatDeep(v, currentDepth + 1);
                } else {
                  iterations++;
                  if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
                    stopped = true;
                  }
                }
                return !stopped;
              }, reverse);
            }
            flatDeep(collection, 0);
            return iterations;
          };
          flatSequence.__iteratorUncached = function (type, reverse) {
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = collection.__iterator(type, reverse);
            var stack = [];
            var iterations = 0;
            return new Iterator(function () {
              while (iterator) {
                var step = iterator.next();
                if (step.done !== false) {
                  iterator = stack.pop();
                  continue;
                }
                var v = step.value;
                if (type === ITERATE_ENTRIES) {
                  v = v[1];
                }
                if ((!depth || stack.length < depth) && isCollection(v)) {
                  stack.push(iterator);
                  iterator = v.__iterator(type, reverse);
                } else {
                  return useKeys ? step : iteratorValue(type, iterations++, v, step);
                }
              }
              return iteratorDone();
            });
          };
          return flatSequence;
        }
        function flatMapFactory(collection, mapper, context) {
          var coerce = collectionClass(collection);
          return collection.toSeq().map(function (v, k) {
            return coerce(mapper.call(context, v, k, collection));
          }).flatten(true);
        }
        function interposeFactory(collection, separator) {
          var interposedSequence = makeSequence(collection);
          interposedSequence.size = collection.size && collection.size * 2 - 1;
          interposedSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            var iterations = 0;
            collection.__iterate(function (v) {
              return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v, iterations++, this$1$1) !== false;
            }, reverse);
            return iterations;
          };
          interposedSequence.__iteratorUncached = function (type, reverse) {
            var iterator = collection.__iterator(ITERATE_VALUES, reverse);
            var iterations = 0;
            var step;
            return new Iterator(function () {
              if (!step || iterations % 2) {
                step = iterator.next();
                if (step.done) {
                  return step;
                }
              }
              return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
            });
          };
          return interposedSequence;
        }
        function sortFactory(collection, comparator, mapper) {
          if (!comparator) {
            comparator = defaultComparator;
          }
          var isKeyedCollection = isKeyed(collection);
          var index = 0;
          var entries = collection.toSeq().map(function (v, k) {
            return [k, v, index++, mapper ? mapper(v, k, collection) : v];
          }).valueSeq().toArray();
          entries.sort(function (a, b) {
            return comparator(a[3], b[3]) || a[2] - b[2];
          }).forEach(isKeyedCollection ? function (v, i) {
            entries[i].length = 2;
          } : function (v, i) {
            entries[i] = v[1];
          });
          return isKeyedCollection ? KeyedSeq(entries) : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);
        }
        function maxFactory(collection, comparator, mapper) {
          if (!comparator) {
            comparator = defaultComparator;
          }
          if (mapper) {
            var entry = collection.toSeq().map(function (v, k) {
              return [v, mapper(v, k, collection)];
            }).reduce(function (a, b) {
              return maxCompare(comparator, a[1], b[1]) ? b : a;
            });
            return entry && entry[0];
          }
          return collection.reduce(function (a, b) {
            return maxCompare(comparator, a, b) ? b : a;
          });
        }
        function maxCompare(comparator, a, b) {
          var comp = comparator(b, a);
          // b is considered the new max if the comparator declares them equal, but
          // they are not equal and b is in fact a nullish value.
          return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
        }
        function zipWithFactory(keyIter, zipper, iters, zipAll) {
          var zipSequence = makeSequence(keyIter);
          var sizes = new ArraySeq(iters).map(function (i) {
            return i.size;
          });
          zipSequence.size = zipAll ? sizes.max() : sizes.min();
          // Note: this a generic base implementation of __iterate in terms of
          // __iterator which may be more generically useful in the future.
          zipSequence.__iterate = function (fn, reverse) {
            /* generic:
            var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
            var step;
            var iterations = 0;
            while (!(step = iterator.next()).done) {
              iterations++;
              if (fn(step.value[1], step.value[0], this) === false) {
                break;
              }
            }
            return iterations;
            */
            // indexed:
            var iterator = this.__iterator(ITERATE_VALUES, reverse);
            var step;
            var iterations = 0;
            while (!(step = iterator.next()).done) {
              if (fn(step.value, iterations++, this) === false) {
                break;
              }
            }
            return iterations;
          };
          zipSequence.__iteratorUncached = function (type, reverse) {
            var iterators = iters.map(function (i) {
              return i = Collection(i), getIterator(reverse ? i.reverse() : i);
            });
            var iterations = 0;
            var isDone = false;
            return new Iterator(function () {
              var steps;
              if (!isDone) {
                steps = iterators.map(function (i) {
                  return i.next();
                });
                isDone = zipAll ? steps.every(function (s) {
                  return s.done;
                }) : steps.some(function (s) {
                  return s.done;
                });
              }
              if (isDone) {
                return iteratorDone();
              }
              return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
                return s.value;
              })));
            });
          };
          return zipSequence;
        }

        // #pragma Helper Functions

        function reify(iter, seq) {
          return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
        }
        function validateEntry(entry) {
          if (entry !== Object(entry)) {
            throw new TypeError('Expected [K, V] tuple: ' + entry);
          }
        }
        function collectionClass(collection) {
          return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
        }
        function makeSequence(collection) {
          return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);
        }
        function cacheResultThrough() {
          if (this._iter.cacheResult) {
            this._iter.cacheResult();
            this.size = this._iter.size;
            return this;
          }
          return Seq.prototype.cacheResult.call(this);
        }
        function defaultComparator(a, b) {
          if (a === undefined && b === undefined) {
            return 0;
          }
          if (a === undefined) {
            return 1;
          }
          if (b === undefined) {
            return -1;
          }
          return a > b ? 1 : a < b ? -1 : 0;
        }
        function arrCopy(arr, offset) {
          offset = offset || 0;
          var len = Math.max(0, arr.length - offset);
          var newArr = new Array(len);
          for (var ii = 0; ii < len; ii++) {
            newArr[ii] = arr[ii + offset];
          }
          return newArr;
        }
        function invariant$1(condition, error) {
          if (!condition) {
            throw new Error(error);
          }
        }
        function assertNotInfinite(size) {
          invariant$1(size !== Infinity, 'Cannot perform this action with an infinite size.');
        }
        function coerceKeyPath(keyPath) {
          if (isArrayLike(keyPath) && typeof keyPath !== 'string') {
            return keyPath;
          }
          if (isOrdered(keyPath)) {
            return keyPath.toArray();
          }
          throw new TypeError('Invalid keyPath: expected Ordered Collection or Array: ' + keyPath);
        }
        var toString = Object.prototype.toString;
        function isPlainObject$1(value) {
          // The base prototype's toString deals with Argument objects and native namespaces like Math
          if (!value || typeof value !== 'object' || toString.call(value) !== '[object Object]') {
            return false;
          }
          var proto = Object.getPrototypeOf(value);
          if (proto === null) {
            return true;
          }

          // Iteratively going up the prototype chain is needed for cross-realm environments (differing contexts, iframes, etc)
          var parentProto = proto;
          var nextProto = Object.getPrototypeOf(proto);
          while (nextProto !== null) {
            parentProto = nextProto;
            nextProto = Object.getPrototypeOf(parentProto);
          }
          return parentProto === proto;
        }

        /**
         * Returns true if the value is a potentially-persistent data structure, either
         * provided by Immutable.js or a plain Array or Object.
         */
        function isDataStructure(value) {
          return typeof value === 'object' && (isImmutable(value) || Array.isArray(value) || isPlainObject$1(value));
        }
        function quoteString(value) {
          try {
            return typeof value === 'string' ? JSON.stringify(value) : String(value);
          } catch (_ignoreError) {
            return JSON.stringify(value);
          }
        }
        function has(collection, key) {
          return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty$1.call(collection, key);
        }
        function get(collection, key, notSetValue) {
          return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === 'function' ? collection.get(key) : collection[key];
        }
        function shallowCopy(from) {
          if (Array.isArray(from)) {
            return arrCopy(from);
          }
          var to = {};
          for (var key in from) {
            if (hasOwnProperty$1.call(from, key)) {
              to[key] = from[key];
            }
          }
          return to;
        }
        function remove(collection, key) {
          if (!isDataStructure(collection)) {
            throw new TypeError('Cannot update non-data-structure value: ' + collection);
          }
          if (isImmutable(collection)) {
            if (!collection.remove) {
              throw new TypeError('Cannot update immutable value without .remove() method: ' + collection);
            }
            return collection.remove(key);
          }
          if (!hasOwnProperty$1.call(collection, key)) {
            return collection;
          }
          var collectionCopy = shallowCopy(collection);
          if (Array.isArray(collectionCopy)) {
            collectionCopy.splice(key, 1);
          } else {
            delete collectionCopy[key];
          }
          return collectionCopy;
        }
        function set(collection, key, value) {
          if (!isDataStructure(collection)) {
            throw new TypeError('Cannot update non-data-structure value: ' + collection);
          }
          if (isImmutable(collection)) {
            if (!collection.set) {
              throw new TypeError('Cannot update immutable value without .set() method: ' + collection);
            }
            return collection.set(key, value);
          }
          if (hasOwnProperty$1.call(collection, key) && value === collection[key]) {
            return collection;
          }
          var collectionCopy = shallowCopy(collection);
          collectionCopy[key] = value;
          return collectionCopy;
        }
        function updateIn$1(collection, keyPath, notSetValue, updater) {
          if (!updater) {
            updater = notSetValue;
            notSetValue = undefined;
          }
          var updatedValue = updateInDeeply(isImmutable(collection), collection, coerceKeyPath(keyPath), 0, notSetValue, updater);
          return updatedValue === NOT_SET ? notSetValue : updatedValue;
        }
        function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {
          var wasNotSet = existing === NOT_SET;
          if (i === keyPath.length) {
            var existingValue = wasNotSet ? notSetValue : existing;
            var newValue = updater(existingValue);
            return newValue === existingValue ? existing : newValue;
          }
          if (!wasNotSet && !isDataStructure(existing)) {
            throw new TypeError('Cannot update within non-data-structure value in path [' + keyPath.slice(0, i).map(quoteString) + ']: ' + existing);
          }
          var key = keyPath[i];
          var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
          var nextUpdated = updateInDeeply(nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting), nextExisting, keyPath, i + 1, notSetValue, updater);
          return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(wasNotSet ? inImmutable ? emptyMap() : {} : existing, key, nextUpdated);
        }
        function setIn$1(collection, keyPath, value) {
          return updateIn$1(collection, keyPath, NOT_SET, function () {
            return value;
          });
        }
        function setIn(keyPath, v) {
          return setIn$1(this, keyPath, v);
        }
        function removeIn(collection, keyPath) {
          return updateIn$1(collection, keyPath, function () {
            return NOT_SET;
          });
        }
        function deleteIn(keyPath) {
          return removeIn(this, keyPath);
        }
        function update$1(collection, key, notSetValue, updater) {
          return updateIn$1(collection, [key], notSetValue, updater);
        }
        function update$2(key, notSetValue, updater) {
          return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);
        }
        function updateIn(keyPath, notSetValue, updater) {
          return updateIn$1(this, keyPath, notSetValue, updater);
        }
        function merge$1() {
          var iters = [],
            len = arguments.length;
          while (len--) iters[len] = arguments[len];
          return mergeIntoKeyedWith(this, iters);
        }
        function mergeWith$1(merger) {
          var iters = [],
            len = arguments.length - 1;
          while (len-- > 0) iters[len] = arguments[len + 1];
          if (typeof merger !== 'function') {
            throw new TypeError('Invalid merger function: ' + merger);
          }
          return mergeIntoKeyedWith(this, iters, merger);
        }
        function mergeIntoKeyedWith(collection, collections, merger) {
          var iters = [];
          for (var ii = 0; ii < collections.length; ii++) {
            var collection$1 = KeyedCollection(collections[ii]);
            if (collection$1.size !== 0) {
              iters.push(collection$1);
            }
          }
          if (iters.length === 0) {
            return collection;
          }
          if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
            return collection.constructor(iters[0]);
          }
          return collection.withMutations(function (collection) {
            var mergeIntoCollection = merger ? function (value, key) {
              update$1(collection, key, NOT_SET, function (oldVal) {
                return oldVal === NOT_SET ? value : merger(oldVal, value, key);
              });
            } : function (value, key) {
              collection.set(key, value);
            };
            for (var ii = 0; ii < iters.length; ii++) {
              iters[ii].forEach(mergeIntoCollection);
            }
          });
        }
        function merge(collection) {
          var sources = [],
            len = arguments.length - 1;
          while (len-- > 0) sources[len] = arguments[len + 1];
          return mergeWithSources(collection, sources);
        }
        function mergeWith(merger, collection) {
          var sources = [],
            len = arguments.length - 2;
          while (len-- > 0) sources[len] = arguments[len + 2];
          return mergeWithSources(collection, sources, merger);
        }
        function mergeDeep$1(collection) {
          var sources = [],
            len = arguments.length - 1;
          while (len-- > 0) sources[len] = arguments[len + 1];
          return mergeDeepWithSources(collection, sources);
        }
        function mergeDeepWith$1(merger, collection) {
          var sources = [],
            len = arguments.length - 2;
          while (len-- > 0) sources[len] = arguments[len + 2];
          return mergeDeepWithSources(collection, sources, merger);
        }
        function mergeDeepWithSources(collection, sources, merger) {
          return mergeWithSources(collection, sources, deepMergerWith(merger));
        }
        function mergeWithSources(collection, sources, merger) {
          if (!isDataStructure(collection)) {
            throw new TypeError('Cannot merge into non-data-structure value: ' + collection);
          }
          if (isImmutable(collection)) {
            return typeof merger === 'function' && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
          }
          var isArray = Array.isArray(collection);
          var merged = collection;
          var Collection = isArray ? IndexedCollection : KeyedCollection;
          var mergeItem = isArray ? function (value) {
            // Copy on write
            if (merged === collection) {
              merged = shallowCopy(merged);
            }
            merged.push(value);
          } : function (value, key) {
            var hasVal = hasOwnProperty$1.call(merged, key);
            var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
            if (!hasVal || nextVal !== merged[key]) {
              // Copy on write
              if (merged === collection) {
                merged = shallowCopy(merged);
              }
              merged[key] = nextVal;
            }
          };
          for (var i = 0; i < sources.length; i++) {
            Collection(sources[i]).forEach(mergeItem);
          }
          return merged;
        }
        function deepMergerWith(merger) {
          function deepMerger(oldValue, newValue, key) {
            return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
          }
          return deepMerger;
        }

        /**
         * It's unclear what the desired behavior is for merging two collections that
         * fall into separate categories between keyed, indexed, or set-like, so we only
         * consider them mergeable if they fall into the same category.
         */
        function areMergeable(oldDataStructure, newDataStructure) {
          var oldSeq = Seq(oldDataStructure);
          var newSeq = Seq(newDataStructure);
          // This logic assumes that a sequence can only fall into one of the three
          // categories mentioned above (since there's no `isSetLike()` method).
          return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
        }
        function mergeDeep() {
          var iters = [],
            len = arguments.length;
          while (len--) iters[len] = arguments[len];
          return mergeDeepWithSources(this, iters);
        }
        function mergeDeepWith(merger) {
          var iters = [],
            len = arguments.length - 1;
          while (len-- > 0) iters[len] = arguments[len + 1];
          return mergeDeepWithSources(this, iters, merger);
        }
        function mergeIn(keyPath) {
          var iters = [],
            len = arguments.length - 1;
          while (len-- > 0) iters[len] = arguments[len + 1];
          return updateIn$1(this, keyPath, emptyMap(), function (m) {
            return mergeWithSources(m, iters);
          });
        }
        function mergeDeepIn(keyPath) {
          var iters = [],
            len = arguments.length - 1;
          while (len-- > 0) iters[len] = arguments[len + 1];
          return updateIn$1(this, keyPath, emptyMap(), function (m) {
            return mergeDeepWithSources(m, iters);
          });
        }
        function withMutations(fn) {
          var mutable = this.asMutable();
          fn(mutable);
          return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
        }
        function asMutable() {
          return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
        }
        function asImmutable() {
          return this.__ensureOwner();
        }
        function wasAltered() {
          return this.__altered;
        }
        var Map$1 = /*@__PURE__*/function (KeyedCollection) {
          function Map(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {
              var iter = KeyedCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v, k) {
                return map.set(k, v);
              });
            });
          }
          if (KeyedCollection) Map.__proto__ = KeyedCollection;
          Map.prototype = Object.create(KeyedCollection && KeyedCollection.prototype);
          Map.prototype.constructor = Map;
          Map.of = function of() {
            var keyValues = [],
              len = arguments.length;
            while (len--) keyValues[len] = arguments[len];
            return emptyMap().withMutations(function (map) {
              for (var i = 0; i < keyValues.length; i += 2) {
                if (i + 1 >= keyValues.length) {
                  throw new Error('Missing value for key: ' + keyValues[i]);
                }
                map.set(keyValues[i], keyValues[i + 1]);
              }
            });
          };
          Map.prototype.toString = function toString() {
            return this.__toString('Map {', '}');
          };

          // @pragma Access

          Map.prototype.get = function get(k, notSetValue) {
            return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
          };

          // @pragma Modification

          Map.prototype.set = function set(k, v) {
            return updateMap(this, k, v);
          };
          Map.prototype.remove = function remove(k) {
            return updateMap(this, k, NOT_SET);
          };
          Map.prototype.deleteAll = function deleteAll(keys) {
            var collection = Collection(keys);
            if (collection.size === 0) {
              return this;
            }
            return this.withMutations(function (map) {
              collection.forEach(function (key) {
                return map.remove(key);
              });
            });
          };
          Map.prototype.clear = function clear() {
            if (this.size === 0) {
              return this;
            }
            if (this.__ownerID) {
              this.size = 0;
              this._root = null;
              this.__hash = undefined;
              this.__altered = true;
              return this;
            }
            return emptyMap();
          };

          // @pragma Composition

          Map.prototype.sort = function sort(comparator) {
            // Late binding
            return OrderedMap(sortFactory(this, comparator));
          };
          Map.prototype.sortBy = function sortBy(mapper, comparator) {
            // Late binding
            return OrderedMap(sortFactory(this, comparator, mapper));
          };
          Map.prototype.map = function map(mapper, context) {
            var this$1$1 = this;
            return this.withMutations(function (map) {
              map.forEach(function (value, key) {
                map.set(key, mapper.call(context, value, key, this$1$1));
              });
            });
          };

          // @pragma Mutability

          Map.prototype.__iterator = function __iterator(type, reverse) {
            return new MapIterator(this, type, reverse);
          };
          Map.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            var iterations = 0;
            this._root && this._root.iterate(function (entry) {
              iterations++;
              return fn(entry[1], entry[0], this$1$1);
            }, reverse);
            return iterations;
          };
          Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
              return this;
            }
            if (!ownerID) {
              if (this.size === 0) {
                return emptyMap();
              }
              this.__ownerID = ownerID;
              this.__altered = false;
              return this;
            }
            return makeMap(this.size, this._root, ownerID, this.__hash);
          };
          return Map;
        }(KeyedCollection);
        Map$1.isMap = isMap;
        var MapPrototype = Map$1.prototype;
        MapPrototype[IS_MAP_SYMBOL] = true;
        MapPrototype[DELETE] = MapPrototype.remove;
        MapPrototype.removeAll = MapPrototype.deleteAll;
        MapPrototype.setIn = setIn;
        MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
        MapPrototype.update = update$2;
        MapPrototype.updateIn = updateIn;
        MapPrototype.merge = MapPrototype.concat = merge$1;
        MapPrototype.mergeWith = mergeWith$1;
        MapPrototype.mergeDeep = mergeDeep;
        MapPrototype.mergeDeepWith = mergeDeepWith;
        MapPrototype.mergeIn = mergeIn;
        MapPrototype.mergeDeepIn = mergeDeepIn;
        MapPrototype.withMutations = withMutations;
        MapPrototype.wasAltered = wasAltered;
        MapPrototype.asImmutable = asImmutable;
        MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;
        MapPrototype['@@transducer/step'] = function (result, arr) {
          return result.set(arr[0], arr[1]);
        };
        MapPrototype['@@transducer/result'] = function (obj) {
          return obj.asImmutable();
        };

        // #pragma Trie Nodes

        var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
          this.ownerID = ownerID;
          this.entries = entries;
        };
        ArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          var entries = this.entries;
          for (var ii = 0, len = entries.length; ii < len; ii++) {
            if (is(key, entries[ii][0])) {
              return entries[ii][1];
            }
          }
          return notSetValue;
        };
        ArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          var removed = value === NOT_SET;
          var entries = this.entries;
          var idx = 0;
          var len = entries.length;
          for (; idx < len; idx++) {
            if (is(key, entries[idx][0])) {
              break;
            }
          }
          var exists = idx < len;
          if (exists ? entries[idx][1] === value : removed) {
            return this;
          }
          SetRef(didAlter);
          (removed || !exists) && SetRef(didChangeSize);
          if (removed && entries.length === 1) {
            return; // undefined
          }
          if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
            return createNodes(ownerID, entries, key, value);
          }
          var isEditable = ownerID && ownerID === this.ownerID;
          var newEntries = isEditable ? entries : arrCopy(entries);
          if (exists) {
            if (removed) {
              idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
            } else {
              newEntries[idx] = [key, value];
            }
          } else {
            newEntries.push([key, value]);
          }
          if (isEditable) {
            this.entries = newEntries;
            return this;
          }
          return new ArrayMapNode(ownerID, newEntries);
        };
        var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
          this.ownerID = ownerID;
          this.bitmap = bitmap;
          this.nodes = nodes;
        };
        BitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
          var bitmap = this.bitmap;
          return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
        };
        BitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var bit = 1 << keyHashFrag;
          var bitmap = this.bitmap;
          var exists = (bitmap & bit) !== 0;
          if (!exists && value === NOT_SET) {
            return this;
          }
          var idx = popCount(bitmap & bit - 1);
          var nodes = this.nodes;
          var node = exists ? nodes[idx] : undefined;
          var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
          if (newNode === node) {
            return this;
          }
          if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
            return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
          }
          if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
            return nodes[idx ^ 1];
          }
          if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
            return newNode;
          }
          var isEditable = ownerID && ownerID === this.ownerID;
          var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
          var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
          if (isEditable) {
            this.bitmap = newBitmap;
            this.nodes = newNodes;
            return this;
          }
          return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
        };
        var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
          this.ownerID = ownerID;
          this.count = count;
          this.nodes = nodes;
        };
        HashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var node = this.nodes[idx];
          return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
        };
        HashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var removed = value === NOT_SET;
          var nodes = this.nodes;
          var node = nodes[idx];
          if (removed && !node) {
            return this;
          }
          var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
          if (newNode === node) {
            return this;
          }
          var newCount = this.count;
          if (!node) {
            newCount++;
          } else if (!newNode) {
            newCount--;
            if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
              return packNodes(ownerID, nodes, newCount, idx);
            }
          }
          var isEditable = ownerID && ownerID === this.ownerID;
          var newNodes = setAt(nodes, idx, newNode, isEditable);
          if (isEditable) {
            this.count = newCount;
            this.nodes = newNodes;
            return this;
          }
          return new HashArrayMapNode(ownerID, newCount, newNodes);
        };
        var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
          this.ownerID = ownerID;
          this.keyHash = keyHash;
          this.entries = entries;
        };
        HashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          var entries = this.entries;
          for (var ii = 0, len = entries.length; ii < len; ii++) {
            if (is(key, entries[ii][0])) {
              return entries[ii][1];
            }
          }
          return notSetValue;
        };
        HashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var removed = value === NOT_SET;
          if (keyHash !== this.keyHash) {
            if (removed) {
              return this;
            }
            SetRef(didAlter);
            SetRef(didChangeSize);
            return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
          }
          var entries = this.entries;
          var idx = 0;
          var len = entries.length;
          for (; idx < len; idx++) {
            if (is(key, entries[idx][0])) {
              break;
            }
          }
          var exists = idx < len;
          if (exists ? entries[idx][1] === value : removed) {
            return this;
          }
          SetRef(didAlter);
          (removed || !exists) && SetRef(didChangeSize);
          if (removed && len === 2) {
            return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
          }
          var isEditable = ownerID && ownerID === this.ownerID;
          var newEntries = isEditable ? entries : arrCopy(entries);
          if (exists) {
            if (removed) {
              idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
            } else {
              newEntries[idx] = [key, value];
            }
          } else {
            newEntries.push([key, value]);
          }
          if (isEditable) {
            this.entries = newEntries;
            return this;
          }
          return new HashCollisionNode(ownerID, this.keyHash, newEntries);
        };
        var ValueNode = function ValueNode(ownerID, keyHash, entry) {
          this.ownerID = ownerID;
          this.keyHash = keyHash;
          this.entry = entry;
        };
        ValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
        };
        ValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          var removed = value === NOT_SET;
          var keyMatch = is(key, this.entry[0]);
          if (keyMatch ? value === this.entry[1] : removed) {
            return this;
          }
          SetRef(didAlter);
          if (removed) {
            SetRef(didChangeSize);
            return; // undefined
          }
          if (keyMatch) {
            if (ownerID && ownerID === this.ownerID) {
              this.entry[1] = value;
              return this;
            }
            return new ValueNode(ownerID, this.keyHash, [key, value]);
          }
          SetRef(didChangeSize);
          return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
        };

        // #pragma Iterators

        ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
          var entries = this.entries;
          for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
            if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
              return false;
            }
          }
        };
        BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
          var nodes = this.nodes;
          for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
            var node = nodes[reverse ? maxIndex - ii : ii];
            if (node && node.iterate(fn, reverse) === false) {
              return false;
            }
          }
        };

        // eslint-disable-next-line no-unused-vars
        ValueNode.prototype.iterate = function (fn, reverse) {
          return fn(this.entry);
        };
        var MapIterator = /*@__PURE__*/function (Iterator) {
          function MapIterator(map, type, reverse) {
            this._type = type;
            this._reverse = reverse;
            this._stack = map._root && mapIteratorFrame(map._root);
          }
          if (Iterator) MapIterator.__proto__ = Iterator;
          MapIterator.prototype = Object.create(Iterator && Iterator.prototype);
          MapIterator.prototype.constructor = MapIterator;
          MapIterator.prototype.next = function next() {
            var type = this._type;
            var stack = this._stack;
            while (stack) {
              var node = stack.node;
              var index = stack.index++;
              var maxIndex = void 0;
              if (node.entry) {
                if (index === 0) {
                  return mapIteratorValue(type, node.entry);
                }
              } else if (node.entries) {
                maxIndex = node.entries.length - 1;
                if (index <= maxIndex) {
                  return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
                }
              } else {
                maxIndex = node.nodes.length - 1;
                if (index <= maxIndex) {
                  var subNode = node.nodes[this._reverse ? maxIndex - index : index];
                  if (subNode) {
                    if (subNode.entry) {
                      return mapIteratorValue(type, subNode.entry);
                    }
                    stack = this._stack = mapIteratorFrame(subNode, stack);
                  }
                  continue;
                }
              }
              stack = this._stack = this._stack.__prev;
            }
            return iteratorDone();
          };
          return MapIterator;
        }(Iterator);
        function mapIteratorValue(type, entry) {
          return iteratorValue(type, entry[0], entry[1]);
        }
        function mapIteratorFrame(node, prev) {
          return {
            node: node,
            index: 0,
            __prev: prev
          };
        }
        function makeMap(size, root, ownerID, hash) {
          var map = Object.create(MapPrototype);
          map.size = size;
          map._root = root;
          map.__ownerID = ownerID;
          map.__hash = hash;
          map.__altered = false;
          return map;
        }
        var EMPTY_MAP;
        function emptyMap() {
          return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
        }
        function updateMap(map, k, v) {
          var newRoot;
          var newSize;
          if (!map._root) {
            if (v === NOT_SET) {
              return map;
            }
            newSize = 1;
            newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
          } else {
            var didChangeSize = MakeRef();
            var didAlter = MakeRef();
            newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
            if (!didAlter.value) {
              return map;
            }
            newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
          }
          if (map.__ownerID) {
            map.size = newSize;
            map._root = newRoot;
            map.__hash = undefined;
            map.__altered = true;
            return map;
          }
          return newRoot ? makeMap(newSize, newRoot) : emptyMap();
        }
        function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (!node) {
            if (value === NOT_SET) {
              return node;
            }
            SetRef(didAlter);
            SetRef(didChangeSize);
            return new ValueNode(ownerID, keyHash, [key, value]);
          }
          return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
        }
        function isLeafNode(node) {
          return node.constructor === ValueNode || node.constructor === HashCollisionNode;
        }
        function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
          if (node.keyHash === keyHash) {
            return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
          }
          var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
          var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var newNode;
          var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
          return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
        }
        function createNodes(ownerID, entries, key, value) {
          if (!ownerID) {
            ownerID = new OwnerID();
          }
          var node = new ValueNode(ownerID, hash(key), [key, value]);
          for (var ii = 0; ii < entries.length; ii++) {
            var entry = entries[ii];
            node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
          }
          return node;
        }
        function packNodes(ownerID, nodes, count, excluding) {
          var bitmap = 0;
          var packedII = 0;
          var packedNodes = new Array(count);
          for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
            var node = nodes[ii];
            if (node !== undefined && ii !== excluding) {
              bitmap |= bit;
              packedNodes[packedII++] = node;
            }
          }
          return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
        }
        function expandNodes(ownerID, nodes, bitmap, including, node) {
          var count = 0;
          var expandedNodes = new Array(SIZE);
          for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
            expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
          }
          expandedNodes[including] = node;
          return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
        }
        function popCount(x) {
          x -= x >> 1 & 0x55555555;
          x = (x & 0x33333333) + (x >> 2 & 0x33333333);
          x = x + (x >> 4) & 0x0f0f0f0f;
          x += x >> 8;
          x += x >> 16;
          return x & 0x7f;
        }
        function setAt(array, idx, val, canEdit) {
          var newArray = canEdit ? array : arrCopy(array);
          newArray[idx] = val;
          return newArray;
        }
        function spliceIn(array, idx, val, canEdit) {
          var newLen = array.length + 1;
          if (canEdit && idx + 1 === newLen) {
            array[idx] = val;
            return array;
          }
          var newArray = new Array(newLen);
          var after = 0;
          for (var ii = 0; ii < newLen; ii++) {
            if (ii === idx) {
              newArray[ii] = val;
              after = -1;
            } else {
              newArray[ii] = array[ii + after];
            }
          }
          return newArray;
        }
        function spliceOut(array, idx, canEdit) {
          var newLen = array.length - 1;
          if (canEdit && idx === newLen) {
            array.pop();
            return array;
          }
          var newArray = new Array(newLen);
          var after = 0;
          for (var ii = 0; ii < newLen; ii++) {
            if (ii === idx) {
              after = 1;
            }
            newArray[ii] = array[ii + after];
          }
          return newArray;
        }
        var MAX_ARRAY_MAP_SIZE = SIZE / 4;
        var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
        var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
        var IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';
        function isList(maybeList) {
          return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
        }
        var List = /*@__PURE__*/function (IndexedCollection) {
          function List(value) {
            var empty = emptyList();
            if (value === undefined || value === null) {
              // eslint-disable-next-line no-constructor-return
              return empty;
            }
            if (isList(value)) {
              // eslint-disable-next-line no-constructor-return
              return value;
            }
            var iter = IndexedCollection(value);
            var size = iter.size;
            if (size === 0) {
              // eslint-disable-next-line no-constructor-return
              return empty;
            }
            assertNotInfinite(size);
            if (size > 0 && size < SIZE) {
              // eslint-disable-next-line no-constructor-return
              return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
            }
            // eslint-disable-next-line no-constructor-return
            return empty.withMutations(function (list) {
              list.setSize(size);
              iter.forEach(function (v, i) {
                return list.set(i, v);
              });
            });
          }
          if (IndexedCollection) List.__proto__ = IndexedCollection;
          List.prototype = Object.create(IndexedCollection && IndexedCollection.prototype);
          List.prototype.constructor = List;
          List.of = function of(/*...values*/
          ) {
            return this(arguments);
          };
          List.prototype.toString = function toString() {
            return this.__toString('List [', ']');
          };

          // @pragma Access

          List.prototype.get = function get(index, notSetValue) {
            index = wrapIndex(this, index);
            if (index >= 0 && index < this.size) {
              index += this._origin;
              var node = listNodeFor(this, index);
              return node && node.array[index & MASK];
            }
            return notSetValue;
          };

          // @pragma Modification

          List.prototype.set = function set(index, value) {
            return updateList(this, index, value);
          };
          List.prototype.remove = function remove(index) {
            return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
          };
          List.prototype.insert = function insert(index, value) {
            return this.splice(index, 0, value);
          };
          List.prototype.clear = function clear() {
            if (this.size === 0) {
              return this;
            }
            if (this.__ownerID) {
              this.size = this._origin = this._capacity = 0;
              this._level = SHIFT;
              this._root = this._tail = this.__hash = undefined;
              this.__altered = true;
              return this;
            }
            return emptyList();
          };
          List.prototype.push = function push(/*...values*/
          ) {
            var values = arguments;
            var oldSize = this.size;
            return this.withMutations(function (list) {
              setListBounds(list, 0, oldSize + values.length);
              for (var ii = 0; ii < values.length; ii++) {
                list.set(oldSize + ii, values[ii]);
              }
            });
          };
          List.prototype.pop = function pop() {
            return setListBounds(this, 0, -1);
          };
          List.prototype.unshift = function unshift(/*...values*/
          ) {
            var values = arguments;
            return this.withMutations(function (list) {
              setListBounds(list, -values.length);
              for (var ii = 0; ii < values.length; ii++) {
                list.set(ii, values[ii]);
              }
            });
          };
          List.prototype.shift = function shift() {
            return setListBounds(this, 1);
          };

          // @pragma Composition

          List.prototype.concat = function concat(/*...collections*/
          ) {
            var arguments$1 = arguments;
            var seqs = [];
            for (var i = 0; i < arguments.length; i++) {
              var argument = arguments$1[i];
              var seq = IndexedCollection(typeof argument !== 'string' && hasIterator(argument) ? argument : [argument]);
              if (seq.size !== 0) {
                seqs.push(seq);
              }
            }
            if (seqs.length === 0) {
              return this;
            }
            if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
              return this.constructor(seqs[0]);
            }
            return this.withMutations(function (list) {
              seqs.forEach(function (seq) {
                return seq.forEach(function (value) {
                  return list.push(value);
                });
              });
            });
          };
          List.prototype.setSize = function setSize(size) {
            return setListBounds(this, 0, size);
          };
          List.prototype.map = function map(mapper, context) {
            var this$1$1 = this;
            return this.withMutations(function (list) {
              for (var i = 0; i < this$1$1.size; i++) {
                list.set(i, mapper.call(context, list.get(i), i, this$1$1));
              }
            });
          };

          // @pragma Iteration

          List.prototype.slice = function slice(begin, end) {
            var size = this.size;
            if (wholeSlice(begin, end, size)) {
              return this;
            }
            return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
          };
          List.prototype.__iterator = function __iterator(type, reverse) {
            var index = reverse ? this.size : 0;
            var values = iterateList(this, reverse);
            return new Iterator(function () {
              var value = values();
              return value === DONE ? iteratorDone() : iteratorValue(type, reverse ? --index : index++, value);
            });
          };
          List.prototype.__iterate = function __iterate(fn, reverse) {
            var index = reverse ? this.size : 0;
            var values = iterateList(this, reverse);
            var value;
            while ((value = values()) !== DONE) {
              if (fn(value, reverse ? --index : index++, this) === false) {
                break;
              }
            }
            return index;
          };
          List.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
              return this;
            }
            if (!ownerID) {
              if (this.size === 0) {
                return emptyList();
              }
              this.__ownerID = ownerID;
              this.__altered = false;
              return this;
            }
            return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
          };
          return List;
        }(IndexedCollection);
        List.isList = isList;
        var ListPrototype = List.prototype;
        ListPrototype[IS_LIST_SYMBOL] = true;
        ListPrototype[DELETE] = ListPrototype.remove;
        ListPrototype.merge = ListPrototype.concat;
        ListPrototype.setIn = setIn;
        ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
        ListPrototype.update = update$2;
        ListPrototype.updateIn = updateIn;
        ListPrototype.mergeIn = mergeIn;
        ListPrototype.mergeDeepIn = mergeDeepIn;
        ListPrototype.withMutations = withMutations;
        ListPrototype.wasAltered = wasAltered;
        ListPrototype.asImmutable = asImmutable;
        ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;
        ListPrototype['@@transducer/step'] = function (result, arr) {
          return result.push(arr);
        };
        ListPrototype['@@transducer/result'] = function (obj) {
          return obj.asImmutable();
        };
        var VNode = function VNode(array, ownerID) {
          this.array = array;
          this.ownerID = ownerID;
        };

        // TODO: seems like these methods are very similar

        VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
          if (index === level ? 1 << level : this.array.length === 0) {
            return this;
          }
          var originIndex = index >>> level & MASK;
          if (originIndex >= this.array.length) {
            return new VNode([], ownerID);
          }
          var removingFirst = originIndex === 0;
          var newChild;
          if (level > 0) {
            var oldChild = this.array[originIndex];
            newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
            if (newChild === oldChild && removingFirst) {
              return this;
            }
          }
          if (removingFirst && !newChild) {
            return this;
          }
          var editable = editableVNode(this, ownerID);
          if (!removingFirst) {
            for (var ii = 0; ii < originIndex; ii++) {
              editable.array[ii] = undefined;
            }
          }
          if (newChild) {
            editable.array[originIndex] = newChild;
          }
          return editable;
        };
        VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
          if (index === (level ? 1 << level : 0) || this.array.length === 0) {
            return this;
          }
          var sizeIndex = index - 1 >>> level & MASK;
          if (sizeIndex >= this.array.length) {
            return this;
          }
          var newChild;
          if (level > 0) {
            var oldChild = this.array[sizeIndex];
            newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
            if (newChild === oldChild && sizeIndex === this.array.length - 1) {
              return this;
            }
          }
          var editable = editableVNode(this, ownerID);
          editable.array.splice(sizeIndex + 1);
          if (newChild) {
            editable.array[sizeIndex] = newChild;
          }
          return editable;
        };
        var DONE = {};
        function iterateList(list, reverse) {
          var left = list._origin;
          var right = list._capacity;
          var tailPos = getTailOffset(right);
          var tail = list._tail;
          return iterateNodeOrLeaf(list._root, list._level, 0);
          function iterateNodeOrLeaf(node, level, offset) {
            return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
          }
          function iterateLeaf(node, offset) {
            var array = offset === tailPos ? tail && tail.array : node && node.array;
            var from = offset > left ? 0 : left - offset;
            var to = right - offset;
            if (to > SIZE) {
              to = SIZE;
            }
            return function () {
              if (from === to) {
                return DONE;
              }
              var idx = reverse ? --to : from++;
              return array && array[idx];
            };
          }
          function iterateNode(node, level, offset) {
            var values;
            var array = node && node.array;
            var from = offset > left ? 0 : left - offset >> level;
            var to = (right - offset >> level) + 1;
            if (to > SIZE) {
              to = SIZE;
            }
            return function () {
              while (true) {
                if (values) {
                  var value = values();
                  if (value !== DONE) {
                    return value;
                  }
                  values = null;
                }
                if (from === to) {
                  return DONE;
                }
                var idx = reverse ? --to : from++;
                values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
              }
            };
          }
        }
        function makeList(origin, capacity, level, root, tail, ownerID, hash) {
          var list = Object.create(ListPrototype);
          list.size = capacity - origin;
          list._origin = origin;
          list._capacity = capacity;
          list._level = level;
          list._root = root;
          list._tail = tail;
          list.__ownerID = ownerID;
          list.__hash = hash;
          list.__altered = false;
          return list;
        }
        var EMPTY_LIST;
        function emptyList() {
          return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
        }
        function updateList(list, index, value) {
          index = wrapIndex(list, index);
          if (index !== index) {
            return list;
          }
          if (index >= list.size || index < 0) {
            return list.withMutations(function (list) {
              index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
            });
          }
          index += list._origin;
          var newTail = list._tail;
          var newRoot = list._root;
          var didAlter = MakeRef();
          if (index >= getTailOffset(list._capacity)) {
            newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
          } else {
            newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
          }
          if (!didAlter.value) {
            return list;
          }
          if (list.__ownerID) {
            list._root = newRoot;
            list._tail = newTail;
            list.__hash = undefined;
            list.__altered = true;
            return list;
          }
          return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
        }
        function updateVNode(node, ownerID, level, index, value, didAlter) {
          var idx = index >>> level & MASK;
          var nodeHas = node && idx < node.array.length;
          if (!nodeHas && value === undefined) {
            return node;
          }
          var newNode;
          if (level > 0) {
            var lowerNode = node && node.array[idx];
            var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
            if (newLowerNode === lowerNode) {
              return node;
            }
            newNode = editableVNode(node, ownerID);
            newNode.array[idx] = newLowerNode;
            return newNode;
          }
          if (nodeHas && node.array[idx] === value) {
            return node;
          }
          if (didAlter) {
            SetRef(didAlter);
          }
          newNode = editableVNode(node, ownerID);
          if (value === undefined && idx === newNode.array.length - 1) {
            newNode.array.pop();
          } else {
            newNode.array[idx] = value;
          }
          return newNode;
        }
        function editableVNode(node, ownerID) {
          if (ownerID && node && ownerID === node.ownerID) {
            return node;
          }
          return new VNode(node ? node.array.slice() : [], ownerID);
        }
        function listNodeFor(list, rawIndex) {
          if (rawIndex >= getTailOffset(list._capacity)) {
            return list._tail;
          }
          if (rawIndex < 1 << list._level + SHIFT) {
            var node = list._root;
            var level = list._level;
            while (node && level > 0) {
              node = node.array[rawIndex >>> level & MASK];
              level -= SHIFT;
            }
            return node;
          }
        }
        function setListBounds(list, begin, end) {
          // Sanitize begin & end using this shorthand for ToInt32(argument)
          // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
          if (begin !== undefined) {
            begin |= 0;
          }
          if (end !== undefined) {
            end |= 0;
          }
          var owner = list.__ownerID || new OwnerID();
          var oldOrigin = list._origin;
          var oldCapacity = list._capacity;
          var newOrigin = oldOrigin + begin;
          var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
          if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
            return list;
          }

          // If it's going to end after it starts, it's empty.
          if (newOrigin >= newCapacity) {
            return list.clear();
          }
          var newLevel = list._level;
          var newRoot = list._root;

          // New origin might need creating a higher root.
          var offsetShift = 0;
          while (newOrigin + offsetShift < 0) {
            newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
            newLevel += SHIFT;
            offsetShift += 1 << newLevel;
          }
          if (offsetShift) {
            newOrigin += offsetShift;
            oldOrigin += offsetShift;
            newCapacity += offsetShift;
            oldCapacity += offsetShift;
          }
          var oldTailOffset = getTailOffset(oldCapacity);
          var newTailOffset = getTailOffset(newCapacity);

          // New size might need creating a higher root.
          while (newTailOffset >= 1 << newLevel + SHIFT) {
            newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
            newLevel += SHIFT;
          }

          // Locate or create the new tail.
          var oldTail = list._tail;
          var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

          // Merge Tail into tree.
          if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
            newRoot = editableVNode(newRoot, owner);
            var node = newRoot;
            for (var level = newLevel; level > SHIFT; level -= SHIFT) {
              var idx = oldTailOffset >>> level & MASK;
              node = node.array[idx] = editableVNode(node.array[idx], owner);
            }
            node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
          }

          // If the size has been reduced, there's a chance the tail needs to be trimmed.
          if (newCapacity < oldCapacity) {
            newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
          }

          // If the new origin is within the tail, then we do not need a root.
          if (newOrigin >= newTailOffset) {
            newOrigin -= newTailOffset;
            newCapacity -= newTailOffset;
            newLevel = SHIFT;
            newRoot = null;
            newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

            // Otherwise, if the root has been trimmed, garbage collect.
          } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
            offsetShift = 0;

            // Identify the new top root node of the subtree of the old root.
            while (newRoot) {
              var beginIndex = newOrigin >>> newLevel & MASK;
              if (beginIndex !== newTailOffset >>> newLevel & MASK) {
                break;
              }
              if (beginIndex) {
                offsetShift += (1 << newLevel) * beginIndex;
              }
              newLevel -= SHIFT;
              newRoot = newRoot.array[beginIndex];
            }

            // Trim the new sides of the new root.
            if (newRoot && newOrigin > oldOrigin) {
              newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
            }
            if (newRoot && newTailOffset < oldTailOffset) {
              newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
            }
            if (offsetShift) {
              newOrigin -= offsetShift;
              newCapacity -= offsetShift;
            }
          }
          if (list.__ownerID) {
            list.size = newCapacity - newOrigin;
            list._origin = newOrigin;
            list._capacity = newCapacity;
            list._level = newLevel;
            list._root = newRoot;
            list._tail = newTail;
            list.__hash = undefined;
            list.__altered = true;
            return list;
          }
          return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
        }
        function getTailOffset(size) {
          return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
        }
        var OrderedMap = /*@__PURE__*/function (Map) {
          function OrderedMap(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
              var iter = KeyedCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v, k) {
                return map.set(k, v);
              });
            });
          }
          if (Map) OrderedMap.__proto__ = Map;
          OrderedMap.prototype = Object.create(Map && Map.prototype);
          OrderedMap.prototype.constructor = OrderedMap;
          OrderedMap.of = function of(/*...values*/
          ) {
            return this(arguments);
          };
          OrderedMap.prototype.toString = function toString() {
            return this.__toString('OrderedMap {', '}');
          };

          // @pragma Access

          OrderedMap.prototype.get = function get(k, notSetValue) {
            var index = this._map.get(k);
            return index !== undefined ? this._list.get(index)[1] : notSetValue;
          };

          // @pragma Modification

          OrderedMap.prototype.clear = function clear() {
            if (this.size === 0) {
              return this;
            }
            if (this.__ownerID) {
              this.size = 0;
              this._map.clear();
              this._list.clear();
              this.__altered = true;
              return this;
            }
            return emptyOrderedMap();
          };
          OrderedMap.prototype.set = function set(k, v) {
            return updateOrderedMap(this, k, v);
          };
          OrderedMap.prototype.remove = function remove(k) {
            return updateOrderedMap(this, k, NOT_SET);
          };
          OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._list.__iterate(function (entry) {
              return entry && fn(entry[1], entry[0], this$1$1);
            }, reverse);
          };
          OrderedMap.prototype.__iterator = function __iterator(type, reverse) {
            return this._list.fromEntrySeq().__iterator(type, reverse);
          };
          OrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
              return this;
            }
            var newMap = this._map.__ensureOwner(ownerID);
            var newList = this._list.__ensureOwner(ownerID);
            if (!ownerID) {
              if (this.size === 0) {
                return emptyOrderedMap();
              }
              this.__ownerID = ownerID;
              this.__altered = false;
              this._map = newMap;
              this._list = newList;
              return this;
            }
            return makeOrderedMap(newMap, newList, ownerID, this.__hash);
          };
          return OrderedMap;
        }(Map$1);
        OrderedMap.isOrderedMap = isOrderedMap;
        OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
        OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
        function makeOrderedMap(map, list, ownerID, hash) {
          var omap = Object.create(OrderedMap.prototype);
          omap.size = map ? map.size : 0;
          omap._map = map;
          omap._list = list;
          omap.__ownerID = ownerID;
          omap.__hash = hash;
          omap.__altered = false;
          return omap;
        }
        var EMPTY_ORDERED_MAP;
        function emptyOrderedMap() {
          return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
        }
        function updateOrderedMap(omap, k, v) {
          var map = omap._map;
          var list = omap._list;
          var i = map.get(k);
          var has = i !== undefined;
          var newMap;
          var newList;
          if (v === NOT_SET) {
            // removed
            if (!has) {
              return omap;
            }
            if (list.size >= SIZE && list.size >= map.size * 2) {
              newList = list.filter(function (entry, idx) {
                return entry !== undefined && i !== idx;
              });
              newMap = newList.toKeyedSeq().map(function (entry) {
                return entry[0];
              }).flip().toMap();
              if (omap.__ownerID) {
                newMap.__ownerID = newList.__ownerID = omap.__ownerID;
              }
            } else {
              newMap = map.remove(k);
              newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
            }
          } else if (has) {
            if (v === list.get(i)[1]) {
              return omap;
            }
            newMap = map;
            newList = list.set(i, [k, v]);
          } else {
            newMap = map.set(k, list.size);
            newList = list.set(list.size, [k, v]);
          }
          if (omap.__ownerID) {
            omap.size = newMap.size;
            omap._map = newMap;
            omap._list = newList;
            omap.__hash = undefined;
            omap.__altered = true;
            return omap;
          }
          return makeOrderedMap(newMap, newList);
        }
        var IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';
        function isStack(maybeStack) {
          return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
        }
        var Stack = /*@__PURE__*/function (IndexedCollection) {
          function Stack(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
          }
          if (IndexedCollection) Stack.__proto__ = IndexedCollection;
          Stack.prototype = Object.create(IndexedCollection && IndexedCollection.prototype);
          Stack.prototype.constructor = Stack;
          Stack.of = function of(/*...values*/
          ) {
            return this(arguments);
          };
          Stack.prototype.toString = function toString() {
            return this.__toString('Stack [', ']');
          };

          // @pragma Access

          Stack.prototype.get = function get(index, notSetValue) {
            var head = this._head;
            index = wrapIndex(this, index);
            while (head && index--) {
              head = head.next;
            }
            return head ? head.value : notSetValue;
          };
          Stack.prototype.peek = function peek() {
            return this._head && this._head.value;
          };

          // @pragma Modification

          Stack.prototype.push = function push(/*...values*/
          ) {
            var arguments$1 = arguments;
            if (arguments.length === 0) {
              return this;
            }
            var newSize = this.size + arguments.length;
            var head = this._head;
            for (var ii = arguments.length - 1; ii >= 0; ii--) {
              head = {
                value: arguments$1[ii],
                next: head
              };
            }
            if (this.__ownerID) {
              this.size = newSize;
              this._head = head;
              this.__hash = undefined;
              this.__altered = true;
              return this;
            }
            return makeStack(newSize, head);
          };
          Stack.prototype.pushAll = function pushAll(iter) {
            iter = IndexedCollection(iter);
            if (iter.size === 0) {
              return this;
            }
            if (this.size === 0 && isStack(iter)) {
              return iter;
            }
            assertNotInfinite(iter.size);
            var newSize = this.size;
            var head = this._head;
            iter.__iterate(function (value) {
              newSize++;
              head = {
                value: value,
                next: head
              };
            }, /* reverse */true);
            if (this.__ownerID) {
              this.size = newSize;
              this._head = head;
              this.__hash = undefined;
              this.__altered = true;
              return this;
            }
            return makeStack(newSize, head);
          };
          Stack.prototype.pop = function pop() {
            return this.slice(1);
          };
          Stack.prototype.clear = function clear() {
            if (this.size === 0) {
              return this;
            }
            if (this.__ownerID) {
              this.size = 0;
              this._head = undefined;
              this.__hash = undefined;
              this.__altered = true;
              return this;
            }
            return emptyStack();
          };
          Stack.prototype.slice = function slice(begin, end) {
            if (wholeSlice(begin, end, this.size)) {
              return this;
            }
            var resolvedBegin = resolveBegin(begin, this.size);
            var resolvedEnd = resolveEnd(end, this.size);
            if (resolvedEnd !== this.size) {
              // super.slice(begin, end);
              return IndexedCollection.prototype.slice.call(this, begin, end);
            }
            var newSize = this.size - resolvedBegin;
            var head = this._head;
            while (resolvedBegin--) {
              head = head.next;
            }
            if (this.__ownerID) {
              this.size = newSize;
              this._head = head;
              this.__hash = undefined;
              this.__altered = true;
              return this;
            }
            return makeStack(newSize, head);
          };

          // @pragma Mutability

          Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
              return this;
            }
            if (!ownerID) {
              if (this.size === 0) {
                return emptyStack();
              }
              this.__ownerID = ownerID;
              this.__altered = false;
              return this;
            }
            return makeStack(this.size, this._head, ownerID, this.__hash);
          };

          // @pragma Iteration

          Stack.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            if (reverse) {
              return new ArraySeq(this.toArray()).__iterate(function (v, k) {
                return fn(v, k, this$1$1);
              }, reverse);
            }
            var iterations = 0;
            var node = this._head;
            while (node) {
              if (fn(node.value, iterations++, this) === false) {
                break;
              }
              node = node.next;
            }
            return iterations;
          };
          Stack.prototype.__iterator = function __iterator(type, reverse) {
            if (reverse) {
              return new ArraySeq(this.toArray()).__iterator(type, reverse);
            }
            var iterations = 0;
            var node = this._head;
            return new Iterator(function () {
              if (node) {
                var value = node.value;
                node = node.next;
                return iteratorValue(type, iterations++, value);
              }
              return iteratorDone();
            });
          };
          return Stack;
        }(IndexedCollection);
        Stack.isStack = isStack;
        var StackPrototype = Stack.prototype;
        StackPrototype[IS_STACK_SYMBOL] = true;
        StackPrototype.shift = StackPrototype.pop;
        StackPrototype.unshift = StackPrototype.push;
        StackPrototype.unshiftAll = StackPrototype.pushAll;
        StackPrototype.withMutations = withMutations;
        StackPrototype.wasAltered = wasAltered;
        StackPrototype.asImmutable = asImmutable;
        StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;
        StackPrototype['@@transducer/step'] = function (result, arr) {
          return result.unshift(arr);
        };
        StackPrototype['@@transducer/result'] = function (obj) {
          return obj.asImmutable();
        };
        function makeStack(size, head, ownerID, hash) {
          var map = Object.create(StackPrototype);
          map.size = size;
          map._head = head;
          map.__ownerID = ownerID;
          map.__hash = hash;
          map.__altered = false;
          return map;
        }
        var EMPTY_STACK;
        function emptyStack() {
          return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
        }
        var IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';
        function isSet(maybeSet) {
          return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
        }
        function isOrderedSet(maybeOrderedSet) {
          return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
        }
        function deepEqual(a, b) {
          if (a === b) {
            return true;
          }
          if (!isCollection(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
            return false;
          }
          if (a.size === 0 && b.size === 0) {
            return true;
          }
          var notAssociative = !isAssociative(a);
          if (isOrdered(a)) {
            var entries = a.entries();
            return b.every(function (v, k) {
              var entry = entries.next().value;
              return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
            }) && entries.next().done;
          }
          var flipped = false;
          if (a.size === undefined) {
            if (b.size === undefined) {
              if (typeof a.cacheResult === 'function') {
                a.cacheResult();
              }
            } else {
              flipped = true;
              var _ = a;
              a = b;
              b = _;
            }
          }
          var allEqual = true;
          var bSize = b.__iterate(function (v, k) {
            if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
              allEqual = false;
              return false;
            }
          });
          return allEqual && a.size === bSize;
        }
        function mixin(ctor, methods) {
          var keyCopier = function (key) {
            ctor.prototype[key] = methods[key];
          };
          Object.keys(methods).forEach(keyCopier);
          Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
          return ctor;
        }
        function toJS(value) {
          if (!value || typeof value !== 'object') {
            return value;
          }
          if (!isCollection(value)) {
            if (!isDataStructure(value)) {
              return value;
            }
            value = Seq(value);
          }
          if (isKeyed(value)) {
            var result$1 = {};
            value.__iterate(function (v, k) {
              result$1[k] = toJS(v);
            });
            return result$1;
          }
          var result = [];
          value.__iterate(function (v) {
            result.push(toJS(v));
          });
          return result;
        }
        var Set$1 = /*@__PURE__*/function (SetCollection) {
          function Set(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
              var iter = SetCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v) {
                return set.add(v);
              });
            });
          }
          if (SetCollection) Set.__proto__ = SetCollection;
          Set.prototype = Object.create(SetCollection && SetCollection.prototype);
          Set.prototype.constructor = Set;
          Set.of = function of(/*...values*/
          ) {
            return this(arguments);
          };
          Set.fromKeys = function fromKeys(value) {
            return this(KeyedCollection(value).keySeq());
          };
          Set.intersect = function intersect(sets) {
            sets = Collection(sets).toArray();
            return sets.length ? SetPrototype.intersect.apply(Set(sets.pop()), sets) : emptySet();
          };
          Set.union = function union(sets) {
            sets = Collection(sets).toArray();
            return sets.length ? SetPrototype.union.apply(Set(sets.pop()), sets) : emptySet();
          };
          Set.prototype.toString = function toString() {
            return this.__toString('Set {', '}');
          };

          // @pragma Access

          Set.prototype.has = function has(value) {
            return this._map.has(value);
          };

          // @pragma Modification

          Set.prototype.add = function add(value) {
            return updateSet(this, this._map.set(value, value));
          };
          Set.prototype.remove = function remove(value) {
            return updateSet(this, this._map.remove(value));
          };
          Set.prototype.clear = function clear() {
            return updateSet(this, this._map.clear());
          };

          // @pragma Composition

          Set.prototype.map = function map(mapper, context) {
            var this$1$1 = this;

            // keep track if the set is altered by the map function
            var didChanges = false;
            var newMap = updateSet(this, this._map.mapEntries(function (ref) {
              var v = ref[1];
              var mapped = mapper.call(context, v, v, this$1$1);
              if (mapped !== v) {
                didChanges = true;
              }
              return [mapped, mapped];
            }, context));
            return didChanges ? newMap : this;
          };
          Set.prototype.union = function union() {
            var iters = [],
              len = arguments.length;
            while (len--) iters[len] = arguments[len];
            iters = iters.filter(function (x) {
              return x.size !== 0;
            });
            if (iters.length === 0) {
              return this;
            }
            if (this.size === 0 && !this.__ownerID && iters.length === 1) {
              return this.constructor(iters[0]);
            }
            return this.withMutations(function (set) {
              for (var ii = 0; ii < iters.length; ii++) {
                if (typeof iters[ii] === 'string') {
                  set.add(iters[ii]);
                } else {
                  SetCollection(iters[ii]).forEach(function (value) {
                    return set.add(value);
                  });
                }
              }
            });
          };
          Set.prototype.intersect = function intersect() {
            var iters = [],
              len = arguments.length;
            while (len--) iters[len] = arguments[len];
            if (iters.length === 0) {
              return this;
            }
            iters = iters.map(function (iter) {
              return SetCollection(iter);
            });
            var toRemove = [];
            this.forEach(function (value) {
              if (!iters.every(function (iter) {
                return iter.includes(value);
              })) {
                toRemove.push(value);
              }
            });
            return this.withMutations(function (set) {
              toRemove.forEach(function (value) {
                set.remove(value);
              });
            });
          };
          Set.prototype.subtract = function subtract() {
            var iters = [],
              len = arguments.length;
            while (len--) iters[len] = arguments[len];
            if (iters.length === 0) {
              return this;
            }
            iters = iters.map(function (iter) {
              return SetCollection(iter);
            });
            var toRemove = [];
            this.forEach(function (value) {
              if (iters.some(function (iter) {
                return iter.includes(value);
              })) {
                toRemove.push(value);
              }
            });
            return this.withMutations(function (set) {
              toRemove.forEach(function (value) {
                set.remove(value);
              });
            });
          };
          Set.prototype.sort = function sort(comparator) {
            // Late binding
            return OrderedSet(sortFactory(this, comparator));
          };
          Set.prototype.sortBy = function sortBy(mapper, comparator) {
            // Late binding
            return OrderedSet(sortFactory(this, comparator, mapper));
          };
          Set.prototype.wasAltered = function wasAltered() {
            return this._map.wasAltered();
          };
          Set.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._map.__iterate(function (k) {
              return fn(k, k, this$1$1);
            }, reverse);
          };
          Set.prototype.__iterator = function __iterator(type, reverse) {
            return this._map.__iterator(type, reverse);
          };
          Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
              return this;
            }
            var newMap = this._map.__ensureOwner(ownerID);
            if (!ownerID) {
              if (this.size === 0) {
                return this.__empty();
              }
              this.__ownerID = ownerID;
              this._map = newMap;
              return this;
            }
            return this.__make(newMap, ownerID);
          };
          return Set;
        }(SetCollection);
        Set$1.isSet = isSet;
        var SetPrototype = Set$1.prototype;
        SetPrototype[IS_SET_SYMBOL] = true;
        SetPrototype[DELETE] = SetPrototype.remove;
        SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
        SetPrototype.withMutations = withMutations;
        SetPrototype.asImmutable = asImmutable;
        SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;
        SetPrototype['@@transducer/step'] = function (result, arr) {
          return result.add(arr);
        };
        SetPrototype['@@transducer/result'] = function (obj) {
          return obj.asImmutable();
        };
        SetPrototype.__empty = emptySet;
        SetPrototype.__make = makeSet;
        function updateSet(set, newMap) {
          if (set.__ownerID) {
            set.size = newMap.size;
            set._map = newMap;
            return set;
          }
          return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
        }
        function makeSet(map, ownerID) {
          var set = Object.create(SetPrototype);
          set.size = map ? map.size : 0;
          set._map = map;
          set.__ownerID = ownerID;
          return set;
        }
        var EMPTY_SET;
        function emptySet() {
          return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
        }

        /**
         * Returns a lazy seq of nums from start (inclusive) to end
         * (exclusive), by step, where start defaults to 0, step to 1, and end to
         * infinity. When start is equal to end, returns empty list.
         */
        var Range = /*@__PURE__*/function (IndexedSeq) {
          function Range(start, end, step) {
            if (!(this instanceof Range)) {
              // eslint-disable-next-line no-constructor-return
              return new Range(start, end, step);
            }
            invariant$1(step !== 0, 'Cannot step a Range by 0');
            start = start || 0;
            if (end === undefined) {
              end = Infinity;
            }
            step = step === undefined ? 1 : Math.abs(step);
            if (end < start) {
              step = -step;
            }
            this._start = start;
            this._end = end;
            this._step = step;
            this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
            if (this.size === 0) {
              if (EMPTY_RANGE) {
                // eslint-disable-next-line no-constructor-return
                return EMPTY_RANGE;
              }
              EMPTY_RANGE = this;
            }
          }
          if (IndexedSeq) Range.__proto__ = IndexedSeq;
          Range.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
          Range.prototype.constructor = Range;
          Range.prototype.toString = function toString() {
            if (this.size === 0) {
              return 'Range []';
            }
            return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';
          };
          Range.prototype.get = function get(index, notSetValue) {
            return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
          };
          Range.prototype.includes = function includes(searchValue) {
            var possibleIndex = (searchValue - this._start) / this._step;
            return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
          };
          Range.prototype.slice = function slice(begin, end) {
            if (wholeSlice(begin, end, this.size)) {
              return this;
            }
            begin = resolveBegin(begin, this.size);
            end = resolveEnd(end, this.size);
            if (end <= begin) {
              return new Range(0, 0);
            }
            return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
          };
          Range.prototype.indexOf = function indexOf(searchValue) {
            var offsetValue = searchValue - this._start;
            if (offsetValue % this._step === 0) {
              var index = offsetValue / this._step;
              if (index >= 0 && index < this.size) {
                return index;
              }
            }
            return -1;
          };
          Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {
            return this.indexOf(searchValue);
          };
          Range.prototype.__iterate = function __iterate(fn, reverse) {
            var size = this.size;
            var step = this._step;
            var value = reverse ? this._start + (size - 1) * step : this._start;
            var i = 0;
            while (i !== size) {
              if (fn(value, reverse ? size - ++i : i++, this) === false) {
                break;
              }
              value += reverse ? -step : step;
            }
            return i;
          };
          Range.prototype.__iterator = function __iterator(type, reverse) {
            var size = this.size;
            var step = this._step;
            var value = reverse ? this._start + (size - 1) * step : this._start;
            var i = 0;
            return new Iterator(function () {
              if (i === size) {
                return iteratorDone();
              }
              var v = value;
              value += reverse ? -step : step;
              return iteratorValue(type, reverse ? size - ++i : i++, v);
            });
          };
          Range.prototype.equals = function equals(other) {
            return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
          };
          return Range;
        }(IndexedSeq);
        var EMPTY_RANGE;
        function getIn$1(collection, searchKeyPath, notSetValue) {
          var keyPath = coerceKeyPath(searchKeyPath);
          var i = 0;
          while (i !== keyPath.length) {
            collection = get(collection, keyPath[i++], NOT_SET);
            if (collection === NOT_SET) {
              return notSetValue;
            }
          }
          return collection;
        }
        function getIn(searchKeyPath, notSetValue) {
          return getIn$1(this, searchKeyPath, notSetValue);
        }
        function hasIn$1(collection, keyPath) {
          return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
        }
        function hasIn(searchKeyPath) {
          return hasIn$1(this, searchKeyPath);
        }
        function toObject() {
          assertNotInfinite(this.size);
          var object = {};
          this.__iterate(function (v, k) {
            object[k] = v;
          });
          return object;
        }

        // Note: all of these methods are deprecated.
        Collection.isIterable = isCollection;
        Collection.isKeyed = isKeyed;
        Collection.isIndexed = isIndexed;
        Collection.isAssociative = isAssociative;
        Collection.isOrdered = isOrdered;
        Collection.Iterator = Iterator;
        mixin(Collection, {
          // ### Conversion to other types

          toArray: function toArray() {
            assertNotInfinite(this.size);
            var array = new Array(this.size || 0);
            var useTuples = isKeyed(this);
            var i = 0;
            this.__iterate(function (v, k) {
              // Keyed collections produce an array of tuples.
              array[i++] = useTuples ? [k, v] : v;
            });
            return array;
          },
          toIndexedSeq: function toIndexedSeq() {
            return new ToIndexedSequence(this);
          },
          toJS: function toJS$1() {
            return toJS(this);
          },
          toKeyedSeq: function toKeyedSeq() {
            return new ToKeyedSequence(this, true);
          },
          toMap: function toMap() {
            // Use Late Binding here to solve the circular dependency.
            return Map$1(this.toKeyedSeq());
          },
          toObject: toObject,
          toOrderedMap: function toOrderedMap() {
            // Use Late Binding here to solve the circular dependency.
            return OrderedMap(this.toKeyedSeq());
          },
          toOrderedSet: function toOrderedSet() {
            // Use Late Binding here to solve the circular dependency.
            return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
          },
          toSet: function toSet() {
            // Use Late Binding here to solve the circular dependency.
            return Set$1(isKeyed(this) ? this.valueSeq() : this);
          },
          toSetSeq: function toSetSeq() {
            return new ToSetSequence(this);
          },
          toSeq: function toSeq() {
            return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
          },
          toStack: function toStack() {
            // Use Late Binding here to solve the circular dependency.
            return Stack(isKeyed(this) ? this.valueSeq() : this);
          },
          toList: function toList() {
            // Use Late Binding here to solve the circular dependency.
            return List(isKeyed(this) ? this.valueSeq() : this);
          },
          // ### Common JavaScript methods and properties

          toString: function toString() {
            return '[Collection]';
          },
          __toString: function __toString(head, tail) {
            if (this.size === 0) {
              return head + tail;
            }
            return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
          },
          // ### ES6 Collection methods (ES6 Array and Map)

          concat: function concat() {
            var values = [],
              len = arguments.length;
            while (len--) values[len] = arguments[len];
            return reify(this, concatFactory(this, values));
          },
          includes: function includes(searchValue) {
            return this.some(function (value) {
              return is(value, searchValue);
            });
          },
          entries: function entries() {
            return this.__iterator(ITERATE_ENTRIES);
          },
          every: function every(predicate, context) {
            assertNotInfinite(this.size);
            var returnValue = true;
            this.__iterate(function (v, k, c) {
              if (!predicate.call(context, v, k, c)) {
                returnValue = false;
                return false;
              }
            });
            return returnValue;
          },
          filter: function filter(predicate, context) {
            return reify(this, filterFactory(this, predicate, context, true));
          },
          partition: function partition(predicate, context) {
            return partitionFactory(this, predicate, context);
          },
          find: function find(predicate, context, notSetValue) {
            var entry = this.findEntry(predicate, context);
            return entry ? entry[1] : notSetValue;
          },
          forEach: function forEach(sideEffect, context) {
            assertNotInfinite(this.size);
            return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
          },
          join: function join(separator) {
            assertNotInfinite(this.size);
            separator = separator !== undefined ? '' + separator : ',';
            var joined = '';
            var isFirst = true;
            this.__iterate(function (v) {
              isFirst ? isFirst = false : joined += separator;
              joined += v !== null && v !== undefined ? v.toString() : '';
            });
            return joined;
          },
          keys: function keys() {
            return this.__iterator(ITERATE_KEYS);
          },
          map: function map(mapper, context) {
            return reify(this, mapFactory(this, mapper, context));
          },
          reduce: function reduce$1(reducer, initialReduction, context) {
            return reduce(this, reducer, initialReduction, context, arguments.length < 2, false);
          },
          reduceRight: function reduceRight(reducer, initialReduction, context) {
            return reduce(this, reducer, initialReduction, context, arguments.length < 2, true);
          },
          reverse: function reverse() {
            return reify(this, reverseFactory(this, true));
          },
          slice: function slice(begin, end) {
            return reify(this, sliceFactory(this, begin, end, true));
          },
          some: function some(predicate, context) {
            assertNotInfinite(this.size);
            var returnValue = false;
            this.__iterate(function (v, k, c) {
              if (predicate.call(context, v, k, c)) {
                returnValue = true;
                return false;
              }
            });
            return returnValue;
          },
          sort: function sort(comparator) {
            return reify(this, sortFactory(this, comparator));
          },
          values: function values() {
            return this.__iterator(ITERATE_VALUES);
          },
          // ### More sequential methods

          butLast: function butLast() {
            return this.slice(0, -1);
          },
          isEmpty: function isEmpty() {
            return this.size !== undefined ? this.size === 0 : !this.some(function () {
              return true;
            });
          },
          count: function count(predicate, context) {
            return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
          },
          countBy: function countBy(grouper, context) {
            return countByFactory(this, grouper, context);
          },
          equals: function equals(other) {
            return deepEqual(this, other);
          },
          entrySeq: function entrySeq() {
            var collection = this;
            if (collection._cache) {
              // We cache as an entries array, so we can just return the cache!
              return new ArraySeq(collection._cache);
            }
            var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
            entriesSequence.fromEntrySeq = function () {
              return collection.toSeq();
            };
            return entriesSequence;
          },
          filterNot: function filterNot(predicate, context) {
            return this.filter(not(predicate), context);
          },
          findEntry: function findEntry(predicate, context, notSetValue) {
            var found = notSetValue;
            this.__iterate(function (v, k, c) {
              if (predicate.call(context, v, k, c)) {
                found = [k, v];
                return false;
              }
            });
            return found;
          },
          findKey: function findKey(predicate, context) {
            var entry = this.findEntry(predicate, context);
            return entry && entry[0];
          },
          findLast: function findLast(predicate, context, notSetValue) {
            return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
          },
          findLastEntry: function findLastEntry(predicate, context, notSetValue) {
            return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
          },
          findLastKey: function findLastKey(predicate, context) {
            return this.toKeyedSeq().reverse().findKey(predicate, context);
          },
          first: function first(notSetValue) {
            return this.find(returnTrue, null, notSetValue);
          },
          flatMap: function flatMap(mapper, context) {
            return reify(this, flatMapFactory(this, mapper, context));
          },
          flatten: function flatten(depth) {
            return reify(this, flattenFactory(this, depth, true));
          },
          fromEntrySeq: function fromEntrySeq() {
            return new FromEntriesSequence(this);
          },
          get: function get(searchKey, notSetValue) {
            return this.find(function (_, key) {
              return is(key, searchKey);
            }, undefined, notSetValue);
          },
          getIn: getIn,
          groupBy: function groupBy(grouper, context) {
            return groupByFactory(this, grouper, context);
          },
          has: function has(searchKey) {
            return this.get(searchKey, NOT_SET) !== NOT_SET;
          },
          hasIn: hasIn,
          isSubset: function isSubset(iter) {
            iter = typeof iter.includes === 'function' ? iter : Collection(iter);
            return this.every(function (value) {
              return iter.includes(value);
            });
          },
          isSuperset: function isSuperset(iter) {
            iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);
            return iter.isSubset(this);
          },
          keyOf: function keyOf(searchValue) {
            return this.findKey(function (value) {
              return is(value, searchValue);
            });
          },
          keySeq: function keySeq() {
            return this.toSeq().map(keyMapper).toIndexedSeq();
          },
          last: function last(notSetValue) {
            return this.toSeq().reverse().first(notSetValue);
          },
          lastKeyOf: function lastKeyOf(searchValue) {
            return this.toKeyedSeq().reverse().keyOf(searchValue);
          },
          max: function max(comparator) {
            return maxFactory(this, comparator);
          },
          maxBy: function maxBy(mapper, comparator) {
            return maxFactory(this, comparator, mapper);
          },
          min: function min(comparator) {
            return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
          },
          minBy: function minBy(mapper, comparator) {
            return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
          },
          rest: function rest() {
            return this.slice(1);
          },
          skip: function skip(amount) {
            return amount === 0 ? this : this.slice(Math.max(0, amount));
          },
          skipLast: function skipLast(amount) {
            return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
          },
          skipWhile: function skipWhile(predicate, context) {
            return reify(this, skipWhileFactory(this, predicate, context, true));
          },
          skipUntil: function skipUntil(predicate, context) {
            return this.skipWhile(not(predicate), context);
          },
          sortBy: function sortBy(mapper, comparator) {
            return reify(this, sortFactory(this, comparator, mapper));
          },
          take: function take(amount) {
            return this.slice(0, Math.max(0, amount));
          },
          takeLast: function takeLast(amount) {
            return this.slice(-Math.max(0, amount));
          },
          takeWhile: function takeWhile(predicate, context) {
            return reify(this, takeWhileFactory(this, predicate, context));
          },
          takeUntil: function takeUntil(predicate, context) {
            return this.takeWhile(not(predicate), context);
          },
          update: function update(fn) {
            return fn(this);
          },
          valueSeq: function valueSeq() {
            return this.toIndexedSeq();
          },
          // ### Hashable Object

          hashCode: function hashCode() {
            return this.__hash || (this.__hash = hashCollection(this));
          }

          // ### Internal

          // abstract __iterate(fn, reverse)

          // abstract __iterator(type, reverse)
        });
        var CollectionPrototype = Collection.prototype;
        CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
        CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
        CollectionPrototype.toJSON = CollectionPrototype.toArray;
        CollectionPrototype.__toStringMapper = quoteString;
        CollectionPrototype.inspect = CollectionPrototype.toSource = function () {
          return this.toString();
        };
        CollectionPrototype.chain = CollectionPrototype.flatMap;
        CollectionPrototype.contains = CollectionPrototype.includes;
        mixin(KeyedCollection, {
          // ### More sequential methods

          flip: function flip() {
            return reify(this, flipFactory(this));
          },
          mapEntries: function mapEntries(mapper, context) {
            var this$1$1 = this;
            var iterations = 0;
            return reify(this, this.toSeq().map(function (v, k) {
              return mapper.call(context, [k, v], iterations++, this$1$1);
            }).fromEntrySeq());
          },
          mapKeys: function mapKeys(mapper, context) {
            var this$1$1 = this;
            return reify(this, this.toSeq().flip().map(function (k, v) {
              return mapper.call(context, k, v, this$1$1);
            }).flip());
          }
        });
        var KeyedCollectionPrototype = KeyedCollection.prototype;
        KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
        KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
        KeyedCollectionPrototype.toJSON = toObject;
        KeyedCollectionPrototype.__toStringMapper = function (v, k) {
          return quoteString(k) + ': ' + quoteString(v);
        };
        mixin(IndexedCollection, {
          // ### Conversion to other types

          toKeyedSeq: function toKeyedSeq() {
            return new ToKeyedSequence(this, false);
          },
          // ### ES6 Collection methods (ES6 Array and Map)

          filter: function filter(predicate, context) {
            return reify(this, filterFactory(this, predicate, context, false));
          },
          findIndex: function findIndex(predicate, context) {
            var entry = this.findEntry(predicate, context);
            return entry ? entry[0] : -1;
          },
          indexOf: function indexOf(searchValue) {
            var key = this.keyOf(searchValue);
            return key === undefined ? -1 : key;
          },
          lastIndexOf: function lastIndexOf(searchValue) {
            var key = this.lastKeyOf(searchValue);
            return key === undefined ? -1 : key;
          },
          reverse: function reverse() {
            return reify(this, reverseFactory(this, false));
          },
          slice: function slice(begin, end) {
            return reify(this, sliceFactory(this, begin, end, false));
          },
          splice: function splice(index, removeNum /*, ...values*/) {
            var numArgs = arguments.length;
            removeNum = Math.max(removeNum || 0, 0);
            if (numArgs === 0 || numArgs === 2 && !removeNum) {
              return this;
            }
            // If index is negative, it should resolve relative to the size of the
            // collection. However size may be expensive to compute if not cached, so
            // only call count() if the number is in fact negative.
            index = resolveBegin(index, index < 0 ? this.count() : this.size);
            var spliced = this.slice(0, index);
            return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
          },
          // ### More collection methods

          findLastIndex: function findLastIndex(predicate, context) {
            var entry = this.findLastEntry(predicate, context);
            return entry ? entry[0] : -1;
          },
          first: function first(notSetValue) {
            return this.get(0, notSetValue);
          },
          flatten: function flatten(depth) {
            return reify(this, flattenFactory(this, depth, false));
          },
          get: function get(index, notSetValue) {
            index = wrapIndex(this, index);
            return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {
              return key === index;
            }, undefined, notSetValue);
          },
          has: function has(index) {
            index = wrapIndex(this, index);
            return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
          },
          interpose: function interpose(separator) {
            return reify(this, interposeFactory(this, separator));
          },
          interleave: function interleave(/*...collections*/
          ) {
            var collections = [this].concat(arrCopy(arguments));
            var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
            var interleaved = zipped.flatten(true);
            if (zipped.size) {
              interleaved.size = zipped.size * collections.length;
            }
            return reify(this, interleaved);
          },
          keySeq: function keySeq() {
            return Range(0, this.size);
          },
          last: function last(notSetValue) {
            return this.get(-1, notSetValue);
          },
          skipWhile: function skipWhile(predicate, context) {
            return reify(this, skipWhileFactory(this, predicate, context, false));
          },
          zip: function zip(/*, ...collections */
          ) {
            var collections = [this].concat(arrCopy(arguments));
            return reify(this, zipWithFactory(this, defaultZipper, collections));
          },
          zipAll: function zipAll(/*, ...collections */
          ) {
            var collections = [this].concat(arrCopy(arguments));
            return reify(this, zipWithFactory(this, defaultZipper, collections, true));
          },
          zipWith: function zipWith(zipper /*, ...collections */) {
            var collections = arrCopy(arguments);
            collections[0] = this;
            return reify(this, zipWithFactory(this, zipper, collections));
          }
        });
        var IndexedCollectionPrototype = IndexedCollection.prototype;
        IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
        IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
        mixin(SetCollection, {
          // ### ES6 Collection methods (ES6 Array and Map)

          get: function get(value, notSetValue) {
            return this.has(value) ? value : notSetValue;
          },
          includes: function includes(value) {
            return this.has(value);
          },
          // ### More sequential methods

          keySeq: function keySeq() {
            return this.valueSeq();
          }
        });
        var SetCollectionPrototype = SetCollection.prototype;
        SetCollectionPrototype.has = CollectionPrototype.includes;
        SetCollectionPrototype.contains = SetCollectionPrototype.includes;
        SetCollectionPrototype.keys = SetCollectionPrototype.values;

        // Mixin subclasses

        mixin(KeyedSeq, KeyedCollectionPrototype);
        mixin(IndexedSeq, IndexedCollectionPrototype);
        mixin(SetSeq, SetCollectionPrototype);

        // #pragma Helper functions

        function reduce(collection, reducer, reduction, context, useFirst, reverse) {
          assertNotInfinite(collection.size);
          collection.__iterate(function (v, k, c) {
            if (useFirst) {
              useFirst = false;
              reduction = v;
            } else {
              reduction = reducer.call(context, reduction, v, k, c);
            }
          }, reverse);
          return reduction;
        }
        function keyMapper(v, k) {
          return k;
        }
        function entryMapper(v, k) {
          return [k, v];
        }
        function not(predicate) {
          return function () {
            return !predicate.apply(this, arguments);
          };
        }
        function neg(predicate) {
          return function () {
            return -predicate.apply(this, arguments);
          };
        }
        function defaultZipper() {
          return arrCopy(arguments);
        }
        function defaultNegComparator(a, b) {
          return a < b ? 1 : a > b ? -1 : 0;
        }
        function hashCollection(collection) {
          if (collection.size === Infinity) {
            return 0;
          }
          var ordered = isOrdered(collection);
          var keyed = isKeyed(collection);
          var h = ordered ? 1 : 0;
          var size = collection.__iterate(keyed ? ordered ? function (v, k) {
            h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
          } : function (v, k) {
            h = h + hashMerge(hash(v), hash(k)) | 0;
          } : ordered ? function (v) {
            h = 31 * h + hash(v) | 0;
          } : function (v) {
            h = h + hash(v) | 0;
          });
          return murmurHashOfSize(size, h);
        }
        function murmurHashOfSize(size, h) {
          h = imul(h, 0xcc9e2d51);
          h = imul(h << 15 | h >>> -15, 0x1b873593);
          h = imul(h << 13 | h >>> -13, 5);
          h = (h + 0xe6546b64 | 0) ^ size;
          h = imul(h ^ h >>> 16, 0x85ebca6b);
          h = imul(h ^ h >>> 13, 0xc2b2ae35);
          h = smi(h ^ h >>> 16);
          return h;
        }
        function hashMerge(a, b) {
          return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int
        }
        var OrderedSet = /*@__PURE__*/function (Set) {
          function OrderedSet(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
              var iter = SetCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v) {
                return set.add(v);
              });
            });
          }
          if (Set) OrderedSet.__proto__ = Set;
          OrderedSet.prototype = Object.create(Set && Set.prototype);
          OrderedSet.prototype.constructor = OrderedSet;
          OrderedSet.of = function of(/*...values*/
          ) {
            return this(arguments);
          };
          OrderedSet.fromKeys = function fromKeys(value) {
            return this(KeyedCollection(value).keySeq());
          };
          OrderedSet.prototype.toString = function toString() {
            return this.__toString('OrderedSet {', '}');
          };
          return OrderedSet;
        }(Set$1);
        OrderedSet.isOrderedSet = isOrderedSet;
        var OrderedSetPrototype = OrderedSet.prototype;
        OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
        OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
        OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
        OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
        OrderedSetPrototype.__empty = emptyOrderedSet;
        OrderedSetPrototype.__make = makeOrderedSet;
        function makeOrderedSet(map, ownerID) {
          var set = Object.create(OrderedSetPrototype);
          set.size = map ? map.size : 0;
          set._map = map;
          set.__ownerID = ownerID;
          return set;
        }
        var EMPTY_ORDERED_SET;
        function emptyOrderedSet() {
          return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
        }
        var PairSorting = {
          LeftThenRight: -1,
          RightThenLeft: 1
        };
        function throwOnInvalidDefaultValues(defaultValues) {
          if (isRecord(defaultValues)) {
            throw new Error('Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead.');
          }
          if (isImmutable(defaultValues)) {
            throw new Error('Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead.');
          }
          if (defaultValues === null || typeof defaultValues !== 'object') {
            throw new Error('Can not call `Record` with a non-object as default values. Use a plain javascript object instead.');
          }
        }
        var Record = function Record(defaultValues, name) {
          var hasInitialized;
          throwOnInvalidDefaultValues(defaultValues);
          var RecordType = function Record(values) {
            var this$1$1 = this;
            if (values instanceof RecordType) {
              return values;
            }
            if (!(this instanceof RecordType)) {
              return new RecordType(values);
            }
            if (!hasInitialized) {
              hasInitialized = true;
              var keys = Object.keys(defaultValues);
              var indices = RecordTypePrototype._indices = {};
              // Deprecated: left to attempt not to break any external code which
              // relies on a ._name property existing on record instances.
              // Use Record.getDescriptiveName() instead
              RecordTypePrototype._name = name;
              RecordTypePrototype._keys = keys;
              RecordTypePrototype._defaultValues = defaultValues;
              for (var i = 0; i < keys.length; i++) {
                var propName = keys[i];
                indices[propName] = i;
                if (RecordTypePrototype[propName]) {
                  /* eslint-disable no-console */
                  typeof console === 'object' && console.warn && console.warn('Cannot define ' + recordName(this) + ' with property "' + propName + '" since that property name is part of the Record API.');
                  /* eslint-enable no-console */
                } else {
                  setProp(RecordTypePrototype, propName);
                }
              }
            }
            this.__ownerID = undefined;
            this._values = List().withMutations(function (l) {
              l.setSize(this$1$1._keys.length);
              KeyedCollection(values).forEach(function (v, k) {
                l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? undefined : v);
              });
            });
            return this;
          };
          var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
          RecordTypePrototype.constructor = RecordType;
          if (name) {
            RecordType.displayName = name;
          }

          // eslint-disable-next-line no-constructor-return
          return RecordType;
        };
        Record.prototype.toString = function toString() {
          var str = recordName(this) + ' { ';
          var keys = this._keys;
          var k;
          for (var i = 0, l = keys.length; i !== l; i++) {
            k = keys[i];
            str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));
          }
          return str + ' }';
        };
        Record.prototype.equals = function equals(other) {
          return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));
        };
        Record.prototype.hashCode = function hashCode() {
          return recordSeq(this).hashCode();
        };

        // @pragma Access

        Record.prototype.has = function has(k) {
          return this._indices.hasOwnProperty(k);
        };
        Record.prototype.get = function get(k, notSetValue) {
          if (!this.has(k)) {
            return notSetValue;
          }
          var index = this._indices[k];
          var value = this._values.get(index);
          return value === undefined ? this._defaultValues[k] : value;
        };

        // @pragma Modification

        Record.prototype.set = function set(k, v) {
          if (this.has(k)) {
            var newValues = this._values.set(this._indices[k], v === this._defaultValues[k] ? undefined : v);
            if (newValues !== this._values && !this.__ownerID) {
              return makeRecord(this, newValues);
            }
          }
          return this;
        };
        Record.prototype.remove = function remove(k) {
          return this.set(k);
        };
        Record.prototype.clear = function clear() {
          var newValues = this._values.clear().setSize(this._keys.length);
          return this.__ownerID ? this : makeRecord(this, newValues);
        };
        Record.prototype.wasAltered = function wasAltered() {
          return this._values.wasAltered();
        };
        Record.prototype.toSeq = function toSeq() {
          return recordSeq(this);
        };
        Record.prototype.toJS = function toJS$1() {
          return toJS(this);
        };
        Record.prototype.entries = function entries() {
          return this.__iterator(ITERATE_ENTRIES);
        };
        Record.prototype.__iterator = function __iterator(type, reverse) {
          return recordSeq(this).__iterator(type, reverse);
        };
        Record.prototype.__iterate = function __iterate(fn, reverse) {
          return recordSeq(this).__iterate(fn, reverse);
        };
        Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
          if (ownerID === this.__ownerID) {
            return this;
          }
          var newValues = this._values.__ensureOwner(ownerID);
          if (!ownerID) {
            this.__ownerID = ownerID;
            this._values = newValues;
            return this;
          }
          return makeRecord(this, newValues, ownerID);
        };
        Record.isRecord = isRecord;
        Record.getDescriptiveName = recordName;
        var RecordPrototype = Record.prototype;
        RecordPrototype[IS_RECORD_SYMBOL] = true;
        RecordPrototype[DELETE] = RecordPrototype.remove;
        RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
        RecordPrototype.getIn = getIn;
        RecordPrototype.hasIn = CollectionPrototype.hasIn;
        RecordPrototype.merge = merge$1;
        RecordPrototype.mergeWith = mergeWith$1;
        RecordPrototype.mergeIn = mergeIn;
        RecordPrototype.mergeDeep = mergeDeep;
        RecordPrototype.mergeDeepWith = mergeDeepWith;
        RecordPrototype.mergeDeepIn = mergeDeepIn;
        RecordPrototype.setIn = setIn;
        RecordPrototype.update = update$2;
        RecordPrototype.updateIn = updateIn;
        RecordPrototype.withMutations = withMutations;
        RecordPrototype.asMutable = asMutable;
        RecordPrototype.asImmutable = asImmutable;
        RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
        RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
        RecordPrototype.inspect = RecordPrototype.toSource = function () {
          return this.toString();
        };
        function makeRecord(likeRecord, values, ownerID) {
          var record = Object.create(Object.getPrototypeOf(likeRecord));
          record._values = values;
          record.__ownerID = ownerID;
          return record;
        }
        function recordName(record) {
          return record.constructor.displayName || record.constructor.name || 'Record';
        }
        function recordSeq(record) {
          return keyedSeqFromValue(record._keys.map(function (k) {
            return [k, record.get(k)];
          }));
        }
        function setProp(prototype, name) {
          try {
            Object.defineProperty(prototype, name, {
              get: function () {
                return this.get(name);
              },
              set: function (value) {
                invariant$1(this.__ownerID, 'Cannot set on an immutable record.');
                this.set(name, value);
              }
            });
          } catch (error) {
            // Object.defineProperty failed. Probably IE8.
          }
        }

        /**
         * Returns a lazy Seq of `value` repeated `times` times. When `times` is
         * undefined, returns an infinite sequence of `value`.
         */
        var Repeat = /*@__PURE__*/function (IndexedSeq) {
          function Repeat(value, times) {
            if (!(this instanceof Repeat)) {
              // eslint-disable-next-line no-constructor-return
              return new Repeat(value, times);
            }
            this._value = value;
            this.size = times === undefined ? Infinity : Math.max(0, times);
            if (this.size === 0) {
              if (EMPTY_REPEAT) {
                // eslint-disable-next-line no-constructor-return
                return EMPTY_REPEAT;
              }
              EMPTY_REPEAT = this;
            }
          }
          if (IndexedSeq) Repeat.__proto__ = IndexedSeq;
          Repeat.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
          Repeat.prototype.constructor = Repeat;
          Repeat.prototype.toString = function toString() {
            if (this.size === 0) {
              return 'Repeat []';
            }
            return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
          };
          Repeat.prototype.get = function get(index, notSetValue) {
            return this.has(index) ? this._value : notSetValue;
          };
          Repeat.prototype.includes = function includes(searchValue) {
            return is(this._value, searchValue);
          };
          Repeat.prototype.slice = function slice(begin, end) {
            var size = this.size;
            return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
          };
          Repeat.prototype.reverse = function reverse() {
            return this;
          };
          Repeat.prototype.indexOf = function indexOf(searchValue) {
            if (is(this._value, searchValue)) {
              return 0;
            }
            return -1;
          };
          Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {
            if (is(this._value, searchValue)) {
              return this.size;
            }
            return -1;
          };
          Repeat.prototype.__iterate = function __iterate(fn, reverse) {
            var size = this.size;
            var i = 0;
            while (i !== size) {
              if (fn(this._value, reverse ? size - ++i : i++, this) === false) {
                break;
              }
            }
            return i;
          };
          Repeat.prototype.__iterator = function __iterator(type, reverse) {
            var this$1$1 = this;
            var size = this.size;
            var i = 0;
            return new Iterator(function () {
              return i === size ? iteratorDone() : iteratorValue(type, reverse ? size - ++i : i++, this$1$1._value);
            });
          };
          Repeat.prototype.equals = function equals(other) {
            return other instanceof Repeat ? is(this._value, other._value) : deepEqual(this, other);
          };
          return Repeat;
        }(IndexedSeq);
        var EMPTY_REPEAT;
        function fromJS(value, converter) {
          return fromJSWith([], converter || defaultConverter, value, '', converter && converter.length > 2 ? [] : undefined, {
            '': value
          });
        }
        function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
          if (typeof value !== 'string' && !isImmutable(value) && (isArrayLike(value) || hasIterator(value) || isPlainObject$1(value))) {
            if (~stack.indexOf(value)) {
              throw new TypeError('Cannot convert circular structure to Immutable');
            }
            stack.push(value);
            keyPath && key !== '' && keyPath.push(key);
            var converted = converter.call(parentValue, key, Seq(value).map(function (v, k) {
              return fromJSWith(stack, converter, v, k, keyPath, value);
            }), keyPath && keyPath.slice());
            stack.pop();
            keyPath && keyPath.pop();
            return converted;
          }
          return value;
        }
        function defaultConverter(k, v) {
          // Effectively the opposite of "Collection.toSeq()"
          return isIndexed(v) ? v.toList() : isKeyed(v) ? v.toMap() : v.toSet();
        }
        var version = "4.3.7";
        var Immutable = {
          version: version,
          Collection: Collection,
          // Note: Iterable is deprecated
          Iterable: Collection,
          Seq: Seq,
          Map: Map$1,
          OrderedMap: OrderedMap,
          List: List,
          Stack: Stack,
          Set: Set$1,
          OrderedSet: OrderedSet,
          PairSorting: PairSorting,
          Record: Record,
          Range: Range,
          Repeat: Repeat,
          is: is,
          fromJS: fromJS,
          hash: hash,
          isImmutable: isImmutable,
          isCollection: isCollection,
          isKeyed: isKeyed,
          isIndexed: isIndexed,
          isAssociative: isAssociative,
          isOrdered: isOrdered,
          isValueObject: isValueObject,
          isPlainObject: isPlainObject$1,
          isSeq: isSeq,
          isList: isList,
          isMap: isMap,
          isOrderedMap: isOrderedMap,
          isStack: isStack,
          isSet: isSet,
          isOrderedSet: isOrderedSet,
          isRecord: isRecord,
          get: get,
          getIn: getIn$1,
          has: has,
          hasIn: hasIn$1,
          merge: merge,
          mergeDeep: mergeDeep$1,
          mergeWith: mergeWith,
          mergeDeepWith: mergeDeepWith$1,
          remove: remove,
          removeIn: removeIn,
          set: set,
          setIn: setIn$1,
          update: update$1,
          updateIn: updateIn$1
        };

        // Note: Iterable is deprecated
        var Iterable = Collection;
        const immutable_es = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          Collection,
          Iterable,
          List,
          Map: Map$1,
          OrderedMap,
          OrderedSet,
          PairSorting,
          Range,
          Record,
          Repeat,
          Seq,
          Set: Set$1,
          Stack,
          default: Immutable,
          fromJS,
          get,
          getIn: getIn$1,
          has,
          hasIn: hasIn$1,
          hash,
          is,
          isAssociative,
          isCollection,
          isImmutable,
          isIndexed,
          isKeyed,
          isList,
          isMap,
          isOrdered,
          isOrderedMap,
          isOrderedSet,
          isPlainObject: isPlainObject$1,
          isRecord,
          isSeq,
          isSet,
          isStack,
          isValueObject,
          merge,
          mergeDeep: mergeDeep$1,
          mergeDeepWith: mergeDeepWith$1,
          mergeWith,
          remove,
          removeIn,
          set,
          setIn: setIn$1,
          update: update$1,
          updateIn: updateIn$1,
          version
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        const require$$2 = /*@__PURE__*/getAugmentedNamespace(immutable_es);
        var hasRequiredReactDraftWysiwyg;
        function requireReactDraftWysiwyg() {
          if (hasRequiredReactDraftWysiwyg) return reactDraftWysiwyg.exports;
          hasRequiredReactDraftWysiwyg = 1;
          (function (module, exports) {
            !function (t, e) {
              module.exports = e(requireReact(), requireDraft(), require$$2);
            }(window, function (n, o, r) {
              return a = {}, i.m = c = [function (t, e, n) {
                t.exports = n(10)();
              }, function (t, e) {
                t.exports = n;
              }, function (t, e, n) {
                var o;
                /*!
                  Copyright (c) 2017 Jed Watson.
                  Licensed under the MIT License (MIT), see
                  http://jedwatson.github.io/classnames
                */
                !function () {
                  var c = {}.hasOwnProperty;
                  function a() {
                    for (var t = [], e = 0; e < arguments.length; e++) {
                      var n = arguments[e];
                      if (n) {
                        var o = typeof n;
                        if ("string" == o || "number" == o) t.push(n);else if (Array.isArray(n) && n.length) {
                          var r = a.apply(null, n);
                          r && t.push(r);
                        } else if ("object" == o) for (var i in n) c.call(n, i) && n[i] && t.push(i);
                      }
                    }
                    return t.join(" ");
                  }
                  t.exports ? (a.default = a, t.exports = a) : void 0 === (o = function () {
                    return a;
                  }.apply(e, [])) || (t.exports = o);
                }();
              }, function (t, e) {
                t.exports = o;
              }, function (t, e, n) {
                function r(t) {
                  if (a[t]) return a[t].exports;
                  var e = a[t] = {
                    i: t,
                    l: false,
                    exports: {}
                  };
                  return c[t].call(e.exports, e, e.exports, r), e.l = true, e.exports;
                }
                var o, i, c, a;
                t.exports = (o = n(3), i = n(5), a = {}, r.m = c = [function (t, e) {
                  t.exports = o;
                }, function (t, e) {
                  t.exports = i;
                }, function (t, e, n) {
                  t.exports = n(3);
                }, function (t, e, n) {
                  n.r(e);
                  var M = n(0),
                    i = n(1);
                  function j(t) {
                    var e = t.getSelection(),
                      n = t.getCurrentContent(),
                      o = e.getStartKey(),
                      r = e.getEndKey(),
                      i = n.getBlockMap();
                    return i.toSeq().skipUntil(function (t, e) {
                      return e === o;
                    }).takeUntil(function (t, e) {
                      return e === r;
                    }).concat([[r, i.get(r)]]);
                  }
                  function u(t) {
                    return j(t).toList();
                  }
                  function l(t) {
                    if (t) return u(t).get(0);
                  }
                  function o(t) {
                    if (t) {
                      var n = l(t),
                        e = t.getCurrentContent().getBlockMap().toSeq().toList(),
                        o = 0;
                      if (e.forEach(function (t, e) {
                        t.get("key") === n.get("key") && (o = e - 1);
                      }), -1 < o) return e.get(o);
                    }
                  }
                  function r(t) {
                    return t ? t.getCurrentContent().getBlockMap().toList() : new i.List();
                  }
                  function c(t) {
                    var e = u(t);
                    if (!e.some(function (t) {
                      return t.type !== e.get(0).type;
                    })) return e.get(0).type;
                  }
                  function a(t) {
                    var e = M.RichUtils.tryToRemoveBlockStyle(t);
                    return e ? M.EditorState.push(t, e, "change-block-type") : t;
                  }
                  function s(t) {
                    var e = "",
                      n = t.getSelection(),
                      o = n.getAnchorOffset(),
                      r = n.getFocusOffset(),
                      i = u(t);
                    if (0 < i.size) {
                      if (n.getIsBackward()) {
                        var c = o;
                        o = r, r = c;
                      }
                      for (var a = 0; a < i.size; a += 1) {
                        var l = 0 === a ? o : 0,
                          s = a === i.size - 1 ? r : i.get(a).getText().length;
                        e += i.get(a).getText().slice(l, s);
                      }
                    }
                    return e;
                  }
                  function p(t) {
                    var e = t.getCurrentContent(),
                      n = t.getSelection(),
                      o = M.Modifier.removeRange(e, n, "forward"),
                      r = o.getSelectionAfter(),
                      i = o.getBlockForKey(r.getStartKey());
                    return o = M.Modifier.insertText(o, r, "\n", i.getInlineStyleAt(r.getStartOffset()), null), M.EditorState.push(t, o, "insert-fragment");
                  }
                  function d(t) {
                    var e = M.Modifier.splitBlock(t.getCurrentContent(), t.getSelection());
                    return a(M.EditorState.push(t, e, "split-block"));
                  }
                  function f(t) {
                    var e = t.getCurrentContent().getBlockMap().toList(),
                      n = t.getSelection().merge({
                        anchorKey: e.first().get("key"),
                        anchorOffset: 0,
                        focusKey: e.last().get("key"),
                        focusOffset: e.last().getLength()
                      }),
                      o = M.Modifier.removeRange(t.getCurrentContent(), n, "forward");
                    return M.EditorState.push(t, o, "remove-range");
                  }
                  function y(t, e) {
                    var n = M.Modifier.setBlockData(t.getCurrentContent(), t.getSelection(), e);
                    return M.EditorState.push(t, n, "change-block-data");
                  }
                  function m(t) {
                    var o = new i.Map({}),
                      e = u(t);
                    if (e && 0 < e.size) for (var n = function (t) {
                        var n = e.get(t).getData();
                        if (!n || 0 === n.size) return o = o.clear(), "break";
                        if (0 === t) o = n;else if (o.forEach(function (t, e) {
                          n.get(e) && n.get(e) === t || (o = o.delete(e));
                        }), 0 === o.size) return o = o.clear(), "break";
                      }, r = 0; r < e.size && "break" !== n(r); r += 1);
                    return o;
                  }
                  var g = Object(i.Map)({
                      code: {
                        element: "pre"
                      }
                    }),
                    b = M.DefaultDraftBlockRenderMap.merge(g);
                  function h(t) {
                    if (t) {
                      var e = t.getType();
                      return "unordered-list-item" === e || "ordered-list-item" === e;
                    }
                    return false;
                  }
                  function v(t, e, n) {
                    var o,
                      r = t.getSelection();
                    o = r.getIsBackward() ? r.getFocusKey() : r.getAnchorKey();
                    var i = t.getCurrentContent(),
                      c = i.getBlockForKey(o),
                      a = c.getType();
                    if ("unordered-list-item" !== a && "ordered-list-item" !== a) return t;
                    var l = i.getBlockBefore(o);
                    if (!l) return t;
                    if (l.getType() !== a) return t;
                    var s = c.getDepth();
                    if (1 === e && s === n) return t;
                    var u,
                      p,
                      d,
                      f,
                      y,
                      m,
                      g,
                      b = Math.min(l.getDepth() + 1, n),
                      h = (p = e, d = b, f = (u = t).getSelection(), y = u.getCurrentContent(), m = y.getBlockMap(), g = j(u).map(function (t) {
                        var e = t.getDepth() + p;
                        return e = Math.max(0, Math.min(e, d)), t.set("depth", e);
                      }), m = m.merge(g), y.merge({
                        blockMap: m,
                        selectionBefore: f,
                        selectionAfter: f
                      }));
                    return M.EditorState.push(t, h, "adjust-depth");
                  }
                  function N(t, e) {
                    var n;
                    return 13 === (n = e).which && (n.getModifierState("Shift") || n.getModifierState("Alt") || n.getModifierState("Control")) ? t.getSelection().isCollapsed() ? M.RichUtils.insertSoftNewline(t) : p(t) : function (t) {
                      var e = t.getSelection();
                      if (e.isCollapsed()) {
                        var n = t.getCurrentContent(),
                          o = e.getStartKey(),
                          r = n.getBlockForKey(o);
                        if (!h(r) && "unstyled" !== r.getType() && r.getLength() === e.getStartOffset()) return d(t);
                        if (h(r) && 0 === r.getLength()) {
                          var i = r.getDepth();
                          if (0 === i) return a(t);
                          if (0 < i) return v(t, -1, i);
                        }
                      }
                    }(t);
                  }
                  function E(e, t) {
                    var n = Object.keys(e);
                    if (Object.getOwnPropertySymbols) {
                      var o = Object.getOwnPropertySymbols(e);
                      t && (o = o.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable;
                      })), n.push.apply(n, o);
                    }
                    return n;
                  }
                  function S(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                      value: n,
                      enumerable: true,
                      configurable: true,
                      writable: true
                    }) : t[e] = n, t;
                  }
                  function w(t) {
                    return (w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                      return typeof t;
                    } : function (t) {
                      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                    })(t);
                  }
                  function C(t) {
                    var e = t.getSelection();
                    if (e.isCollapsed()) {
                      var n = {},
                        o = t.getCurrentInlineStyle().toList().toJS();
                      if (o) return ["BOLD", "ITALIC", "UNDERLINE", "STRIKETHROUGH", "CODE", "SUPERSCRIPT", "SUBSCRIPT"].forEach(function (t) {
                        n[t] = 0 <= o.indexOf(t);
                      }), n;
                    }
                    var c = e.getStartOffset(),
                      a = e.getEndOffset(),
                      l = u(t);
                    if (0 < l.size) {
                      var r = function () {
                        for (var n = {
                            BOLD: true,
                            ITALIC: true,
                            UNDERLINE: true,
                            STRIKETHROUGH: true,
                            CODE: true,
                            SUPERSCRIPT: true,
                            SUBSCRIPT: true
                          }, o = 0; o < l.size; o += 1) {
                          var t = 0 === o ? c : 0,
                            e = o === l.size - 1 ? a : l.get(o).getText().length;
                          t === e && 0 === t ? (t = 1, e = 2) : t === e && --t;
                          for (var r = function (t) {
                              var e = l.get(o).getInlineStyleAt(t);
                              ["BOLD", "ITALIC", "UNDERLINE", "STRIKETHROUGH", "CODE", "SUPERSCRIPT", "SUBSCRIPT"].forEach(function (t) {
                                n[t] = n[t] && e.get(t) === t;
                              });
                            }, i = t; i < e; i += 1) r(i);
                        }
                        return {
                          v: n
                        };
                      }();
                      if ("object" === w(r)) return r.v;
                    }
                    return {};
                  }
                  function L(t) {
                    var e,
                      n = t.getSelection(),
                      o = n.getStartOffset(),
                      r = n.getEndOffset();
                    o === r && 0 === o ? r = 1 : o === r && --o;
                    for (var i = l(t), c = o; c < r; c += 1) {
                      var a = i.getEntityAt(c);
                      if (!a) {
                        e = void 0;
                        break;
                      }
                      if (c === o) e = a;else if (e !== a) {
                        e = void 0;
                        break;
                      }
                    }
                    return e;
                  }
                  function D(t, e) {
                    var n,
                      o = l(t);
                    return o.findEntityRanges(function (t) {
                      return t.get("entity") === e;
                    }, function (t, e) {
                      n = {
                        start: t,
                        end: e,
                        text: o.get("text").slice(t, e)
                      };
                    }), n;
                  }
                  function k(t, e, n) {
                    x[t]["".concat(t.toLowerCase(), "-").concat(n)] = S({}, "".concat(e), n);
                  }
                  function O() {
                    return function (e) {
                      for (var t = 1; t < arguments.length; t++) {
                        var n = null != arguments[t] ? arguments[t] : {};
                        t % 2 ? E(Object(n), true).forEach(function (t) {
                          S(e, t, n[t]);
                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : E(Object(n)).forEach(function (t) {
                          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
                        });
                      }
                      return e;
                    }({}, x.color, {}, x.bgcolor, {}, x.fontSize, {}, x.fontFamily, {
                      CODE: x.CODE,
                      SUPERSCRIPT: x.SUPERSCRIPT,
                      SUBSCRIPT: x.SUBSCRIPT
                    });
                  }
                  var x = {
                    color: {},
                    bgcolor: {},
                    fontSize: {},
                    fontFamily: {},
                    CODE: {
                      fontFamily: "monospace",
                      wordWrap: "break-word",
                      background: "#f1f1f1",
                      borderRadius: 3,
                      padding: "1px 3px"
                    },
                    SUPERSCRIPT: {
                      fontSize: 11,
                      position: "relative",
                      top: -8,
                      display: "inline-flex"
                    },
                    SUBSCRIPT: {
                      fontSize: 11,
                      position: "relative",
                      bottom: -8,
                      display: "inline-flex"
                    }
                  };
                  function I(t, e, n) {
                    var o = t.getSelection(),
                      r = Object.keys(x[e]).reduce(function (t, e) {
                        return M.Modifier.removeInlineStyle(t, o, e);
                      }, t.getCurrentContent()),
                      i = M.EditorState.push(t, r, "changeinline-style"),
                      c = t.getCurrentInlineStyle();
                    if (o.isCollapsed() && (i = c.reduce(function (t, e) {
                      return M.RichUtils.toggleInlineStyle(t, e);
                    }, i)), "SUPERSCRIPT" === e || "SUBSCRIPT" == e) c.has(n) || (i = M.RichUtils.toggleInlineStyle(i, n));else {
                      var a = "bgcolor" === e ? "backgroundColor" : e;
                      c.has("".concat(a, "-").concat(n)) || (i = M.RichUtils.toggleInlineStyle(i, "".concat(e.toLowerCase(), "-").concat(n)), k(e, a, n));
                    }
                    return i;
                  }
                  function T(t) {
                    t && t.getCurrentContent().getBlockMap().map(function (t) {
                      return t.get("characterList");
                    }).toList().flatten().forEach(function (t) {
                      t && 0 === t.indexOf("color-") ? k("color", "color", t.substr(6)) : t && 0 === t.indexOf("bgcolor-") ? k("bgcolor", "backgroundColor", t.substr(8)) : t && 0 === t.indexOf("fontsize-") ? k("fontSize", "fontSize", +t.substr(9)) : t && 0 === t.indexOf("fontfamily-") && k("fontFamily", "fontFamily", t.substr(11));
                    });
                  }
                  function A(t, e, n) {
                    var o = t.getInlineStyleAt(n).toList().filter(function (t) {
                      return t.startsWith(e.toLowerCase());
                    });
                    if (o && 0 < o.size) return o.get(0);
                  }
                  function z(o, s) {
                    if (o && s && 0 < s.length) {
                      var t = function () {
                        var t = o.getSelection(),
                          i = {};
                        if (t.isCollapsed()) return s.forEach(function (t) {
                          i[t] = function (t, e) {
                            var n = t.getCurrentInlineStyle().toList().filter(function (t) {
                              return t.startsWith(e.toLowerCase());
                            });
                            if (n && 0 < n.size) return n.get(0);
                          }(o, t);
                        }), {
                          v: i
                        };
                        var c = t.getStartOffset(),
                          a = t.getEndOffset(),
                          l = u(o);
                        if (0 < l.size) {
                          for (var e = function (n) {
                              var t = 0 === n ? c : 0,
                                e = n === l.size - 1 ? a : l.get(n).getText().length;
                              t === e && 0 === t ? (t = 1, e = 2) : t === e && --t;
                              for (var o = function (e) {
                                  e === t ? s.forEach(function (t) {
                                    i[t] = A(l.get(n), t, e);
                                  }) : s.forEach(function (t) {
                                    i[t] && i[t] !== A(l.get(n), t, e) && (i[t] = void 0);
                                  });
                                }, r = t; r < e; r += 1) o(r);
                            }, n = 0; n < l.size; n += 1) e(n);
                          return {
                            v: i
                          };
                        }
                      }();
                      if ("object" === w(t)) return t.v;
                    }
                    return {};
                  }
                  function _(e) {
                    var t = e.getCurrentInlineStyle(),
                      n = e.getCurrentContent();
                    return t.forEach(function (t) {
                      n = M.Modifier.removeInlineStyle(n, e.getSelection(), t);
                    }), M.EditorState.push(e, n, "change-inline-style");
                  }
                  n.d(e, "isListBlock", function () {
                    return h;
                  }), n.d(e, "changeDepth", function () {
                    return v;
                  }), n.d(e, "handleNewLine", function () {
                    return N;
                  }), n.d(e, "getEntityRange", function () {
                    return D;
                  }), n.d(e, "getCustomStyleMap", function () {
                    return O;
                  }), n.d(e, "toggleCustomInlineStyle", function () {
                    return I;
                  }), n.d(e, "getSelectionEntity", function () {
                    return L;
                  }), n.d(e, "extractInlineStyle", function () {
                    return T;
                  }), n.d(e, "removeAllInlineStyles", function () {
                    return _;
                  }), n.d(e, "getSelectionInlineStyle", function () {
                    return C;
                  }), n.d(e, "getSelectionCustomInlineStyle", function () {
                    return z;
                  }), n.d(e, "getSelectedBlocksMap", function () {
                    return j;
                  }), n.d(e, "getSelectedBlocksList", function () {
                    return u;
                  }), n.d(e, "getSelectedBlock", function () {
                    return l;
                  }), n.d(e, "getBlockBeforeSelectedBlock", function () {
                    return o;
                  }), n.d(e, "getAllBlocks", function () {
                    return r;
                  }), n.d(e, "getSelectedBlocksType", function () {
                    return c;
                  }), n.d(e, "removeSelectedBlocksStyle", function () {
                    return a;
                  }), n.d(e, "getSelectionText", function () {
                    return s;
                  }), n.d(e, "addLineBreakRemovingSelection", function () {
                    return p;
                  }), n.d(e, "insertNewUnstyledBlock", function () {
                    return d;
                  }), n.d(e, "clearEditorContent", function () {
                    return f;
                  }), n.d(e, "setBlockData", function () {
                    return y;
                  }), n.d(e, "getSelectedBlocksMetadata", function () {
                    return m;
                  }), n.d(e, "blockRenderMap", function () {
                    return b;
                  });
                }], r.c = a, r.d = function (t, e, n) {
                  r.o(t, e) || Object.defineProperty(t, e, {
                    enumerable: true,
                    get: n
                  });
                }, r.r = function (t) {
                  "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                    value: "Module"
                  }), Object.defineProperty(t, "__esModule", {
                    value: true
                  });
                }, r.t = function (e, t) {
                  if (1 & t && (e = r(e)), 8 & t) return e;
                  if (4 & t && "object" == typeof e && e && e.__esModule) return e;
                  var n = Object.create(null);
                  if (r.r(n), Object.defineProperty(n, "default", {
                    enumerable: true,
                    value: e
                  }), 2 & t && "string" != typeof e) for (var o in e) r.d(n, o, function (t) {
                    return e[t];
                  }.bind(null, o));
                  return n;
                }, r.n = function (t) {
                  var e = t && t.__esModule ? function () {
                    return t.default;
                  } : function () {
                    return t;
                  };
                  return r.d(e, "a", e), e;
                }, r.o = function (t, e) {
                  return Object.prototype.hasOwnProperty.call(t, e);
                }, r.p = "", r(r.s = 2));
              }, function (t, e) {
                t.exports = r;
              }, function (t, e, n) {
                function r(t) {
                  if (a[t]) return a[t].exports;
                  var e = a[t] = {
                    i: t,
                    l: false,
                    exports: {}
                  };
                  return c[t].call(e.exports, e, e.exports, r), e.l = true, e.exports;
                }
                var o, i, c, a;
                t.exports = (o = n(5), i = n(3), a = {}, r.m = c = [function (t, e) {
                  t.exports = o;
                }, function (t, e) {
                  t.exports = i;
                }, function (t, e, n) {
                  t.exports = n(3);
                }, function (t, e, n) {
                  n.r(e);
                  var j = n(1),
                    s = n(0),
                    v = function (t, e, n) {
                      var o,
                        r = t.textContent;
                      return "" === r.trim() ? {
                        chunk: (o = n, {
                          text: " ",
                          inlines: [new s.OrderedSet()],
                          entities: [o],
                          blocks: []
                        })
                      } : {
                        chunk: {
                          text: r,
                          inlines: Array(r.length).fill(e),
                          entities: Array(r.length).fill(n),
                          blocks: []
                        }
                      };
                    },
                    N = function () {
                      return {
                        text: "\n",
                        inlines: [new s.OrderedSet()],
                        entities: new Array(1),
                        blocks: []
                      };
                    },
                    E = function () {
                      return {
                        text: "",
                        inlines: [],
                        entities: [],
                        blocks: []
                      };
                    },
                    S = function (t, e) {
                      return {
                        text: "",
                        inlines: [],
                        entities: [],
                        blocks: [{
                          type: t,
                          depth: 0,
                          data: e || new s.Map({})
                        }]
                      };
                    },
                    w = function (t, e, n) {
                      return {
                        text: "\r",
                        inlines: [],
                        entities: [],
                        blocks: [{
                          type: t,
                          depth: Math.max(0, Math.min(4, e)),
                          data: n || new s.Map({})
                        }]
                      };
                    },
                    C = function (t) {
                      return {
                        text: "\r ",
                        inlines: [new s.OrderedSet()],
                        entities: [t],
                        blocks: [{
                          type: "atomic",
                          depth: 0,
                          data: new s.Map({})
                        }]
                      };
                    },
                    L = function (t, e) {
                      return {
                        text: t.text + e.text,
                        inlines: t.inlines.concat(e.inlines),
                        entities: t.entities.concat(e.entities),
                        blocks: t.blocks.concat(e.blocks)
                      };
                    },
                    D = new s.Map({
                      "header-one": {
                        element: "h1"
                      },
                      "header-two": {
                        element: "h2"
                      },
                      "header-three": {
                        element: "h3"
                      },
                      "header-four": {
                        element: "h4"
                      },
                      "header-five": {
                        element: "h5"
                      },
                      "header-six": {
                        element: "h6"
                      },
                      "unordered-list-item": {
                        element: "li",
                        wrapper: "ul"
                      },
                      "ordered-list-item": {
                        element: "li",
                        wrapper: "ol"
                      },
                      blockquote: {
                        element: "blockquote"
                      },
                      code: {
                        element: "pre"
                      },
                      atomic: {
                        element: "figure"
                      },
                      unstyled: {
                        element: "p",
                        aliasedElements: ["div"]
                      }
                    }),
                    k = {
                      code: "CODE",
                      del: "STRIKETHROUGH",
                      em: "ITALIC",
                      strong: "BOLD",
                      ins: "UNDERLINE",
                      sub: "SUBSCRIPT",
                      sup: "SUPERSCRIPT"
                    };
                  function O(t) {
                    return t.style.textAlign ? new s.Map({
                      "text-align": t.style.textAlign
                    }) : t.style.marginLeft ? new s.Map({
                      "margin-left": t.style.marginLeft
                    }) : void 0;
                  }
                  var x = function (t) {
                    var e = void 0;
                    if (t instanceof HTMLAnchorElement) {
                      var n = {};
                      e = t.dataset && void 0 !== t.dataset.mention ? (n.url = t.href, n.text = t.innerHTML, n.value = t.dataset.value, j.Entity.__create("MENTION", "IMMUTABLE", n)) : (n.url = t.getAttribute && t.getAttribute("href") || t.href, n.title = t.innerHTML, n.targetOption = t.target, j.Entity.__create("LINK", "MUTABLE", n));
                    }
                    return e;
                  };
                  n.d(e, "default", function () {
                    return o;
                  });
                  var u = " ",
                    p = new RegExp("&nbsp;", "g"),
                    I = true;
                  function o(t, e) {
                    var n,
                      o,
                      r,
                      i = (n = e, o = t.trim().replace(p, u), (r = function (t) {
                        var e,
                          n = null;
                        return document.implementation && document.implementation.createHTMLDocument && ((e = document.implementation.createHTMLDocument("foo")).documentElement.innerHTML = t, n = e.getElementsByTagName("body")[0]), n;
                      }(o)) ? (I = true, {
                        chunk: function t(e, n, o, r, i, c) {
                          var a = e.nodeName.toLowerCase();
                          if (c) {
                            var l = c(a, e);
                            if (l) {
                              var s = j.Entity.__create(l.type, l.mutability, l.data || {});
                              return {
                                chunk: C(s)
                              };
                            }
                          }
                          if ("#text" === a && "\n" !== e.textContent) return v(e, n, i);
                          if ("br" === a) return {
                            chunk: N()
                          };
                          if ("img" === a && e instanceof HTMLImageElement) {
                            var u = {};
                            u.src = e.getAttribute && e.getAttribute("src") || e.src, u.alt = e.alt, u.height = e.style.height, u.width = e.style.width, e.style.float && (u.alignment = e.style.float);
                            var p = j.Entity.__create("IMAGE", "MUTABLE", u);
                            return {
                              chunk: C(p)
                            };
                          }
                          if ("video" === a && e instanceof HTMLVideoElement) {
                            var d = {};
                            d.src = e.getAttribute && e.getAttribute("src") || e.src, d.alt = e.alt, d.height = e.style.height, d.width = e.style.width, e.style.float && (d.alignment = e.style.float);
                            var f = j.Entity.__create("VIDEO", "MUTABLE", d);
                            return {
                              chunk: C(f)
                            };
                          }
                          if ("iframe" === a && e instanceof HTMLIFrameElement) {
                            var y = {};
                            y.src = e.getAttribute && e.getAttribute("src") || e.src, y.height = e.height, y.width = e.width;
                            var m = j.Entity.__create("EMBEDDED_LINK", "MUTABLE", y);
                            return {
                              chunk: C(m)
                            };
                          }
                          var g,
                            b = function (e, n) {
                              var t = D.filter(function (t) {
                                return t.element === e && (!t.wrapper || t.wrapper === n) || t.wrapper === e || t.aliasedElements && -1 < t.aliasedElements.indexOf(e);
                              }).keySeq().toSet().toArray();
                              if (1 === t.length) return t[0];
                            }(a, r);
                          b && ("ul" === a || "ol" === a ? (r = a, o += 1) : ("unordered-list-item" !== b && "ordered-list-item" !== b && (r = "", o = -1), I ? (g = S(b, O(e)), I = false) : g = w(b, o, O(e)))), g = g || E(), n = function (t, e, n) {
                            var o,
                              r = k[t];
                            if (r) o = n.add(r).toOrderedSet();else if (e instanceof HTMLElement) {
                              var l = e;
                              o = (o = n).withMutations(function (t) {
                                var e = l.style.color,
                                  n = l.style.backgroundColor,
                                  o = l.style.fontSize,
                                  r = l.style.fontFamily.replace(/^"|"$/g, ""),
                                  i = l.style.fontWeight,
                                  c = l.style.textDecoration,
                                  a = l.style.fontStyle;
                                e && t.add("color-".concat(e.replace(/ /g, ""))), n && t.add("bgcolor-".concat(n.replace(/ /g, ""))), o && t.add("fontsize-".concat(o.replace(/px$/g, ""))), r && t.add("fontfamily-".concat(r)), "bold" === i && t.add(k.strong), "underline" === c && t.add(k.ins), "italic" === a && t.add(k.em);
                              }).toOrderedSet();
                            }
                            return o;
                          }(a, e, n);
                          for (var h = e.firstChild; h;) {
                            var M = t(h, n, o, r, x(h) || i, c).chunk;
                            g = L(g, M), h = h.nextSibling;
                          }
                          return {
                            chunk: g
                          };
                        }(r, new s.OrderedSet(), -1, "", void 0, n).chunk
                      }) : null);
                    if (i) {
                      var c = i.chunk,
                        a = new s.OrderedMap({});
                      c.entities && c.entities.forEach(function (t) {
                        t && (a = a.set(t, j.Entity.__get(t)));
                      });
                      var l = 0;
                      return {
                        contentBlocks: c.text.split("\r").map(function (t, e) {
                          var n = l + t.length,
                            o = c && c.inlines.slice(l, n),
                            r = c && c.entities.slice(l, n),
                            i = new s.List(o.map(function (t, e) {
                              var n = {
                                style: t,
                                entity: null
                              };
                              return r[e] && (n.entity = r[e]), j.CharacterMetadata.create(n);
                            }));
                          return l = n, new j.ContentBlock({
                            key: Object(j.genKey)(),
                            type: c && c.blocks[e] && c.blocks[e].type || "unstyled",
                            depth: c && c.blocks[e] && c.blocks[e].depth,
                            data: c && c.blocks[e] && c.blocks[e].data || new s.Map({}),
                            text: t,
                            characterList: i
                          });
                        }),
                        entityMap: a
                      };
                    }
                    return null;
                  }
                }], r.c = a, r.d = function (t, e, n) {
                  r.o(t, e) || Object.defineProperty(t, e, {
                    enumerable: true,
                    get: n
                  });
                }, r.r = function (t) {
                  "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                    value: "Module"
                  }), Object.defineProperty(t, "__esModule", {
                    value: true
                  });
                }, r.t = function (e, t) {
                  if (1 & t && (e = r(e)), 8 & t) return e;
                  if (4 & t && "object" == typeof e && e && e.__esModule) return e;
                  var n = Object.create(null);
                  if (r.r(n), Object.defineProperty(n, "default", {
                    enumerable: true,
                    value: e
                  }), 2 & t && "string" != typeof e) for (var o in e) r.d(n, o, function (t) {
                    return e[t];
                  }.bind(null, o));
                  return n;
                }, r.n = function (t) {
                  var e = t && t.__esModule ? function () {
                    return t.default;
                  } : function () {
                    return t;
                  };
                  return r.d(e, "a", e), e;
                }, r.o = function (t, e) {
                  return Object.prototype.hasOwnProperty.call(t, e);
                }, r.p = "", r(r.s = 2));
              }, function (t, e, l) {
                function o(n) {
                  return Array.prototype.slice.call(arguments, 1).forEach(function (e) {
                    e && Object.keys(e).forEach(function (t) {
                      n[t] = e[t];
                    });
                  }), n;
                }
                function s(t) {
                  return Object.prototype.toString.call(t);
                }
                function u(t) {
                  return "[object Function]" === s(t);
                }
                function p(t) {
                  return t.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
                }
                var r = {
                  fuzzyLink: true,
                  fuzzyEmail: true,
                  fuzzyIP: false
                };
                var i = {
                    "http:": {
                      validate: function (t, e, n) {
                        var o = t.slice(e);
                        return n.re.http || (n.re.http = new RegExp("^\\/\\/" + n.re.src_auth + n.re.src_host_port_strict + n.re.src_path, "i")), n.re.http.test(o) ? o.match(n.re.http)[0].length : 0;
                      }
                    },
                    "https:": "http:",
                    "ftp:": "http:",
                    "//": {
                      validate: function (t, e, n) {
                        var o = t.slice(e);
                        return n.re.no_http || (n.re.no_http = new RegExp("^" + n.re.src_auth + "(?:localhost|(?:(?:" + n.re.src_domain + ")\\.)+" + n.re.src_domain_root + ")" + n.re.src_port + n.re.src_host_terminator + n.re.src_path, "i")), n.re.no_http.test(o) ? 3 <= e && ":" === t[e - 3] ? 0 : 3 <= e && "/" === t[e - 3] ? 0 : o.match(n.re.no_http)[0].length : 0;
                      }
                    },
                    "mailto:": {
                      validate: function (t, e, n) {
                        var o = t.slice(e);
                        return n.re.mailto || (n.re.mailto = new RegExp("^" + n.re.src_email_name + "@" + n.re.src_host_strict, "i")), n.re.mailto.test(o) ? o.match(n.re.mailto)[0].length : 0;
                      }
                    }
                  },
                  d = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",
                  c = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
                function f() {
                  return function (t, e) {
                    e.normalize(t);
                  };
                }
                function a(r) {
                  var e = r.re = l(21)(r.__opts__),
                    t = r.__tlds__.slice();
                  function n(t) {
                    return t.replace("%TLDS%", e.src_tlds);
                  }
                  r.onCompile(), r.__tlds_replaced__ || t.push(d), t.push(e.src_xn), e.src_tlds = t.join("|"), e.email_fuzzy = RegExp(n(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(n(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(n(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(n(e.tpl_host_fuzzy_test), "i");
                  var i = [];
                  function c(t, e) {
                    throw new Error('(LinkifyIt) Invalid schema "' + t + '": ' + e);
                  }
                  r.__compiled__ = {}, Object.keys(r.__schemas__).forEach(function (t) {
                    var e = r.__schemas__[t];
                    if (null !== e) {
                      var o,
                        n = {
                          validate: null,
                          link: null
                        };
                      if (r.__compiled__[t] = n, "[object Object]" === s(e)) return "[object RegExp]" === s(e.validate) ? n.validate = (o = e.validate, function (t, e) {
                        var n = t.slice(e);
                        return o.test(n) ? n.match(o)[0].length : 0;
                      }) : u(e.validate) ? n.validate = e.validate : c(t, e), void (u(e.normalize) ? n.normalize = e.normalize : e.normalize ? c(t, e) : n.normalize = f());
                      if ("[object String]" !== s(e)) c(t, e);else i.push(t);
                    }
                  }), i.forEach(function (t) {
                    r.__compiled__[r.__schemas__[t]] && (r.__compiled__[t].validate = r.__compiled__[r.__schemas__[t]].validate, r.__compiled__[t].normalize = r.__compiled__[r.__schemas__[t]].normalize);
                  }), r.__compiled__[""] = {
                    validate: null,
                    normalize: f()
                  };
                  var o,
                    a = Object.keys(r.__compiled__).filter(function (t) {
                      return 0 < t.length && r.__compiled__[t];
                    }).map(p).join("|");
                  r.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + e.src_ZPCc + "))(" + a + ")", "i"), r.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + e.src_ZPCc + "))(" + a + ")", "ig"), r.re.pretest = RegExp("(" + r.re.schema_test.source + ")|(" + r.re.host_fuzzy_test.source + ")|@", "i"), (o = r).__index__ = -1, o.__text_cache__ = "";
                }
                function y(t, e) {
                  var n = t.__index__,
                    o = t.__last_index__,
                    r = t.__text_cache__.slice(n, o);
                  this.schema = t.__schema__.toLowerCase(), this.index = n + e, this.lastIndex = o + e, this.raw = r, this.text = r, this.url = r;
                }
                function m(t, e) {
                  var n = new y(t, e);
                  return t.__compiled__[n.schema].normalize(n, t), n;
                }
                function g(t, e) {
                  if (!(this instanceof g)) return new g(t, e);
                  var n;
                  e || (n = t, Object.keys(n || {}).reduce(function (t, e) {
                    return t || r.hasOwnProperty(e);
                  }, false) && (e = t, t = {})), this.__opts__ = o({}, r, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = o({}, i, t), this.__compiled__ = {}, this.__tlds__ = c, this.__tlds_replaced__ = false, this.re = {}, a(this);
                }
                g.prototype.add = function (t, e) {
                  return this.__schemas__[t] = e, a(this), this;
                }, g.prototype.set = function (t) {
                  return this.__opts__ = o(this.__opts__, t), this;
                }, g.prototype.test = function (t) {
                  if (this.__text_cache__ = t, this.__index__ = -1, !t.length) return false;
                  var e, n, o, r, i, c, a, l;
                  if (this.re.schema_test.test(t)) for ((a = this.re.schema_search).lastIndex = 0; null !== (e = a.exec(t));) if (r = this.testSchemaAt(t, e[2], a.lastIndex)) {
                    this.__schema__ = e[2], this.__index__ = e.index + e[1].length, this.__last_index__ = e.index + e[0].length + r;
                    break;
                  }
                  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && 0 <= (l = t.search(this.re.host_fuzzy_test)) && (this.__index__ < 0 || l < this.__index__) && null !== (n = t.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) && (i = n.index + n[1].length, (this.__index__ < 0 || i < this.__index__) && (this.__schema__ = "", this.__index__ = i, this.__last_index__ = n.index + n[0].length)), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && 0 <= t.indexOf("@") && null !== (o = t.match(this.re.email_fuzzy)) && (i = o.index + o[1].length, c = o.index + o[0].length, (this.__index__ < 0 || i < this.__index__ || i === this.__index__ && c > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = i, this.__last_index__ = c)), 0 <= this.__index__;
                }, g.prototype.pretest = function (t) {
                  return this.re.pretest.test(t);
                }, g.prototype.testSchemaAt = function (t, e, n) {
                  return this.__compiled__[e.toLowerCase()] ? this.__compiled__[e.toLowerCase()].validate(t, n, this) : 0;
                }, g.prototype.match = function (t) {
                  var e = 0,
                    n = [];
                  0 <= this.__index__ && this.__text_cache__ === t && (n.push(m(this, e)), e = this.__last_index__);
                  for (var o = e ? t.slice(e) : t; this.test(o);) n.push(m(this, e)), o = o.slice(this.__last_index__), e += this.__last_index__;
                  return n.length ? n : null;
                }, g.prototype.tlds = function (t, e) {
                  return t = Array.isArray(t) ? t : [t], e ? this.__tlds__ = this.__tlds__.concat(t).sort().filter(function (t, e, n) {
                    return t !== n[e - 1];
                  }).reverse() : (this.__tlds__ = t.slice(), this.__tlds_replaced__ = true), a(this), this;
                }, g.prototype.normalize = function (t) {
                  t.schema || (t.url = "http://" + t.url), "mailto:" !== t.schema || /^mailto:/i.test(t.url) || (t.url = "mailto:" + t.url);
                }, g.prototype.onCompile = function () {}, t.exports = g;
              }, function (t, e, n) {
                t.exports = n(40);
              }, function (t, e, n) {}, function (t, e, n) {
                var a = n(11);
                function o() {}
                function r() {}
                r.resetWarningCache = o, t.exports = function () {
                  function t(t, e, n, o, r, i) {
                    if (i !== a) {
                      var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                      throw c.name = "Invariant Violation", c;
                    }
                  }
                  function e() {
                    return t;
                  }
                  var n = {
                    array: t.isRequired = t,
                    bigint: t,
                    bool: t,
                    func: t,
                    number: t,
                    object: t,
                    string: t,
                    symbol: t,
                    any: t,
                    arrayOf: e,
                    element: t,
                    elementType: t,
                    instanceOf: e,
                    node: t,
                    objectOf: e,
                    oneOf: e,
                    oneOfType: e,
                    shape: e,
                    exact: e,
                    checkPropTypes: r,
                    resetWarningCache: o
                  };
                  return n.PropTypes = n;
                };
              }, function (t, e, n) {
                t.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
              }, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, o) {
                t.exports = function (t) {
                  var e = {};
                  e.src_Any = o(22).source, e.src_Cc = o(23).source, e.src_Z = o(24).source, e.src_P = o(25).source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
                  var n = "[><]";
                  return e.src_pseudo_letter = "(?:(?![><]|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|[><]|" + e.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + n + "|[()[\\]{}.,\"'?!\\-]).|\\[(?:(?!" + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + '|["]).)+\\"|\\\'(?:(?!' + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-]).|\\.{2,4}[a-zA-Z0-9%/]|\\.(?!" + e.src_ZCc + "|[.]).|" + (t && t["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + "\\,(?!" + e.src_ZCc + ").|\\!(?!" + e.src_ZCc + "|[!]).|\\?(?!" + e.src_ZCc + "|[?]).)+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = '(^|[><]|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + e.src_ZPCc + "))((?![$+<=>^`|])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + e.src_ZPCc + "))((?![$+<=>^`|])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
                };
              }, function (t, e) {
                t.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
              }, function (t, e) {
                t.exports = /[\0-\x1F\x7F-\x9F]/;
              }, function (t, e) {
                t.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
              }, function (t, e) {
                t.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
              }, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {}, function (t, e, n) {
                n.r(e), n.d(e, "Editor", function () {
                  return ar;
                });
                var f = n(1),
                  N = n.n(f),
                  o = n(0),
                  y = n.n(o),
                  E = n(3),
                  S = n(4),
                  r = n(2),
                  w = n.n(r);
                function c(t, e, n) {
                  return Object.defineProperty(t, "prototype", {
                    writable: false
                  }), t;
                }
                var a = c(function t() {
                  var n = this;
                  !function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                  }(this, t), this.callBacks = [], this.suggestionCallback = void 0, this.editorFlag = false, this.suggestionFlag = false, this.closeAllModals = function (e) {
                    n.callBacks.forEach(function (t) {
                      t(e);
                    });
                  }, this.init = function (t) {
                    var e = document.getElementById(t);
                    e && e.addEventListener("click", function () {
                      n.editorFlag = true;
                    }), document && (document.addEventListener("click", function () {
                      n.editorFlag ? n.editorFlag = false : (n.closeAllModals(), n.suggestionCallback && n.suggestionCallback());
                    }), document.addEventListener("keydown", function (t) {
                      "Escape" === t.key && n.closeAllModals();
                    }));
                  }, this.onEditorClick = function () {
                    n.closeModals(), !n.suggestionFlag && n.suggestionCallback ? n.suggestionCallback() : n.suggestionFlag = false;
                  }, this.closeModals = function (t) {
                    n.closeAllModals(t);
                  }, this.registerCallBack = function (t) {
                    n.callBacks.push(t);
                  }, this.deregisterCallBack = function (e) {
                    n.callBacks = n.callBacks.filter(function (t) {
                      return t !== e;
                    });
                  }, this.setSuggestionCallback = function (t) {
                    n.suggestionCallback = t;
                  }, this.removeSuggestionCallback = function () {
                    n.suggestionCallback = void 0;
                  }, this.onSuggestionClick = function () {
                    n.suggestionFlag = true;
                  };
                });
                function s(t, e, n) {
                  return Object.defineProperty(t, "prototype", {
                    writable: false
                  }), t;
                }
                var u,
                  p = s(function t() {
                    var e = this;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, t), this.inputFocused = false, this.editorMouseDown = false, this.onEditorMouseDown = function () {
                      e.editorFocused = true;
                    }, this.onInputMouseDown = function () {
                      e.inputFocused = true;
                    }, this.isEditorBlur = function (t) {
                      return "INPUT" !== t.target.tagName && "LABEL" !== t.target.tagName && "TEXTAREA" !== t.target.tagName || e.editorFocused ? !("INPUT" === t.target.tagName && "LABEL" === t.target.tagName && "TEXTAREA" === t.target.tagName || e.inputFocused) && !(e.editorFocused = false) : !(e.inputFocused = false);
                    }, this.isEditorFocused = function () {
                      return !e.inputFocused || (e.inputFocused = false);
                    }, this.isToolbarFocused = function () {
                      return !e.editorFocused || (e.editorFocused = false);
                    }, this.isInputFocused = function () {
                      return e.inputFocused;
                    };
                  }),
                  d = [],
                  C = {
                    onKeyDown: function (e) {
                      d.forEach(function (t) {
                        t(e);
                      });
                    },
                    registerCallBack: function (t) {
                      d.push(t);
                    },
                    deregisterCallBack: function (e) {
                      d = d.filter(function (t) {
                        return t !== e;
                      });
                    }
                  },
                  m = function () {
                    u = true;
                  },
                  g = function () {
                    u = false;
                  },
                  b = function () {
                    return u;
                  };
                function L(t) {
                  var e = t.getData() && t.getData().get("text-align");
                  return e ? "rdw-".concat(e, "-aligned-block") : "";
                }
                function h(t, e) {
                  if (t) for (var n in t) !{}.hasOwnProperty.call(t, n) || e(n, t[n]);
                }
                function M(t, e) {
                  var n = false;
                  if (t) for (var o in t) if ({}.hasOwnProperty.call(t, o) && e === o) {
                    n = true;
                    break;
                  }
                  return n;
                }
                function j(t) {
                  t.stopPropagation();
                }
                function v(t) {
                  return t[t.options[0]].icon;
                }
                function D(t, o) {
                  if (t && void 0 === o) return t;
                  var r = {};
                  return h(t, function (t, e) {
                    var n;
                    n = e, "[object Object]" === Object.prototype.toString.call(n) ? r[t] = D(e, o[t]) : r[t] = void 0 !== o[t] ? o[t] : e;
                  }), r;
                }
                var k = n(6),
                  O = n.n(k),
                  x = n(5);
                n(9);
                function I(t) {
                  return (I = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function T(t, e, n) {
                  return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  }) : t[e] = n, t;
                }
                function A(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function z(t, e) {
                  return (z = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function _(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = P(o);
                    if (r) {
                      var n = P(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === I(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function P(t) {
                  return (P = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var R = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && z(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    o = _(i);
                  function i() {
                    var r;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i);
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return (r = o.call.apply(o, [this].concat(e))).onClick = function () {
                      var t = r.props,
                        e = t.disabled,
                        n = t.onClick,
                        o = t.value;
                      e || n(o);
                    }, r;
                  }
                  return t = i, (e = [{
                    key: "render",
                    value: function () {
                      var t,
                        e = this.props,
                        n = e.children,
                        o = e.className,
                        r = e.activeClassName,
                        i = e.active,
                        c = e.disabled,
                        a = e.title;
                      return N.a.createElement("div", {
                        className: w()("rdw-option-wrapper", o, (T(t = {}, "rdw-option-active ".concat(r), i), T(t, "rdw-option-disabled", c), t)),
                        onClick: this.onClick,
                        "aria-selected": i,
                        title: a
                      }, n);
                    }
                  }]) && A(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                R.propTypes = {
                  onClick: y.a.func.isRequired,
                  children: y.a.any,
                  value: y.a.string,
                  className: y.a.string,
                  activeClassName: y.a.string,
                  active: y.a.bool,
                  disabled: y.a.bool,
                  title: y.a.string
                }, R.defaultProps = {
                  activeClassName: ""
                };
                n(12);
                function U(t) {
                  return (U = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function B(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function F(t, e) {
                  return (F = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Y(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Q(o);
                    if (r) {
                      var n = Q(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === U(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Q(t) {
                  return (Q = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var H = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && F(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    r = Y(i);
                  function i() {
                    var o;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i);
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return (o = r.call.apply(r, [this].concat(e))).state = {
                      highlighted: -1
                    }, o.onChange = function (t) {
                      var e = o.props.onChange;
                      e && e(t), o.toggleExpansion();
                    }, o.setHighlighted = function (t) {
                      o.setState({
                        highlighted: t
                      });
                    }, o.toggleExpansion = function () {
                      var t = o.props,
                        e = t.doExpand,
                        n = t.doCollapse;
                      t.expanded ? n() : e();
                    }, o;
                  }
                  return t = i, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      var e = this.props.expanded;
                      t.expanded && !e && this.setState({
                        highlighted: -1
                      });
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var n = this,
                        t = this.props,
                        e = t.expanded,
                        o = t.children,
                        r = t.className,
                        i = t.optionWrapperClassName,
                        c = t.ariaLabel,
                        a = t.onExpandEvent,
                        l = t.title,
                        s = this.state.highlighted,
                        u = o.slice(1, o.length);
                      return N.a.createElement("div", {
                        className: w()("rdw-dropdown-wrapper", r),
                        "aria-expanded": e,
                        "aria-label": c || "rdw-dropdown"
                      }, N.a.createElement("a", {
                        className: "rdw-dropdown-selectedtext",
                        onClick: a,
                        title: l
                      }, o[0], N.a.createElement("div", {
                        className: w()({
                          "rdw-dropdown-carettoclose": e,
                          "rdw-dropdown-carettoopen": !e
                        })
                      })), e ? N.a.createElement("ul", {
                        className: w()("rdw-dropdown-optionwrapper", i),
                        onClick: j
                      }, N.a.Children.map(u, function (t, e) {
                        return t && N.a.cloneElement(t, {
                          onSelect: n.onChange,
                          highlighted: s === e,
                          setHighlighted: n.setHighlighted,
                          index: e
                        });
                      })) : void 0);
                    }
                  }]) && B(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                H.propTypes = {
                  children: y.a.any,
                  onChange: y.a.func,
                  className: y.a.string,
                  expanded: y.a.bool,
                  doExpand: y.a.func,
                  doCollapse: y.a.func,
                  onExpandEvent: y.a.func,
                  optionWrapperClassName: y.a.string,
                  ariaLabel: y.a.string,
                  title: y.a.string
                };
                n(13);
                function Z(t) {
                  return (Z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function W(t, e, n) {
                  return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  }) : t[e] = n, t;
                }
                function G(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function J(t, e) {
                  return (J = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function V(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = q(o);
                    if (r) {
                      var n = q(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === Z(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function q(t) {
                  return (q = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var K = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && J(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = V(r);
                  function r() {
                    var i;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r);
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return (i = o.call.apply(o, [this].concat(e))).onClick = function (t) {
                      var e = i.props,
                        n = e.onSelect,
                        o = e.onClick,
                        r = e.value;
                      e.disabled || (n && n(r), o && (t.stopPropagation(), o(r)));
                    }, i.setHighlighted = function () {
                      var t = i.props;
                      (0, t.setHighlighted)(t.index);
                    }, i.resetHighlighted = function () {
                      (0, i.props.setHighlighted)(-1);
                    }, i;
                  }
                  return t = r, (e = [{
                    key: "render",
                    value: function () {
                      var t,
                        e = this.props,
                        n = e.children,
                        o = e.active,
                        r = e.disabled,
                        i = e.highlighted,
                        c = e.className,
                        a = e.activeClassName,
                        l = e.disabledClassName,
                        s = e.highlightedClassName,
                        u = e.title;
                      return N.a.createElement("li", {
                        className: w()("rdw-dropdownoption-default", c, (W(t = {}, "rdw-dropdownoption-active ".concat(a), o), W(t, "rdw-dropdownoption-highlighted ".concat(s), i), W(t, "rdw-dropdownoption-disabled ".concat(l), r), t)),
                        onMouseEnter: this.setHighlighted,
                        onMouseLeave: this.resetHighlighted,
                        onClick: this.onClick,
                        title: u
                      }, n);
                    }
                  }]) && G(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                K.propTypes = {
                  children: y.a.any,
                  value: y.a.any,
                  onClick: y.a.func,
                  onSelect: y.a.func,
                  setHighlighted: y.a.func,
                  index: y.a.number,
                  disabled: y.a.bool,
                  active: y.a.bool,
                  highlighted: y.a.bool,
                  className: y.a.string,
                  activeClassName: y.a.string,
                  disabledClassName: y.a.string,
                  highlightedClassName: y.a.string,
                  title: y.a.string
                }, K.defaultProps = {
                  activeClassName: "",
                  disabledClassName: "",
                  highlightedClassName: ""
                };
                n(14);
                function X(t) {
                  return (X = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function $(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function tt(t, e) {
                  return (tt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function et(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = nt(o);
                    if (r) {
                      var n = nt(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === X(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function nt(t) {
                  return (nt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var ot = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && tt(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = et(r);
                  function r() {
                    return function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r), o.apply(this, arguments);
                  }
                  return t = r, (e = [{
                    key: "renderInFlatList",
                    value: function () {
                      var t = this.props,
                        n = t.config,
                        o = t.currentState,
                        r = t.onChange,
                        i = t.translations;
                      return N.a.createElement("div", {
                        className: w()("rdw-inline-wrapper", n.className),
                        "aria-label": "rdw-inline-control"
                      }, n.options.map(function (t, e) {
                        return N.a.createElement(R, {
                          key: e,
                          value: t,
                          onClick: r,
                          className: w()(n[t].className),
                          active: true === o[t] || "MONOSPACE" === t && o.CODE,
                          title: n[t].title || i["components.controls.inline.".concat(t)]
                        }, N.a.createElement("img", {
                          alt: "",
                          src: n[t].icon
                        }));
                      }));
                    }
                  }, {
                    key: "renderInDropDown",
                    value: function () {
                      var t = this.props,
                        n = t.config,
                        e = t.expanded,
                        o = t.doExpand,
                        r = t.onExpandEvent,
                        i = t.doCollapse,
                        c = t.currentState,
                        a = t.onChange,
                        l = t.translations,
                        s = n.className,
                        u = n.dropdownClassName,
                        p = n.title;
                      return N.a.createElement(H, {
                        className: w()("rdw-inline-dropdown", s),
                        optionWrapperClassName: w()(u),
                        onChange: a,
                        expanded: e,
                        doExpand: o,
                        doCollapse: i,
                        onExpandEvent: r,
                        "aria-label": "rdw-inline-control",
                        title: p
                      }, N.a.createElement("img", {
                        src: v(n),
                        alt: ""
                      }), n.options.map(function (t, e) {
                        return N.a.createElement(K, {
                          key: e,
                          value: t,
                          className: w()("rdw-inline-dropdownoption", n[t].className),
                          active: true === c[t] || "MONOSPACE" === t && c.CODE,
                          title: n[t].title || l["components.controls.inline.".concat(t)]
                        }, N.a.createElement("img", {
                          src: n[t].icon,
                          alt: ""
                        }));
                      }));
                    }
                  }, {
                    key: "render",
                    value: function () {
                      return this.props.config.inDropdown ? this.renderInDropDown() : this.renderInFlatList();
                    }
                  }]) && $(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                function rt(t) {
                  return (rt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function it(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function ct(t, e) {
                  return (ct = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function at(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = lt(o);
                    if (r) {
                      var n = lt(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === rt(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function lt(t) {
                  return (lt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                ot.propTypes = {
                  expanded: y.a.bool,
                  doExpand: y.a.func,
                  doCollapse: y.a.func,
                  onExpandEvent: y.a.func,
                  config: y.a.object,
                  onChange: y.a.func,
                  currentState: y.a.object,
                  translations: y.a.object
                };
                var st = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && ct(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    r = at(i);
                  function i(t) {
                    var l;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i), (l = r.call(this, t)).onExpandEvent = function () {
                      l.signalExpanded = !l.state.expanded;
                    }, l.expandCollapse = function () {
                      l.setState({
                        expanded: l.signalExpanded
                      }), l.signalExpanded = false;
                    }, l.toggleInlineStyle = function (t) {
                      var e = "monospace" === t ? "CODE" : t.toUpperCase(),
                        n = l.props,
                        o = n.editorState,
                        r = n.onChange,
                        i = E.RichUtils.toggleInlineStyle(o, e);
                      if ("subscript" === t || "superscript" === t) {
                        var c = "subscript" === t ? "SUPERSCRIPT" : "SUBSCRIPT",
                          a = E.Modifier.removeInlineStyle(i.getCurrentContent(), i.getSelection(), c);
                        i = E.EditorState.push(i, a, "change-inline-style");
                      }
                      i && r(i);
                    }, l.changeKeys = function (t) {
                      if (t) {
                        var n = {};
                        return h(t, function (t, e) {
                          n["CODE" === t ? "monospace" : t.toLowerCase()] = e;
                        }), n;
                      }
                    }, l.doExpand = function () {
                      l.setState({
                        expanded: true
                      });
                    }, l.doCollapse = function () {
                      l.setState({
                        expanded: false
                      });
                    };
                    var e = l.props,
                      n = e.editorState,
                      o = e.modalHandler;
                    return l.state = {
                      currentStyles: n ? l.changeKeys(Object(S.getSelectionInlineStyle)(n)) : {}
                    }, o.registerCallBack(l.expandCollapse), l;
                  }
                  return t = i, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      var e = this.props.editorState;
                      e && e !== t.editorState && this.setState({
                        currentStyles: this.changeKeys(Object(S.getSelectionInlineStyle)(e))
                      });
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.translations,
                        o = this.state,
                        r = o.expanded,
                        i = o.currentStyles,
                        c = e.component || ot;
                      return N.a.createElement(c, {
                        config: e,
                        translations: n,
                        currentState: i,
                        expanded: r,
                        onExpandEvent: this.onExpandEvent,
                        doExpand: this.doExpand,
                        doCollapse: this.doCollapse,
                        onChange: this.toggleInlineStyle
                      });
                    }
                  }]) && it(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                st.propTypes = {
                  onChange: y.a.func.isRequired,
                  editorState: y.a.object.isRequired,
                  modalHandler: y.a.object,
                  config: y.a.object,
                  translations: y.a.object
                };
                n(15);
                function ut(t) {
                  return (ut = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function pt(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function dt(t, e) {
                  return (dt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function ft(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = yt(o);
                    if (r) {
                      var n = yt(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === ut(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function yt(t) {
                  return (yt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var mt = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && dt(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = ft(r);
                  function r(t) {
                    var e;
                    return function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r), (e = o.call(this, t)).getBlockTypes = function (t) {
                      return [{
                        label: "Normal",
                        displayName: t["components.controls.blocktype.normal"]
                      }, {
                        label: "H1",
                        displayName: t["components.controls.blocktype.h1"]
                      }, {
                        label: "H2",
                        displayName: t["components.controls.blocktype.h2"]
                      }, {
                        label: "H3",
                        displayName: t["components.controls.blocktype.h3"]
                      }, {
                        label: "H4",
                        displayName: t["components.controls.blocktype.h4"]
                      }, {
                        label: "H5",
                        displayName: t["components.controls.blocktype.h5"]
                      }, {
                        label: "H6",
                        displayName: t["components.controls.blocktype.h6"]
                      }, {
                        label: "Blockquote",
                        displayName: t["components.controls.blocktype.blockquote"]
                      }, {
                        label: "Code",
                        displayName: t["components.controls.blocktype.code"]
                      }];
                    }, e.state = {
                      blockTypes: e.getBlockTypes(t.translations)
                    }, e;
                  }
                  return t = r, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      var e = this.props.translations;
                      e !== t.translations && this.setState({
                        blockTypes: this.getBlockTypes(e)
                      });
                    }
                  }, {
                    key: "renderFlat",
                    value: function (t) {
                      var e = this.props,
                        n = e.config.className,
                        o = e.onChange,
                        r = e.currentState.blockType;
                      return N.a.createElement("div", {
                        className: w()("rdw-inline-wrapper", n)
                      }, t.map(function (t, e) {
                        return N.a.createElement(R, {
                          key: e,
                          value: t.label,
                          active: r === t.label,
                          onClick: o
                        }, t.displayName);
                      }));
                    }
                  }, {
                    key: "renderInDropdown",
                    value: function (t) {
                      var e = this.props,
                        n = e.config,
                        o = n.className,
                        r = n.dropdownClassName,
                        i = n.title,
                        c = e.currentState.blockType,
                        a = e.expanded,
                        l = e.doExpand,
                        s = e.onExpandEvent,
                        u = e.doCollapse,
                        p = e.onChange,
                        d = e.translations,
                        f = this.state.blockTypes.filter(function (t) {
                          return t.label === c;
                        }),
                        y = f && f[0] && f[0].displayName;
                      return N.a.createElement("div", {
                        className: "rdw-block-wrapper",
                        "aria-label": "rdw-block-control"
                      }, N.a.createElement(H, {
                        className: w()("rdw-block-dropdown", o),
                        optionWrapperClassName: w()(r),
                        onChange: p,
                        expanded: a,
                        doExpand: l,
                        doCollapse: u,
                        onExpandEvent: s,
                        title: i || d["components.controls.blocktype.blocktype"]
                      }, N.a.createElement("span", null, y || d["components.controls.blocktype.blocktype"]), t.map(function (t, e) {
                        return N.a.createElement(K, {
                          active: c === t.label,
                          value: t.label,
                          key: e
                        }, t.displayName);
                      })));
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var n = this.props.config,
                        t = n.inDropdown,
                        e = this.state.blockTypes.filter(function (t) {
                          var e = t.label;
                          return -1 < n.options.indexOf(e);
                        });
                      return t ? this.renderInDropdown(e) : this.renderFlat(e);
                    }
                  }]) && pt(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                mt.propTypes = {
                  expanded: y.a.bool,
                  onExpandEvent: y.a.func,
                  doExpand: y.a.func,
                  doCollapse: y.a.func,
                  onChange: y.a.func,
                  config: y.a.object,
                  currentState: y.a.object,
                  translations: y.a.object
                };
                var gt = mt;
                function bt(t) {
                  return (bt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function ht(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function Mt(t, e) {
                  return (Mt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function jt(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = vt(o);
                    if (r) {
                      var n = vt(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === bt(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function vt(t) {
                  return (vt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var Nt = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && Mt(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = jt(r);
                  function r(t) {
                    var c;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r), (c = o.call(this, t)).onExpandEvent = function () {
                      c.signalExpanded = !c.state.expanded;
                    }, c.expandCollapse = function () {
                      c.setState({
                        expanded: c.signalExpanded
                      }), c.signalExpanded = false;
                    }, c.blocksTypes = [{
                      label: "Normal",
                      style: "unstyled"
                    }, {
                      label: "H1",
                      style: "header-one"
                    }, {
                      label: "H2",
                      style: "header-two"
                    }, {
                      label: "H3",
                      style: "header-three"
                    }, {
                      label: "H4",
                      style: "header-four"
                    }, {
                      label: "H5",
                      style: "header-five"
                    }, {
                      label: "H6",
                      style: "header-six"
                    }, {
                      label: "Blockquote",
                      style: "blockquote"
                    }, {
                      label: "Code",
                      style: "code"
                    }], c.doExpand = function () {
                      c.setState({
                        expanded: true
                      });
                    }, c.doCollapse = function () {
                      c.setState({
                        expanded: false
                      });
                    }, c.toggleBlockType = function (e) {
                      var t = c.blocksTypes.find(function (t) {
                          return t.label === e;
                        }).style,
                        n = c.props,
                        o = n.editorState,
                        r = n.onChange,
                        i = E.RichUtils.toggleBlockType(o, t);
                      i && r(i);
                    };
                    var e = t.editorState,
                      n = t.modalHandler;
                    return c.state = {
                      expanded: false,
                      currentBlockType: e ? Object(S.getSelectedBlocksType)(e) : "unstyled"
                    }, n.registerCallBack(c.expandCollapse), c;
                  }
                  return t = r, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      var e = this.props.editorState;
                      e && e !== t.editorState && this.setState({
                        currentBlockType: Object(S.getSelectedBlocksType)(e)
                      });
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.translations,
                        o = this.state,
                        r = o.expanded,
                        i = o.currentBlockType,
                        c = e.component || gt,
                        a = this.blocksTypes.find(function (t) {
                          return t.style === i;
                        });
                      return N.a.createElement(c, {
                        config: e,
                        translations: n,
                        currentState: {
                          blockType: a && a.label
                        },
                        onChange: this.toggleBlockType,
                        expanded: r,
                        onExpandEvent: this.onExpandEvent,
                        doExpand: this.doExpand,
                        doCollapse: this.doCollapse
                      });
                    }
                  }]) && ht(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                Nt.propTypes = {
                  onChange: y.a.func.isRequired,
                  editorState: y.a.object,
                  modalHandler: y.a.object,
                  config: y.a.object,
                  translations: y.a.object
                };
                var Et = Nt;
                n(16);
                function St(t) {
                  return (St = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function wt(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function Ct(t, e) {
                  return (Ct = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Lt(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Dt(o);
                    if (r) {
                      var n = Dt(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === St(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Dt(t) {
                  return (Dt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var kt = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && Ct(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    r = Lt(i);
                  function i() {
                    var t;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i);
                    for (var e = arguments.length, n = new Array(e), o = 0; o < e; o++) n[o] = arguments[o];
                    return (t = r.call.apply(r, [this].concat(n))).state = {
                      defaultFontSize: void 0
                    }, t;
                  }
                  return t = i, (e = [{
                    key: "componentDidMount",
                    value: function () {
                      var t = document.getElementsByClassName("DraftEditor-root");
                      if (t && 0 < t.length) {
                        var e = window.getComputedStyle(t[0]).getPropertyValue("font-size");
                        e = e.substring(0, e.length - 2), this.setState({
                          defaultFontSize: e
                        });
                      }
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = e.icon,
                        o = e.className,
                        r = e.dropdownClassName,
                        i = e.options,
                        c = e.title,
                        a = t.onChange,
                        l = t.expanded,
                        s = t.doCollapse,
                        u = t.onExpandEvent,
                        p = t.doExpand,
                        d = t.translations,
                        f = this.props.currentState.fontSize,
                        y = this.state.defaultFontSize;
                      return y = Number(y), f = f || i && 0 <= i.indexOf(y) && y, N.a.createElement("div", {
                        className: "rdw-fontsize-wrapper",
                        "aria-label": "rdw-font-size-control"
                      }, N.a.createElement(H, {
                        className: w()("rdw-fontsize-dropdown", o),
                        optionWrapperClassName: w()(r),
                        onChange: a,
                        expanded: l,
                        doExpand: p,
                        doCollapse: s,
                        onExpandEvent: u,
                        title: c || d["components.controls.fontsize.fontsize"]
                      }, f ? N.a.createElement("span", null, f) : N.a.createElement("img", {
                        src: n,
                        alt: ""
                      }), i.map(function (t, e) {
                        return N.a.createElement(K, {
                          className: "rdw-fontsize-option",
                          active: f === t,
                          value: t,
                          key: e
                        }, t);
                      })));
                    }
                  }]) && wt(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                function Ot(t) {
                  return (Ot = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function xt(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function It(t, e) {
                  return (It = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Tt(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = At(o);
                    if (r) {
                      var n = At(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === Ot(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function At(t) {
                  return (At = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                kt.propTypes = {
                  expanded: y.a.bool,
                  onExpandEvent: y.a.func,
                  doExpand: y.a.func,
                  doCollapse: y.a.func,
                  onChange: y.a.func,
                  config: y.a.object,
                  currentState: y.a.object,
                  translations: y.a.object
                };
                var zt = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && It(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = Tt(r);
                  function r(t) {
                    var i;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r), (i = o.call(this, t)).onExpandEvent = function () {
                      i.signalExpanded = !i.state.expanded;
                    }, i.expandCollapse = function () {
                      i.setState({
                        expanded: i.signalExpanded
                      }), i.signalExpanded = false;
                    }, i.doExpand = function () {
                      i.setState({
                        expanded: true
                      });
                    }, i.doCollapse = function () {
                      i.setState({
                        expanded: false
                      });
                    }, i.toggleFontSize = function (t) {
                      var e = i.props,
                        n = e.editorState,
                        o = e.onChange,
                        r = Object(S.toggleCustomInlineStyle)(n, "fontSize", t);
                      r && o(r);
                    };
                    var e = t.editorState,
                      n = t.modalHandler;
                    return i.state = {
                      expanded: void 0,
                      currentFontSize: e ? Object(S.getSelectionCustomInlineStyle)(e, ["FONTSIZE"]).FONTSIZE : void 0
                    }, n.registerCallBack(i.expandCollapse), i;
                  }
                  return t = r, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      var e = this.props.editorState;
                      e && e !== t.editorState && this.setState({
                        currentFontSize: Object(S.getSelectionCustomInlineStyle)(e, ["FONTSIZE"]).FONTSIZE
                      });
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.translations,
                        o = this.state,
                        r = o.expanded,
                        i = o.currentFontSize,
                        c = e.component || kt,
                        a = i && Number(i.substring(9));
                      return N.a.createElement(c, {
                        config: e,
                        translations: n,
                        currentState: {
                          fontSize: a
                        },
                        onChange: this.toggleFontSize,
                        expanded: r,
                        onExpandEvent: this.onExpandEvent,
                        doExpand: this.doExpand,
                        doCollapse: this.doCollapse
                      });
                    }
                  }]) && xt(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                zt.propTypes = {
                  onChange: y.a.func.isRequired,
                  editorState: y.a.object,
                  modalHandler: y.a.object,
                  config: y.a.object,
                  translations: y.a.object
                };
                n(17);
                function _t(t) {
                  return (_t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function Pt(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function Rt(t, e) {
                  return (Rt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Ut(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Bt(o);
                    if (r) {
                      var n = Bt(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === _t(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Bt(t) {
                  return (Bt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var Ft = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && Rt(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    r = Ut(i);
                  function i() {
                    var t;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i);
                    for (var e = arguments.length, n = new Array(e), o = 0; o < e; o++) n[o] = arguments[o];
                    return (t = r.call.apply(r, [this].concat(n))).state = {
                      defaultFontFamily: void 0
                    }, t;
                  }
                  return t = i, (e = [{
                    key: "componentDidMount",
                    value: function () {
                      var t = document.getElementsByClassName("DraftEditor-root");
                      if (t && 0 < t.length) {
                        var e = window.getComputedStyle(t[0]).getPropertyValue("font-family");
                        this.setState({
                          defaultFontFamily: e
                        });
                      }
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var e = this.state.defaultFontFamily,
                        t = this.props,
                        n = t.config,
                        o = n.className,
                        r = n.dropdownClassName,
                        i = n.options,
                        c = n.title,
                        a = t.translations,
                        l = t.onChange,
                        s = t.expanded,
                        u = t.doCollapse,
                        p = t.onExpandEvent,
                        d = t.doExpand,
                        f = this.props.currentState.fontFamily;
                      return f = f || i && e && i.some(function (t) {
                        return t.toLowerCase() === e.toLowerCase();
                      }) && e, N.a.createElement("div", {
                        className: "rdw-fontfamily-wrapper",
                        "aria-label": "rdw-font-family-control"
                      }, N.a.createElement(H, {
                        className: w()("rdw-fontfamily-dropdown", o),
                        optionWrapperClassName: w()("rdw-fontfamily-optionwrapper", r),
                        onChange: l,
                        expanded: s,
                        doExpand: d,
                        doCollapse: u,
                        onExpandEvent: p,
                        title: c || a["components.controls.fontfamily.fontfamily"]
                      }, N.a.createElement("span", {
                        className: "rdw-fontfamily-placeholder"
                      }, f || a["components.controls.fontfamily.fontfamily"]), i.map(function (t, e) {
                        return N.a.createElement(K, {
                          active: f === t,
                          value: t,
                          key: e
                        }, t);
                      })));
                    }
                  }]) && Pt(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                Ft.propTypes = {
                  expanded: y.a.bool,
                  onExpandEvent: y.a.func,
                  doExpand: y.a.func,
                  doCollapse: y.a.func,
                  onChange: y.a.func,
                  config: y.a.object,
                  currentState: y.a.object,
                  translations: y.a.object
                };
                var Yt = Ft;
                function Qt(t) {
                  return (Qt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function Ht(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function Zt(t, e) {
                  return (Zt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Wt(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Gt(o);
                    if (r) {
                      var n = Gt(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === Qt(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Gt(t) {
                  return (Gt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var Jt = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && Zt(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = Wt(r);
                  function r(t) {
                    var i;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r), (i = o.call(this, t)).onExpandEvent = function () {
                      i.signalExpanded = !i.state.expanded;
                    }, i.expandCollapse = function () {
                      i.setState({
                        expanded: i.signalExpanded
                      }), i.signalExpanded = false;
                    }, i.doExpand = function () {
                      i.setState({
                        expanded: true
                      });
                    }, i.doCollapse = function () {
                      i.setState({
                        expanded: false
                      });
                    }, i.toggleFontFamily = function (t) {
                      var e = i.props,
                        n = e.editorState,
                        o = e.onChange,
                        r = Object(S.toggleCustomInlineStyle)(n, "fontFamily", t);
                      r && o(r);
                    };
                    var e = t.editorState,
                      n = t.modalHandler;
                    return i.state = {
                      expanded: void 0,
                      currentFontFamily: e ? Object(S.getSelectionCustomInlineStyle)(e, ["FONTFAMILY"]).FONTFAMILY : void 0
                    }, n.registerCallBack(i.expandCollapse), i;
                  }
                  return t = r, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      var e = this.props.editorState;
                      e && e !== t.editorState && this.setState({
                        currentFontFamily: Object(S.getSelectionCustomInlineStyle)(e, ["FONTFAMILY"]).FONTFAMILY
                      });
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.translations,
                        o = this.state,
                        r = o.expanded,
                        i = o.currentFontFamily,
                        c = e.component || Yt,
                        a = i && i.substring(11);
                      return N.a.createElement(c, {
                        translations: n,
                        config: e,
                        currentState: {
                          fontFamily: a
                        },
                        onChange: this.toggleFontFamily,
                        expanded: r,
                        onExpandEvent: this.onExpandEvent,
                        doExpand: this.doExpand,
                        doCollapse: this.doCollapse
                      });
                    }
                  }]) && Ht(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                Jt.propTypes = {
                  onChange: y.a.func.isRequired,
                  editorState: y.a.object,
                  modalHandler: y.a.object,
                  config: y.a.object,
                  translations: y.a.object
                };
                n(18);
                function Vt(t) {
                  return (Vt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function qt(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function Kt(t, e) {
                  return (Kt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Xt(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = $t(o);
                    if (r) {
                      var n = $t(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === Vt(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function $t(t) {
                  return ($t = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var te = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && Kt(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    r = Xt(i);
                  function i() {
                    var e;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i);
                    for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++) n[o] = arguments[o];
                    return (e = r.call.apply(r, [this].concat(n))).options = ["unordered", "ordered", "indent", "outdent"], e.toggleBlockType = function (t) {
                      (0, e.props.onChange)(t);
                    }, e.indent = function () {
                      (0, e.props.onChange)("indent");
                    }, e.outdent = function () {
                      (0, e.props.onChange)("outdent");
                    }, e;
                  }
                  return t = i, (e = [{
                    key: "renderInFlatList",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.currentState.listType,
                        o = t.translations,
                        r = t.indentDisabled,
                        i = t.outdentDisabled,
                        c = e.options,
                        a = e.unordered,
                        l = e.ordered,
                        s = e.indent,
                        u = e.outdent,
                        p = e.className;
                      return N.a.createElement("div", {
                        className: w()("rdw-list-wrapper", p),
                        "aria-label": "rdw-list-control"
                      }, 0 <= c.indexOf("unordered") && N.a.createElement(R, {
                        value: "unordered",
                        onClick: this.toggleBlockType,
                        className: w()(a.className),
                        active: "unordered" === n,
                        title: a.title || o["components.controls.list.unordered"]
                      }, N.a.createElement("img", {
                        src: a.icon,
                        alt: ""
                      })), 0 <= c.indexOf("ordered") && N.a.createElement(R, {
                        value: "ordered",
                        onClick: this.toggleBlockType,
                        className: w()(l.className),
                        active: "ordered" === n,
                        title: l.title || o["components.controls.list.ordered"]
                      }, N.a.createElement("img", {
                        src: l.icon,
                        alt: ""
                      })), 0 <= c.indexOf("indent") && N.a.createElement(R, {
                        onClick: this.indent,
                        disabled: r,
                        className: w()(s.className),
                        title: s.title || o["components.controls.list.indent"]
                      }, N.a.createElement("img", {
                        src: s.icon,
                        alt: ""
                      })), 0 <= c.indexOf("outdent") && N.a.createElement(R, {
                        onClick: this.outdent,
                        disabled: i,
                        className: w()(u.className),
                        title: u.title || o["components.controls.list.outdent"]
                      }, N.a.createElement("img", {
                        src: u.icon,
                        alt: ""
                      })));
                    }
                  }, {
                    key: "renderInDropDown",
                    value: function () {
                      var n = this,
                        t = this.props,
                        o = t.config,
                        e = t.expanded,
                        r = t.doCollapse,
                        i = t.doExpand,
                        c = t.onExpandEvent,
                        a = t.onChange,
                        l = t.currentState.listType,
                        s = t.translations,
                        u = o.options,
                        p = o.className,
                        d = o.dropdownClassName,
                        f = o.title;
                      return N.a.createElement(H, {
                        className: w()("rdw-list-dropdown", p),
                        optionWrapperClassName: w()(d),
                        onChange: a,
                        expanded: e,
                        doExpand: i,
                        doCollapse: r,
                        onExpandEvent: c,
                        "aria-label": "rdw-list-control",
                        title: f || s["components.controls.list.list"]
                      }, N.a.createElement("img", {
                        src: v(o),
                        alt: ""
                      }), this.options.filter(function (t) {
                        return 0 <= u.indexOf(t);
                      }).map(function (t, e) {
                        return N.a.createElement(K, {
                          key: e,
                          value: t,
                          disabled: n.props["".concat(t, "Disabled")],
                          className: w()("rdw-list-dropdownOption", o[t].className),
                          active: l === t,
                          title: o[t].title || s["components.controls.list.".concat(t)]
                        }, N.a.createElement("img", {
                          src: o[t].icon,
                          alt: ""
                        }));
                      }));
                    }
                  }, {
                    key: "render",
                    value: function () {
                      return this.props.config.inDropdown ? this.renderInDropDown() : this.renderInFlatList();
                    }
                  }]) && qt(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                function ee(t) {
                  return (ee = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function ne(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function oe(t, e) {
                  return (oe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function re(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = ie(o);
                    if (r) {
                      var n = ie(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === ee(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function ie(t) {
                  return (ie = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                te.propTypes = {
                  expanded: y.a.bool,
                  doExpand: y.a.func,
                  doCollapse: y.a.func,
                  onExpandEvent: y.a.func,
                  config: y.a.object,
                  onChange: y.a.func,
                  currentState: y.a.object,
                  translations: y.a.object,
                  indentDisabled: y.a.bool,
                  outdentDisabled: y.a.bool
                };
                var ce = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && oe(t, e);
                  }(c, f["Component"]);
                  var t,
                    e,
                    r = re(c);
                  function c(t) {
                    var i;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, c), (i = r.call(this, t)).onExpandEvent = function () {
                      i.signalExpanded = !i.state.expanded;
                    }, i.onChange = function (t) {
                      "unordered" === t ? i.toggleBlockType("unordered-list-item") : "ordered" === t ? i.toggleBlockType("ordered-list-item") : "indent" === t ? i.adjustDepth(1) : i.adjustDepth(-1);
                    }, i.expandCollapse = function () {
                      i.setState({
                        expanded: i.signalExpanded
                      }), i.signalExpanded = false;
                    }, i.doExpand = function () {
                      i.setState({
                        expanded: true
                      });
                    }, i.doCollapse = function () {
                      i.setState({
                        expanded: false
                      });
                    }, i.toggleBlockType = function (t) {
                      var e = i.props,
                        n = e.onChange,
                        o = e.editorState,
                        r = E.RichUtils.toggleBlockType(o, t);
                      r && n(r);
                    }, i.adjustDepth = function (t) {
                      var e = i.props,
                        n = e.onChange,
                        o = e.editorState,
                        r = Object(S.changeDepth)(o, t, 4);
                      r && n(r);
                    }, i.isIndentDisabled = function () {
                      var t = i.props.editorState,
                        e = i.state.currentBlock,
                        n = Object(S.getBlockBeforeSelectedBlock)(t);
                      return !n || !Object(S.isListBlock)(e) || n.get("type") !== e.get("type") || n.get("depth") < e.get("depth");
                    }, i.isOutdentDisabled = function () {
                      var t = i.state.currentBlock;
                      return !t || !Object(S.isListBlock)(t) || t.get("depth") <= 0;
                    };
                    var e = i.props,
                      n = e.editorState,
                      o = e.modalHandler;
                    return i.state = {
                      expanded: false,
                      currentBlock: n ? Object(S.getSelectedBlock)(n) : void 0
                    }, o.registerCallBack(i.expandCollapse), i;
                  }
                  return t = c, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      var e = this.props.editorState;
                      e && e !== t.editorState && this.setState({
                        currentBlock: Object(S.getSelectedBlock)(e)
                      });
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t,
                        e = this.props,
                        n = e.config,
                        o = e.translations,
                        r = this.state,
                        i = r.expanded,
                        c = r.currentBlock,
                        a = n.component || te;
                      "unordered-list-item" === c.get("type") ? t = "unordered" : "ordered-list-item" === c.get("type") && (t = "ordered");
                      var l = this.isIndentDisabled(),
                        s = this.isOutdentDisabled();
                      return N.a.createElement(a, {
                        config: n,
                        translations: o,
                        currentState: {
                          listType: t
                        },
                        expanded: i,
                        onExpandEvent: this.onExpandEvent,
                        doExpand: this.doExpand,
                        doCollapse: this.doCollapse,
                        onChange: this.onChange,
                        indentDisabled: l,
                        outdentDisabled: s
                      });
                    }
                  }]) && ne(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), c;
                }();
                ce.propTypes = {
                  onChange: y.a.func.isRequired,
                  editorState: y.a.object.isRequired,
                  modalHandler: y.a.object,
                  config: y.a.object,
                  translations: y.a.object
                };
                n(19);
                function ae(t) {
                  return (ae = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function le(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function se(t, e) {
                  return (se = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function ue(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = pe(o);
                    if (r) {
                      var n = pe(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === ae(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function pe(t) {
                  return (pe = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var de = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && se(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = ue(r);
                  function r() {
                    return function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r), o.apply(this, arguments);
                  }
                  return t = r, (e = [{
                    key: "renderInFlatList",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = e.options,
                        o = e.left,
                        r = e.center,
                        i = e.right,
                        c = e.justify,
                        a = e.className,
                        l = t.onChange,
                        s = t.currentState.textAlignment,
                        u = t.translations;
                      return N.a.createElement("div", {
                        className: w()("rdw-text-align-wrapper", a),
                        "aria-label": "rdw-textalign-control"
                      }, 0 <= n.indexOf("left") && N.a.createElement(R, {
                        value: "left",
                        className: w()(o.className),
                        active: "left" === s,
                        onClick: l,
                        title: o.title || u["components.controls.textalign.left"]
                      }, N.a.createElement("img", {
                        src: o.icon,
                        alt: ""
                      })), 0 <= n.indexOf("center") && N.a.createElement(R, {
                        value: "center",
                        className: w()(r.className),
                        active: "center" === s,
                        onClick: l,
                        title: r.title || u["components.controls.textalign.center"]
                      }, N.a.createElement("img", {
                        src: r.icon,
                        alt: ""
                      })), 0 <= n.indexOf("right") && N.a.createElement(R, {
                        value: "right",
                        className: w()(i.className),
                        active: "right" === s,
                        onClick: l,
                        title: i.title || u["components.controls.textalign.right"]
                      }, N.a.createElement("img", {
                        src: i.icon,
                        alt: ""
                      })), 0 <= n.indexOf("justify") && N.a.createElement(R, {
                        value: "justify",
                        className: w()(c.className),
                        active: "justify" === s,
                        onClick: l,
                        title: c.title || u["components.controls.textalign.justify"]
                      }, N.a.createElement("img", {
                        src: c.icon,
                        alt: ""
                      })));
                    }
                  }, {
                    key: "renderInDropDown",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.expanded,
                        o = t.doExpand,
                        r = t.onExpandEvent,
                        i = t.doCollapse,
                        c = t.currentState.textAlignment,
                        a = t.onChange,
                        l = t.translations,
                        s = e.options,
                        u = e.left,
                        p = e.center,
                        d = e.right,
                        f = e.justify,
                        y = e.className,
                        m = e.dropdownClassName,
                        g = e.title;
                      return N.a.createElement(H, {
                        className: w()("rdw-text-align-dropdown", y),
                        optionWrapperClassName: w()(m),
                        onChange: a,
                        expanded: n,
                        doExpand: o,
                        doCollapse: i,
                        onExpandEvent: r,
                        "aria-label": "rdw-textalign-control",
                        title: g || l["components.controls.textalign.textalign"]
                      }, N.a.createElement("img", {
                        src: c && e[c] && e[c].icon || v(e),
                        alt: ""
                      }), 0 <= s.indexOf("left") && N.a.createElement(K, {
                        value: "left",
                        active: "left" === c,
                        className: w()("rdw-text-align-dropdownOption", u.className),
                        title: u.title || l["components.controls.textalign.left"]
                      }, N.a.createElement("img", {
                        src: u.icon,
                        alt: ""
                      })), 0 <= s.indexOf("center") && N.a.createElement(K, {
                        value: "center",
                        active: "center" === c,
                        className: w()("rdw-text-align-dropdownOption", p.className),
                        title: p.title || l["components.controls.textalign.center"]
                      }, N.a.createElement("img", {
                        src: p.icon,
                        alt: ""
                      })), 0 <= s.indexOf("right") && N.a.createElement(K, {
                        value: "right",
                        active: "right" === c,
                        className: w()("rdw-text-align-dropdownOption", d.className),
                        title: d.title || l["components.controls.textalign.right"]
                      }, N.a.createElement("img", {
                        src: d.icon,
                        alt: ""
                      })), 0 <= s.indexOf("justify") && N.a.createElement(K, {
                        value: "justify",
                        active: "justify" === c,
                        className: w()("rdw-text-align-dropdownOption", f.className),
                        title: f.title || l["components.controls.textalign.justify"]
                      }, N.a.createElement("img", {
                        src: f.icon,
                        alt: ""
                      })));
                    }
                  }, {
                    key: "render",
                    value: function () {
                      return this.props.config.inDropdown ? this.renderInDropDown() : this.renderInFlatList();
                    }
                  }]) && le(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                function fe(t) {
                  return (fe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function ye(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function me(t, e) {
                  return (me = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function ge(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = be(o);
                    if (r) {
                      var n = be(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === fe(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function be(t) {
                  return (be = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                de.propTypes = {
                  expanded: y.a.bool,
                  doExpand: y.a.func,
                  doCollapse: y.a.func,
                  onExpandEvent: y.a.func,
                  config: y.a.object,
                  onChange: y.a.func,
                  currentState: y.a.object,
                  translations: y.a.object
                };
                var he = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && me(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    o = ge(i);
                  function i(t) {
                    var r;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i), (r = o.call(this, t)).onExpandEvent = function () {
                      r.signalExpanded = !r.state.expanded;
                    }, r.expandCollapse = function () {
                      r.setState({
                        expanded: r.signalExpanded
                      }), r.signalExpanded = false;
                    }, r.doExpand = function () {
                      r.setState({
                        expanded: true
                      });
                    }, r.doCollapse = function () {
                      r.setState({
                        expanded: false
                      });
                    }, r.addBlockAlignmentData = function (t) {
                      var e = r.props,
                        n = e.editorState,
                        o = e.onChange;
                      o(r.state.currentTextAlignment !== t ? Object(S.setBlockData)(n, {
                        "text-align": t
                      }) : Object(S.setBlockData)(n, {
                        "text-align": void 0
                      }));
                    };
                    var e = r.props.modalHandler;
                    return r.state = {
                      currentTextAlignment: void 0
                    }, e.registerCallBack(r.expandCollapse), r;
                  }
                  return t = i, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      var e = this.props.editorState;
                      e !== t.editorState && this.setState({
                        currentTextAlignment: Object(S.getSelectedBlocksMetadata)(e).get("text-align")
                      });
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.translations,
                        o = this.state,
                        r = o.expanded,
                        i = o.currentTextAlignment,
                        c = e.component || de;
                      return N.a.createElement(c, {
                        config: e,
                        translations: n,
                        expanded: r,
                        onExpandEvent: this.onExpandEvent,
                        doExpand: this.doExpand,
                        doCollapse: this.doCollapse,
                        currentState: {
                          textAlignment: i
                        },
                        onChange: this.addBlockAlignmentData
                      });
                    }
                  }]) && ye(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                he.propTypes = {
                  editorState: y.a.object.isRequired,
                  onChange: y.a.func.isRequired,
                  modalHandler: y.a.object,
                  config: y.a.object,
                  translations: y.a.object
                };
                n(20);
                function Me(t) {
                  return (Me = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function je(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function ve(t, e) {
                  return (ve = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Ne(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Ee(o);
                    if (r) {
                      var n = Ee(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === Me(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Ee(t) {
                  return (Ee = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var Se = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && ve(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = Ne(r);
                  function r() {
                    var u;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r);
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return (u = o.call.apply(o, [this].concat(e))).state = {
                      currentStyle: "color"
                    }, u.onChange = function (t) {
                      (0, u.props.onChange)(u.state.currentStyle, t);
                    }, u.setCurrentStyleColor = function () {
                      u.setState({
                        currentStyle: "color"
                      });
                    }, u.setCurrentStyleBgcolor = function () {
                      u.setState({
                        currentStyle: "bgcolor"
                      });
                    }, u.renderModal = function () {
                      var t = u.props,
                        e = t.config,
                        n = e.popupClassName,
                        o = e.colors,
                        r = t.currentState,
                        i = r.color,
                        c = r.bgColor,
                        a = t.translations,
                        l = u.state.currentStyle,
                        s = "color" === l ? i : c;
                      return N.a.createElement("div", {
                        className: w()("rdw-colorpicker-modal", n),
                        onClick: j
                      }, N.a.createElement("span", {
                        className: "rdw-colorpicker-modal-header"
                      }, N.a.createElement("span", {
                        className: w()("rdw-colorpicker-modal-style-label", {
                          "rdw-colorpicker-modal-style-label-active": "color" === l
                        }),
                        onClick: u.setCurrentStyleColor
                      }, a["components.controls.colorpicker.text"]), N.a.createElement("span", {
                        className: w()("rdw-colorpicker-modal-style-label", {
                          "rdw-colorpicker-modal-style-label-active": "bgcolor" === l
                        }),
                        onClick: u.setCurrentStyleBgcolor
                      }, a["components.controls.colorpicker.background"])), N.a.createElement("span", {
                        className: "rdw-colorpicker-modal-options"
                      }, o.map(function (t, e) {
                        return N.a.createElement(R, {
                          value: t,
                          key: e,
                          className: "rdw-colorpicker-option",
                          activeClassName: "rdw-colorpicker-option-active",
                          active: s === t,
                          onClick: u.onChange
                        }, N.a.createElement("span", {
                          style: {
                            backgroundColor: t
                          },
                          className: "rdw-colorpicker-cube"
                        }));
                      })));
                    }, u;
                  }
                  return t = r, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      this.props.expanded && !t.expanded && this.setState({
                        currentStyle: "color"
                      });
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = e.icon,
                        o = e.className,
                        r = e.title,
                        i = t.expanded,
                        c = t.onExpandEvent,
                        a = t.translations;
                      return N.a.createElement("div", {
                        className: "rdw-colorpicker-wrapper",
                        "aria-haspopup": "true",
                        "aria-expanded": i,
                        "aria-label": "rdw-color-picker",
                        title: r || a["components.controls.colorpicker.colorpicker"]
                      }, N.a.createElement(R, {
                        onClick: c,
                        className: w()(o)
                      }, N.a.createElement("img", {
                        src: n,
                        alt: ""
                      })), i ? this.renderModal() : void 0);
                    }
                  }]) && je(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                Se.propTypes = {
                  expanded: y.a.bool,
                  onExpandEvent: y.a.func,
                  onChange: y.a.func,
                  config: y.a.object,
                  currentState: y.a.object,
                  translations: y.a.object
                };
                var we = Se;
                function Ce(t) {
                  return (Ce = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function Le(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function De(t, e) {
                  return (De = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function ke(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Oe(o);
                    if (r) {
                      var n = Oe(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === Ce(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Oe(t) {
                  return (Oe = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var xe = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && De(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    r = ke(i);
                  function i(t) {
                    var c;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i), (c = r.call(this, t)).state = {
                      expanded: false,
                      currentColor: void 0,
                      currentBgColor: void 0
                    }, c.onExpandEvent = function () {
                      c.signalExpanded = !c.state.expanded;
                    }, c.expandCollapse = function () {
                      c.setState({
                        expanded: c.signalExpanded
                      }), c.signalExpanded = false;
                    }, c.doExpand = function () {
                      c.setState({
                        expanded: true
                      });
                    }, c.doCollapse = function () {
                      c.setState({
                        expanded: false
                      });
                    }, c.toggleColor = function (t, e) {
                      var n = c.props,
                        o = n.editorState,
                        r = n.onChange,
                        i = Object(S.toggleCustomInlineStyle)(o, t, e);
                      i && r(i), c.doCollapse();
                    };
                    var e = t.editorState,
                      n = t.modalHandler,
                      o = {
                        expanded: false,
                        currentColor: void 0,
                        currentBgColor: void 0
                      };
                    return e && (o.currentColor = Object(S.getSelectionCustomInlineStyle)(e, ["COLOR"]).COLOR, o.currentBgColor = Object(S.getSelectionCustomInlineStyle)(e, ["BGCOLOR"]).BGCOLOR), c.state = o, n.registerCallBack(c.expandCollapse), c;
                  }
                  return t = i, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      var e = this.props.editorState;
                      e && e !== t.editorState && this.setState({
                        currentColor: Object(S.getSelectionCustomInlineStyle)(e, ["COLOR"]).COLOR,
                        currentBgColor: Object(S.getSelectionCustomInlineStyle)(e, ["BGCOLOR"]).BGCOLOR
                      });
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.translations,
                        o = this.state,
                        r = o.currentColor,
                        i = o.currentBgColor,
                        c = o.expanded,
                        a = e.component || we,
                        l = r && r.substring(6),
                        s = i && i.substring(8);
                      return N.a.createElement(a, {
                        config: e,
                        translations: n,
                        onChange: this.toggleColor,
                        expanded: c,
                        onExpandEvent: this.onExpandEvent,
                        doExpand: this.doExpand,
                        doCollapse: this.doCollapse,
                        currentState: {
                          color: l,
                          bgColor: s
                        }
                      });
                    }
                  }]) && Le(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                xe.propTypes = {
                  onChange: y.a.func.isRequired,
                  editorState: y.a.object.isRequired,
                  modalHandler: y.a.object,
                  config: y.a.object,
                  translations: y.a.object
                };
                var Ie = xe,
                  Te = n(7),
                  Ae = n.n(Te);
                n(26);
                function ze(t) {
                  return (ze = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function _e(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function Pe(t, e) {
                  return (Pe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Re(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Ue(o);
                    if (r) {
                      var n = Ue(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === ze(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Ue(t) {
                  return (Ue = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var Be = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && Pe(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = Re(r);
                  function r() {
                    var c;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r);
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return (c = o.call.apply(o, [this].concat(e))).state = {
                      showModal: false,
                      linkTarget: "",
                      linkTitle: "",
                      linkTargetOption: c.props.config.defaultTargetOption
                    }, c.removeLink = function () {
                      (0, c.props.onChange)("unlink");
                    }, c.addLink = function () {
                      var t = c.props.onChange,
                        e = c.state;
                      t("link", e.linkTitle, e.linkTarget, e.linkTargetOption);
                    }, c.updateValue = function (t) {
                      var e, n, o;
                      c.setState((e = {}, n = "".concat(t.target.name), o = t.target.value, n in e ? Object.defineProperty(e, n, {
                        value: o,
                        enumerable: true,
                        configurable: true,
                        writable: true
                      }) : e[n] = o, e));
                    }, c.updateTargetOption = function (t) {
                      c.setState({
                        linkTargetOption: t.target.checked ? "_blank" : "_self"
                      });
                    }, c.hideModal = function () {
                      c.setState({
                        showModal: false
                      });
                    }, c.signalExpandShowModal = function () {
                      var t = c.props,
                        e = t.onExpandEvent,
                        n = t.currentState,
                        o = n.link,
                        r = n.selectionText,
                        i = c.state.linkTargetOption;
                      e(), c.setState({
                        showModal: true,
                        linkTarget: o && o.target || "",
                        linkTargetOption: o && o.targetOption || i,
                        linkTitle: o && o.title || r
                      });
                    }, c.forceExpandAndShowModal = function () {
                      var t = c.props,
                        e = t.doExpand,
                        n = t.currentState,
                        o = n.link,
                        r = n.selectionText,
                        i = c.state.linkTargetOption;
                      e(), c.setState({
                        showModal: true,
                        linkTarget: o && o.target,
                        linkTargetOption: o && o.targetOption || i,
                        linkTitle: o && o.title || r
                      });
                    }, c;
                  }
                  return t = r, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      t.expanded && !this.props.expanded && this.setState({
                        showModal: false,
                        linkTarget: "",
                        linkTitle: "",
                        linkTargetOption: this.props.config.defaultTargetOption
                      });
                    }
                  }, {
                    key: "renderAddLinkModal",
                    value: function () {
                      var t = this.props,
                        e = t.config.popupClassName,
                        n = t.doCollapse,
                        o = t.translations,
                        r = this.state,
                        i = r.linkTitle,
                        c = r.linkTarget,
                        a = r.linkTargetOption;
                      return N.a.createElement("div", {
                        className: w()("rdw-link-modal", e),
                        onClick: j
                      }, N.a.createElement("label", {
                        className: "rdw-link-modal-label",
                        htmlFor: "linkTitle"
                      }, o["components.controls.link.linkTitle"]), N.a.createElement("input", {
                        id: "linkTitle",
                        className: "rdw-link-modal-input",
                        onChange: this.updateValue,
                        onBlur: this.updateValue,
                        name: "linkTitle",
                        value: i
                      }), N.a.createElement("label", {
                        className: "rdw-link-modal-label",
                        htmlFor: "linkTarget"
                      }, o["components.controls.link.linkTarget"]), N.a.createElement("input", {
                        id: "linkTarget",
                        className: "rdw-link-modal-input",
                        onChange: this.updateValue,
                        onBlur: this.updateValue,
                        name: "linkTarget",
                        value: c
                      }), N.a.createElement("label", {
                        className: "rdw-link-modal-target-option",
                        htmlFor: "openLinkInNewWindow"
                      }, N.a.createElement("input", {
                        id: "openLinkInNewWindow",
                        type: "checkbox",
                        defaultChecked: "_blank" === a,
                        value: "_blank",
                        onChange: this.updateTargetOption
                      }), N.a.createElement("span", null, o["components.controls.link.linkTargetOption"])), N.a.createElement("span", {
                        className: "rdw-link-modal-buttonsection"
                      }, N.a.createElement("button", {
                        className: "rdw-link-modal-btn",
                        onClick: this.addLink,
                        disabled: !c || !i
                      }, o["generic.add"]), N.a.createElement("button", {
                        className: "rdw-link-modal-btn",
                        onClick: n
                      }, o["generic.cancel"])));
                    }
                  }, {
                    key: "renderInFlatList",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = e.options,
                        o = e.link,
                        r = e.unlink,
                        i = e.className,
                        c = t.currentState,
                        a = t.expanded,
                        l = t.translations,
                        s = this.state.showModal;
                      return N.a.createElement("div", {
                        className: w()("rdw-link-wrapper", i),
                        "aria-label": "rdw-link-control"
                      }, 0 <= n.indexOf("link") && N.a.createElement(R, {
                        value: "unordered-list-item",
                        className: w()(o.className),
                        onClick: this.signalExpandShowModal,
                        "aria-haspopup": "true",
                        "aria-expanded": s,
                        title: o.title || l["components.controls.link.link"]
                      }, N.a.createElement("img", {
                        src: o.icon,
                        alt: ""
                      })), 0 <= n.indexOf("unlink") && N.a.createElement(R, {
                        disabled: !c.link,
                        value: "ordered-list-item",
                        className: w()(r.className),
                        onClick: this.removeLink,
                        title: r.title || l["components.controls.link.unlink"]
                      }, N.a.createElement("img", {
                        src: r.icon,
                        alt: ""
                      })), a && s ? this.renderAddLinkModal() : void 0);
                    }
                  }, {
                    key: "renderInDropDown",
                    value: function () {
                      var t = this.props,
                        e = t.expanded,
                        n = t.onExpandEvent,
                        o = t.doCollapse,
                        r = t.doExpand,
                        i = t.onChange,
                        c = t.config,
                        a = t.currentState,
                        l = t.translations,
                        s = c.options,
                        u = c.link,
                        p = c.unlink,
                        d = c.className,
                        f = c.dropdownClassName,
                        y = c.title,
                        m = this.state.showModal;
                      return N.a.createElement("div", {
                        className: "rdw-link-wrapper",
                        "aria-haspopup": "true",
                        "aria-label": "rdw-link-control",
                        "aria-expanded": e,
                        title: y
                      }, N.a.createElement(H, {
                        className: w()("rdw-link-dropdown", d),
                        optionWrapperClassName: w()(f),
                        onChange: i,
                        expanded: e && !m,
                        doExpand: r,
                        doCollapse: o,
                        onExpandEvent: n
                      }, N.a.createElement("img", {
                        src: v(c),
                        alt: ""
                      }), 0 <= s.indexOf("link") && N.a.createElement(K, {
                        onClick: this.forceExpandAndShowModal,
                        className: w()("rdw-link-dropdownoption", u.className),
                        title: u.title || l["components.controls.link.link"]
                      }, N.a.createElement("img", {
                        src: u.icon,
                        alt: ""
                      })), 0 <= s.indexOf("unlink") && N.a.createElement(K, {
                        onClick: this.removeLink,
                        disabled: !a.link,
                        className: w()("rdw-link-dropdownoption", p.className),
                        title: p.title || l["components.controls.link.unlink"]
                      }, N.a.createElement("img", {
                        src: p.icon,
                        alt: ""
                      }))), e && m ? this.renderAddLinkModal() : void 0);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      return this.props.config.inDropdown ? this.renderInDropDown() : this.renderInFlatList();
                    }
                  }]) && _e(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                Be.propTypes = {
                  expanded: y.a.bool,
                  doExpand: y.a.func,
                  doCollapse: y.a.func,
                  onExpandEvent: y.a.func,
                  config: y.a.object,
                  onChange: y.a.func,
                  currentState: y.a.object,
                  translations: y.a.object
                };
                var Fe = Be;
                function Ye(t) {
                  return (Ye = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function Qe(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function He(t, e) {
                  return (He = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Ze(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = We(o);
                    if (r) {
                      var n = We(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === Ye(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function We(t) {
                  return (We = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                function Ge(e, t) {
                  var n = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    t && (o = o.filter(function (t) {
                      return Object.getOwnPropertyDescriptor(e, t).enumerable;
                    })), n.push.apply(n, o);
                  }
                  return n;
                }
                function Je(e) {
                  for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Ge(Object(n), true).forEach(function (t) {
                      Ve(e, t, n[t]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ge(Object(n)).forEach(function (t) {
                      Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                  }
                  return e;
                }
                function Ve(t, e, n) {
                  return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  }) : t[e] = n, t;
                }
                function qe(t) {
                  var e = Ke.match(t.target);
                  return Je(Je({}, t), {}, {
                    target: e && e[0] && e[0].url || t.target
                  });
                }
                var Ke = Ae()(),
                  Xe = function () {
                    !function (t, e) {
                      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                      t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                          value: t,
                          writable: true,
                          configurable: true
                        }
                      }), Object.defineProperty(t, "prototype", {
                        writable: false
                      }), e && He(t, e);
                    }(i, f["Component"]);
                    var t,
                      e,
                      r = Ze(i);
                    function i(t) {
                      var d;
                      !function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                      }(this, i), (d = r.call(this, t)).onExpandEvent = function () {
                        d.signalExpanded = !d.state.expanded;
                      }, d.onChange = function (t, e, n, o) {
                        var r = d.props.config.linkCallback;
                        if ("link" === t) {
                          var i = (r || qe)({
                            title: e,
                            target: n,
                            targetOption: o
                          });
                          d.addLink(i.title, i.target, i.targetOption);
                        } else d.removeLink();
                      }, d.getCurrentValues = function () {
                        var t = d.props.editorState,
                          e = d.state.currentEntity,
                          n = t.getCurrentContent(),
                          o = {};
                        if (e && "LINK" === n.getEntity(e).get("type")) {
                          o.link = {};
                          var r = e && Object(S.getEntityRange)(t, e);
                          o.link.target = e && n.getEntity(e).get("data").url, o.link.targetOption = e && n.getEntity(e).get("data").targetOption, o.link.title = r && r.text;
                        }
                        return o.selectionText = Object(S.getSelectionText)(t), o;
                      }, d.doExpand = function () {
                        d.setState({
                          expanded: true
                        });
                      }, d.expandCollapse = function () {
                        d.setState({
                          expanded: d.signalExpanded
                        }), d.signalExpanded = false;
                      }, d.doCollapse = function () {
                        d.setState({
                          expanded: false
                        });
                      }, d.removeLink = function () {
                        var t = d.props,
                          e = t.editorState,
                          n = t.onChange,
                          o = d.state.currentEntity,
                          r = e.getSelection();
                        if (o) {
                          var i = Object(S.getEntityRange)(e, o);
                          r = r.getIsBackward() ? r.merge({
                            anchorOffset: i.end,
                            focusOffset: i.start
                          }) : r.merge({
                            anchorOffset: i.start,
                            focusOffset: i.end
                          }), n(E.RichUtils.toggleLink(e, r, null));
                        }
                      }, d.addLink = function (t, e, n) {
                        var o = d.props,
                          r = o.editorState,
                          i = o.onChange,
                          c = d.state.currentEntity,
                          a = r.getSelection();
                        if (c) {
                          var l = Object(S.getEntityRange)(r, c);
                          a = a.getIsBackward() ? a.merge({
                            anchorOffset: l.end,
                            focusOffset: l.start
                          }) : a.merge({
                            anchorOffset: l.start,
                            focusOffset: l.end
                          });
                        }
                        var s = r.getCurrentContent().createEntity("LINK", "MUTABLE", {
                            url: e,
                            targetOption: n
                          }).getLastCreatedEntityKey(),
                          u = E.Modifier.replaceText(r.getCurrentContent(), a, "".concat(t), r.getCurrentInlineStyle(), s),
                          p = E.EditorState.push(r, u, "insert-characters");
                        a = p.getSelection().merge({
                          anchorOffset: a.get("anchorOffset") + t.length,
                          focusOffset: a.get("anchorOffset") + t.length
                        }), p = E.EditorState.acceptSelection(p, a), u = E.Modifier.insertText(p.getCurrentContent(), a, " ", p.getCurrentInlineStyle(), void 0), i(E.EditorState.push(p, u, "insert-characters")), d.doCollapse();
                      };
                      var e = d.props,
                        n = e.editorState,
                        o = e.modalHandler;
                      return d.state = {
                        expanded: false,
                        link: void 0,
                        selectionText: void 0,
                        currentEntity: n ? Object(S.getSelectionEntity)(n) : void 0
                      }, o.registerCallBack(d.expandCollapse), d;
                    }
                    return t = i, (e = [{
                      key: "componentDidUpdate",
                      value: function (t) {
                        var e = this.props.editorState;
                        e && e !== t.editorState && this.setState({
                          currentEntity: Object(S.getSelectionEntity)(e)
                        });
                      }
                    }, {
                      key: "componentWillUnmount",
                      value: function () {
                        this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                      }
                    }, {
                      key: "render",
                      value: function () {
                        var t = this.props,
                          e = t.config,
                          n = t.translations,
                          o = this.state.expanded,
                          r = this.getCurrentValues(),
                          i = r.link,
                          c = r.selectionText,
                          a = e.component || Fe;
                        return N.a.createElement(a, {
                          config: e,
                          translations: n,
                          expanded: o,
                          onExpandEvent: this.onExpandEvent,
                          doExpand: this.doExpand,
                          doCollapse: this.doCollapse,
                          currentState: {
                            link: i,
                            selectionText: c
                          },
                          onChange: this.onChange
                        });
                      }
                    }]) && Qe(t.prototype, e), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), i;
                  }();
                Xe.propTypes = {
                  editorState: y.a.object.isRequired,
                  onChange: y.a.func.isRequired,
                  modalHandler: y.a.object,
                  config: y.a.object,
                  translations: y.a.object
                };
                var $e = Xe;
                n(27);
                function tn(t) {
                  return (tn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function en(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function nn(t, e) {
                  return (nn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function on(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = rn(o);
                    if (r) {
                      var n = rn(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === tn(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function rn(t) {
                  return (rn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var cn = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && nn(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    o = on(i);
                  function i() {
                    var r;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i);
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return (r = o.call.apply(o, [this].concat(e))).state = {
                      embeddedLink: "",
                      height: r.props.config.defaultSize.height,
                      width: r.props.config.defaultSize.width
                    }, r.onChange = function () {
                      var t = r.props.onChange,
                        e = r.state;
                      t(e.embeddedLink, e.height, e.width);
                    }, r.updateValue = function (t) {
                      var e, n, o;
                      r.setState((e = {}, n = "".concat(t.target.name), o = t.target.value, n in e ? Object.defineProperty(e, n, {
                        value: o,
                        enumerable: true,
                        configurable: true,
                        writable: true
                      }) : e[n] = o, e));
                    }, r;
                  }
                  return t = i, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      var e = this.props,
                        n = e.expanded,
                        o = e.config;
                      if (!n && t.expanded) {
                        var r = o.defaultSize,
                          i = r.height,
                          c = r.width;
                        this.setState({
                          embeddedLink: "",
                          height: i,
                          width: c
                        });
                      }
                    }
                  }, {
                    key: "rendeEmbeddedLinkModal",
                    value: function () {
                      var t = this.state,
                        e = t.embeddedLink,
                        n = t.height,
                        o = t.width,
                        r = this.props,
                        i = r.config.popupClassName,
                        c = r.doCollapse,
                        a = r.translations;
                      return N.a.createElement("div", {
                        className: w()("rdw-embedded-modal", i),
                        onClick: j
                      }, N.a.createElement("div", {
                        className: "rdw-embedded-modal-header"
                      }, N.a.createElement("span", {
                        className: "rdw-embedded-modal-header-option"
                      }, a["components.controls.embedded.embeddedlink"], N.a.createElement("span", {
                        className: "rdw-embedded-modal-header-label"
                      }))), N.a.createElement("div", {
                        className: "rdw-embedded-modal-link-section"
                      }, N.a.createElement("span", {
                        className: "rdw-embedded-modal-link-input-wrapper"
                      }, N.a.createElement("input", {
                        className: "rdw-embedded-modal-link-input",
                        placeholder: a["components.controls.embedded.enterlink"],
                        onChange: this.updateValue,
                        onBlur: this.updateValue,
                        value: e,
                        name: "embeddedLink"
                      }), N.a.createElement("span", {
                        className: "rdw-image-mandatory-sign"
                      }, "*")), N.a.createElement("div", {
                        className: "rdw-embedded-modal-size"
                      }, N.a.createElement("span", null, N.a.createElement("input", {
                        onChange: this.updateValue,
                        onBlur: this.updateValue,
                        value: n,
                        name: "height",
                        className: "rdw-embedded-modal-size-input",
                        placeholder: "Height"
                      }), N.a.createElement("span", {
                        className: "rdw-image-mandatory-sign"
                      }, "*")), N.a.createElement("span", null, N.a.createElement("input", {
                        onChange: this.updateValue,
                        onBlur: this.updateValue,
                        value: o,
                        name: "width",
                        className: "rdw-embedded-modal-size-input",
                        placeholder: "Width"
                      }), N.a.createElement("span", {
                        className: "rdw-image-mandatory-sign"
                      }, "*")))), N.a.createElement("span", {
                        className: "rdw-embedded-modal-btn-section"
                      }, N.a.createElement("button", {
                        type: "button",
                        className: "rdw-embedded-modal-btn",
                        onClick: this.onChange,
                        disabled: !e || !n || !o
                      }, a["generic.add"]), N.a.createElement("button", {
                        type: "button",
                        className: "rdw-embedded-modal-btn",
                        onClick: c
                      }, a["generic.cancel"])));
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = e.icon,
                        o = e.className,
                        r = e.title,
                        i = t.expanded,
                        c = t.onExpandEvent,
                        a = t.translations;
                      return N.a.createElement("div", {
                        className: "rdw-embedded-wrapper",
                        "aria-haspopup": "true",
                        "aria-expanded": i,
                        "aria-label": "rdw-embedded-control"
                      }, N.a.createElement(R, {
                        className: w()(o),
                        value: "unordered-list-item",
                        onClick: c,
                        title: r || a["components.controls.embedded.embedded"]
                      }, N.a.createElement("img", {
                        src: n,
                        alt: ""
                      })), i ? this.rendeEmbeddedLinkModal() : void 0);
                    }
                  }]) && en(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                cn.propTypes = {
                  expanded: y.a.bool,
                  onExpandEvent: y.a.func,
                  onChange: y.a.func,
                  config: y.a.object,
                  translations: y.a.object,
                  doCollapse: y.a.func
                };
                var an = cn;
                function ln(t) {
                  return (ln = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function sn(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function un(t, e) {
                  return (un = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function pn(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = dn(o);
                    if (r) {
                      var n = dn(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === ln(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function dn(t) {
                  return (dn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var fn = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && un(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = pn(r);
                  function r() {
                    var s;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r);
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return (s = o.call.apply(o, [this].concat(e))).state = {
                      expanded: false
                    }, s.onExpandEvent = function () {
                      s.signalExpanded = !s.state.expanded;
                    }, s.expandCollapse = function () {
                      s.setState({
                        expanded: s.signalExpanded
                      }), s.signalExpanded = false;
                    }, s.doExpand = function () {
                      s.setState({
                        expanded: true
                      });
                    }, s.doCollapse = function () {
                      s.setState({
                        expanded: false
                      });
                    }, s.addEmbeddedLink = function (t, e, n) {
                      var o = s.props,
                        r = o.editorState,
                        i = o.onChange,
                        c = o.config.embedCallback,
                        a = c ? c(t) : t,
                        l = r.getCurrentContent().createEntity("EMBEDDED_LINK", "MUTABLE", {
                          src: a,
                          height: e,
                          width: n
                        }).getLastCreatedEntityKey();
                      i(E.AtomicBlockUtils.insertAtomicBlock(r, l, " ")), s.doCollapse();
                    }, s;
                  }
                  return t = r, (e = [{
                    key: "componentDidMount",
                    value: function () {
                      this.props.modalHandler.registerCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.translations,
                        o = this.state.expanded,
                        r = e.component || an;
                      return N.a.createElement(r, {
                        config: e,
                        translations: n,
                        onChange: this.addEmbeddedLink,
                        expanded: o,
                        onExpandEvent: this.onExpandEvent,
                        doExpand: this.doExpand,
                        doCollapse: this.doCollapse
                      });
                    }
                  }]) && sn(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                fn.propTypes = {
                  editorState: y.a.object.isRequired,
                  onChange: y.a.func.isRequired,
                  modalHandler: y.a.object,
                  config: y.a.object,
                  translations: y.a.object
                };
                var yn = fn;
                n(28);
                function mn(t) {
                  return (mn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function gn(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function bn(t, e) {
                  return (bn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function hn(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Mn(o);
                    if (r) {
                      var n = Mn(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === mn(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Mn(t) {
                  return (Mn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var jn = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && bn(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    r = hn(i);
                  function i() {
                    var e;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i);
                    for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++) n[o] = arguments[o];
                    return (e = r.call.apply(r, [this].concat(n))).onChange = function (t) {
                      (0, e.props.onChange)(t.target.innerHTML);
                    }, e;
                  }
                  return t = i, (e = [{
                    key: "renderEmojiModal",
                    value: function () {
                      var n = this,
                        t = this.props.config,
                        e = t.popupClassName,
                        o = t.emojis;
                      return N.a.createElement("div", {
                        className: w()("rdw-emoji-modal", e),
                        onClick: j
                      }, o.map(function (t, e) {
                        return N.a.createElement("span", {
                          key: e,
                          className: "rdw-emoji-icon",
                          alt: "",
                          onClick: n.onChange
                        }, t);
                      }));
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = e.icon,
                        o = e.className,
                        r = e.title,
                        i = t.expanded,
                        c = t.onExpandEvent,
                        a = t.translations;
                      return N.a.createElement("div", {
                        className: "rdw-emoji-wrapper",
                        "aria-haspopup": "true",
                        "aria-label": "rdw-emoji-control",
                        "aria-expanded": i,
                        title: r || a["components.controls.emoji.emoji"]
                      }, N.a.createElement(R, {
                        className: w()(o),
                        value: "unordered-list-item",
                        onClick: c
                      }, N.a.createElement("img", {
                        src: n,
                        alt: ""
                      })), i ? this.renderEmojiModal() : void 0);
                    }
                  }]) && gn(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                jn.propTypes = {
                  expanded: y.a.bool,
                  onExpandEvent: y.a.func,
                  onChange: y.a.func,
                  config: y.a.object,
                  translations: y.a.object
                };
                var vn = jn;
                function Nn(t) {
                  return (Nn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function En(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function Sn(t, e) {
                  return (Sn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function wn(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Cn(o);
                    if (r) {
                      var n = Cn(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === Nn(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Cn(t) {
                  return (Cn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var Ln = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && Sn(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = wn(r);
                  function r() {
                    var i;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r);
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return (i = o.call.apply(o, [this].concat(e))).state = {
                      expanded: false
                    }, i.onExpandEvent = function () {
                      i.signalExpanded = !i.state.expanded;
                    }, i.expandCollapse = function () {
                      i.setState({
                        expanded: i.signalExpanded
                      }), i.signalExpanded = false;
                    }, i.doExpand = function () {
                      i.setState({
                        expanded: true
                      });
                    }, i.doCollapse = function () {
                      i.setState({
                        expanded: false
                      });
                    }, i.addEmoji = function (t) {
                      var e = i.props,
                        n = e.editorState,
                        o = e.onChange,
                        r = E.Modifier.replaceText(n.getCurrentContent(), n.getSelection(), t, n.getCurrentInlineStyle());
                      o(E.EditorState.push(n, r, "insert-characters")), i.doCollapse();
                    }, i;
                  }
                  return t = r, (e = [{
                    key: "componentDidMount",
                    value: function () {
                      this.props.modalHandler.registerCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.translations,
                        o = this.state.expanded,
                        r = e.component || vn;
                      return N.a.createElement(r, {
                        config: e,
                        translations: n,
                        onChange: this.addEmoji,
                        expanded: o,
                        onExpandEvent: this.onExpandEvent,
                        doExpand: this.doExpand,
                        doCollapse: this.doCollapse,
                        onCollpase: this.closeModal
                      });
                    }
                  }]) && En(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                Ln.propTypes = {
                  editorState: y.a.object.isRequired,
                  onChange: y.a.func.isRequired,
                  modalHandler: y.a.object,
                  config: y.a.object,
                  translations: y.a.object
                };
                function Dn() {
                  return N.a.createElement("div", {
                    className: "rdw-spinner"
                  }, N.a.createElement("div", {
                    className: "rdw-bounce1"
                  }), N.a.createElement("div", {
                    className: "rdw-bounce2"
                  }), N.a.createElement("div", {
                    className: "rdw-bounce3"
                  }));
                }
                n(29), n(30);
                function kn(t) {
                  return (kn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function On(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function xn(t, e) {
                  return (xn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function In(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Tn(o);
                    if (r) {
                      var n = Tn(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === kn(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Tn(t) {
                  return (Tn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var An = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && xn(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = In(r);
                  function r() {
                    var a;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r);
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return (a = o.call.apply(o, [this].concat(e))).state = {
                      imgSrc: "",
                      dragEnter: false,
                      uploadHighlighted: a.props.config.uploadEnabled && !!a.props.config.uploadCallback,
                      showImageLoading: false,
                      height: a.props.config.defaultSize.height,
                      width: a.props.config.defaultSize.width,
                      alt: ""
                    }, a.onDragEnter = function (t) {
                      a.stopPropagation(t), a.setState({
                        dragEnter: true
                      });
                    }, a.onImageDrop = function (t) {
                      var e, n;
                      t.preventDefault(), t.stopPropagation(), a.setState({
                        dragEnter: false
                      }), n = t.dataTransfer.items ? (e = t.dataTransfer.items, true) : (e = t.dataTransfer.files, false);
                      for (var o = 0; o < e.length; o += 1) if ((!n || "file" === e[o].kind) && e[o].type.match("^image/")) {
                        var r = n ? e[o].getAsFile() : e[o];
                        a.uploadImage(r);
                      }
                    }, a.showImageUploadOption = function () {
                      a.setState({
                        uploadHighlighted: true
                      });
                    }, a.addImageFromState = function () {
                      var t = a.state,
                        e = t.imgSrc,
                        n = t.alt,
                        o = a.state,
                        r = o.height,
                        i = o.width,
                        c = a.props.onChange;
                      isNaN(r) || (r += "px"), isNaN(i) || (i += "px"), c(e, r, i, n);
                    }, a.showImageURLOption = function () {
                      a.setState({
                        uploadHighlighted: false
                      });
                    }, a.toggleShowImageLoading = function () {
                      var t = !a.state.showImageLoading;
                      a.setState({
                        showImageLoading: t
                      });
                    }, a.updateValue = function (t) {
                      var e, n, o;
                      a.setState((e = {}, n = "".concat(t.target.name), o = t.target.value, n in e ? Object.defineProperty(e, n, {
                        value: o,
                        enumerable: true,
                        configurable: true,
                        writable: true
                      }) : e[n] = o, e));
                    }, a.selectImage = function (t) {
                      t.target.files && 0 < t.target.files.length && a.uploadImage(t.target.files[0]);
                    }, a.uploadImage = function (t) {
                      a.toggleShowImageLoading(), (0, a.props.config.uploadCallback)(t).then(function (t) {
                        var e = t.data;
                        a.setState({
                          showImageLoading: false,
                          dragEnter: false,
                          imgSrc: e.link || e.url
                        }), a.fileUpload = false;
                      }).catch(function () {
                        a.setState({
                          showImageLoading: false,
                          dragEnter: false
                        });
                      });
                    }, a.fileUploadClick = function (t) {
                      a.fileUpload = true, t.stopPropagation();
                    }, a.stopPropagation = function (t) {
                      a.fileUpload ? a.fileUpload = false : (t.preventDefault(), t.stopPropagation());
                    }, a;
                  }
                  return t = r, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      var e = this.props.config;
                      t.expanded && !this.props.expanded ? this.setState({
                        imgSrc: "",
                        dragEnter: false,
                        uploadHighlighted: e.uploadEnabled && !!e.uploadCallback,
                        showImageLoading: false,
                        height: e.defaultSize.height,
                        width: e.defaultSize.width,
                        alt: ""
                      }) : e.uploadCallback === t.config.uploadCallback && e.uploadEnabled === t.config.uploadEnabled || this.setState({
                        uploadHighlighted: e.uploadEnabled && !!e.uploadCallback
                      });
                    }
                  }, {
                    key: "renderAddImageModal",
                    value: function () {
                      var t = this.state,
                        e = t.imgSrc,
                        n = t.uploadHighlighted,
                        o = t.showImageLoading,
                        r = t.dragEnter,
                        i = t.height,
                        c = t.width,
                        a = t.alt,
                        l = this.props,
                        s = l.config,
                        u = s.popupClassName,
                        p = s.uploadCallback,
                        d = s.uploadEnabled,
                        f = s.urlEnabled,
                        y = s.previewImage,
                        m = s.inputAccept,
                        g = s.alt,
                        b = l.doCollapse,
                        h = l.translations;
                      return N.a.createElement("div", {
                        className: w()("rdw-image-modal", u),
                        onClick: this.stopPropagation
                      }, N.a.createElement("div", {
                        className: "rdw-image-modal-header"
                      }, d && p && N.a.createElement("span", {
                        onClick: this.showImageUploadOption,
                        className: "rdw-image-modal-header-option"
                      }, h["components.controls.image.fileUpload"], N.a.createElement("span", {
                        className: w()("rdw-image-modal-header-label", {
                          "rdw-image-modal-header-label-highlighted": n
                        })
                      })), f && N.a.createElement("span", {
                        onClick: this.showImageURLOption,
                        className: "rdw-image-modal-header-option"
                      }, h["components.controls.image.byURL"], N.a.createElement("span", {
                        className: w()("rdw-image-modal-header-label", {
                          "rdw-image-modal-header-label-highlighted": !n
                        })
                      }))), n ? N.a.createElement("div", {
                        onClick: this.fileUploadClick
                      }, N.a.createElement("div", {
                        onDragEnter: this.onDragEnter,
                        onDragOver: this.stopPropagation,
                        onDrop: this.onImageDrop,
                        className: w()("rdw-image-modal-upload-option", {
                          "rdw-image-modal-upload-option-highlighted": r
                        })
                      }, N.a.createElement("label", {
                        htmlFor: "file",
                        className: "rdw-image-modal-upload-option-label"
                      }, y && e ? N.a.createElement("img", {
                        src: e,
                        alt: e,
                        className: "rdw-image-modal-upload-option-image-preview"
                      }) : e || h["components.controls.image.dropFileText"])), N.a.createElement("input", {
                        type: "file",
                        id: "file",
                        accept: m,
                        onChange: this.selectImage,
                        className: "rdw-image-modal-upload-option-input"
                      })) : N.a.createElement("div", {
                        className: "rdw-image-modal-url-section"
                      }, N.a.createElement("input", {
                        className: "rdw-image-modal-url-input",
                        placeholder: h["components.controls.image.enterlink"],
                        name: "imgSrc",
                        onChange: this.updateValue,
                        onBlur: this.updateValue,
                        value: e
                      }), N.a.createElement("span", {
                        className: "rdw-image-mandatory-sign"
                      }, "*")), g.present && N.a.createElement("div", {
                        className: "rdw-image-modal-size"
                      }, N.a.createElement("span", {
                        className: "rdw-image-modal-alt-lbl"
                      }, "Alt Text"), N.a.createElement("input", {
                        onChange: this.updateValue,
                        onBlur: this.updateValue,
                        value: a,
                        name: "alt",
                        className: "rdw-image-modal-alt-input",
                        placeholder: "alt"
                      }), N.a.createElement("span", {
                        className: "rdw-image-mandatory-sign"
                      }, g.mandatory && "*")), N.a.createElement("div", {
                        className: "rdw-image-modal-size"
                      }, "", N.a.createElement("input", {
                        onChange: this.updateValue,
                        onBlur: this.updateValue,
                        value: i,
                        name: "height",
                        className: "rdw-image-modal-size-input",
                        placeholder: "Height"
                      }), N.a.createElement("span", {
                        className: "rdw-image-mandatory-sign"
                      }, "*"), "", N.a.createElement("input", {
                        onChange: this.updateValue,
                        onBlur: this.updateValue,
                        value: c,
                        name: "width",
                        className: "rdw-image-modal-size-input",
                        placeholder: "Width"
                      }), N.a.createElement("span", {
                        className: "rdw-image-mandatory-sign"
                      }, "*")), N.a.createElement("span", {
                        className: "rdw-image-modal-btn-section"
                      }, N.a.createElement("button", {
                        className: "rdw-image-modal-btn",
                        onClick: this.addImageFromState,
                        disabled: !e || !i || !c || g.mandatory && !a
                      }, h["generic.add"]), N.a.createElement("button", {
                        className: "rdw-image-modal-btn",
                        onClick: b
                      }, h["generic.cancel"])), o ? N.a.createElement("div", {
                        className: "rdw-image-modal-spinner"
                      }, N.a.createElement(Dn, null)) : void 0);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = e.icon,
                        o = e.className,
                        r = e.title,
                        i = t.expanded,
                        c = t.onExpandEvent,
                        a = t.translations;
                      return N.a.createElement("div", {
                        className: "rdw-image-wrapper",
                        "aria-haspopup": "true",
                        "aria-expanded": i,
                        "aria-label": "rdw-image-control"
                      }, N.a.createElement(R, {
                        className: w()(o),
                        value: "unordered-list-item",
                        onClick: c,
                        title: r || a["components.controls.image.image"]
                      }, N.a.createElement("img", {
                        src: n,
                        alt: ""
                      })), i ? this.renderAddImageModal() : void 0);
                    }
                  }]) && On(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                An.propTypes = {
                  expanded: y.a.bool,
                  onExpandEvent: y.a.func,
                  doCollapse: y.a.func,
                  onChange: y.a.func,
                  config: y.a.object,
                  translations: y.a.object
                };
                var zn = An;
                function _n(t) {
                  return (_n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function Pn(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function Rn(t, e) {
                  return (Rn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Un(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Bn(o);
                    if (r) {
                      var n = Bn(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === _n(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Bn(t) {
                  return (Bn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var Fn = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && Rn(t, e);
                  }(r, f["Component"]);
                  var t,
                    e,
                    o = Un(r);
                  function r(t) {
                    var s;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, r), (s = o.call(this, t)).onExpandEvent = function () {
                      s.signalExpanded = !s.state.expanded;
                    }, s.doExpand = function () {
                      s.setState({
                        expanded: true
                      });
                    }, s.doCollapse = function () {
                      s.setState({
                        expanded: false
                      });
                    }, s.expandCollapse = function () {
                      s.setState({
                        expanded: s.signalExpanded
                      }), s.signalExpanded = false;
                    }, s.addImage = function (t, e, n, o) {
                      var r = s.props,
                        i = r.editorState,
                        c = r.onChange,
                        a = {
                          src: t,
                          height: e,
                          width: n
                        };
                      r.config.alt.present && (a.alt = o);
                      var l = i.getCurrentContent().createEntity("IMAGE", "MUTABLE", a).getLastCreatedEntityKey();
                      c(E.AtomicBlockUtils.insertAtomicBlock(i, l, " ")), s.doCollapse();
                    };
                    var e = s.props.modalHandler;
                    return s.state = {
                      expanded: false
                    }, e.registerCallBack(s.expandCollapse), s;
                  }
                  return t = r, (e = [{
                    key: "componentWillUnmount",
                    value: function () {
                      this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.translations,
                        o = this.state.expanded,
                        r = e.component || zn;
                      return N.a.createElement(r, {
                        config: e,
                        translations: n,
                        onChange: this.addImage,
                        expanded: o,
                        onExpandEvent: this.onExpandEvent,
                        doExpand: this.doExpand,
                        doCollapse: this.doCollapse
                      });
                    }
                  }]) && Pn(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), r;
                }();
                Fn.propTypes = {
                  editorState: y.a.object.isRequired,
                  onChange: y.a.func.isRequired,
                  modalHandler: y.a.object,
                  config: y.a.object,
                  translations: y.a.object
                };
                function Yn(t) {
                  var e = t.config,
                    n = t.onChange,
                    o = t.translations,
                    r = e.icon,
                    i = e.className,
                    c = e.title;
                  return N.a.createElement("div", {
                    className: "rdw-remove-wrapper",
                    "aria-label": "rdw-remove-control"
                  }, N.a.createElement(R, {
                    className: w()(i),
                    onClick: n,
                    title: c || o["components.controls.remove.remove"]
                  }, N.a.createElement("img", {
                    src: r,
                    alt: ""
                  })));
                }
                var Qn = Fn;
                n(31);
                Yn.propTypes = {
                  onChange: y.a.func,
                  config: y.a.object,
                  translations: y.a.object
                };
                var Hn = Yn;
                function Zn(t) {
                  return (Zn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function Wn(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function Gn(t, e) {
                  return (Gn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Jn(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Vn(o);
                    if (r) {
                      var n = Vn(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === Zn(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Vn(t) {
                  return (Vn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var qn = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && Gn(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    r = Jn(i);
                  function i() {
                    var n;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i);
                    for (var t = arguments.length, e = new Array(t), o = 0; o < t; o++) e[o] = arguments[o];
                    return (n = r.call.apply(r, [this].concat(e))).state = {
                      expanded: false
                    }, n.onExpandEvent = function () {
                      n.signalExpanded = !n.state.expanded;
                    }, n.expandCollapse = function () {
                      n.setState({
                        expanded: n.signalExpanded
                      }), n.signalExpanded = false;
                    }, n.removeInlineStyles = function () {
                      var t = n.props,
                        e = t.editorState;
                      (0, t.onChange)(n.removeAllInlineStyles(e));
                    }, n.removeAllInlineStyles = function (n) {
                      var o = n.getCurrentContent();
                      return ["BOLD", "ITALIC", "UNDERLINE", "STRIKETHROUGH", "MONOSPACE", "SUPERSCRIPT", "SUBSCRIPT"].forEach(function (t) {
                        o = E.Modifier.removeInlineStyle(o, n.getSelection(), t);
                      }), h(Object(S.getSelectionCustomInlineStyle)(n, ["FONTSIZE", "FONTFAMILY", "COLOR", "BGCOLOR"]), function (t, e) {
                        e && (o = E.Modifier.removeInlineStyle(o, n.getSelection(), e));
                      }), E.EditorState.push(n, o, "change-inline-style");
                    }, n.doExpand = function () {
                      n.setState({
                        expanded: true
                      });
                    }, n.doCollapse = function () {
                      n.setState({
                        expanded: false
                      });
                    }, n;
                  }
                  return t = i, (e = [{
                    key: "componentDidMount",
                    value: function () {
                      this.props.modalHandler.registerCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.translations,
                        o = this.state.expanded,
                        r = e.component || Hn;
                      return N.a.createElement(r, {
                        config: e,
                        translations: n,
                        expanded: o,
                        onExpandEvent: this.onExpandEvent,
                        doExpand: this.doExpand,
                        doCollapse: this.doCollapse,
                        onChange: this.removeInlineStyles
                      });
                    }
                  }]) && Wn(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                qn.propTypes = {
                  onChange: y.a.func.isRequired,
                  editorState: y.a.object.isRequired,
                  config: y.a.object,
                  translations: y.a.object,
                  modalHandler: y.a.object
                };
                n(32);
                function Kn(t) {
                  return (Kn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function Xn(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function $n(t, e) {
                  return ($n = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function to(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = eo(o);
                    if (r) {
                      var n = eo(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === Kn(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function eo(t) {
                  return (eo = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var no = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && $n(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    r = to(i);
                  function i() {
                    var e;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i);
                    for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++) n[o] = arguments[o];
                    return (e = r.call.apply(r, [this].concat(n))).onChange = function (t) {
                      (0, e.props.onChange)(t);
                    }, e;
                  }
                  return t = i, (e = [{
                    key: "renderInDropDown",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.expanded,
                        o = t.doExpand,
                        r = t.onExpandEvent,
                        i = t.doCollapse,
                        c = t.currentState,
                        a = c.undoDisabled,
                        l = c.redoDisabled,
                        s = t.translations,
                        u = e.options,
                        p = e.undo,
                        d = e.redo,
                        f = e.className,
                        y = e.dropdownClassName,
                        m = e.title;
                      return N.a.createElement(H, {
                        className: w()("rdw-history-dropdown", f),
                        optionWrapperClassName: w()(y),
                        expanded: n,
                        doExpand: o,
                        doCollapse: i,
                        onExpandEvent: r,
                        "aria-label": "rdw-history-control",
                        title: m || s["components.controls.history.history"]
                      }, N.a.createElement("img", {
                        src: v(e),
                        alt: ""
                      }), 0 <= u.indexOf("undo") && N.a.createElement(K, {
                        value: "undo",
                        onClick: this.onChange,
                        disabled: a,
                        className: w()("rdw-history-dropdownoption", p.className),
                        title: p.title || s["components.controls.history.undo"]
                      }, N.a.createElement("img", {
                        src: p.icon,
                        alt: ""
                      })), 0 <= u.indexOf("redo") && N.a.createElement(K, {
                        value: "redo",
                        onClick: this.onChange,
                        disabled: l,
                        className: w()("rdw-history-dropdownoption", d.className),
                        title: d.title || s["components.controls.history.redo"]
                      }, N.a.createElement("img", {
                        src: d.icon,
                        alt: ""
                      })));
                    }
                  }, {
                    key: "renderInFlatList",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = e.options,
                        o = e.undo,
                        r = e.redo,
                        i = e.className,
                        c = t.currentState,
                        a = c.undoDisabled,
                        l = c.redoDisabled,
                        s = t.translations;
                      return N.a.createElement("div", {
                        className: w()("rdw-history-wrapper", i),
                        "aria-label": "rdw-history-control"
                      }, 0 <= n.indexOf("undo") && N.a.createElement(R, {
                        value: "undo",
                        onClick: this.onChange,
                        className: w()(o.className),
                        disabled: a,
                        title: o.title || s["components.controls.history.undo"]
                      }, N.a.createElement("img", {
                        src: o.icon,
                        alt: ""
                      })), 0 <= n.indexOf("redo") && N.a.createElement(R, {
                        value: "redo",
                        onClick: this.onChange,
                        className: w()(r.className),
                        disabled: l,
                        title: r.title || s["components.controls.history.redo"]
                      }, N.a.createElement("img", {
                        src: r.icon,
                        alt: ""
                      })));
                    }
                  }, {
                    key: "render",
                    value: function () {
                      return this.props.config.inDropdown ? this.renderInDropDown() : this.renderInFlatList();
                    }
                  }]) && Xn(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                function oo(t) {
                  return (oo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function ro(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function io(t, e) {
                  return (io = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function co(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = ao(o);
                    if (r) {
                      var n = ao(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === oo(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function ao(t) {
                  return (ao = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                no.propTypes = {
                  expanded: y.a.bool,
                  doExpand: y.a.func,
                  doCollapse: y.a.func,
                  onExpandEvent: y.a.func,
                  config: y.a.object,
                  onChange: y.a.func,
                  currentState: y.a.object,
                  translations: y.a.object
                };
                var lo = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && io(t, e);
                  }(c, f["Component"]);
                  var t,
                    e,
                    r = co(c);
                  function c(t) {
                    var i;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, c), (i = r.call(this, t)).onExpandEvent = function () {
                      i.signalExpanded = !i.state.expanded;
                    }, i.onChange = function (t) {
                      var e = i.props,
                        n = e.editorState,
                        o = e.onChange,
                        r = E.EditorState[t](n);
                      r && o(r);
                    }, i.doExpand = function () {
                      i.setState({
                        expanded: true
                      });
                    }, i.doCollapse = function () {
                      i.setState({
                        expanded: false
                      });
                    };
                    var e = {
                        expanded: !(i.expandCollapse = function () {
                          i.setState({
                            expanded: i.signalExpanded
                          }), i.signalExpanded = false;
                        }),
                        undoDisabled: false,
                        redoDisabled: false
                      },
                      n = t.editorState,
                      o = t.modalHandler;
                    return n && (e.undoDisabled = 0 === n.getUndoStack().size, e.redoDisabled = 0 === n.getRedoStack().size), i.state = e, o.registerCallBack(i.expandCollapse), i;
                  }
                  return t = c, (e = [{
                    key: "componentDidUpdate",
                    value: function (t) {
                      var e = this.props.editorState;
                      e && t.editorState !== e && this.setState({
                        undoDisabled: 0 === e.getUndoStack().size,
                        redoDisabled: 0 === e.getRedoStack().size
                      });
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.props.modalHandler.deregisterCallBack(this.expandCollapse);
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.props,
                        e = t.config,
                        n = t.translations,
                        o = this.state,
                        r = o.undoDisabled,
                        i = o.redoDisabled,
                        c = o.expanded,
                        a = e.component || no;
                      return N.a.createElement(a, {
                        config: e,
                        translations: n,
                        currentState: {
                          undoDisabled: r,
                          redoDisabled: i
                        },
                        expanded: c,
                        onExpandEvent: this.onExpandEvent,
                        doExpand: this.doExpand,
                        doCollapse: this.doCollapse,
                        onChange: this.onChange
                      });
                    }
                  }]) && ro(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), c;
                }();
                lo.propTypes = {
                  onChange: y.a.func.isRequired,
                  editorState: y.a.object,
                  modalHandler: y.a.object,
                  config: y.a.object,
                  translations: y.a.object
                };
                var so = {
                    inline: st,
                    blockType: Et,
                    fontSize: zt,
                    fontFamily: Jt,
                    list: ce,
                    textAlign: he,
                    colorPicker: Ie,
                    link: $e,
                    embedded: yn,
                    emoji: Ln,
                    image: Qn,
                    remove: qn,
                    history: lo
                  },
                  uo = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
                  po = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
                function fo(t) {
                  return String(t).replace(uo, "").match(po) ? t : "#";
                }
                n(33);
                function yo(t) {
                  return (yo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function mo(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function go(t, e) {
                  return (go = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function bo(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = ho(o);
                    if (r) {
                      var n = ho(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === yo(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function ho(t) {
                  return (ho = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                function Mo(t, e, n) {
                  t.findEntityRanges(function (t) {
                    var e = t.getEntity();
                    return null !== e && "LINK" === n.getEntity(e).getType();
                  }, e);
                }
                function jo(t) {
                  var e,
                    a = t.showOpenOptionOnHover;
                  return (e = function () {
                    !function (t, e) {
                      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                      t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                          value: t,
                          writable: true,
                          configurable: true
                        }
                      }), Object.defineProperty(t, "prototype", {
                        writable: false
                      }), e && go(t, e);
                    }(i, f["Component"]);
                    var t,
                      e,
                      o = bo(i);
                    function i() {
                      var r;
                      !function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                      }(this, i);
                      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                      return (r = o.call.apply(o, [this].concat(e))).state = {
                        showPopOver: false
                      }, r.openLink = function () {
                        var t = r.props,
                          e = t.entityKey,
                          n = t.contentState.getEntity(e).getData().url,
                          o = window.open(fo(n), "blank");
                        o && o.focus();
                      }, r.toggleShowPopOver = function () {
                        var t = !r.state.showPopOver;
                        r.setState({
                          showPopOver: t
                        });
                      }, r;
                    }
                    return t = i, (e = [{
                      key: "render",
                      value: function () {
                        var t = this.props,
                          e = t.children,
                          n = t.entityKey,
                          o = t.contentState.getEntity(n).getData(),
                          r = o.url,
                          i = o.targetOption,
                          c = this.state.showPopOver;
                        return N.a.createElement("span", {
                          className: "rdw-link-decorator-wrapper",
                          onMouseEnter: this.toggleShowPopOver,
                          onMouseLeave: this.toggleShowPopOver
                        }, N.a.createElement("a", {
                          href: fo(r),
                          target: i
                        }, e), c && a ? N.a.createElement("img", {
                          src: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuMDcyIDBIOC45MTVhLjkyNS45MjUgMCAwIDAgMCAxLjg0OWgyLjkyNUw2Ljk2MSA2LjcyN2EuOTE4LjkxOCAwIDAgMC0uMjcuNjU0YzAgLjI0Ny4wOTUuNDguMjcuNjU0YS45MTguOTE4IDAgMCAwIC42NTQuMjcuOTE4LjkxOCAwIDAgMCAuNjUzLS4yN2w0Ljg4LTQuODh2Mi45MjZhLjkyNS45MjUgMCAwIDAgMS44NDggMFYuOTI0QS45MjUuOTI1IDAgMCAwIDE0LjA3MiAweiIvPjxwYXRoIGQ9Ik0xMC42MjMgMTMuNDExSDEuNTg1VjQuMzcyaDYuNzk4bDEuNTg0LTEuNTg0SC43OTJBLjc5Mi43OTIgMCAwIDAgMCAzLjU4djEwLjYyNGMwIC40MzcuMzU1Ljc5Mi43OTIuNzkyaDEwLjYyNGEuNzkyLjc5MiAwIDAgMCAuNzkyLS43OTJWNS4wMjlsLTEuNTg1IDEuNTg0djYuNzk4eiIvPjwvZz48L3N2Zz4=",
                          alt: "",
                          onClick: this.openLink,
                          className: "rdw-link-decorator-icon"
                        }) : void 0);
                      }
                    }]) && mo(t.prototype, e), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), i;
                  }()).propTypes = {
                    entityKey: y.a.string.isRequired,
                    children: y.a.array,
                    contentState: y.a.object
                  }, e;
                }
                n(34);
                function No(t, e, n) {
                  return Object.defineProperty(t, "prototype", {
                    writable: false
                  }), t;
                }
                var Eo = No(function t(e) {
                  var n = this;
                  !function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                  }(this, t), this.getMentionComponent = function () {
                    function t(t) {
                      var e = t.entityKey,
                        n = t.children,
                        o = t.contentState.getEntity(e).getData(),
                        r = o.url,
                        i = o.value;
                      return N.a.createElement("a", {
                        href: r || i,
                        className: w()("rdw-mention-link", c)
                      }, n);
                    }
                    var c = n.className;
                    return t.propTypes = {
                      entityKey: y.a.number,
                      children: y.a.array,
                      contentState: y.a.object
                    }, t;
                  }, this.getMentionDecorator = function () {
                    return {
                      strategy: n.findMentionEntities,
                      component: n.getMentionComponent()
                    };
                  }, this.className = e;
                });
                Eo.prototype.findMentionEntities = function (t, e, n) {
                  t.findEntityRanges(function (t) {
                    var e = t.getEntity();
                    return null !== e && "MENTION" === n.getEntity(e).getType();
                  }, e);
                };
                var So = Eo;
                n(35);
                function wo(t) {
                  return (wo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function Co(t, e) {
                  return (Co = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Lo(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Do(o);
                    if (r) {
                      var n = Do(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === wo(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Do(t) {
                  return (Do = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                function ko(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function Oo(t, e, n) {
                  return e && ko(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), t;
                }
                function xo(t, e) {
                  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                }
                var Io = Oo(function t(e) {
                    var p = this;
                    xo(this, t), this.findSuggestionEntities = function (t, e) {
                      if (p.config.getEditorState()) {
                        var n = p.config,
                          o = n.separator,
                          r = n.trigger,
                          i = n.getSuggestions,
                          c = (0, n.getEditorState)().getSelection();
                        if (c.get("anchorKey") === t.get("key") && c.get("anchorKey") === c.get("focusKey")) {
                          var a = t.getText(),
                            l = (a = a.substr(0, c.get("focusOffset") === a.length - 1 ? a.length : c.get("focusOffset") + 1)).lastIndexOf(o + r),
                            s = o + r;
                          if ((void 0 === l || l < 0) && a[0] === r && (l = 0, s = r), 0 <= l) {
                            var u = a.substr(l + s.length, a.length);
                            i().some(function (t) {
                              return !!t.value && (p.config.caseSensitive ? 0 <= t.value.indexOf(u) : 0 <= t.value.toLowerCase().indexOf(u && u.toLowerCase()));
                            }) && e(0 === l ? 0 : l + 1, a.length);
                          }
                        }
                      }
                    }, this.getSuggestionComponent = function () {
                      var t,
                        a = this.config;
                      return (t = function () {
                        !function (t, e) {
                          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                          t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                              value: t,
                              writable: true,
                              configurable: true
                            }
                          }), Object.defineProperty(t, "prototype", {
                            writable: false
                          }), e && Co(t, e);
                        }(r, f["Component"]);
                        var o = Lo(r);
                        function r() {
                          var c;
                          xo(this, r);
                          for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                          return (c = o.call.apply(o, [this].concat(e))).state = {
                            style: {
                              left: 15
                            },
                            activeOption: -1,
                            showSuggestions: true
                          }, c.onEditorKeyDown = function (t) {
                            var e = c.state.activeOption,
                              n = {};
                            "ArrowDown" === t.key ? (t.preventDefault(), e === c.filteredSuggestions.length - 1 ? n.activeOption = 0 : n.activeOption = e + 1) : "ArrowUp" === t.key ? n.activeOption = e <= 0 ? c.filteredSuggestions.length - 1 : e - 1 : "Escape" === t.key ? (n.showSuggestions = false, g()) : "Enter" === t.key && c.addMention(), c.setState(n);
                          }, c.onOptionMouseEnter = function (t) {
                            var e = t.target.getAttribute("data-index");
                            c.setState({
                              activeOption: e
                            });
                          }, c.onOptionMouseLeave = function () {
                            c.setState({
                              activeOption: -1
                            });
                          }, c.setSuggestionReference = function (t) {
                            c.suggestion = t;
                          }, c.setDropdownReference = function (t) {
                            c.dropdown = t;
                          }, c.closeSuggestionDropdown = function () {
                            c.setState({
                              showSuggestions: false
                            });
                          }, c.filteredSuggestions = [], c.filterSuggestions = function (t) {
                            var e = t.children[0].props.text.substr(1),
                              n = a.getSuggestions();
                            c.filteredSuggestions = n && n.filter(function (t) {
                              return !e || 0 === e.length || (a.caseSensitive ? 0 <= t.value.indexOf(e) : 0 <= t.value.toLowerCase().indexOf(e && e.toLowerCase()));
                            });
                          }, c.addMention = function () {
                            var t = c.state.activeOption,
                              e = a.getEditorState(),
                              n = a.onChange,
                              o = a.separator,
                              r = a.trigger,
                              i = c.filteredSuggestions[t];
                            i && function (t, e, n, o, r) {
                              var i = r.value,
                                c = r.url,
                                a = t.getCurrentContent().createEntity("MENTION", "IMMUTABLE", {
                                  text: "".concat(o).concat(i),
                                  value: i,
                                  url: c
                                }).getLastCreatedEntityKey(),
                                l = Object(S.getSelectedBlock)(t).getText(),
                                s = t.getSelection().focusOffset,
                                u = (l.lastIndexOf(n + o, s) || 0) + 1,
                                p = false;
                              l.length === u + 1 && (s = l.length), " " === l[s] && (p = true);
                              var d = t.getSelection().merge({
                                  anchorOffset: u,
                                  focusOffset: s
                                }),
                                f = E.EditorState.acceptSelection(t, d),
                                y = E.Modifier.replaceText(f.getCurrentContent(), d, "".concat(o).concat(i), f.getCurrentInlineStyle(), a);
                              f = E.EditorState.push(f, y, "insert-characters"), p || (d = f.getSelection().merge({
                                anchorOffset: u + i.length + o.length,
                                focusOffset: u + i.length + o.length
                              }), f = E.EditorState.acceptSelection(f, d), y = E.Modifier.insertText(f.getCurrentContent(), d, " ", f.getCurrentInlineStyle(), void 0)), e(E.EditorState.push(f, y, "insert-characters"));
                            }(e, n, o, r, i);
                          }, c;
                        }
                        return Oo(r, [{
                          key: "componentDidMount",
                          value: function () {
                            var t,
                              e,
                              n,
                              o = a.getWrapperRef().getBoundingClientRect(),
                              r = this.suggestion.getBoundingClientRect(),
                              i = this.dropdown.getBoundingClientRect();
                            o.width < r.left - o.left + i.width ? e = 15 : t = 15, o.bottom < i.bottom && (n = 0), this.setState({
                              style: {
                                left: t,
                                right: e,
                                bottom: n
                              }
                            }), C.registerCallBack(this.onEditorKeyDown), m(), a.modalHandler.setSuggestionCallback(this.closeSuggestionDropdown), this.filterSuggestions(this.props);
                          }
                        }, {
                          key: "componentDidUpdate",
                          value: function (t) {
                            this.props.children !== t.children && (this.filterSuggestions(t), this.setState({
                              showSuggestions: true
                            }));
                          }
                        }, {
                          key: "componentWillUnmount",
                          value: function () {
                            C.deregisterCallBack(this.onEditorKeyDown), g(), a.modalHandler.removeSuggestionCallback();
                          }
                        }, {
                          key: "render",
                          value: function () {
                            var n = this,
                              t = this.props.children,
                              e = this.state,
                              o = e.activeOption,
                              r = e.showSuggestions,
                              i = a.dropdownClassName,
                              c = a.optionClassName;
                            return N.a.createElement("span", {
                              className: "rdw-suggestion-wrapper",
                              ref: this.setSuggestionReference,
                              onClick: a.modalHandler.onSuggestionClick,
                              "aria-haspopup": "true",
                              "aria-label": "rdw-suggestion-popup"
                            }, N.a.createElement("span", null, t), r && N.a.createElement("span", {
                              className: w()("rdw-suggestion-dropdown", i),
                              contentEditable: "false",
                              suppressContentEditableWarning: true,
                              style: this.state.style,
                              ref: this.setDropdownReference
                            }, this.filteredSuggestions.map(function (t, e) {
                              return N.a.createElement("span", {
                                key: e,
                                spellCheck: false,
                                onClick: n.addMention,
                                "data-index": e,
                                onMouseEnter: n.onOptionMouseEnter,
                                onMouseLeave: n.onOptionMouseLeave,
                                className: w()("rdw-suggestion-option", c, {
                                  "rdw-suggestion-option-active": e === o
                                })
                              }, t.text);
                            })));
                          }
                        }]), r;
                      }()).propTypes = {
                        children: y.a.array
                      }, t;
                    }.bind(this), this.getSuggestionDecorator = function () {
                      return {
                        strategy: p.findSuggestionEntities,
                        component: p.getSuggestionComponent()
                      };
                    };
                    var n = e.separator,
                      o = e.trigger,
                      r = e.getSuggestions,
                      i = e.onChange,
                      c = e.getEditorState,
                      a = e.getWrapperRef,
                      l = e.caseSensitive,
                      s = e.dropdownClassName,
                      u = e.optionClassName,
                      d = e.modalHandler;
                    this.config = {
                      separator: n,
                      trigger: o,
                      getSuggestions: r,
                      onChange: i,
                      getEditorState: c,
                      getWrapperRef: a,
                      caseSensitive: l,
                      dropdownClassName: s,
                      optionClassName: u,
                      modalHandler: d
                    };
                  }),
                  To = function (t) {
                    return [new So(t.mentionClassName).getMentionDecorator(), new Io(t).getSuggestionDecorator()];
                  };
                n(36);
                function zo(t, e, n) {
                  return Object.defineProperty(t, "prototype", {
                    writable: false
                  }), t;
                }
                function _o(t) {
                  var e = t.block,
                    n = t.contentState.getEntity(e.getEntityAt(0)).getData(),
                    o = n.src,
                    r = n.height,
                    i = n.width;
                  return N.a.createElement("iframe", {
                    height: r,
                    width: i,
                    src: o,
                    frameBorder: "0",
                    allowFullScreen: true,
                    title: "Wysiwyg Embedded Content"
                  });
                }
                var Po = zo(function t(e) {
                    var a = this;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, t), this.getHashtagComponent = function () {
                      function t(t) {
                        var e = t.children,
                          n = e[0].props.text;
                        return N.a.createElement("a", {
                          href: n,
                          className: w()("rdw-hashtag-link", o)
                        }, e);
                      }
                      var o = a.className;
                      return t.propTypes = {
                        children: y.a.object
                      }, t;
                    }, this.findHashtagEntities = function (t, e) {
                      for (var n = t.getText(), o = 0, r = 0; 0 < n.length && 0 <= o;) if (n[0] === a.hashCharacter ? (r = o = 0, n = n.substr(a.hashCharacter.length)) : 0 <= (o = n.indexOf(a.separator + a.hashCharacter)) && (n = n.substr(o + (a.separator + a.hashCharacter).length), r += o + a.separator.length), 0 <= o) {
                        var i = 0 <= n.indexOf(a.separator) ? n.indexOf(a.separator) : n.length,
                          c = n.substr(0, i);
                        c && 0 < c.length && (e(r, r + c.length + a.hashCharacter.length), r += a.hashCharacter.length);
                      }
                    }, this.getHashtagDecorator = function () {
                      return {
                        strategy: a.findHashtagEntities,
                        component: a.getHashtagComponent()
                      };
                    }, this.className = e.className, this.hashCharacter = e.hashCharacter || "#", this.separator = e.separator || " ";
                  }),
                  Ro = function (t) {
                    return new Po(t).getHashtagDecorator();
                  };
                _o.propTypes = {
                  block: y.a.object,
                  contentState: y.a.object
                };
                var Uo = _o;
                n(37);
                function Bo(t) {
                  return (Bo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function Fo(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function Yo(t, e) {
                  return (Yo = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function Qo(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = Ho(o);
                    if (r) {
                      var n = Ho(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === Bo(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function Ho(t) {
                  return (Ho = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var Zo = function (d) {
                    var t;
                    return (t = function () {
                      !function (t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                        t.prototype = Object.create(e && e.prototype, {
                          constructor: {
                            value: t,
                            writable: true,
                            configurable: true
                          }
                        }), Object.defineProperty(t, "prototype", {
                          writable: false
                        }), e && Yo(t, e);
                      }(r, f["Component"]);
                      var t,
                        e,
                        o = Qo(r);
                      function r() {
                        var i;
                        !function (t, e) {
                          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                        }(this, r);
                        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        return (i = o.call.apply(o, [this].concat(e))).state = {
                          hovered: false
                        }, i.setEntityAlignmentLeft = function () {
                          i.setEntityAlignment("left");
                        }, i.setEntityAlignmentRight = function () {
                          i.setEntityAlignment("right");
                        }, i.setEntityAlignmentCenter = function () {
                          i.setEntityAlignment("none");
                        }, i.setEntityAlignment = function (t) {
                          var e = i.props,
                            n = e.block,
                            o = e.contentState,
                            r = n.getEntityAt(0);
                          o.mergeEntityData(r, {
                            alignment: t
                          }), d.onChange(E.EditorState.push(d.getEditorState(), o, "change-block-data")), i.setState({
                            dummy: true
                          });
                        }, i.toggleHovered = function () {
                          var t = !i.state.hovered;
                          i.setState({
                            hovered: t
                          });
                        }, i;
                      }
                      return t = r, (e = [{
                        key: "renderAlignmentOptions",
                        value: function (t) {
                          return N.a.createElement("div", {
                            className: w()("rdw-image-alignment-options-popup", {
                              "rdw-image-alignment-options-popup-right": "right" === t
                            })
                          }, N.a.createElement(R, {
                            onClick: this.setEntityAlignmentLeft,
                            className: "rdw-image-alignment-option"
                          }, "L"), N.a.createElement(R, {
                            onClick: this.setEntityAlignmentCenter,
                            className: "rdw-image-alignment-option"
                          }, "C"), N.a.createElement(R, {
                            onClick: this.setEntityAlignmentRight,
                            className: "rdw-image-alignment-option"
                          }, "R"));
                        }
                      }, {
                        key: "render",
                        value: function () {
                          var t = this.props,
                            e = t.block,
                            n = t.contentState,
                            o = this.state.hovered,
                            r = d.isReadOnly,
                            i = d.isImageAlignmentEnabled,
                            c = n.getEntity(e.getEntityAt(0)).getData(),
                            a = c.src,
                            l = c.alignment,
                            s = c.height,
                            u = c.width,
                            p = c.alt;
                          return N.a.createElement("span", {
                            onMouseEnter: this.toggleHovered,
                            onMouseLeave: this.toggleHovered,
                            className: w()("rdw-image-alignment", {
                              "rdw-image-left": "left" === l,
                              "rdw-image-right": "right" === l,
                              "rdw-image-center": !l || "none" === l
                            })
                          }, N.a.createElement("span", {
                            className: "rdw-image-imagewrapper"
                          }, N.a.createElement("img", {
                            src: a,
                            alt: p,
                            style: {
                              height: s,
                              width: u
                            }
                          }), !r() && o && i() ? this.renderAlignmentOptions(l) : void 0));
                        }
                      }]) && Fo(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: false
                      }), r;
                    }()).propTypes = {
                      block: y.a.object,
                      contentState: y.a.object
                    }, t;
                  },
                  Wo = function (o, r) {
                    return function (t) {
                      if ("function" == typeof r) {
                        var e = r(t, o, o.getEditorState);
                        if (e) return e;
                      }
                      if ("atomic" === t.getType()) {
                        var n = o.getEditorState().getCurrentContent().getEntity(t.getEntityAt(0));
                        if (n && "IMAGE" === n.type) return {
                          component: Zo(o),
                          editable: false
                        };
                        if (n && "EMBEDDED_LINK" === n.type) return {
                          component: Uo,
                          editable: false
                        };
                      }
                    };
                  },
                  Go = {
                    options: ["inline", "blockType", "fontSize", "fontFamily", "list", "textAlign", "colorPicker", "link", "embedded", "emoji", "image", "remove", "history"],
                    inline: {
                      inDropdown: false,
                      className: void 0,
                      component: void 0,
                      dropdownClassName: void 0,
                      options: ["bold", "italic", "underline", "strikethrough", "monospace", "superscript", "subscript"],
                      bold: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuMjM2IDBjMS42NTIgMCAyLjk0LjI5OCAzLjg2Ni44OTMuOTI1LjU5NSAxLjM4OCAxLjQ4NSAxLjM4OCAyLjY2OSAwIC42MDEtLjE3MyAxLjEzOS0uNTE2IDEuNjEtLjM0My40NzQtLjg0NC44My0xLjQ5OSAxLjA2OC44NDMuMTY3IDEuNDc0LjUyMyAxLjg5NSAxLjA3MS40MTkuNTUuNjMgMS4xODMuNjMgMS45MDMgMCAxLjI0NS0uNDQ0IDIuMTg3LTEuMzMgMi44MjUtLjg4Ni42NDEtMi4xNDQuOTYxLTMuNzY5Ljk2MUgwdi0yLjE2N2gxLjQ5NFYyLjE2N0gwVjBoNi4yMzZ6TTQuMzA4IDUuNDQ2aDIuMDI0Yy43NTIgMCAxLjMzLS4xNDMgMS43MzQtLjQzLjQwNS0uMjg1LjYwOC0uNzAxLjYwOC0xLjI1IDAtLjYtLjIwNC0xLjA0NC0uNjEyLTEuMzMtLjQwOC0uMjg2LTEuMDE2LS40MjctMS44MjYtLjQyN0g0LjMwOHYzLjQzN3ptMCAxLjgwNFYxMWgyLjU5M2MuNzQ3IDAgMS4zMTQtLjE1MiAxLjcwNy0uNDUyLjM5LS4zLjU4OC0uNzQ1LjU4OC0xLjMzNCAwLS42MzYtLjE2OC0xLjEyNC0uNS0xLjQ2LS4zMzYtLjMzNS0uODY0LS41MDQtMS41ODItLjUwNEg0LjMwOHoiIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==",
                        className: void 0,
                        title: void 0
                      },
                      italic: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTcgM1YyaDR2MUg5Ljc1M2wtMyAxMEg4djFINHYtMWgxLjI0N2wzLTEwSDd6Ii8+PC9zdmc+",
                        className: void 0,
                        title: void 0
                      },
                      underline: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTYuMDQ1IDJ2Ljk5Mkw0Ljc4NSAzdjUuMTcyYzAgLjg1OS4yNDMgMS41MTIuNzI3IDEuOTU3czEuMTI0LjY2OCAxLjkxOC42NjhjLjgzNiAwIDEuNTA5LS4yMjEgMi4wMTktLjY2NC41MTEtLjQ0Mi43NjYtMS4wOTYuNzY2LTEuOTYxVjNsLTEuMjYtLjAwOFYySDEzdi45OTJMMTEuNzM5IDN2NS4xNzJjMCAxLjIzNC0uMzk4IDIuMTgxLTEuMTk1IDIuODQtLjc5Ny42NTktMS44MzUuOTg4LTMuMTE0Ljk4OC0xLjI0MiAwLTIuMjQ4LS4zMjktMy4wMTctLjk4OC0uNzY5LS42NTktMS4xNTItMS42MDUtMS4xNTItMi44NFYzTDIgMi45OTJWMmg0LjA0NXpNMiAxM2gxMXYxSDJ6Ii8+PC9zdmc+",
                        className: void 0,
                        title: void 0
                      },
                      strikethrough: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNNC4wNCA1Ljk1NGg2LjIxNWE3LjQxMiA3LjQxMiAwIDAgMC0uNzk1LS40MzggMTEuOTA3IDExLjkwNyAwIDAgMC0xLjQ0Ny0uNTU3Yy0xLjE4OC0uMzQ4LTEuOTY2LS43MTEtMi4zMzQtMS4wODgtLjM2OC0uMzc3LS41NTItLjc3LS41NTItMS4xODEgMC0uNDk1LjE4Ny0uOTA2LjU2LTEuMjMyLjM4LS4zMzEuODg3LS40OTcgMS41MjMtLjQ5Ny42OCAwIDEuMjY2LjI1NSAxLjc1Ny43NjcuMjk1LjMxNS41ODIuODkxLjg2MSAxLjczbC4xMTcuMDE2LjcwMy4wNS4xLS4wMjRjLjAyOC0uMTUyLjA0Mi0uMjc5LjA0Mi0uMzggMC0uMzM3LS4wMzktLjg1Mi0uMTE3LTEuNTQ0YTkuMzc0IDkuMzc0IDAgMCAwLS4xNzYtLjk5NUM5Ljg4LjM3OSA5LjM4NS4yNDQgOS4wMTcuMTc2IDguMzY1LjA3IDcuODk5LjAxNiA3LjYyLjAxNmMtMS40NSAwLTIuNTQ1LjM1Ny0zLjI4NyAxLjA3MS0uNzQ3LjcyLTEuMTIgMS41ODktMS4xMiAyLjYwNyAwIC41MTEuMTMzIDEuMDQuNCAxLjU4Ni4xMjkuMjUzLjI3LjQ3OC40MjcuNjc0ek04LjI4IDguMTE0Yy41NzUuMjM2Ljk1Ny40MzYgMS4xNDcuNTk5LjQ1MS40MS42NzcuODUyLjY3NyAxLjMyNCAwIC4zODMtLjEzLjc0NS0uMzkzIDEuMDg4LS4yNS4zMzgtLjU5LjU4LTEuMDIuNzI2YTMuNDE2IDMuNDE2IDAgMCAxLTEuMTYzLjIyOGMtLjQwNyAwLS43NzUtLjA2Mi0xLjEwNC0uMTg2YTIuNjk2IDIuNjk2IDAgMCAxLS44NzgtLjQ4IDMuMTMzIDMuMTMzIDAgMCAxLS42Ny0uNzk0IDEuNTI3IDEuNTI3IDAgMCAxLS4xMDQtLjIyNyA1Ny41MjMgNTcuNTIzIDAgMCAwLS4xODgtLjQ3MyAyMS4zNzEgMjEuMzcxIDAgMCAwLS4yNTEtLjU5OWwtLjg1My4wMTd2LjM3MWwtLjAxNy4zMTNhOS45MiA5LjkyIDAgMCAwIDAgLjU3M2MuMDExLjI3LjAxNy43MDkuMDE3IDEuMzE2di4xMWMwIC4wNzkuMDIyLjE0LjA2Ny4xODUuMDgzLjA2OC4yODQuMTQ3LjYwMi4yMzdsMS4xNy4zMzdjLjQ1Mi4xMy45OTYuMTk0IDEuNjMyLjE5NC42ODYgMCAxLjI1Mi0uMDU5IDEuNjk4LS4xNzdhNC42OTQgNC42OTQgMCAwIDAgMS4yOC0uNTU3Yy40MDEtLjI1OS43MDUtLjQ4Ni45MTEtLjY4My4yNjgtLjI3Ni40NjYtLjU2OC41OTQtLjg3OGE0Ljc0IDQuNzQgMCAwIDAgLjM0My0xLjc4OGMwLS4yOTgtLjAyLS41NTctLjA1OC0uNzc2SDguMjgxek0xNC45MTQgNi41N2EuMjYuMjYgMCAwIDAtLjE5My0uMDc2SC4yNjhhLjI2LjI2IDAgMCAwLS4xOTMuMDc2LjI2NC4yNjQgMCAwIDAtLjA3NS4xOTR2LjU0YzAgLjA3OS4wMjUuMTQzLjA3NS4xOTRhLjI2LjI2IDAgMCAwIC4xOTMuMDc2SDE0LjcyYS4yNi4yNiAwIDAgMCAuMTkzLS4wNzYuMjY0LjI2NCAwIDAgMCAuMDc1LS4xOTR2LS41NGEuMjY0LjI2NCAwIDAgMC0uMDc1LS4xOTR6Ii8+PC9nPjwvc3ZnPg==",
                        className: void 0,
                        title: void 0
                      },
                      monospace: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzQ0NCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMS4wMjEgMi45MDZjLjE4NiAxLjIxOS4zNzIgMS41LjM3MiAyLjcxOUMxLjM5MyA2LjM3NSAwIDcuMDMxIDAgNy4wMzF2LjkzOHMxLjM5My42NTYgMS4zOTMgMS40MDZjMCAxLjIxOS0uMTg2IDEuNS0uMzcyIDIuNzE5Qy43NDMgMTQuMDYzIDEuNzY0IDE1IDIuNjkzIDE1aDEuOTV2LTEuODc1cy0xLjY3Mi4xODgtMS42NzItLjkzOGMwLS44NDMuMTg2LS44NDMuMzcyLTIuNzE4LjA5My0uODQ0LS40NjQtMS41LTEuMDIyLTEuOTY5LjU1OC0uNDY5IDEuMTE1LTEuMDMxIDEuMDIyLTEuODc1QzMuMDY0IDMuNzUgMi45NyAzLjc1IDIuOTcgMi45MDZjMC0xLjEyNSAxLjY3Mi0xLjAzMSAxLjY3Mi0xLjAzMVYwaC0xLjk1QzEuNjcgMCAuNzQzLjkzOCAxLjAyIDIuOTA2ek0xMS45NzkgMi45MDZjLS4xODYgMS4yMTktLjM3MiAxLjUtLjM3MiAyLjcxOSAwIC43NSAxLjM5MyAxLjQwNiAxLjM5MyAxLjQwNnYuOTM4cy0xLjM5My42NTYtMS4zOTMgMS40MDZjMCAxLjIxOS4xODYgMS41LjM3MiAyLjcxOS4yNzggMS45NjktLjc0MyAyLjkwNi0xLjY3MiAyLjkwNmgtMS45NXYtMS44NzVzMS42NzIuMTg4IDEuNjcyLS45MzhjMC0uODQzLS4xODYtLjg0My0uMzcyLTIuNzE4LS4wOTMtLjg0NC40NjQtMS41IDEuMDIyLTEuOTY5LS41NTgtLjQ2OS0xLjExNS0xLjAzMS0xLjAyMi0xLjg3NS4xODYtMS44NzUuMzcyLTEuODc1LjM3Mi0yLjcxOSAwLTEuMTI1LTEuNjcyLTEuMDMxLTEuNjcyLTEuMDMxVjBoMS45NWMxLjAyMiAwIDEuOTUuOTM4IDEuNjcyIDIuOTA2eiIvPjwvZz48L3N2Zz4=",
                        className: void 0,
                        title: void 0
                      },
                      superscript: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTcuMzA1IDEwLjE2NUwxMS44NjUgMTVIOS4wNTdsLTMuMTkyLTMuNTM2TDIuNzQ2IDE1SDBsNC41MjMtNC44MzVMLjIxOCA1LjYwM2gyLjc3TDUuOTg2IDguOTEgOS4wMSA1LjYwM2gyLjY0OWwtNC4zNTQgNC41NjJ6bTYuMjM0LTMuMjY5bDEuODc5LTEuMzA2Yy42NC0uNDE2IDEuMDYyLS44MDEgMS4yNjQtMS4xNTcuMjAxLS4zNTYuMzAyLS43MzguMzAyLTEuMTQ4IDAtLjY2OS0uMjM3LTEuMjEtLjcxLTEuNjItLjQ3NC0uNDExLTEuMDk3LS42MTctMS44NjgtLjYxNy0uNzQ0IDAtMS4zNC4yMDgtMS43ODUuNjI0LS40NDcuNDE2LS42NyAxLjA0My0uNjcgMS44ODFoMS40MzZjMC0uNS4wOTQtLjg0Ni4yODEtMS4wMzguMTg4LS4xOTEuNDQ1LS4yODcuNzcyLS4yODdzLjU4NS4wOTcuNzc3LjI5MmMuMTkuMTk1LjI4Ni40MzcuMjg2LjcyNiAwIC4yOS0uMDg5LjU1LS4yNjYuNzg1cy0uNjcuNjI4LTEuNDc5IDEuMTg0Yy0uNjkxLjQ3Ny0xLjYyNy45MjctMS45MDggMS4zNWwuMDE0IDEuNTY5SDE3VjYuODk2aC0zLjQ2MXoiLz48L3N2Zz4=",
                        className: void 0,
                        title: void 0
                      },
                      subscript: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTExLjg2NiAxMS42NDZIOS4wNkw1Ljg2NyA3Ljk0MmwtMy4xMjEgMy43MDRIMGw0LjUyNC01LjA2NEwuMjE4IDEuODA0aDIuNzdsMyAzLjQ2NCAzLjAyMy0zLjQ2NGgyLjY1TDcuMzA2IDYuNTgybDQuNTYgNS4wNjR6bTEuNzI1IDIuMDU4bDEuODI3LTEuMzY4Yy42NC0uNDM1IDEuMDYyLS44NCAxLjI2NC0xLjIxMi4yMDItLjM3Mi4zMDItLjc3My4zMDItMS4yMDIgMC0uNy0uMjM3LTEuMjY2LS43MS0xLjY5Ni0uNDc0LS40MzEtMS4wOTctLjY0Ni0xLjg2OS0uNjQ2LS43NDQgMC0xLjM0LjIxOC0xLjc4NS42NTMtLjQ0Ni40MzYtLjY3IDEuMDkyLS42NyAxLjk3aDEuNDM2YzAtLjUyNC4wOTQtLjg4Ni4yODEtMS4wODcuMTg4LS4yLjQ0NS0uMzAxLjc3Mi0uMzAxcy41ODYuMTAyLjc3Ny4zMDZjLjE5LjIwNC4yODYuNDU4LjI4Ni43NiAwIC4zMDMtLjA4OC41NzctLjI2Ni44MjItLjE3Ny4yNDUtLjY3LjY1OC0xLjQ3OCAxLjI0LS42OTIuNS0xLjYyOC45NzEtMS45MSAxLjQxM0wxMS44NjQgMTVIMTd2LTEuMjk2aC0zLjQxeiIvPjwvc3ZnPg==",
                        className: void 0,
                        title: void 0
                      }
                    },
                    blockType: {
                      inDropdown: true,
                      options: ["Normal", "H1", "H2", "H3", "H4", "H5", "H6", "Blockquote", "Code"],
                      className: void 0,
                      component: void 0,
                      dropdownClassName: void 0,
                      title: void 0
                    },
                    fontSize: {
                      icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTEuOTIxIDMuMTE5YS40MjcuNDI3IDAgMCAwIC4zMzUuMTY0aC45N2EuNDI2LjQyNiAwIDAgMCAuMzA0LS4xMy40NDEuNDQxIDAgMCAwIC4xMjUtLjMxbC4wMDItMi40MWEuNDM0LjQzNCAwIDAgMC0uNDMtLjQzMkguNDNBLjQzNC40MzQgMCAwIDAgMCAuNDR2Mi40MDZjMCAuMjQyLjE5Mi40MzguNDMuNDM4aC45N2MuMTMgMCAuMjU0LS4wNi4zMzUtLjE2NWwuNzMtLjkzSDUuNTR2MTEuMzZjMCAuMjQxLjE5Mi40MzcuNDMuNDM3aDEuNzE3Yy4yMzcgMCAuNDMtLjE5Ni40My0uNDM3VjIuMTg4aDMuMDdsLjczNC45MzF6TTEzLjg5OCAxMS4yNjNhLjQyNS40MjUgMCAwIDAtLjQ4Mi0uMTQ2bC0uNTQ3LjE5NFY5LjYxN2EuNDQyLjQ0MiAwIDAgMC0uMTI2LS4zMS40MjYuNDI2IDAgMCAwLS4zMDQtLjEyN2gtLjQyOWEuNDM0LjQzNCAwIDAgMC0uNDMuNDM3djEuNjk0bC0uNTQ3LS4xOTRhLjQyNS40MjUgMCAwIDAtLjQ4MS4xNDYuNDQ0LjQ0NCAwIDAgMC0uMDE2LjUxMmwxLjMzMiAyLjAxN2EuNDI3LjQyNyAwIDAgMCAuNzEzIDBsMS4zMzMtMi4wMTdhLjQ0NC40NDQgMCAwIDAtLjAxNi0uNTEyeiIvPjwvZz48L3N2Zz4=",
                      options: [8, 9, 10, 11, 12, 14, 16, 18, 24, 30, 36, 48, 60, 72, 96],
                      className: void 0,
                      component: void 0,
                      dropdownClassName: void 0,
                      title: void 0
                    },
                    fontFamily: {
                      options: ["Arial", "Georgia", "Impact", "Tahoma", "Times New Roman", "Verdana"],
                      className: void 0,
                      component: void 0,
                      dropdownClassName: void 0,
                      title: void 0
                    },
                    list: {
                      inDropdown: false,
                      className: void 0,
                      component: void 0,
                      dropdownClassName: void 0,
                      options: ["unordered", "ordered", "indent", "outdent"],
                      unordered: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMS43MiAzLjQyN2MuOTUxIDAgMS43MjItLjc2OCAxLjcyMi0xLjcwOFMyLjY3LjAxIDEuNzIuMDFDLjc3LjAwOCAwIC43NzUgMCAxLjcxNWMwIC45NC43NzQgMS43MTEgMS43MiAxLjcxMXptMC0yLjYyNWMuNTEgMCAuOTIyLjQxMi45MjIuOTE0YS45Mi45MiAwIDAgMS0xLjg0MiAwIC45Mi45MiAwIDAgMSAuOTItLjkxNHpNMS43MiA4LjcwM2MuOTUxIDAgMS43MjItLjc2OCAxLjcyMi0xLjcwOFMyLjY3IDUuMjg3IDEuNzIgNS4yODdDLjc3IDUuMjg3IDAgNi4wNTIgMCA2Ljk5NXMuNzc0IDEuNzA4IDEuNzIgMS43MDh6bTAtMi42MjJjLjUxIDAgLjkyMi40MTIuOTIyLjkxNGEuOTIuOTIgMCAwIDEtMS44NDIgMGMwLS41MDUuNDE1LS45MTQuOTItLjkxNHpNMS43MiAxMy45ODJjLjk1MSAwIDEuNzIyLS43NjggMS43MjItMS43MDggMC0uOTQzLS43NzQtMS43MDgtMS43MjEtMS43MDgtLjk0NyAwLTEuNzIxLjc2OC0xLjcyMSAxLjcwOHMuNzc0IDEuNzA4IDEuNzIgMS43MDh6bTAtMi42MjVjLjUxIDAgLjkyMi40MTIuOTIyLjkxNGEuOTIuOTIgMCAxIDEtMS44NDIgMCAuOTIuOTIgMCAwIDEgLjkyLS45MTR6TTUuNzQ0IDIuMTE1aDkuODQ1YS40LjQgMCAwIDAgLjQwMS0uMzk5LjQuNCAwIDAgMC0uNDAxLS4zOTlINS43NDRhLjQuNCAwIDAgMC0uNDAyLjM5OS40LjQgMCAwIDAgLjQwMi4zOTl6TTUuNzQ0IDcuMzk0aDkuODQ1YS40LjQgMCAwIDAgLjQwMS0uMzk5LjQuNCAwIDAgMC0uNDAxLS4zOThINS43NDRhLjQuNCAwIDAgMC0uNDAyLjM5OC40LjQgMCAwIDAgLjQwMi4zOTl6TTUuNzQ0IDEyLjY3aDkuODQ1YS40LjQgMCAwIDAgLjQwMS0uMzk5LjQuNCAwIDAgMC0uNDAxLS4zOTlINS43NDRhLjQuNCAwIDAgMC0uNDAyLjQuNC40IDAgMCAwIC40MDIuMzk4eiIvPjwvZz48L3N2Zz4=",
                        className: void 0,
                        title: void 0
                      },
                      ordered: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNNC4yMDIgMS40NjZoOC4xNWMuMzM4IDAgLjYxMi0uMzIyLjYxMi0uNzIgMC0uMzk3LS4yNzQtLjcyLS42MTItLjcyaC04LjE1Yy0uMzM4IDAtLjYxMS4zMjMtLjYxMS43MiAwIC4zOTguMjczLjcyLjYxLjcyek0xMi4zNTIgNS43ODNoLTguMTVjLS4zMzggMC0uNjExLjMyMi0uNjExLjcyIDAgLjM5Ny4yNzMuNzIuNjEuNzJoOC4xNTFjLjMzOCAwIC42MTItLjMyMy42MTItLjcyIDAtLjM5OC0uMjc0LS43Mi0uNjEyLS43MnpNMTIuMzUyIDExLjU0aC04LjE1Yy0uMzM4IDAtLjYxMS4zMjItLjYxMS43MiAwIC4zOTYuMjczLjcxOS42MS43MTloOC4xNTFjLjMzOCAwIC42MTItLjMyMy42MTItLjcyIDAtLjM5Ny0uMjc0LS43Mi0uNjEyLS43MnpNLjc2NyAxLjI0OXYxLjgwMmMwIC4xOTUuMTM2LjM0My4zMTUuMzQzLjE3NiAwIC4zMTUtLjE1LjMxNS0uMzQzVi4zNTZjMC0uMTktLjEzMy0uMzM5LS4zMDItLjMzOS0uMTQ4IDAtLjIyMy4xMTgtLjI0Ny4xNTZhLjIyOC4yMjggMCAwIDAtLjAwMy4wMDVMLjU3OS42MjFhLjQ3NC40NzQgMCAwIDAtLjA5OC4yNzNjMCAuMTk0LjEyOC4zNTEuMjg2LjM1NXpNLjM1MiA4LjE5SDEuNTVjLjE1NyAwIC4yODUtLjE2Mi4yODUtLjM2MiAwLS4xOTgtLjEyOC0uMzU5LS4yODUtLjM1OUguNjh2LS4wMDZjMC0uMTA3LjIxLS4yODEuMzc4LS40MjIuMzM2LS4yNzguNzUzLS42MjUuNzUzLTEuMjI2IDAtLjU3LS4zNzYtMS0uODc0LTEtLjQ3NyAwLS44MzYuMzg1LS44MzYuODk3IDAgLjI5Ny4xNjQuNDAyLjMwNS40MDIuMiAwIC4zMjEtLjE3Ni4zMjEtLjM0NiAwLS4xMDYuMDIzLS4yMjguMjA0LS4yMjguMjQzIDAgLjI1LjI1NC4yNS4yODMgMCAuMjI4LS4yNTIuNDQyLS40OTUuNjQ5LS4zMDEuMjU1LS42NDIuNTQ0LS42NDIuOTkydi4zODRjMCAuMjA1LjE1OS4zNDMuMzA4LjM0M3pNMS43NyAxMC41NDNjMC0uNTkyLS4yOTYtLjkzMS0uODE0LS45MzEtLjY4IDAtLjg1OS41Ny0uODU5Ljg3MiAwIC4zNTEuMjIyLjM5LjMxOC4zOS4xODUgMCAuMzEtLjE0OC4zMS0uMzY2IDAtLjA4NC4wMjYtLjE4MS4yMjQtLjE4MS4xNDIgMCAuMi4wMjQuMi4yNjcgMCAuMjM3LS4wNDMuMjYzLS4yMTMuMjYzLS4xNjQgMC0uMjg4LjE1Mi0uMjg4LjM1NCAwIC4yLjEyNS4zNS4yOTEuMzUuMjI1IDAgLjI3LjEwOC4yNy4yODN2LjA3NWMwIC4yOTQtLjA5Ny4zNS0uMjc3LjM1LS4yNDggMC0uMjY3LS4xNS0uMjY3LS4xOTcgMC0uMTc0LS4wOTgtLjM1LS4zMTctLjM1LS4xOTIgMC0uMzA3LjE0MS0uMzA3LjM3OCAwIC40My4zMTMuODg4Ljg5NS44ODguNTY0IDAgLjkwMS0uNC45MDEtMS4wN3YtLjA3NGMwLS4yNzQtLjA3NC0uNTAyLS4yMTQtLjY2Ni4wOTYtLjE2My4xNDgtLjM4LjE0OC0uNjM1eiIvPjwvZz48L3N2Zz4=",
                        className: void 0,
                        title: void 0
                      },
                      indent: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNNS43MTYgMy4yMTFIMTd2MS4xOTdINS43MTZ6TTAgLjAyaDE3djEuMTk3SDB6TTAgMTIuNzgzaDE3djEuMTk3SDB6TTUuNzE2IDkuNTkzSDE3djEuMTk3SDUuNzE2ek01LjcxNiA2LjQwMkgxN3YxLjE5N0g1LjcxNnpNLjE4NyA5LjQ5MUwyLjUyIDcgLjE4NyA0LjUwOXoiLz48L2c+PC9zdmc+",
                        className: void 0,
                        title: void 0
                      },
                      outdent: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNNS4zOTYgMy4xOTNoMTAuNTczVjQuMzlINS4zOTZ6TS4wMzkuMDAzaDE1LjkzVjEuMkguMDM5ek0uMDM5IDEyLjc2NmgxNS45M3YxLjE5N0guMDM5ek01LjM5NiA5LjU3NWgxMC41NzN2MS4xOTdINS4zOTZ6TTUuMzk2IDYuMzg0aDEwLjU3M3YxLjE5N0g1LjM5NnpNMi4xODcgNC40OTFMMCA2Ljk4M2wyLjE4NyAyLjQ5MXoiLz48L2c+PC9zdmc+",
                        className: void 0,
                        title: void 0
                      },
                      title: void 0
                    },
                    textAlign: {
                      inDropdown: false,
                      className: void 0,
                      component: void 0,
                      dropdownClassName: void 0,
                      options: ["left", "center", "right", "justify"],
                      left: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNOC40OTMgMTQuODg3SC4zMjZhLjMyNi4zMjYgMCAwIDEgMC0uNjUyaDguMTY3YS4zMjYuMzI2IDAgMCAxIDAgLjY1MnpNMTQuNjE4IDEwLjE2MkguMzI2YS4zMjYuMzI2IDAgMCAxIDAtLjY1M2gxNC4yOTJhLjMyNi4zMjYgMCAwIDEgMCAuNjUzek04LjQ5MyA1LjQzNUguMzI2YS4zMjYuMzI2IDAgMCAxIDAtLjY1Mmg4LjE2N2EuMzI2LjMyNiAwIDAgMSAwIC42NTJ6TTE0LjYxOC43MDlILjMyNmEuMzI2LjMyNiAwIDAgMSAwLS42NTJoMTQuMjkyYS4zMjYuMzI2IDAgMCAxIDAgLjY1MnoiLz48L2c+PC9zdmc+",
                        className: void 0,
                        title: void 0
                      },
                      center: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTEuNTU2IDE0Ljg4N0gzLjM4OGEuMzI2LjMyNiAwIDAgMSAwLS42NTJoOC4xNjdhLjMyNi4zMjYgMCAwIDEgMCAuNjUyek0xNC42MTggMTAuMTYySC4zMjZhLjMyNi4zMjYgMCAwIDEgMC0uNjUzaDE0LjI5MmEuMzI2LjMyNiAwIDAgMSAwIC42NTN6TTExLjU1NiA1LjQzNUgzLjM4OGEuMzI2LjMyNiAwIDAgMSAwLS42NTJoOC4xNjdhLjMyNi4zMjYgMCAwIDEgMCAuNjUyek0xNC42MTguNzA5SC4zMjZhLjMyNi4zMjYgMCAwIDEgMC0uNjUyaDE0LjI5MmEuMzI2LjMyNiAwIDAgMSAwIC42NTJ6Ii8+PC9nPjwvc3ZnPg==",
                        className: void 0,
                        title: void 0
                      },
                      right: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuNjE4IDE0Ljg4N0g2LjQ1YS4zMjYuMzI2IDAgMCAxIDAtLjY1Mmg4LjE2N2EuMzI2LjMyNiAwIDAgMSAwIC42NTJ6TTE0LjYxOCAxMC4xNjJILjMyNmEuMzI2LjMyNiAwIDAgMSAwLS42NTNoMTQuMjkyYS4zMjYuMzI2IDAgMCAxIDAgLjY1M3pNMTQuNjE4IDUuNDM1SDYuNDVhLjMyNi4zMjYgMCAwIDEgMC0uNjUyaDguMTY3YS4zMjYuMzI2IDAgMCAxIDAgLjY1MnpNMTQuNjE4LjcwOUguMzI2YS4zMjYuMzI2IDAgMCAxIDAtLjY1MmgxNC4yOTJhLjMyNi4zMjYgMCAwIDEgMCAuNjUyeiIvPjwvZz48L3N2Zz4=",
                        className: void 0,
                        title: void 0
                      },
                      justify: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuNjIgMTQuODg4SC4zMjVhLjMyNi4zMjYgMCAwIDEgMC0uNjUySDE0LjYyYS4zMjYuMzI2IDAgMCAxIDAgLjY1MnpNMTQuNjIgMTAuMTYySC4zMjVhLjMyNi4zMjYgMCAwIDEgMC0uNjUySDE0LjYyYS4zMjYuMzI2IDAgMCAxIDAgLjY1MnpNMTQuNjIgNS40MzZILjMyNWEuMzI2LjMyNiAwIDAgMSAwLS42NTJIMTQuNjJhLjMyNi4zMjYgMCAwIDEgMCAuNjUyek0xNC42Mi43MUguMzI1YS4zMjYuMzI2IDAgMCAxIDAtLjY1M0gxNC42MmEuMzI2LjMyNiAwIDAgMSAwIC42NTN6Ii8+PC9nPjwvc3ZnPg==",
                        className: void 0,
                        title: void 0
                      },
                      title: void 0
                    },
                    colorPicker: {
                      icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuNDA2LjU4NWExLjk5OCAxLjk5OCAwIDAgMC0yLjgyNSAwbC0uNTQuNTRhLjc0MS43NDEgMCAxIDAtMS4wNDggMS4wNDhsLjE3NS4xNzUtNS44MjYgNS44MjUtMi4wMjIgMi4wMjNhLjkxLjkxIDAgMCAwLS4yNjYuNjAybC0uMDA1LjEwOHYuMDAybC0uMDgxIDEuODI5YS4zMDIuMzAyIDAgMCAwIC4zMDIuMzE2aC4wMTNsLjk3LS4wNDQuNTkyLS4wMjYuMjY4LS4wMTJjLjI5Ny0uMDEzLjU3OS0uMTM3Ljc5LS4zNDdsNy43Ny03Ljc3LjE0Ni4xNDRhLjc0Ljc0IDAgMCAwIDEuMDQ4IDBjLjI5LS4yOS4yOS0uNzU5IDAtMS4wNDhsLjU0LS41NGMuNzgtLjc4Ljc4LTIuMDQ0IDAtMi44MjV6TTguNzk1IDcuMzMzbC0yLjczLjUxNSA0LjQ1Mi00LjQ1MiAxLjEwOCAxLjEwNy0yLjgzIDIuODN6TTIuMDggMTMuNjczYy0xLjE0OCAwLTIuMDguMjk1LTIuMDguNjYgMCAuMzYzLjkzMi42NTggMi4wOC42NTggMS4xNSAwIDIuMDgtLjI5NCAyLjA4LS42NTkgMC0uMzY0LS45My0uNjU5LTIuMDgtLjY1OXoiLz48L2c+PC9zdmc+",
                      className: void 0,
                      component: void 0,
                      popupClassName: void 0,
                      colors: ["rgb(97,189,109)", "rgb(26,188,156)", "rgb(84,172,210)", "rgb(44,130,201)", "rgb(147,101,184)", "rgb(71,85,119)", "rgb(204,204,204)", "rgb(65,168,95)", "rgb(0,168,133)", "rgb(61,142,185)", "rgb(41,105,176)", "rgb(85,57,130)", "rgb(40,50,78)", "rgb(0,0,0)", "rgb(247,218,100)", "rgb(251,160,38)", "rgb(235,107,86)", "rgb(226,80,65)", "rgb(163,143,132)", "rgb(239,239,239)", "rgb(255,255,255)", "rgb(250,197,28)", "rgb(243,121,52)", "rgb(209,72,65)", "rgb(184,49,47)", "rgb(124,112,107)", "rgb(209,213,216)"],
                      title: void 0
                    },
                    link: {
                      inDropdown: false,
                      className: void 0,
                      component: void 0,
                      popupClassName: void 0,
                      dropdownClassName: void 0,
                      showOpenOptionOnHover: true,
                      defaultTargetOption: "_self",
                      options: ["link", "unlink"],
                      link: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEzLjk2Ny45NUEzLjIyNiAzLjIyNiAwIDAgMCAxMS42Ny4wMDJjLS44NyAwLTEuNjg2LjMzNy0yLjI5Ny45NDhMNy4xMDUgMy4yMThBMy4yNDcgMy4yNDcgMCAwIDAgNi4yNCA2LjI0YTMuMjI1IDMuMjI1IDAgMCAwLTMuMDIyLjg2NUwuOTUgOS4zNzNhMy4yNTMgMy4yNTMgMCAwIDAgMCA0LjU5NCAzLjIyNiAzLjIyNiAwIDAgMCAyLjI5Ny45NDhjLjg3IDAgMS42ODYtLjMzNiAyLjI5OC0uOTQ4TDcuODEyIDExLjdhMy4yNDcgMy4yNDcgMCAwIDAgLjg2NS0zLjAyMyAzLjIyNSAzLjIyNSAwIDAgMCAzLjAyMi0uODY1bDIuMjY4LTIuMjY3YTMuMjUyIDMuMjUyIDAgMCAwIDAtNC41OTV6TTcuMTA1IDEwLjk5M0w0LjgzNyAxMy4yNmEyLjIzMyAyLjIzMyAwIDAgMS0xLjU5LjY1NSAyLjIzMyAyLjIzMyAwIDAgMS0xLjU5LS42NTUgMi4yNTIgMi4yNTIgMCAwIDEgMC0zLjE4bDIuMjY4LTIuMjY4YTIuMjMyIDIuMjMyIDAgMCAxIDEuNTktLjY1NWMuNDMgMCAuODQxLjEyIDEuMTk1LjM0M0w0Ljc3MiA5LjQzOGEuNS41IDAgMSAwIC43MDcuNzA3bDEuOTM5LTEuOTM4Yy41NDUuODY4LjQ0MiAyLjAzLS4zMTMgMi43ODV6bTYuMTU1LTYuMTU1bC0yLjI2OCAyLjI2N2EyLjIzMyAyLjIzMyAwIDAgMS0xLjU5LjY1NWMtLjQzMSAwLS44NDEtLjEyLTEuMTk1LS4zNDNsMS45MzgtMS45MzhhLjUuNSAwIDEgMC0uNzA3LS43MDdMNy40OTkgNi43MWEyLjI1MiAyLjI1MiAwIDAgMSAuMzEzLTIuNzg1bDIuMjY3LTIuMjY4YTIuMjMzIDIuMjMzIDAgMCAxIDEuNTktLjY1NSAyLjIzMyAyLjIzMyAwIDAgMSAyLjI0NiAyLjI0NWMwIC42MDMtLjIzMiAxLjE2OC0uNjU1IDEuNTl6IiBmaWxsPSIjMDAwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=",
                        className: void 0,
                        title: void 0
                      },
                      unlink: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTMuOTU2IDEuMDM3YTMuNTUgMy41NSAwIDAgMC01LjAxNCAwTDYuNDM2IDMuNTQ0YS41NDUuNTQ1IDAgMSAwIC43Ny43N2wyLjUwOC0yLjUwNmEyLjQzOCAyLjQzOCAwIDAgMSAxLjczNS0uNzE1Yy42NTggMCAxLjI3NS4yNTQgMS43MzYuNzE1LjQ2LjQ2MS43MTUgMS4wNzguNzE1IDEuNzM2IDAgLjY1OC0uMjU0IDEuMjc0LS43MTUgMS43MzVMOS45MDcgOC41NThhMi40NTggMi40NTggMCAwIDEtMy40NzIgMCAuNTQ1LjU0NSAwIDEgMC0uNzcxLjc3MSAzLjUzNCAzLjUzNCAwIDAgMCAyLjUwNyAxLjAzN2MuOTA4IDAgMS44MTYtLjM0NiAyLjUwNy0xLjAzN2wzLjI3OC0zLjI3OGEzLjUyIDMuNTIgMCAwIDAgMS4wMzUtMi41MDdjMC0uOTUtLjM2Ny0xLjg0LTEuMDM1LTIuNTA3eiIvPjxwYXRoIGQ9Ik03LjQgMTEuMDY1bC0yLjEyMiAyLjEyYTIuNDM3IDIuNDM3IDAgMCAxLTEuNzM1LjcxNiAyLjQzNyAyLjQzNyAwIDAgMS0xLjczNi0uNzE1IDIuNDU3IDIuNDU3IDAgMCAxIDAtMy40NzFsMy4wODYtMy4wODZhMi40MzggMi40MzggMCAwIDEgMS43MzUtLjcxNWMuNjU4IDAgMS4yNzUuMjU0IDEuNzM2LjcxNWEuNTQ1LjU0NSAwIDEgMCAuNzcxLS43NzEgMy41NSAzLjU1IDAgMCAwLTUuMDE0IDBMMS4wMzYgOC45NDRBMy41MiAzLjUyIDAgMCAwIDAgMTEuNDVjMCAuOTUuMzY3IDEuODQgMS4wMzUgMi41MDdhMy41MiAzLjUyIDAgMCAwIDIuNTA2IDEuMDM1Yy45NSAwIDEuODQtLjM2OCAyLjUwNy0xLjAzNWwyLjEyMi0yLjEyMWEuNTQ1LjU0NSAwIDAgMC0uNzcxLS43NzF6TTkuMjc0IDEyLjAwMmEuNTQ2LjU0NiAwIDAgMC0uNTQ2LjU0NXYxLjYzN2EuNTQ2LjU0NiAwIDAgMCAxLjA5MSAwdi0xLjYzN2EuNTQ1LjU0NSAwIDAgMC0uNTQ1LS41NDV6TTExLjIzIDExLjYxNmEuNTQ1LjU0NSAwIDEgMC0uNzcyLjc3MmwxLjE1NyAxLjE1NmEuNTQzLjU0MyAwIDAgMCAuNzcxIDAgLjU0NS41NDUgMCAwIDAgMC0uNzdsLTEuMTU2LTEuMTU4ek0xMi41MzcgOS44MkgxMC45YS41NDYuNTQ2IDAgMCAwIDAgMS4wOTFoMS42MzdhLjU0Ni41NDYgMCAwIDAgMC0xLjA5ek00LjkxIDMuNTQ3YS41NDYuNTQ2IDAgMCAwIC41NDUtLjU0NVYxLjM2NmEuNTQ2LjU0NiAwIDAgMC0xLjA5IDB2MS42MzZjMCAuMzAxLjI0NC41NDUuNTQ1LjU0NXpNMi44ODggMy45MzNhLjU0My41NDMgMCAwIDAgLjc3MSAwIC41NDUuNTQ1IDAgMCAwIDAtLjc3MUwyLjUwMiAyLjAwNWEuNTQ1LjU0NSAwIDEgMC0uNzcxLjc3bDEuMTU3IDEuMTU4ek0xLjYyOCA1LjczaDEuNjM2YS41NDYuNTQ2IDAgMCAwIDAtMS4wOTJIMS42MjhhLjU0Ni41NDYgMCAwIDAgMCAxLjA5MXoiLz48L2c+PC9zdmc+",
                        className: void 0,
                        title: void 0
                      },
                      linkCallback: void 0
                    },
                    emoji: {
                      icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTciIHZpZXdCb3g9IjE1LjcyOSAyMi4wODIgMTcgMTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTI5LjcwOCAyNS4xMDRjLTMuMDIxLTMuMDIyLTcuOTM3LTMuMDIyLTEwLjk1OCAwLTMuMDIxIDMuMDItMy4wMiA3LjkzNiAwIDEwLjk1OCAzLjAyMSAzLjAyIDcuOTM3IDMuMDIgMTAuOTU4LS4wMDEgMy4wMi0zLjAyMSAzLjAyLTcuOTM2IDAtMTAuOTU3em0tLjg0NSAxMC4xMTJhNi41NiA2LjU2IDAgMCAxLTkuMjY4IDAgNi41NiA2LjU2IDAgMCAxIDAtOS4yNjcgNi41NiA2LjU2IDAgMCAxIDkuMjY4IDAgNi41NiA2LjU2IDAgMCAxIDAgOS4yNjd6bS03LjUyNC02LjczYS45MDYuOTA2IDAgMSAxIDEuODExIDAgLjkwNi45MDYgMCAwIDEtMS44MTEgMHptNC4xMDYgMGEuOTA2LjkwNiAwIDEgMSAxLjgxMiAwIC45MDYuOTA2IDAgMCAxLTEuODEyIDB6bTIuMTQxIDMuNzA4Yy0uNTYxIDEuMjk4LTEuODc1IDIuMTM3LTMuMzQ4IDIuMTM3LTEuNTA1IDAtMi44MjctLjg0My0zLjM2OS0yLjE0N2EuNDM4LjQzOCAwIDAgMSAuODEtLjMzNmMuNDA1Ljk3NiAxLjQxIDEuNjA3IDIuNTU5IDEuNjA3IDEuMTIzIDAgMi4xMjEtLjYzMSAyLjU0NC0xLjYwOGEuNDM4LjQzOCAwIDAgMSAuODA0LjM0N3oiLz48L3N2Zz4=",
                      className: void 0,
                      component: void 0,
                      popupClassName: void 0,
                      emojis: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                      title: void 0
                    },
                    embedded: {
                      icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuNzA4IDYuNjE1YS40MzYuNDM2IDAgMCAwLS41NDMuMjkxbC0xLjgzIDYuMDQ1YS40MzYuNDM2IDAgMCAwIC44MzMuMjUyTDcgNy4xNmEuNDM2LjQzNiAwIDAgMC0uMjktLjU0NHpNOC45MzEgNi42MTVhLjQzNi40MzYgMCAwIDAtLjU0My4yOTFsLTEuODMgNi4wNDVhLjQzNi40MzYgMCAwIDAgLjgzNC4yNTJsMS44My02LjA0NGEuNDM2LjQzNiAwIDAgMC0uMjktLjU0NHoiLz48cGF0aCBkPSJNMTYuNTY0IDBILjQzNkEuNDM2LjQzNiAwIDAgMCAwIC40MzZ2MTYuMTI4YzAgLjI0LjE5NS40MzYuNDM2LjQzNmgxNi4xMjhjLjI0IDAgLjQzNi0uMTk1LjQzNi0uNDM2Vi40MzZBLjQzNi40MzYgMCAwIDAgMTYuNTY0IDB6TTMuNDg3Ljg3MmgxMC4wMjZ2MS43NDNIMy40ODdWLjg3MnptLTIuNjE1IDBoMS43NDN2MS43NDNILjg3MlYuODcyem0xNS4yNTYgMTUuMjU2SC44NzJWMy40ODhoMTUuMjU2djEyLjY0em0wLTEzLjUxM2gtMS43NDNWLjg3MmgxLjc0M3YxLjc0M3oiLz48Y2lyY2xlIGN4PSI5My44NjciIGN5PSIyNDUuMDY0IiByPSIxMy4xMjgiIHRyYW5zZm9ybT0ibWF0cml4KC4wMzMyIDAgMCAuMDMzMiAwIDApIi8+PGNpcmNsZSBjeD0iOTMuODY3IiBjeT0iMzYwLjU5MiIgcj0iMTMuMTI4IiB0cmFuc2Zvcm09Im1hdHJpeCguMDMzMiAwIDAgLjAzMzIgMCAwKSIvPjxwYXRoIGQ9Ik0xNC4yNTQgMTIuNjQxSDEwLjJhLjQzNi40MzYgMCAwIDAgMCAuODcyaDQuMDU0YS40MzYuNDM2IDAgMCAwIDAtLjg3MnoiLz48L3N2Zz4=",
                      className: void 0,
                      component: void 0,
                      popupClassName: void 0,
                      embedCallback: void 0,
                      defaultSize: {
                        height: "auto",
                        width: "auto"
                      },
                      title: void 0
                    },
                    image: {
                      icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuNzQxIDBILjI2Qy4xMTYgMCAwIC4xMzYgMCAuMzA0djEzLjM5MmMwIC4xNjguMTE2LjMwNC4yNTkuMzA0SDE0Ljc0Yy4xNDMgMCAuMjU5LS4xMzYuMjU5LS4zMDRWLjMwNEMxNSAuMTM2IDE0Ljg4NCAwIDE0Ljc0MSAwem0tLjI1OCAxMy4zOTFILjUxN1YuNjFoMTMuOTY2VjEzLjM5eiIvPjxwYXRoIGQ9Ik00LjEzOCA2LjczOGMuNzk0IDAgMS40NC0uNzYgMS40NC0xLjY5NXMtLjY0Ni0xLjY5NS0xLjQ0LTEuNjk1Yy0uNzk0IDAtMS40NC43Ni0xLjQ0IDEuNjk1IDAgLjkzNC42NDYgMS42OTUgMS40NCAxLjY5NXptMC0yLjc4MWMuNTA5IDAgLjkyMy40ODcuOTIzIDEuMDg2IDAgLjU5OC0uNDE0IDEuMDg2LS45MjMgMS4wODYtLjUwOSAwLS45MjMtLjQ4Ny0uOTIzLTEuMDg2IDAtLjU5OS40MTQtMS4wODYuOTIzLTEuMDg2ek0xLjgxIDEyLjE3NGMuMDYgMCAuMTIyLS4wMjUuMTcxLS4wNzZMNi4yIDcuNzI4bDIuNjY0IDMuMTM0YS4yMzIuMjMyIDAgMCAwIC4zNjYgMCAuMzQzLjM0MyAwIDAgMCAwLS40M0w3Ljk4NyA4Ljk2OWwyLjM3NC0zLjA2IDIuOTEyIDMuMTQyYy4xMDYuMTEzLjI3LjEwNS4zNjYtLjAyYS4zNDMuMzQzIDAgMCAwLS4wMTYtLjQzbC0zLjEwNC0zLjM0N2EuMjQ0LjI0NCAwIDAgMC0uMTg2LS4wOC4yNDUuMjQ1IDAgMCAwLS4xOC4xTDcuNjIyIDguNTM3IDYuMzk0IDcuMDk0YS4yMzIuMjMyIDAgMCAwLS4zNTQtLjAxM2wtNC40IDQuNTZhLjM0My4zNDMgMCAwIDAtLjAyNC40My4yNDMuMjQzIDAgMCAwIC4xOTQuMTAzeiIvPjwvZz48L3N2Zz4=",
                      className: void 0,
                      component: void 0,
                      popupClassName: void 0,
                      urlEnabled: true,
                      uploadEnabled: true,
                      previewImage: false,
                      alignmentEnabled: true,
                      uploadCallback: void 0,
                      inputAccept: "image/gif,image/jpeg,image/jpg,image/png,image/svg",
                      alt: {
                        present: false,
                        mandatory: false
                      },
                      defaultSize: {
                        height: "auto",
                        width: "auto"
                      },
                      title: void 0
                    },
                    remove: {
                      icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNSIgaGVpZ2h0PSIxNSIgdmlld0JveD0iMCAwIDE2IDE2Ij48cGF0aCBkPSJNOC4xIDE0bDYuNC03LjJjLjYtLjcuNi0xLjgtLjEtMi41bC0yLjctMi43Yy0uMy0uNC0uOC0uNi0xLjMtLjZIOC42Yy0uNSAwLTEgLjItMS40LjZMLjUgOS4yYy0uNi43LS42IDEuOS4xIDIuNWwyLjcgMi43Yy4zLjQuOC42IDEuMy42SDE2di0xSDguMXptLTEuMy0uMXMwLS4xIDAgMGwtMi43LTIuN2MtLjQtLjQtLjQtLjkgMC0xLjNMNy41IDZoLTFsLTMgMy4zYy0uNi43LS42IDEuNy4xIDIuNEw1LjkgMTRINC42Yy0uMiAwLS40LS4xLS42LS4yTDEuMiAxMWMtLjMtLjMtLjMtLjggMC0xLjFMNC43IDZoMS44TDEwIDJoMUw3LjUgNmwzLjEgMy43LTMuNSA0Yy0uMS4xLS4yLjEtLjMuMnoiLz48L3N2Zz4=",
                      className: void 0,
                      component: void 0,
                      title: void 0
                    },
                    history: {
                      inDropdown: false,
                      className: void 0,
                      component: void 0,
                      dropdownClassName: void 0,
                      options: ["undo", "redo"],
                      undo: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTcgMTQuODc1YzIuNjcyIDAgNC44NDYtMi4xNDUgNC44NDYtNC43ODEgMC0yLjYzNy0yLjE3NC00Ljc4MS00Ljg0Ni00Ljc4MVY4LjVMMS42MTUgNC4yNSA3IDB2My4xODhjMy44NiAwIDcgMy4wOTggNyA2LjkwNlMxMC44NiAxNyA3IDE3cy03LTMuMDk4LTctNi45MDZoMi4xNTRjMCAyLjYzNiAyLjE3NCA0Ljc4MSA0Ljg0NiA0Ljc4MXoiIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==",
                        className: void 0,
                        title: void 0
                      },
                      redo: {
                        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuNTA0IDEzLjk3N2E0LjQ5NyA0LjQ5NyAwIDAgMS00LjQ5Mi00LjQ5MiA0LjQ5NyA0LjQ5NyAwIDAgMSA0LjQ5Mi00LjQ5M3YyLjk5NWw0Ljk5LTMuOTkzTDYuNTA0IDB2Mi45OTVhNi40OTYgNi40OTYgMCAwIDAtNi40ODggNi40OWMwIDMuNTc4IDIuOTEgNi40OSA2LjQ4OCA2LjQ5YTYuNDk2IDYuNDk2IDAgMCAwIDYuNDg3LTYuNDloLTEuOTk2YTQuNDk3IDQuNDk3IDAgMCAxLTQuNDkxIDQuNDkyeiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9zdmc+",
                        className: void 0,
                        title: void 0
                      },
                      title: void 0
                    }
                  },
                  Jo = {
                    en: {
                      "generic.add": "Add",
                      "generic.cancel": "Cancel",
                      "components.controls.blocktype.h1": "H1",
                      "components.controls.blocktype.h2": "H2",
                      "components.controls.blocktype.h3": "H3",
                      "components.controls.blocktype.h4": "H4",
                      "components.controls.blocktype.h5": "H5",
                      "components.controls.blocktype.h6": "H6",
                      "components.controls.blocktype.blockquote": "Blockquote",
                      "components.controls.blocktype.code": "Code",
                      "components.controls.blocktype.blocktype": "Block Type",
                      "components.controls.blocktype.normal": "Normal",
                      "components.controls.colorpicker.colorpicker": "Color Picker",
                      "components.controls.colorpicker.text": "Text",
                      "components.controls.colorpicker.background": "Highlight",
                      "components.controls.embedded.embedded": "Embedded",
                      "components.controls.embedded.embeddedlink": "Embedded Link",
                      "components.controls.embedded.enterlink": "Enter link",
                      "components.controls.emoji.emoji": "Emoji",
                      "components.controls.fontfamily.fontfamily": "Font",
                      "components.controls.fontsize.fontsize": "Font Size",
                      "components.controls.history.history": "History",
                      "components.controls.history.undo": "Undo",
                      "components.controls.history.redo": "Redo",
                      "components.controls.image.image": "Image",
                      "components.controls.image.fileUpload": "File Upload",
                      "components.controls.image.byURL": "URL",
                      "components.controls.image.dropFileText": "Drop the file or click to upload",
                      "components.controls.inline.bold": "Bold",
                      "components.controls.inline.italic": "Italic",
                      "components.controls.inline.underline": "Underline",
                      "components.controls.inline.strikethrough": "Strikethrough",
                      "components.controls.inline.monospace": "Monospace",
                      "components.controls.inline.superscript": "Superscript",
                      "components.controls.inline.subscript": "Subscript",
                      "components.controls.link.linkTitle": "Link Title",
                      "components.controls.link.linkTarget": "Link Target",
                      "components.controls.link.linkTargetOption": "Open link in new window",
                      "components.controls.link.link": "Link",
                      "components.controls.link.unlink": "Unlink",
                      "components.controls.list.list": "List",
                      "components.controls.list.unordered": "Unordered",
                      "components.controls.list.ordered": "Ordered",
                      "components.controls.list.indent": "Indent",
                      "components.controls.list.outdent": "Outdent",
                      "components.controls.remove.remove": "Remove",
                      "components.controls.textalign.textalign": "Text Align",
                      "components.controls.textalign.left": "Left",
                      "components.controls.textalign.center": "Center",
                      "components.controls.textalign.right": "Right",
                      "components.controls.textalign.justify": "Justify"
                    },
                    fr: {
                      "generic.add": "Ok",
                      "generic.cancel": "Annuler",
                      "components.controls.blocktype.h1": "Titre 1",
                      "components.controls.blocktype.h2": "Titre 2",
                      "components.controls.blocktype.h3": "Titre 3",
                      "components.controls.blocktype.h4": "Titre 4",
                      "components.controls.blocktype.h5": "Titre 5",
                      "components.controls.blocktype.h6": "Titre 6",
                      "components.controls.blocktype.blockquote": "Citation",
                      "components.controls.blocktype.code": "Code",
                      "components.controls.blocktype.blocktype": "Type bloc",
                      "components.controls.blocktype.normal": "Normal",
                      "components.controls.colorpicker.colorpicker": "Palette de couleur",
                      "components.controls.colorpicker.text": "Texte",
                      "components.controls.colorpicker.background": "Fond",
                      "components.controls.embedded.embedded": "Embedded",
                      "components.controls.embedded.embeddedlink": "Lien iFrame",
                      "components.controls.embedded.enterlink": "Entrer le lien",
                      "components.controls.emoji.emoji": "Emoji",
                      "components.controls.fontfamily.fontfamily": "Police",
                      "components.controls.fontsize.fontsize": "Taille de police",
                      "components.controls.history.history": "Historique",
                      "components.controls.history.undo": "Prcdent",
                      "components.controls.history.redo": "Suivant",
                      "components.controls.image.image": "Image",
                      "components.controls.image.fileUpload": "Tlchargement",
                      "components.controls.image.byURL": "URL",
                      "components.controls.image.dropFileText": "Glisser une image ou cliquer pour tlcharger",
                      "components.controls.inline.bold": "Gras",
                      "components.controls.inline.italic": "Italique",
                      "components.controls.inline.underline": "Souligner",
                      "components.controls.inline.strikethrough": "Barrer",
                      "components.controls.inline.monospace": "Monospace",
                      "components.controls.inline.superscript": "Exposant",
                      "components.controls.inline.subscript": "Indice",
                      "components.controls.link.linkTitle": "Titre du lien",
                      "components.controls.link.linkTarget": "Cible du lien",
                      "components.controls.link.linkTargetOption": "Ouvrir le lien dans une nouvelle fentre",
                      "components.controls.link.link": "Lier",
                      "components.controls.link.unlink": "Dlier",
                      "components.controls.list.list": "Liste",
                      "components.controls.list.unordered": "Dsordonne",
                      "components.controls.list.ordered": "Ordonne",
                      "components.controls.list.indent": "Augmenter le retrait",
                      "components.controls.list.outdent": "Diminuer le retrait",
                      "components.controls.remove.remove": "Supprimer",
                      "components.controls.textalign.textalign": "Alignement du texte",
                      "components.controls.textalign.left": "Gauche",
                      "components.controls.textalign.center": "Centre",
                      "components.controls.textalign.right": "Droite",
                      "components.controls.textalign.justify": "Justifier"
                    },
                    zh: {
                      "generic.add": "",
                      "generic.cancel": "",
                      "components.controls.blocktype.h1": "1",
                      "components.controls.blocktype.h2": "2",
                      "components.controls.blocktype.h3": "3",
                      "components.controls.blocktype.h4": "4",
                      "components.controls.blocktype.h5": "5",
                      "components.controls.blocktype.h6": "6",
                      "components.controls.blocktype.blockquote": "",
                      "components.controls.blocktype.code": "",
                      "components.controls.blocktype.blocktype": "",
                      "components.controls.blocktype.normal": "",
                      "components.controls.colorpicker.colorpicker": "",
                      "components.controls.colorpicker.text": "",
                      "components.controls.colorpicker.background": "",
                      "components.controls.embedded.embedded": "",
                      "components.controls.embedded.embeddedlink": "",
                      "components.controls.embedded.enterlink": "",
                      "components.controls.emoji.emoji": "",
                      "components.controls.fontfamily.fontfamily": "",
                      "components.controls.fontsize.fontsize": "",
                      "components.controls.history.history": "",
                      "components.controls.history.undo": "",
                      "components.controls.history.redo": "",
                      "components.controls.image.image": "",
                      "components.controls.image.fileUpload": "",
                      "components.controls.image.byURL": "",
                      "components.controls.image.dropFileText": "",
                      "components.controls.inline.bold": "",
                      "components.controls.inline.italic": "",
                      "components.controls.inline.underline": "",
                      "components.controls.inline.strikethrough": "",
                      "components.controls.inline.monospace": "",
                      "components.controls.inline.superscript": "",
                      "components.controls.inline.subscript": "",
                      "components.controls.link.linkTitle": "",
                      "components.controls.link.linkTarget": "",
                      "components.controls.link.linkTargetOption": "",
                      "components.controls.link.link": "",
                      "components.controls.link.unlink": "",
                      "components.controls.list.list": "",
                      "components.controls.list.unordered": "",
                      "components.controls.list.ordered": "",
                      "components.controls.list.indent": "",
                      "components.controls.list.outdent": "",
                      "components.controls.remove.remove": "",
                      "components.controls.textalign.textalign": "",
                      "components.controls.textalign.left": "",
                      "components.controls.textalign.center": "",
                      "components.controls.textalign.right": "",
                      "components.controls.textalign.justify": ""
                    },
                    ru: {
                      "generic.add": "",
                      "generic.cancel": "",
                      "components.controls.blocktype.h1": " 1",
                      "components.controls.blocktype.h2": " 2",
                      "components.controls.blocktype.h3": " 3",
                      "components.controls.blocktype.h4": " 4",
                      "components.controls.blocktype.h5": " 5",
                      "components.controls.blocktype.h6": " 6",
                      "components.controls.blocktype.blockquote": "",
                      "components.controls.blocktype.code": "",
                      "components.controls.blocktype.blocktype": "",
                      "components.controls.blocktype.normal": "",
                      "components.controls.colorpicker.colorpicker": " ",
                      "components.controls.colorpicker.text": "",
                      "components.controls.colorpicker.background": "",
                      "components.controls.embedded.embedded": "",
                      "components.controls.embedded.embeddedlink": "  iFrame",
                      "components.controls.embedded.enterlink": " ",
                      "components.controls.emoji.emoji": "",
                      "components.controls.fontfamily.fontfamily": "",
                      "components.controls.fontsize.fontsize": " ",
                      "components.controls.history.history": "",
                      "components.controls.history.undo": "",
                      "components.controls.history.redo": "",
                      "components.controls.image.image": "",
                      "components.controls.image.fileUpload": "",
                      "components.controls.image.byURL": "URL",
                      "components.controls.image.dropFileText": "        ",
                      "components.controls.inline.bold": "",
                      "components.controls.inline.italic": "",
                      "components.controls.inline.underline": "",
                      "components.controls.inline.strikethrough": "",
                      "components.controls.inline.monospace": "Monospace",
                      "components.controls.inline.superscript": " ",
                      "components.controls.inline.subscript": " ",
                      "components.controls.link.linkTitle": "",
                      "components.controls.link.linkTarget": " ",
                      "components.controls.link.linkTargetOption": "   ",
                      "components.controls.link.link": "",
                      "components.controls.link.unlink": " ",
                      "components.controls.list.list": "",
                      "components.controls.list.unordered": "",
                      "components.controls.list.ordered": "",
                      "components.controls.list.indent": "",
                      "components.controls.list.outdent": "",
                      "components.controls.remove.remove": "",
                      "components.controls.textalign.textalign": " ",
                      "components.controls.textalign.left": "",
                      "components.controls.textalign.center": " ",
                      "components.controls.textalign.right": "",
                      "components.controls.textalign.justify": ""
                    },
                    pt: {
                      "generic.add": "Ok",
                      "generic.cancel": "Cancelar",
                      "components.controls.blocktype.h1": "Ttulo 1",
                      "components.controls.blocktype.h2": "Ttulo 2",
                      "components.controls.blocktype.h3": "Ttulo 3",
                      "components.controls.blocktype.h4": "Ttulo 4",
                      "components.controls.blocktype.h5": "Ttulo 5",
                      "components.controls.blocktype.h6": "Ttulo 6",
                      "components.controls.blocktype.blockquote": "Citao",
                      "components.controls.blocktype.code": "Code",
                      "components.controls.blocktype.blocktype": "Estilo",
                      "components.controls.blocktype.normal": "Normal",
                      "components.controls.colorpicker.colorpicker": "Paleta de cores",
                      "components.controls.colorpicker.text": "Texto",
                      "components.controls.colorpicker.background": "Fundo",
                      "components.controls.embedded.embedded": "Embarcado",
                      "components.controls.embedded.embeddedlink": "Link embarcado",
                      "components.controls.embedded.enterlink": "Coloque o link",
                      "components.controls.emoji.emoji": "Emoji",
                      "components.controls.fontfamily.fontfamily": "Fonte",
                      "components.controls.fontsize.fontsize": "Tamanho da Fonte",
                      "components.controls.history.history": "Histrico",
                      "components.controls.history.undo": "Desfazer",
                      "components.controls.history.redo": "Refazer",
                      "components.controls.image.image": "Imagem",
                      "components.controls.image.fileUpload": "Carregar arquivo",
                      "components.controls.image.byURL": "URL",
                      "components.controls.image.dropFileText": "Arraste uma imagem aqui ou clique para carregar",
                      "components.controls.inline.bold": "Negrito",
                      "components.controls.inline.italic": "Itlico",
                      "components.controls.inline.underline": "Sublinhado",
                      "components.controls.inline.strikethrough": "Strikethrough",
                      "components.controls.inline.monospace": "Monospace",
                      "components.controls.inline.superscript": "Sobrescrito",
                      "components.controls.inline.subscript": "Subscrito",
                      "components.controls.link.linkTitle": "Ttulo do link",
                      "components.controls.link.linkTarget": "Alvo do link",
                      "components.controls.link.linkTargetOption": "Abrir link em outra janela",
                      "components.controls.link.link": "Adicionar Link",
                      "components.controls.link.unlink": "Remover link",
                      "components.controls.list.list": "Lista",
                      "components.controls.list.unordered": "Sem ordeno",
                      "components.controls.list.ordered": "Ordenada",
                      "components.controls.list.indent": "Aumentar recuo",
                      "components.controls.list.outdent": "Diminuir recuo",
                      "components.controls.remove.remove": "Remover",
                      "components.controls.textalign.textalign": "Alinhamento do texto",
                      "components.controls.textalign.left": " Esquerda",
                      "components.controls.textalign.center": "Centralizado",
                      "components.controls.textalign.right": " Direita",
                      "components.controls.textalign.justify": "Justificado"
                    },
                    ko: {
                      "generic.add": "",
                      "generic.cancel": "",
                      "components.controls.blocktype.h1": "1",
                      "components.controls.blocktype.h2": "2",
                      "components.controls.blocktype.h3": "3",
                      "components.controls.blocktype.h4": "4",
                      "components.controls.blocktype.h5": "5",
                      "components.controls.blocktype.h6": "6",
                      "components.controls.blocktype.blockquote": "",
                      "components.controls.blocktype.code": "Code",
                      "components.controls.blocktype.blocktype": "",
                      "components.controls.blocktype.normal": "",
                      "components.controls.colorpicker.colorpicker": " ",
                      "components.controls.colorpicker.text": "",
                      "components.controls.colorpicker.background": "",
                      "components.controls.embedded.embedded": "",
                      "components.controls.embedded.embeddedlink": " ",
                      "components.controls.embedded.enterlink": " ",
                      "components.controls.emoji.emoji": "",
                      "components.controls.fontfamily.fontfamily": "",
                      "components.controls.fontsize.fontsize": " ",
                      "components.controls.history.history": "",
                      "components.controls.history.undo": " ",
                      "components.controls.history.redo": " ",
                      "components.controls.image.image": "",
                      "components.controls.image.fileUpload": " ",
                      "components.controls.image.byURL": "",
                      "components.controls.image.dropFileText": "   ",
                      "components.controls.inline.bold": "",
                      "components.controls.inline.italic": "",
                      "components.controls.inline.underline": "",
                      "components.controls.inline.strikethrough": "",
                      "components.controls.inline.monospace": " ",
                      "components.controls.inline.superscript": " ",
                      "components.controls.inline.subscript": " ",
                      "components.controls.link.linkTitle": " ",
                      "components.controls.link.linkTarget": " ",
                      "components.controls.link.linkTargetOption": " ",
                      "components.controls.link.link": "",
                      "components.controls.link.unlink": " ",
                      "components.controls.list.list": "",
                      "components.controls.list.unordered": " ",
                      "components.controls.list.ordered": " ",
                      "components.controls.list.indent": "",
                      "components.controls.list.outdent": "",
                      "components.controls.remove.remove": "",
                      "components.controls.textalign.textalign": " ",
                      "components.controls.textalign.left": "",
                      "components.controls.textalign.center": "",
                      "components.controls.textalign.right": "",
                      "components.controls.textalign.justify": ""
                    },
                    it: {
                      "generic.add": "Aggiungi",
                      "generic.cancel": "Annulla",
                      "components.controls.blocktype.h1": "H1",
                      "components.controls.blocktype.h2": "H2",
                      "components.controls.blocktype.h3": "H3",
                      "components.controls.blocktype.h4": "H4",
                      "components.controls.blocktype.h5": "H5",
                      "components.controls.blocktype.h6": "H6",
                      "components.controls.blocktype.blockquote": "Citazione",
                      "components.controls.blocktype.code": "Codice",
                      "components.controls.blocktype.blocktype": "Stili",
                      "components.controls.blocktype.normal": "Normale",
                      "components.controls.colorpicker.colorpicker": "Colore testo",
                      "components.controls.colorpicker.text": "Testo",
                      "components.controls.colorpicker.background": "Evidenziazione",
                      "components.controls.embedded.embedded": "Incorpora",
                      "components.controls.embedded.embeddedlink": "Incorpora link",
                      "components.controls.embedded.enterlink": "Inserisci link",
                      "components.controls.emoji.emoji": "Emoji",
                      "components.controls.fontfamily.fontfamily": "Carattere",
                      "components.controls.fontsize.fontsize": "Dimensione carattere",
                      "components.controls.history.history": "Modifiche",
                      "components.controls.history.undo": "Annulla",
                      "components.controls.history.redo": "Ripristina",
                      "components.controls.image.image": "Immagine",
                      "components.controls.image.fileUpload": "Carica immagine",
                      "components.controls.image.byURL": "URL",
                      "components.controls.image.dropFileText": "Trascina il file o clicca per caricare",
                      "components.controls.inline.bold": "Grassetto",
                      "components.controls.inline.italic": "Corsivo",
                      "components.controls.inline.underline": "Sottolineato",
                      "components.controls.inline.strikethrough": "Barrato",
                      "components.controls.inline.monospace": "Monospace",
                      "components.controls.inline.superscript": "Apice",
                      "components.controls.inline.subscript": "Pedice",
                      "components.controls.link.linkTitle": "Testo",
                      "components.controls.link.linkTarget": "Link",
                      "components.controls.link.linkTargetOption": "Apri link in una nuova finestra",
                      "components.controls.link.link": "Inserisci link",
                      "components.controls.link.unlink": "Rimuovi link",
                      "components.controls.list.list": "Lista",
                      "components.controls.list.unordered": "Elenco puntato",
                      "components.controls.list.ordered": "Elenco numerato",
                      "components.controls.list.indent": "Indent",
                      "components.controls.list.outdent": "Outdent",
                      "components.controls.remove.remove": "Rimuovi formattazione",
                      "components.controls.textalign.textalign": "Allineamento del testo",
                      "components.controls.textalign.left": "Allinea a sinistra",
                      "components.controls.textalign.center": "Allinea al centro",
                      "components.controls.textalign.right": "Allinea a destra",
                      "components.controls.textalign.justify": "Giustifica"
                    },
                    nl: {
                      "generic.add": "Toevoegen",
                      "generic.cancel": "Annuleren",
                      "components.controls.blocktype.h1": "H1",
                      "components.controls.blocktype.h2": "H2",
                      "components.controls.blocktype.h3": "H3",
                      "components.controls.blocktype.h4": "H4",
                      "components.controls.blocktype.h5": "H5",
                      "components.controls.blocktype.h6": "H6",
                      "components.controls.blocktype.blockquote": "Blockquote",
                      "components.controls.blocktype.code": "Code",
                      "components.controls.blocktype.blocktype": "Blocktype",
                      "components.controls.blocktype.normal": "Normaal",
                      "components.controls.colorpicker.colorpicker": "Kleurkiezer",
                      "components.controls.colorpicker.text": "Tekst",
                      "components.controls.colorpicker.background": "Achtergrond",
                      "components.controls.embedded.embedded": "Ingevoegd",
                      "components.controls.embedded.embeddedlink": "Ingevoegde link",
                      "components.controls.embedded.enterlink": "Voeg link toe",
                      "components.controls.emoji.emoji": "Emoji",
                      "components.controls.fontfamily.fontfamily": "Lettertype",
                      "components.controls.fontsize.fontsize": "Lettergrootte",
                      "components.controls.history.history": "Geschiedenis",
                      "components.controls.history.undo": "Ongedaan maken",
                      "components.controls.history.redo": "Opnieuw",
                      "components.controls.image.image": "Afbeelding",
                      "components.controls.image.fileUpload": "Bestand uploaden",
                      "components.controls.image.byURL": "URL",
                      "components.controls.image.dropFileText": "Drop het bestand hier of klik om te uploaden",
                      "components.controls.inline.bold": "Dikgedrukt",
                      "components.controls.inline.italic": "Schuingedrukt",
                      "components.controls.inline.underline": "Onderstrepen",
                      "components.controls.inline.strikethrough": "Doorstrepen",
                      "components.controls.inline.monospace": "Monospace",
                      "components.controls.inline.superscript": "Superscript",
                      "components.controls.inline.subscript": "Subscript",
                      "components.controls.link.linkTitle": "Linktitel",
                      "components.controls.link.linkTarget": "Link bestemming",
                      "components.controls.link.linkTargetOption": "Open link in een nieuw venster",
                      "components.controls.link.link": "Link",
                      "components.controls.link.unlink": "Unlink",
                      "components.controls.list.list": "Lijst",
                      "components.controls.list.unordered": "Ongeordend",
                      "components.controls.list.ordered": "Geordend",
                      "components.controls.list.indent": "Inspringen",
                      "components.controls.list.outdent": "Inspringen verkleinen",
                      "components.controls.remove.remove": "Verwijderen",
                      "components.controls.textalign.textalign": "Tekst uitlijnen",
                      "components.controls.textalign.left": "Links",
                      "components.controls.textalign.center": "Gecentreerd",
                      "components.controls.textalign.right": "Rechts",
                      "components.controls.textalign.justify": "Uitgelijnd"
                    },
                    de: {
                      "generic.add": "Hinzufgen",
                      "generic.cancel": "Abbrechen",
                      "components.controls.blocktype.h1": "berschrift 1",
                      "components.controls.blocktype.h2": "berschrift 2",
                      "components.controls.blocktype.h3": "berschrift 3",
                      "components.controls.blocktype.h4": "berschrift 4",
                      "components.controls.blocktype.h5": "berschrift 5",
                      "components.controls.blocktype.h6": "berschrift 6",
                      "components.controls.blocktype.blockquote": "Zitat",
                      "components.controls.blocktype.code": "Quellcode",
                      "components.controls.blocktype.blocktype": "Blocktyp",
                      "components.controls.blocktype.normal": "Normal",
                      "components.controls.colorpicker.colorpicker": "Farbauswahl",
                      "components.controls.colorpicker.text": "Text",
                      "components.controls.colorpicker.background": "Hintergrund",
                      "components.controls.embedded.embedded": "Eingebettet",
                      "components.controls.embedded.embeddedlink": "Eingebetteter Link",
                      "components.controls.embedded.enterlink": "Link eingeben",
                      "components.controls.emoji.emoji": "Emoji",
                      "components.controls.fontfamily.fontfamily": "Schriftart",
                      "components.controls.fontsize.fontsize": "Schriftgre",
                      "components.controls.history.history": "Historie",
                      "components.controls.history.undo": "Zurcknehmen",
                      "components.controls.history.redo": "Wiederholen",
                      "components.controls.image.image": "Bild",
                      "components.controls.image.fileUpload": "Datei-Upload",
                      "components.controls.image.byURL": "URL",
                      "components.controls.image.dropFileText": "Dateien ziehen und ablegen, oder klicken zum Hochladen",
                      "components.controls.inline.bold": "Fett",
                      "components.controls.inline.italic": "Kursiv",
                      "components.controls.inline.underline": "Unterstreichen",
                      "components.controls.inline.strikethrough": "Durchstreichen",
                      "components.controls.inline.monospace": "Monospace",
                      "components.controls.inline.superscript": "Hochgestellt",
                      "components.controls.inline.subscript": "Tiefgestellt",
                      "components.controls.link.linkTitle": "Link-Titel",
                      "components.controls.link.linkTarget": "Link-Ziel",
                      "components.controls.link.linkTargetOption": "Link in neuem Fenster ffnen",
                      "components.controls.link.link": "Link",
                      "components.controls.link.unlink": "Aufheben",
                      "components.controls.list.list": "Liste",
                      "components.controls.list.unordered": "Aufzhlung",
                      "components.controls.list.ordered": "Nummerierte Liste",
                      "components.controls.list.indent": "Einzug vergrern",
                      "components.controls.list.outdent": "Einzug reduzieren",
                      "components.controls.remove.remove": "Entfernen",
                      "components.controls.textalign.textalign": "Textausrichtung",
                      "components.controls.textalign.left": "Linksbndig",
                      "components.controls.textalign.center": "Zentrieren",
                      "components.controls.textalign.right": "Rechtsbndig",
                      "components.controls.textalign.justify": "Blocksatz"
                    },
                    da: {
                      "generic.add": "Tilfj",
                      "generic.cancel": "Annuller",
                      "components.controls.blocktype.h1": "Overskrift 1",
                      "components.controls.blocktype.h2": "Overskrift 2",
                      "components.controls.blocktype.h3": "Overskrift 3",
                      "components.controls.blocktype.h4": "Overskrift 4",
                      "components.controls.blocktype.h5": "Overskrift 5",
                      "components.controls.blocktype.h6": "Overskrift 6",
                      "components.controls.blocktype.blockquote": "Blokcitat",
                      "components.controls.blocktype.code": "Kode",
                      "components.controls.blocktype.blocktype": "Blok Type",
                      "components.controls.blocktype.normal": "Normal",
                      "components.controls.colorpicker.colorpicker": "Farver",
                      "components.controls.colorpicker.text": "Tekst",
                      "components.controls.colorpicker.background": "Baggrund",
                      "components.controls.embedded.embedded": "Indlejre",
                      "components.controls.embedded.embeddedlink": "Indlejre Link",
                      "components.controls.embedded.enterlink": "Indtast link",
                      "components.controls.emoji.emoji": "Emoji",
                      "components.controls.fontfamily.fontfamily": "Fonttype",
                      "components.controls.fontsize.fontsize": "Fontstrrelser",
                      "components.controls.history.history": "Historie",
                      "components.controls.history.undo": "Fortryd",
                      "components.controls.history.redo": "Gendan",
                      "components.controls.image.image": "Billede",
                      "components.controls.image.fileUpload": "Filoverfrsel",
                      "components.controls.image.byURL": "URL",
                      "components.controls.image.dropFileText": "Drop filen eller klik for at uploade",
                      "components.controls.inline.bold": "Fed",
                      "components.controls.inline.italic": "Kursiv",
                      "components.controls.inline.underline": "Understrege",
                      "components.controls.inline.strikethrough": "Gennemstreget",
                      "components.controls.inline.monospace": "Monospace",
                      "components.controls.inline.superscript": "Hvet",
                      "components.controls.inline.subscript": "Snket",
                      "components.controls.link.linkTitle": "Link Titel",
                      "components.controls.link.linkTarget": "Link Ml",
                      "components.controls.link.linkTargetOption": "bn link i nyt vindue",
                      "components.controls.link.link": "Link",
                      "components.controls.link.unlink": "Fjern link",
                      "components.controls.list.list": "Liste",
                      "components.controls.list.unordered": "Uordnet",
                      "components.controls.list.ordered": "Ordnet",
                      "components.controls.list.indent": "Indrykning",
                      "components.controls.list.outdent": "Udrykning",
                      "components.controls.remove.remove": "Fjern",
                      "components.controls.textalign.textalign": "Tekstjustering",
                      "components.controls.textalign.left": "Venstre",
                      "components.controls.textalign.center": "Center",
                      "components.controls.textalign.right": "Hjre",
                      "components.controls.textalign.justify": "Margener"
                    },
                    zh_tw: {
                      "generic.add": "",
                      "generic.cancel": "",
                      "components.controls.blocktype.h1": "1",
                      "components.controls.blocktype.h2": "2",
                      "components.controls.blocktype.h3": "3",
                      "components.controls.blocktype.h4": "4",
                      "components.controls.blocktype.h5": "5",
                      "components.controls.blocktype.h6": "6",
                      "components.controls.blocktype.blockquote": "",
                      "components.controls.blocktype.code": "",
                      "components.controls.blocktype.blocktype": "",
                      "components.controls.blocktype.normal": "",
                      "components.controls.colorpicker.colorpicker": "",
                      "components.controls.colorpicker.text": "",
                      "components.controls.colorpicker.background": "",
                      "components.controls.embedded.embedded": "",
                      "components.controls.embedded.embeddedlink": "",
                      "components.controls.embedded.enterlink": "",
                      "components.controls.emoji.emoji": "",
                      "components.controls.fontfamily.fontfamily": "",
                      "components.controls.fontsize.fontsize": "",
                      "components.controls.history.history": "",
                      "components.controls.history.undo": "",
                      "components.controls.history.redo": "",
                      "components.controls.image.image": "",
                      "components.controls.image.fileUpload": "",
                      "components.controls.image.byURL": "",
                      "components.controls.image.dropFileText": "",
                      "components.controls.inline.bold": "",
                      "components.controls.inline.italic": "",
                      "components.controls.inline.underline": "",
                      "components.controls.inline.strikethrough": "",
                      "components.controls.inline.monospace": "",
                      "components.controls.inline.superscript": "",
                      "components.controls.inline.subscript": "",
                      "components.controls.link.linkTitle": "",
                      "components.controls.link.linkTarget": "",
                      "components.controls.link.linkTargetOption": "",
                      "components.controls.link.link": "",
                      "components.controls.link.unlink": "",
                      "components.controls.list.list": "",
                      "components.controls.list.unordered": "",
                      "components.controls.list.ordered": "",
                      "components.controls.list.indent": "",
                      "components.controls.list.outdent": "",
                      "components.controls.remove.remove": "",
                      "components.controls.textalign.textalign": "",
                      "components.controls.textalign.left": "",
                      "components.controls.textalign.center": "",
                      "components.controls.textalign.right": "",
                      "components.controls.textalign.justify": ""
                    },
                    pl: {
                      "generic.add": "Dodaj",
                      "generic.cancel": "Anuluj",
                      "components.controls.blocktype.h1": "Nagwek 1",
                      "components.controls.blocktype.h2": "Nagwek 2",
                      "components.controls.blocktype.h3": "Nagwek 3",
                      "components.controls.blocktype.h4": "Nagwek 4",
                      "components.controls.blocktype.h5": "Nagwek 5",
                      "components.controls.blocktype.h6": "Nagwek 6",
                      "components.controls.blocktype.blockquote": "Cytat",
                      "components.controls.blocktype.code": "Kod",
                      "components.controls.blocktype.blocktype": "Format",
                      "components.controls.blocktype.normal": "Normalny",
                      "components.controls.colorpicker.colorpicker": "Kolor",
                      "components.controls.colorpicker.text": "Tekst",
                      "components.controls.colorpicker.background": "To",
                      "components.controls.embedded.embedded": "Osad",
                      "components.controls.embedded.embeddedlink": "Osad odnonik",
                      "components.controls.embedded.enterlink": "Wprowad odnonik",
                      "components.controls.emoji.emoji": "Emoji",
                      "components.controls.fontfamily.fontfamily": "Krj czcionki",
                      "components.controls.fontsize.fontsize": "Rozmiar czcionki",
                      "components.controls.history.history": "Historia",
                      "components.controls.history.undo": "Cofnij",
                      "components.controls.history.redo": "Ponw",
                      "components.controls.image.image": "Obrazek",
                      "components.controls.image.fileUpload": "Przelij plik",
                      "components.controls.image.byURL": "URL",
                      "components.controls.image.dropFileText": "Upu plik lub kliknij, aby przesa",
                      "components.controls.inline.bold": "Pogrubienie",
                      "components.controls.inline.italic": "Kursywa",
                      "components.controls.inline.underline": "Podkrelenie",
                      "components.controls.inline.strikethrough": "Przekrelenie",
                      "components.controls.inline.monospace": "Monospace",
                      "components.controls.inline.superscript": "Indeks grny",
                      "components.controls.inline.subscript": "Indeks dolny",
                      "components.controls.link.linkTitle": "Tytu odnonika",
                      "components.controls.link.linkTarget": "Adres odnonika",
                      "components.controls.link.linkTargetOption": "Otwrz odnonik w nowej karcie",
                      "components.controls.link.link": "Wstaw odnonik",
                      "components.controls.link.unlink": "Usu odnonik",
                      "components.controls.list.list": "Lista",
                      "components.controls.list.unordered": "Lista nieuporzdkowana",
                      "components.controls.list.ordered": "Lista uporzdkowana",
                      "components.controls.list.indent": "Zwiksz wcicie",
                      "components.controls.list.outdent": "Zmniejsz wcicie",
                      "components.controls.remove.remove": "Usu",
                      "components.controls.textalign.textalign": "Wyrwnaj tekst",
                      "components.controls.textalign.left": "Do lewej",
                      "components.controls.textalign.center": "Do rodka",
                      "components.controls.textalign.right": "Do prawej",
                      "components.controls.textalign.justify": "Wyjustuj"
                    },
                    es: {
                      "generic.add": "Aadir",
                      "generic.cancel": "Cancelar",
                      "components.controls.blocktype.h1": "H1",
                      "components.controls.blocktype.h2": "H2",
                      "components.controls.blocktype.h3": "H3",
                      "components.controls.blocktype.h4": "H4",
                      "components.controls.blocktype.h5": "H5",
                      "components.controls.blocktype.h6": "H6",
                      "components.controls.blocktype.blockquote": "Blockquote",
                      "components.controls.blocktype.code": "Cdigo",
                      "components.controls.blocktype.blocktype": "Tipo de bloque",
                      "components.controls.blocktype.normal": "Normal",
                      "components.controls.colorpicker.colorpicker": "Seleccionar color",
                      "components.controls.colorpicker.text": "Texto",
                      "components.controls.colorpicker.background": "Subrayado",
                      "components.controls.embedded.embedded": "Adjuntar",
                      "components.controls.embedded.embeddedlink": "Adjuntar Link",
                      "components.controls.embedded.enterlink": "Introducir link",
                      "components.controls.emoji.emoji": "Emoji",
                      "components.controls.fontfamily.fontfamily": "Fuente",
                      "components.controls.fontsize.fontsize": "Tamao de fuente",
                      "components.controls.history.history": "Histrico",
                      "components.controls.history.undo": "Deshacer",
                      "components.controls.history.redo": "Rehacer",
                      "components.controls.image.image": "Imagen",
                      "components.controls.image.fileUpload": "Subir archivo",
                      "components.controls.image.byURL": "URL",
                      "components.controls.image.dropFileText": "Arrastra el archivo o haz click para subirlo",
                      "components.controls.inline.bold": "Negrita",
                      "components.controls.inline.italic": "Cursiva",
                      "components.controls.inline.underline": "Subrayado",
                      "components.controls.inline.strikethrough": "Tachado",
                      "components.controls.inline.monospace": "Monospace",
                      "components.controls.inline.superscript": "Sobrendice",
                      "components.controls.inline.subscript": "Subndice",
                      "components.controls.link.linkTitle": "Ttulo del enlace",
                      "components.controls.link.linkTarget": "Objetivo del enlace",
                      "components.controls.link.linkTargetOption": "Abrir en nueva ventana",
                      "components.controls.link.link": "Enlazar",
                      "components.controls.link.unlink": "Desenlazar",
                      "components.controls.list.list": "Lista",
                      "components.controls.list.unordered": "Desordenada",
                      "components.controls.list.ordered": "Ordenada",
                      "components.controls.list.indent": "Indentada",
                      "components.controls.list.outdent": "Dentada",
                      "components.controls.remove.remove": "Eliminar",
                      "components.controls.textalign.textalign": "Alineacin del texto",
                      "components.controls.textalign.left": "Izquierda",
                      "components.controls.textalign.center": "Centrado",
                      "components.controls.textalign.right": "Derecha",
                      "components.controls.textalign.justify": "Justificado"
                    },
                    ja: {
                      "generic.add": "",
                      "generic.cancel": "",
                      "components.controls.blocktype.h1": "1",
                      "components.controls.blocktype.h2": "2",
                      "components.controls.blocktype.h3": "3",
                      "components.controls.blocktype.h4": "4",
                      "components.controls.blocktype.h5": "5",
                      "components.controls.blocktype.h6": "6",
                      "components.controls.blocktype.blockquote": "",
                      "components.controls.blocktype.code": "",
                      "components.controls.blocktype.blocktype": "",
                      "components.controls.blocktype.normal": "",
                      "components.controls.colorpicker.colorpicker": "",
                      "components.controls.colorpicker.text": "",
                      "components.controls.colorpicker.background": "",
                      "components.controls.embedded.embedded": "",
                      "components.controls.embedded.embeddedlink": "",
                      "components.controls.embedded.enterlink": "",
                      "components.controls.emoji.emoji": "",
                      "components.controls.fontfamily.fontfamily": "",
                      "components.controls.fontsize.fontsize": "",
                      "components.controls.history.history": "",
                      "components.controls.history.undo": "",
                      "components.controls.history.redo": "",
                      "components.controls.image.image": "",
                      "components.controls.image.fileUpload": "",
                      "components.controls.image.byURL": "URL",
                      "components.controls.image.dropFileText": "",
                      "components.controls.inline.bold": "",
                      "components.controls.inline.italic": "",
                      "components.controls.inline.underline": "",
                      "components.controls.inline.strikethrough": "",
                      "components.controls.inline.monospace": "",
                      "components.controls.inline.superscript": "",
                      "components.controls.inline.subscript": "",
                      "components.controls.link.linkTitle": "",
                      "components.controls.link.linkTarget": "",
                      "components.controls.link.linkTargetOption": "",
                      "components.controls.link.link": "",
                      "components.controls.link.unlink": "",
                      "components.controls.list.list": "",
                      "components.controls.list.unordered": "",
                      "components.controls.list.ordered": "",
                      "components.controls.list.indent": "",
                      "components.controls.list.outdent": "",
                      "components.controls.remove.remove": "",
                      "components.controls.textalign.textalign": "",
                      "components.controls.textalign.left": "",
                      "components.controls.textalign.center": "",
                      "components.controls.textalign.right": "",
                      "components.controls.textalign.justify": ""
                    }
                  };
                n(38), n(39);
                function Vo(t) {
                  return (Vo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t;
                  } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                  })(t);
                }
                function qo() {
                  return (qo = Object.assign ? Object.assign.bind() : function (t) {
                    for (var e = 1; e < arguments.length; e++) {
                      var n = arguments[e];
                      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
                    }
                    return t;
                  }).apply(this, arguments);
                }
                function Ko(e, t) {
                  var n = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    t && (o = o.filter(function (t) {
                      return Object.getOwnPropertyDescriptor(e, t).enumerable;
                    })), n.push.apply(n, o);
                  }
                  return n;
                }
                function Xo(e) {
                  for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Ko(Object(n), true).forEach(function (t) {
                      $o(e, t, n[t]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ko(Object(n)).forEach(function (t) {
                      Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                  }
                  return e;
                }
                function $o(t, e, n) {
                  return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  }) : t[e] = n, t;
                }
                function tr(t) {
                  return function (t) {
                    if (Array.isArray(t)) return er(t);
                  }(t) || function (t) {
                    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
                  }(t) || function (t, e) {
                    if (!t) return;
                    if ("string" == typeof t) return er(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === n && t.constructor && (n = t.constructor.name);
                    if ("Map" === n || "Set" === n) return Array.from(t);
                    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return er(t, e);
                  }(t) || function () {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                  }();
                }
                function er(t, e) {
                  (null == e || e > t.length) && (e = t.length);
                  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
                  return o;
                }
                function nr(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
                  }
                }
                function or(t, e) {
                  return (or = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                    return t.__proto__ = e, t;
                  })(t, e);
                }
                function rr(o) {
                  var r = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
                    } catch (t) {
                      return false;
                    }
                  }();
                  return function () {
                    var t,
                      e = ir(o);
                    if (r) {
                      var n = ir(this).constructor;
                      t = Reflect.construct(e, arguments, n);
                    } else t = e.apply(this, arguments);
                    return function (t, e) {
                      {
                        if (e && ("object" === Vo(e) || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                      }
                      return function (t) {
                        if (void 0 !== t) return t;
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      }(t);
                    }(this, t);
                  };
                }
                function ir(t) {
                  return (ir = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
                }
                var cr = function () {
                  !function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && or(t, e);
                  }(i, f["Component"]);
                  var t,
                    e,
                    r = rr(i);
                  function i(t) {
                    var c;
                    !function (t, e) {
                      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                    }(this, i), (c = r.call(this, t)).onEditorBlur = function () {
                      c.setState({
                        editorFocused: false
                      });
                    }, c.onEditorFocus = function (t) {
                      var e = c.props.onFocus;
                      c.setState({
                        editorFocused: true
                      });
                      var n = c.focusHandler.isEditorFocused();
                      e && n && e(t);
                    }, c.onEditorMouseDown = function () {
                      c.focusHandler.onEditorMouseDown();
                    }, c.keyBindingFn = function (t) {
                      if ("Tab" !== t.key) return "ArrowUp" !== t.key && "ArrowDown" !== t.key || b() && t.preventDefault(), Object(E.getDefaultKeyBinding)(t);
                      var e = c.props.onTab;
                      if (!e || !e(t)) {
                        var n = Object(S.changeDepth)(c.state.editorState, t.shiftKey ? -1 : 1, 4);
                        n && n !== c.state.editorState && (c.onChange(n), t.preventDefault());
                      }
                      return null;
                    }, c.onToolbarFocus = function (t) {
                      var e = c.props.onFocus;
                      e && c.focusHandler.isToolbarFocused() && e(t);
                    }, c.onWrapperBlur = function (t) {
                      var e = c.props.onBlur;
                      e && c.focusHandler.isEditorBlur(t) && e(t, c.getEditorState());
                    }, c.onChange = function (t) {
                      var e = c.props,
                        n = e.readOnly,
                        o = e.onEditorStateChange;
                      n || "atomic" === Object(S.getSelectedBlocksType)(t) && t.getSelection().isCollapsed || (o && o(t, c.props.wrapperId), M(c.props, "editorState") ? c.afterChange(t) : c.setState({
                        editorState: t
                      }, c.afterChange(t)));
                    }, c.setWrapperReference = function (t) {
                      c.wrapper = t;
                    }, c.setEditorReference = function (t) {
                      c.props.editorRef && c.props.editorRef(t), c.editor = t;
                    }, c.getCompositeDecorator = function (t) {
                      var e = [].concat(tr(c.props.customDecorators), [{
                        strategy: Mo,
                        component: jo({
                          showOpenOptionOnHover: t.link.showOpenOptionOnHover
                        })
                      }]);
                      return c.props.mention && e.push.apply(e, tr(To(Xo(Xo({}, c.props.mention), {}, {
                        onChange: c.onChange,
                        getEditorState: c.getEditorState,
                        getSuggestions: c.getSuggestions,
                        getWrapperRef: c.getWrapperRef,
                        modalHandler: c.modalHandler
                      })))), c.props.hashtag && e.push(Ro(c.props.hashtag)), new E.CompositeDecorator(e);
                    }, c.getWrapperRef = function () {
                      return c.wrapper;
                    }, c.getEditorState = function () {
                      return c.state ? c.state.editorState : null;
                    }, c.getSuggestions = function () {
                      return c.props.mention && c.props.mention.suggestions;
                    }, c.afterChange = function (o) {
                      setTimeout(function () {
                        var t = c.props,
                          e = t.onChange,
                          n = t.onContentStateChange;
                        e && e(Object(E.convertToRaw)(o.getCurrentContent())), n && n(Object(E.convertToRaw)(o.getCurrentContent()));
                      });
                    }, c.isReadOnly = function () {
                      return c.props.readOnly;
                    }, c.isImageAlignmentEnabled = function () {
                      return c.state.toolbar.image.alignmentEnabled;
                    }, c.createEditorState = function (t) {
                      var e;
                      if (M(c.props, "editorState")) c.props.editorState && (e = E.EditorState.set(c.props.editorState, {
                        decorator: t
                      }));else if (M(c.props, "defaultEditorState")) c.props.defaultEditorState && (e = E.EditorState.set(c.props.defaultEditorState, {
                        decorator: t
                      }));else if (M(c.props, "contentState")) {
                        if (c.props.contentState) {
                          var n = Object(E.convertFromRaw)(c.props.contentState);
                          e = E.EditorState.createWithContent(n, t), e = E.EditorState.moveSelectionToEnd(e);
                        }
                      } else if (M(c.props, "defaultContentState") || M(c.props, "initialContentState")) {
                        var o = c.props.defaultContentState || c.props.initialContentState;
                        o && (o = Object(E.convertFromRaw)(o), e = E.EditorState.createWithContent(o, t), e = E.EditorState.moveSelectionToEnd(e));
                      }
                      return e = e || E.EditorState.createEmpty(t);
                    }, c.filterEditorProps = function (t) {
                      return e = t, n = ["onChange", "onEditorStateChange", "onContentStateChange", "initialContentState", "defaultContentState", "contentState", "editorState", "defaultEditorState", "locale", "localization", "toolbarOnFocus", "toolbar", "toolbarCustomButtons", "toolbarClassName", "editorClassName", "toolbarHidden", "wrapperClassName", "toolbarStyle", "editorStyle", "wrapperStyle", "uploadCallback", "onFocus", "onBlur", "onTab", "mention", "hashtag", "ariaLabel", "customBlockRenderFunc", "customDecorators", "handlePastedText", "customStyleMap"], o = Object.keys(e).filter(function (t) {
                        return n.indexOf(t) < 0;
                      }), r = {}, o && 0 < o.length && o.forEach(function (t) {
                        r[t] = e[t];
                      }), r;
                      var e, n, o, r;
                    }, c.getStyleMap = function (t) {
                      return Xo(Xo({}, Object(S.getCustomStyleMap)()), t.customStyleMap);
                    }, c.changeEditorState = function (t) {
                      var e = Object(E.convertFromRaw)(t),
                        n = c.state.editorState;
                      return n = E.EditorState.push(n, e, "insert-characters"), n = E.EditorState.moveSelectionToEnd(n);
                    }, c.focusEditor = function () {
                      setTimeout(function () {
                        c.editor.focus();
                      });
                    }, c.handleKeyCommand = function (t) {
                      var e = c.state,
                        n = e.editorState,
                        o = e.toolbar.inline;
                      if (o && 0 <= o.options.indexOf(t)) {
                        var r = E.RichUtils.handleKeyCommand(n, t);
                        if (r) return c.onChange(r), true;
                      }
                      return false;
                    }, c.handleReturn = function (t) {
                      if (b()) return true;
                      var e = c.state.editorState,
                        n = Object(S.handleNewLine)(e, t);
                      return !!n && (c.onChange(n), true);
                    }, c.handlePastedTextFn = function (t, e) {
                      var n = c.state.editorState,
                        o = c.props,
                        r = o.handlePastedText,
                        i = o.stripPastedStyles;
                      return r ? r(t, e, n, c.onChange) : !i && function (t, e, n, o) {
                        var r = Object(S.getSelectedBlock)(n);
                        if (r && "code" === r.type) {
                          var i = E.Modifier.replaceText(n.getCurrentContent(), n.getSelection(), t, n.getCurrentInlineStyle());
                          return o(E.EditorState.push(n, i, "insert-characters")), true;
                        }
                        if (e) {
                          var c = O()(e),
                            a = n.getCurrentContent();
                          return c.entityMap.forEach(function (t, e) {
                            a = a.mergeEntityData(e, t);
                          }), a = E.Modifier.replaceWithFragment(a, n.getSelection(), new x.List(c.contentBlocks)), o(E.EditorState.push(n, a, "insert-characters")), true;
                        }
                        return false;
                      }(t, e, n, c.onChange);
                    }, c.preventDefault = function (t) {
                      "INPUT" === t.target.tagName || "LABEL" === t.target.tagName || "TEXTAREA" === t.target.tagName ? c.focusHandler.onInputMouseDown() : t.preventDefault();
                    };
                    var e = D(Go, t.toolbar),
                      n = t.wrapperId ? t.wrapperId : Math.floor(1e4 * Math.random());
                    c.wrapperId = "rdw-wrapper-".concat(n), c.modalHandler = new a(), c.focusHandler = new p(), c.blockRendererFn = Wo({
                      isReadOnly: c.isReadOnly,
                      isImageAlignmentEnabled: c.isImageAlignmentEnabled,
                      getEditorState: c.getEditorState,
                      onChange: c.onChange
                    }, t.customBlockRenderFunc), c.editorProps = c.filterEditorProps(t), c.customStyleMap = c.getStyleMap(t), c.compositeDecorator = c.getCompositeDecorator(e);
                    var o = c.createEditorState(c.compositeDecorator);
                    return Object(S.extractInlineStyle)(o), c.state = {
                      editorState: o,
                      editorFocused: false,
                      toolbar: e
                    }, c;
                  }
                  return t = i, (e = [{
                    key: "componentDidMount",
                    value: function () {
                      this.modalHandler.init(this.wrapperId);
                    }
                  }, {
                    key: "componentDidUpdate",
                    value: function (t) {
                      if (t !== this.props) {
                        var e = {},
                          n = this.props,
                          o = n.editorState,
                          r = n.contentState;
                        if (!this.state.toolbar) {
                          var i = D(Go, i);
                          e.toolbar = i;
                        }
                        if (M(this.props, "editorState") && o !== t.editorState) e.editorState = o ? E.EditorState.set(o, {
                          decorator: this.compositeDecorator
                        }) : E.EditorState.createEmpty(this.compositeDecorator);else if (M(this.props, "contentState") && r !== t.contentState) if (r) {
                          var c = this.changeEditorState(r);
                          c && (e.editorState = c);
                        } else e.editorState = E.EditorState.createEmpty(this.compositeDecorator);
                        t.editorState === o && t.contentState === r || Object(S.extractInlineStyle)(e.editorState), Object.keys(e).length && this.setState(e), this.editorProps = this.filterEditorProps(this.props), this.customStyleMap = this.getStyleMap(this.props);
                      }
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var t = this.state,
                        e = t.editorState,
                        n = t.editorFocused,
                        r = t.toolbar,
                        o = this.props,
                        i = o.locale,
                        c = o.localization,
                        a = c.locale,
                        l = c.translations,
                        s = o.toolbarCustomButtons,
                        u = o.toolbarOnFocus,
                        p = o.toolbarClassName,
                        d = o.toolbarHidden,
                        f = o.editorClassName,
                        y = o.wrapperClassName,
                        m = o.toolbarStyle,
                        g = o.editorStyle,
                        b = o.wrapperStyle,
                        h = o.uploadCallback,
                        M = o.ariaLabel,
                        j = {
                          modalHandler: this.modalHandler,
                          editorState: e,
                          onChange: this.onChange,
                          translations: Xo(Xo({}, Jo[i || a]), l)
                        },
                        v = n || this.focusHandler.isInputFocused() || !u;
                      return N.a.createElement("div", {
                        id: this.wrapperId,
                        className: w()(y, "rdw-editor-wrapper"),
                        style: b,
                        onClick: this.modalHandler.onEditorClick,
                        onBlur: this.onWrapperBlur,
                        "aria-label": "rdw-wrapper"
                      }, !d && N.a.createElement("div", {
                        className: w()("rdw-editor-toolbar", p),
                        style: Xo({
                          visibility: v ? "visible" : "hidden"
                        }, m),
                        onMouseDown: this.preventDefault,
                        "aria-label": "rdw-toolbar",
                        "aria-hidden": (!n && u).toString(),
                        onFocus: this.onToolbarFocus
                      }, r.options.map(function (t, e) {
                        var n = so[t],
                          o = r[t];
                        return "image" === t && h && (o.uploadCallback = h), N.a.createElement(n, qo({
                          key: e
                        }, j, {
                          config: o
                        }));
                      }), s && s.map(function (t, e) {
                        return N.a.cloneElement(t, Xo({
                          key: e
                        }, j));
                      })), N.a.createElement("div", {
                        ref: this.setWrapperReference,
                        className: w()(f, "rdw-editor-main"),
                        style: g,
                        onClick: this.focusEditor,
                        onFocus: this.onEditorFocus,
                        onBlur: this.onEditorBlur,
                        onKeyDown: C.onKeyDown,
                        onMouseDown: this.onEditorMouseDown
                      }, N.a.createElement(E.Editor, qo({
                        ref: this.setEditorReference,
                        keyBindingFn: this.keyBindingFn,
                        editorState: e,
                        onChange: this.onChange,
                        blockStyleFn: L,
                        customStyleMap: this.getStyleMap(this.props),
                        handleReturn: this.handleReturn,
                        handlePastedText: this.handlePastedTextFn,
                        blockRendererFn: this.blockRendererFn,
                        handleKeyCommand: this.handleKeyCommand,
                        ariaLabel: M || "rdw-editor",
                        blockRenderMap: S.blockRenderMap
                      }, this.editorProps))));
                    }
                  }]) && nr(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), i;
                }();
                cr.propTypes = {
                  onChange: y.a.func,
                  onEditorStateChange: y.a.func,
                  onContentStateChange: y.a.func,
                  initialContentState: y.a.object,
                  defaultContentState: y.a.object,
                  contentState: y.a.object,
                  editorState: y.a.object,
                  defaultEditorState: y.a.object,
                  toolbarOnFocus: y.a.bool,
                  spellCheck: y.a.bool,
                  stripPastedStyles: y.a.bool,
                  toolbar: y.a.object,
                  toolbarCustomButtons: y.a.array,
                  toolbarClassName: y.a.string,
                  toolbarHidden: y.a.bool,
                  locale: y.a.string,
                  localization: y.a.object,
                  editorClassName: y.a.string,
                  wrapperClassName: y.a.string,
                  toolbarStyle: y.a.object,
                  editorStyle: y.a.object,
                  wrapperStyle: y.a.object,
                  uploadCallback: y.a.func,
                  onFocus: y.a.func,
                  onBlur: y.a.func,
                  onTab: y.a.func,
                  mention: y.a.object,
                  hashtag: y.a.object,
                  textAlignment: y.a.string,
                  readOnly: y.a.bool,
                  tabIndex: y.a.number,
                  placeholder: y.a.string,
                  ariaLabel: y.a.string,
                  ariaOwneeID: y.a.string,
                  ariaActiveDescendantID: y.a.string,
                  ariaAutoComplete: y.a.string,
                  ariaDescribedBy: y.a.string,
                  ariaExpanded: y.a.string,
                  ariaHasPopup: y.a.string,
                  customBlockRenderFunc: y.a.func,
                  wrapperId: y.a.number,
                  customDecorators: y.a.array,
                  editorRef: y.a.func,
                  handlePastedText: y.a.func
                }, cr.defaultProps = {
                  toolbarOnFocus: false,
                  toolbarHidden: false,
                  stripPastedStyles: false,
                  localization: {
                    locale: "en",
                    translations: {}
                  },
                  customDecorators: []
                };
                var ar = cr;
              }], i.c = a, i.d = function (t, e, n) {
                i.o(t, e) || Object.defineProperty(t, e, {
                  enumerable: true,
                  get: n
                });
              }, i.r = function (t) {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                  value: "Module"
                }), Object.defineProperty(t, "__esModule", {
                  value: true
                });
              }, i.t = function (e, t) {
                if (1 & t && (e = i(e)), 8 & t) return e;
                if (4 & t && "object" == typeof e && e && e.__esModule) return e;
                var n = Object.create(null);
                if (i.r(n), Object.defineProperty(n, "default", {
                  enumerable: true,
                  value: e
                }), 2 & t && "string" != typeof e) for (var o in e) i.d(n, o, function (t) {
                  return e[t];
                }.bind(null, o));
                return n;
              }, i.n = function (t) {
                var e = t && t.__esModule ? function () {
                  return t.default;
                } : function () {
                  return t;
                };
                return i.d(e, "a", e), e;
              }, i.o = function (t, e) {
                return Object.prototype.hasOwnProperty.call(t, e);
              }, i.p = "", i(i.s = 8);
              function i(t) {
                if (a[t]) return a[t].exports;
                var e = a[t] = {
                  i: t,
                  l: false,
                  exports: {}
                };
                return c[t].call(e.exports, e, e.exports, i), e.l = true, e.exports;
              }
              var c, a;
            });
          })(reactDraftWysiwyg);
          return reactDraftWysiwyg.exports;
        }
        var reactDraftWysiwygExports = exports("a8", requireReactDraftWysiwyg());
        var draftjsToHtml$1 = {
          exports: {}
        };
        var draftjsToHtml = draftjsToHtml$1.exports;
        var hasRequiredDraftjsToHtml;
        function requireDraftjsToHtml() {
          if (hasRequiredDraftjsToHtml) return draftjsToHtml$1.exports;
          hasRequiredDraftjsToHtml = 1;
          (function (module, exports) {
            (function (global, factory) {
              module.exports = factory();
            })(draftjsToHtml, function () {
              function forEach(obj, callback) {
                if (obj) {
                  for (var key in obj) {
                    if ({}.hasOwnProperty.call(obj, key)) {
                      callback(key, obj[key]);
                    }
                  }
                }
              }
              function isEmptyString(str) {
                if (str === void 0 || str === null || str.length === 0 || str.trim().length === 0) {
                  return true;
                }
                return false;
              }
              var blockTypesMapping = {
                unstyled: "p",
                "header-one": "h1",
                "header-two": "h2",
                "header-three": "h3",
                "header-four": "h4",
                "header-five": "h5",
                "header-six": "h6",
                "unordered-list-item": "ul",
                "ordered-list-item": "ol",
                blockquote: "blockquote",
                code: "pre"
              };
              function getBlockTag(type) {
                return type && blockTypesMapping[type];
              }
              function getBlockStyle(data) {
                var styles = "";
                forEach(data, function (key, value) {
                  if (value) {
                    styles += "".concat(key, ":").concat(value, ";");
                  }
                });
                return styles;
              }
              function getHashtagRanges(blockText, hashtagConfig) {
                var sections = [];
                if (hashtagConfig) {
                  var counter = 0;
                  var startIndex = 0;
                  var text = blockText;
                  var trigger = hashtagConfig.trigger || "#";
                  var separator = hashtagConfig.separator || " ";
                  for (; text.length > 0 && startIndex >= 0;) {
                    if (text[0] === trigger) {
                      startIndex = 0;
                      counter = 0;
                      text = text.substr(trigger.length);
                    } else {
                      startIndex = text.indexOf(separator + trigger);
                      if (startIndex >= 0) {
                        text = text.substr(startIndex + (separator + trigger).length);
                        counter += startIndex + separator.length;
                      }
                    }
                    if (startIndex >= 0) {
                      var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;
                      var hashtag = text.substr(0, endIndex);
                      if (hashtag && hashtag.length > 0) {
                        sections.push({
                          offset: counter,
                          length: hashtag.length + trigger.length,
                          type: "HASHTAG"
                        });
                      }
                      counter += trigger.length;
                    }
                  }
                }
                return sections;
              }
              function getSections(block, hashtagConfig) {
                var sections = [];
                var lastOffset = 0;
                var sectionRanges = block.entityRanges.map(function (range) {
                  var offset = range.offset,
                    length = range.length,
                    key = range.key;
                  return {
                    offset,
                    length,
                    key,
                    type: "ENTITY"
                  };
                });
                sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));
                sectionRanges = sectionRanges.sort(function (s1, s2) {
                  return s1.offset - s2.offset;
                });
                sectionRanges.forEach(function (r) {
                  if (r.offset > lastOffset) {
                    sections.push({
                      start: lastOffset,
                      end: r.offset
                    });
                  }
                  sections.push({
                    start: r.offset,
                    end: r.offset + r.length,
                    entityKey: r.key,
                    type: r.type
                  });
                  lastOffset = r.offset + r.length;
                });
                if (lastOffset < block.text.length) {
                  sections.push({
                    start: lastOffset,
                    end: block.text.length
                  });
                }
                return sections;
              }
              function isAtomicEntityBlock(block) {
                if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === "atomic")) {
                  return true;
                }
                return false;
              }
              function getStyleArrayForBlock(block) {
                var text = block.text,
                  inlineStyleRanges = block.inlineStyleRanges;
                var inlineStyles = {
                  BOLD: new Array(text.length),
                  ITALIC: new Array(text.length),
                  UNDERLINE: new Array(text.length),
                  STRIKETHROUGH: new Array(text.length),
                  CODE: new Array(text.length),
                  SUPERSCRIPT: new Array(text.length),
                  SUBSCRIPT: new Array(text.length),
                  COLOR: new Array(text.length),
                  BGCOLOR: new Array(text.length),
                  FONTSIZE: new Array(text.length),
                  FONTFAMILY: new Array(text.length),
                  length: text.length
                };
                if (inlineStyleRanges && inlineStyleRanges.length > 0) {
                  inlineStyleRanges.forEach(function (range) {
                    var offset = range.offset;
                    var length = offset + range.length;
                    for (var i = offset; i < length; i += 1) {
                      if (range.style.indexOf("color-") === 0) {
                        inlineStyles.COLOR[i] = range.style.substring(6);
                      } else if (range.style.indexOf("bgcolor-") === 0) {
                        inlineStyles.BGCOLOR[i] = range.style.substring(8);
                      } else if (range.style.indexOf("fontsize-") === 0) {
                        inlineStyles.FONTSIZE[i] = range.style.substring(9);
                      } else if (range.style.indexOf("fontfamily-") === 0) {
                        inlineStyles.FONTFAMILY[i] = range.style.substring(11);
                      } else if (inlineStyles[range.style]) {
                        inlineStyles[range.style][i] = true;
                      }
                    }
                  });
                }
                return inlineStyles;
              }
              function getStylesAtOffset(inlineStyles, offset) {
                var styles = {};
                if (inlineStyles.COLOR[offset]) {
                  styles.COLOR = inlineStyles.COLOR[offset];
                }
                if (inlineStyles.BGCOLOR[offset]) {
                  styles.BGCOLOR = inlineStyles.BGCOLOR[offset];
                }
                if (inlineStyles.FONTSIZE[offset]) {
                  styles.FONTSIZE = inlineStyles.FONTSIZE[offset];
                }
                if (inlineStyles.FONTFAMILY[offset]) {
                  styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];
                }
                if (inlineStyles.UNDERLINE[offset]) {
                  styles.UNDERLINE = true;
                }
                if (inlineStyles.ITALIC[offset]) {
                  styles.ITALIC = true;
                }
                if (inlineStyles.BOLD[offset]) {
                  styles.BOLD = true;
                }
                if (inlineStyles.STRIKETHROUGH[offset]) {
                  styles.STRIKETHROUGH = true;
                }
                if (inlineStyles.CODE[offset]) {
                  styles.CODE = true;
                }
                if (inlineStyles.SUBSCRIPT[offset]) {
                  styles.SUBSCRIPT = true;
                }
                if (inlineStyles.SUPERSCRIPT[offset]) {
                  styles.SUPERSCRIPT = true;
                }
                return styles;
              }
              function sameStyleAsPrevious(inlineStyles, styles, index) {
                var sameStyled = true;
                if (index > 0 && index < inlineStyles.length) {
                  styles.forEach(function (style) {
                    sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];
                  });
                } else {
                  sameStyled = false;
                }
                return sameStyled;
              }
              function addInlineStyleMarkup(style, content) {
                if (style === "BOLD") {
                  return "<strong>".concat(content, "</strong>");
                }
                if (style === "ITALIC") {
                  return "<em>".concat(content, "</em>");
                }
                if (style === "UNDERLINE") {
                  return "<ins>".concat(content, "</ins>");
                }
                if (style === "STRIKETHROUGH") {
                  return "<del>".concat(content, "</del>");
                }
                if (style === "CODE") {
                  return "<code>".concat(content, "</code>");
                }
                if (style === "SUPERSCRIPT") {
                  return "<sup>".concat(content, "</sup>");
                }
                if (style === "SUBSCRIPT") {
                  return "<sub>".concat(content, "</sub>");
                }
                return content;
              }
              function getSectionText(text) {
                if (text && text.length > 0) {
                  var chars = text.map(function (ch) {
                    switch (ch) {
                      case "\n":
                        return "<br>";
                      case "&":
                        return "&amp;";
                      case "<":
                        return "&lt;";
                      case ">":
                        return "&gt;";
                      default:
                        return ch;
                    }
                  });
                  return chars.join("");
                }
                return "";
              }
              function addStylePropertyMarkup(styles, text) {
                if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {
                  var styleString = 'style="';
                  if (styles.COLOR) {
                    styleString += "color: ".concat(styles.COLOR, ";");
                  }
                  if (styles.BGCOLOR) {
                    styleString += "background-color: ".concat(styles.BGCOLOR, ";");
                  }
                  if (styles.FONTSIZE) {
                    styleString += "font-size: ".concat(styles.FONTSIZE).concat(/^\d+$/.test(styles.FONTSIZE) ? "px" : "", ";");
                  }
                  if (styles.FONTFAMILY) {
                    styleString += "font-family: ".concat(styles.FONTFAMILY, ";");
                  }
                  styleString += '"';
                  return "<span ".concat(styleString, ">").concat(text, "</span>");
                }
                return text;
              }
              function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {
                var entity = entityMap[entityKey];
                if (typeof customEntityTransform === "function") {
                  var html = customEntityTransform(entity, text);
                  if (html) {
                    return html;
                  }
                }
                if (entity.type === "MENTION") {
                  return '<a href="'.concat(entity.data.url, '" class="wysiwyg-mention" data-mention data-value="').concat(entity.data.value, '">').concat(text, "</a>");
                }
                if (entity.type === "LINK") {
                  var targetOption = entity.data.targetOption || "_self";
                  return '<a href="'.concat(entity.data.url, '" target="').concat(targetOption, '">').concat(text, "</a>");
                }
                if (entity.type === "IMAGE") {
                  var alignment = entity.data.alignment;
                  if (alignment && alignment.length) {
                    return '<div style="text-align:'.concat(alignment, ';"><img src="').concat(entity.data.src, '" alt="').concat(entity.data.alt, '" style="height: ').concat(entity.data.height, ";width: ").concat(entity.data.width, '"/></div>');
                  }
                  return '<img src="'.concat(entity.data.src, '" alt="').concat(entity.data.alt, '" style="height: ').concat(entity.data.height, ";width: ").concat(entity.data.width, '"/>');
                }
                if (entity.type === "EMBEDDED_LINK") {
                  return '<iframe width="'.concat(entity.data.width, '" height="').concat(entity.data.height, '" src="').concat(entity.data.src, '" frameBorder="0"></iframe>');
                }
                return text;
              }
              function getInlineStyleSections(block, styles, start, end) {
                var styleSections = [];
                var text = Array.from(block.text);
                if (text.length > 0) {
                  var inlineStyles = getStyleArrayForBlock(block);
                  var section;
                  for (var i = start; i < end; i += 1) {
                    if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {
                      section.text.push(text[i]);
                      section.end = i + 1;
                    } else {
                      section = {
                        styles: getStylesAtOffset(inlineStyles, i),
                        text: [text[i]],
                        start: i,
                        end: i + 1
                      };
                      styleSections.push(section);
                    }
                  }
                }
                return styleSections;
              }
              function trimLeadingZeros(sectionText) {
                if (sectionText) {
                  var replacedText = sectionText;
                  for (var i = 0; i < replacedText.length; i += 1) {
                    if (sectionText[i] === " ") {
                      replacedText = replacedText.replace(" ", "&nbsp;");
                    } else {
                      break;
                    }
                  }
                  return replacedText;
                }
                return sectionText;
              }
              function trimTrailingZeros(sectionText) {
                if (sectionText) {
                  var replacedText = sectionText;
                  for (var i = replacedText.length - 1; i >= 0; i -= 1) {
                    if (replacedText[i] === " ") {
                      replacedText = "".concat(replacedText.substring(0, i), "&nbsp;").concat(replacedText.substring(i + 1));
                    } else {
                      break;
                    }
                  }
                  return replacedText;
                }
                return sectionText;
              }
              function getStyleTagSectionMarkup(styleSection) {
                var styles = styleSection.styles,
                  text = styleSection.text;
                var content = getSectionText(text);
                forEach(styles, function (style, value) {
                  content = addInlineStyleMarkup(style, content);
                });
                return content;
              }
              function getInlineStyleSectionMarkup(block, styleSection) {
                var styleTagSections = getInlineStyleSections(block, ["BOLD", "ITALIC", "UNDERLINE", "STRIKETHROUGH", "CODE", "SUPERSCRIPT", "SUBSCRIPT"], styleSection.start, styleSection.end);
                var styleSectionText = "";
                styleTagSections.forEach(function (stylePropertySection) {
                  styleSectionText += getStyleTagSectionMarkup(stylePropertySection);
                });
                styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);
                return styleSectionText;
              }
              function getSectionMarkup(block, entityMap, section, customEntityTransform) {
                var entityInlineMarkup = [];
                var inlineStyleSections = getInlineStyleSections(block, ["COLOR", "BGCOLOR", "FONTSIZE", "FONTFAMILY"], section.start, section.end);
                inlineStyleSections.forEach(function (styleSection) {
                  entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));
                });
                var sectionText = entityInlineMarkup.join("");
                if (section.type === "ENTITY") {
                  if (section.entityKey !== void 0 && section.entityKey !== null) {
                    sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform);
                  }
                } else if (section.type === "HASHTAG") {
                  sectionText = '<a href="'.concat(sectionText, '" class="wysiwyg-hashtag">').concat(sectionText, "</a>");
                }
                return sectionText;
              }
              function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {
                var blockMarkup = [];
                var sections = getSections(block, hashtagConfig);
                sections.forEach(function (section, index) {
                  var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);
                  if (index === 0) {
                    sectionText = trimLeadingZeros(sectionText);
                  }
                  if (index === sections.length - 1) {
                    sectionText = trimTrailingZeros(sectionText);
                  }
                  blockMarkup.push(sectionText);
                });
                return blockMarkup.join("");
              }
              function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {
                var blockHtml = [];
                if (isAtomicEntityBlock(block)) {
                  blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, void 0, customEntityTransform));
                } else {
                  var blockTag = getBlockTag(block.type);
                  if (blockTag) {
                    blockHtml.push("<".concat(blockTag));
                    var blockStyle = getBlockStyle(block.data);
                    if (blockStyle) {
                      blockHtml.push(' style="'.concat(blockStyle, '"'));
                    }
                    if (directional) {
                      blockHtml.push(' dir = "auto"');
                    }
                    blockHtml.push(">");
                    blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));
                    blockHtml.push("</".concat(blockTag, ">"));
                  }
                }
                blockHtml.push("\n");
                return blockHtml.join("");
              }
              function isList(blockType) {
                return blockType === "unordered-list-item" || blockType === "ordered-list-item";
              }
              function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {
                var listHtml = [];
                var nestedListBlock = [];
                var previousBlock;
                listBlocks.forEach(function (block) {
                  var nestedBlock = false;
                  if (!previousBlock) {
                    listHtml.push("<".concat(getBlockTag(block.type), ">\n"));
                  } else if (previousBlock.type !== block.type) {
                    listHtml.push("</".concat(getBlockTag(previousBlock.type), ">\n"));
                    listHtml.push("<".concat(getBlockTag(block.type), ">\n"));
                  } else if (previousBlock.depth === block.depth) {
                    if (nestedListBlock && nestedListBlock.length > 0) {
                      listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));
                      nestedListBlock = [];
                    }
                  } else {
                    nestedBlock = true;
                    nestedListBlock.push(block);
                  }
                  if (!nestedBlock) {
                    listHtml.push("<li");
                    var blockStyle = getBlockStyle(block.data);
                    if (blockStyle) {
                      listHtml.push(' style="'.concat(blockStyle, '"'));
                    }
                    if (directional) {
                      listHtml.push(' dir = "auto"');
                    }
                    listHtml.push(">");
                    listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));
                    listHtml.push("</li>\n");
                    previousBlock = block;
                  }
                });
                if (nestedListBlock && nestedListBlock.length > 0) {
                  listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));
                }
                listHtml.push("</".concat(getBlockTag(previousBlock.type), ">\n"));
                return listHtml.join("");
              }
              function draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {
                var html = [];
                if (editorContent) {
                  var blocks = editorContent.blocks,
                    entityMap = editorContent.entityMap;
                  if (blocks && blocks.length > 0) {
                    var listBlocks = [];
                    blocks.forEach(function (block) {
                      if (isList(block.type)) {
                        listBlocks.push(block);
                      } else {
                        if (listBlocks.length > 0) {
                          var listHtml2 = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform);
                          html.push(listHtml2);
                          listBlocks = [];
                        }
                        var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);
                        html.push(blockHtml);
                      }
                    });
                    if (listBlocks.length > 0) {
                      var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform);
                      html.push(listHtml);
                      listBlocks = [];
                    }
                  }
                }
                return html.join("");
              }
              return draftToHtml;
            });
          })(draftjsToHtml$1);
          return draftjsToHtml$1.exports;
        }
        var draftjsToHtmlExports = requireDraftjsToHtml();
        const draftToHtml = exports("a9", /*@__PURE__*/getDefaultExportFromCjs(draftjsToHtmlExports));
        const we = 0,
          zt = 1,
          qt = 2,
          kn = 4;
        function un(t) {
          return () => t;
        }
        function fo(t) {
          t();
        }
        function ne(t, e) {
          return n => t(e(n));
        }
        function an(t, e) {
          return () => t(e);
        }
        function mo(t, e) {
          return n => t(e, n);
        }
        function We(t) {
          return t !== void 0;
        }
        function po(...t) {
          return () => {
            t.map(fo);
          };
        }
        function Yt() {}
        function ve(t, e) {
          return e(t), t;
        }
        function ho(t, e) {
          return e(t);
        }
        function X(...t) {
          return t;
        }
        function K$1(t, e) {
          return t(zt, e);
        }
        function G$1(t, e) {
          t(we, e);
        }
        function Ge(t) {
          t(qt);
        }
        function ot(t) {
          return t(kn);
        }
        function O$1(t, e) {
          return K$1(t, mo(e, we));
        }
        function Tt(t, e) {
          const n = t(zt, o => {
            n(), e(o);
          });
          return n;
        }
        function dn(t) {
          let e, n;
          return o => r => {
            e = r, n && clearTimeout(n), n = setTimeout(() => {
              o(e);
            }, t);
          };
        }
        function Fn(t, e) {
          return t === e;
        }
        function Y(t = Fn) {
          let e;
          return n => o => {
            t(e, o) || (e = o, n(o));
          };
        }
        function A$1(t) {
          return e => n => {
            t(n) && e(n);
          };
        }
        function E$1(t) {
          return e => ne(e, t);
        }
        function Rt(t) {
          return e => () => {
            e(t);
          };
        }
        function S(t, ...e) {
          const n = go(...e);
          return (o, r) => {
            switch (o) {
              case qt:
                Ge(t);
                return;
              case zt:
                return K$1(t, n(r));
            }
          };
        }
        function bt(t, e) {
          return n => o => {
            n(e = t(e, o));
          };
        }
        function Dt(t) {
          return e => n => {
            t > 0 ? t-- : e(n);
          };
        }
        function kt(t) {
          let e = null,
            n;
          return o => r => {
            e = r, !n && (n = setTimeout(() => {
              n = void 0, o(e);
            }, t));
          };
        }
        function N$1(...t) {
          const e = new Array(t.length);
          let n = 0,
            o = null;
          const r = Math.pow(2, t.length) - 1;
          return t.forEach((s, i) => {
            const l = Math.pow(2, i);
            K$1(s, c => {
              const a = n;
              n = n | l, e[i] = c, a !== r && n === r && o && (o(), o = null);
            });
          }), s => i => {
            const l = () => {
              s([i].concat(e));
            };
            n === r ? l() : o = l;
          };
        }
        function go(...t) {
          return e => t.reduceRight(ho, e);
        }
        function Io(t) {
          let e, n;
          const o = () => e == null ? void 0 : e();
          return function (r, s) {
            switch (r) {
              case zt:
                return s ? n === s ? void 0 : (o(), n = s, e = K$1(t, s), e) : (o(), Yt);
              case qt:
                o(), n = null;
                return;
            }
          };
        }
        function w$1(t) {
          let e = t;
          const n = $();
          return (o, r) => {
            switch (o) {
              case we:
                e = r;
                break;
              case zt:
                {
                  r(e);
                  break;
                }
              case kn:
                return e;
            }
            return n(o, r);
          };
        }
        function ct(t, e) {
          return ve(w$1(e), n => O$1(t, n));
        }
        function $() {
          const t = [];
          return (e, n) => {
            switch (e) {
              case we:
                t.slice().forEach(o => {
                  o(n);
                });
                return;
              case qt:
                t.splice(0, t.length);
                return;
              case zt:
                return t.push(n), () => {
                  const o = t.indexOf(n);
                  o > -1 && t.splice(o, 1);
                };
            }
          };
        }
        function ht(t) {
          return ve($(), e => O$1(t, e));
        }
        function U$1(t, e = [], {
          singleton: n
        } = {
          singleton: true
        }) {
          return {
            constructor: t,
            dependencies: e,
            id: So(),
            singleton: n
          };
        }
        const So = () => Symbol();
        function xo(t) {
          const e = /* @__PURE__ */new Map(),
            n = ({
              constructor: o,
              dependencies: r,
              id: s,
              singleton: i
            }) => {
              if (i && e.has(s)) return e.get(s);
              const l = o(r.map(c => n(c)));
              return i && e.set(s, l), l;
            };
          return n(t);
        }
        function rt(...t) {
          const e = $(),
            n = new Array(t.length);
          let o = 0;
          const r = Math.pow(2, t.length) - 1;
          return t.forEach((s, i) => {
            const l = Math.pow(2, i);
            K$1(s, c => {
              n[i] = c, o = o | l, o === r && G$1(e, n);
            });
          }), function (s, i) {
            switch (s) {
              case qt:
                {
                  Ge(e);
                  return;
                }
              case zt:
                return o === r && i(n), K$1(e, i);
            }
          };
        }
        function V$1(t, e = Fn) {
          return S(t, Y(e));
        }
        function Le(...t) {
          return function (e, n) {
            switch (e) {
              case qt:
                return;
              case zt:
                return po(...t.map(o => K$1(o, n)));
            }
          };
        }
        var mt = /* @__PURE__ */(t => (t[t.DEBUG = 0] = "DEBUG", t[t.INFO = 1] = "INFO", t[t.WARN = 2] = "WARN", t[t.ERROR = 3] = "ERROR", t))(mt || {});
        const To = {
            0: "debug",
            3: "error",
            1: "log",
            2: "warn"
          },
          Co = () => typeof globalThis > "u" ? window : globalThis,
          Vt = U$1(() => {
            const t = w$1(3
            /* ERROR */);
            return {
              log: w$1((n, o, r = 1) => {
                var i;
                const s = (i = Co().VIRTUOSO_LOG_LEVEL) != null ? i : ot(t);
                r >= s && console[To[r]]("%creact-virtuoso: %c%s %o", "color: #0253b3; font-weight: bold", "color: initial", n, o);
              }),
              logLevel: t
            };
          }, [], {
            singleton: true
          });
        function Ht(t, e, n) {
          return _e(t, e, n).callbackRef;
        }
        function _e(t, e, n) {
          const o = React.useRef(null);
          let r = i => {};
          const s = React.useMemo(() => typeof ResizeObserver < "u" ? new ResizeObserver(i => {
            const l = () => {
              const c = i[0].target;
              c.offsetParent !== null && t(c);
            };
            n ? l() : requestAnimationFrame(l);
          }) : null, [t, n]);
          return r = i => {
            i && e ? (s == null || s.observe(i), o.current = i) : (o.current && (s == null || s.unobserve(o.current)), o.current = null);
          }, {
            callbackRef: r,
            ref: o
          };
        }
        function On(t, e, n, o, r, s, i, l, c) {
          const a = React.useCallback(m => {
            const x = wo(m.children, e, l ? "offsetWidth" : "offsetHeight", r);
            let h = m.parentElement;
            for (; !h.dataset.virtuosoScroller;) h = h.parentElement;
            const I = h.lastElementChild.dataset.viewportType === "window";
            let C;
            I && (C = h.ownerDocument.defaultView);
            const v = i ? l ? i.scrollLeft : i.scrollTop : I ? l ? C.scrollX || C.document.documentElement.scrollLeft : C.scrollY || C.document.documentElement.scrollTop : l ? h.scrollLeft : h.scrollTop,
              g = i ? l ? i.scrollWidth : i.scrollHeight : I ? l ? C.document.documentElement.scrollWidth : C.document.documentElement.scrollHeight : l ? h.scrollWidth : h.scrollHeight,
              p = i ? l ? i.offsetWidth : i.offsetHeight : I ? l ? C.innerWidth : C.innerHeight : l ? h.offsetWidth : h.offsetHeight;
            o({
              scrollHeight: g,
              scrollTop: Math.max(v, 0),
              viewportHeight: p
            }), s == null || s(l ? fn("column-gap", getComputedStyle(m).columnGap, r) : fn("row-gap", getComputedStyle(m).rowGap, r)), x !== null && t(x);
          }, [t, e, r, s, i, o, l]);
          return _e(a, n, c);
        }
        function wo(t, e, n, o) {
          const r = t.length;
          if (r === 0) return null;
          const s = [];
          for (let i = 0; i < r; i++) {
            const l = t.item(i);
            if (l.dataset.index === void 0) continue;
            const c = parseInt(l.dataset.index),
              a = parseFloat(l.dataset.knownSize),
              m = e(l, n);
            if (m === 0 && o("Zero-sized element, this should not happen", {
              child: l
            }, mt.ERROR), m === a) continue;
            const x = s[s.length - 1];
            s.length === 0 || x.size !== m || x.endIndex !== c - 1 ? s.push({
              endIndex: c,
              size: m,
              startIndex: c
            }) : s[s.length - 1].endIndex++;
          }
          return s;
        }
        function fn(t, e, n) {
          return e !== "normal" && !(e != null && e.endsWith("px")) && n(`${t} was not resolved to pixel value correctly`, e, mt.WARN), e === "normal" ? 0 : parseInt(e != null ? e : "0", 10);
        }
        function Ne(t, e, n) {
          const o = React.useRef(null),
            r = React.useCallback(c => {
              if (!(c != null && c.offsetParent)) return;
              const a = c.getBoundingClientRect(),
                m = a.width;
              let x, h;
              if (e) {
                const I = e.getBoundingClientRect(),
                  C = a.top - I.top;
                h = I.height - Math.max(0, C), x = C + e.scrollTop;
              } else {
                const I = i.current.ownerDocument.defaultView;
                h = I.innerHeight - Math.max(0, a.top), x = a.top + I.scrollY;
              }
              o.current = {
                offsetTop: x,
                visibleHeight: h,
                visibleWidth: m
              }, t(o.current);
            },
            // eslint-disable-next-line react-hooks/exhaustive-deps
            [t, e]),
            {
              callbackRef: s,
              ref: i
            } = _e(r, true, n),
            l = React.useCallback(() => {
              r(i.current);
            }, [r, i]);
          return React.useEffect(() => {
            var c;
            if (e) {
              e.addEventListener("scroll", l);
              const a = new ResizeObserver(() => {
                requestAnimationFrame(l);
              });
              return a.observe(e), () => {
                e.removeEventListener("scroll", l), a.unobserve(e);
              };
            } else {
              const a = (c = i.current) == null ? void 0 : c.ownerDocument.defaultView;
              return a == null || a.addEventListener("scroll", l), a == null || a.addEventListener("resize", l), () => {
                a == null || a.removeEventListener("scroll", l), a == null || a.removeEventListener("resize", l);
              };
            }
          }, [l, e, i]), s;
        }
        const at = U$1(() => {
            const t = $(),
              e = $(),
              n = w$1(0),
              o = $(),
              r = w$1(0),
              s = $(),
              i = $(),
              l = w$1(0),
              c = w$1(0),
              a = w$1(0),
              m = w$1(0),
              x = $(),
              h = $(),
              I = w$1(false),
              C = w$1(false),
              v = w$1(false);
            return O$1(S(t, E$1(({
              scrollTop: g
            }) => g)), e), O$1(S(t, E$1(({
              scrollHeight: g
            }) => g)), i), O$1(e, r), {
              deviation: n,
              fixedFooterHeight: a,
              fixedHeaderHeight: c,
              footerHeight: m,
              headerHeight: l,
              horizontalDirection: C,
              scrollBy: h,
              // input
              scrollContainerState: t,
              scrollHeight: i,
              scrollingInProgress: I,
              // signals
              scrollTo: x,
              scrollTop: e,
              skipAnimationFrameInResizeObserver: v,
              smoothScrollTargetReached: o,
              // state
              statefulScrollTop: r,
              viewportHeight: s
            };
          }, [], {
            singleton: true
          }),
          oe = {
            lvl: 0
          };
        function Ln(t, e) {
          const n = t.length;
          if (n === 0) return [];
          let {
            index: o,
            value: r
          } = e(t[0]);
          const s = [];
          for (let i = 1; i < n; i++) {
            const {
              index: l,
              value: c
            } = e(t[i]);
            s.push({
              end: l - 1,
              start: o,
              value: r
            }), o = l, r = c;
          }
          return s.push({
            end: 1 / 0,
            start: o,
            value: r
          }), s;
        }
        function j(t) {
          return t === oe;
        }
        function re(t, e) {
          if (!j(t)) return e === t.k ? t.v : e < t.k ? re(t.l, e) : re(t.r, e);
        }
        function wt(t, e, n = "k") {
          if (j(t)) return [-1 / 0, void 0];
          if (Number(t[n]) === e) return [t.k, t.v];
          if (Number(t[n]) < e) {
            const o = wt(t.r, e, n);
            return o[0] === -1 / 0 ? [t.k, t.v] : o;
          }
          return wt(t.l, e, n);
        }
        function pt(t, e, n) {
          return j(t) ? Pn(e, n, 1) : e === t.k ? st(t, {
            k: e,
            v: n
          }) : e < t.k ? mn(st(t, {
            l: pt(t.l, e, n)
          })) : mn(st(t, {
            r: pt(t.r, e, n)
          }));
        }
        function jt() {
          return oe;
        }
        function ye(t, e, n) {
          if (j(t)) return [];
          const o = wt(t, e)[0];
          return vo(Ve(t, o, n));
        }
        function ze(t, e) {
          if (j(t)) return oe;
          const {
            k: n,
            l: o,
            r
          } = t;
          if (e === n) {
            if (j(o)) return r;
            if (j(r)) return o;
            {
              const [s, i] = Vn(o);
              return ge(st(t, {
                k: s,
                l: zn(o),
                v: i
              }));
            }
          } else return e < n ? ge(st(t, {
            l: ze(o, e)
          })) : ge(st(t, {
            r: ze(r, e)
          }));
        }
        function Gt(t) {
          return j(t) ? [] : [...Gt(t.l), {
            k: t.k,
            v: t.v
          }, ...Gt(t.r)];
        }
        function Ve(t, e, n) {
          if (j(t)) return [];
          const {
            k: o,
            l: r,
            r: s,
            v: i
          } = t;
          let l = [];
          return o > e && (l = l.concat(Ve(r, e, n))), o >= e && o <= n && l.push({
            k: o,
            v: i
          }), o <= n && (l = l.concat(Ve(s, e, n))), l;
        }
        function ge(t) {
          const {
            l: e,
            lvl: n,
            r: o
          } = t;
          if (o.lvl >= n - 1 && e.lvl >= n - 1) return t;
          if (n > o.lvl + 1) {
            if (Ee(e)) return An(st(t, {
              lvl: n - 1
            }));
            if (!j(e) && !j(e.r)) return st(e.r, {
              l: st(e, {
                r: e.r.l
              }),
              lvl: n,
              r: st(t, {
                l: e.r.r,
                lvl: n - 1
              })
            });
            throw new Error("Unexpected empty nodes");
          } else {
            if (Ee(t)) return Pe(st(t, {
              lvl: n - 1
            }));
            if (!j(o) && !j(o.l)) {
              const r = o.l,
                s = Ee(r) ? o.lvl - 1 : o.lvl;
              return st(r, {
                l: st(t, {
                  lvl: n - 1,
                  r: r.l
                }),
                lvl: r.lvl + 1,
                r: Pe(st(o, {
                  l: r.r,
                  lvl: s
                }))
              });
            } else throw new Error("Unexpected empty nodes");
          }
        }
        function st(t, e) {
          return Pn(e.k !== void 0 ? e.k : t.k, e.v !== void 0 ? e.v : t.v, e.lvl !== void 0 ? e.lvl : t.lvl, e.l !== void 0 ? e.l : t.l, e.r !== void 0 ? e.r : t.r);
        }
        function zn(t) {
          return j(t.r) ? t.l : ge(st(t, {
            r: zn(t.r)
          }));
        }
        function Ee(t) {
          return j(t) || t.lvl > t.r.lvl;
        }
        function Vn(t) {
          return j(t.r) ? [t.k, t.v] : Vn(t.r);
        }
        function Pn(t, e, n, o = oe, r = oe) {
          return {
            k: t,
            l: o,
            lvl: n,
            r,
            v: e
          };
        }
        function mn(t) {
          return Pe(An(t));
        }
        function An(t) {
          const {
            l: e
          } = t;
          return !j(e) && e.lvl === t.lvl ? st(e, {
            r: st(t, {
              l: e.r
            })
          }) : t;
        }
        function Pe(t) {
          const {
            lvl: e,
            r: n
          } = t;
          return !j(n) && !j(n.r) && n.lvl === e && n.r.lvl === e ? st(n, {
            l: st(t, {
              r: n.l
            }),
            lvl: e + 1
          }) : t;
        }
        function vo(t) {
          return Ln(t, ({
            k: e,
            v: n
          }) => ({
            index: e,
            value: n
          }));
        }
        function Mn(t, e) {
          return !!(t && t.startIndex === e.startIndex && t.endIndex === e.endIndex);
        }
        function se(t, e) {
          return !!(t && t[0] === e[0] && t[1] === e[1]);
        }
        const De = U$1(() => ({
          recalcInProgress: w$1(false)
        }), [], {
          singleton: true
        });
        function Wn(t, e, n) {
          return t[Se(t, e, n)];
        }
        function Se(t, e, n, o = 0) {
          let r = t.length - 1;
          for (; o <= r;) {
            const s = Math.floor((o + r) / 2),
              i = t[s],
              l = n(i, e);
            if (l === 0) return s;
            if (l === -1) {
              if (r - o < 2) return s - 1;
              r = s - 1;
            } else {
              if (r === o) return s;
              o = s + 1;
            }
          }
          throw new Error(`Failed binary finding record in array - ${t.join(",")}, searched for ${e}`);
        }
        function yo(t, e, n, o) {
          const r = Se(t, e, o),
            s = Se(t, n, o, r);
          return t.slice(r, s + 1);
        }
        function vt(t, e) {
          return Math.round(t.getBoundingClientRect()[e]);
        }
        function Re(t) {
          return !j(t.groupOffsetTree);
        }
        function $e({
          index: t
        }, e) {
          return e === t ? 0 : e < t ? -1 : 1;
        }
        function Ro() {
          return {
            groupIndices: [],
            groupOffsetTree: jt(),
            lastIndex: 0,
            lastOffset: 0,
            lastSize: 0,
            offsetTree: [],
            sizeTree: jt()
          };
        }
        function bo(t, e) {
          let n = j(t) ? 0 : 1 / 0;
          for (const o of e) {
            const {
              endIndex: r,
              size: s,
              startIndex: i
            } = o;
            if (n = Math.min(n, i), j(t)) {
              t = pt(t, 0, s);
              continue;
            }
            const l = ye(t, i - 1, r + 1);
            if (l.some(Lo(o))) continue;
            let c = false,
              a = false;
            for (const {
              end: m,
              start: x,
              value: h
            } of l) c ? (r >= x || s === h) && (t = ze(t, x)) : (a = h !== s, c = true), m > r && r >= x && h !== s && (t = pt(t, r + 1, h));
            a && (t = pt(t, i, s));
          }
          return [t, n];
        }
        function Ho(t) {
          return typeof t.groupIndex < "u";
        }
        function Eo({
          offset: t
        }, e) {
          return e === t ? 0 : e < t ? -1 : 1;
        }
        function ie(t, e, n) {
          if (e.length === 0) return 0;
          const {
              index: o,
              offset: r,
              size: s
            } = Wn(e, t, $e),
            i = t - o,
            l = s * i + (i - 1) * n + r;
          return l > 0 ? l + n : l;
        }
        function Gn(t, e) {
          if (!Re(e)) return t;
          let n = 0;
          for (; e.groupIndices[n] <= t + n;) n++;
          return t + n;
        }
        function _n(t, e, n) {
          if (Ho(t)) return e.groupIndices[t.groupIndex] + 1;
          {
            const o = t.index === "LAST" ? n : t.index;
            let r = Gn(o, e);
            return r = Math.max(0, r, Math.min(n, r)), r;
          }
        }
        function Bo(t, e, n, o = 0) {
          return o > 0 && (e = Math.max(e, Wn(t, o, $e).offset)), Ln(yo(t, e, n, Eo), Oo);
        }
        function ko(t, [e, n, o, r]) {
          e.length > 0 && o("received item sizes", e, mt.DEBUG);
          const s = t.sizeTree;
          let i = s,
            l = 0;
          if (n.length > 0 && j(s) && e.length === 2) {
            const h = e[0].size,
              I = e[1].size;
            i = n.reduce((C, v) => pt(pt(C, v, h), v + 1, I), i);
          } else [i, l] = bo(i, e);
          if (i === s) return t;
          const {
            lastIndex: c,
            lastOffset: a,
            lastSize: m,
            offsetTree: x
          } = Ae(t.offsetTree, l, i, r);
          return {
            groupIndices: n,
            groupOffsetTree: n.reduce((h, I) => pt(h, I, ie(I, x, r)), jt()),
            lastIndex: c,
            lastOffset: a,
            lastSize: m,
            offsetTree: x,
            sizeTree: i
          };
        }
        function Fo(t) {
          return Gt(t).map(({
            k: e,
            v: n
          }, o, r) => {
            const s = r[o + 1];
            return {
              endIndex: s ? s.k - 1 : 1 / 0,
              size: n,
              startIndex: e
            };
          });
        }
        function pn(t, e) {
          let n = 0,
            o = 0;
          for (; n < t;) n += e[o + 1] - e[o] - 1, o++;
          return o - (n === t ? 0 : 1);
        }
        function Ae(t, e, n, o) {
          let r = t,
            s = 0,
            i = 0,
            l = 0,
            c = 0;
          if (e !== 0) {
            c = Se(r, e - 1, $e), l = r[c].offset;
            const m = wt(n, e - 1);
            s = m[0], i = m[1], r.length && r[c].size === wt(n, e)[1] && (c -= 1), r = r.slice(0, c + 1);
          } else r = [];
          for (const {
            start: a,
            value: m
          } of ye(n, e, 1 / 0)) {
            const x = a - s,
              h = x * i + l + x * o;
            r.push({
              index: a,
              offset: h,
              size: m
            }), s = a, l = h, i = m;
          }
          return {
            lastIndex: s,
            lastOffset: l,
            lastSize: i,
            offsetTree: r
          };
        }
        function Oo(t) {
          return {
            index: t.index,
            value: t
          };
        }
        function Lo(t) {
          const {
            endIndex: e,
            size: n,
            startIndex: o
          } = t;
          return r => r.start === o && (r.end === e || r.end === 1 / 0) && r.value === n;
        }
        const zo = {
            offsetHeight: "height",
            offsetWidth: "width"
          },
          Et = U$1(([{
            log: t
          }, {
            recalcInProgress: e
          }]) => {
            const n = $(),
              o = $(),
              r = ct(o, 0),
              s = $(),
              i = $(),
              l = w$1(0),
              c = w$1([]),
              a = w$1(void 0),
              m = w$1(void 0),
              x = w$1((f, d) => vt(f, zo[d])),
              h = w$1(void 0),
              I = w$1(0),
              C = Ro(),
              v = ct(S(n, N$1(c, t, I), bt(ko, C), Y()), C),
              g = ct(S(c, Y(), bt((f, d) => ({
                current: d,
                prev: f.current
              }), {
                current: [],
                prev: []
              }), E$1(({
                prev: f
              }) => f)), []);
            O$1(S(c, A$1(f => f.length > 0), N$1(v, I), E$1(([f, d, y]) => {
              const B = f.reduce((k, L, z) => pt(k, L, ie(L, d.offsetTree, y) || z), jt());
              return {
                ...d,
                groupIndices: f,
                groupOffsetTree: B
              };
            })), v), O$1(S(o, N$1(v), A$1(([f, {
              lastIndex: d
            }]) => f < d), E$1(([f, {
              lastIndex: d,
              lastSize: y
            }]) => [{
              endIndex: d,
              size: y,
              startIndex: f
            }])), n), O$1(a, m);
            const p = ct(S(a, E$1(f => f === void 0)), true);
            O$1(S(m, A$1(f => f !== void 0 && j(ot(v).sizeTree)), E$1(f => [{
              endIndex: 0,
              size: f,
              startIndex: 0
            }])), n);
            const u = ht(S(n, N$1(v), bt(({
              sizes: f
            }, [d, y]) => ({
              changed: y !== f,
              sizes: y
            }), {
              changed: false,
              sizes: C
            }), E$1(f => f.changed)));
            K$1(S(l, bt((f, d) => ({
              diff: f.prev - d,
              prev: d
            }), {
              diff: 0,
              prev: 0
            }), E$1(f => f.diff)), f => {
              const {
                groupIndices: d
              } = ot(v);
              if (f > 0) G$1(e, true), G$1(s, f + pn(f, d));else if (f < 0) {
                const y = ot(g);
                y.length > 0 && (f -= pn(-f, y)), G$1(i, f);
              }
            }), K$1(S(l, N$1(t)), ([f, d]) => {
              f < 0 && d("`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value", {
                firstItemIndex: l
              }, mt.ERROR);
            });
            const T = ht(s);
            O$1(S(s, N$1(v), E$1(([f, d]) => {
              const y = d.groupIndices.length > 0,
                B = [],
                k = d.lastSize;
              if (y) {
                const L = re(d.sizeTree, 0);
                let z = 0,
                  _ = 0;
                for (; z < f;) {
                  const F = d.groupIndices[_],
                    q = d.groupIndices.length === _ + 1 ? 1 / 0 : d.groupIndices[_ + 1] - F - 1;
                  B.push({
                    endIndex: F,
                    size: L,
                    startIndex: F
                  }), B.push({
                    endIndex: F + 1 + q - 1,
                    size: k,
                    startIndex: F + 1
                  }), _++, z += q + 1;
                }
                const J = Gt(d.sizeTree);
                return z !== f && J.shift(), J.reduce((F, {
                  k: q,
                  v: it
                }) => {
                  let dt = F.ranges;
                  return F.prevSize !== 0 && (dt = [...F.ranges, {
                    endIndex: q + f - 1,
                    size: F.prevSize,
                    startIndex: F.prevIndex
                  }]), {
                    prevIndex: q + f,
                    prevSize: it,
                    ranges: dt
                  };
                }, {
                  prevIndex: f,
                  prevSize: 0,
                  ranges: B
                }).ranges;
              }
              return Gt(d.sizeTree).reduce((L, {
                k: z,
                v: _
              }) => ({
                prevIndex: z + f,
                prevSize: _,
                ranges: [...L.ranges, {
                  endIndex: z + f - 1,
                  size: L.prevSize,
                  startIndex: L.prevIndex
                }]
              }), {
                prevIndex: 0,
                prevSize: k,
                ranges: []
              }).ranges;
            })), n);
            const b = ht(S(i, N$1(v, I), E$1(([f, {
              offsetTree: d
            }, y]) => {
              const B = -f;
              return ie(B, d, y);
            })));
            return O$1(S(i, N$1(v, I), E$1(([f, d, y]) => {
              if (d.groupIndices.length > 0) {
                if (j(d.sizeTree)) return d;
                let k = jt();
                const L = ot(g);
                let z = 0,
                  _ = 0,
                  J = 0;
                for (; z < -f;) {
                  J = L[_];
                  const F = L[_ + 1] - J - 1;
                  _++, z += F + 1;
                }
                if (k = Gt(d.sizeTree).reduce((F, {
                  k: q,
                  v: it
                }) => pt(F, Math.max(0, q + f), it), k), z !== -f) {
                  const F = re(d.sizeTree, J);
                  k = pt(k, 0, F);
                  const q = wt(d.sizeTree, -f + 1)[1];
                  k = pt(k, 1, q);
                }
                return {
                  ...d,
                  sizeTree: k,
                  ...Ae(d.offsetTree, 0, k, y)
                };
              } else {
                const k = Gt(d.sizeTree).reduce((L, {
                  k: z,
                  v: _
                }) => pt(L, Math.max(0, z + f), _), jt());
                return {
                  ...d,
                  sizeTree: k,
                  ...Ae(d.offsetTree, 0, k, y)
                };
              }
            })), v), {
              beforeUnshiftWith: T,
              // input
              data: h,
              defaultItemSize: m,
              firstItemIndex: l,
              fixedItemSize: a,
              gap: I,
              groupIndices: c,
              itemSize: x,
              listRefresh: u,
              shiftWith: i,
              shiftWithOffset: b,
              sizeRanges: n,
              // output
              sizes: v,
              statefulTotalCount: r,
              totalCount: o,
              trackItemSizes: p,
              unshiftWith: s
            };
          }, X(Vt, De), {
            singleton: true
          });
        function Vo(t) {
          return t.reduce((e, n) => (e.groupIndices.push(e.totalCount), e.totalCount += n + 1, e), {
            groupIndices: [],
            totalCount: 0
          });
        }
        const Nn = U$1(([{
            groupIndices: t,
            sizes: e,
            totalCount: n
          }, {
            headerHeight: o,
            scrollTop: r
          }]) => {
            const s = $(),
              i = $(),
              l = ht(S(s, E$1(Vo)));
            return O$1(S(l, E$1(c => c.totalCount)), n), O$1(S(l, E$1(c => c.groupIndices)), t), O$1(S(rt(r, e, o), A$1(([c, a]) => Re(a)), E$1(([c, a, m]) => wt(a.groupOffsetTree, Math.max(c - m, 0), "v")[0]), Y(), E$1(c => [c])), i), {
              groupCounts: s,
              topItemsIndexes: i
            };
          }, X(Et, at)),
          Pt = U$1(([{
            log: t
          }]) => {
            const e = w$1(false),
              n = ht(S(e, A$1(o => o), Y()));
            return K$1(e, o => {
              o && ot(t)("props updated", {}, mt.DEBUG);
            }), {
              didMount: n,
              propsReady: e
            };
          }, X(Vt), {
            singleton: true
          }),
          Po = typeof document < "u" && "scrollBehavior" in document.documentElement.style;
        function Dn(t) {
          const e = typeof t == "number" ? {
            index: t
          } : t;
          return e.align || (e.align = "start"), (!e.behavior || !Po) && (e.behavior = "auto"), e.offset || (e.offset = 0), e;
        }
        const ce = U$1(([{
          gap: t,
          listRefresh: e,
          sizes: n,
          totalCount: o
        }, {
          fixedFooterHeight: r,
          fixedHeaderHeight: s,
          footerHeight: i,
          headerHeight: l,
          scrollingInProgress: c,
          scrollTo: a,
          smoothScrollTargetReached: m,
          viewportHeight: x
        }, {
          log: h
        }]) => {
          const I = $(),
            C = $(),
            v = w$1(0);
          let g = null,
            p = null,
            u = null;
          function T() {
            g && (g(), g = null), u && (u(), u = null), p && (clearTimeout(p), p = null), G$1(c, false);
          }
          return O$1(S(I, N$1(n, x, o, v, l, i, h), N$1(t, s, r), E$1(([[b, f, d, y, B, k, L, z], _, J, nt]) => {
            const F = Dn(b),
              {
                align: q,
                behavior: it,
                offset: dt
              } = F,
              St = y - 1,
              ft = _n(F, f, St);
            let ut = ie(ft, f.offsetTree, _) + k;
            q === "end" ? (ut += J + wt(f.sizeTree, ft)[1] - d + nt, ft === St && (ut += L)) : q === "center" ? ut += (J + wt(f.sizeTree, ft)[1] - d + nt) / 2 : ut -= B, dt && (ut += dt);
            const At = xt => {
              T(), xt ? (z("retrying to scroll to", {
                location: b
              }, mt.DEBUG), G$1(I, b)) : (G$1(C, true), z("list did not change, scroll successful", {}, mt.DEBUG));
            };
            if (T(), it === "smooth") {
              let xt = false;
              u = K$1(e, Xt => {
                xt = xt || Xt;
              }), g = Tt(m, () => {
                At(xt);
              });
            } else g = Tt(S(e, Ao(150)), At);
            return p = setTimeout(() => {
              T();
            }, 1200), G$1(c, true), z("scrolling from index to", {
              behavior: it,
              index: ft,
              top: ut
            }, mt.DEBUG), {
              behavior: it,
              top: ut
            };
          })), a), {
            scrollTargetReached: C,
            scrollToIndex: I,
            topListHeight: v
          };
        }, X(Et, at, Vt), {
          singleton: true
        });
        function Ao(t) {
          return e => {
            const n = setTimeout(() => {
              e(false);
            }, t);
            return o => {
              o && (e(true), clearTimeout(n));
            };
          };
        }
        function Ue(t, e) {
          t == 0 ? e() : requestAnimationFrame(() => {
            Ue(t - 1, e);
          });
        }
        function Ke(t, e) {
          const n = e - 1;
          return typeof t == "number" ? t : t.index === "LAST" ? n : t.index;
        }
        const ue = U$1(([{
          defaultItemSize: t,
          listRefresh: e,
          sizes: n
        }, {
          scrollTop: o
        }, {
          scrollTargetReached: r,
          scrollToIndex: s
        }, {
          didMount: i
        }]) => {
          const l = w$1(true),
            c = w$1(0),
            a = w$1(true);
          return O$1(S(i, N$1(c), A$1(([m, x]) => !!x), Rt(false)), l), O$1(S(i, N$1(c), A$1(([m, x]) => !!x), Rt(false)), a), K$1(S(rt(e, i), N$1(l, n, t, a), A$1(([[, m], x, {
            sizeTree: h
          }, I, C]) => m && (!j(h) || We(I)) && !x && !C), N$1(c)), ([, m]) => {
            Tt(r, () => {
              G$1(a, true);
            }), Ue(4, () => {
              Tt(o, () => {
                G$1(l, true);
              }), G$1(s, m);
            });
          }), {
            initialItemFinalLocationReached: a,
            initialTopMostItemIndex: c,
            scrolledToInitialItem: l
          };
        }, X(Et, at, ce, Pt), {
          singleton: true
        });
        function $n(t, e) {
          return Math.abs(t - e) < 1.01;
        }
        const le = "up",
          te = "down",
          Mo = "none",
          Wo = {
            atBottom: false,
            notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
            state: {
              offsetBottom: 0,
              scrollHeight: 0,
              scrollTop: 0,
              viewportHeight: 0
            }
          },
          Go = 0,
          ae = U$1(([{
            footerHeight: t,
            headerHeight: e,
            scrollBy: n,
            scrollContainerState: o,
            scrollTop: r,
            viewportHeight: s
          }]) => {
            const i = w$1(false),
              l = w$1(true),
              c = $(),
              a = $(),
              m = w$1(4),
              x = w$1(Go),
              h = ct(S(Le(S(V$1(r), Dt(1), Rt(true)), S(V$1(r), Dt(1), Rt(false), dn(100))), Y()), false),
              I = ct(S(Le(S(n, Rt(true)), S(n, Rt(false), dn(200))), Y()), false);
            O$1(S(rt(V$1(r), V$1(x)), E$1(([u, T]) => u <= T), Y()), l), O$1(S(l, kt(50)), a);
            const C = ht(S(rt(o, V$1(s), V$1(e), V$1(t), V$1(m)), bt((u, [{
                scrollHeight: T,
                scrollTop: b
              }, f, d, y, B]) => {
                const k = b + f - T > -B,
                  L = {
                    scrollHeight: T,
                    scrollTop: b,
                    viewportHeight: f
                  };
                if (k) {
                  let _, J;
                  return b > u.state.scrollTop ? (_ = "SCROLLED_DOWN", J = u.state.scrollTop - b) : (_ = "SIZE_DECREASED", J = u.state.scrollTop - b || u.scrollTopDelta), {
                    atBottom: true,
                    atBottomBecause: _,
                    scrollTopDelta: J,
                    state: L
                  };
                }
                let z;
                return L.scrollHeight > u.state.scrollHeight ? z = "SIZE_INCREASED" : f < u.state.viewportHeight ? z = "VIEWPORT_HEIGHT_DECREASING" : b < u.state.scrollTop ? z = "SCROLLING_UPWARDS" : z = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM", {
                  atBottom: false,
                  notAtBottomBecause: z,
                  state: L
                };
              }, Wo), Y((u, T) => u && u.atBottom === T.atBottom))),
              v = ct(S(o, bt((u, {
                scrollHeight: T,
                scrollTop: b,
                viewportHeight: f
              }) => {
                if ($n(u.scrollHeight, T)) return {
                  changed: false,
                  jump: 0,
                  scrollHeight: T,
                  scrollTop: b
                };
                {
                  const d = T - (b + f) < 1;
                  return u.scrollTop !== b && d ? {
                    changed: true,
                    jump: u.scrollTop - b,
                    scrollHeight: T,
                    scrollTop: b
                  } : {
                    changed: true,
                    jump: 0,
                    scrollHeight: T,
                    scrollTop: b
                  };
                }
              }, {
                changed: false,
                jump: 0,
                scrollHeight: 0,
                scrollTop: 0
              }), A$1(u => u.changed), E$1(u => u.jump)), 0);
            O$1(S(C, E$1(u => u.atBottom)), i), O$1(S(i, kt(50)), c);
            const g = w$1(te);
            O$1(S(o, E$1(({
              scrollTop: u
            }) => u), Y(), bt((u, T) => ot(I) ? {
              direction: u.direction,
              prevScrollTop: T
            } : {
              direction: T < u.prevScrollTop ? le : te,
              prevScrollTop: T
            }, {
              direction: te,
              prevScrollTop: 0
            }), E$1(u => u.direction)), g), O$1(S(o, kt(50), Rt(Mo)), g);
            const p = w$1(0);
            return O$1(S(h, A$1(u => !u), Rt(0)), p), O$1(S(r, kt(100), N$1(h), A$1(([u, T]) => !!T), bt(([u, T], [b]) => [T, b], [0, 0]), E$1(([u, T]) => T - u)), p), {
              atBottomState: C,
              atBottomStateChange: c,
              atBottomThreshold: m,
              atTopStateChange: a,
              atTopThreshold: x,
              isAtBottom: i,
              isAtTop: l,
              isScrolling: h,
              lastJumpDueToItemResize: v,
              scrollDirection: g,
              scrollVelocity: p
            };
          }, X(at)),
          xe = "top",
          Te = "bottom",
          hn = "none";
        function gn(t, e, n) {
          return typeof t == "number" ? n === le && e === xe || n === te && e === Te ? t : 0 : n === le ? e === xe ? t.main : t.reverse : e === Te ? t.main : t.reverse;
        }
        function In(t, e) {
          var n;
          return typeof t == "number" ? t : (n = t[e]) != null ? n : 0;
        }
        const je = U$1(([{
          deviation: t,
          fixedHeaderHeight: e,
          headerHeight: n,
          scrollTop: o,
          viewportHeight: r
        }]) => {
          const s = $(),
            i = w$1(0),
            l = w$1(0),
            c = w$1(0),
            a = ct(S(rt(V$1(o), V$1(r), V$1(n), V$1(s, se), V$1(c), V$1(i), V$1(e), V$1(t), V$1(l)), E$1(([m, x, h, [I, C], v, g, p, u, T]) => {
              const b = m - u,
                f = g + p,
                d = Math.max(h - b, 0);
              let y = hn;
              const B = In(T, xe),
                k = In(T, Te);
              return I -= u, I += h + p, C += h + p, C -= u, I > m + f - B && (y = le), C < m - d + x + k && (y = te), y !== hn ? [Math.max(b - h - gn(v, xe, y) - B, 0), b - d - p + x + gn(v, Te, y) + k] : null;
            }), A$1(m => m != null), Y(se)), [0, 0]);
          return {
            increaseViewportBy: l,
            // input
            listBoundary: s,
            overscan: c,
            topListHeight: i,
            // output
            visibleRange: a
          };
        }, X(at), {
          singleton: true
        });
        function _o(t, e, n) {
          if (Re(e)) {
            const o = Gn(t, e);
            return [{
              index: wt(e.groupOffsetTree, o)[0],
              offset: 0,
              size: 0
            }, {
              data: n == null ? void 0 : n[0],
              index: o,
              offset: 0,
              size: 0
            }];
          }
          return [{
            data: n == null ? void 0 : n[0],
            index: t,
            offset: 0,
            size: 0
          }];
        }
        const Be = {
          bottom: 0,
          firstItemIndex: 0,
          items: [],
          offsetBottom: 0,
          offsetTop: 0,
          top: 0,
          topItems: [],
          topListHeight: 0,
          totalCount: 0
        };
        function Ie(t, e, n, o, r, s) {
          const {
            lastIndex: i,
            lastOffset: l,
            lastSize: c
          } = r;
          let a = 0,
            m = 0;
          if (t.length > 0) {
            a = t[0].offset;
            const v = t[t.length - 1];
            m = v.offset + v.size;
          }
          const x = n - i,
            h = l + x * c + (x - 1) * o,
            I = a,
            C = h - m;
          return {
            bottom: m,
            firstItemIndex: s,
            items: Sn(t, r, s),
            offsetBottom: C,
            offsetTop: a,
            top: I,
            topItems: Sn(e, r, s),
            topListHeight: e.reduce((v, g) => g.size + v, 0),
            totalCount: n
          };
        }
        function Un(t, e, n, o, r, s) {
          let i = 0;
          if (n.groupIndices.length > 0) for (const m of n.groupIndices) {
            if (m - i >= t) break;
            i++;
          }
          const l = t + i,
            c = Ke(e, l),
            a = Array.from({
              length: l
            }).map((m, x) => ({
              data: s[x + c],
              index: x + c,
              offset: 0,
              size: 0
            }));
          return Ie(a, [], l, r, n, o);
        }
        function Sn(t, e, n) {
          if (t.length === 0) return [];
          if (!Re(e)) return t.map(a => ({
            ...a,
            index: a.index + n,
            originalIndex: a.index
          }));
          const o = t[0].index,
            r = t[t.length - 1].index,
            s = [],
            i = ye(e.groupOffsetTree, o, r);
          let l,
            c = 0;
          for (const a of t) {
            (!l || l.end < a.index) && (l = i.shift(), c = e.groupIndices.indexOf(l.start));
            let m;
            a.index === l.start ? m = {
              index: c,
              type: "group"
            } : m = {
              groupIndex: c,
              index: a.index - (c + 1) + n
            }, s.push({
              ...m,
              data: a.data,
              offset: a.offset,
              originalIndex: a.index,
              size: a.size
            });
          }
          return s;
        }
        const $t = U$1(([{
            data: t,
            firstItemIndex: e,
            gap: n,
            sizes: o,
            totalCount: r
          }, s, {
            listBoundary: i,
            topListHeight: l,
            visibleRange: c
          }, {
            initialTopMostItemIndex: a,
            scrolledToInitialItem: m
          }, {
            topListHeight: x
          }, h, {
            didMount: I
          }, {
            recalcInProgress: C
          }]) => {
            const v = w$1([]),
              g = w$1(0),
              p = $();
            O$1(s.topItemsIndexes, v);
            const u = ct(S(rt(I, C, V$1(c, se), V$1(r), V$1(o), V$1(a), m, V$1(v), V$1(e), V$1(n), t), A$1(([d, y,, B,,,,,,, k]) => {
              const L = k && k.length !== B;
              return d && !y && !L;
            }), E$1(([,, [d, y], B, k, L, z, _, J, nt, F]) => {
              const q = k,
                {
                  offsetTree: it,
                  sizeTree: dt
                } = q,
                St = ot(g);
              if (B === 0) return {
                ...Be,
                totalCount: B
              };
              if (d === 0 && y === 0) return St === 0 ? {
                ...Be,
                totalCount: B
              } : Un(St, L, k, J, nt, F || []);
              if (j(dt)) return St > 0 ? null : Ie(_o(Ke(L, B), q, F), [], B, nt, q, J);
              const ft = [];
              if (_.length > 0) {
                const Mt = _[0],
                  yt = _[_.length - 1];
                let Bt = 0;
                for (const R of ye(dt, Mt, yt)) {
                  const D = R.value,
                    Q = Math.max(R.start, Mt),
                    lt = Math.min(R.end, yt);
                  for (let tt = Q; tt <= lt; tt++) ft.push({
                    data: F == null ? void 0 : F[tt],
                    index: tt,
                    offset: Bt,
                    size: D
                  }), Bt += D;
                }
              }
              if (!z) return Ie([], ft, B, nt, q, J);
              const ut = _.length > 0 ? _[_.length - 1] + 1 : 0,
                At = Bo(it, d, y, ut);
              if (At.length === 0) return null;
              const xt = B - 1,
                Xt = ve([], Mt => {
                  for (const yt of At) {
                    const Bt = yt.value;
                    let R = Bt.offset,
                      D = yt.start;
                    const Q = Bt.size;
                    if (Bt.offset < d) {
                      D += Math.floor((d - Bt.offset + nt) / (Q + nt));
                      const tt = D - yt.start;
                      R += tt * Q + tt * nt;
                    }
                    D < ut && (R += (ut - D) * Q, D = ut);
                    const lt = Math.min(yt.end, xt);
                    for (let tt = D; tt <= lt && !(R >= y); tt++) Mt.push({
                      data: F == null ? void 0 : F[tt],
                      index: tt,
                      offset: R,
                      size: Q
                    }), R += Q + nt;
                  }
                });
              return Ie(Xt, ft, B, nt, q, J);
            }),
            //@ts-expect-error filter needs to be fixed
            A$1(d => d !== null), Y()), Be);
            O$1(S(t, A$1(We), E$1(d => d == null ? void 0 : d.length)), r), O$1(S(u, E$1(d => d.topListHeight)), x), O$1(x, l), O$1(S(u, E$1(d => [d.top, d.bottom])), i), O$1(S(u, E$1(d => d.items)), p);
            const T = ht(S(u, A$1(({
                items: d
              }) => d.length > 0), N$1(r, t), A$1(([{
                items: d
              }, y]) => d[d.length - 1].originalIndex === y - 1), E$1(([, d, y]) => [d - 1, y]), Y(se), E$1(([d]) => d))),
              b = ht(S(u, kt(200), A$1(({
                items: d,
                topItems: y
              }) => d.length > 0 && d[0].originalIndex === y.length), E$1(({
                items: d
              }) => d[0].index), Y())),
              f = ht(S(u, A$1(({
                items: d
              }) => d.length > 0), E$1(({
                items: d
              }) => {
                let y = 0,
                  B = d.length - 1;
                for (; d[y].type === "group" && y < B;) y++;
                for (; d[B].type === "group" && B > y;) B--;
                return {
                  endIndex: d[B].index,
                  startIndex: d[y].index
                };
              }), Y(Mn)));
            return {
              endReached: T,
              initialItemCount: g,
              itemsRendered: p,
              listState: u,
              rangeChanged: f,
              startReached: b,
              topItemsIndexes: v,
              ...h
            };
          }, X(Et, Nn, je, ue, ce, ae, Pt, De), {
            singleton: true
          }),
          Kn = U$1(([{
            fixedFooterHeight: t,
            fixedHeaderHeight: e,
            footerHeight: n,
            headerHeight: o
          }, {
            listState: r
          }]) => {
            const s = $(),
              i = ct(S(rt(n, t, o, e, r), E$1(([l, c, a, m, x]) => l + c + a + m + x.offsetBottom + x.bottom)), 0);
            return O$1(V$1(i), s), {
              totalListHeight: i,
              totalListHeightChanged: s
            };
          }, X(at, $t), {
            singleton: true
          }),
          No = U$1(([{
            viewportHeight: t
          }, {
            totalListHeight: e
          }]) => {
            const n = w$1(false),
              o = ct(S(rt(n, t, e), A$1(([r]) => r), E$1(([, r, s]) => Math.max(0, r - s)), kt(0), Y()), 0);
            return {
              alignToBottom: n,
              paddingTopAddition: o
            };
          }, X(at, Kn), {
            singleton: true
          }),
          jn = U$1(() => ({
            context: w$1(null)
          })),
          Do = ({
            itemBottom: t,
            itemTop: e,
            locationParams: {
              align: n,
              behavior: o,
              ...r
            },
            viewportBottom: s,
            viewportTop: i
          }) => e < i ? {
            ...r,
            align: n != null ? n : "start",
            behavior: o
          } : t > s ? {
            ...r,
            align: n != null ? n : "end",
            behavior: o
          } : null,
          qn = U$1(([{
            gap: t,
            sizes: e,
            totalCount: n
          }, {
            fixedFooterHeight: o,
            fixedHeaderHeight: r,
            headerHeight: s,
            scrollingInProgress: i,
            scrollTop: l,
            viewportHeight: c
          }, {
            scrollToIndex: a
          }]) => {
            const m = $();
            return O$1(S(m, N$1(e, c, n, s, r, o, l), N$1(t), E$1(([[x, h, I, C, v, g, p, u], T]) => {
              const {
                  align: b,
                  behavior: f,
                  calculateViewLocation: d = Do,
                  done: y,
                  ...B
                } = x,
                k = _n(x, h, C - 1),
                L = ie(k, h.offsetTree, T) + v + g,
                z = L + wt(h.sizeTree, k)[1],
                _ = u + g,
                J = u + I - p,
                nt = d({
                  itemBottom: z,
                  itemTop: L,
                  locationParams: {
                    align: b,
                    behavior: f,
                    ...B
                  },
                  viewportBottom: J,
                  viewportTop: _
                });
              return nt ? y && Tt(S(i, A$1(F => !F),
              // skips the initial publish of false, and the cleanup call.
              // but if scrollingInProgress is true, we skip the initial publish.
              Dt(ot(i) ? 1 : 2)), y) : y && y(), nt;
            }), A$1(x => x !== null)), a), {
              scrollIntoView: m
            };
          }, X(Et, at, ce, $t, Vt), {
            singleton: true
          });
        function xn(t) {
          return t ? t === "smooth" ? "smooth" : "auto" : false;
        }
        const $o = (t, e) => typeof t == "function" ? xn(t(e)) : e && xn(t),
          Uo = U$1(([{
            listRefresh: t,
            totalCount: e,
            fixedItemSize: n,
            data: o
          }, {
            atBottomState: r,
            isAtBottom: s
          }, {
            scrollToIndex: i
          }, {
            scrolledToInitialItem: l
          }, {
            didMount: c,
            propsReady: a
          }, {
            log: m
          }, {
            scrollingInProgress: x
          }, {
            context: h
          }, {
            scrollIntoView: I
          }]) => {
            const C = w$1(false),
              v = $();
            let g = null;
            function p(f) {
              G$1(i, {
                align: "end",
                behavior: f,
                index: "LAST"
              });
            }
            K$1(S(rt(S(V$1(e), Dt(1)), c), N$1(V$1(C), s, l, x), E$1(([[f, d], y, B, k, L]) => {
              let z = d && k,
                _ = "auto";
              return z && (_ = $o(y, B || L), z = z && !!_), {
                followOutputBehavior: _,
                shouldFollow: z,
                totalCount: f
              };
            }), A$1(({
              shouldFollow: f
            }) => f)), ({
              followOutputBehavior: f,
              totalCount: d
            }) => {
              g && (g(), g = null), ot(n) ? requestAnimationFrame(() => {
                ot(m)("following output to ", {
                  totalCount: d
                }, mt.DEBUG), p(f);
              }) : g = Tt(t, () => {
                ot(m)("following output to ", {
                  totalCount: d
                }, mt.DEBUG), p(f), g = null;
              });
            });
            function u(f) {
              const d = Tt(r, y => {
                f && !y.atBottom && y.notAtBottomBecause === "SIZE_INCREASED" && !g && (ot(m)("scrolling to bottom due to increased size", {}, mt.DEBUG), p("auto"));
              });
              setTimeout(d, 100);
            }
            K$1(S(rt(V$1(C), e, a), A$1(([f,, d]) => f && d), bt(({
              value: f
            }, [, d]) => ({
              refreshed: f === d,
              value: d
            }), {
              refreshed: false,
              value: 0
            }), A$1(({
              refreshed: f
            }) => f), N$1(C, e)), ([, f]) => {
              ot(l) && u(f !== false);
            }), K$1(v, () => {
              u(ot(C) !== false);
            }), K$1(rt(V$1(C), r), ([f, d]) => {
              f && !d.atBottom && d.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && p("auto");
            });
            const T = w$1(null),
              b = $();
            return O$1(Le(S(V$1(o), E$1(f => {
              var d;
              return (d = f == null ? void 0 : f.length) != null ? d : 0;
            })), S(V$1(e))), b), K$1(S(rt(S(b, Dt(1)), c), N$1(V$1(T), l, x, h), E$1(([[f, d], y, B, k, L]) => d && B && (y == null ? void 0 : y({
              context: L,
              totalCount: f,
              scrollingInProgress: k
            }))), A$1(f => !!f), kt(0)), f => {
              g && (g(), g = null), ot(n) ? requestAnimationFrame(() => {
                ot(m)("scrolling into view", {}), G$1(I, f);
              }) : g = Tt(t, () => {
                ot(m)("scrolling into view", {}), G$1(I, f), g = null;
              });
            }), {
              autoscrollToBottom: v,
              followOutput: C,
              scrollIntoViewOnChange: T
            };
          }, X(Et, ae, ce, ue, Pt, Vt, at, jn, qn)),
          Ko = U$1(([{
            data: t,
            firstItemIndex: e,
            gap: n,
            sizes: o
          }, {
            initialTopMostItemIndex: r
          }, {
            initialItemCount: s,
            listState: i
          }, {
            didMount: l
          }]) => (O$1(S(l, N$1(s), A$1(([, c]) => c !== 0), N$1(r, o, e, n, t), E$1(([[, c], a, m, x, h, I = []]) => Un(c, a, m, x, h, I))), i), {}), X(Et, ue, $t, Pt), {
            singleton: true
          }),
          jo = U$1(([{
            didMount: t
          }, {
            scrollTo: e
          }, {
            listState: n
          }]) => {
            const o = w$1(0);
            return K$1(S(t, N$1(o), A$1(([, r]) => r !== 0), E$1(([, r]) => ({
              top: r
            }))), r => {
              Tt(S(n, Dt(1), A$1(s => s.items.length > 1)), () => {
                requestAnimationFrame(() => {
                  G$1(e, r);
                });
              });
            }), {
              initialScrollTop: o
            };
          }, X(Pt, at, $t), {
            singleton: true
          }),
          Yn = U$1(([{
            scrollVelocity: t
          }]) => {
            const e = w$1(false),
              n = $(),
              o = w$1(false);
            return O$1(S(t, N$1(o, e, n), A$1(([r, s]) => !!s), E$1(([r, s, i, l]) => {
              const {
                enter: c,
                exit: a
              } = s;
              if (i) {
                if (a(r, l)) return false;
              } else if (c(r, l)) return true;
              return i;
            }), Y()), e), K$1(S(rt(e, t, n), N$1(o)), ([[r, s, i], l]) => {
              r && l && l.change && l.change(s, i);
            }), {
              isSeeking: e,
              scrollSeekConfiguration: o,
              scrollSeekRangeChanged: n,
              scrollVelocity: t
            };
          }, X(ae), {
            singleton: true
          }),
          qe = U$1(([{
            scrollContainerState: t,
            scrollTo: e
          }]) => {
            const n = $(),
              o = $(),
              r = $(),
              s = w$1(false),
              i = w$1(void 0);
            return O$1(S(rt(n, o), E$1(([{
              scrollHeight: l,
              scrollTop: c,
              viewportHeight: a
            }, {
              offsetTop: m
            }]) => ({
              scrollHeight: l,
              scrollTop: Math.max(0, c - m),
              viewportHeight: a
            }))), t), O$1(S(e, N$1(o), E$1(([l, {
              offsetTop: c
            }]) => ({
              ...l,
              top: l.top + c
            }))), r), {
              customScrollParent: i,
              // config
              useWindowScroll: s,
              // input
              windowScrollContainerState: n,
              // signals
              windowScrollTo: r,
              windowViewportRect: o
            };
          }, X(at)),
          qo = U$1(([{
            sizeRanges: t,
            sizes: e
          }, {
            headerHeight: n,
            scrollTop: o
          }, {
            initialTopMostItemIndex: r
          }, {
            didMount: s
          }, {
            useWindowScroll: i,
            windowScrollContainerState: l,
            windowViewportRect: c
          }]) => {
            const a = $(),
              m = w$1(void 0),
              x = w$1(null),
              h = w$1(null);
            return O$1(l, x), O$1(c, h), K$1(S(a, N$1(e, o, i, x, h, n)), ([I, C, v, g, p, u, T]) => {
              const b = Fo(C.sizeTree);
              g && p !== null && u !== null && (v = p.scrollTop - u.offsetTop), v -= T, I({
                ranges: b,
                scrollTop: v
              });
            }), O$1(S(m, A$1(We), E$1(Yo)), r), O$1(S(s, N$1(m), A$1(([, I]) => I !== void 0), Y(), E$1(([, I]) => I.ranges)), t), {
              getState: a,
              restoreStateFrom: m
            };
          }, X(Et, at, ue, Pt, qe));
        function Yo(t) {
          return {
            align: "start",
            index: 0,
            offset: t.scrollTop
          };
        }
        const Zo = U$1(([{
          topItemsIndexes: t
        }]) => {
          const e = w$1(0);
          return O$1(S(e, A$1(n => n >= 0), E$1(n => Array.from({
            length: n
          }).map((o, r) => r))), t), {
            topItemCount: e
          };
        }, X($t));
        function Zn(t) {
          let e = false,
            n;
          return () => (e || (e = true, n = t()), n);
        }
        const Xo = Zn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent)),
          Jo = U$1(([{
            deviation: t,
            scrollBy: e,
            scrollingInProgress: n,
            scrollTop: o
          }, {
            isAtBottom: r,
            isScrolling: s,
            lastJumpDueToItemResize: i,
            scrollDirection: l
          }, {
            listState: c
          }, {
            beforeUnshiftWith: a,
            gap: m,
            shiftWithOffset: x,
            sizes: h
          }, {
            log: I
          }, {
            recalcInProgress: C
          }]) => {
            const v = ht(S(c, N$1(i), bt(([, p, u, T], [{
              bottom: b,
              items: f,
              offsetBottom: d,
              totalCount: y
            }, B]) => {
              const k = b + d;
              let L = 0;
              return u === y && p.length > 0 && f.length > 0 && (f[0].originalIndex === 0 && p[0].originalIndex === 0 || (L = k - T, L !== 0 && (L += B))), [L, f, y, k];
            }, [0, [], 0, 0]), A$1(([p]) => p !== 0), N$1(o, l, n, r, I, C), A$1(([, p, u, T,,, b]) => !b && !T && p !== 0 && u === le), E$1(([[p],,,,, u]) => (u("Upward scrolling compensation", {
              amount: p
            }, mt.DEBUG), p))));
            function g(p) {
              p > 0 ? (G$1(e, {
                behavior: "auto",
                top: -p
              }), G$1(t, 0)) : (G$1(t, 0), G$1(e, {
                behavior: "auto",
                top: -p
              }));
            }
            return K$1(S(v, N$1(t, s)), ([p, u, T]) => {
              T && Xo() ? G$1(t, u - p) : g(-p);
            }), K$1(S(rt(ct(s, false), t, C), A$1(([p, u, T]) => !p && !T && u !== 0), E$1(([p, u]) => u), kt(1)), g), O$1(S(x, E$1(p => ({
              top: -p
            }))), e), K$1(S(a, N$1(h, m), E$1(([p, {
              groupIndices: u,
              lastSize: T,
              sizeTree: b
            }, f]) => {
              function d(y) {
                return y * (T + f);
              }
              if (u.length === 0) return d(p);
              {
                let y = 0;
                const B = re(b, 0);
                let k = 0,
                  L = 0;
                for (; k < p;) {
                  k++, y += B;
                  let z = u.length === L + 1 ? 1 / 0 : u[L + 1] - u[L] - 1;
                  k + z > p && (y -= B, z = p - k + 1), k += z, y += d(z), L++;
                }
                return y;
              }
            })), p => {
              G$1(t, p), requestAnimationFrame(() => {
                G$1(e, {
                  top: p
                }), requestAnimationFrame(() => {
                  G$1(t, 0), G$1(C, false);
                });
              });
            }), {
              deviation: t
            };
          }, X(at, ae, $t, Et, Vt, De)),
          Qo = U$1(([t, e, n, o, r, s, i, l, c, a, m]) => ({
            ...t,
            ...e,
            ...n,
            ...o,
            ...r,
            ...s,
            ...i,
            ...l,
            ...c,
            ...a,
            ...m
          }), X(je, Ko, Pt, Yn, Kn, jo, No, qe, qn, Vt, jn)),
          Xn = U$1(([{
            data: t,
            defaultItemSize: e,
            firstItemIndex: n,
            fixedItemSize: o,
            gap: r,
            groupIndices: s,
            itemSize: i,
            sizeRanges: l,
            sizes: c,
            statefulTotalCount: a,
            totalCount: m,
            trackItemSizes: x
          }, {
            initialItemFinalLocationReached: h,
            initialTopMostItemIndex: I,
            scrolledToInitialItem: C
          }, v, g, p, {
            listState: u,
            topItemsIndexes: T,
            ...b
          }, {
            scrollToIndex: f
          }, d, {
            topItemCount: y
          }, {
            groupCounts: B
          }, k]) => (O$1(b.rangeChanged, k.scrollSeekRangeChanged), O$1(S(k.windowViewportRect, E$1(L => L.visibleHeight)), v.viewportHeight), {
            data: t,
            defaultItemHeight: e,
            firstItemIndex: n,
            fixedItemHeight: o,
            gap: r,
            groupCounts: B,
            initialItemFinalLocationReached: h,
            initialTopMostItemIndex: I,
            scrolledToInitialItem: C,
            sizeRanges: l,
            topItemCount: y,
            topItemsIndexes: T,
            // input
            totalCount: m,
            ...p,
            groupIndices: s,
            itemSize: i,
            listState: u,
            scrollToIndex: f,
            // output
            statefulTotalCount: a,
            trackItemSizes: x,
            // exported from stateFlagsSystem
            ...b,
            // the bag of IO from featureGroup1System
            ...k,
            ...v,
            sizes: c,
            ...g
          }), X(Et, ue, at, qo, Uo, $t, ce, Jo, Zo, Nn, Qo));
        function tr(t, e) {
          const n = {},
            o = {};
          let r = 0;
          const s = t.length;
          for (; r < s;) o[t[r]] = 1, r += 1;
          for (const i in e) Object.hasOwn(o, i) || (n[i] = e[i]);
          return n;
        }
        const pe = typeof document < "u" ? React.useLayoutEffect : React.useEffect;
        function Ye(t, e, n) {
          const o = Object.keys(e.required || {}),
            r = Object.keys(e.optional || {}),
            s = Object.keys(e.methods || {}),
            i = Object.keys(e.events || {}),
            l = React.createContext({});
          function c(p, u) {
            p.propsReady && G$1(p.propsReady, false);
            for (const T of o) {
              const b = p[e.required[T]];
              G$1(b, u[T]);
            }
            for (const T of r) if (T in u) {
              const b = p[e.optional[T]];
              G$1(b, u[T]);
            }
            p.propsReady && G$1(p.propsReady, true);
          }
          function a(p) {
            return s.reduce((u, T) => (u[T] = b => {
              const f = p[e.methods[T]];
              G$1(f, b);
            }, u), {});
          }
          function m(p) {
            return i.reduce((u, T) => (u[T] = Io(p[e.events[T]]), u), {});
          }
          const x = React.forwardRef((p, u) => {
              const {
                  children: T,
                  ...b
                } = p,
                [f] = React.useState(() => ve(xo(t), B => {
                  c(B, b);
                })),
                [d] = React.useState(an(m, f));
              pe(() => {
                for (const B of i) B in b && K$1(d[B], b[B]);
                return () => {
                  Object.values(d).map(Ge);
                };
              }, [b, d, f]), pe(() => {
                c(f, b);
              }), React.useImperativeHandle(u, un(a(f)));
              const y = n;
              return /* @__PURE__ */jsxRuntimeExports.jsx(l.Provider, {
                value: f,
                children: n ? /* @__PURE__ */jsxRuntimeExports.jsx(y, {
                  ...tr([...o, ...r, ...i], b),
                  children: T
                }) : T
              });
            }),
            h = p => {
              const u = React.useContext(l);
              return React.useCallback(T => {
                G$1(u[p], T);
              }, [u, p]);
            },
            I = p => {
              const T = React.useContext(l)[p],
                b = React.useCallback(f => K$1(T, f), [T]);
              return React.useSyncExternalStore(b, () => ot(T), () => ot(T));
            },
            C = p => {
              const T = React.useContext(l)[p],
                [b, f] = React.useState(an(ot, T));
              return pe(() => K$1(T, d => {
                d !== b && f(un(d));
              }), [T, b]), b;
            },
            v = React.version.startsWith("18") ? I : C;
          return {
            Component: x,
            useEmitter: (p, u) => {
              const b = React.useContext(l)[p];
              pe(() => K$1(b, u), [u, b]);
            },
            useEmitterValue: v,
            usePublisher: h
          };
        }
        const be = React.createContext(void 0),
          Jn = React.createContext(void 0),
          Qn = typeof document < "u" ? React.useLayoutEffect : React.useEffect;
        function ke(t) {
          return "self" in t;
        }
        function er(t) {
          return "body" in t;
        }
        function to(t, e, n, o = Yt, r, s) {
          const i = React.useRef(null),
            l = React.useRef(null),
            c = React.useRef(null),
            a = React.useCallback(h => {
              let I, C, v;
              const g = h.target;
              if (er(g) || ke(g)) {
                const u = ke(g) ? g : g.defaultView;
                v = s ? u.scrollX : u.scrollY, I = s ? u.document.documentElement.scrollWidth : u.document.documentElement.scrollHeight, C = s ? u.innerWidth : u.innerHeight;
              } else v = s ? g.scrollLeft : g.scrollTop, I = s ? g.scrollWidth : g.scrollHeight, C = s ? g.offsetWidth : g.offsetHeight;
              const p = () => {
                t({
                  scrollHeight: I,
                  scrollTop: Math.max(v, 0),
                  viewportHeight: C
                });
              };
              h.suppressFlushSync ? p() : ao.flushSync(p), l.current !== null && (v === l.current || v <= 0 || v === I - C) && (l.current = null, e(true), c.current && (clearTimeout(c.current), c.current = null));
            }, [t, e, s]);
          React.useEffect(() => {
            const h = r || i.current;
            return o(r || i.current), a({
              suppressFlushSync: true,
              target: h
            }), h.addEventListener("scroll", a, {
              passive: true
            }), () => {
              o(null), h.removeEventListener("scroll", a);
            };
          }, [i, a, n, o, r]);
          function m(h) {
            const I = i.current;
            if (!I || (s ? "offsetWidth" in I && I.offsetWidth === 0 : "offsetHeight" in I && I.offsetHeight === 0)) return;
            const C = h.behavior === "smooth";
            let v, g, p;
            ke(I) ? (g = Math.max(vt(I.document.documentElement, s ? "width" : "height"), s ? I.document.documentElement.scrollWidth : I.document.documentElement.scrollHeight), v = s ? I.innerWidth : I.innerHeight, p = s ? window.scrollX : window.scrollY) : (g = I[s ? "scrollWidth" : "scrollHeight"], v = vt(I, s ? "width" : "height"), p = I[s ? "scrollLeft" : "scrollTop"]);
            const u = g - v;
            if (h.top = Math.ceil(Math.max(Math.min(u, h.top), 0)), $n(v, g) || h.top === p) {
              t({
                scrollHeight: g,
                scrollTop: p,
                viewportHeight: v
              }), C && e(true);
              return;
            }
            C ? (l.current = h.top, c.current && clearTimeout(c.current), c.current = setTimeout(() => {
              c.current = null, l.current = null, e(true);
            }, 1e3)) : l.current = null, s && (h = {
              behavior: h.behavior,
              left: h.top
            }), I.scrollTo(h);
          }
          function x(h) {
            s && (h = {
              behavior: h.behavior,
              left: h.top
            }), i.current.scrollBy(h);
          }
          return {
            scrollByCallback: x,
            scrollerRef: i,
            scrollToCallback: m
          };
        }
        const Fe = "-webkit-sticky",
          Tn = "sticky",
          Ze = Zn(() => {
            if (typeof document > "u") return Tn;
            const t = document.createElement("div");
            return t.style.position = Fe, t.style.position === Fe ? Fe : Tn;
          });
        function Xe(t) {
          return t;
        }
        const nr = /* @__PURE__ */U$1(() => {
            const t = w$1(l => `Item ${l}`),
              e = w$1(l => `Group ${l}`),
              n = w$1({}),
              o = w$1(Xe),
              r = w$1("div"),
              s = w$1(Yt),
              i = (l, c = null) => ct(S(n, E$1(a => a[l]), Y()), c);
            return {
              components: n,
              computeItemKey: o,
              EmptyPlaceholder: i("EmptyPlaceholder"),
              FooterComponent: i("Footer"),
              GroupComponent: i("Group", "div"),
              groupContent: e,
              HeaderComponent: i("Header"),
              HeaderFooterTag: r,
              ItemComponent: i("Item", "div"),
              itemContent: t,
              ListComponent: i("List", "div"),
              ScrollerComponent: i("Scroller", "div"),
              scrollerRef: s,
              ScrollSeekPlaceholder: i("ScrollSeekPlaceholder"),
              TopItemListComponent: i("TopItemList")
            };
          }),
          or = /* @__PURE__ */U$1(([t, e]) => ({
            ...t,
            ...e
          }), X(Xn, nr)),
          rr = ({
            height: t
          }) => /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            style: {
              height: t
            }
          }),
          sr = {
            overflowAnchor: "none",
            position: Ze(),
            zIndex: 1
          },
          eo = {
            overflowAnchor: "none"
          },
          ir = {
            ...eo,
            display: "inline-block",
            height: "100%"
          },
          Cn = /* @__PURE__ */React.memo(function ({
            showTopList: e = false
          }) {
            const n = M("listState"),
              o = gt("sizeRanges"),
              r = M("useWindowScroll"),
              s = M("customScrollParent"),
              i = gt("windowScrollContainerState"),
              l = gt("scrollContainerState"),
              c = s || r ? i : l,
              a = M("itemContent"),
              m = M("context"),
              x = M("groupContent"),
              h = M("trackItemSizes"),
              I = M("itemSize"),
              C = M("log"),
              v = gt("gap"),
              g = M("horizontalDirection"),
              {
                callbackRef: p
              } = On(o, I, h, e ? Yt : c, C, v, s, g, M("skipAnimationFrameInResizeObserver")),
              [u, T] = React.useState(0);
            tn("deviation", F => {
              u !== F && T(F);
            });
            const b = M("EmptyPlaceholder"),
              f = M("ScrollSeekPlaceholder") || rr,
              d = M("ListComponent"),
              y = M("ItemComponent"),
              B = M("GroupComponent"),
              k = M("computeItemKey"),
              L = M("isSeeking"),
              z = M("groupIndices").length > 0,
              _ = M("alignToBottom"),
              J = M("initialItemFinalLocationReached"),
              nt = e ? {} : {
                boxSizing: "border-box",
                ...(g ? {
                  display: "inline-block",
                  height: "100%",
                  marginLeft: u !== 0 ? u : _ ? "auto" : 0,
                  paddingLeft: n.offsetTop,
                  paddingRight: n.offsetBottom,
                  whiteSpace: "nowrap"
                } : {
                  marginTop: u !== 0 ? u : _ ? "auto" : 0,
                  paddingBottom: n.offsetBottom,
                  paddingTop: n.offsetTop
                }),
                ...(J ? {} : {
                  visibility: "hidden"
                })
              };
            return !e && n.totalCount === 0 && b ? /* @__PURE__ */jsxRuntimeExports.jsx(b, {
              ...Z(b, m)
            }) : /* @__PURE__ */jsxRuntimeExports.jsx(d, {
              ...Z(d, m),
              "data-testid": e ? "virtuoso-top-item-list" : "virtuoso-item-list",
              ref: p,
              style: nt,
              children: (e ? n.topItems : n.items).map(F => {
                const q = F.originalIndex,
                  it = k(q + n.firstItemIndex, F.data, m);
                return L ? /* @__PURE__ */reactExports.createElement(f, {
                  ...Z(f, m),
                  height: F.size,
                  index: F.index,
                  key: it,
                  type: F.type || "item",
                  ...(F.type === "group" ? {} : {
                    groupIndex: F.groupIndex
                  })
                }) : F.type === "group" ? /* @__PURE__ */reactExports.createElement(B, {
                  ...Z(B, m),
                  "data-index": q,
                  "data-item-index": F.index,
                  "data-known-size": F.size,
                  key: it,
                  style: sr
                }, x(F.index, m)) : /* @__PURE__ */reactExports.createElement(y, {
                  ...Z(y, m),
                  ...no(y, F.data),
                  "data-index": q,
                  "data-item-group-index": F.groupIndex,
                  "data-item-index": F.index,
                  "data-known-size": F.size,
                  key: it,
                  style: g ? ir : eo
                }, z ? a(F.index, F.groupIndex, F.data, m) : a(F.index, F.data, m));
              })
            });
          }),
          lr = {
            height: "100%",
            outline: "none",
            overflowY: "auto",
            position: "relative",
            WebkitOverflowScrolling: "touch"
          },
          cr = {
            outline: "none",
            overflowX: "auto",
            position: "relative"
          },
          Zt = t => ({
            height: "100%",
            position: "absolute",
            top: 0,
            width: "100%",
            ...(t ? {
              display: "flex",
              flexDirection: "column"
            } : {})
          }),
          ur = {
            position: Ze(),
            top: 0,
            width: "100%",
            zIndex: 1
          };
        function Z(t, e) {
          if (typeof t != "string") return {
            context: e
          };
        }
        function no(t, e) {
          return {
            item: typeof t == "string" ? void 0 : e
          };
        }
        const ar = /* @__PURE__ */React.memo(function () {
            const e = M("HeaderComponent"),
              n = gt("headerHeight"),
              o = M("HeaderFooterTag"),
              r = Ht(React.useMemo(() => i => {
                n(vt(i, "height"));
              }, [n]), true, M("skipAnimationFrameInResizeObserver")),
              s = M("context");
            return e ? /* @__PURE__ */jsxRuntimeExports.jsx(o, {
              ref: r,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(e, {
                ...Z(e, s)
              })
            }) : null;
          }),
          dr = /* @__PURE__ */React.memo(function () {
            const e = M("FooterComponent"),
              n = gt("footerHeight"),
              o = M("HeaderFooterTag"),
              r = Ht(React.useMemo(() => i => {
                n(vt(i, "height"));
              }, [n]), true, M("skipAnimationFrameInResizeObserver")),
              s = M("context");
            return e ? /* @__PURE__ */jsxRuntimeExports.jsx(o, {
              ref: r,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(e, {
                ...Z(e, s)
              })
            }) : null;
          });
        function Je({
          useEmitter: t,
          useEmitterValue: e,
          usePublisher: n
        }) {
          return React.memo(function ({
            children: s,
            style: i,
            context: l,
            ...c
          }) {
            const a = n("scrollContainerState"),
              m = e("ScrollerComponent"),
              x = n("smoothScrollTargetReached"),
              h = e("scrollerRef"),
              I = e("horizontalDirection") || false,
              {
                scrollByCallback: C,
                scrollerRef: v,
                scrollToCallback: g
              } = to(a, x, m, h, void 0, I);
            return t("scrollTo", g), t("scrollBy", C), /* @__PURE__ */jsxRuntimeExports.jsx(m, {
              "data-testid": "virtuoso-scroller",
              "data-virtuoso-scroller": true,
              ref: v,
              style: {
                ...(I ? cr : lr),
                ...i
              },
              tabIndex: 0,
              ...c,
              ...Z(m, l),
              children: s
            });
          });
        }
        function Qe({
          useEmitter: t,
          useEmitterValue: e,
          usePublisher: n
        }) {
          return React.memo(function ({
            children: s,
            style: i,
            context: l,
            ...c
          }) {
            const a = n("windowScrollContainerState"),
              m = e("ScrollerComponent"),
              x = n("smoothScrollTargetReached"),
              h = e("totalListHeight"),
              I = e("deviation"),
              C = e("customScrollParent"),
              v = React.useRef(null),
              g = e("scrollerRef"),
              {
                scrollByCallback: p,
                scrollerRef: u,
                scrollToCallback: T
              } = to(a, x, m, g, C);
            return Qn(() => {
              var b;
              return u.current = C || ((b = v.current) == null ? void 0 : b.ownerDocument.defaultView), () => {
                u.current = null;
              };
            }, [u, C]), t("windowScrollTo", T), t("scrollBy", p), /* @__PURE__ */jsxRuntimeExports.jsx(m, {
              ref: v,
              "data-virtuoso-scroller": true,
              style: {
                position: "relative",
                ...i,
                ...(h !== 0 ? {
                  height: h + I
                } : {})
              },
              ...c,
              ...Z(m, l),
              children: s
            });
          });
        }
        const fr = ({
            children: t
          }) => {
            const e = React.useContext(be),
              n = gt("viewportHeight"),
              o = gt("fixedItemHeight"),
              r = M("alignToBottom"),
              s = M("horizontalDirection"),
              i = React.useMemo(() => ne(n, c => vt(c, s ? "width" : "height")), [n, s]),
              l = Ht(i, true, M("skipAnimationFrameInResizeObserver"));
            return React.useEffect(() => {
              e && (n(e.viewportHeight), o(e.itemHeight));
            }, [e, n, o]), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              "data-viewport-type": "element",
              ref: l,
              style: Zt(r),
              children: t
            });
          },
          mr = ({
            children: t
          }) => {
            const e = React.useContext(be),
              n = gt("windowViewportRect"),
              o = gt("fixedItemHeight"),
              r = M("customScrollParent"),
              s = Ne(n, r, M("skipAnimationFrameInResizeObserver")),
              i = M("alignToBottom");
            return React.useEffect(() => {
              e && (o(e.itemHeight), n({
                offsetTop: 0,
                visibleHeight: e.viewportHeight,
                visibleWidth: 100
              }));
            }, [e, n, o]), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              "data-viewport-type": "window",
              ref: s,
              style: Zt(i),
              children: t
            });
          },
          pr = ({
            children: t
          }) => {
            const e = M("TopItemListComponent") || "div",
              n = M("headerHeight"),
              o = {
                ...ur,
                marginTop: `${n}px`
              },
              r = M("context");
            return /* @__PURE__ */jsxRuntimeExports.jsx(e, {
              style: o,
              ...Z(e, r),
              children: t
            });
          },
          hr = /* @__PURE__ */React.memo(function (e) {
            const n = M("useWindowScroll"),
              o = M("topItemsIndexes").length > 0,
              r = M("customScrollParent"),
              s = M("context");
            return /* @__PURE__ */jsxRuntimeExports.jsxs(r || n ? Ir : gr, {
              ...e,
              context: s,
              children: [o && /* @__PURE__ */jsxRuntimeExports.jsx(pr, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Cn, {
                  showTopList: true
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(r || n ? mr : fr, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(ar, {}), /* @__PURE__ */jsxRuntimeExports.jsx(Cn, {}), /* @__PURE__ */jsxRuntimeExports.jsx(dr, {})]
              })]
            });
          }),
          {
            Component: oo,
            useEmitter: tn,
            useEmitterValue: M,
            usePublisher: gt
          } = /* @__PURE__ */Ye(or, {
            required: {},
            optional: {
              restoreStateFrom: "restoreStateFrom",
              context: "context",
              followOutput: "followOutput",
              scrollIntoViewOnChange: "scrollIntoViewOnChange",
              itemContent: "itemContent",
              groupContent: "groupContent",
              overscan: "overscan",
              increaseViewportBy: "increaseViewportBy",
              totalCount: "totalCount",
              groupCounts: "groupCounts",
              topItemCount: "topItemCount",
              firstItemIndex: "firstItemIndex",
              initialTopMostItemIndex: "initialTopMostItemIndex",
              components: "components",
              atBottomThreshold: "atBottomThreshold",
              atTopThreshold: "atTopThreshold",
              computeItemKey: "computeItemKey",
              defaultItemHeight: "defaultItemHeight",
              fixedItemHeight: "fixedItemHeight",
              itemSize: "itemSize",
              scrollSeekConfiguration: "scrollSeekConfiguration",
              headerFooterTag: "HeaderFooterTag",
              data: "data",
              initialItemCount: "initialItemCount",
              initialScrollTop: "initialScrollTop",
              alignToBottom: "alignToBottom",
              useWindowScroll: "useWindowScroll",
              customScrollParent: "customScrollParent",
              scrollerRef: "scrollerRef",
              logLevel: "logLevel",
              horizontalDirection: "horizontalDirection",
              skipAnimationFrameInResizeObserver: "skipAnimationFrameInResizeObserver"
            },
            methods: {
              scrollToIndex: "scrollToIndex",
              scrollIntoView: "scrollIntoView",
              scrollTo: "scrollTo",
              scrollBy: "scrollBy",
              autoscrollToBottom: "autoscrollToBottom",
              getState: "getState"
            },
            events: {
              isScrolling: "isScrolling",
              endReached: "endReached",
              startReached: "startReached",
              rangeChanged: "rangeChanged",
              atBottomStateChange: "atBottomStateChange",
              atTopStateChange: "atTopStateChange",
              totalListHeightChanged: "totalListHeightChanged",
              itemsRendered: "itemsRendered",
              groupIndices: "groupIndices"
            }
          }, hr),
          gr = /* @__PURE__ */Je({
            useEmitter: tn,
            useEmitterValue: M,
            usePublisher: gt
          }),
          Ir = /* @__PURE__ */Qe({
            useEmitter: tn,
            useEmitterValue: M,
            usePublisher: gt
          }),
          qr = exports("aa", oo),
          Sr = /* @__PURE__ */U$1(() => {
            const t = w$1(a => /* @__PURE__ */jsxRuntimeExports.jsxs("td", {
                children: ["Item $", a]
              })),
              e = w$1(null),
              n = w$1(a => /* @__PURE__ */jsxRuntimeExports.jsxs("td", {
                colSpan: 1e3,
                children: ["Group ", a]
              })),
              o = w$1(null),
              r = w$1(null),
              s = w$1({}),
              i = w$1(Xe),
              l = w$1(Yt),
              c = (a, m = null) => ct(S(s, E$1(x => x[a]), Y()), m);
            return {
              components: s,
              computeItemKey: i,
              context: e,
              EmptyPlaceholder: c("EmptyPlaceholder"),
              FillerRow: c("FillerRow"),
              fixedFooterContent: r,
              fixedHeaderContent: o,
              itemContent: t,
              groupContent: n,
              ScrollerComponent: c("Scroller", "div"),
              scrollerRef: l,
              ScrollSeekPlaceholder: c("ScrollSeekPlaceholder"),
              TableBodyComponent: c("TableBody", "tbody"),
              TableComponent: c("Table", "table"),
              TableFooterComponent: c("TableFoot", "tfoot"),
              TableHeadComponent: c("TableHead", "thead"),
              TableRowComponent: c("TableRow", "tr"),
              GroupComponent: c("Group", "tr")
            };
          }); /* @__PURE__ */
        U$1(([t, e]) => ({
          ...t,
          ...e
        }), X(Xn, Sr));
        ({
          position: Ze()
        });
        const yn = {
            bottom: 0,
            itemHeight: 0,
            items: [],
            itemWidth: 0,
            offsetBottom: 0,
            offsetTop: 0,
            top: 0
          },
          Br = {
            bottom: 0,
            itemHeight: 0,
            items: [{
              index: 0
            }],
            itemWidth: 0,
            offsetBottom: 0,
            offsetTop: 0,
            top: 0
          },
          {
            ceil: Rn,
            floor: Ce,
            max: ee,
            min: Oe,
            round: bn
          } = Math;
        function Hn(t, e, n) {
          return Array.from({
            length: e - t + 1
          }).map((o, r) => ({
            data: n === null ? null : n[r + t],
            index: r + t
          }));
        }
        function kr(t) {
          return {
            ...Br,
            items: t
          };
        }
        function he(t, e) {
          return t && t.width === e.width && t.height === e.height;
        }
        function Fr(t, e) {
          return t && t.column === e.column && t.row === e.row;
        }
        const Or = /* @__PURE__ */U$1(([{
          increaseViewportBy: t,
          listBoundary: e,
          overscan: n,
          visibleRange: o
        }, {
          footerHeight: r,
          headerHeight: s,
          scrollBy: i,
          scrollContainerState: l,
          scrollTo: c,
          scrollTop: a,
          smoothScrollTargetReached: m,
          viewportHeight: x
        }, h, I, {
          didMount: C,
          propsReady: v
        }, {
          customScrollParent: g,
          useWindowScroll: p,
          windowScrollContainerState: u,
          windowScrollTo: T,
          windowViewportRect: b
        }, f]) => {
          const d = w$1(0),
            y = w$1(0),
            B = w$1(yn),
            k = w$1({
              height: 0,
              width: 0
            }),
            L = w$1({
              height: 0,
              width: 0
            }),
            z = $(),
            _ = $(),
            J = w$1(0),
            nt = w$1(null),
            F = w$1({
              column: 0,
              row: 0
            }),
            q = $(),
            it = $(),
            dt = w$1(false),
            St = w$1(0),
            ft = w$1(true),
            ut = w$1(false),
            At = w$1(false);
          K$1(S(C, N$1(St), A$1(([R, D]) => !!D)), () => {
            G$1(ft, false);
          }), K$1(S(rt(C, ft, L, k, St, ut), A$1(([R, D, Q, lt,, tt]) => R && !D && Q.height !== 0 && lt.height !== 0 && !tt)), ([,,,, R]) => {
            G$1(ut, true), Ue(1, () => {
              G$1(z, R);
            }), Tt(S(a), () => {
              G$1(e, [0, 0]), G$1(ft, true);
            });
          }), O$1(S(it, A$1(R => R != null && R.scrollTop > 0), Rt(0)), y), K$1(S(C, N$1(it), A$1(([, R]) => R != null)), ([, R]) => {
            R && (G$1(k, R.viewport), G$1(L, R.item), G$1(F, R.gap), R.scrollTop > 0 && (G$1(dt, true), Tt(S(a, Dt(1)), D => {
              G$1(dt, false);
            }), G$1(c, {
              top: R.scrollTop
            })));
          }), O$1(S(k, E$1(({
            height: R
          }) => R)), x), O$1(S(rt(V$1(k, he), V$1(L, he), V$1(F, (R, D) => R && R.column === D.column && R.row === D.row), V$1(a)), E$1(([R, D, Q, lt]) => ({
            gap: Q,
            item: D,
            scrollTop: lt,
            viewport: R
          }))), q), O$1(S(rt(V$1(d), o, V$1(F, Fr), V$1(L, he), V$1(k, he), V$1(nt), V$1(y), V$1(dt), V$1(ft), V$1(St)), A$1(([,,,,,,, R]) => !R), E$1(([R, [D, Q], lt, tt, Ft, Jt, Ut,, de, Ot]) => {
            const {
                column: Lt,
                row: Qt
              } = lt,
              {
                height: fe,
                width: He
              } = tt,
              {
                width: nn
              } = Ft;
            if (Ut === 0 && (R === 0 || nn === 0)) return yn;
            if (He === 0) {
              const cn = Ke(Ot, R),
                co = cn + Math.max(Ut - 1, 0);
              return kr(Hn(cn, co, Jt));
            }
            const me = so(nn, He, Lt);
            let Kt, Wt;
            de ? D === 0 && Q === 0 && Ut > 0 ? (Kt = 0, Wt = Ut - 1) : (Kt = me * Ce((D + Qt) / (fe + Qt)), Wt = me * Rn((Q + Qt) / (fe + Qt)) - 1, Wt = Oe(R - 1, ee(Wt, me - 1)), Kt = Oe(Wt, ee(0, Kt))) : (Kt = 0, Wt = -1);
            const on = Hn(Kt, Wt, Jt),
              {
                bottom: rn,
                top: sn
              } = En(Ft, lt, tt, on),
              ln = Rn(R / me),
              lo = ln * fe + (ln - 1) * Qt - rn;
            return {
              bottom: rn,
              itemHeight: fe,
              items: on,
              itemWidth: He,
              offsetBottom: lo,
              offsetTop: sn,
              top: sn
            };
          })), B), O$1(S(nt, A$1(R => R !== null), E$1(R => R.length)), d), O$1(S(rt(k, L, B, F), A$1(([R, D, {
            items: Q
          }]) => Q.length > 0 && D.height !== 0 && R.height !== 0), E$1(([R, D, {
            items: Q
          }, lt]) => {
            const {
              bottom: tt,
              top: Ft
            } = En(R, lt, D, Q);
            return [Ft, tt];
          }), Y(se)), e);
          const xt = w$1(false);
          O$1(S(a, N$1(xt), E$1(([R, D]) => D || R !== 0)), xt);
          const Xt = ht(S(rt(B, d), A$1(([{
              items: R
            }]) => R.length > 0), N$1(xt), A$1(([[R, D], Q]) => {
              const tt = R.items[R.items.length - 1].index === D - 1;
              return (Q || R.bottom > 0 && R.itemHeight > 0 && R.offsetBottom === 0 && R.items.length === D) && tt;
            }), E$1(([[, R]]) => R - 1), Y())),
            Mt = ht(S(V$1(B), A$1(({
              items: R
            }) => R.length > 0 && R[0].index === 0), Rt(0), Y())),
            yt = ht(S(V$1(B), N$1(dt), A$1(([{
              items: R
            }, D]) => R.length > 0 && !D), E$1(([{
              items: R
            }]) => ({
              endIndex: R[R.length - 1].index,
              startIndex: R[0].index
            })), Y(Mn), kt(0)));
          O$1(yt, I.scrollSeekRangeChanged), O$1(S(z, N$1(k, L, d, F), E$1(([R, D, Q, lt, tt]) => {
            const Ft = Dn(R),
              {
                align: Jt,
                behavior: Ut,
                offset: de
              } = Ft;
            let Ot = Ft.index;
            Ot === "LAST" && (Ot = lt - 1), Ot = ee(0, Ot, Oe(lt - 1, Ot));
            let Lt = Me(D, tt, Q, Ot);
            return Jt === "end" ? Lt = bn(Lt - D.height + Q.height) : Jt === "center" && (Lt = bn(Lt - D.height / 2 + Q.height / 2)), de && (Lt += de), {
              behavior: Ut,
              top: Lt
            };
          })), c);
          const Bt = ct(S(B, E$1(R => R.offsetBottom + R.bottom)), 0);
          return O$1(S(b, E$1(R => ({
            height: R.visibleHeight,
            width: R.visibleWidth
          }))), k), {
            customScrollParent: g,
            // input
            data: nt,
            deviation: J,
            footerHeight: r,
            gap: F,
            headerHeight: s,
            increaseViewportBy: t,
            initialItemCount: y,
            itemDimensions: L,
            overscan: n,
            restoreStateFrom: it,
            scrollBy: i,
            scrollContainerState: l,
            scrollHeight: _,
            scrollTo: c,
            scrollToIndex: z,
            scrollTop: a,
            smoothScrollTargetReached: m,
            totalCount: d,
            useWindowScroll: p,
            viewportDimensions: k,
            windowScrollContainerState: u,
            windowScrollTo: T,
            windowViewportRect: b,
            ...I,
            // output
            gridState: B,
            horizontalDirection: At,
            initialTopMostItemIndex: St,
            totalListHeight: Bt,
            ...h,
            endReached: Xt,
            propsReady: v,
            rangeChanged: yt,
            startReached: Mt,
            stateChanged: q,
            stateRestoreInProgress: dt,
            ...f
          };
        }, X(je, at, ae, Yn, Pt, qe, Vt));
        function so(t, e, n) {
          return ee(1, Ce((t + n) / (Ce(e) + n)));
        }
        function En(t, e, n, o) {
          const {
            height: r
          } = n;
          if (r === void 0 || o.length === 0) return {
            bottom: 0,
            top: 0
          };
          const s = Me(t, e, n, o[0].index);
          return {
            bottom: Me(t, e, n, o[o.length - 1].index) + r,
            top: s
          };
        }
        function Me(t, e, n, o) {
          const r = so(t.width, n.width, e.column),
            s = Ce(o / r),
            i = s * n.height + ee(0, s - 1) * e.row;
          return i > 0 ? i + e.row : i;
        }
        const Lr = /* @__PURE__ */U$1(() => {
            const t = w$1(x => `Item ${x}`),
              e = w$1({}),
              n = w$1(null),
              o = w$1("virtuoso-grid-item"),
              r = w$1("virtuoso-grid-list"),
              s = w$1(Xe),
              i = w$1("div"),
              l = w$1(Yt),
              c = (x, h = null) => ct(S(e, E$1(I => I[x]), Y()), h),
              a = w$1(false),
              m = w$1(false);
            return O$1(V$1(m), a), {
              components: e,
              computeItemKey: s,
              context: n,
              FooterComponent: c("Footer"),
              HeaderComponent: c("Header"),
              headerFooterTag: i,
              itemClassName: o,
              ItemComponent: c("Item", "div"),
              itemContent: t,
              listClassName: r,
              ListComponent: c("List", "div"),
              readyStateChanged: a,
              reportReadyState: m,
              ScrollerComponent: c("Scroller", "div"),
              scrollerRef: l,
              ScrollSeekPlaceholder: c("ScrollSeekPlaceholder", "div")
            };
          }),
          zr = /* @__PURE__ */U$1(([t, e]) => ({
            ...t,
            ...e
          }), X(Or, Lr)),
          Vr = /* @__PURE__ */React.memo(function () {
            const e = et("gridState"),
              n = et("listClassName"),
              o = et("itemClassName"),
              r = et("itemContent"),
              s = et("computeItemKey"),
              i = et("isSeeking"),
              l = It("scrollHeight"),
              c = et("ItemComponent"),
              a = et("ListComponent"),
              m = et("ScrollSeekPlaceholder"),
              x = et("context"),
              h = It("itemDimensions"),
              I = It("gap"),
              C = et("log"),
              v = et("stateRestoreInProgress"),
              g = It("reportReadyState"),
              p = Ht(React.useMemo(() => u => {
                const T = u.parentElement.parentElement.scrollHeight;
                l(T);
                const b = u.firstChild;
                if (b) {
                  const {
                    height: f,
                    width: d
                  } = b.getBoundingClientRect();
                  h({
                    height: f,
                    width: d
                  });
                }
                I({
                  column: Bn("column-gap", getComputedStyle(u).columnGap, C),
                  row: Bn("row-gap", getComputedStyle(u).rowGap, C)
                });
              }, [l, h, I, C]), true, false);
            return Qn(() => {
              e.itemHeight > 0 && e.itemWidth > 0 && g(true);
            }, [e]), v ? null : /* @__PURE__ */jsxRuntimeExports.jsx(a, {
              className: n,
              ref: p,
              ...Z(a, x),
              "data-testid": "virtuoso-item-list",
              style: {
                paddingBottom: e.offsetBottom,
                paddingTop: e.offsetTop
              },
              children: e.items.map(u => {
                const T = s(u.index, u.data, x);
                return i ? /* @__PURE__ */jsxRuntimeExports.jsx(m, {
                  ...Z(m, x),
                  height: e.itemHeight,
                  index: u.index,
                  width: e.itemWidth
                }, T) : /* @__PURE__ */reactExports.createElement(c, {
                  ...Z(c, x),
                  className: o,
                  "data-index": u.index,
                  key: T
                }, r(u.index, u.data, x));
              })
            });
          }),
          Pr = React.memo(function () {
            const e = et("HeaderComponent"),
              n = It("headerHeight"),
              o = et("headerFooterTag"),
              r = Ht(React.useMemo(() => i => {
                n(vt(i, "height"));
              }, [n]), true, false),
              s = et("context");
            return e ? /* @__PURE__ */jsxRuntimeExports.jsx(o, {
              ref: r,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(e, {
                ...Z(e, s)
              })
            }) : null;
          }),
          Ar = React.memo(function () {
            const e = et("FooterComponent"),
              n = It("footerHeight"),
              o = et("headerFooterTag"),
              r = Ht(React.useMemo(() => i => {
                n(vt(i, "height"));
              }, [n]), true, false),
              s = et("context");
            return e ? /* @__PURE__ */jsxRuntimeExports.jsx(o, {
              ref: r,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(e, {
                ...Z(e, s)
              })
            }) : null;
          }),
          Mr = ({
            children: t
          }) => {
            const e = React.useContext(Jn),
              n = It("itemDimensions"),
              o = It("viewportDimensions"),
              r = Ht(React.useMemo(() => s => {
                o(s.getBoundingClientRect());
              }, [o]), true, false);
            return React.useEffect(() => {
              e && (o({
                height: e.viewportHeight,
                width: e.viewportWidth
              }), n({
                height: e.itemHeight,
                width: e.itemWidth
              }));
            }, [e, o, n]), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              ref: r,
              style: Zt(false),
              children: t
            });
          },
          Wr = ({
            children: t
          }) => {
            const e = React.useContext(Jn),
              n = It("windowViewportRect"),
              o = It("itemDimensions"),
              r = et("customScrollParent"),
              s = Ne(n, r, false);
            return React.useEffect(() => {
              e && (o({
                height: e.itemHeight,
                width: e.itemWidth
              }), n({
                offsetTop: 0,
                visibleHeight: e.viewportHeight,
                visibleWidth: e.viewportWidth
              }));
            }, [e, n, o]), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              ref: s,
              style: Zt(false),
              children: t
            });
          },
          Gr = /* @__PURE__ */React.memo(function ({
            ...e
          }) {
            const n = et("useWindowScroll"),
              o = et("customScrollParent"),
              r = o || n ? Dr : Nr,
              s = o || n ? Wr : Mr,
              i = et("context");
            return /* @__PURE__ */jsxRuntimeExports.jsx(r, {
              ...e,
              ...Z(r, i),
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(s, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Pr, {}), /* @__PURE__ */jsxRuntimeExports.jsx(Vr, {}), /* @__PURE__ */jsxRuntimeExports.jsx(Ar, {})]
              })
            });
          }),
          {
            useEmitter: io,
            useEmitterValue: et,
            usePublisher: It
          } = /* @__PURE__ */Ye(zr, {
            optional: {
              context: "context",
              totalCount: "totalCount",
              overscan: "overscan",
              itemContent: "itemContent",
              components: "components",
              computeItemKey: "computeItemKey",
              data: "data",
              initialItemCount: "initialItemCount",
              scrollSeekConfiguration: "scrollSeekConfiguration",
              headerFooterTag: "headerFooterTag",
              listClassName: "listClassName",
              itemClassName: "itemClassName",
              useWindowScroll: "useWindowScroll",
              customScrollParent: "customScrollParent",
              scrollerRef: "scrollerRef",
              logLevel: "logLevel",
              restoreStateFrom: "restoreStateFrom",
              initialTopMostItemIndex: "initialTopMostItemIndex",
              increaseViewportBy: "increaseViewportBy"
            },
            methods: {
              scrollTo: "scrollTo",
              scrollBy: "scrollBy",
              scrollToIndex: "scrollToIndex"
            },
            events: {
              isScrolling: "isScrolling",
              endReached: "endReached",
              startReached: "startReached",
              rangeChanged: "rangeChanged",
              atBottomStateChange: "atBottomStateChange",
              atTopStateChange: "atTopStateChange",
              stateChanged: "stateChanged",
              readyStateChanged: "readyStateChanged"
            }
          }, Gr),
          Nr = /* @__PURE__ */Je({
            useEmitter: io,
            useEmitterValue: et,
            usePublisher: It
          }),
          Dr = /* @__PURE__ */Qe({
            useEmitter: io,
            useEmitterValue: et,
            usePublisher: It
          });
        function Bn(t, e, n) {
          return e !== "normal" && !(e != null && e.endsWith("px")) && n(`${t} was not resolved to pixel value correctly`, e, mt.WARN), e === "normal" ? 0 : parseInt(e != null ? e : "0", 10);
        }

        /**
         * SSR Window 5.0.1
         * Better handling for window object in SSR environment
         * https://github.com/nolimits4web/ssr-window
         *
         * Copyright 2025, Vladimir Kharlampidi
         *
         * Licensed under MIT
         *
         * Released on: June 27, 2025
         */
        /* eslint-disable no-param-reassign */
        function isObject$3(obj) {
          return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
        }
        function extend$2(target = {}, src = {}) {
          const noExtend = ['__proto__', 'constructor', 'prototype'];
          Object.keys(src).filter(key => noExtend.indexOf(key) < 0).forEach(key => {
            if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$3(src[key]) && isObject$3(target[key]) && Object.keys(src[key]).length > 0) {
              extend$2(target[key], src[key]);
            }
          });
        }
        const ssrDocument = {
          body: {},
          addEventListener() {},
          removeEventListener() {},
          activeElement: {
            blur() {},
            nodeName: ''
          },
          querySelector() {
            return null;
          },
          querySelectorAll() {
            return [];
          },
          getElementById() {
            return null;
          },
          createEvent() {
            return {
              initEvent() {}
            };
          },
          createElement() {
            return {
              children: [],
              childNodes: [],
              style: {},
              setAttribute() {},
              getElementsByTagName() {
                return [];
              }
            };
          },
          createElementNS() {
            return {};
          },
          importNode() {
            return null;
          },
          location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: ''
          }
        };
        function getDocument() {
          const doc = typeof document !== 'undefined' ? document : {};
          extend$2(doc, ssrDocument);
          return doc;
        }
        const ssrWindow = {
          document: ssrDocument,
          navigator: {
            userAgent: ''
          },
          location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: ''
          },
          history: {
            replaceState() {},
            pushState() {},
            go() {},
            back() {}
          },
          CustomEvent: function CustomEvent() {
            return this;
          },
          addEventListener() {},
          removeEventListener() {},
          getComputedStyle() {
            return {
              getPropertyValue() {
                return '';
              }
            };
          },
          Image() {},
          Date() {},
          screen: {},
          setTimeout() {},
          clearTimeout() {},
          matchMedia() {
            return {};
          },
          requestAnimationFrame(callback) {
            if (typeof setTimeout === 'undefined') {
              callback();
              return null;
            }
            return setTimeout(callback, 0);
          },
          cancelAnimationFrame(id) {
            if (typeof setTimeout === 'undefined') {
              return;
            }
            clearTimeout(id);
          }
        };
        function getWindow() {
          const win = typeof window !== 'undefined' ? window : {};
          extend$2(win, ssrWindow);
          return win;
        }
        function classesToTokens(classes = '') {
          return classes.trim().split(' ').filter(c => !!c.trim());
        }
        function deleteProps(obj) {
          const object = obj;
          Object.keys(object).forEach(key => {
            try {
              object[key] = null;
            } catch (e) {
              // no getter for object
            }
            try {
              delete object[key];
            } catch (e) {
              // something got wrong
            }
          });
        }
        function nextTick(callback, delay = 0) {
          return setTimeout(callback, delay);
        }
        function now() {
          return Date.now();
        }
        function getComputedStyle$1(el) {
          const window = getWindow();
          let style;
          if (window.getComputedStyle) {
            style = window.getComputedStyle(el, null);
          }
          if (!style && el.currentStyle) {
            style = el.currentStyle;
          }
          if (!style) {
            style = el.style;
          }
          return style;
        }
        function getTranslate(el, axis = 'x') {
          const window = getWindow();
          let matrix;
          let curTransform;
          let transformMatrix;
          const curStyle = getComputedStyle$1(el);
          if (window.WebKitCSSMatrix) {
            curTransform = curStyle.transform || curStyle.webkitTransform;
            if (curTransform.split(',').length > 6) {
              curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
            }
            // Some old versions of Webkit choke when 'none' is passed; pass
            // empty string instead in this case
            transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
          } else {
            transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
            matrix = transformMatrix.toString().split(',');
          }
          if (axis === 'x') {
            // Latest Chrome and webkits Fix
            if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
            // Crazy IE10 Matrix
            else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
            // Normal Browsers
            else curTransform = parseFloat(matrix[4]);
          }
          if (axis === 'y') {
            // Latest Chrome and webkits Fix
            if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
            // Crazy IE10 Matrix
            else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
            // Normal Browsers
            else curTransform = parseFloat(matrix[5]);
          }
          return curTransform || 0;
        }
        function isObject$2(o) {
          return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
        }
        function isNode(node) {
          // eslint-disable-next-line
          if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
            return node instanceof HTMLElement;
          }
          return node && (node.nodeType === 1 || node.nodeType === 11);
        }
        function extend$1(...args) {
          const to = Object(args[0]);
          const noExtend = ['__proto__', 'constructor', 'prototype'];
          for (let i = 1; i < args.length; i += 1) {
            const nextSource = args[i];
            if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
              const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
              for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                const nextKey = keysArray[nextIndex];
                const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                if (desc !== undefined && desc.enumerable) {
                  if (isObject$2(to[nextKey]) && isObject$2(nextSource[nextKey])) {
                    if (nextSource[nextKey].__swiper__) {
                      to[nextKey] = nextSource[nextKey];
                    } else {
                      extend$1(to[nextKey], nextSource[nextKey]);
                    }
                  } else if (!isObject$2(to[nextKey]) && isObject$2(nextSource[nextKey])) {
                    to[nextKey] = {};
                    if (nextSource[nextKey].__swiper__) {
                      to[nextKey] = nextSource[nextKey];
                    } else {
                      extend$1(to[nextKey], nextSource[nextKey]);
                    }
                  } else {
                    to[nextKey] = nextSource[nextKey];
                  }
                }
              }
            }
          }
          return to;
        }
        function setCSSProperty(el, varName, varValue) {
          el.style.setProperty(varName, varValue);
        }
        function animateCSSModeScroll({
          swiper,
          targetPosition,
          side
        }) {
          const window = getWindow();
          const startPosition = -swiper.translate;
          let startTime = null;
          let time;
          const duration = swiper.params.speed;
          swiper.wrapperEl.style.scrollSnapType = 'none';
          window.cancelAnimationFrame(swiper.cssModeFrameID);
          const dir = targetPosition > startPosition ? 'next' : 'prev';
          const isOutOfBound = (current, target) => {
            return dir === 'next' && current >= target || dir === 'prev' && current <= target;
          };
          const animate = () => {
            time = new Date().getTime();
            if (startTime === null) {
              startTime = time;
            }
            const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
            const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
            let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
            if (isOutOfBound(currentPosition, targetPosition)) {
              currentPosition = targetPosition;
            }
            swiper.wrapperEl.scrollTo({
              [side]: currentPosition
            });
            if (isOutOfBound(currentPosition, targetPosition)) {
              swiper.wrapperEl.style.overflow = 'hidden';
              swiper.wrapperEl.style.scrollSnapType = '';
              setTimeout(() => {
                swiper.wrapperEl.style.overflow = '';
                swiper.wrapperEl.scrollTo({
                  [side]: currentPosition
                });
              });
              window.cancelAnimationFrame(swiper.cssModeFrameID);
              return;
            }
            swiper.cssModeFrameID = window.requestAnimationFrame(animate);
          };
          animate();
        }
        function getSlideTransformEl(slideEl) {
          return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;
        }
        function elementChildren(element, selector = '') {
          const window = getWindow();
          const children = [...element.children];
          if (window.HTMLSlotElement && element instanceof HTMLSlotElement) {
            children.push(...element.assignedElements());
          }
          if (!selector) {
            return children;
          }
          return children.filter(el => el.matches(selector));
        }
        function elementIsChildOfSlot(el, slot) {
          // Breadth-first search through all parent's children and assigned elements
          const elementsQueue = [slot];
          while (elementsQueue.length > 0) {
            const elementToCheck = elementsQueue.shift();
            if (el === elementToCheck) {
              return true;
            }
            elementsQueue.push(...elementToCheck.children, ...(elementToCheck.shadowRoot ? elementToCheck.shadowRoot.children : []), ...(elementToCheck.assignedElements ? elementToCheck.assignedElements() : []));
          }
        }
        function elementIsChildOf(el, parent) {
          const window = getWindow();
          let isChild = parent.contains(el);
          if (!isChild && window.HTMLSlotElement && parent instanceof HTMLSlotElement) {
            const children = [...parent.assignedElements()];
            isChild = children.includes(el);
            if (!isChild) {
              isChild = elementIsChildOfSlot(el, parent);
            }
          }
          return isChild;
        }
        function showWarning(text) {
          try {
            console.warn(text);
            return;
          } catch (err) {
            // err
          }
        }
        function createElement(tag, classes = []) {
          const el = document.createElement(tag);
          el.classList.add(...(Array.isArray(classes) ? classes : classesToTokens(classes)));
          return el;
        }
        function elementOffset(el) {
          const window = getWindow();
          const document = getDocument();
          const box = el.getBoundingClientRect();
          const body = document.body;
          const clientTop = el.clientTop || body.clientTop || 0;
          const clientLeft = el.clientLeft || body.clientLeft || 0;
          const scrollTop = el === window ? window.scrollY : el.scrollTop;
          const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
          return {
            top: box.top + scrollTop - clientTop,
            left: box.left + scrollLeft - clientLeft
          };
        }
        function elementPrevAll(el, selector) {
          const prevEls = [];
          while (el.previousElementSibling) {
            const prev = el.previousElementSibling; // eslint-disable-line
            if (selector) {
              if (prev.matches(selector)) prevEls.push(prev);
            } else prevEls.push(prev);
            el = prev;
          }
          return prevEls;
        }
        function elementNextAll(el, selector) {
          const nextEls = [];
          while (el.nextElementSibling) {
            const next = el.nextElementSibling; // eslint-disable-line
            if (selector) {
              if (next.matches(selector)) nextEls.push(next);
            } else nextEls.push(next);
            el = next;
          }
          return nextEls;
        }
        function elementStyle(el, prop) {
          const window = getWindow();
          return window.getComputedStyle(el, null).getPropertyValue(prop);
        }
        function elementIndex(el) {
          let child = el;
          let i;
          if (child) {
            i = 0;
            // eslint-disable-next-line
            while ((child = child.previousSibling) !== null) {
              if (child.nodeType === 1) i += 1;
            }
            return i;
          }
          return undefined;
        }
        function elementParents(el, selector) {
          const parents = []; // eslint-disable-line
          let parent = el.parentElement; // eslint-disable-line
          while (parent) {
            if (selector) {
              if (parent.matches(selector)) parents.push(parent);
            } else {
              parents.push(parent);
            }
            parent = parent.parentElement;
          }
          return parents;
        }
        function elementTransitionEnd(el, callback) {
          function fireCallBack(e) {
            if (e.target !== el) return;
            callback.call(el, e);
            el.removeEventListener('transitionend', fireCallBack);
          }
          if (callback) {
            el.addEventListener('transitionend', fireCallBack);
          }
        }
        function elementOuterSize(el, size, includeMargins) {
          const window = getWindow();
          {
            return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));
          }
        }
        function makeElementsArray(el) {
          return (Array.isArray(el) ? el : [el]).filter(e => !!e);
        }
        function getRotateFix(swiper) {
          return v => {
            if (Math.abs(v) > 0 && swiper.browser && swiper.browser.need3dFix && Math.abs(v) % 90 === 0) {
              return v + 0.001;
            }
            return v;
          };
        }
        function setInnerHTML(el, html = '') {
          if (typeof trustedTypes !== 'undefined') {
            el.innerHTML = trustedTypes.createPolicy('html', {
              createHTML: s => s
            }).createHTML(html);
          } else {
            el.innerHTML = html;
          }
        }
        let support;
        function calcSupport() {
          const window = getWindow();
          const document = getDocument();
          return {
            smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,
            touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)
          };
        }
        function getSupport() {
          if (!support) {
            support = calcSupport();
          }
          return support;
        }
        let deviceCached;
        function calcDevice({
          userAgent
        } = {}) {
          const support = getSupport();
          const window = getWindow();
          const platform = window.navigator.platform;
          const ua = userAgent || window.navigator.userAgent;
          const device = {
            ios: false,
            android: false
          };
          const screenWidth = window.screen.width;
          const screenHeight = window.screen.height;
          const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
          let ipad = ua.match(/(iPad)(?!\1).*OS\s([\d_]+)/);
          const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
          const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
          const windows = platform === 'Win32';
          let macos = platform === 'MacIntel';

          // iPadOs 13 fix
          const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
          if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
            ipad = ua.match(/(Version)\/([\d.]+)/);
            if (!ipad) ipad = [0, 1, '13_0_0'];
            macos = false;
          }

          // Android
          if (android && !windows) {
            device.os = 'android';
            device.android = true;
          }
          if (ipad || iphone || ipod) {
            device.os = 'ios';
            device.ios = true;
          }

          // Export object
          return device;
        }
        function getDevice(overrides = {}) {
          if (!deviceCached) {
            deviceCached = calcDevice(overrides);
          }
          return deviceCached;
        }
        let browser;
        function calcBrowser() {
          const window = getWindow();
          const device = getDevice();
          let needPerspectiveFix = false;
          function isSafari() {
            const ua = window.navigator.userAgent.toLowerCase();
            return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
          }
          if (isSafari()) {
            const ua = String(window.navigator.userAgent);
            if (ua.includes('Version/')) {
              const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));
              needPerspectiveFix = major < 16 || major === 16 && minor < 2;
            }
          }
          const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);
          const isSafariBrowser = isSafari();
          const need3dFix = isSafariBrowser || isWebView && device.ios;
          return {
            isSafari: needPerspectiveFix || isSafariBrowser,
            needPerspectiveFix,
            need3dFix,
            isWebView
          };
        }
        function getBrowser() {
          if (!browser) {
            browser = calcBrowser();
          }
          return browser;
        }
        function Resize({
          swiper,
          on,
          emit
        }) {
          const window = getWindow();
          let observer = null;
          let animationFrame = null;
          const resizeHandler = () => {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            emit('beforeResize');
            emit('resize');
          };
          const createObserver = () => {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            observer = new ResizeObserver(entries => {
              animationFrame = window.requestAnimationFrame(() => {
                const {
                  width,
                  height
                } = swiper;
                let newWidth = width;
                let newHeight = height;
                entries.forEach(({
                  contentBoxSize,
                  contentRect,
                  target
                }) => {
                  if (target && target !== swiper.el) return;
                  newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                  newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                });
                if (newWidth !== width || newHeight !== height) {
                  resizeHandler();
                }
              });
            });
            observer.observe(swiper.el);
          };
          const removeObserver = () => {
            if (animationFrame) {
              window.cancelAnimationFrame(animationFrame);
            }
            if (observer && observer.unobserve && swiper.el) {
              observer.unobserve(swiper.el);
              observer = null;
            }
          };
          const orientationChangeHandler = () => {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            emit('orientationchange');
          };
          on('init', () => {
            if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
              createObserver();
              return;
            }
            window.addEventListener('resize', resizeHandler);
            window.addEventListener('orientationchange', orientationChangeHandler);
          });
          on('destroy', () => {
            removeObserver();
            window.removeEventListener('resize', resizeHandler);
            window.removeEventListener('orientationchange', orientationChangeHandler);
          });
        }
        function Observer({
          swiper,
          extendParams,
          on,
          emit
        }) {
          const observers = [];
          const window = getWindow();
          const attach = (target, options = {}) => {
            const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
            const observer = new ObserverFunc(mutations => {
              // The observerUpdate event should only be triggered
              // once despite the number of mutations.  Additional
              // triggers are redundant and are very costly
              if (swiper.__preventObserver__) return;
              if (mutations.length === 1) {
                emit('observerUpdate', mutations[0]);
                return;
              }
              const observerUpdate = function observerUpdate() {
                emit('observerUpdate', mutations[0]);
              };
              if (window.requestAnimationFrame) {
                window.requestAnimationFrame(observerUpdate);
              } else {
                window.setTimeout(observerUpdate, 0);
              }
            });
            observer.observe(target, {
              attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
              childList: swiper.isElement || (typeof options.childList === 'undefined' ? true : options).childList,
              characterData: typeof options.characterData === 'undefined' ? true : options.characterData
            });
            observers.push(observer);
          };
          const init = () => {
            if (!swiper.params.observer) return;
            if (swiper.params.observeParents) {
              const containerParents = elementParents(swiper.hostEl);
              for (let i = 0; i < containerParents.length; i += 1) {
                attach(containerParents[i]);
              }
            }
            // Observe container
            attach(swiper.hostEl, {
              childList: swiper.params.observeSlideChildren
            });

            // Observe wrapper
            attach(swiper.wrapperEl, {
              attributes: false
            });
          };
          const destroy = () => {
            observers.forEach(observer => {
              observer.disconnect();
            });
            observers.splice(0, observers.length);
          };
          extendParams({
            observer: false,
            observeParents: false,
            observeSlideChildren: false
          });
          on('init', init);
          on('destroy', destroy);
        }

        /* eslint-disable no-underscore-dangle */

        var eventsEmitter = {
          on(events, handler, priority) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (typeof handler !== 'function') return self;
            const method = priority ? 'unshift' : 'push';
            events.split(' ').forEach(event => {
              if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
              self.eventsListeners[event][method](handler);
            });
            return self;
          },
          once(events, handler, priority) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (typeof handler !== 'function') return self;
            function onceHandler(...args) {
              self.off(events, onceHandler);
              if (onceHandler.__emitterProxy) {
                delete onceHandler.__emitterProxy;
              }
              handler.apply(self, args);
            }
            onceHandler.__emitterProxy = handler;
            return self.on(events, onceHandler, priority);
          },
          onAny(handler, priority) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (typeof handler !== 'function') return self;
            const method = priority ? 'unshift' : 'push';
            if (self.eventsAnyListeners.indexOf(handler) < 0) {
              self.eventsAnyListeners[method](handler);
            }
            return self;
          },
          offAny(handler) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (!self.eventsAnyListeners) return self;
            const index = self.eventsAnyListeners.indexOf(handler);
            if (index >= 0) {
              self.eventsAnyListeners.splice(index, 1);
            }
            return self;
          },
          off(events, handler) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (!self.eventsListeners) return self;
            events.split(' ').forEach(event => {
              if (typeof handler === 'undefined') {
                self.eventsListeners[event] = [];
              } else if (self.eventsListeners[event]) {
                self.eventsListeners[event].forEach((eventHandler, index) => {
                  if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                    self.eventsListeners[event].splice(index, 1);
                  }
                });
              }
            });
            return self;
          },
          emit(...args) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (!self.eventsListeners) return self;
            let events;
            let data;
            let context;
            if (typeof args[0] === 'string' || Array.isArray(args[0])) {
              events = args[0];
              data = args.slice(1, args.length);
              context = self;
            } else {
              events = args[0].events;
              data = args[0].data;
              context = args[0].context || self;
            }
            data.unshift(context);
            const eventsArray = Array.isArray(events) ? events : events.split(' ');
            eventsArray.forEach(event => {
              if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
                self.eventsAnyListeners.forEach(eventHandler => {
                  eventHandler.apply(context, [event, ...data]);
                });
              }
              if (self.eventsListeners && self.eventsListeners[event]) {
                self.eventsListeners[event].forEach(eventHandler => {
                  eventHandler.apply(context, data);
                });
              }
            });
            return self;
          }
        };
        function updateSize() {
          const swiper = this;
          let width;
          let height;
          const el = swiper.el;
          if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
            width = swiper.params.width;
          } else {
            width = el.clientWidth;
          }
          if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
            height = swiper.params.height;
          } else {
            height = el.clientHeight;
          }
          if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
            return;
          }

          // Subtract paddings
          width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);
          height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);
          if (Number.isNaN(width)) width = 0;
          if (Number.isNaN(height)) height = 0;
          Object.assign(swiper, {
            width,
            height,
            size: swiper.isHorizontal() ? width : height
          });
        }
        function updateSlides() {
          const swiper = this;
          function getDirectionPropertyValue(node, label) {
            return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
          }
          const params = swiper.params;
          const {
            wrapperEl,
            slidesEl,
            rtlTranslate: rtl,
            wrongRTL
          } = swiper;
          const isVirtual = swiper.virtual && params.virtual.enabled;
          const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
          const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
          const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
          let snapGrid = [];
          const slidesGrid = [];
          const slidesSizesGrid = [];
          let offsetBefore = params.slidesOffsetBefore;
          if (typeof offsetBefore === 'function') {
            offsetBefore = params.slidesOffsetBefore.call(swiper);
          }
          let offsetAfter = params.slidesOffsetAfter;
          if (typeof offsetAfter === 'function') {
            offsetAfter = params.slidesOffsetAfter.call(swiper);
          }
          const previousSnapGridLength = swiper.snapGrid.length;
          const previousSlidesGridLength = swiper.slidesGrid.length;
          const swiperSize = swiper.size - offsetBefore - offsetAfter;
          let spaceBetween = params.spaceBetween;
          let slidePosition = -offsetBefore;
          let prevSlideSize = 0;
          let index = 0;
          if (typeof swiperSize === 'undefined') {
            return;
          }
          if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
            spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
          } else if (typeof spaceBetween === 'string') {
            spaceBetween = parseFloat(spaceBetween);
          }
          swiper.virtualSize = -spaceBetween - offsetBefore - offsetAfter;

          // reset margins
          slides.forEach(slideEl => {
            if (rtl) {
              slideEl.style.marginLeft = '';
            } else {
              slideEl.style.marginRight = '';
            }
            slideEl.style.marginBottom = '';
            slideEl.style.marginTop = '';
          });

          // reset cssMode offsets
          if (params.centeredSlides && params.cssMode) {
            setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');
            setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');
          }
          const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
          if (gridEnabled) {
            swiper.grid.initSlides(slides);
          } else if (swiper.grid) {
            swiper.grid.unsetSlides();
          }

          // Calc slides
          let slideSize;
          const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
            return typeof params.breakpoints[key].slidesPerView !== 'undefined';
          }).length > 0;
          for (let i = 0; i < slidesLength; i += 1) {
            slideSize = 0;
            const slide = slides[i];
            if (slide) {
              if (gridEnabled) {
                swiper.grid.updateSlide(i, slide, slides);
              }
              if (elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line
            }
            if (isVirtual && params.slidesPerView === 'auto') {
              if (params.virtual.slidesPerViewAutoSlideSize) {
                slideSize = params.virtual.slidesPerViewAutoSlideSize;
              }
              if (slideSize && slide) {
                if (params.roundLengths) slideSize = Math.floor(slideSize);
                slide.style[swiper.getDirectionLabel('width')] = `${slideSize}px`;
              }
            } else if (params.slidesPerView === 'auto') {
              if (shouldResetSlideSize) {
                slide.style[swiper.getDirectionLabel('width')] = ``;
              }
              const slideStyles = getComputedStyle(slide);
              const currentTransform = slide.style.transform;
              const currentWebKitTransform = slide.style.webkitTransform;
              if (currentTransform) {
                slide.style.transform = 'none';
              }
              if (currentWebKitTransform) {
                slide.style.webkitTransform = 'none';
              }
              if (params.roundLengths) {
                slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width') : elementOuterSize(slide, 'height');
              } else {
                // eslint-disable-next-line
                const width = getDirectionPropertyValue(slideStyles, 'width');
                const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
                const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
                const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
                const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
                const boxSizing = slideStyles.getPropertyValue('box-sizing');
                if (boxSizing && boxSizing === 'border-box') {
                  slideSize = width + marginLeft + marginRight;
                } else {
                  const {
                    clientWidth,
                    offsetWidth
                  } = slide;
                  slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                }
              }
              if (currentTransform) {
                slide.style.transform = currentTransform;
              }
              if (currentWebKitTransform) {
                slide.style.webkitTransform = currentWebKitTransform;
              }
              if (params.roundLengths) slideSize = Math.floor(slideSize);
            } else {
              slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
              if (params.roundLengths) slideSize = Math.floor(slideSize);
              if (slide) {
                slide.style[swiper.getDirectionLabel('width')] = `${slideSize}px`;
              }
            }
            if (slide) {
              slide.swiperSlideSize = slideSize;
            }
            slidesSizesGrid.push(slideSize);
            if (params.centeredSlides) {
              slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
              if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
              if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
              if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
              if (params.roundLengths) slidePosition = Math.floor(slidePosition);
              if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
              slidesGrid.push(slidePosition);
            } else {
              if (params.roundLengths) slidePosition = Math.floor(slidePosition);
              if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
              slidesGrid.push(slidePosition);
              slidePosition = slidePosition + slideSize + spaceBetween;
            }
            swiper.virtualSize += slideSize + spaceBetween;
            prevSlideSize = slideSize;
            index += 1;
          }
          swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
          if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
            wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
          }
          if (params.setWrapperSize) {
            wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
          }
          if (gridEnabled) {
            swiper.grid.updateWrapperSize(slideSize, snapGrid);
          }

          // Remove last grid elements depending on width
          if (!params.centeredSlides) {
            const newSlidesGrid = [];
            for (let i = 0; i < snapGrid.length; i += 1) {
              let slidesGridItem = snapGrid[i];
              if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
              if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
                newSlidesGrid.push(slidesGridItem);
              }
            }
            snapGrid = newSlidesGrid;
            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
              snapGrid.push(swiper.virtualSize - swiperSize);
            }
          }
          if (isVirtual && params.loop) {
            const size = slidesSizesGrid[0] + spaceBetween;
            if (params.slidesPerGroup > 1) {
              const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
              const groupSize = size * params.slidesPerGroup;
              for (let i = 0; i < groups; i += 1) {
                snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
              }
            }
            for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
              if (params.slidesPerGroup === 1) {
                snapGrid.push(snapGrid[snapGrid.length - 1] + size);
              }
              slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
              swiper.virtualSize += size;
            }
          }
          if (snapGrid.length === 0) snapGrid = [0];
          if (spaceBetween !== 0) {
            const key = swiper.isHorizontal() && rtl ? 'marginLeft' : swiper.getDirectionLabel('marginRight');
            slides.filter((_, slideIndex) => {
              if (!params.cssMode || params.loop) return true;
              if (slideIndex === slides.length - 1) {
                return false;
              }
              return true;
            }).forEach(slideEl => {
              slideEl.style[key] = `${spaceBetween}px`;
            });
          }
          if (params.centeredSlides && params.centeredSlidesBounds) {
            let allSlidesSize = 0;
            slidesSizesGrid.forEach(slideSizeValue => {
              allSlidesSize += slideSizeValue + (spaceBetween || 0);
            });
            allSlidesSize -= spaceBetween;
            const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
            snapGrid = snapGrid.map(snap => {
              if (snap <= 0) return -offsetBefore;
              if (snap > maxSnap) return maxSnap + offsetAfter;
              return snap;
            });
          }
          if (params.centerInsufficientSlides) {
            let allSlidesSize = 0;
            slidesSizesGrid.forEach(slideSizeValue => {
              allSlidesSize += slideSizeValue + (spaceBetween || 0);
            });
            allSlidesSize -= spaceBetween;
            const offsetSize = (offsetBefore || 0) + (offsetAfter || 0);
            if (allSlidesSize + offsetSize < swiperSize) {
              const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
              snapGrid.forEach((snap, snapIndex) => {
                snapGrid[snapIndex] = snap - allSlidesOffset;
              });
              slidesGrid.forEach((snap, snapIndex) => {
                slidesGrid[snapIndex] = snap + allSlidesOffset;
              });
            }
          }
          Object.assign(swiper, {
            slides,
            snapGrid,
            slidesGrid,
            slidesSizesGrid
          });
          if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
            setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
            setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
            const addToSnapGrid = -swiper.snapGrid[0];
            const addToSlidesGrid = -swiper.slidesGrid[0];
            swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
            swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
          }
          if (slidesLength !== previousSlidesLength) {
            swiper.emit('slidesLengthChange');
          }
          if (snapGrid.length !== previousSnapGridLength) {
            if (swiper.params.watchOverflow) swiper.checkOverflow();
            swiper.emit('snapGridLengthChange');
          }
          if (slidesGrid.length !== previousSlidesGridLength) {
            swiper.emit('slidesGridLengthChange');
          }
          if (params.watchSlidesProgress) {
            swiper.updateSlidesOffset();
          }
          swiper.emit('slidesUpdated');
          if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
            const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
            const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
            if (slidesLength <= params.maxBackfaceHiddenSlides) {
              if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
            } else if (hasClassBackfaceClassAdded) {
              swiper.el.classList.remove(backFaceHiddenClass);
            }
          }
        }
        function updateAutoHeight(speed) {
          const swiper = this;
          const activeSlides = [];
          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
          let newHeight = 0;
          let i;
          if (typeof speed === 'number') {
            swiper.setTransition(speed);
          } else if (speed === true) {
            swiper.setTransition(swiper.params.speed);
          }
          const getSlideByIndex = index => {
            if (isVirtual) {
              return swiper.slides[swiper.getSlideIndexByData(index)];
            }
            return swiper.slides[index];
          };
          // Find slides currently in view
          if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
            if (swiper.params.centeredSlides) {
              (swiper.visibleSlides || []).forEach(slide => {
                activeSlides.push(slide);
              });
            } else {
              for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                const index = swiper.activeIndex + i;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
              }
            }
          } else {
            activeSlides.push(getSlideByIndex(swiper.activeIndex));
          }

          // Find new height from highest slide in view
          for (i = 0; i < activeSlides.length; i += 1) {
            if (typeof activeSlides[i] !== 'undefined') {
              const height = activeSlides[i].offsetHeight;
              newHeight = height > newHeight ? height : newHeight;
            }
          }

          // Update Height
          if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
        }
        function updateSlidesOffset() {
          const swiper = this;
          const slides = swiper.slides;
          // eslint-disable-next-line
          const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
          for (let i = 0; i < slides.length; i += 1) {
            slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
          }
        }
        const toggleSlideClasses$1 = (slideEl, condition, className) => {
          if (condition && !slideEl.classList.contains(className)) {
            slideEl.classList.add(className);
          } else if (!condition && slideEl.classList.contains(className)) {
            slideEl.classList.remove(className);
          }
        };
        function updateSlidesProgress(translate = this && this.translate || 0) {
          const swiper = this;
          const params = swiper.params;
          const {
            slides,
            rtlTranslate: rtl,
            snapGrid
          } = swiper;
          if (slides.length === 0) return;
          if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
          let offsetCenter = -translate;
          if (rtl) offsetCenter = translate;
          swiper.visibleSlidesIndexes = [];
          swiper.visibleSlides = [];
          let spaceBetween = params.spaceBetween;
          if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
            spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
          } else if (typeof spaceBetween === 'string') {
            spaceBetween = parseFloat(spaceBetween);
          }
          for (let i = 0; i < slides.length; i += 1) {
            const slide = slides[i];
            let slideOffset = slide.swiperSlideOffset;
            if (params.cssMode && params.centeredSlides) {
              slideOffset -= slides[0].swiperSlideOffset;
            }
            const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
            const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
            const slideBefore = -(offsetCenter - slideOffset);
            const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
            const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
            const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
            if (isVisible) {
              swiper.visibleSlides.push(slide);
              swiper.visibleSlidesIndexes.push(i);
            }
            toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);
            toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);
            slide.progress = rtl ? -slideProgress : slideProgress;
            slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
          }
        }
        function updateProgress(translate) {
          const swiper = this;
          if (typeof translate === 'undefined') {
            const multiplier = swiper.rtlTranslate ? -1 : 1;
            // eslint-disable-next-line
            translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
          }
          const params = swiper.params;
          const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
          let {
            progress,
            isBeginning,
            isEnd,
            progressLoop
          } = swiper;
          const wasBeginning = isBeginning;
          const wasEnd = isEnd;
          if (translatesDiff === 0) {
            progress = 0;
            isBeginning = true;
            isEnd = true;
          } else {
            progress = (translate - swiper.minTranslate()) / translatesDiff;
            const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
            const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
            isBeginning = isBeginningRounded || progress <= 0;
            isEnd = isEndRounded || progress >= 1;
            if (isBeginningRounded) progress = 0;
            if (isEndRounded) progress = 1;
          }
          if (params.loop) {
            const firstSlideIndex = swiper.getSlideIndexByData(0);
            const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
            const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
            const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
            const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
            const translateAbs = Math.abs(translate);
            if (translateAbs >= firstSlideTranslate) {
              progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
            } else {
              progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
            }
            if (progressLoop > 1) progressLoop -= 1;
          }
          Object.assign(swiper, {
            progress,
            progressLoop,
            isBeginning,
            isEnd
          });
          if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
          if (isBeginning && !wasBeginning) {
            swiper.emit('reachBeginning toEdge');
          }
          if (isEnd && !wasEnd) {
            swiper.emit('reachEnd toEdge');
          }
          if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
            swiper.emit('fromEdge');
          }
          swiper.emit('progress', progress);
        }
        const toggleSlideClasses = (slideEl, condition, className) => {
          if (condition && !slideEl.classList.contains(className)) {
            slideEl.classList.add(className);
          } else if (!condition && slideEl.classList.contains(className)) {
            slideEl.classList.remove(className);
          }
        };
        function updateSlidesClasses() {
          const swiper = this;
          const {
            slides,
            params,
            slidesEl,
            activeIndex
          } = swiper;
          const isVirtual = swiper.virtual && params.virtual.enabled;
          const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
          const getFilteredSlide = selector => {
            return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
          };
          let activeSlide;
          let prevSlide;
          let nextSlide;
          if (isVirtual) {
            if (params.loop) {
              let slideIndex = activeIndex - swiper.virtual.slidesBefore;
              if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
              if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
              activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
            } else {
              activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
            }
          } else {
            if (gridEnabled) {
              activeSlide = slides.find(slideEl => slideEl.column === activeIndex);
              nextSlide = slides.find(slideEl => slideEl.column === activeIndex + 1);
              prevSlide = slides.find(slideEl => slideEl.column === activeIndex - 1);
            } else {
              activeSlide = slides[activeIndex];
            }
          }
          if (activeSlide) {
            if (!gridEnabled) {
              // Next Slide
              nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
              if (params.loop && !nextSlide) {
                nextSlide = slides[0];
              }

              // Prev Slide
              prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
              if (params.loop && !prevSlide === 0) {
                prevSlide = slides[slides.length - 1];
              }
            }
          }
          slides.forEach(slideEl => {
            toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
            toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
            toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
          });
          swiper.emitSlidesClasses();
        }
        const processLazyPreloader = (swiper, imageEl) => {
          if (!swiper || swiper.destroyed || !swiper.params) return;
          const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
          const slideEl = imageEl.closest(slideSelector());
          if (slideEl) {
            let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
            if (!lazyEl && swiper.isElement) {
              if (slideEl.shadowRoot) {
                lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
              } else {
                // init later
                requestAnimationFrame(() => {
                  if (slideEl.shadowRoot) {
                    lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                    if (lazyEl) lazyEl.remove();
                  }
                });
              }
            }
            if (lazyEl) lazyEl.remove();
          }
        };
        const unlazy = (swiper, index) => {
          if (!swiper.slides[index]) return;
          const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
          if (imageEl) imageEl.removeAttribute('loading');
        };
        const preload = swiper => {
          if (!swiper || swiper.destroyed || !swiper.params) return;
          let amount = swiper.params.lazyPreloadPrevNext;
          const len = swiper.slides.length;
          if (!len || !amount || amount < 0) return;
          amount = Math.min(amount, len);
          const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
          const activeIndex = swiper.activeIndex;
          if (swiper.params.grid && swiper.params.grid.rows > 1) {
            const activeColumn = activeIndex;
            const preloadColumns = [activeColumn - amount];
            preloadColumns.push(...Array.from({
              length: amount
            }).map((_, i) => {
              return activeColumn + slidesPerView + i;
            }));
            swiper.slides.forEach((slideEl, i) => {
              if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
            });
            return;
          }
          const slideIndexLastInView = activeIndex + slidesPerView - 1;
          if (swiper.params.rewind || swiper.params.loop) {
            for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
              const realIndex = (i % len + len) % len;
              if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
            }
          } else {
            for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
              if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
                unlazy(swiper, i);
              }
            }
          }
        };
        function getActiveIndexByTranslate(swiper) {
          const {
            slidesGrid,
            params
          } = swiper;
          const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
          let activeIndex;
          for (let i = 0; i < slidesGrid.length; i += 1) {
            if (typeof slidesGrid[i + 1] !== 'undefined') {
              if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
                activeIndex = i;
              } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
                activeIndex = i + 1;
              }
            } else if (translate >= slidesGrid[i]) {
              activeIndex = i;
            }
          }
          // Normalize slideIndex
          if (params.normalizeSlideIndex) {
            if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
          }
          return activeIndex;
        }
        function updateActiveIndex(newActiveIndex) {
          const swiper = this;
          const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
          const {
            snapGrid,
            params,
            activeIndex: previousIndex,
            realIndex: previousRealIndex,
            snapIndex: previousSnapIndex
          } = swiper;
          let activeIndex = newActiveIndex;
          let snapIndex;
          const getVirtualRealIndex = aIndex => {
            let realIndex = aIndex - swiper.virtual.slidesBefore;
            if (realIndex < 0) {
              realIndex = swiper.virtual.slides.length + realIndex;
            }
            if (realIndex >= swiper.virtual.slides.length) {
              realIndex -= swiper.virtual.slides.length;
            }
            return realIndex;
          };
          if (typeof activeIndex === 'undefined') {
            activeIndex = getActiveIndexByTranslate(swiper);
          }
          if (snapGrid.indexOf(translate) >= 0) {
            snapIndex = snapGrid.indexOf(translate);
          } else {
            const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
            snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
          }
          if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
          if (activeIndex === previousIndex && !swiper.params.loop) {
            if (snapIndex !== previousSnapIndex) {
              swiper.snapIndex = snapIndex;
              swiper.emit('snapIndexChange');
            }
            return;
          }
          if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
            swiper.realIndex = getVirtualRealIndex(activeIndex);
            return;
          }
          const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;

          // Get real index
          let realIndex;
          if (swiper.virtual && params.virtual.enabled && params.loop) {
            realIndex = getVirtualRealIndex(activeIndex);
          } else if (gridEnabled) {
            const firstSlideInColumn = swiper.slides.find(slideEl => slideEl.column === activeIndex);
            let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute('data-swiper-slide-index'), 10);
            if (Number.isNaN(activeSlideIndex)) {
              activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
            }
            realIndex = Math.floor(activeSlideIndex / params.grid.rows);
          } else if (swiper.slides[activeIndex]) {
            const slideIndex = swiper.slides[activeIndex].getAttribute('data-swiper-slide-index');
            if (slideIndex) {
              realIndex = parseInt(slideIndex, 10);
            } else {
              realIndex = activeIndex;
            }
          } else {
            realIndex = activeIndex;
          }
          Object.assign(swiper, {
            previousSnapIndex,
            snapIndex,
            previousRealIndex,
            realIndex,
            previousIndex,
            activeIndex
          });
          if (swiper.initialized) {
            preload(swiper);
          }
          swiper.emit('activeIndexChange');
          swiper.emit('snapIndexChange');
          if (swiper.initialized || swiper.params.runCallbacksOnInit) {
            if (previousRealIndex !== realIndex) {
              swiper.emit('realIndexChange');
            }
            swiper.emit('slideChange');
          }
        }
        function updateClickedSlide(el, path) {
          const swiper = this;
          const params = swiper.params;
          let slide = el.closest(`.${params.slideClass}, swiper-slide`);
          if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {
            [...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {
              if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
                slide = pathEl;
              }
            });
          }
          let slideFound = false;
          let slideIndex;
          if (slide) {
            for (let i = 0; i < swiper.slides.length; i += 1) {
              if (swiper.slides[i] === slide) {
                slideFound = true;
                slideIndex = i;
                break;
              }
            }
          }
          if (slide && slideFound) {
            swiper.clickedSlide = slide;
            if (swiper.virtual && swiper.params.virtual.enabled) {
              swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);
            } else {
              swiper.clickedIndex = slideIndex;
            }
          } else {
            swiper.clickedSlide = undefined;
            swiper.clickedIndex = undefined;
            return;
          }
          if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
            swiper.slideToClickedSlide();
          }
        }
        var update = {
          updateSize,
          updateSlides,
          updateAutoHeight,
          updateSlidesOffset,
          updateSlidesProgress,
          updateProgress,
          updateSlidesClasses,
          updateActiveIndex,
          updateClickedSlide
        };
        function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
          const swiper = this;
          const {
            params,
            rtlTranslate: rtl,
            translate,
            wrapperEl
          } = swiper;
          if (params.virtualTranslate) {
            return rtl ? -translate : translate;
          }
          if (params.cssMode) {
            return translate;
          }
          let currentTranslate = getTranslate(wrapperEl, axis);
          currentTranslate += swiper.cssOverflowAdjustment();
          if (rtl) currentTranslate = -currentTranslate;
          return currentTranslate || 0;
        }
        function setTranslate(translate, byController) {
          const swiper = this;
          const {
            rtlTranslate: rtl,
            params,
            wrapperEl,
            progress
          } = swiper;
          let x = 0;
          let y = 0;
          const z = 0;
          if (swiper.isHorizontal()) {
            x = rtl ? -translate : translate;
          } else {
            y = translate;
          }
          if (params.roundLengths) {
            x = Math.floor(x);
            y = Math.floor(y);
          }
          swiper.previousTranslate = swiper.translate;
          swiper.translate = swiper.isHorizontal() ? x : y;
          if (params.cssMode) {
            wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
          } else if (!params.virtualTranslate) {
            if (swiper.isHorizontal()) {
              x -= swiper.cssOverflowAdjustment();
            } else {
              y -= swiper.cssOverflowAdjustment();
            }
            wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
          }

          // Check if we need to update progress
          let newProgress;
          const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
          if (translatesDiff === 0) {
            newProgress = 0;
          } else {
            newProgress = (translate - swiper.minTranslate()) / translatesDiff;
          }
          if (newProgress !== progress) {
            swiper.updateProgress(translate);
          }
          swiper.emit('setTranslate', swiper.translate, byController);
        }
        function minTranslate() {
          return -this.snapGrid[0];
        }
        function maxTranslate() {
          return -this.snapGrid[this.snapGrid.length - 1];
        }
        function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
          const swiper = this;
          const {
            params,
            wrapperEl
          } = swiper;
          if (swiper.animating && params.preventInteractionOnTransition) {
            return false;
          }
          const minTranslate = swiper.minTranslate();
          const maxTranslate = swiper.maxTranslate();
          let newTranslate;
          if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;

          // Update progress
          swiper.updateProgress(newTranslate);
          if (params.cssMode) {
            const isH = swiper.isHorizontal();
            if (speed === 0) {
              wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
            } else {
              if (!swiper.support.smoothScroll) {
                animateCSSModeScroll({
                  swiper,
                  targetPosition: -newTranslate,
                  side: isH ? 'left' : 'top'
                });
                return true;
              }
              wrapperEl.scrollTo({
                [isH ? 'left' : 'top']: -newTranslate,
                behavior: 'smooth'
              });
            }
            return true;
          }
          if (speed === 0) {
            swiper.setTransition(0);
            swiper.setTranslate(newTranslate);
            if (runCallbacks) {
              swiper.emit('beforeTransitionStart', speed, internal);
              swiper.emit('transitionEnd');
            }
          } else {
            swiper.setTransition(speed);
            swiper.setTranslate(newTranslate);
            if (runCallbacks) {
              swiper.emit('beforeTransitionStart', speed, internal);
              swiper.emit('transitionStart');
            }
            if (!swiper.animating) {
              swiper.animating = true;
              if (!swiper.onTranslateToWrapperTransitionEnd) {
                swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                  if (!swiper || swiper.destroyed) return;
                  if (e.target !== this) return;
                  swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
                  swiper.onTranslateToWrapperTransitionEnd = null;
                  delete swiper.onTranslateToWrapperTransitionEnd;
                  swiper.animating = false;
                  if (runCallbacks) {
                    swiper.emit('transitionEnd');
                  }
                };
              }
              swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
            }
          }
          return true;
        }
        var translate = {
          getTranslate: getSwiperTranslate,
          setTranslate,
          minTranslate,
          maxTranslate,
          translateTo
        };
        function setTransition(duration, byController) {
          const swiper = this;
          if (!swiper.params.cssMode) {
            swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
            swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';
          }
          swiper.emit('setTransition', duration, byController);
        }
        function transitionEmit({
          swiper,
          runCallbacks,
          direction,
          step
        }) {
          const {
            activeIndex,
            previousIndex
          } = swiper;
          let dir = direction;
          if (!dir) {
            if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
          }
          swiper.emit(`transition${step}`);
          if (runCallbacks && dir === 'reset') {
            swiper.emit(`slideResetTransition${step}`);
          } else if (runCallbacks && activeIndex !== previousIndex) {
            swiper.emit(`slideChangeTransition${step}`);
            if (dir === 'next') {
              swiper.emit(`slideNextTransition${step}`);
            } else {
              swiper.emit(`slidePrevTransition${step}`);
            }
          }
        }
        function transitionStart(runCallbacks = true, direction) {
          const swiper = this;
          const {
            params
          } = swiper;
          if (params.cssMode) return;
          if (params.autoHeight) {
            swiper.updateAutoHeight();
          }
          transitionEmit({
            swiper,
            runCallbacks,
            direction,
            step: 'Start'
          });
        }
        function transitionEnd(runCallbacks = true, direction) {
          const swiper = this;
          const {
            params
          } = swiper;
          swiper.animating = false;
          if (params.cssMode) return;
          swiper.setTransition(0);
          transitionEmit({
            swiper,
            runCallbacks,
            direction,
            step: 'End'
          });
        }
        var transition = {
          setTransition,
          transitionStart,
          transitionEnd
        };
        function slideTo(index = 0, speed, runCallbacks = true, internal, initial) {
          if (typeof index === 'string') {
            index = parseInt(index, 10);
          }
          const swiper = this;
          let slideIndex = index;
          if (slideIndex < 0) slideIndex = 0;
          const {
            params,
            snapGrid,
            slidesGrid,
            previousIndex,
            activeIndex,
            rtlTranslate: rtl,
            wrapperEl,
            enabled
          } = swiper;
          if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
            return false;
          }
          if (typeof speed === 'undefined') {
            speed = swiper.params.speed;
          }
          const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
          let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
          if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
          const translate = -snapGrid[snapIndex];
          // Normalize slideIndex
          if (params.normalizeSlideIndex) {
            for (let i = 0; i < slidesGrid.length; i += 1) {
              const normalizedTranslate = -Math.floor(translate * 100);
              const normalizedGrid = Math.floor(slidesGrid[i] * 100);
              const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
              if (typeof slidesGrid[i + 1] !== 'undefined') {
                if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
                  slideIndex = i;
                } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
                  slideIndex = i + 1;
                }
              } else if (normalizedTranslate >= normalizedGrid) {
                slideIndex = i;
              }
            }
          }
          // Directions locks
          if (swiper.initialized && slideIndex !== activeIndex) {
            if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {
              return false;
            }
            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
              if ((activeIndex || 0) !== slideIndex) {
                return false;
              }
            }
          }
          if (slideIndex !== (previousIndex || 0) && runCallbacks) {
            swiper.emit('beforeSlideChangeStart');
          }

          // Update progress
          swiper.updateProgress(translate);
          let direction;
          if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';

          // initial virtual
          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
          const isInitialVirtual = isVirtual && initial;
          // Update Index
          if (!isInitialVirtual && (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate)) {
            swiper.updateActiveIndex(slideIndex);
            // Update Height
            if (params.autoHeight) {
              swiper.updateAutoHeight();
            }
            swiper.updateSlidesClasses();
            if (params.effect !== 'slide') {
              swiper.setTranslate(translate);
            }
            if (direction !== 'reset') {
              swiper.transitionStart(runCallbacks, direction);
              swiper.transitionEnd(runCallbacks, direction);
            }
            return false;
          }
          if (params.cssMode) {
            const isH = swiper.isHorizontal();
            const t = rtl ? translate : -translate;
            if (speed === 0) {
              if (isVirtual) {
                swiper.wrapperEl.style.scrollSnapType = 'none';
                swiper._immediateVirtual = true;
              }
              if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                swiper._cssModeVirtualInitialSet = true;
                requestAnimationFrame(() => {
                  wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
                });
              } else {
                wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
              }
              if (isVirtual) {
                requestAnimationFrame(() => {
                  swiper.wrapperEl.style.scrollSnapType = '';
                  swiper._immediateVirtual = false;
                });
              }
            } else {
              if (!swiper.support.smoothScroll) {
                animateCSSModeScroll({
                  swiper,
                  targetPosition: t,
                  side: isH ? 'left' : 'top'
                });
                return true;
              }
              wrapperEl.scrollTo({
                [isH ? 'left' : 'top']: t,
                behavior: 'smooth'
              });
            }
            return true;
          }
          const browser = getBrowser();
          const isSafari = browser.isSafari;
          if (isVirtual && !initial && isSafari && swiper.isElement) {
            swiper.virtual.update(false, false, slideIndex);
          }
          swiper.setTransition(speed);
          swiper.setTranslate(translate);
          swiper.updateActiveIndex(slideIndex);
          swiper.updateSlidesClasses();
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.transitionStart(runCallbacks, direction);
          if (speed === 0) {
            swiper.transitionEnd(runCallbacks, direction);
          } else if (!swiper.animating) {
            swiper.animating = true;
            if (!swiper.onSlideToWrapperTransitionEnd) {
              swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                if (!swiper || swiper.destroyed) return;
                if (e.target !== this) return;
                swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                swiper.onSlideToWrapperTransitionEnd = null;
                delete swiper.onSlideToWrapperTransitionEnd;
                swiper.transitionEnd(runCallbacks, direction);
              };
            }
            swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          }
          return true;
        }
        function slideToLoop(index = 0, speed, runCallbacks = true, internal) {
          if (typeof index === 'string') {
            const indexAsNumber = parseInt(index, 10);
            index = indexAsNumber;
          }
          const swiper = this;
          if (swiper.destroyed) return;
          if (typeof speed === 'undefined') {
            speed = swiper.params.speed;
          }
          const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
          let newIndex = index;
          if (swiper.params.loop) {
            if (swiper.virtual && swiper.params.virtual.enabled) {
              // eslint-disable-next-line
              newIndex = newIndex + swiper.virtual.slidesBefore;
            } else {
              let targetSlideIndex;
              if (gridEnabled) {
                const slideIndex = newIndex * swiper.params.grid.rows;
                targetSlideIndex = swiper.slides.find(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex).column;
              } else {
                targetSlideIndex = swiper.getSlideIndexByData(newIndex);
              }
              const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
              const {
                centeredSlides,
                slidesOffsetBefore,
                slidesOffsetAfter
              } = swiper.params;
              const bothDirections = centeredSlides || !!slidesOffsetBefore || !!slidesOffsetAfter;
              let slidesPerView = swiper.params.slidesPerView;
              if (slidesPerView === 'auto') {
                slidesPerView = swiper.slidesPerViewDynamic();
              } else {
                slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
                if (bothDirections && slidesPerView % 2 === 0) {
                  slidesPerView = slidesPerView + 1;
                }
              }
              let needLoopFix = cols - targetSlideIndex < slidesPerView;
              if (bothDirections) {
                needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
              }
              if (internal && bothDirections && swiper.params.slidesPerView !== 'auto' && !gridEnabled) {
                needLoopFix = false;
              }
              if (needLoopFix) {
                const direction = bothDirections ? targetSlideIndex < swiper.activeIndex ? 'prev' : 'next' : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? 'next' : 'prev';
                swiper.loopFix({
                  direction,
                  slideTo: true,
                  activeSlideIndex: direction === 'next' ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
                  slideRealIndex: direction === 'next' ? swiper.realIndex : undefined
                });
              }
              if (gridEnabled) {
                const slideIndex = newIndex * swiper.params.grid.rows;
                newIndex = swiper.slides.find(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex).column;
              } else {
                newIndex = swiper.getSlideIndexByData(newIndex);
              }
            }
          }
          requestAnimationFrame(() => {
            swiper.slideTo(newIndex, speed, runCallbacks, internal);
          });
          return swiper;
        }

        /* eslint no-unused-vars: "off" */
        function slideNext(speed, runCallbacks = true, internal) {
          const swiper = this;
          const {
            enabled,
            params,
            animating
          } = swiper;
          if (!enabled || swiper.destroyed) return swiper;
          if (typeof speed === 'undefined') {
            speed = swiper.params.speed;
          }
          let perGroup = params.slidesPerGroup;
          if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
            perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
          }
          const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
          const isVirtual = swiper.virtual && params.virtual.enabled;
          if (params.loop) {
            if (animating && !isVirtual && params.loopPreventsSliding) return false;
            swiper.loopFix({
              direction: 'next'
            });
            // eslint-disable-next-line
            swiper._clientLeft = swiper.wrapperEl.clientLeft;
            if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
              requestAnimationFrame(() => {
                swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
              });
              return true;
            }
          }
          if (params.rewind && swiper.isEnd) {
            return swiper.slideTo(0, speed, runCallbacks, internal);
          }
          return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        }

        /* eslint no-unused-vars: "off" */
        function slidePrev(speed, runCallbacks = true, internal) {
          const swiper = this;
          const {
            params,
            snapGrid,
            slidesGrid,
            rtlTranslate,
            enabled,
            animating
          } = swiper;
          if (!enabled || swiper.destroyed) return swiper;
          if (typeof speed === 'undefined') {
            speed = swiper.params.speed;
          }
          const isVirtual = swiper.virtual && params.virtual.enabled;
          if (params.loop) {
            if (animating && !isVirtual && params.loopPreventsSliding) return false;
            swiper.loopFix({
              direction: 'prev'
            });
            // eslint-disable-next-line
            swiper._clientLeft = swiper.wrapperEl.clientLeft;
          }
          const translate = rtlTranslate ? swiper.translate : -swiper.translate;
          function normalize(val) {
            if (val < 0) return -Math.floor(Math.abs(val));
            return Math.floor(val);
          }
          const normalizedTranslate = normalize(translate);
          const normalizedSnapGrid = snapGrid.map(val => normalize(val));
          const isFreeMode = params.freeMode && params.freeMode.enabled;
          let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
          if (typeof prevSnap === 'undefined' && (params.cssMode || isFreeMode)) {
            let prevSnapIndex;
            snapGrid.forEach((snap, snapIndex) => {
              if (normalizedTranslate >= snap) {
                // prevSnap = snap;
                prevSnapIndex = snapIndex;
              }
            });
            if (typeof prevSnapIndex !== 'undefined') {
              prevSnap = isFreeMode ? snapGrid[prevSnapIndex] : snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
          }
          let prevIndex = 0;
          if (typeof prevSnap !== 'undefined') {
            prevIndex = slidesGrid.indexOf(prevSnap);
            if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
            if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
              prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
              prevIndex = Math.max(prevIndex, 0);
            }
          }
          if (params.rewind && swiper.isBeginning) {
            const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
            return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
          } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
            requestAnimationFrame(() => {
              swiper.slideTo(prevIndex, speed, runCallbacks, internal);
            });
            return true;
          }
          return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        }

        /* eslint no-unused-vars: "off" */
        function slideReset(speed, runCallbacks = true, internal) {
          const swiper = this;
          if (swiper.destroyed) return;
          if (typeof speed === 'undefined') {
            speed = swiper.params.speed;
          }
          return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
        }

        /* eslint no-unused-vars: "off" */
        function slideToClosest(speed, runCallbacks = true, internal, threshold = 0.5) {
          const swiper = this;
          if (swiper.destroyed) return;
          if (typeof speed === 'undefined') {
            speed = swiper.params.speed;
          }
          let index = swiper.activeIndex;
          const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
          const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
          const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
          if (translate >= swiper.snapGrid[snapIndex]) {
            // The current translate is on or after the current snap index, so the choice
            // is between the current index and the one after it.
            const currentSnap = swiper.snapGrid[snapIndex];
            const nextSnap = swiper.snapGrid[snapIndex + 1];
            if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
              index += swiper.params.slidesPerGroup;
            }
          } else {
            // The current translate is before the current snap index, so the choice
            // is between the current index and the one before it.
            const prevSnap = swiper.snapGrid[snapIndex - 1];
            const currentSnap = swiper.snapGrid[snapIndex];
            if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
              index -= swiper.params.slidesPerGroup;
            }
          }
          index = Math.max(index, 0);
          index = Math.min(index, swiper.slidesGrid.length - 1);
          return swiper.slideTo(index, speed, runCallbacks, internal);
        }
        function slideToClickedSlide() {
          const swiper = this;
          if (swiper.destroyed) return;
          const {
            params,
            slidesEl
          } = swiper;
          const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
          let slideToIndex = swiper.getSlideIndexWhenGrid(swiper.clickedIndex);
          let realIndex;
          const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
          const isGrid = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
          if (params.loop) {
            if (swiper.animating) return;
            realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
            if (params.centeredSlides) {
              swiper.slideToLoop(realIndex);
            } else if (slideToIndex > (isGrid ? (swiper.slides.length - slidesPerView) / 2 - (swiper.params.grid.rows - 1) : swiper.slides.length - slidesPerView)) {
              swiper.loopFix();
              slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
              nextTick(() => {
                swiper.slideTo(slideToIndex);
              });
            } else {
              swiper.slideTo(slideToIndex);
            }
          } else {
            swiper.slideTo(slideToIndex);
          }
        }
        var slide = {
          slideTo,
          slideToLoop,
          slideNext,
          slidePrev,
          slideReset,
          slideToClosest,
          slideToClickedSlide
        };
        function loopCreate(slideRealIndex, initial) {
          const swiper = this;
          const {
            params,
            slidesEl
          } = swiper;
          if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
          const initSlides = () => {
            const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
            slides.forEach((el, index) => {
              el.setAttribute('data-swiper-slide-index', index);
            });
          };
          const clearBlankSlides = () => {
            const slides = elementChildren(slidesEl, `.${params.slideBlankClass}`);
            slides.forEach(el => {
              el.remove();
            });
            if (slides.length > 0) {
              swiper.recalcSlides();
              swiper.updateSlides();
            }
          };
          const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
          if (params.loopAddBlankSlides && (params.slidesPerGroup > 1 || gridEnabled)) {
            clearBlankSlides();
          }
          const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
          const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
          const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
          const addBlankSlides = amountOfSlides => {
            for (let i = 0; i < amountOfSlides; i += 1) {
              const slideEl = swiper.isElement ? createElement('swiper-slide', [params.slideBlankClass]) : createElement('div', [params.slideClass, params.slideBlankClass]);
              swiper.slidesEl.append(slideEl);
            }
          };
          if (shouldFillGroup) {
            if (params.loopAddBlankSlides) {
              const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
              addBlankSlides(slidesToAdd);
              swiper.recalcSlides();
              swiper.updateSlides();
            } else {
              showWarning('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
            }
            initSlides();
          } else if (shouldFillGrid) {
            if (params.loopAddBlankSlides) {
              const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
              addBlankSlides(slidesToAdd);
              swiper.recalcSlides();
              swiper.updateSlides();
            } else {
              showWarning('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
            }
            initSlides();
          } else {
            initSlides();
          }
          const bothDirections = params.centeredSlides || !!params.slidesOffsetBefore || !!params.slidesOffsetAfter;
          swiper.loopFix({
            slideRealIndex,
            direction: bothDirections ? undefined : 'next',
            initial
          });
        }
        function loopFix({
          slideRealIndex,
          slideTo = true,
          direction,
          setTranslate,
          activeSlideIndex,
          initial,
          byController,
          byMousewheel
        } = {}) {
          const swiper = this;
          if (!swiper.params.loop) return;
          swiper.emit('beforeLoopFix');
          const {
            slides,
            allowSlidePrev,
            allowSlideNext,
            slidesEl,
            params
          } = swiper;
          const {
            centeredSlides,
            slidesOffsetBefore,
            slidesOffsetAfter,
            initialSlide
          } = params;
          const bothDirections = centeredSlides || !!slidesOffsetBefore || !!slidesOffsetAfter;
          swiper.allowSlidePrev = true;
          swiper.allowSlideNext = true;
          if (swiper.virtual && params.virtual.enabled) {
            if (slideTo) {
              if (!bothDirections && swiper.snapIndex === 0) {
                swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
              } else if (bothDirections && swiper.snapIndex < params.slidesPerView) {
                swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
              } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
                swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
              }
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            swiper.emit('loopFix');
            return;
          }
          let slidesPerView = params.slidesPerView;
          if (slidesPerView === 'auto') {
            slidesPerView = swiper.slidesPerViewDynamic();
          } else {
            slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
            if (bothDirections && slidesPerView % 2 === 0) {
              slidesPerView = slidesPerView + 1;
            }
          }
          const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
          let loopedSlides = bothDirections ? Math.max(slidesPerGroup, Math.ceil(slidesPerView / 2)) : slidesPerGroup;
          if (loopedSlides % slidesPerGroup !== 0) {
            loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
          }
          loopedSlides += params.loopAdditionalSlides;
          swiper.loopedSlides = loopedSlides;
          const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
          if (slides.length < slidesPerView + loopedSlides || swiper.params.effect === 'cards' && slides.length < slidesPerView + loopedSlides * 2) {
            showWarning('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters');
          } else if (gridEnabled && params.grid.fill === 'row') {
            showWarning('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`');
          }
          const prependSlidesIndexes = [];
          const appendSlidesIndexes = [];
          const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
          const isInitialOverflow = initial && cols - initialSlide < slidesPerView && !bothDirections;
          let activeIndex = isInitialOverflow ? initialSlide : swiper.activeIndex;
          if (typeof activeSlideIndex === 'undefined') {
            activeSlideIndex = swiper.getSlideIndex(slides.find(el => el.classList.contains(params.slideActiveClass)));
          } else {
            activeIndex = activeSlideIndex;
          }
          const isNext = direction === 'next' || !direction;
          const isPrev = direction === 'prev' || !direction;
          let slidesPrepended = 0;
          let slidesAppended = 0;
          const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
          const activeColIndexWithShift = activeColIndex + (bothDirections && typeof setTranslate === 'undefined' ? -slidesPerView / 2 + 0.5 : 0);
          // prepend last slides before start
          if (activeColIndexWithShift < loopedSlides) {
            slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
            for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
              const index = i - Math.floor(i / cols) * cols;
              if (gridEnabled) {
                const colIndexToPrepend = cols - index - 1;
                for (let i = slides.length - 1; i >= 0; i -= 1) {
                  if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);
                }
                // slides.forEach((slide, slideIndex) => {
                //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);
                // });
              } else {
                prependSlidesIndexes.push(cols - index - 1);
              }
            }
          } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
            slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
            if (isInitialOverflow) {
              slidesAppended = Math.max(slidesAppended, slidesPerView - cols + initialSlide + 1);
            }
            for (let i = 0; i < slidesAppended; i += 1) {
              const index = i - Math.floor(i / cols) * cols;
              if (gridEnabled) {
                slides.forEach((slide, slideIndex) => {
                  if (slide.column === index) appendSlidesIndexes.push(slideIndex);
                });
              } else {
                appendSlidesIndexes.push(index);
              }
            }
          }
          swiper.__preventObserver__ = true;
          requestAnimationFrame(() => {
            swiper.__preventObserver__ = false;
          });
          if (swiper.params.effect === 'cards' && slides.length < slidesPerView + loopedSlides * 2) {
            if (appendSlidesIndexes.includes(activeSlideIndex)) {
              appendSlidesIndexes.splice(appendSlidesIndexes.indexOf(activeSlideIndex), 1);
            }
            if (prependSlidesIndexes.includes(activeSlideIndex)) {
              prependSlidesIndexes.splice(prependSlidesIndexes.indexOf(activeSlideIndex), 1);
            }
          }
          if (isPrev) {
            prependSlidesIndexes.forEach(index => {
              slides[index].swiperLoopMoveDOM = true;
              slidesEl.prepend(slides[index]);
              slides[index].swiperLoopMoveDOM = false;
            });
          }
          if (isNext) {
            appendSlidesIndexes.forEach(index => {
              slides[index].swiperLoopMoveDOM = true;
              slidesEl.append(slides[index]);
              slides[index].swiperLoopMoveDOM = false;
            });
          }
          swiper.recalcSlides();
          if (params.slidesPerView === 'auto') {
            swiper.updateSlides();
          } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
            swiper.slides.forEach((slide, slideIndex) => {
              swiper.grid.updateSlide(slideIndex, slide, swiper.slides);
            });
          }
          if (params.watchSlidesProgress) {
            swiper.updateSlidesOffset();
          }
          if (slideTo) {
            if (prependSlidesIndexes.length > 0 && isPrev) {
              if (typeof slideRealIndex === 'undefined') {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) {
                  swiper.setTranslate(swiper.translate - diff);
                } else {
                  swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
                  if (setTranslate) {
                    swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                    swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                  }
                }
              } else {
                if (setTranslate) {
                  const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
                  swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
                  swiper.touchEventsData.currentTranslate = swiper.translate;
                }
              }
            } else if (appendSlidesIndexes.length > 0 && isNext) {
              if (typeof slideRealIndex === 'undefined') {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) {
                  swiper.setTranslate(swiper.translate - diff);
                } else {
                  swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                  if (setTranslate) {
                    swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                    swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                  }
                }
              } else {
                const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
                swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
              }
            }
          }
          swiper.allowSlidePrev = allowSlidePrev;
          swiper.allowSlideNext = allowSlideNext;
          if (swiper.controller && swiper.controller.control && !byController) {
            const loopParams = {
              slideRealIndex,
              direction,
              setTranslate,
              activeSlideIndex,
              byController: true
            };
            if (Array.isArray(swiper.controller.control)) {
              swiper.controller.control.forEach(c => {
                if (!c.destroyed && c.params.loop) c.loopFix({
                  ...loopParams,
                  slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
                });
              });
            } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
              swiper.controller.control.loopFix({
                ...loopParams,
                slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
              });
            }
          }
          swiper.emit('loopFix');
        }
        function loopDestroy() {
          const swiper = this;
          const {
            params,
            slidesEl
          } = swiper;
          if (!params.loop || !slidesEl || swiper.virtual && swiper.params.virtual.enabled) return;
          swiper.recalcSlides();
          const newSlidesOrder = [];
          swiper.slides.forEach(slideEl => {
            const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;
            newSlidesOrder[index] = slideEl;
          });
          swiper.slides.forEach(slideEl => {
            slideEl.removeAttribute('data-swiper-slide-index');
          });
          newSlidesOrder.forEach(slideEl => {
            slidesEl.append(slideEl);
          });
          swiper.recalcSlides();
          swiper.slideTo(swiper.realIndex, 0);
        }
        var loop = {
          loopCreate,
          loopFix,
          loopDestroy
        };
        function setGrabCursor(moving) {
          const swiper = this;
          if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
          const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
          if (swiper.isElement) {
            swiper.__preventObserver__ = true;
          }
          el.style.cursor = 'move';
          el.style.cursor = moving ? 'grabbing' : 'grab';
          if (swiper.isElement) {
            requestAnimationFrame(() => {
              swiper.__preventObserver__ = false;
            });
          }
        }
        function unsetGrabCursor() {
          const swiper = this;
          if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
            return;
          }
          if (swiper.isElement) {
            swiper.__preventObserver__ = true;
          }
          swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
          if (swiper.isElement) {
            requestAnimationFrame(() => {
              swiper.__preventObserver__ = false;
            });
          }
        }
        var grabCursor = {
          setGrabCursor,
          unsetGrabCursor
        };

        // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
        function closestElement(selector, base = this) {
          function __closestFrom(el) {
            if (!el || el === getDocument() || el === getWindow()) return null;
            if (el.assignedSlot) el = el.assignedSlot;
            const found = el.closest(selector);
            if (!found && !el.getRootNode) {
              return null;
            }
            return found || __closestFrom(el.getRootNode().host);
          }
          return __closestFrom(base);
        }
        function preventEdgeSwipe(swiper, event, startX) {
          const window = getWindow();
          const {
            params
          } = swiper;
          const edgeSwipeDetection = params.edgeSwipeDetection;
          const edgeSwipeThreshold = params.edgeSwipeThreshold;
          if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
            if (edgeSwipeDetection === 'prevent') {
              event.preventDefault();
              return true;
            }
            return false;
          }
          return true;
        }
        function onTouchStart(event) {
          const swiper = this;
          const document = getDocument();
          let e = event;
          if (e.originalEvent) e = e.originalEvent;
          const data = swiper.touchEventsData;
          if (e.type === 'pointerdown') {
            if (data.pointerId !== null && data.pointerId !== e.pointerId) {
              return;
            }
            data.pointerId = e.pointerId;
          } else if (e.type === 'touchstart' && e.targetTouches.length === 1) {
            data.touchId = e.targetTouches[0].identifier;
          }
          if (e.type === 'touchstart') {
            // don't proceed touch event
            preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
            return;
          }
          const {
            params,
            touches,
            enabled
          } = swiper;
          if (!enabled) return;
          if (!params.simulateTouch && e.pointerType === 'mouse') return;
          if (swiper.animating && params.preventInteractionOnTransition) {
            return;
          }
          if (!swiper.animating && params.cssMode && params.loop) {
            swiper.loopFix();
          }
          let targetEl = e.target;
          if (params.touchEventsTarget === 'wrapper') {
            if (!elementIsChildOf(targetEl, swiper.wrapperEl)) return;
          }
          if ('which' in e && e.which === 3) return;
          if ('button' in e && e.button > 0) return;
          if (data.isTouched && data.isMoved) return;

          // change target el for shadow root component
          const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
          // eslint-disable-next-line
          const eventPath = e.composedPath ? e.composedPath() : e.path;
          if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
            targetEl = eventPath[0];
          }
          const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
          const isTargetShadow = !!(e.target && e.target.shadowRoot);

          // use closestElement for shadow root element to get the actual closest for nested shadow root element
          if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
            swiper.allowClick = true;
            return;
          }
          if (params.swipeHandler) {
            if (!targetEl.closest(params.swipeHandler)) return;
          }
          touches.currentX = e.pageX;
          touches.currentY = e.pageY;
          const startX = touches.currentX;
          const startY = touches.currentY;

          // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

          if (!preventEdgeSwipe(swiper, e, startX)) {
            return;
          }
          Object.assign(data, {
            isTouched: true,
            isMoved: false,
            allowTouchCallbacks: true,
            isScrolling: undefined,
            startMoving: undefined
          });
          touches.startX = startX;
          touches.startY = startY;
          data.touchStartTime = now();
          swiper.allowClick = true;
          swiper.updateSize();
          swiper.swipeDirection = undefined;
          if (params.threshold > 0) data.allowThresholdMove = false;
          let preventDefault = true;
          if (targetEl.matches(data.focusableElements)) {
            preventDefault = false;
            if (targetEl.nodeName === 'SELECT') {
              data.isTouched = false;
            }
          }
          if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl && (e.pointerType === 'mouse' || e.pointerType !== 'mouse' && !targetEl.matches(data.focusableElements))) {
            document.activeElement.blur();
          }
          const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
          if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
            e.preventDefault();
          }
          if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
            swiper.freeMode.onTouchStart();
          }
          swiper.emit('touchStart', e);
        }
        function onTouchMove(event) {
          const document = getDocument();
          const swiper = this;
          const data = swiper.touchEventsData;
          const {
            params,
            touches,
            rtlTranslate: rtl,
            enabled
          } = swiper;
          if (!enabled) return;
          if (!params.simulateTouch && event.pointerType === 'mouse') return;
          let e = event;
          if (e.originalEvent) e = e.originalEvent;
          if (e.type === 'pointermove') {
            if (data.touchId !== null) return; // return from pointer if we use touch
            const id = e.pointerId;
            if (id !== data.pointerId) return;
          }
          let targetTouch;
          if (e.type === 'touchmove') {
            targetTouch = [...e.changedTouches].find(t => t.identifier === data.touchId);
            if (!targetTouch || targetTouch.identifier !== data.touchId) return;
          } else {
            targetTouch = e;
          }
          if (!data.isTouched) {
            if (data.startMoving && data.isScrolling) {
              swiper.emit('touchMoveOpposite', e);
            }
            return;
          }
          const pageX = targetTouch.pageX;
          const pageY = targetTouch.pageY;
          if (e.preventedByNestedSwiper) {
            touches.startX = pageX;
            touches.startY = pageY;
            return;
          }
          if (!swiper.allowTouchMove) {
            if (!e.target.matches(data.focusableElements)) {
              swiper.allowClick = false;
            }
            if (data.isTouched) {
              Object.assign(touches, {
                startX: pageX,
                startY: pageY,
                currentX: pageX,
                currentY: pageY
              });
              data.touchStartTime = now();
            }
            return;
          }
          if (params.touchReleaseOnEdges && !params.loop) {
            if (swiper.isVertical()) {
              // Vertical
              if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                data.isTouched = false;
                data.isMoved = false;
                return;
              }
            } else if (rtl && (pageX > touches.startX && -swiper.translate <= swiper.maxTranslate() || pageX < touches.startX && -swiper.translate >= swiper.minTranslate())) {
              return;
            } else if (!rtl && (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate())) {
              return;
            }
          }
          if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== e.target && e.pointerType !== 'mouse') {
            document.activeElement.blur();
          }
          if (document.activeElement) {
            if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
              data.isMoved = true;
              swiper.allowClick = false;
              return;
            }
          }
          if (data.allowTouchCallbacks) {
            swiper.emit('touchMove', e);
          }
          touches.previousX = touches.currentX;
          touches.previousY = touches.currentY;
          touches.currentX = pageX;
          touches.currentY = pageY;
          const diffX = touches.currentX - touches.startX;
          const diffY = touches.currentY - touches.startY;
          if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
          if (typeof data.isScrolling === 'undefined') {
            let touchAngle;
            if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
              data.isScrolling = false;
            } else {
              // eslint-disable-next-line
              if (diffX * diffX + diffY * diffY >= 25) {
                touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
              }
            }
          }
          if (data.isScrolling) {
            swiper.emit('touchMoveOpposite', e);
          }
          if (typeof data.startMoving === 'undefined') {
            if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
              data.startMoving = true;
            }
          }
          if (data.isScrolling || e.type === 'touchmove' && data.preventTouchMoveFromPointerMove) {
            data.isTouched = false;
            return;
          }
          if (!data.startMoving) {
            return;
          }
          swiper.allowClick = false;
          if (!params.cssMode && e.cancelable) {
            e.preventDefault();
          }
          if (params.touchMoveStopPropagation && !params.nested) {
            e.stopPropagation();
          }
          let diff = swiper.isHorizontal() ? diffX : diffY;
          let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
          if (params.oneWayMovement) {
            diff = Math.abs(diff) * (rtl ? 1 : -1);
            touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
          }
          touches.diff = diff;
          diff *= params.touchRatio;
          if (rtl) {
            diff = -diff;
            touchesDiff = -touchesDiff;
          }
          const prevTouchesDirection = swiper.touchesDirection;
          swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
          swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';
          const isLoop = swiper.params.loop && !params.cssMode;
          const allowLoopFix = swiper.touchesDirection === 'next' && swiper.allowSlideNext || swiper.touchesDirection === 'prev' && swiper.allowSlidePrev;
          if (!data.isMoved) {
            if (isLoop && allowLoopFix) {
              swiper.loopFix({
                direction: swiper.swipeDirection
              });
            }
            data.startTranslate = swiper.getTranslate();
            swiper.setTransition(0);
            if (swiper.animating) {
              const evt = new window.CustomEvent('transitionend', {
                bubbles: true,
                cancelable: true,
                detail: {
                  bySwiperTouchMove: true
                }
              });
              swiper.wrapperEl.dispatchEvent(evt);
            }
            data.allowMomentumBounce = false;
            // Grab Cursor
            if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
              swiper.setGrabCursor(true);
            }
            swiper.emit('sliderFirstMove', e);
          }
          new Date().getTime();
          if (params._loopSwapReset !== false && data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
            Object.assign(touches, {
              startX: pageX,
              startY: pageY,
              currentX: pageX,
              currentY: pageY,
              startTranslate: data.currentTranslate
            });
            data.loopSwapReset = true;
            data.startTranslate = data.currentTranslate;
            return;
          }
          swiper.emit('sliderMove', e);
          data.isMoved = true;
          data.currentTranslate = diff + data.startTranslate;
          let disableParentSwiper = true;
          let resistanceRatio = params.resistanceRatio;
          if (params.touchReleaseOnEdges) {
            resistanceRatio = 0;
          }
          if (diff > 0) {
            if (isLoop && allowLoopFix && true && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {
              swiper.loopFix({
                direction: 'prev',
                setTranslate: true,
                activeSlideIndex: 0
              });
            }
            if (data.currentTranslate > swiper.minTranslate()) {
              disableParentSwiper = false;
              if (params.resistance) {
                data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
              }
            }
          } else if (diff < 0) {
            if (isLoop && allowLoopFix && true && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {
              swiper.loopFix({
                direction: 'next',
                setTranslate: true,
                activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
              });
            }
            if (data.currentTranslate < swiper.maxTranslate()) {
              disableParentSwiper = false;
              if (params.resistance) {
                data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
              }
            }
          }
          if (disableParentSwiper) {
            e.preventedByNestedSwiper = true;
          }

          // Directions locks
          if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
            data.currentTranslate = data.startTranslate;
          }
          if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
            data.currentTranslate = data.startTranslate;
          }
          if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
            data.currentTranslate = data.startTranslate;
          }

          // Threshold
          if (params.threshold > 0) {
            if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
              if (!data.allowThresholdMove) {
                data.allowThresholdMove = true;
                touches.startX = touches.currentX;
                touches.startY = touches.currentY;
                data.currentTranslate = data.startTranslate;
                touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                return;
              }
            } else {
              data.currentTranslate = data.startTranslate;
              return;
            }
          }
          if (!params.followFinger || params.cssMode) return;

          // Update active index in free mode
          if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
          }
          if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
            swiper.freeMode.onTouchMove();
          }
          // Update progress
          swiper.updateProgress(data.currentTranslate);
          // Update translate
          swiper.setTranslate(data.currentTranslate);
        }
        function onTouchEnd(event) {
          const swiper = this;
          const data = swiper.touchEventsData;
          let e = event;
          if (e.originalEvent) e = e.originalEvent;
          let targetTouch;
          const isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel';
          if (!isTouchEvent) {
            if (data.touchId !== null) return; // return from pointer if we use touch
            if (e.pointerId !== data.pointerId) return;
            targetTouch = e;
          } else {
            targetTouch = [...e.changedTouches].find(t => t.identifier === data.touchId);
            if (!targetTouch || targetTouch.identifier !== data.touchId) return;
          }
          if (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(e.type)) {
            const proceed = ['pointercancel', 'contextmenu'].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
            if (!proceed) {
              return;
            }
          }
          data.pointerId = null;
          data.touchId = null;
          const {
            params,
            touches,
            rtlTranslate: rtl,
            slidesGrid,
            enabled
          } = swiper;
          if (!enabled) return;
          if (!params.simulateTouch && e.pointerType === 'mouse') return;
          if (data.allowTouchCallbacks) {
            swiper.emit('touchEnd', e);
          }
          data.allowTouchCallbacks = false;
          if (!data.isTouched) {
            if (data.isMoved && params.grabCursor) {
              swiper.setGrabCursor(false);
            }
            data.isMoved = false;
            data.startMoving = false;
            return;
          }

          // Return Grab Cursor
          if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(false);
          }

          // Time diff
          const touchEndTime = now();
          const timeDiff = touchEndTime - data.touchStartTime;

          // Tap, doubleTap, Click
          if (swiper.allowClick) {
            const pathTree = e.path || e.composedPath && e.composedPath();
            swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
            swiper.emit('tap click', e);
            if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
              swiper.emit('doubleTap doubleClick', e);
            }
          }
          data.lastClickTime = now();
          nextTick(() => {
            if (!swiper.destroyed) swiper.allowClick = true;
          });
          if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            return;
          }
          data.isTouched = false;
          data.isMoved = false;
          data.startMoving = false;
          let currentPos;
          if (params.followFinger) {
            currentPos = rtl ? swiper.translate : -swiper.translate;
          } else {
            currentPos = -data.currentTranslate;
          }
          if (params.cssMode) {
            return;
          }
          if (params.freeMode && params.freeMode.enabled) {
            swiper.freeMode.onTouchEnd({
              currentPos
            });
            return;
          }

          // Find current slide
          const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
          let stopIndex = 0;
          let groupSize = swiper.slidesSizesGrid[0];
          for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
            const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (typeof slidesGrid[i + increment] !== 'undefined') {
              if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                stopIndex = i;
                groupSize = slidesGrid[i + increment] - slidesGrid[i];
              }
            } else if (swipeToLast || currentPos >= slidesGrid[i]) {
              stopIndex = i;
              groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
            }
          }
          let rewindFirstIndex = null;
          let rewindLastIndex = null;
          if (params.rewind) {
            if (swiper.isBeginning) {
              rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
            } else if (swiper.isEnd) {
              rewindFirstIndex = 0;
            }
          }
          // Find current slide size
          const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
          const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
          if (timeDiff > params.longSwipesMs) {
            // Long touches
            if (!params.longSwipes) {
              swiper.slideTo(swiper.activeIndex);
              return;
            }
            if (swiper.swipeDirection === 'next') {
              if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
            }
            if (swiper.swipeDirection === 'prev') {
              if (ratio > 1 - params.longSwipesRatio) {
                swiper.slideTo(stopIndex + increment);
              } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
                swiper.slideTo(rewindLastIndex);
              } else {
                swiper.slideTo(stopIndex);
              }
            }
          } else {
            // Short swipes
            if (!params.shortSwipes) {
              swiper.slideTo(swiper.activeIndex);
              return;
            }
            const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
            if (!isNavButtonTarget) {
              if (swiper.swipeDirection === 'next') {
                swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
              }
              if (swiper.swipeDirection === 'prev') {
                swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
              }
            } else if (e.target === swiper.navigation.nextEl) {
              swiper.slideTo(stopIndex + increment);
            } else {
              swiper.slideTo(stopIndex);
            }
          }
        }
        function onResize() {
          const swiper = this;
          const {
            params,
            el
          } = swiper;
          if (el && el.offsetWidth === 0) return;

          // Breakpoints
          if (params.breakpoints) {
            swiper.setBreakpoint();
          }

          // Save locks
          const {
            allowSlideNext,
            allowSlidePrev,
            snapGrid
          } = swiper;
          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

          // Disable locks on resize
          swiper.allowSlideNext = true;
          swiper.allowSlidePrev = true;
          swiper.updateSize();
          swiper.updateSlides();
          swiper.updateSlidesClasses();
          const isVirtualLoop = isVirtual && params.loop;
          if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
            swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            if (swiper.params.loop && !isVirtual) {
              swiper.slideToLoop(swiper.realIndex, 0, false, true);
            } else {
              swiper.slideTo(swiper.activeIndex, 0, false, true);
            }
          }
          if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
            clearTimeout(swiper.autoplay.resizeTimeout);
            swiper.autoplay.resizeTimeout = setTimeout(() => {
              if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                swiper.autoplay.resume();
              }
            }, 500);
          }
          // Return locks after resize
          swiper.allowSlidePrev = allowSlidePrev;
          swiper.allowSlideNext = allowSlideNext;
          if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
          }
        }
        function onClick(e) {
          const swiper = this;
          if (!swiper.enabled) return;
          if (!swiper.allowClick) {
            if (swiper.params.preventClicks) e.preventDefault();
            if (swiper.params.preventClicksPropagation && swiper.animating) {
              e.stopPropagation();
              e.stopImmediatePropagation();
            }
          }
        }
        function onScroll() {
          const swiper = this;
          const {
            wrapperEl,
            rtlTranslate,
            enabled
          } = swiper;
          if (!enabled) return;
          swiper.previousTranslate = swiper.translate;
          if (swiper.isHorizontal()) {
            swiper.translate = -wrapperEl.scrollLeft;
          } else {
            swiper.translate = -wrapperEl.scrollTop;
          }
          // eslint-disable-next-line
          if (swiper.translate === 0) swiper.translate = 0;
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
          let newProgress;
          const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
          if (translatesDiff === 0) {
            newProgress = 0;
          } else {
            newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
          }
          if (newProgress !== swiper.progress) {
            swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
          }
          swiper.emit('setTranslate', swiper.translate, false);
        }
        function onLoad(e) {
          const swiper = this;
          processLazyPreloader(swiper, e.target);
          if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {
            return;
          }
          swiper.update();
        }
        function onDocumentTouchStart() {
          const swiper = this;
          if (swiper.documentTouchHandlerProceeded) return;
          swiper.documentTouchHandlerProceeded = true;
          if (swiper.params.touchReleaseOnEdges) {
            swiper.el.style.touchAction = 'auto';
          }
        }
        const events$1 = (swiper, method) => {
          const document = getDocument();
          const {
            params,
            el,
            wrapperEl,
            device
          } = swiper;
          const capture = !!params.nested;
          const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
          const swiperMethod = method;
          if (!el || typeof el === 'string') return;

          // Touch Events
          document[domMethod]('touchstart', swiper.onDocumentTouchStart, {
            passive: false,
            capture
          });
          el[domMethod]('touchstart', swiper.onTouchStart, {
            passive: false
          });
          el[domMethod]('pointerdown', swiper.onTouchStart, {
            passive: false
          });
          document[domMethod]('touchmove', swiper.onTouchMove, {
            passive: false,
            capture
          });
          document[domMethod]('pointermove', swiper.onTouchMove, {
            passive: false,
            capture
          });
          document[domMethod]('touchend', swiper.onTouchEnd, {
            passive: true
          });
          document[domMethod]('pointerup', swiper.onTouchEnd, {
            passive: true
          });
          document[domMethod]('pointercancel', swiper.onTouchEnd, {
            passive: true
          });
          document[domMethod]('touchcancel', swiper.onTouchEnd, {
            passive: true
          });
          document[domMethod]('pointerout', swiper.onTouchEnd, {
            passive: true
          });
          document[domMethod]('pointerleave', swiper.onTouchEnd, {
            passive: true
          });
          document[domMethod]('contextmenu', swiper.onTouchEnd, {
            passive: true
          });

          // Prevent Links Clicks
          if (params.preventClicks || params.preventClicksPropagation) {
            el[domMethod]('click', swiper.onClick, true);
          }
          if (params.cssMode) {
            wrapperEl[domMethod]('scroll', swiper.onScroll);
          }

          // Resize handler
          if (params.updateOnWindowResize) {
            swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
          } else {
            swiper[swiperMethod]('observerUpdate', onResize, true);
          }

          // Images loader
          el[domMethod]('load', swiper.onLoad, {
            capture: true
          });
        };
        function attachEvents() {
          const swiper = this;
          const {
            params
          } = swiper;
          swiper.onTouchStart = onTouchStart.bind(swiper);
          swiper.onTouchMove = onTouchMove.bind(swiper);
          swiper.onTouchEnd = onTouchEnd.bind(swiper);
          swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
          if (params.cssMode) {
            swiper.onScroll = onScroll.bind(swiper);
          }
          swiper.onClick = onClick.bind(swiper);
          swiper.onLoad = onLoad.bind(swiper);
          events$1(swiper, 'on');
        }
        function detachEvents() {
          const swiper = this;
          events$1(swiper, 'off');
        }
        var events$1$1 = {
          attachEvents,
          detachEvents
        };
        const isGridEnabled = (swiper, params) => {
          return swiper.grid && params.grid && params.grid.rows > 1;
        };
        function setBreakpoint() {
          const swiper = this;
          const {
            realIndex,
            initialized,
            params,
            el
          } = swiper;
          const breakpoints = params.breakpoints;
          if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
          const document = getDocument();

          // Get breakpoint for window/container width and update parameters
          const breakpointsBase = params.breakpointsBase === 'window' || !params.breakpointsBase ? params.breakpointsBase : 'container';
          const breakpointContainer = ['window', 'container'].includes(params.breakpointsBase) || !params.breakpointsBase ? swiper.el : document.querySelector(params.breakpointsBase);
          const breakpoint = swiper.getBreakpoint(breakpoints, breakpointsBase, breakpointContainer);
          if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
          const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
          const breakpointParams = breakpointOnlyParams || swiper.originalParams;
          const wasMultiRow = isGridEnabled(swiper, params);
          const isMultiRow = isGridEnabled(swiper, breakpointParams);
          const wasGrabCursor = swiper.params.grabCursor;
          const isGrabCursor = breakpointParams.grabCursor;
          const wasEnabled = params.enabled;
          if (wasMultiRow && !isMultiRow) {
            el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
            swiper.emitContainerClasses();
          } else if (!wasMultiRow && isMultiRow) {
            el.classList.add(`${params.containerModifierClass}grid`);
            if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
              el.classList.add(`${params.containerModifierClass}grid-column`);
            }
            swiper.emitContainerClasses();
          }
          if (wasGrabCursor && !isGrabCursor) {
            swiper.unsetGrabCursor();
          } else if (!wasGrabCursor && isGrabCursor) {
            swiper.setGrabCursor();
          }

          // Toggle navigation, pagination, scrollbar
          ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
            if (typeof breakpointParams[prop] === 'undefined') return;
            const wasModuleEnabled = params[prop] && params[prop].enabled;
            const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
            if (wasModuleEnabled && !isModuleEnabled) {
              swiper[prop].disable();
            }
            if (!wasModuleEnabled && isModuleEnabled) {
              swiper[prop].enable();
            }
          });
          const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
          const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
          const wasLoop = params.loop;
          if (directionChanged && initialized) {
            swiper.changeDirection();
          }
          extend$1(swiper.params, breakpointParams);
          const isEnabled = swiper.params.enabled;
          const hasLoop = swiper.params.loop;
          Object.assign(swiper, {
            allowTouchMove: swiper.params.allowTouchMove,
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev
          });
          if (wasEnabled && !isEnabled) {
            swiper.disable();
          } else if (!wasEnabled && isEnabled) {
            swiper.enable();
          }
          swiper.currentBreakpoint = breakpoint;
          swiper.emit('_beforeBreakpoint', breakpointParams);
          if (initialized) {
            if (needsReLoop) {
              swiper.loopDestroy();
              swiper.loopCreate(realIndex);
              swiper.updateSlides();
            } else if (!wasLoop && hasLoop) {
              swiper.loopCreate(realIndex);
              swiper.updateSlides();
            } else if (wasLoop && !hasLoop) {
              swiper.loopDestroy();
            }
          }
          swiper.emit('breakpoint', breakpointParams);
        }
        function getBreakpoint(breakpoints, base = 'window', containerEl) {
          if (!breakpoints || base === 'container' && !containerEl) return undefined;
          let breakpoint = false;
          const window = getWindow();
          const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
          const points = Object.keys(breakpoints).map(point => {
            if (typeof point === 'string' && point.indexOf('@') === 0) {
              const minRatio = parseFloat(point.substr(1));
              const value = currentHeight * minRatio;
              return {
                value,
                point
              };
            }
            return {
              value: point,
              point
            };
          });
          points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
          for (let i = 0; i < points.length; i += 1) {
            const {
              point,
              value
            } = points[i];
            if (base === 'window') {
              if (window.matchMedia(`(min-width: ${value}px)`).matches) {
                breakpoint = point;
              }
            } else if (value <= containerEl.clientWidth) {
              breakpoint = point;
            }
          }
          return breakpoint || 'max';
        }
        var breakpoints = {
          setBreakpoint,
          getBreakpoint
        };
        function prepareClasses(entries, prefix) {
          const resultClasses = [];
          entries.forEach(item => {
            if (typeof item === 'object') {
              Object.keys(item).forEach(classNames => {
                if (item[classNames]) {
                  resultClasses.push(prefix + classNames);
                }
              });
            } else if (typeof item === 'string') {
              resultClasses.push(prefix + item);
            }
          });
          return resultClasses;
        }
        function addClasses() {
          const swiper = this;
          const {
            classNames,
            params,
            rtl,
            el,
            device
          } = swiper;
          // prettier-ignore
          const suffixes = prepareClasses(['initialized', params.direction, {
            'free-mode': swiper.params.freeMode && params.freeMode.enabled
          }, {
            'autoheight': params.autoHeight
          }, {
            'rtl': rtl
          }, {
            'grid': params.grid && params.grid.rows > 1
          }, {
            'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
          }, {
            'android': device.android
          }, {
            'ios': device.ios
          }, {
            'css-mode': params.cssMode
          }, {
            'centered': params.cssMode && params.centeredSlides
          }, {
            'watch-progress': params.watchSlidesProgress
          }], params.containerModifierClass);
          classNames.push(...suffixes);
          el.classList.add(...classNames);
          swiper.emitContainerClasses();
        }
        function removeClasses() {
          const swiper = this;
          const {
            el,
            classNames
          } = swiper;
          if (!el || typeof el === 'string') return;
          el.classList.remove(...classNames);
          swiper.emitContainerClasses();
        }
        var classes = {
          addClasses,
          removeClasses
        };
        function checkOverflow() {
          const swiper = this;
          const {
            isLocked: wasLocked,
            params
          } = swiper;
          const {
            slidesOffsetBefore
          } = params;
          if (slidesOffsetBefore) {
            const lastSlideIndex = swiper.slides.length - 1;
            const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
            swiper.isLocked = swiper.size > lastSlideRightEdge;
          } else {
            swiper.isLocked = swiper.snapGrid.length === 1;
          }
          if (params.allowSlideNext === true) {
            swiper.allowSlideNext = !swiper.isLocked;
          }
          if (params.allowSlidePrev === true) {
            swiper.allowSlidePrev = !swiper.isLocked;
          }
          if (wasLocked && wasLocked !== swiper.isLocked) {
            swiper.isEnd = false;
          }
          if (wasLocked !== swiper.isLocked) {
            swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
          }
        }
        var checkOverflow$1 = {
          checkOverflow
        };
        var defaults = {
          init: true,
          direction: 'horizontal',
          oneWayMovement: false,
          swiperElementNodeName: 'SWIPER-CONTAINER',
          touchEventsTarget: 'wrapper',
          initialSlide: 0,
          speed: 300,
          cssMode: false,
          updateOnWindowResize: true,
          resizeObserver: true,
          nested: false,
          createElements: false,
          eventsPrefix: 'swiper',
          enabled: true,
          focusableElements: 'input, select, option, textarea, button, video, label',
          // Overrides
          width: null,
          height: null,
          //
          preventInteractionOnTransition: false,
          // ssr
          userAgent: null,
          url: null,
          // To support iOS's swipe-to-go-back gesture (when being used in-app).
          edgeSwipeDetection: false,
          edgeSwipeThreshold: 20,
          // Autoheight
          autoHeight: false,
          // Set wrapper width
          setWrapperSize: false,
          // Virtual Translate
          virtualTranslate: false,
          // Effects
          effect: 'slide',
          // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

          // Breakpoints
          breakpoints: undefined,
          breakpointsBase: 'window',
          // Slides grid
          spaceBetween: 0,
          slidesPerView: 1,
          slidesPerGroup: 1,
          slidesPerGroupSkip: 0,
          slidesPerGroupAuto: false,
          centeredSlides: false,
          centeredSlidesBounds: false,
          slidesOffsetBefore: 0,
          // in px
          slidesOffsetAfter: 0,
          // in px
          normalizeSlideIndex: true,
          centerInsufficientSlides: false,
          // Disable swiper and hide navigation when container not overflow
          watchOverflow: true,
          // Round length
          roundLengths: false,
          // Touches
          touchRatio: 1,
          touchAngle: 45,
          simulateTouch: true,
          shortSwipes: true,
          longSwipes: true,
          longSwipesRatio: 0.5,
          longSwipesMs: 300,
          followFinger: true,
          allowTouchMove: true,
          threshold: 5,
          touchMoveStopPropagation: false,
          touchStartPreventDefault: true,
          touchStartForcePreventDefault: false,
          touchReleaseOnEdges: false,
          // Unique Navigation Elements
          uniqueNavElements: true,
          // Resistance
          resistance: true,
          resistanceRatio: 0.85,
          // Progress
          watchSlidesProgress: false,
          // Cursor
          grabCursor: false,
          // Clicks
          preventClicks: true,
          preventClicksPropagation: true,
          slideToClickedSlide: false,
          // loop
          loop: false,
          loopAddBlankSlides: true,
          loopAdditionalSlides: 0,
          loopPreventsSliding: true,
          // rewind
          rewind: false,
          // Swiping/no swiping
          allowSlidePrev: true,
          allowSlideNext: true,
          swipeHandler: null,
          // '.swipe-handler',
          noSwiping: true,
          noSwipingClass: 'swiper-no-swiping',
          noSwipingSelector: null,
          // Passive Listeners
          passiveListeners: true,
          maxBackfaceHiddenSlides: 10,
          // NS
          containerModifierClass: 'swiper-',
          // NEW
          slideClass: 'swiper-slide',
          slideBlankClass: 'swiper-slide-blank',
          slideActiveClass: 'swiper-slide-active',
          slideVisibleClass: 'swiper-slide-visible',
          slideFullyVisibleClass: 'swiper-slide-fully-visible',
          slideNextClass: 'swiper-slide-next',
          slidePrevClass: 'swiper-slide-prev',
          wrapperClass: 'swiper-wrapper',
          lazyPreloaderClass: 'swiper-lazy-preloader',
          lazyPreloadPrevNext: 0,
          // Callbacks
          runCallbacksOnInit: true,
          // Internals
          _emitClasses: false
        };
        function moduleExtendParams(params, allModulesParams) {
          return function extendParams(obj = {}) {
            const moduleParamName = Object.keys(obj)[0];
            const moduleParams = obj[moduleParamName];
            if (typeof moduleParams !== 'object' || moduleParams === null) {
              extend$1(allModulesParams, obj);
              return;
            }
            if (params[moduleParamName] === true) {
              params[moduleParamName] = {
                enabled: true
              };
            }
            if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
              params[moduleParamName].auto = true;
            }
            if (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
              params[moduleParamName].auto = true;
            }
            if (!(moduleParamName in params && 'enabled' in moduleParams)) {
              extend$1(allModulesParams, obj);
              return;
            }
            if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
              params[moduleParamName].enabled = true;
            }
            if (!params[moduleParamName]) params[moduleParamName] = {
              enabled: false
            };
            extend$1(allModulesParams, obj);
          };
        }

        /* eslint no-param-reassign: "off" */
        const prototypes = {
          eventsEmitter,
          update,
          translate,
          transition,
          slide,
          loop,
          grabCursor,
          events: events$1$1,
          breakpoints,
          checkOverflow: checkOverflow$1,
          classes
        };
        const extendedDefaults = {};
        let Swiper$1 = class Swiper {
          constructor(...args) {
            let el;
            let params;
            if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
              params = args[0];
            } else {
              [el, params] = args;
            }
            if (!params) params = {};
            params = extend$1({}, params);
            if (el && !params.el) params.el = el;
            const document = getDocument();
            if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {
              const swipers = [];
              document.querySelectorAll(params.el).forEach(containerEl => {
                const newParams = extend$1({}, params, {
                  el: containerEl
                });
                swipers.push(new Swiper(newParams));
              });
              // eslint-disable-next-line no-constructor-return
              return swipers;
            }

            // Swiper Instance
            const swiper = this;
            swiper.__swiper__ = true;
            swiper.support = getSupport();
            swiper.device = getDevice({
              userAgent: params.userAgent
            });
            swiper.browser = getBrowser();
            swiper.eventsListeners = {};
            swiper.eventsAnyListeners = [];
            swiper.modules = [...swiper.__modules__];
            if (params.modules && Array.isArray(params.modules)) {
              swiper.modules.push(...params.modules);
            }
            const allModulesParams = {};
            swiper.modules.forEach(mod => {
              mod({
                params,
                swiper,
                extendParams: moduleExtendParams(params, allModulesParams),
                on: swiper.on.bind(swiper),
                once: swiper.once.bind(swiper),
                off: swiper.off.bind(swiper),
                emit: swiper.emit.bind(swiper)
              });
            });

            // Extend defaults with modules params
            const swiperParams = extend$1({}, defaults, allModulesParams);

            // Extend defaults with passed params
            swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
            swiper.originalParams = extend$1({}, swiper.params);
            swiper.passedParams = extend$1({}, params);

            // add event listeners
            if (swiper.params && swiper.params.on) {
              Object.keys(swiper.params.on).forEach(eventName => {
                swiper.on(eventName, swiper.params.on[eventName]);
              });
            }
            if (swiper.params && swiper.params.onAny) {
              swiper.onAny(swiper.params.onAny);
            }

            // Extend Swiper
            Object.assign(swiper, {
              enabled: swiper.params.enabled,
              el,
              // Classes
              classNames: [],
              // Slides
              slides: [],
              slidesGrid: [],
              snapGrid: [],
              slidesSizesGrid: [],
              // isDirection
              isHorizontal() {
                return swiper.params.direction === 'horizontal';
              },
              isVertical() {
                return swiper.params.direction === 'vertical';
              },
              // Indexes
              activeIndex: 0,
              realIndex: 0,
              //
              isBeginning: true,
              isEnd: false,
              // Props
              translate: 0,
              previousTranslate: 0,
              progress: 0,
              velocity: 0,
              animating: false,
              cssOverflowAdjustment() {
                // Returns 0 unless `translate` is > 2**23
                // Should be subtracted from css values to prevent overflow
                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
              },
              // Locks
              allowSlideNext: swiper.params.allowSlideNext,
              allowSlidePrev: swiper.params.allowSlidePrev,
              // Touch Events
              touchEventsData: {
                isTouched: undefined,
                isMoved: undefined,
                allowTouchCallbacks: undefined,
                touchStartTime: undefined,
                isScrolling: undefined,
                currentTranslate: undefined,
                startTranslate: undefined,
                allowThresholdMove: undefined,
                // Form elements to match
                focusableElements: swiper.params.focusableElements,
                // Last click time
                lastClickTime: 0,
                clickTimeout: undefined,
                // Velocities
                velocities: [],
                allowMomentumBounce: undefined,
                startMoving: undefined,
                pointerId: null,
                touchId: null
              },
              // Clicks
              allowClick: true,
              // Touches
              allowTouchMove: swiper.params.allowTouchMove,
              touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
              },
              // Images
              imagesToLoad: [],
              imagesLoaded: 0
            });
            swiper.emit('_swiper');

            // Init
            if (swiper.params.init) {
              swiper.init();
            }

            // Return app instance
            // eslint-disable-next-line no-constructor-return
            return swiper;
          }
          getDirectionLabel(property) {
            if (this.isHorizontal()) {
              return property;
            }
            // prettier-ignore
            return {
              'width': 'height',
              'margin-top': 'margin-left',
              'margin-bottom ': 'margin-right',
              'margin-left': 'margin-top',
              'margin-right': 'margin-bottom',
              'padding-left': 'padding-top',
              'padding-right': 'padding-bottom',
              'marginRight': 'marginBottom'
            }[property];
          }
          getSlideIndex(slideEl) {
            const {
              slidesEl,
              params
            } = this;
            const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
            const firstSlideIndex = elementIndex(slides[0]);
            return elementIndex(slideEl) - firstSlideIndex;
          }
          getSlideIndexByData(index) {
            return this.getSlideIndex(this.slides.find(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index));
          }
          getSlideIndexWhenGrid(index) {
            if (this.grid && this.params.grid && this.params.grid.rows > 1) {
              if (this.params.grid.fill === 'column') {
                index = Math.floor(index / this.params.grid.rows);
              } else if (this.params.grid.fill === 'row') {
                index = index % Math.ceil(this.slides.length / this.params.grid.rows);
              }
            }
            return index;
          }
          recalcSlides() {
            const swiper = this;
            const {
              slidesEl,
              params
            } = swiper;
            swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
          }
          enable() {
            const swiper = this;
            if (swiper.enabled) return;
            swiper.enabled = true;
            if (swiper.params.grabCursor) {
              swiper.setGrabCursor();
            }
            swiper.emit('enable');
          }
          disable() {
            const swiper = this;
            if (!swiper.enabled) return;
            swiper.enabled = false;
            if (swiper.params.grabCursor) {
              swiper.unsetGrabCursor();
            }
            swiper.emit('disable');
          }
          setProgress(progress, speed) {
            const swiper = this;
            progress = Math.min(Math.max(progress, 0), 1);
            const min = swiper.minTranslate();
            const max = swiper.maxTranslate();
            const current = (max - min) * progress + min;
            swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
          }
          emitContainerClasses() {
            const swiper = this;
            if (!swiper.params._emitClasses || !swiper.el) return;
            const cls = swiper.el.className.split(' ').filter(className => {
              return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
            });
            swiper.emit('_containerClasses', cls.join(' '));
          }
          getSlideClasses(slideEl) {
            const swiper = this;
            if (swiper.destroyed) return '';
            return slideEl.className.split(' ').filter(className => {
              return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
            }).join(' ');
          }
          emitSlidesClasses() {
            const swiper = this;
            if (!swiper.params._emitClasses || !swiper.el) return;
            const updates = [];
            swiper.slides.forEach(slideEl => {
              const classNames = swiper.getSlideClasses(slideEl);
              updates.push({
                slideEl,
                classNames
              });
              swiper.emit('_slideClass', slideEl, classNames);
            });
            swiper.emit('_slideClasses', updates);
          }
          slidesPerViewDynamic(view = 'current', exact = false) {
            const swiper = this;
            const {
              params,
              slides,
              slidesGrid,
              slidesSizesGrid,
              size: swiperSize,
              activeIndex
            } = swiper;
            let spv = 1;
            if (typeof params.slidesPerView === 'number') return params.slidesPerView;
            if (params.centeredSlides) {
              let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
              let breakLoop;
              for (let i = activeIndex + 1; i < slides.length; i += 1) {
                if (slides[i] && !breakLoop) {
                  slideSize += Math.ceil(slides[i].swiperSlideSize);
                  spv += 1;
                  if (slideSize > swiperSize) breakLoop = true;
                }
              }
              for (let i = activeIndex - 1; i >= 0; i -= 1) {
                if (slides[i] && !breakLoop) {
                  slideSize += slides[i].swiperSlideSize;
                  spv += 1;
                  if (slideSize > swiperSize) breakLoop = true;
                }
              }
            } else {
              // eslint-disable-next-line
              if (view === 'current') {
                for (let i = activeIndex + 1; i < slides.length; i += 1) {
                  const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                  if (slideInView) {
                    spv += 1;
                  }
                }
              } else {
                // previous
                for (let i = activeIndex - 1; i >= 0; i -= 1) {
                  const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                  if (slideInView) {
                    spv += 1;
                  }
                }
              }
            }
            return spv;
          }
          update() {
            const swiper = this;
            if (!swiper || swiper.destroyed) return;
            const {
              snapGrid,
              params
            } = swiper;
            // Breakpoints
            if (params.breakpoints) {
              swiper.setBreakpoint();
            }
            [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
              if (imageEl.complete) {
                processLazyPreloader(swiper, imageEl);
              }
            });
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();
            function setTranslate() {
              const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
              const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
              swiper.setTranslate(newTranslate);
              swiper.updateActiveIndex();
              swiper.updateSlidesClasses();
            }
            let translated;
            if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
              setTranslate();
              if (params.autoHeight) {
                swiper.updateAutoHeight();
              }
            } else {
              if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
                const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                translated = swiper.slideTo(slides.length - 1, 0, false, true);
              } else {
                translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
              }
              if (!translated) {
                setTranslate();
              }
            }
            if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
              swiper.checkOverflow();
            }
            swiper.emit('update');
          }
          changeDirection(newDirection, needUpdate = true) {
            const swiper = this;
            const currentDirection = swiper.params.direction;
            if (!newDirection) {
              // eslint-disable-next-line
              newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
            }
            if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
              return swiper;
            }
            swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
            swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
            swiper.emitContainerClasses();
            swiper.params.direction = newDirection;
            swiper.slides.forEach(slideEl => {
              if (newDirection === 'vertical') {
                slideEl.style.width = '';
              } else {
                slideEl.style.height = '';
              }
            });
            swiper.emit('changeDirection');
            if (needUpdate) swiper.update();
            return swiper;
          }
          changeLanguageDirection(direction) {
            const swiper = this;
            if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
            swiper.rtl = direction === 'rtl';
            swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
            if (swiper.rtl) {
              swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
              swiper.el.dir = 'rtl';
            } else {
              swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
              swiper.el.dir = 'ltr';
            }
            swiper.update();
          }
          mount(element) {
            const swiper = this;
            if (swiper.mounted) return true;

            // Find el
            let el = element || swiper.params.el;
            if (typeof el === 'string') {
              el = document.querySelector(el);
            }
            if (!el) {
              return false;
            }
            el.swiper = swiper;
            if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
              swiper.isElement = true;
            }
            const getWrapperSelector = () => {
              return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
            };
            const getWrapper = () => {
              if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                const res = el.shadowRoot.querySelector(getWrapperSelector());
                // Children needs to return slot items
                return res;
              }
              return elementChildren(el, getWrapperSelector())[0];
            };
            // Find Wrapper
            let wrapperEl = getWrapper();
            if (!wrapperEl && swiper.params.createElements) {
              wrapperEl = createElement('div', swiper.params.wrapperClass);
              el.append(wrapperEl);
              elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {
                wrapperEl.append(slideEl);
              });
            }
            Object.assign(swiper, {
              el,
              wrapperEl,
              slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
              hostEl: swiper.isElement ? el.parentNode.host : el,
              mounted: true,
              // RTL
              rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',
              rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),
              wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'
            });
            return true;
          }
          init(el) {
            const swiper = this;
            if (swiper.initialized) return swiper;
            const mounted = swiper.mount(el);
            if (mounted === false) return swiper;
            swiper.emit('beforeInit');

            // Set breakpoint
            if (swiper.params.breakpoints) {
              swiper.setBreakpoint();
            }

            // Add Classes
            swiper.addClasses();

            // Update size
            swiper.updateSize();

            // Update slides
            swiper.updateSlides();
            if (swiper.params.watchOverflow) {
              swiper.checkOverflow();
            }

            // Set Grab Cursor
            if (swiper.params.grabCursor && swiper.enabled) {
              swiper.setGrabCursor();
            }

            // Slide To Initial Slide
            if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
              swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
            } else {
              swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
            }

            // Create loop
            if (swiper.params.loop) {
              swiper.loopCreate(undefined, true);
            }

            // Attach events
            swiper.attachEvents();
            const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
            if (swiper.isElement) {
              lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
            }
            lazyElements.forEach(imageEl => {
              if (imageEl.complete) {
                processLazyPreloader(swiper, imageEl);
              } else {
                imageEl.addEventListener('load', e => {
                  processLazyPreloader(swiper, e.target);
                });
              }
            });
            preload(swiper);

            // Init Flag
            swiper.initialized = true;
            preload(swiper);

            // Emit
            swiper.emit('init');
            swiper.emit('afterInit');
            return swiper;
          }
          destroy(deleteInstance = true, cleanStyles = true) {
            const swiper = this;
            const {
              params,
              el,
              wrapperEl,
              slides
            } = swiper;
            if (typeof swiper.params === 'undefined' || swiper.destroyed) {
              return null;
            }
            swiper.emit('beforeDestroy');

            // Init Flag
            swiper.initialized = false;

            // Detach events
            swiper.detachEvents();

            // Destroy loop
            if (params.loop) {
              swiper.loopDestroy();
            }

            // Cleanup styles
            if (cleanStyles) {
              swiper.removeClasses();
              if (el && typeof el !== 'string') {
                el.removeAttribute('style');
              }
              if (wrapperEl) {
                wrapperEl.removeAttribute('style');
              }
              if (slides && slides.length) {
                slides.forEach(slideEl => {
                  slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                  slideEl.removeAttribute('style');
                  slideEl.removeAttribute('data-swiper-slide-index');
                });
              }
            }
            swiper.emit('destroy');

            // Detach emitter events
            Object.keys(swiper.eventsListeners).forEach(eventName => {
              swiper.off(eventName);
            });
            if (deleteInstance !== false) {
              if (swiper.el && typeof swiper.el !== 'string') {
                swiper.el.swiper = null;
              }
              deleteProps(swiper);
            }
            swiper.destroyed = true;
            return null;
          }
          static extendDefaults(newDefaults) {
            extend$1(extendedDefaults, newDefaults);
          }
          static get extendedDefaults() {
            return extendedDefaults;
          }
          static get defaults() {
            return defaults;
          }
          static installModule(mod) {
            if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
            const modules = Swiper.prototype.__modules__;
            if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
              modules.push(mod);
            }
          }
          static use(module) {
            if (Array.isArray(module)) {
              module.forEach(m => Swiper.installModule(m));
              return Swiper;
            }
            Swiper.installModule(module);
            return Swiper;
          }
        };
        Object.keys(prototypes).forEach(prototypeGroup => {
          Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
            Swiper$1.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
          });
        });
        Swiper$1.use([Resize, Observer]);

        /* underscore in name -> watch for changes */
        const paramsList = ['eventsPrefix', 'injectStyles', 'injectStylesUrls', 'modules', 'init', '_direction', 'oneWayMovement', 'swiperElementNodeName', 'touchEventsTarget', 'initialSlide', '_speed', 'cssMode', 'updateOnWindowResize', 'resizeObserver', 'nested', 'focusableElements', '_enabled', '_width', '_height', 'preventInteractionOnTransition', 'userAgent', 'url', '_edgeSwipeDetection', '_edgeSwipeThreshold', '_freeMode', '_autoHeight', 'setWrapperSize', 'virtualTranslate', '_effect', 'breakpoints', 'breakpointsBase', '_spaceBetween', '_slidesPerView', 'maxBackfaceHiddenSlides', '_grid', '_slidesPerGroup', '_slidesPerGroupSkip', '_slidesPerGroupAuto', '_centeredSlides', '_centeredSlidesBounds', '_slidesOffsetBefore', '_slidesOffsetAfter', 'normalizeSlideIndex', '_centerInsufficientSlides', '_watchOverflow', 'roundLengths', 'touchRatio', 'touchAngle', 'simulateTouch', '_shortSwipes', '_longSwipes', 'longSwipesRatio', 'longSwipesMs', '_followFinger', 'allowTouchMove', '_threshold', 'touchMoveStopPropagation', 'touchStartPreventDefault', 'touchStartForcePreventDefault', 'touchReleaseOnEdges', 'uniqueNavElements', '_resistance', '_resistanceRatio', '_watchSlidesProgress', '_grabCursor', 'preventClicks', 'preventClicksPropagation', '_slideToClickedSlide', '_loop', 'loopAdditionalSlides', 'loopAddBlankSlides', 'loopPreventsSliding', '_rewind', '_allowSlidePrev', '_allowSlideNext', '_swipeHandler', '_noSwiping', 'noSwipingClass', 'noSwipingSelector', 'passiveListeners', 'containerModifierClass', 'slideClass', 'slideActiveClass', 'slideVisibleClass', 'slideFullyVisibleClass', 'slideNextClass', 'slidePrevClass', 'slideBlankClass', 'wrapperClass', 'lazyPreloaderClass', 'lazyPreloadPrevNext', 'runCallbacksOnInit', 'observer', 'observeParents', 'observeSlideChildren',
        // modules
        'a11y', '_autoplay', '_controller', 'coverflowEffect', 'cubeEffect', 'fadeEffect', 'flipEffect', 'creativeEffect', 'cardsEffect', 'hashNavigation', 'history', 'keyboard', 'mousewheel', '_navigation', '_pagination', 'parallax', '_scrollbar', '_thumbs', 'virtual', 'zoom', 'control'];
        function isObject$1(o) {
          return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object' && !o.__swiper__;
        }
        function extend(target, src) {
          const noExtend = ['__proto__', 'constructor', 'prototype'];
          Object.keys(src).filter(key => noExtend.indexOf(key) < 0).forEach(key => {
            if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
              if (src[key].__swiper__) target[key] = src[key];else extend(target[key], src[key]);
            } else {
              target[key] = src[key];
            }
          });
        }
        function needsNavigation(params = {}) {
          return params.navigation && typeof params.navigation.nextEl === 'undefined' && typeof params.navigation.prevEl === 'undefined';
        }
        function needsPagination(params = {}) {
          return params.pagination && typeof params.pagination.el === 'undefined';
        }
        function needsScrollbar(params = {}) {
          return params.scrollbar && typeof params.scrollbar.el === 'undefined';
        }
        function uniqueClasses(classNames = '') {
          const classes = classNames.split(' ').map(c => c.trim()).filter(c => !!c);
          const unique = [];
          classes.forEach(c => {
            if (unique.indexOf(c) < 0) unique.push(c);
          });
          return unique.join(' ');
        }
        function attrToProp(attrName = '') {
          return attrName.replace(/-[a-z]/g, l => l.toUpperCase().replace('-', ''));
        }
        function wrapperClass(className = '') {
          if (!className) return 'swiper-wrapper';
          if (!className.includes('swiper-wrapper')) return `swiper-wrapper ${className}`;
          return className;
        }
        function updateSwiper({
          swiper,
          slides,
          passedParams,
          changedParams,
          nextEl,
          prevEl,
          scrollbarEl,
          paginationEl
        }) {
          const updateParams = changedParams.filter(key => key !== 'children' && key !== 'direction' && key !== 'wrapperClass');
          const {
            params: currentParams,
            pagination,
            navigation,
            scrollbar,
            virtual,
            thumbs
          } = swiper;
          let needThumbsInit;
          let needControllerInit;
          let needPaginationInit;
          let needScrollbarInit;
          let needNavigationInit;
          let loopNeedDestroy;
          let loopNeedEnable;
          let loopNeedReloop;
          if (changedParams.includes('thumbs') && passedParams.thumbs && passedParams.thumbs.swiper && !passedParams.thumbs.swiper.destroyed && currentParams.thumbs && (!currentParams.thumbs.swiper || currentParams.thumbs.swiper.destroyed)) {
            needThumbsInit = true;
          }
          if (changedParams.includes('controller') && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
            needControllerInit = true;
          }
          if (changedParams.includes('pagination') && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
            needPaginationInit = true;
          }
          if (changedParams.includes('scrollbar') && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
            needScrollbarInit = true;
          }
          if (changedParams.includes('navigation') && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
            needNavigationInit = true;
          }
          const destroyModule = mod => {
            if (!swiper[mod]) return;
            swiper[mod].destroy();
            if (mod === 'navigation') {
              if (swiper.isElement) {
                swiper[mod].prevEl.remove();
                swiper[mod].nextEl.remove();
              }
              currentParams[mod].prevEl = undefined;
              currentParams[mod].nextEl = undefined;
              swiper[mod].prevEl = undefined;
              swiper[mod].nextEl = undefined;
            } else {
              if (swiper.isElement) {
                swiper[mod].el.remove();
              }
              currentParams[mod].el = undefined;
              swiper[mod].el = undefined;
            }
          };
          if (changedParams.includes('loop') && swiper.isElement) {
            if (currentParams.loop && !passedParams.loop) {
              loopNeedDestroy = true;
            } else if (!currentParams.loop && passedParams.loop) {
              loopNeedEnable = true;
            } else {
              loopNeedReloop = true;
            }
          }
          updateParams.forEach(key => {
            if (isObject$1(currentParams[key]) && isObject$1(passedParams[key])) {
              Object.assign(currentParams[key], passedParams[key]);
              if ((key === 'navigation' || key === 'pagination' || key === 'scrollbar') && 'enabled' in passedParams[key] && !passedParams[key].enabled) {
                destroyModule(key);
              }
            } else {
              const newValue = passedParams[key];
              if ((newValue === true || newValue === false) && (key === 'navigation' || key === 'pagination' || key === 'scrollbar')) {
                if (newValue === false) {
                  destroyModule(key);
                }
              } else {
                currentParams[key] = passedParams[key];
              }
            }
          });
          if (updateParams.includes('controller') && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {
            swiper.controller.control = currentParams.controller.control;
          }
          if (changedParams.includes('children') && slides && virtual && currentParams.virtual.enabled) {
            virtual.slides = slides;
            virtual.update(true);
          } else if (changedParams.includes('virtual') && virtual && currentParams.virtual.enabled) {
            if (slides) virtual.slides = slides;
            virtual.update(true);
          }
          if (changedParams.includes('children') && slides && currentParams.loop) {
            loopNeedReloop = true;
          }
          if (needThumbsInit) {
            const initialized = thumbs.init();
            if (initialized) thumbs.update(true);
          }
          if (needControllerInit) {
            swiper.controller.control = currentParams.controller.control;
          }
          if (needPaginationInit) {
            if (swiper.isElement && (!paginationEl || typeof paginationEl === 'string')) {
              paginationEl = document.createElement('div');
              paginationEl.classList.add('swiper-pagination');
              paginationEl.part.add('pagination');
              swiper.el.appendChild(paginationEl);
            }
            if (paginationEl) currentParams.pagination.el = paginationEl;
            pagination.init();
            pagination.render();
            pagination.update();
          }
          if (needScrollbarInit) {
            if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === 'string')) {
              scrollbarEl = document.createElement('div');
              scrollbarEl.classList.add('swiper-scrollbar');
              scrollbarEl.part.add('scrollbar');
              swiper.el.appendChild(scrollbarEl);
            }
            if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;
            scrollbar.init();
            scrollbar.updateSize();
            scrollbar.setTranslate();
          }
          if (needNavigationInit) {
            if (swiper.isElement) {
              if (!nextEl || typeof nextEl === 'string') {
                nextEl = document.createElement('div');
                nextEl.classList.add('swiper-button-next');
                setInnerHTML(nextEl, swiper.hostEl.constructor.nextButtonSvg);
                nextEl.part.add('button-next');
                swiper.el.appendChild(nextEl);
              }
              if (!prevEl || typeof prevEl === 'string') {
                prevEl = document.createElement('div');
                prevEl.classList.add('swiper-button-prev');
                setInnerHTML(prevEl, swiper.hostEl.constructor.prevButtonSvg);
                prevEl.part.add('button-prev');
                swiper.el.appendChild(prevEl);
              }
            }
            if (nextEl) currentParams.navigation.nextEl = nextEl;
            if (prevEl) currentParams.navigation.prevEl = prevEl;
            navigation.init();
            navigation.update();
          }
          if (changedParams.includes('allowSlideNext')) {
            swiper.allowSlideNext = passedParams.allowSlideNext;
          }
          if (changedParams.includes('allowSlidePrev')) {
            swiper.allowSlidePrev = passedParams.allowSlidePrev;
          }
          if (changedParams.includes('direction')) {
            swiper.changeDirection(passedParams.direction, false);
          }
          if (loopNeedDestroy || loopNeedReloop) {
            swiper.loopDestroy();
          }
          if (loopNeedEnable || loopNeedReloop) {
            swiper.loopCreate();
          }
          swiper.update();
        }
        function getParams$1(obj = {}, splitEvents = true) {
          const params = {
            on: {}
          };
          const events = {};
          const passedParams = {};
          extend(params, defaults);
          params._emitClasses = true;
          params.init = false;
          const rest = {};
          const allowedParams = paramsList.map(key => key.replace(/_/, ''));
          const plainObj = Object.assign({}, obj);
          Object.keys(plainObj).forEach(key => {
            if (typeof obj[key] === 'undefined') return;
            if (allowedParams.indexOf(key) >= 0) {
              if (isObject$1(obj[key])) {
                params[key] = {};
                passedParams[key] = {};
                extend(params[key], obj[key]);
                extend(passedParams[key], obj[key]);
              } else {
                params[key] = obj[key];
                passedParams[key] = obj[key];
              }
            } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === 'function') {
              if (splitEvents) {
                events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
              } else {
                params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
              }
            } else {
              rest[key] = obj[key];
            }
          });
          ['navigation', 'pagination', 'scrollbar'].forEach(key => {
            if (params[key] === true) params[key] = {};
            if (params[key] === false) delete params[key];
          });
          return {
            params,
            passedParams,
            rest,
            events
          };
        }
        function mountSwiper({
          el,
          nextEl,
          prevEl,
          paginationEl,
          scrollbarEl,
          swiper
        }, swiperParams) {
          if (needsNavigation(swiperParams) && nextEl && prevEl) {
            swiper.params.navigation.nextEl = nextEl;
            swiper.originalParams.navigation.nextEl = nextEl;
            swiper.params.navigation.prevEl = prevEl;
            swiper.originalParams.navigation.prevEl = prevEl;
          }
          if (needsPagination(swiperParams) && paginationEl) {
            swiper.params.pagination.el = paginationEl;
            swiper.originalParams.pagination.el = paginationEl;
          }
          if (needsScrollbar(swiperParams) && scrollbarEl) {
            swiper.params.scrollbar.el = scrollbarEl;
            swiper.originalParams.scrollbar.el = scrollbarEl;
          }
          swiper.init(el);
        }
        function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
          const keys = [];
          if (!oldParams) return keys;
          const addKey = key => {
            if (keys.indexOf(key) < 0) keys.push(key);
          };
          if (children && oldChildren) {
            const oldChildrenKeys = oldChildren.map(getKey);
            const childrenKeys = children.map(getKey);
            if (oldChildrenKeys.join('') !== childrenKeys.join('')) addKey('children');
            if (oldChildren.length !== children.length) addKey('children');
          }
          const watchParams = paramsList.filter(key => key[0] === '_').map(key => key.replace(/_/, ''));
          watchParams.forEach(key => {
            if (key in swiperParams && key in oldParams) {
              if (isObject$1(swiperParams[key]) && isObject$1(oldParams[key])) {
                const newKeys = Object.keys(swiperParams[key]);
                const oldKeys = Object.keys(oldParams[key]);
                if (newKeys.length !== oldKeys.length) {
                  addKey(key);
                } else {
                  newKeys.forEach(newKey => {
                    if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
                      addKey(key);
                    }
                  });
                  oldKeys.forEach(oldKey => {
                    if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);
                  });
                }
              } else if (swiperParams[key] !== oldParams[key]) {
                addKey(key);
              }
            }
          });
          return keys;
        }
        const updateOnVirtualData = swiper => {
          if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;
          swiper.updateSlides();
          swiper.updateProgress();
          swiper.updateSlidesClasses();
          swiper.emit('_virtualUpdated');
          if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {
            swiper.parallax.setTranslate();
          }
        };

        /**
         * Swiper React 12.0.2
         * Most modern mobile touch slider and framework with hardware accelerated transitions
         * https://swiperjs.com
         *
         * Copyright 2014-2025 Vladimir Kharlampidi
         *
         * Released under the MIT License
         *
         * Released on: September 18, 2025
         */

        function _extends$1() {
          _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends$1.apply(this, arguments);
        }
        function isChildSwiperSlide(child) {
          return child.type && child.type.displayName && child.type.displayName.includes('SwiperSlide');
        }
        function processChildren(c) {
          const slides = [];
          React.Children.toArray(c).forEach(child => {
            if (isChildSwiperSlide(child)) {
              slides.push(child);
            } else if (child.props && child.props.children) {
              processChildren(child.props.children).forEach(slide => slides.push(slide));
            }
          });
          return slides;
        }
        function getChildren(c) {
          const slides = [];
          const slots = {
            'container-start': [],
            'container-end': [],
            'wrapper-start': [],
            'wrapper-end': []
          };
          React.Children.toArray(c).forEach(child => {
            if (isChildSwiperSlide(child)) {
              slides.push(child);
            } else if (child.props && child.props.slot && slots[child.props.slot]) {
              slots[child.props.slot].push(child);
            } else if (child.props && child.props.children) {
              const foundSlides = processChildren(child.props.children);
              if (foundSlides.length > 0) {
                foundSlides.forEach(slide => slides.push(slide));
              } else {
                slots['container-end'].push(child);
              }
            } else {
              slots['container-end'].push(child);
            }
          });
          return {
            slides,
            slots
          };
        }
        function renderVirtual(swiper, slides, virtualData) {
          if (!virtualData) return null;
          const getSlideIndex = index => {
            let slideIndex = index;
            if (index < 0) {
              slideIndex = slides.length + index;
            } else if (slideIndex >= slides.length) {
              // eslint-disable-next-line
              slideIndex = slideIndex - slides.length;
            }
            return slideIndex;
          };
          const style = swiper.isHorizontal() ? {
            [swiper.rtlTranslate ? 'right' : 'left']: `${virtualData.offset}px`
          } : {
            top: `${virtualData.offset}px`
          };
          const {
            from,
            to
          } = virtualData;
          const loopFrom = swiper.params.loop ? -slides.length : 0;
          const loopTo = swiper.params.loop ? slides.length * 2 : slides.length;
          const slidesToRender = [];
          for (let i = loopFrom; i < loopTo; i += 1) {
            if (i >= from && i <= to) {
              slidesToRender.push(slides[getSlideIndex(i)]);
            }
          }
          return slidesToRender.map((child, index) => {
            return /*#__PURE__*/React.cloneElement(child, {
              swiper,
              style,
              key: child.props.virtualIndex || child.key || `slide-${index}`
            });
          });
        }
        function useIsomorphicLayoutEffect(callback, deps) {
          // eslint-disable-next-line
          if (typeof window === 'undefined') return reactExports.useEffect(callback, deps);
          return reactExports.useLayoutEffect(callback, deps);
        }
        const SwiperSlideContext = /*#__PURE__*/reactExports.createContext(null);
        const SwiperContext = /*#__PURE__*/reactExports.createContext(null);
        const Swiper = exports("ab", /*#__PURE__*/reactExports.forwardRef(({
          className,
          tag: Tag = 'div',
          wrapperTag: WrapperTag = 'div',
          children,
          onSwiper,
          ...rest
        } = {}, externalElRef) => {
          let eventsAssigned = false;
          const [containerClasses, setContainerClasses] = reactExports.useState('swiper');
          const [virtualData, setVirtualData] = reactExports.useState(null);
          const [breakpointChanged, setBreakpointChanged] = reactExports.useState(false);
          const initializedRef = reactExports.useRef(false);
          const swiperElRef = reactExports.useRef(null);
          const swiperRef = reactExports.useRef(null);
          const oldPassedParamsRef = reactExports.useRef(null);
          const oldSlides = reactExports.useRef(null);
          const nextElRef = reactExports.useRef(null);
          const prevElRef = reactExports.useRef(null);
          const paginationElRef = reactExports.useRef(null);
          const scrollbarElRef = reactExports.useRef(null);
          const {
            params: swiperParams,
            passedParams,
            rest: restProps,
            events
          } = getParams$1(rest);
          const {
            slides,
            slots
          } = getChildren(children);
          const onBeforeBreakpoint = () => {
            setBreakpointChanged(!breakpointChanged);
          };
          Object.assign(swiperParams.on, {
            _containerClasses(swiper, classes) {
              setContainerClasses(classes);
            }
          });
          const initSwiper = () => {
            // init swiper
            Object.assign(swiperParams.on, events);
            eventsAssigned = true;
            const passParams = {
              ...swiperParams
            };
            delete passParams.wrapperClass;
            swiperRef.current = new Swiper$1(passParams);
            if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {
              swiperRef.current.virtual.slides = slides;
              const extendWith = {
                cache: false,
                slides,
                renderExternal: setVirtualData,
                renderExternalUpdate: false
              };
              extend(swiperRef.current.params.virtual, extendWith);
              extend(swiperRef.current.originalParams.virtual, extendWith);
            }
          };
          if (!swiperElRef.current) {
            initSwiper();
          }

          // Listen for breakpoints change
          if (swiperRef.current) {
            swiperRef.current.on('_beforeBreakpoint', onBeforeBreakpoint);
          }
          const attachEvents = () => {
            if (eventsAssigned || !events || !swiperRef.current) return;
            Object.keys(events).forEach(eventName => {
              swiperRef.current.on(eventName, events[eventName]);
            });
          };
          const detachEvents = () => {
            if (!events || !swiperRef.current) return;
            Object.keys(events).forEach(eventName => {
              swiperRef.current.off(eventName, events[eventName]);
            });
          };
          reactExports.useEffect(() => {
            return () => {
              if (swiperRef.current) swiperRef.current.off('_beforeBreakpoint', onBeforeBreakpoint);
            };
          });

          // set initialized flag
          reactExports.useEffect(() => {
            if (!initializedRef.current && swiperRef.current) {
              swiperRef.current.emitSlidesClasses();
              initializedRef.current = true;
            }
          });

          // mount swiper
          useIsomorphicLayoutEffect(() => {
            if (externalElRef) {
              externalElRef.current = swiperElRef.current;
            }
            if (!swiperElRef.current) return;
            if (swiperRef.current.destroyed) {
              initSwiper();
            }
            mountSwiper({
              el: swiperElRef.current,
              nextEl: nextElRef.current,
              prevEl: prevElRef.current,
              paginationEl: paginationElRef.current,
              scrollbarEl: scrollbarElRef.current,
              swiper: swiperRef.current
            }, swiperParams);
            if (onSwiper && !swiperRef.current.destroyed) onSwiper(swiperRef.current);
            // eslint-disable-next-line
            return () => {
              if (swiperRef.current && !swiperRef.current.destroyed) {
                swiperRef.current.destroy(true, false);
              }
            };
          }, []);

          // watch for params change
          useIsomorphicLayoutEffect(() => {
            attachEvents();
            const changedParams = getChangedParams(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, c => c.key);
            oldPassedParamsRef.current = passedParams;
            oldSlides.current = slides;
            if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {
              updateSwiper({
                swiper: swiperRef.current,
                slides,
                passedParams,
                changedParams,
                nextEl: nextElRef.current,
                prevEl: prevElRef.current,
                scrollbarEl: scrollbarElRef.current,
                paginationEl: paginationElRef.current
              });
            }
            return () => {
              detachEvents();
            };
          });

          // update on virtual update
          useIsomorphicLayoutEffect(() => {
            updateOnVirtualData(swiperRef.current);
          }, [virtualData]);

          // bypass swiper instance to slides
          function renderSlides() {
            if (swiperParams.virtual) {
              return renderVirtual(swiperRef.current, slides, virtualData);
            }
            return slides.map((child, index) => {
              return /*#__PURE__*/React.cloneElement(child, {
                swiper: swiperRef.current,
                swiperSlideIndex: index
              });
            });
          }
          return /*#__PURE__*/React.createElement(Tag, _extends$1({
            ref: swiperElRef,
            className: uniqueClasses(`${containerClasses}${className ? ` ${className}` : ''}`)
          }, restProps), /*#__PURE__*/React.createElement(SwiperContext.Provider, {
            value: swiperRef.current
          }, slots['container-start'], /*#__PURE__*/React.createElement(WrapperTag, {
            className: wrapperClass(swiperParams.wrapperClass)
          }, slots['wrapper-start'], renderSlides(), slots['wrapper-end']), needsNavigation(swiperParams) && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
            ref: prevElRef,
            className: "swiper-button-prev"
          }), /*#__PURE__*/React.createElement("div", {
            ref: nextElRef,
            className: "swiper-button-next"
          })), needsScrollbar(swiperParams) && /*#__PURE__*/React.createElement("div", {
            ref: scrollbarElRef,
            className: "swiper-scrollbar"
          }), needsPagination(swiperParams) && /*#__PURE__*/React.createElement("div", {
            ref: paginationElRef,
            className: "swiper-pagination"
          }), slots['container-end']));
        }));
        Swiper.displayName = 'Swiper';
        const SwiperSlide$1 = exports("ae", /*#__PURE__*/reactExports.forwardRef(({
          tag: Tag = 'div',
          children,
          className = '',
          swiper,
          zoom,
          lazy,
          virtualIndex,
          swiperSlideIndex,
          ...rest
        } = {}, externalRef) => {
          const slideElRef = reactExports.useRef(null);
          const [slideClasses, setSlideClasses] = reactExports.useState('swiper-slide');
          const [lazyLoaded, setLazyLoaded] = reactExports.useState(false);
          function updateClasses(_s, el, classNames) {
            if (el === slideElRef.current) {
              setSlideClasses(classNames);
            }
          }
          useIsomorphicLayoutEffect(() => {
            if (typeof swiperSlideIndex !== 'undefined') {
              slideElRef.current.swiperSlideIndex = swiperSlideIndex;
            }
            if (externalRef) {
              externalRef.current = slideElRef.current;
            }
            if (!slideElRef.current || !swiper) {
              return;
            }
            if (swiper.destroyed) {
              if (slideClasses !== 'swiper-slide') {
                setSlideClasses('swiper-slide');
              }
              return;
            }
            swiper.on('_slideClass', updateClasses);
            // eslint-disable-next-line
            return () => {
              if (!swiper) return;
              swiper.off('_slideClass', updateClasses);
            };
          });
          useIsomorphicLayoutEffect(() => {
            if (swiper && slideElRef.current && !swiper.destroyed) {
              setSlideClasses(swiper.getSlideClasses(slideElRef.current));
            }
          }, [swiper]);
          const slideData = {
            isActive: slideClasses.indexOf('swiper-slide-active') >= 0,
            isVisible: slideClasses.indexOf('swiper-slide-visible') >= 0,
            isPrev: slideClasses.indexOf('swiper-slide-prev') >= 0,
            isNext: slideClasses.indexOf('swiper-slide-next') >= 0
          };
          const renderChildren = () => {
            return typeof children === 'function' ? children(slideData) : children;
          };
          const onLoad = () => {
            setLazyLoaded(true);
          };
          return /*#__PURE__*/React.createElement(Tag, _extends$1({
            ref: slideElRef,
            className: uniqueClasses(`${slideClasses}${className ? ` ${className}` : ''}`),
            "data-swiper-slide-index": virtualIndex,
            onLoad: onLoad
          }, rest), zoom && /*#__PURE__*/React.createElement(SwiperSlideContext.Provider, {
            value: slideData
          }, /*#__PURE__*/React.createElement("div", {
            className: "swiper-zoom-container",
            "data-swiper-zoom": typeof zoom === 'number' ? zoom : undefined
          }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/React.createElement("div", {
            className: "swiper-lazy-preloader"
          }))), !zoom && /*#__PURE__*/React.createElement(SwiperSlideContext.Provider, {
            value: slideData
          }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/React.createElement("div", {
            className: "swiper-lazy-preloader"
          })));
        }));
        SwiperSlide$1.displayName = 'SwiperSlide';
        function Virtual({
          swiper,
          extendParams,
          on,
          emit
        }) {
          extendParams({
            virtual: {
              enabled: false,
              slides: [],
              cache: true,
              slidesPerViewAutoSlideSize: 320,
              renderSlide: null,
              renderExternal: null,
              renderExternalUpdate: true,
              addSlidesBefore: 0,
              addSlidesAfter: 0
            }
          });
          let cssModeTimeout;
          const document = getDocument();
          swiper.virtual = {
            cache: {},
            from: undefined,
            to: undefined,
            slides: [],
            offset: 0,
            slidesGrid: []
          };
          const tempDOM = document.createElement('div');
          function renderSlide(slide, index) {
            const params = swiper.params.virtual;
            if (params.cache && swiper.virtual.cache[index]) {
              return swiper.virtual.cache[index];
            }
            // eslint-disable-next-line
            let slideEl;
            if (params.renderSlide) {
              slideEl = params.renderSlide.call(swiper, slide, index);
              if (typeof slideEl === 'string') {
                setInnerHTML(tempDOM, slideEl);
                slideEl = tempDOM.children[0];
              }
            } else if (swiper.isElement) {
              slideEl = createElement('swiper-slide');
            } else {
              slideEl = createElement('div', swiper.params.slideClass);
            }
            slideEl.setAttribute('data-swiper-slide-index', index);
            if (!params.renderSlide) {
              setInnerHTML(slideEl, slide);
            }
            if (params.cache) {
              swiper.virtual.cache[index] = slideEl;
            }
            return slideEl;
          }
          function update(force, beforeInit, forceActiveIndex) {
            const {
              slidesPerGroup,
              centeredSlides,
              slidesPerView,
              loop: isLoop,
              initialSlide
            } = swiper.params;
            if (beforeInit && !isLoop && initialSlide > 0) {
              return;
            }
            const {
              addSlidesBefore,
              addSlidesAfter,
              slidesPerViewAutoSlideSize
            } = swiper.params.virtual;
            const {
              from: previousFrom,
              to: previousTo,
              slides,
              slidesGrid: previousSlidesGrid,
              offset: previousOffset
            } = swiper.virtual;
            if (!swiper.params.cssMode) {
              swiper.updateActiveIndex();
            }
            const activeIndex = typeof forceActiveIndex === 'undefined' ? swiper.activeIndex || 0 : forceActiveIndex;
            let offsetProp;
            if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
            let slidesPerViewNumeric;
            if (slidesPerView === 'auto') {
              if (slidesPerViewAutoSlideSize) {
                let swiperSize = swiper.size;
                if (!swiperSize) {
                  swiperSize = swiper.isHorizontal() ? swiper.el.getBoundingClientRect().width : swiper.el.getBoundingClientRect().height;
                }
                slidesPerViewNumeric = Math.max(1, Math.ceil(swiperSize / slidesPerViewAutoSlideSize));
              } else {
                slidesPerViewNumeric = 1;
              }
            } else {
              slidesPerViewNumeric = slidesPerView;
            }
            let slidesAfter;
            let slidesBefore;
            if (centeredSlides) {
              slidesAfter = Math.floor(slidesPerViewNumeric / 2) + slidesPerGroup + addSlidesAfter;
              slidesBefore = Math.floor(slidesPerViewNumeric / 2) + slidesPerGroup + addSlidesBefore;
            } else {
              slidesAfter = slidesPerViewNumeric + (slidesPerGroup - 1) + addSlidesAfter;
              slidesBefore = (isLoop ? slidesPerViewNumeric : slidesPerGroup) + addSlidesBefore;
            }
            let from = activeIndex - slidesBefore;
            let to = activeIndex + slidesAfter;
            if (!isLoop) {
              from = Math.max(from, 0);
              to = Math.min(to, slides.length - 1);
            }
            let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
            if (isLoop && activeIndex >= slidesBefore) {
              from -= slidesBefore;
              if (!centeredSlides) offset += swiper.slidesGrid[0];
            } else if (isLoop && activeIndex < slidesBefore) {
              from = -slidesBefore;
              if (centeredSlides) offset += swiper.slidesGrid[0];
            }
            Object.assign(swiper.virtual, {
              from,
              to,
              offset,
              slidesGrid: swiper.slidesGrid,
              slidesBefore,
              slidesAfter
            });
            function onRendered() {
              swiper.updateSlides();
              swiper.updateProgress();
              swiper.updateSlidesClasses();
              emit('virtualUpdate');
            }
            if (previousFrom === from && previousTo === to && !force) {
              if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
                swiper.slides.forEach(slideEl => {
                  slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
                });
              }
              swiper.updateProgress();
              emit('virtualUpdate');
              return;
            }
            if (swiper.params.virtual.renderExternal) {
              swiper.params.virtual.renderExternal.call(swiper, {
                offset,
                from,
                to,
                slides: function getSlides() {
                  const slidesToRender = [];
                  for (let i = from; i <= to; i += 1) {
                    slidesToRender.push(slides[i]);
                  }
                  return slidesToRender;
                }()
              });
              if (swiper.params.virtual.renderExternalUpdate) {
                onRendered();
              } else {
                emit('virtualUpdate');
              }
              return;
            }
            const prependIndexes = [];
            const appendIndexes = [];
            const getSlideIndex = index => {
              let slideIndex = index;
              if (index < 0) {
                slideIndex = slides.length + index;
              } else if (slideIndex >= slides.length) {
                // eslint-disable-next-line
                slideIndex = slideIndex - slides.length;
              }
              return slideIndex;
            };
            if (force) {
              swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`)).forEach(slideEl => {
                slideEl.remove();
              });
            } else {
              for (let i = previousFrom; i <= previousTo; i += 1) {
                if (i < from || i > to) {
                  const slideIndex = getSlideIndex(i);
                  swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}[data-swiper-slide-index="${slideIndex}"], swiper-slide[data-swiper-slide-index="${slideIndex}"]`)).forEach(slideEl => {
                    slideEl.remove();
                  });
                }
              }
            }
            const loopFrom = isLoop ? -slides.length : 0;
            const loopTo = isLoop ? slides.length * 2 : slides.length;
            for (let i = loopFrom; i < loopTo; i += 1) {
              if (i >= from && i <= to) {
                const slideIndex = getSlideIndex(i);
                if (typeof previousTo === 'undefined' || force) {
                  appendIndexes.push(slideIndex);
                } else {
                  if (i > previousTo) appendIndexes.push(slideIndex);
                  if (i < previousFrom) prependIndexes.push(slideIndex);
                }
              }
            }
            appendIndexes.forEach(index => {
              swiper.slidesEl.append(renderSlide(slides[index], index));
            });
            if (isLoop) {
              for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {
                const index = prependIndexes[i];
                swiper.slidesEl.prepend(renderSlide(slides[index], index));
              }
            } else {
              prependIndexes.sort((a, b) => b - a);
              prependIndexes.forEach(index => {
                swiper.slidesEl.prepend(renderSlide(slides[index], index));
              });
            }
            elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {
              slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
            });
            onRendered();
          }
          function appendSlide(slides) {
            if (typeof slides === 'object' && 'length' in slides) {
              for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) swiper.virtual.slides.push(slides[i]);
              }
            } else {
              swiper.virtual.slides.push(slides);
            }
            update(true);
          }
          function prependSlide(slides) {
            const activeIndex = swiper.activeIndex;
            let newActiveIndex = activeIndex + 1;
            let numberOfNewSlides = 1;
            if (Array.isArray(slides)) {
              for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
              }
              newActiveIndex = activeIndex + slides.length;
              numberOfNewSlides = slides.length;
            } else {
              swiper.virtual.slides.unshift(slides);
            }
            if (swiper.params.virtual.cache) {
              const cache = swiper.virtual.cache;
              const newCache = {};
              Object.keys(cache).forEach(cachedIndex => {
                const cachedEl = cache[cachedIndex];
                const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');
                if (cachedElIndex) {
                  cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
                }
                newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;
              });
              swiper.virtual.cache = newCache;
            }
            update(true);
            swiper.slideTo(newActiveIndex, 0);
          }
          function removeSlide(slidesIndexes) {
            if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
            let activeIndex = swiper.activeIndex;
            if (Array.isArray(slidesIndexes)) {
              for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
                if (swiper.params.virtual.cache) {
                  delete swiper.virtual.cache[slidesIndexes[i]];
                  // shift cache indexes
                  Object.keys(swiper.virtual.cache).forEach(key => {
                    if (key > slidesIndexes) {
                      swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
                      swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);
                      delete swiper.virtual.cache[key];
                    }
                  });
                }
                swiper.virtual.slides.splice(slidesIndexes[i], 1);
                if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
                activeIndex = Math.max(activeIndex, 0);
              }
            } else {
              if (swiper.params.virtual.cache) {
                delete swiper.virtual.cache[slidesIndexes];
                // shift cache indexes
                Object.keys(swiper.virtual.cache).forEach(key => {
                  if (key > slidesIndexes) {
                    swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
                    swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);
                    delete swiper.virtual.cache[key];
                  }
                });
              }
              swiper.virtual.slides.splice(slidesIndexes, 1);
              if (slidesIndexes < activeIndex) activeIndex -= 1;
              activeIndex = Math.max(activeIndex, 0);
            }
            update(true);
            swiper.slideTo(activeIndex, 0);
          }
          function removeAllSlides() {
            swiper.virtual.slides = [];
            if (swiper.params.virtual.cache) {
              swiper.virtual.cache = {};
            }
            update(true);
            swiper.slideTo(0, 0);
          }
          on('beforeInit', () => {
            if (!swiper.params.virtual.enabled) return;
            let domSlidesAssigned;
            if (typeof swiper.passedParams.virtual.slides === 'undefined') {
              const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));
              if (slides && slides.length) {
                swiper.virtual.slides = [...slides];
                domSlidesAssigned = true;
                slides.forEach((slideEl, slideIndex) => {
                  slideEl.setAttribute('data-swiper-slide-index', slideIndex);
                  swiper.virtual.cache[slideIndex] = slideEl;
                  slideEl.remove();
                });
              }
            }
            if (!domSlidesAssigned) {
              swiper.virtual.slides = swiper.params.virtual.slides;
            }
            swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
            update(false, true);
          });
          on('setTranslate', () => {
            if (!swiper.params.virtual.enabled) return;
            if (swiper.params.cssMode && !swiper._immediateVirtual) {
              clearTimeout(cssModeTimeout);
              cssModeTimeout = setTimeout(() => {
                update();
              }, 100);
            } else {
              update();
            }
          });
          on('init update resize', () => {
            if (!swiper.params.virtual.enabled) return;
            if (swiper.params.cssMode) {
              setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
            }
          });
          Object.assign(swiper.virtual, {
            appendSlide,
            prependSlide,
            removeSlide,
            removeAllSlides,
            update
          });
        }

        /* eslint-disable consistent-return */
        function Keyboard({
          swiper,
          extendParams,
          on,
          emit
        }) {
          const document = getDocument();
          const window = getWindow();
          swiper.keyboard = {
            enabled: false
          };
          extendParams({
            keyboard: {
              enabled: false,
              onlyInViewport: true,
              pageUpDown: true
            }
          });
          function handle(event) {
            if (!swiper.enabled) return;
            const {
              rtlTranslate: rtl
            } = swiper;
            let e = event;
            if (e.originalEvent) e = e.originalEvent; // jquery fix
            const kc = e.keyCode || e.charCode;
            const pageUpDown = swiper.params.keyboard.pageUpDown;
            const isPageUp = pageUpDown && kc === 33;
            const isPageDown = pageUpDown && kc === 34;
            const isArrowLeft = kc === 37;
            const isArrowRight = kc === 39;
            const isArrowUp = kc === 38;
            const isArrowDown = kc === 40;
            // Directions locks
            if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
              return false;
            }
            if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
              return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
              return undefined;
            }
            if (document.activeElement && (document.activeElement.isContentEditable || document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea'))) {
              return undefined;
            }
            if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
              let inView = false;
              // Check that swiper should be inside of visible area of window
              if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {
                return undefined;
              }
              const el = swiper.el;
              const swiperWidth = el.clientWidth;
              const swiperHeight = el.clientHeight;
              const windowWidth = window.innerWidth;
              const windowHeight = window.innerHeight;
              const swiperOffset = elementOffset(el);
              if (rtl) swiperOffset.left -= el.scrollLeft;
              const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
              for (let i = 0; i < swiperCoord.length; i += 1) {
                const point = swiperCoord[i];
                if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                  if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line
                  inView = true;
                }
              }
              if (!inView) return undefined;
            }
            if (swiper.isHorizontal()) {
              if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
                if (e.preventDefault) e.preventDefault();else e.returnValue = false;
              }
              if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
              if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
            } else {
              if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
                if (e.preventDefault) e.preventDefault();else e.returnValue = false;
              }
              if (isPageDown || isArrowDown) swiper.slideNext();
              if (isPageUp || isArrowUp) swiper.slidePrev();
            }
            emit('keyPress', kc);
            return undefined;
          }
          function enable() {
            if (swiper.keyboard.enabled) return;
            document.addEventListener('keydown', handle);
            swiper.keyboard.enabled = true;
          }
          function disable() {
            if (!swiper.keyboard.enabled) return;
            document.removeEventListener('keydown', handle);
            swiper.keyboard.enabled = false;
          }
          on('init', () => {
            if (swiper.params.keyboard.enabled) {
              enable();
            }
          });
          on('destroy', () => {
            if (swiper.keyboard.enabled) {
              disable();
            }
          });
          Object.assign(swiper.keyboard, {
            enable,
            disable
          });
        }

        /* eslint-disable consistent-return */
        function Mousewheel({
          swiper,
          extendParams,
          on,
          emit
        }) {
          const window = getWindow();
          extendParams({
            mousewheel: {
              enabled: false,
              releaseOnEdges: false,
              invert: false,
              forceToAxis: false,
              sensitivity: 1,
              eventsTarget: 'container',
              thresholdDelta: null,
              thresholdTime: null,
              noMousewheelClass: 'swiper-no-mousewheel'
            }
          });
          swiper.mousewheel = {
            enabled: false
          };
          let timeout;
          let lastScrollTime = now();
          let lastEventBeforeSnap;
          const recentWheelEvents = [];
          function normalize(e) {
            // Reasonable defaults
            const PIXEL_STEP = 10;
            const LINE_HEIGHT = 40;
            const PAGE_HEIGHT = 800;
            let sX = 0;
            let sY = 0; // spinX, spinY
            let pX = 0;
            let pY = 0; // pixelX, pixelY

            // Legacy
            if ('detail' in e) {
              sY = e.detail;
            }
            if ('wheelDelta' in e) {
              sY = -e.wheelDelta / 120;
            }
            if ('wheelDeltaY' in e) {
              sY = -e.wheelDeltaY / 120;
            }
            if ('wheelDeltaX' in e) {
              sX = -e.wheelDeltaX / 120;
            }

            // side scrolling on FF with DOMMouseScroll
            if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
              sX = sY;
              sY = 0;
            }
            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;
            if ('deltaY' in e) {
              pY = e.deltaY;
            }
            if ('deltaX' in e) {
              pX = e.deltaX;
            }
            if (e.shiftKey && !pX) {
              // if user scrolls with shift he wants horizontal scroll
              pX = pY;
              pY = 0;
            }
            if ((pX || pY) && e.deltaMode) {
              if (e.deltaMode === 1) {
                // delta in LINE units
                pX *= LINE_HEIGHT;
                pY *= LINE_HEIGHT;
              } else {
                // delta in PAGE units
                pX *= PAGE_HEIGHT;
                pY *= PAGE_HEIGHT;
              }
            }

            // Fall-back if spin cannot be determined
            if (pX && !sX) {
              sX = pX < 1 ? -1 : 1;
            }
            if (pY && !sY) {
              sY = pY < 1 ? -1 : 1;
            }
            return {
              spinX: sX,
              spinY: sY,
              pixelX: pX,
              pixelY: pY
            };
          }
          function handleMouseEnter() {
            if (!swiper.enabled) return;
            swiper.mouseEntered = true;
          }
          function handleMouseLeave() {
            if (!swiper.enabled) return;
            swiper.mouseEntered = false;
          }
          function animateSlider(newEvent) {
            if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
              // Prevent if delta of wheel scroll delta is below configured threshold
              return false;
            }
            if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
              // Prevent if time between scrolls is below configured threshold
              return false;
            }

            // If the movement is NOT big enough and
            // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
            //   Don't go any further (avoid insignificant scroll movement).
            if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
              // Return false as a default
              return true;
            }
            // If user is scrolling towards the end:
            //   If the slider hasn't hit the latest slide or
            //   if the slider is a loop and
            //   if the slider isn't moving right now:
            //     Go to next slide and
            //     emit a scroll event.
            // Else (the user is scrolling towards the beginning) and
            // if the slider hasn't hit the first slide or
            // if the slider is a loop and
            // if the slider isn't moving right now:
            //   Go to prev slide and
            //   emit a scroll event.
            if (newEvent.direction < 0) {
              if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                swiper.slideNext();
                emit('scroll', newEvent.raw);
              }
            } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
              swiper.slidePrev();
              emit('scroll', newEvent.raw);
            }
            // If you got here is because an animation has been triggered so store the current time
            lastScrollTime = new window.Date().getTime();
            // Return false as a default
            return false;
          }
          function releaseScroll(newEvent) {
            const params = swiper.params.mousewheel;
            if (newEvent.direction < 0) {
              if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
                // Return true to animate scroll on edges
                return true;
              }
            } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
              // Return true to animate scroll on edges
              return true;
            }
            return false;
          }
          function handle(event) {
            let e = event;
            let disableParentSwiper = true;
            if (!swiper.enabled) return;

            // Ignore event if the target or its parents have the swiper-no-mousewheel class
            if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;
            const params = swiper.params.mousewheel;
            if (swiper.params.cssMode) {
              e.preventDefault();
            }
            let targetEl = swiper.el;
            if (swiper.params.mousewheel.eventsTarget !== 'container') {
              targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
            }
            const targetElContainsTarget = targetEl && targetEl.contains(e.target);
            if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;
            if (e.originalEvent) e = e.originalEvent; // jquery fix
            let delta = 0;
            const rtlFactor = swiper.rtlTranslate ? -1 : 1;
            const data = normalize(e);
            if (params.forceToAxis) {
              if (swiper.isHorizontal()) {
                if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
              } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
            } else {
              delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
            }
            if (delta === 0) return true;
            if (params.invert) delta = -delta;

            // Get the scroll positions
            let positions = swiper.getTranslate() + delta * params.sensitivity;
            if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
            if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();

            // When loop is true:
            //     the disableParentSwiper will be true.
            // When loop is false:
            //     if the scroll positions is not on edge,
            //     then the disableParentSwiper will be true.
            //     if the scroll on edge positions,
            //     then the disableParentSwiper will be false.
            disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
            if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
            if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
              // Register the new event in a variable which stores the relevant data
              const newEvent = {
                time: now(),
                delta: Math.abs(delta),
                direction: Math.sign(delta),
                raw: event
              };

              // Keep the most recent events
              if (recentWheelEvents.length >= 2) {
                recentWheelEvents.shift(); // only store the last N events
              }
              const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
              recentWheelEvents.push(newEvent);

              // If there is at least one previous recorded event:
              //   If direction has changed or
              //   if the scroll is quicker than the previous one:
              //     Animate the slider.
              // Else (this is the first time the wheel is moved):
              //     Animate the slider.
              if (prevEvent) {
                if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
                  animateSlider(newEvent);
                }
              } else {
                animateSlider(newEvent);
              }

              // If it's time to release the scroll:
              //   Return now so you don't hit the preventDefault.
              if (releaseScroll(newEvent)) {
                return true;
              }
            } else {
              // Freemode or scrollContainer:

              // If we recently snapped after a momentum scroll, then ignore wheel events
              // to give time for the deceleration to finish. Stop ignoring after 500 msecs
              // or if it's a new scroll (larger delta or inverse sign as last event before
              // an end-of-momentum snap).
              const newEvent = {
                time: now(),
                delta: Math.abs(delta),
                direction: Math.sign(delta)
              };
              const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
              if (!ignoreWheelEvents) {
                lastEventBeforeSnap = undefined;
                let position = swiper.getTranslate() + delta * params.sensitivity;
                const wasBeginning = swiper.isBeginning;
                const wasEnd = swiper.isEnd;
                if (position >= swiper.minTranslate()) position = swiper.minTranslate();
                if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
                swiper.setTransition(0);
                swiper.setTranslate(position);
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
                if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
                  swiper.updateSlidesClasses();
                }
                if (swiper.params.loop) {
                  swiper.loopFix({
                    direction: newEvent.direction < 0 ? 'next' : 'prev',
                    byMousewheel: true
                  });
                }
                if (swiper.params.freeMode.sticky) {
                  // When wheel scrolling starts with sticky (aka snap) enabled, then detect
                  // the end of a momentum scroll by storing recent (N=15?) wheel events.
                  // 1. do all N events have decreasing or same (absolute value) delta?
                  // 2. did all N events arrive in the last M (M=500?) msecs?
                  // 3. does the earliest event have an (absolute value) delta that's
                  //    at least P (P=1?) larger than the most recent event's delta?
                  // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
                  // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
                  // Snap immediately and ignore remaining wheel events in this scroll.
                  // See comment above for "remaining wheel events in this scroll" determination.
                  // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
                  clearTimeout(timeout);
                  timeout = undefined;
                  if (recentWheelEvents.length >= 15) {
                    recentWheelEvents.shift(); // only store the last N events
                  }
                  const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
                  const firstEvent = recentWheelEvents[0];
                  recentWheelEvents.push(newEvent);
                  if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
                    // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
                    recentWheelEvents.splice(0);
                  } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                    // We're at the end of the deceleration of a momentum scroll, so there's no need
                    // to wait for more events. Snap ASAP on the next tick.
                    // Also, because there's some remaining momentum we'll bias the snap in the
                    // direction of the ongoing scroll because it's better UX for the scroll to snap
                    // in the same direction as the scroll instead of reversing to snap.  Therefore,
                    // if it's already scrolled more than 20% in the current direction, keep going.
                    const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                    lastEventBeforeSnap = newEvent;
                    recentWheelEvents.splice(0);
                    timeout = nextTick(() => {
                      if (swiper.destroyed || !swiper.params) return;
                      swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                    }, 0); // no delay; move on next tick
                  }
                  if (!timeout) {
                    // if we get here, then we haven't detected the end of a momentum scroll, so
                    // we'll consider a scroll "complete" when there haven't been any wheel events
                    // for 500ms.
                    timeout = nextTick(() => {
                      if (swiper.destroyed || !swiper.params) return;
                      const snapToThreshold = 0.5;
                      lastEventBeforeSnap = newEvent;
                      recentWheelEvents.splice(0);
                      swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                    }, 500);
                  }
                }

                // Emit event
                if (!ignoreWheelEvents) emit('scroll', e);

                // Stop autoplay
                if (swiper.params.autoplay && swiper.params.autoplay.disableOnInteraction) swiper.autoplay.stop();
                // Return page scroll on edge positions
                if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {
                  return true;
                }
              }
            }
            if (e.preventDefault) e.preventDefault();else e.returnValue = false;
            return false;
          }
          function events(method) {
            let targetEl = swiper.el;
            if (swiper.params.mousewheel.eventsTarget !== 'container') {
              targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
            }
            targetEl[method]('mouseenter', handleMouseEnter);
            targetEl[method]('mouseleave', handleMouseLeave);
            targetEl[method]('wheel', handle);
          }
          function enable() {
            if (swiper.params.cssMode) {
              swiper.wrapperEl.removeEventListener('wheel', handle);
              return true;
            }
            if (swiper.mousewheel.enabled) return false;
            events('addEventListener');
            swiper.mousewheel.enabled = true;
            return true;
          }
          function disable() {
            if (swiper.params.cssMode) {
              swiper.wrapperEl.addEventListener(event, handle);
              return true;
            }
            if (!swiper.mousewheel.enabled) return false;
            events('removeEventListener');
            swiper.mousewheel.enabled = false;
            return true;
          }
          on('init', () => {
            if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
              disable();
            }
            if (swiper.params.mousewheel.enabled) enable();
          });
          on('destroy', () => {
            if (swiper.params.cssMode) {
              enable();
            }
            if (swiper.mousewheel.enabled) disable();
          });
          Object.assign(swiper.mousewheel, {
            enable,
            disable
          });
        }
        function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
          if (swiper.params.createElements) {
            Object.keys(checkProps).forEach(key => {
              if (!params[key] && params.auto === true) {
                let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];
                if (!element) {
                  element = createElement('div', checkProps[key]);
                  element.className = checkProps[key];
                  swiper.el.append(element);
                }
                params[key] = element;
                originalParams[key] = element;
              }
            });
          }
          return params;
        }
        const arrowSvg$1 = `<svg class="swiper-navigation-icon" width="11" height="20" viewBox="0 0 11 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.38296 20.0762C0.111788 19.805 0.111788 19.3654 0.38296 19.0942L9.19758 10.2796L0.38296 1.46497C0.111788 1.19379 0.111788 0.754138 0.38296 0.482966C0.654131 0.211794 1.09379 0.211794 1.36496 0.482966L10.4341 9.55214C10.8359 9.9539 10.8359 10.6053 10.4341 11.007L1.36496 20.0762C1.09379 20.3474 0.654131 20.3474 0.38296 20.0762Z" fill="currentColor"/></svg>`;
        function Navigation({
          swiper,
          extendParams,
          on,
          emit
        }) {
          extendParams({
            navigation: {
              nextEl: null,
              prevEl: null,
              addIcons: true,
              hideOnClick: false,
              disabledClass: 'swiper-button-disabled',
              hiddenClass: 'swiper-button-hidden',
              lockClass: 'swiper-button-lock',
              navigationDisabledClass: 'swiper-navigation-disabled'
            }
          });
          swiper.navigation = {
            nextEl: null,
            prevEl: null
          };
          function getEl(el) {
            let res;
            if (el && typeof el === 'string' && swiper.isElement) {
              res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);
              if (res) return res;
            }
            if (el) {
              if (typeof el === 'string') res = [...document.querySelectorAll(el)];
              if (swiper.params.uniqueNavElements && typeof el === 'string' && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
                res = swiper.el.querySelector(el);
              } else if (res && res.length === 1) {
                res = res[0];
              }
            }
            if (el && !res) return el;
            // if (Array.isArray(res) && res.length === 1) res = res[0];
            return res;
          }
          function toggleEl(el, disabled) {
            const params = swiper.params.navigation;
            el = makeElementsArray(el);
            el.forEach(subEl => {
              if (subEl) {
                subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));
                if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;
                if (swiper.params.watchOverflow && swiper.enabled) {
                  subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
                }
              }
            });
          }
          function update() {
            // Update Navigation Buttons
            const {
              nextEl,
              prevEl
            } = swiper.navigation;
            if (swiper.params.loop) {
              toggleEl(prevEl, false);
              toggleEl(nextEl, false);
              return;
            }
            toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
            toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
          }
          function onPrevClick(e) {
            e.preventDefault();
            if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
            swiper.slidePrev();
            emit('navigationPrev');
          }
          function onNextClick(e) {
            e.preventDefault();
            if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
            swiper.slideNext();
            emit('navigationNext');
          }
          function init() {
            const params = swiper.params.navigation;
            swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
              nextEl: 'swiper-button-next',
              prevEl: 'swiper-button-prev'
            });
            if (!(params.nextEl || params.prevEl)) return;
            let nextEl = getEl(params.nextEl);
            let prevEl = getEl(params.prevEl);
            Object.assign(swiper.navigation, {
              nextEl,
              prevEl
            });
            nextEl = makeElementsArray(nextEl);
            prevEl = makeElementsArray(prevEl);
            const initButton = (el, dir) => {
              if (el) {
                if (params.addIcons && el.matches('.swiper-button-next,.swiper-button-prev') && !el.querySelector('svg')) {
                  const tempEl = document.createElement('div');
                  setInnerHTML(tempEl, arrowSvg$1);
                  el.appendChild(tempEl.querySelector('svg'));
                  tempEl.remove();
                }
                el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
              }
              if (!swiper.enabled && el) {
                el.classList.add(...params.lockClass.split(' '));
              }
            };
            nextEl.forEach(el => initButton(el, 'next'));
            prevEl.forEach(el => initButton(el, 'prev'));
          }
          function destroy() {
            let {
              nextEl,
              prevEl
            } = swiper.navigation;
            nextEl = makeElementsArray(nextEl);
            prevEl = makeElementsArray(prevEl);
            const destroyButton = (el, dir) => {
              el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
              el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));
            };
            nextEl.forEach(el => destroyButton(el, 'next'));
            prevEl.forEach(el => destroyButton(el, 'prev'));
          }
          on('init', () => {
            if (swiper.params.navigation.enabled === false) {
              // eslint-disable-next-line
              disable();
            } else {
              init();
              update();
            }
          });
          on('toEdge fromEdge lock unlock', () => {
            update();
          });
          on('destroy', () => {
            destroy();
          });
          on('enable disable', () => {
            let {
              nextEl,
              prevEl
            } = swiper.navigation;
            nextEl = makeElementsArray(nextEl);
            prevEl = makeElementsArray(prevEl);
            if (swiper.enabled) {
              update();
              return;
            }
            [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.add(swiper.params.navigation.lockClass));
          });
          on('click', (_s, e) => {
            let {
              nextEl,
              prevEl
            } = swiper.navigation;
            nextEl = makeElementsArray(nextEl);
            prevEl = makeElementsArray(prevEl);
            const targetEl = e.target;
            let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
            if (swiper.isElement && !targetIsButton) {
              const path = e.path || e.composedPath && e.composedPath();
              if (path) {
                targetIsButton = path.find(pathEl => nextEl.includes(pathEl) || prevEl.includes(pathEl));
              }
            }
            if (swiper.params.navigation.hideOnClick && !targetIsButton) {
              if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
              let isHidden;
              if (nextEl.length) {
                isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
              } else if (prevEl.length) {
                isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
              }
              if (isHidden === true) {
                emit('navigationShow');
              } else {
                emit('navigationHide');
              }
              [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));
            }
          });
          const enable = () => {
            swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));
            init();
            update();
          };
          const disable = () => {
            swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));
            destroy();
          };
          Object.assign(swiper.navigation, {
            enable,
            disable,
            update,
            init,
            destroy
          });
        }
        function classesToSelector(classes = '') {
          return `.${classes.trim().replace(/([\.:!+\/()[\]])/g, '\\$1') // eslint-disable-line
          .replace(/ /g, '.')}`;
        }
        function Pagination({
          swiper,
          extendParams,
          on,
          emit
        }) {
          const pfx = 'swiper-pagination';
          extendParams({
            pagination: {
              el: null,
              bulletElement: 'span',
              clickable: false,
              hideOnClick: false,
              renderBullet: null,
              renderProgressbar: null,
              renderFraction: null,
              renderCustom: null,
              progressbarOpposite: false,
              type: 'bullets',
              // 'bullets' or 'progressbar' or 'fraction' or 'custom'
              dynamicBullets: false,
              dynamicMainBullets: 1,
              formatFractionCurrent: number => number,
              formatFractionTotal: number => number,
              bulletClass: `${pfx}-bullet`,
              bulletActiveClass: `${pfx}-bullet-active`,
              modifierClass: `${pfx}-`,
              currentClass: `${pfx}-current`,
              totalClass: `${pfx}-total`,
              hiddenClass: `${pfx}-hidden`,
              progressbarFillClass: `${pfx}-progressbar-fill`,
              progressbarOppositeClass: `${pfx}-progressbar-opposite`,
              clickableClass: `${pfx}-clickable`,
              lockClass: `${pfx}-lock`,
              horizontalClass: `${pfx}-horizontal`,
              verticalClass: `${pfx}-vertical`,
              paginationDisabledClass: `${pfx}-disabled`
            }
          });
          swiper.pagination = {
            el: null,
            bullets: []
          };
          let bulletSize;
          let dynamicBulletIndex = 0;
          function isPaginationDisabled() {
            return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
          }
          function setSideBullets(bulletEl, position) {
            const {
              bulletActiveClass
            } = swiper.params.pagination;
            if (!bulletEl) return;
            bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
            if (bulletEl) {
              bulletEl.classList.add(`${bulletActiveClass}-${position}`);
              bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
              if (bulletEl) {
                bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
              }
            }
          }
          function getMoveDirection(prevIndex, nextIndex, length) {
            prevIndex = prevIndex % length;
            nextIndex = nextIndex % length;
            if (nextIndex === prevIndex + 1) {
              return 'next';
            } else if (nextIndex === prevIndex - 1) {
              return 'previous';
            }
            return;
          }
          function onBulletClick(e) {
            const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
            if (!bulletEl) {
              return;
            }
            e.preventDefault();
            const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
            if (swiper.params.loop) {
              if (swiper.realIndex === index) return;
              const moveDirection = getMoveDirection(swiper.realIndex, index, swiper.slides.length);
              if (moveDirection === 'next') {
                swiper.slideNext();
              } else if (moveDirection === 'previous') {
                swiper.slidePrev();
              } else {
                swiper.slideToLoop(index);
              }
            } else {
              swiper.slideTo(index);
            }
          }
          function update() {
            // Render || Update Pagination bullets/items
            const rtl = swiper.rtl;
            const params = swiper.params.pagination;
            if (isPaginationDisabled()) return;
            let el = swiper.pagination.el;
            el = makeElementsArray(el);
            // Current/Total
            let current;
            let previousIndex;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            if (swiper.params.loop) {
              previousIndex = swiper.previousRealIndex || 0;
              current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
            } else if (typeof swiper.snapIndex !== 'undefined') {
              current = swiper.snapIndex;
              previousIndex = swiper.previousSnapIndex;
            } else {
              previousIndex = swiper.previousIndex || 0;
              current = swiper.activeIndex || 0;
            }
            // Types
            if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
              const bullets = swiper.pagination.bullets;
              let firstIndex;
              let lastIndex;
              let midIndex;
              if (params.dynamicBullets) {
                bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height');
                el.forEach(subEl => {
                  subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
                });
                if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {
                  dynamicBulletIndex += current - (previousIndex || 0);
                  if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                    dynamicBulletIndex = params.dynamicMainBullets - 1;
                  } else if (dynamicBulletIndex < 0) {
                    dynamicBulletIndex = 0;
                  }
                }
                firstIndex = Math.max(current - dynamicBulletIndex, 0);
                lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                midIndex = (lastIndex + firstIndex) / 2;
              }
              bullets.forEach(bulletEl => {
                const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();
                bulletEl.classList.remove(...classesToRemove);
              });
              if (el.length > 1) {
                bullets.forEach(bullet => {
                  const bulletIndex = elementIndex(bullet);
                  if (bulletIndex === current) {
                    bullet.classList.add(...params.bulletActiveClass.split(' '));
                  } else if (swiper.isElement) {
                    bullet.setAttribute('part', 'bullet');
                  }
                  if (params.dynamicBullets) {
                    if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                      bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));
                    }
                    if (bulletIndex === firstIndex) {
                      setSideBullets(bullet, 'prev');
                    }
                    if (bulletIndex === lastIndex) {
                      setSideBullets(bullet, 'next');
                    }
                  }
                });
              } else {
                const bullet = bullets[current];
                if (bullet) {
                  bullet.classList.add(...params.bulletActiveClass.split(' '));
                }
                if (swiper.isElement) {
                  bullets.forEach((bulletEl, bulletIndex) => {
                    bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');
                  });
                }
                if (params.dynamicBullets) {
                  const firstDisplayedBullet = bullets[firstIndex];
                  const lastDisplayedBullet = bullets[lastIndex];
                  for (let i = firstIndex; i <= lastIndex; i += 1) {
                    if (bullets[i]) {
                      bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));
                    }
                  }
                  setSideBullets(firstDisplayedBullet, 'prev');
                  setSideBullets(lastDisplayedBullet, 'next');
                }
              }
              if (params.dynamicBullets) {
                const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                const offsetProp = rtl ? 'right' : 'left';
                bullets.forEach(bullet => {
                  bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;
                });
              }
            }
            el.forEach((subEl, subElIndex) => {
              if (params.type === 'fraction') {
                subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {
                  fractionEl.textContent = params.formatFractionCurrent(current + 1);
                });
                subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {
                  totalEl.textContent = params.formatFractionTotal(total);
                });
              }
              if (params.type === 'progressbar') {
                let progressbarDirection;
                if (params.progressbarOpposite) {
                  progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
                } else {
                  progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
                }
                const scale = (current + 1) / total;
                let scaleX = 1;
                let scaleY = 1;
                if (progressbarDirection === 'horizontal') {
                  scaleX = scale;
                } else {
                  scaleY = scale;
                }
                subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {
                  progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
                  progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
                });
              }
              if (params.type === 'custom' && params.renderCustom) {
                setInnerHTML(subEl, params.renderCustom(swiper, current + 1, total));
                if (subElIndex === 0) emit('paginationRender', subEl);
              } else {
                if (subElIndex === 0) emit('paginationRender', subEl);
                emit('paginationUpdate', subEl);
              }
              if (swiper.params.watchOverflow && swiper.enabled) {
                subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
              }
            });
          }
          function render() {
            // Render Container
            const params = swiper.params.pagination;
            if (isPaginationDisabled()) return;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
            let el = swiper.pagination.el;
            el = makeElementsArray(el);
            let paginationHTML = '';
            if (params.type === 'bullets') {
              let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
              if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
                numberOfBullets = slidesLength;
              }
              for (let i = 0; i < numberOfBullets; i += 1) {
                if (params.renderBullet) {
                  paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
                } else {
                  // prettier-ignore
                  paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ''} class="${params.bulletClass}"></${params.bulletElement}>`;
                }
              }
            }
            if (params.type === 'fraction') {
              if (params.renderFraction) {
                paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
              } else {
                paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
              }
            }
            if (params.type === 'progressbar') {
              if (params.renderProgressbar) {
                paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
              } else {
                paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
              }
            }
            swiper.pagination.bullets = [];
            el.forEach(subEl => {
              if (params.type !== 'custom') {
                setInnerHTML(subEl, paginationHTML || '');
              }
              if (params.type === 'bullets') {
                swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
              }
            });
            if (params.type !== 'custom') {
              emit('paginationRender', el[0]);
            }
          }
          function init() {
            swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
              el: 'swiper-pagination'
            });
            const params = swiper.params.pagination;
            if (!params.el) return;
            let el;
            if (typeof params.el === 'string' && swiper.isElement) {
              el = swiper.el.querySelector(params.el);
            }
            if (!el && typeof params.el === 'string') {
              el = [...document.querySelectorAll(params.el)];
            }
            if (!el) {
              el = params.el;
            }
            if (!el || el.length === 0) return;
            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {
              el = [...swiper.el.querySelectorAll(params.el)];
              // check if it belongs to another nested Swiper
              if (el.length > 1) {
                el = el.find(subEl => {
                  if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;
                  return true;
                });
              }
            }
            if (Array.isArray(el) && el.length === 1) el = el[0];
            Object.assign(swiper.pagination, {
              el
            });
            el = makeElementsArray(el);
            el.forEach(subEl => {
              if (params.type === 'bullets' && params.clickable) {
                subEl.classList.add(...(params.clickableClass || '').split(' '));
              }
              subEl.classList.add(params.modifierClass + params.type);
              subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
              if (params.type === 'bullets' && params.dynamicBullets) {
                subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
                dynamicBulletIndex = 0;
                if (params.dynamicMainBullets < 1) {
                  params.dynamicMainBullets = 1;
                }
              }
              if (params.type === 'progressbar' && params.progressbarOpposite) {
                subEl.classList.add(params.progressbarOppositeClass);
              }
              if (params.clickable) {
                subEl.addEventListener('click', onBulletClick);
              }
              if (!swiper.enabled) {
                subEl.classList.add(params.lockClass);
              }
            });
          }
          function destroy() {
            const params = swiper.params.pagination;
            if (isPaginationDisabled()) return;
            let el = swiper.pagination.el;
            if (el) {
              el = makeElementsArray(el);
              el.forEach(subEl => {
                subEl.classList.remove(params.hiddenClass);
                subEl.classList.remove(params.modifierClass + params.type);
                subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                if (params.clickable) {
                  subEl.classList.remove(...(params.clickableClass || '').split(' '));
                  subEl.removeEventListener('click', onBulletClick);
                }
              });
            }
            if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));
          }
          on('changeDirection', () => {
            if (!swiper.pagination || !swiper.pagination.el) return;
            const params = swiper.params.pagination;
            let {
              el
            } = swiper.pagination;
            el = makeElementsArray(el);
            el.forEach(subEl => {
              subEl.classList.remove(params.horizontalClass, params.verticalClass);
              subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
            });
          });
          on('init', () => {
            if (swiper.params.pagination.enabled === false) {
              // eslint-disable-next-line
              disable();
            } else {
              init();
              render();
              update();
            }
          });
          on('activeIndexChange', () => {
            if (typeof swiper.snapIndex === 'undefined') {
              update();
            }
          });
          on('snapIndexChange', () => {
            update();
          });
          on('snapGridLengthChange', () => {
            render();
            update();
          });
          on('destroy', () => {
            destroy();
          });
          on('enable disable', () => {
            let {
              el
            } = swiper.pagination;
            if (el) {
              el = makeElementsArray(el);
              el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));
            }
          });
          on('lock unlock', () => {
            update();
          });
          on('click', (_s, e) => {
            const targetEl = e.target;
            const el = makeElementsArray(swiper.pagination.el);
            if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
              if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
              const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
              if (isHidden === true) {
                emit('paginationShow');
              } else {
                emit('paginationHide');
              }
              el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
            }
          });
          const enable = () => {
            swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
            let {
              el
            } = swiper.pagination;
            if (el) {
              el = makeElementsArray(el);
              el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
            }
            init();
            render();
            update();
          };
          const disable = () => {
            swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
            let {
              el
            } = swiper.pagination;
            if (el) {
              el = makeElementsArray(el);
              el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
            }
            destroy();
          };
          Object.assign(swiper.pagination, {
            enable,
            disable,
            render,
            update,
            init,
            destroy
          });
        }
        function Scrollbar({
          swiper,
          extendParams,
          on,
          emit
        }) {
          const document = getDocument();
          let isTouched = false;
          let timeout = null;
          let dragTimeout = null;
          let dragStartPos;
          let dragSize;
          let trackSize;
          let divider;
          extendParams({
            scrollbar: {
              el: null,
              dragSize: 'auto',
              hide: false,
              draggable: false,
              snapOnRelease: true,
              lockClass: 'swiper-scrollbar-lock',
              dragClass: 'swiper-scrollbar-drag',
              scrollbarDisabledClass: 'swiper-scrollbar-disabled',
              horizontalClass: `swiper-scrollbar-horizontal`,
              verticalClass: `swiper-scrollbar-vertical`
            }
          });
          swiper.scrollbar = {
            el: null,
            dragEl: null
          };
          function setTranslate() {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            const {
              scrollbar,
              rtlTranslate: rtl
            } = swiper;
            const {
              dragEl,
              el
            } = scrollbar;
            const params = swiper.params.scrollbar;
            const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
            let newSize = dragSize;
            let newPos = (trackSize - dragSize) * progress;
            if (rtl) {
              newPos = -newPos;
              if (newPos > 0) {
                newSize = dragSize - newPos;
                newPos = 0;
              } else if (-newPos + dragSize > trackSize) {
                newSize = trackSize + newPos;
              }
            } else if (newPos < 0) {
              newSize = dragSize + newPos;
              newPos = 0;
            } else if (newPos + dragSize > trackSize) {
              newSize = trackSize - newPos;
            }
            if (swiper.isHorizontal()) {
              dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
              dragEl.style.width = `${newSize}px`;
            } else {
              dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
              dragEl.style.height = `${newSize}px`;
            }
            if (params.hide) {
              clearTimeout(timeout);
              el.style.opacity = 1;
              timeout = setTimeout(() => {
                el.style.opacity = 0;
                el.style.transitionDuration = '400ms';
              }, 1000);
            }
          }
          function setTransition(duration) {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
          }
          function updateSize() {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            const {
              scrollbar
            } = swiper;
            const {
              dragEl,
              el
            } = scrollbar;
            dragEl.style.width = '';
            dragEl.style.height = '';
            trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
            divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
            if (swiper.params.scrollbar.dragSize === 'auto') {
              dragSize = trackSize * divider;
            } else {
              dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
            }
            if (swiper.isHorizontal()) {
              dragEl.style.width = `${dragSize}px`;
            } else {
              dragEl.style.height = `${dragSize}px`;
            }
            if (divider >= 1) {
              el.style.display = 'none';
            } else {
              el.style.display = '';
            }
            if (swiper.params.scrollbar.hide) {
              el.style.opacity = 0;
            }
            if (swiper.params.watchOverflow && swiper.enabled) {
              scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);
            }
          }
          function getPointerPosition(e) {
            return swiper.isHorizontal() ? e.clientX : e.clientY;
          }
          function setDragPosition(e) {
            const {
              scrollbar,
              rtlTranslate: rtl
            } = swiper;
            const {
              el
            } = scrollbar;
            let positionRatio;
            positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
            positionRatio = Math.max(Math.min(positionRatio, 1), 0);
            if (rtl) {
              positionRatio = 1 - positionRatio;
            }
            const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
            swiper.updateProgress(position);
            swiper.setTranslate(position);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
          }
          function onDragStart(e) {
            const params = swiper.params.scrollbar;
            const {
              scrollbar,
              wrapperEl
            } = swiper;
            const {
              el,
              dragEl
            } = scrollbar;
            isTouched = true;
            dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
            e.preventDefault();
            e.stopPropagation();
            wrapperEl.style.transitionDuration = '100ms';
            dragEl.style.transitionDuration = '100ms';
            setDragPosition(e);
            clearTimeout(dragTimeout);
            el.style.transitionDuration = '0ms';
            if (params.hide) {
              el.style.opacity = 1;
            }
            if (swiper.params.cssMode) {
              swiper.wrapperEl.style['scroll-snap-type'] = 'none';
            }
            emit('scrollbarDragStart', e);
          }
          function onDragMove(e) {
            const {
              scrollbar,
              wrapperEl
            } = swiper;
            const {
              el,
              dragEl
            } = scrollbar;
            if (!isTouched) return;
            if (e.preventDefault && e.cancelable) e.preventDefault();else e.returnValue = false;
            setDragPosition(e);
            wrapperEl.style.transitionDuration = '0ms';
            el.style.transitionDuration = '0ms';
            dragEl.style.transitionDuration = '0ms';
            emit('scrollbarDragMove', e);
          }
          function onDragEnd(e) {
            const params = swiper.params.scrollbar;
            const {
              scrollbar,
              wrapperEl
            } = swiper;
            const {
              el
            } = scrollbar;
            if (!isTouched) return;
            isTouched = false;
            if (swiper.params.cssMode) {
              swiper.wrapperEl.style['scroll-snap-type'] = '';
              wrapperEl.style.transitionDuration = '';
            }
            if (params.hide) {
              clearTimeout(dragTimeout);
              dragTimeout = nextTick(() => {
                el.style.opacity = 0;
                el.style.transitionDuration = '400ms';
              }, 1000);
            }
            emit('scrollbarDragEnd', e);
            if (params.snapOnRelease) {
              swiper.slideToClosest();
            }
          }
          function events(method) {
            const {
              scrollbar,
              params
            } = swiper;
            const el = scrollbar.el;
            if (!el) return;
            const target = el;
            const activeListener = params.passiveListeners ? {
              passive: false,
              capture: false
            } : false;
            const passiveListener = params.passiveListeners ? {
              passive: true,
              capture: false
            } : false;
            if (!target) return;
            const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
            target[eventMethod]('pointerdown', onDragStart, activeListener);
            document[eventMethod]('pointermove', onDragMove, activeListener);
            document[eventMethod]('pointerup', onDragEnd, passiveListener);
          }
          function enableDraggable() {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            events('on');
          }
          function disableDraggable() {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            events('off');
          }
          function init() {
            const {
              scrollbar,
              el: swiperEl
            } = swiper;
            swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
              el: 'swiper-scrollbar'
            });
            const params = swiper.params.scrollbar;
            if (!params.el) return;
            let el;
            if (typeof params.el === 'string' && swiper.isElement) {
              el = swiper.el.querySelector(params.el);
            }
            if (!el && typeof params.el === 'string') {
              el = document.querySelectorAll(params.el);
              if (!el.length) return;
            } else if (!el) {
              el = params.el;
            }
            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
              el = swiperEl.querySelector(params.el);
            }
            if (el.length > 0) el = el[0];
            el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
            let dragEl;
            if (el) {
              dragEl = el.querySelector(classesToSelector(swiper.params.scrollbar.dragClass));
              if (!dragEl) {
                dragEl = createElement('div', swiper.params.scrollbar.dragClass);
                el.append(dragEl);
              }
            }
            Object.assign(scrollbar, {
              el,
              dragEl
            });
            if (params.draggable) {
              enableDraggable();
            }
            if (el) {
              el.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));
            }
          }
          function destroy() {
            const params = swiper.params.scrollbar;
            const el = swiper.scrollbar.el;
            if (el) {
              el.classList.remove(...classesToTokens(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));
            }
            disableDraggable();
          }
          on('changeDirection', () => {
            if (!swiper.scrollbar || !swiper.scrollbar.el) return;
            const params = swiper.params.scrollbar;
            let {
              el
            } = swiper.scrollbar;
            el = makeElementsArray(el);
            el.forEach(subEl => {
              subEl.classList.remove(params.horizontalClass, params.verticalClass);
              subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
            });
          });
          on('init', () => {
            if (swiper.params.scrollbar.enabled === false) {
              // eslint-disable-next-line
              disable();
            } else {
              init();
              updateSize();
              setTranslate();
            }
          });
          on('update resize observerUpdate lock unlock changeDirection', () => {
            updateSize();
          });
          on('setTranslate', () => {
            setTranslate();
          });
          on('setTransition', (_s, duration) => {
            setTransition(duration);
          });
          on('enable disable', () => {
            const {
              el
            } = swiper.scrollbar;
            if (el) {
              el.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));
            }
          });
          on('destroy', () => {
            destroy();
          });
          const enable = () => {
            swiper.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
            if (swiper.scrollbar.el) {
              swiper.scrollbar.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
            }
            init();
            updateSize();
            setTranslate();
          };
          const disable = () => {
            swiper.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
            if (swiper.scrollbar.el) {
              swiper.scrollbar.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
            }
            destroy();
          };
          Object.assign(swiper.scrollbar, {
            enable,
            disable,
            updateSize,
            setTranslate,
            init,
            destroy
          });
        }
        function Parallax({
          swiper,
          extendParams,
          on
        }) {
          extendParams({
            parallax: {
              enabled: false
            }
          });
          const elementsSelector = '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]';
          const setTransform = (el, progress) => {
            const {
              rtl
            } = swiper;
            const rtlFactor = rtl ? -1 : 1;
            const p = el.getAttribute('data-swiper-parallax') || '0';
            let x = el.getAttribute('data-swiper-parallax-x');
            let y = el.getAttribute('data-swiper-parallax-y');
            const scale = el.getAttribute('data-swiper-parallax-scale');
            const opacity = el.getAttribute('data-swiper-parallax-opacity');
            const rotate = el.getAttribute('data-swiper-parallax-rotate');
            if (x || y) {
              x = x || '0';
              y = y || '0';
            } else if (swiper.isHorizontal()) {
              x = p;
              y = '0';
            } else {
              y = p;
              x = '0';
            }
            if (x.indexOf('%') >= 0) {
              x = `${parseInt(x, 10) * progress * rtlFactor}%`;
            } else {
              x = `${x * progress * rtlFactor}px`;
            }
            if (y.indexOf('%') >= 0) {
              y = `${parseInt(y, 10) * progress}%`;
            } else {
              y = `${y * progress}px`;
            }
            if (typeof opacity !== 'undefined' && opacity !== null) {
              const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
              el.style.opacity = currentOpacity;
            }
            let transform = `translate3d(${x}, ${y}, 0px)`;
            if (typeof scale !== 'undefined' && scale !== null) {
              const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
              transform += ` scale(${currentScale})`;
            }
            if (rotate && typeof rotate !== 'undefined' && rotate !== null) {
              const currentRotate = rotate * progress * -1;
              transform += ` rotate(${currentRotate}deg)`;
            }
            el.style.transform = transform;
          };
          const setTranslate = () => {
            const {
              el,
              slides,
              progress,
              snapGrid,
              isElement
            } = swiper;
            const elements = elementChildren(el, elementsSelector);
            if (swiper.isElement) {
              elements.push(...elementChildren(swiper.hostEl, elementsSelector));
            }
            elements.forEach(subEl => {
              setTransform(subEl, progress);
            });
            slides.forEach((slideEl, slideIndex) => {
              let slideProgress = slideEl.progress;
              if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
                slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
              }
              slideProgress = Math.min(Math.max(slideProgress, -1), 1);
              slideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach(subEl => {
                setTransform(subEl, slideProgress);
              });
            });
          };
          const setTransition = (duration = swiper.params.speed) => {
            const {
              el,
              hostEl
            } = swiper;
            const elements = [...el.querySelectorAll(elementsSelector)];
            if (swiper.isElement) {
              elements.push(...hostEl.querySelectorAll(elementsSelector));
            }
            elements.forEach(parallaxEl => {
              let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;
              if (duration === 0) parallaxDuration = 0;
              parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;
            });
          };
          on('beforeInit', () => {
            if (!swiper.params.parallax.enabled) return;
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
          });
          on('init', () => {
            if (!swiper.params.parallax.enabled) return;
            setTranslate();
          });
          on('setTranslate', () => {
            if (!swiper.params.parallax.enabled) return;
            setTranslate();
          });
          on('setTransition', (_swiper, duration) => {
            if (!swiper.params.parallax.enabled) return;
            setTransition(duration);
          });
        }
        function Zoom({
          swiper,
          extendParams,
          on,
          emit
        }) {
          const window = getWindow();
          extendParams({
            zoom: {
              enabled: false,
              limitToOriginalSize: false,
              maxRatio: 3,
              minRatio: 1,
              panOnMouseMove: false,
              toggle: true,
              containerClass: 'swiper-zoom-container',
              zoomedSlideClass: 'swiper-slide-zoomed'
            }
          });
          swiper.zoom = {
            enabled: false
          };
          let currentScale = 1;
          let isScaling = false;
          let isPanningWithMouse = false;
          let mousePanStart = {
            x: 0,
            y: 0
          };
          const mousePanSensitivity = -3; // Negative to invert pan direction
          let fakeGestureTouched;
          let fakeGestureMoved;
          const evCache = [];
          const gesture = {
            originX: 0,
            originY: 0,
            slideEl: undefined,
            slideWidth: undefined,
            slideHeight: undefined,
            imageEl: undefined,
            imageWrapEl: undefined,
            maxRatio: 3
          };
          const image = {
            isTouched: undefined,
            isMoved: undefined,
            currentX: undefined,
            currentY: undefined,
            minX: undefined,
            minY: undefined,
            maxX: undefined,
            maxY: undefined,
            width: undefined,
            height: undefined,
            startX: undefined,
            startY: undefined,
            touchesStart: {},
            touchesCurrent: {}
          };
          const velocity = {
            x: undefined,
            y: undefined,
            prevPositionX: undefined,
            prevPositionY: undefined,
            prevTime: undefined
          };
          let scale = 1;
          Object.defineProperty(swiper.zoom, 'scale', {
            get() {
              return scale;
            },
            set(value) {
              if (scale !== value) {
                const imageEl = gesture.imageEl;
                const slideEl = gesture.slideEl;
                emit('zoomChange', value, imageEl, slideEl);
              }
              scale = value;
            }
          });
          function getDistanceBetweenTouches() {
            if (evCache.length < 2) return 1;
            const x1 = evCache[0].pageX;
            const y1 = evCache[0].pageY;
            const x2 = evCache[1].pageX;
            const y2 = evCache[1].pageY;
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            return distance;
          }
          function getMaxRatio() {
            const params = swiper.params.zoom;
            const maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;
            if (params.limitToOriginalSize && gesture.imageEl && gesture.imageEl.naturalWidth) {
              const imageMaxRatio = gesture.imageEl.naturalWidth / gesture.imageEl.offsetWidth;
              return Math.min(imageMaxRatio, maxRatio);
            }
            return maxRatio;
          }
          function getScaleOrigin() {
            if (evCache.length < 2) return {
              x: null,
              y: null
            };
            const box = gesture.imageEl.getBoundingClientRect();
            return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale];
          }
          function getSlideSelector() {
            return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
          }
          function eventWithinSlide(e) {
            const slideSelector = getSlideSelector();
            if (e.target.matches(slideSelector)) return true;
            if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;
            return false;
          }
          function eventWithinZoomContainer(e) {
            const selector = `.${swiper.params.zoom.containerClass}`;
            if (e.target.matches(selector)) return true;
            if ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;
            return false;
          }

          // Events
          function onGestureStart(e) {
            if (e.pointerType === 'mouse') {
              evCache.splice(0, evCache.length);
            }
            if (!eventWithinSlide(e)) return;
            const params = swiper.params.zoom;
            fakeGestureTouched = false;
            fakeGestureMoved = false;
            evCache.push(e);
            if (evCache.length < 2) {
              return;
            }
            fakeGestureTouched = true;
            gesture.scaleStart = getDistanceBetweenTouches();
            if (!gesture.slideEl) {
              gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
              if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];
              let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
              if (imageEl) {
                imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
              }
              gesture.imageEl = imageEl;
              if (imageEl) {
                gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
              } else {
                gesture.imageWrapEl = undefined;
              }
              if (!gesture.imageWrapEl) {
                gesture.imageEl = undefined;
                return;
              }
              gesture.maxRatio = getMaxRatio();
            }
            if (gesture.imageEl) {
              const [originX, originY] = getScaleOrigin();
              gesture.originX = originX;
              gesture.originY = originY;
              gesture.imageEl.style.transitionDuration = '0ms';
            }
            isScaling = true;
          }
          function onGestureChange(e) {
            if (!eventWithinSlide(e)) return;
            const params = swiper.params.zoom;
            const zoom = swiper.zoom;
            const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
            if (pointerIndex >= 0) evCache[pointerIndex] = e;
            if (evCache.length < 2) {
              return;
            }
            fakeGestureMoved = true;
            gesture.scaleMove = getDistanceBetweenTouches();
            if (!gesture.imageEl) {
              return;
            }
            zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
            if (zoom.scale > gesture.maxRatio) {
              zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
            }
            if (zoom.scale < params.minRatio) {
              zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
            }
            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
          }
          function onGestureEnd(e) {
            if (!eventWithinSlide(e)) return;
            if (e.pointerType === 'mouse' && e.type === 'pointerout') return;
            const params = swiper.params.zoom;
            const zoom = swiper.zoom;
            const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
            if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);
            if (!fakeGestureTouched || !fakeGestureMoved) {
              return;
            }
            fakeGestureTouched = false;
            fakeGestureMoved = false;
            if (!gesture.imageEl) return;
            zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
            gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;
            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
            currentScale = zoom.scale;
            isScaling = false;
            if (zoom.scale > 1 && gesture.slideEl) {
              gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
            } else if (zoom.scale <= 1 && gesture.slideEl) {
              gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
            }
            if (zoom.scale === 1) {
              gesture.originX = 0;
              gesture.originY = 0;
              gesture.slideEl = undefined;
            }
          }
          let allowTouchMoveTimeout;
          function allowTouchMove() {
            swiper.touchEventsData.preventTouchMoveFromPointerMove = false;
          }
          function preventTouchMove() {
            clearTimeout(allowTouchMoveTimeout);
            swiper.touchEventsData.preventTouchMoveFromPointerMove = true;
            allowTouchMoveTimeout = setTimeout(() => {
              if (swiper.destroyed) return;
              allowTouchMove();
            });
          }
          function onTouchStart(e) {
            const device = swiper.device;
            if (!gesture.imageEl) return;
            if (image.isTouched) return;
            if (device.android && e.cancelable) e.preventDefault();
            image.isTouched = true;
            const event = evCache.length > 0 ? evCache[0] : e;
            image.touchesStart.x = event.pageX;
            image.touchesStart.y = event.pageY;
          }
          function onTouchMove(e) {
            const isMouseEvent = e.pointerType === 'mouse';
            const isMousePan = isMouseEvent && swiper.params.zoom.panOnMouseMove;
            if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) {
              return;
            }
            const zoom = swiper.zoom;
            if (!gesture.imageEl) {
              return;
            }
            if (!image.isTouched || !gesture.slideEl) {
              if (isMousePan) onMouseMove(e);
              return;
            }
            if (isMousePan) {
              onMouseMove(e);
              return;
            }
            if (!image.isMoved) {
              image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
              image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
              image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;
              image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;
              gesture.slideWidth = gesture.slideEl.offsetWidth;
              gesture.slideHeight = gesture.slideEl.offsetHeight;
              gesture.imageWrapEl.style.transitionDuration = '0ms';
            }
            // Define if we need image drag
            const scaledWidth = image.width * zoom.scale;
            const scaledHeight = image.height * zoom.scale;
            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
            image.maxX = -image.minX;
            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
            image.maxY = -image.minY;
            image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;
            image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;
            const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));
            if (touchesDiff > 5) {
              swiper.allowClick = false;
            }
            if (!image.isMoved && !isScaling) {
              if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
                image.isTouched = false;
                allowTouchMove();
                return;
              }
              if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
                image.isTouched = false;
                allowTouchMove();
                return;
              }
            }
            if (e.cancelable) {
              e.preventDefault();
            }
            e.stopPropagation();
            preventTouchMove();
            image.isMoved = true;
            const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);
            const {
              originX,
              originY
            } = gesture;
            image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);
            image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);
            if (image.currentX < image.minX) {
              image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
            }
            if (image.currentX > image.maxX) {
              image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
            }
            if (image.currentY < image.minY) {
              image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
            }
            if (image.currentY > image.maxY) {
              image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
            }

            // Velocity
            if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
            if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
            if (!velocity.prevTime) velocity.prevTime = Date.now();
            velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
            velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
            if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
            if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
            velocity.prevPositionX = image.touchesCurrent.x;
            velocity.prevPositionY = image.touchesCurrent.y;
            velocity.prevTime = Date.now();
            gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
          }
          function onTouchEnd() {
            const zoom = swiper.zoom;
            evCache.length = 0;
            if (!gesture.imageEl) return;
            if (!image.isTouched || !image.isMoved) {
              image.isTouched = false;
              image.isMoved = false;
              return;
            }
            image.isTouched = false;
            image.isMoved = false;
            let momentumDurationX = 300;
            let momentumDurationY = 300;
            const momentumDistanceX = velocity.x * momentumDurationX;
            const newPositionX = image.currentX + momentumDistanceX;
            const momentumDistanceY = velocity.y * momentumDurationY;
            const newPositionY = image.currentY + momentumDistanceY;

            // Fix duration
            if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
            if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
            const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
            image.currentX = newPositionX;
            image.currentY = newPositionY;
            // Define if we need image drag
            const scaledWidth = image.width * zoom.scale;
            const scaledHeight = image.height * zoom.scale;
            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
            image.maxX = -image.minX;
            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
            image.maxY = -image.minY;
            image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
            image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
            gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;
            gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
          }
          function onTransitionEnd() {
            const zoom = swiper.zoom;
            if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {
              if (gesture.imageEl) {
                gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
              }
              if (gesture.imageWrapEl) {
                gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
              }
              gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);
              zoom.scale = 1;
              currentScale = 1;
              gesture.slideEl = undefined;
              gesture.imageEl = undefined;
              gesture.imageWrapEl = undefined;
              gesture.originX = 0;
              gesture.originY = 0;
            }
          }
          function onMouseMove(e) {
            // Only pan if zoomed in and mouse panning is enabled
            if (currentScale <= 1 || !gesture.imageWrapEl) return;
            if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;
            const currentTransform = window.getComputedStyle(gesture.imageWrapEl).transform;
            const matrix = new window.DOMMatrix(currentTransform);
            if (!isPanningWithMouse) {
              isPanningWithMouse = true;
              mousePanStart.x = e.clientX;
              mousePanStart.y = e.clientY;
              image.startX = matrix.e;
              image.startY = matrix.f;
              image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
              image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
              gesture.slideWidth = gesture.slideEl.offsetWidth;
              gesture.slideHeight = gesture.slideEl.offsetHeight;
              return;
            }
            const deltaX = (e.clientX - mousePanStart.x) * mousePanSensitivity;
            const deltaY = (e.clientY - mousePanStart.y) * mousePanSensitivity;
            const scaledWidth = image.width * currentScale;
            const scaledHeight = image.height * currentScale;
            const slideWidth = gesture.slideWidth;
            const slideHeight = gesture.slideHeight;
            const minX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
            const maxX = -minX;
            const minY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
            const maxY = -minY;
            const newX = Math.max(Math.min(image.startX + deltaX, maxX), minX);
            const newY = Math.max(Math.min(image.startY + deltaY, maxY), minY);
            gesture.imageWrapEl.style.transitionDuration = '0ms';
            gesture.imageWrapEl.style.transform = `translate3d(${newX}px, ${newY}px, 0)`;
            mousePanStart.x = e.clientX;
            mousePanStart.y = e.clientY;
            image.startX = newX;
            image.startY = newY;
            image.currentX = newX;
            image.currentY = newY;
          }
          function zoomIn(e) {
            const zoom = swiper.zoom;
            const params = swiper.params.zoom;
            if (!gesture.slideEl) {
              if (e && e.target) {
                gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
              }
              if (!gesture.slideEl) {
                if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                  gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
                } else {
                  gesture.slideEl = swiper.slides[swiper.activeIndex];
                }
              }
              let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
              if (imageEl) {
                imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
              }
              gesture.imageEl = imageEl;
              if (imageEl) {
                gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
              } else {
                gesture.imageWrapEl = undefined;
              }
            }
            if (!gesture.imageEl || !gesture.imageWrapEl) return;
            if (swiper.params.cssMode) {
              swiper.wrapperEl.style.overflow = 'hidden';
              swiper.wrapperEl.style.touchAction = 'none';
            }
            gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
            let touchX;
            let touchY;
            let offsetX;
            let offsetY;
            let diffX;
            let diffY;
            let translateX;
            let translateY;
            let imageWidth;
            let imageHeight;
            let scaledWidth;
            let scaledHeight;
            let translateMinX;
            let translateMinY;
            let translateMaxX;
            let translateMaxY;
            let slideWidth;
            let slideHeight;
            if (typeof image.touchesStart.x === 'undefined' && e) {
              touchX = e.pageX;
              touchY = e.pageY;
            } else {
              touchX = image.touchesStart.x;
              touchY = image.touchesStart.y;
            }
            const prevScale = currentScale;
            const forceZoomRatio = typeof e === 'number' ? e : null;
            if (currentScale === 1 && forceZoomRatio) {
              touchX = undefined;
              touchY = undefined;
              image.touchesStart.x = undefined;
              image.touchesStart.y = undefined;
            }
            const maxRatio = getMaxRatio();
            zoom.scale = forceZoomRatio || maxRatio;
            currentScale = forceZoomRatio || maxRatio;
            if (e && !(currentScale === 1 && forceZoomRatio)) {
              slideWidth = gesture.slideEl.offsetWidth;
              slideHeight = gesture.slideEl.offsetHeight;
              offsetX = elementOffset(gesture.slideEl).left + window.scrollX;
              offsetY = elementOffset(gesture.slideEl).top + window.scrollY;
              diffX = offsetX + slideWidth / 2 - touchX;
              diffY = offsetY + slideHeight / 2 - touchY;
              imageWidth = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
              imageHeight = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
              scaledWidth = imageWidth * zoom.scale;
              scaledHeight = imageHeight * zoom.scale;
              translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
              translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
              translateMaxX = -translateMinX;
              translateMaxY = -translateMinY;
              if (prevScale > 0 && forceZoomRatio && typeof image.currentX === 'number' && typeof image.currentY === 'number') {
                translateX = image.currentX * zoom.scale / prevScale;
                translateY = image.currentY * zoom.scale / prevScale;
              } else {
                translateX = diffX * zoom.scale;
                translateY = diffY * zoom.scale;
              }
              if (translateX < translateMinX) {
                translateX = translateMinX;
              }
              if (translateX > translateMaxX) {
                translateX = translateMaxX;
              }
              if (translateY < translateMinY) {
                translateY = translateMinY;
              }
              if (translateY > translateMaxY) {
                translateY = translateMaxY;
              }
            } else {
              translateX = 0;
              translateY = 0;
            }
            if (forceZoomRatio && zoom.scale === 1) {
              gesture.originX = 0;
              gesture.originY = 0;
            }
            image.currentX = translateX;
            image.currentY = translateY;
            gesture.imageWrapEl.style.transitionDuration = '300ms';
            gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;
            gesture.imageEl.style.transitionDuration = '300ms';
            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
          }
          function zoomOut() {
            const zoom = swiper.zoom;
            const params = swiper.params.zoom;
            if (!gesture.slideEl) {
              if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
              } else {
                gesture.slideEl = swiper.slides[swiper.activeIndex];
              }
              let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
              if (imageEl) {
                imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
              }
              gesture.imageEl = imageEl;
              if (imageEl) {
                gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
              } else {
                gesture.imageWrapEl = undefined;
              }
            }
            if (!gesture.imageEl || !gesture.imageWrapEl) return;
            if (swiper.params.cssMode) {
              swiper.wrapperEl.style.overflow = '';
              swiper.wrapperEl.style.touchAction = '';
            }
            zoom.scale = 1;
            currentScale = 1;
            image.currentX = undefined;
            image.currentY = undefined;
            image.touchesStart.x = undefined;
            image.touchesStart.y = undefined;
            gesture.imageWrapEl.style.transitionDuration = '300ms';
            gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
            gesture.imageEl.style.transitionDuration = '300ms';
            gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
            gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
            gesture.slideEl = undefined;
            gesture.originX = 0;
            gesture.originY = 0;
            if (swiper.params.zoom.panOnMouseMove) {
              mousePanStart = {
                x: 0,
                y: 0
              };
              if (isPanningWithMouse) {
                isPanningWithMouse = false;
                image.startX = 0;
                image.startY = 0;
              }
            }
          }

          // Toggle Zoom
          function zoomToggle(e) {
            const zoom = swiper.zoom;
            if (zoom.scale && zoom.scale !== 1) {
              // Zoom Out
              zoomOut();
            } else {
              // Zoom In
              zoomIn(e);
            }
          }
          function getListeners() {
            const passiveListener = swiper.params.passiveListeners ? {
              passive: true,
              capture: false
            } : false;
            const activeListenerWithCapture = swiper.params.passiveListeners ? {
              passive: false,
              capture: true
            } : true;
            return {
              passiveListener,
              activeListenerWithCapture
            };
          }

          // Attach/Detach Events
          function enable() {
            const zoom = swiper.zoom;
            if (zoom.enabled) return;
            zoom.enabled = true;
            const {
              passiveListener,
              activeListenerWithCapture
            } = getListeners();

            // Scale image
            swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);
            swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);
            ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {
              swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);
            });

            // Move image
            swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);
          }
          function disable() {
            const zoom = swiper.zoom;
            if (!zoom.enabled) return;
            zoom.enabled = false;
            const {
              passiveListener,
              activeListenerWithCapture
            } = getListeners();

            // Scale image
            swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);
            swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);
            ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {
              swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);
            });

            // Move image
            swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);
          }
          on('init', () => {
            if (swiper.params.zoom.enabled) {
              enable();
            }
          });
          on('destroy', () => {
            disable();
          });
          on('touchStart', (_s, e) => {
            if (!swiper.zoom.enabled) return;
            onTouchStart(e);
          });
          on('touchEnd', (_s, e) => {
            if (!swiper.zoom.enabled) return;
            onTouchEnd();
          });
          on('doubleTap', (_s, e) => {
            if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
              zoomToggle(e);
            }
          });
          on('transitionEnd', () => {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
              onTransitionEnd();
            }
          });
          on('slideChange', () => {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
              onTransitionEnd();
            }
          });
          Object.assign(swiper.zoom, {
            enable,
            disable,
            in: zoomIn,
            out: zoomOut,
            toggle: zoomToggle
          });
        }

        /* eslint no-bitwise: ["error", { "allow": [">>"] }] */
        function Controller({
          swiper,
          extendParams,
          on
        }) {
          extendParams({
            controller: {
              control: undefined,
              inverse: false,
              by: 'slide' // or 'container'
            }
          });
          swiper.controller = {
            control: undefined
          };
          function LinearSpline(x, y) {
            const binarySearch = function search() {
              let maxIndex;
              let minIndex;
              let guess;
              return (array, val) => {
                minIndex = -1;
                maxIndex = array.length;
                while (maxIndex - minIndex > 1) {
                  guess = maxIndex + minIndex >> 1;
                  if (array[guess] <= val) {
                    minIndex = guess;
                  } else {
                    maxIndex = guess;
                  }
                }
                return maxIndex;
              };
            }();
            this.x = x;
            this.y = y;
            this.lastIndex = x.length - 1;
            // Given an x value (x2), return the expected y2 value:
            // (x1,y1) is the known point before given value,
            // (x3,y3) is the known point after given value.
            let i1;
            let i3;
            this.interpolate = function interpolate(x2) {
              if (!x2) return 0;

              // Get the indexes of x1 and x3 (the array indexes before and after given x2):
              i3 = binarySearch(this.x, x2);
              i1 = i3 - 1;

              // We have our indexes i1 & i3, so we can calculate already:
              // y2 := ((x2x1)  (y3y1))  (x3x1) + y1
              return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
            };
            return this;
          }
          function getInterpolateFunction(c) {
            swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
          }
          function setTranslate(_t, byController) {
            const controlled = swiper.controller.control;
            let multiplier;
            let controlledTranslate;
            const Swiper = swiper.constructor;
            function setControlledTranslate(c) {
              if (c.destroyed) return;

              // this will create an Interpolate function based on the snapGrids
              // x is the Grid of the scrolled scroller and y will be the controlled scroller
              // it makes sense to create this only once and recall it for the interpolation
              // the function does a lot of value caching for performance
              const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
              if (swiper.params.controller.by === 'slide') {
                getInterpolateFunction(c);
                // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
                // but it did not work out
                controlledTranslate = -swiper.controller.spline.interpolate(-translate);
              }
              if (!controlledTranslate || swiper.params.controller.by === 'container') {
                multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {
                  multiplier = 1;
                }
                controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
              }
              if (swiper.params.controller.inverse) {
                controlledTranslate = c.maxTranslate() - controlledTranslate;
              }
              c.updateProgress(controlledTranslate);
              c.setTranslate(controlledTranslate, swiper);
              c.updateActiveIndex();
              c.updateSlidesClasses();
            }
            if (Array.isArray(controlled)) {
              for (let i = 0; i < controlled.length; i += 1) {
                if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                  setControlledTranslate(controlled[i]);
                }
              }
            } else if (controlled instanceof Swiper && byController !== controlled) {
              setControlledTranslate(controlled);
            }
          }
          function setTransition(duration, byController) {
            const Swiper = swiper.constructor;
            const controlled = swiper.controller.control;
            let i;
            function setControlledTransition(c) {
              if (c.destroyed) return;
              c.setTransition(duration, swiper);
              if (duration !== 0) {
                c.transitionStart();
                if (c.params.autoHeight) {
                  nextTick(() => {
                    c.updateAutoHeight();
                  });
                }
                elementTransitionEnd(c.wrapperEl, () => {
                  if (!controlled) return;
                  c.transitionEnd();
                });
              }
            }
            if (Array.isArray(controlled)) {
              for (i = 0; i < controlled.length; i += 1) {
                if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                  setControlledTransition(controlled[i]);
                }
              }
            } else if (controlled instanceof Swiper && byController !== controlled) {
              setControlledTransition(controlled);
            }
          }
          function removeSpline() {
            if (!swiper.controller.control) return;
            if (swiper.controller.spline) {
              swiper.controller.spline = undefined;
              delete swiper.controller.spline;
            }
          }
          on('beforeInit', () => {
            if (typeof window !== 'undefined' && (
            // eslint-disable-line
            typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {
              const controlElements = typeof swiper.params.controller.control === 'string' ? [...document.querySelectorAll(swiper.params.controller.control)] : [swiper.params.controller.control];
              controlElements.forEach(controlElement => {
                if (!swiper.controller.control) swiper.controller.control = [];
                if (controlElement && controlElement.swiper) {
                  swiper.controller.control.push(controlElement.swiper);
                } else if (controlElement) {
                  const eventName = `${swiper.params.eventsPrefix}init`;
                  const onControllerSwiper = e => {
                    swiper.controller.control.push(e.detail[0]);
                    swiper.update();
                    controlElement.removeEventListener(eventName, onControllerSwiper);
                  };
                  controlElement.addEventListener(eventName, onControllerSwiper);
                }
              });
              return;
            }
            swiper.controller.control = swiper.params.controller.control;
          });
          on('update', () => {
            removeSpline();
          });
          on('resize', () => {
            removeSpline();
          });
          on('observerUpdate', () => {
            removeSpline();
          });
          on('setTranslate', (_s, translate, byController) => {
            if (!swiper.controller.control || swiper.controller.control.destroyed) return;
            swiper.controller.setTranslate(translate, byController);
          });
          on('setTransition', (_s, duration, byController) => {
            if (!swiper.controller.control || swiper.controller.control.destroyed) return;
            swiper.controller.setTransition(duration, byController);
          });
          Object.assign(swiper.controller, {
            setTranslate,
            setTransition
          });
        }
        function A11y({
          swiper,
          extendParams,
          on
        }) {
          extendParams({
            a11y: {
              enabled: true,
              notificationClass: 'swiper-notification',
              prevSlideMessage: 'Previous slide',
              nextSlideMessage: 'Next slide',
              firstSlideMessage: 'This is the first slide',
              lastSlideMessage: 'This is the last slide',
              paginationBulletMessage: 'Go to slide {{index}}',
              slideLabelMessage: '{{index}} / {{slidesLength}}',
              containerMessage: null,
              containerRoleDescriptionMessage: null,
              containerRole: null,
              itemRoleDescriptionMessage: null,
              slideRole: 'group',
              id: null,
              scrollOnFocus: true,
              wrapperLiveRegion: true
            }
          });
          swiper.a11y = {
            clicked: false
          };
          let liveRegion = null;
          let preventFocusHandler;
          let focusTargetSlideEl;
          let visibilityChangedTimestamp = new Date().getTime();
          function notify(message) {
            const notification = liveRegion;
            if (notification.length === 0) return;
            setInnerHTML(notification, message);
          }
          function getRandomNumber(size = 16) {
            const randomChar = () => Math.round(16 * Math.random()).toString(16);
            return 'x'.repeat(size).replace(/x/g, randomChar);
          }
          function makeElFocusable(el) {
            el = makeElementsArray(el);
            el.forEach(subEl => {
              subEl.setAttribute('tabIndex', '0');
            });
          }
          function makeElNotFocusable(el) {
            el = makeElementsArray(el);
            el.forEach(subEl => {
              subEl.setAttribute('tabIndex', '-1');
            });
          }
          function addElRole(el, role) {
            el = makeElementsArray(el);
            el.forEach(subEl => {
              subEl.setAttribute('role', role);
            });
          }
          function addElRoleDescription(el, description) {
            el = makeElementsArray(el);
            el.forEach(subEl => {
              subEl.setAttribute('aria-roledescription', description);
            });
          }
          function addElControls(el, controls) {
            el = makeElementsArray(el);
            el.forEach(subEl => {
              subEl.setAttribute('aria-controls', controls);
            });
          }
          function addElLabel(el, label) {
            el = makeElementsArray(el);
            el.forEach(subEl => {
              subEl.setAttribute('aria-label', label);
            });
          }
          function addElId(el, id) {
            el = makeElementsArray(el);
            el.forEach(subEl => {
              subEl.setAttribute('id', id);
            });
          }
          function addElLive(el, live) {
            el = makeElementsArray(el);
            el.forEach(subEl => {
              subEl.setAttribute('aria-live', live);
            });
          }
          function disableEl(el) {
            el = makeElementsArray(el);
            el.forEach(subEl => {
              subEl.setAttribute('aria-disabled', true);
            });
          }
          function enableEl(el) {
            el = makeElementsArray(el);
            el.forEach(subEl => {
              subEl.setAttribute('aria-disabled', false);
            });
          }
          function onEnterOrSpaceKey(e) {
            if (e.keyCode !== 13 && e.keyCode !== 32) return;
            const params = swiper.params.a11y;
            const targetEl = e.target;
            if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {
              if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;
            }
            if (swiper.navigation && swiper.navigation.prevEl && swiper.navigation.nextEl) {
              const prevEls = makeElementsArray(swiper.navigation.prevEl);
              const nextEls = makeElementsArray(swiper.navigation.nextEl);
              if (nextEls.includes(targetEl)) {
                if (!(swiper.isEnd && !swiper.params.loop)) {
                  swiper.slideNext();
                }
                if (swiper.isEnd) {
                  notify(params.lastSlideMessage);
                } else {
                  notify(params.nextSlideMessage);
                }
              }
              if (prevEls.includes(targetEl)) {
                if (!(swiper.isBeginning && !swiper.params.loop)) {
                  swiper.slidePrev();
                }
                if (swiper.isBeginning) {
                  notify(params.firstSlideMessage);
                } else {
                  notify(params.prevSlideMessage);
                }
              }
            }
            if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {
              targetEl.click();
            }
          }
          function updateNavigation() {
            if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
            const {
              nextEl,
              prevEl
            } = swiper.navigation;
            if (prevEl) {
              if (swiper.isBeginning) {
                disableEl(prevEl);
                makeElNotFocusable(prevEl);
              } else {
                enableEl(prevEl);
                makeElFocusable(prevEl);
              }
            }
            if (nextEl) {
              if (swiper.isEnd) {
                disableEl(nextEl);
                makeElNotFocusable(nextEl);
              } else {
                enableEl(nextEl);
                makeElFocusable(nextEl);
              }
            }
          }
          function hasPagination() {
            return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
          }
          function hasClickablePagination() {
            return hasPagination() && swiper.params.pagination.clickable;
          }
          function updatePagination() {
            const params = swiper.params.a11y;
            if (!hasPagination()) return;
            swiper.pagination.bullets.forEach(bulletEl => {
              if (swiper.params.pagination.clickable) {
                makeElFocusable(bulletEl);
                if (!swiper.params.pagination.renderBullet) {
                  addElRole(bulletEl, 'button');
                  addElLabel(bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, elementIndex(bulletEl) + 1));
                }
              }
              if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {
                bulletEl.setAttribute('aria-current', 'true');
              } else {
                bulletEl.removeAttribute('aria-current');
              }
            });
          }
          const initNavEl = (el, wrapperId, message) => {
            makeElFocusable(el);
            if (el.tagName !== 'BUTTON') {
              addElRole(el, 'button');
              el.addEventListener('keydown', onEnterOrSpaceKey);
            }
            addElLabel(el, message);
            addElControls(el, wrapperId);
          };
          const handlePointerDown = e => {
            if (focusTargetSlideEl && focusTargetSlideEl !== e.target && !focusTargetSlideEl.contains(e.target)) {
              preventFocusHandler = true;
            }
            swiper.a11y.clicked = true;
          };
          const handlePointerUp = () => {
            preventFocusHandler = false;
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                if (!swiper.destroyed) {
                  swiper.a11y.clicked = false;
                }
              });
            });
          };
          const onVisibilityChange = e => {
            visibilityChangedTimestamp = new Date().getTime();
          };
          const handleFocus = e => {
            if (swiper.a11y.clicked || !swiper.params.a11y.scrollOnFocus) return;
            if (new Date().getTime() - visibilityChangedTimestamp < 100) return;
            const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
            if (!slideEl || !swiper.slides.includes(slideEl)) return;
            focusTargetSlideEl = slideEl;
            const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
            const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
            if (isActive || isVisible) return;
            if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
            if (swiper.isHorizontal()) {
              swiper.el.scrollLeft = 0;
            } else {
              swiper.el.scrollTop = 0;
            }
            requestAnimationFrame(() => {
              if (preventFocusHandler) return;
              if (swiper.params.loop) {
                swiper.slideToLoop(swiper.getSlideIndexWhenGrid(parseInt(slideEl.getAttribute('data-swiper-slide-index'))), 0);
              } else {
                swiper.slideTo(swiper.getSlideIndexWhenGrid(swiper.slides.indexOf(slideEl)), 0);
              }
              preventFocusHandler = false;
            });
          };
          const initSlides = () => {
            const params = swiper.params.a11y;
            if (params.itemRoleDescriptionMessage) {
              addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);
            }
            if (params.slideRole) {
              addElRole(swiper.slides, params.slideRole);
            }
            const slidesLength = swiper.slides.length;
            if (params.slideLabelMessage) {
              swiper.slides.forEach((slideEl, index) => {
                const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;
                const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
                addElLabel(slideEl, ariaLabelMessage);
              });
            }
          };
          const init = () => {
            const params = swiper.params.a11y;
            swiper.el.append(liveRegion);

            // Container
            const containerEl = swiper.el;
            if (params.containerRoleDescriptionMessage) {
              addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);
            }
            if (params.containerMessage) {
              addElLabel(containerEl, params.containerMessage);
            }
            if (params.containerRole) {
              addElRole(containerEl, params.containerRole);
            }

            // Wrapper
            const wrapperEl = swiper.wrapperEl;
            const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;
            addElId(wrapperEl, wrapperId);
            if (params.wrapperLiveRegion) {
              const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
              addElLive(wrapperEl, live);
            }

            // Slide
            initSlides();

            // Navigation
            let {
              nextEl,
              prevEl
            } = swiper.navigation ? swiper.navigation : {};
            nextEl = makeElementsArray(nextEl);
            prevEl = makeElementsArray(prevEl);
            if (nextEl) {
              nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));
            }
            if (prevEl) {
              prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));
            }

            // Pagination
            if (hasClickablePagination()) {
              const paginationEl = makeElementsArray(swiper.pagination.el);
              paginationEl.forEach(el => {
                el.addEventListener('keydown', onEnterOrSpaceKey);
              });
            }

            // Tab focus
            const document = getDocument();
            document.addEventListener('visibilitychange', onVisibilityChange);
            swiper.el.addEventListener('focus', handleFocus, true);
            swiper.el.addEventListener('focus', handleFocus, true);
            swiper.el.addEventListener('pointerdown', handlePointerDown, true);
            swiper.el.addEventListener('pointerup', handlePointerUp, true);
          };
          function destroy() {
            if (liveRegion) liveRegion.remove();
            let {
              nextEl,
              prevEl
            } = swiper.navigation ? swiper.navigation : {};
            nextEl = makeElementsArray(nextEl);
            prevEl = makeElementsArray(prevEl);
            if (nextEl) {
              nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));
            }
            if (prevEl) {
              prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));
            }

            // Pagination
            if (hasClickablePagination()) {
              const paginationEl = makeElementsArray(swiper.pagination.el);
              paginationEl.forEach(el => {
                el.removeEventListener('keydown', onEnterOrSpaceKey);
              });
            }
            const document = getDocument();
            document.removeEventListener('visibilitychange', onVisibilityChange);
            // Tab focus
            if (swiper.el && typeof swiper.el !== 'string') {
              swiper.el.removeEventListener('focus', handleFocus, true);
              swiper.el.removeEventListener('pointerdown', handlePointerDown, true);
              swiper.el.removeEventListener('pointerup', handlePointerUp, true);
            }
          }
          on('beforeInit', () => {
            liveRegion = createElement('span', swiper.params.a11y.notificationClass);
            liveRegion.setAttribute('aria-live', 'assertive');
            liveRegion.setAttribute('aria-atomic', 'true');
          });
          on('afterInit', () => {
            if (!swiper.params.a11y.enabled) return;
            init();
          });
          on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {
            if (!swiper.params.a11y.enabled) return;
            initSlides();
          });
          on('fromEdge toEdge afterInit lock unlock', () => {
            if (!swiper.params.a11y.enabled) return;
            updateNavigation();
          });
          on('paginationUpdate', () => {
            if (!swiper.params.a11y.enabled) return;
            updatePagination();
          });
          on('destroy', () => {
            if (!swiper.params.a11y.enabled) return;
            destroy();
          });
        }
        function History({
          swiper,
          extendParams,
          on
        }) {
          extendParams({
            history: {
              enabled: false,
              root: '',
              replaceState: false,
              key: 'slides',
              keepQuery: false
            }
          });
          let initialized = false;
          let paths = {};
          const slugify = text => {
            return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
          };
          const getPathValues = urlOverride => {
            const window = getWindow();
            let location;
            if (urlOverride) {
              location = new URL(urlOverride);
            } else {
              location = window.location;
            }
            const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
            const total = pathArray.length;
            const key = pathArray[total - 2];
            const value = pathArray[total - 1];
            return {
              key,
              value
            };
          };
          const setHistory = (key, index) => {
            const window = getWindow();
            if (!initialized || !swiper.params.history.enabled) return;
            let location;
            if (swiper.params.url) {
              location = new URL(swiper.params.url);
            } else {
              location = window.location;
            }
            const slide = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${index}"]`) : swiper.slides[index];
            let value = slugify(slide.getAttribute('data-history'));
            if (swiper.params.history.root.length > 0) {
              let root = swiper.params.history.root;
              if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
              value = `${root}/${key ? `${key}/` : ''}${value}`;
            } else if (!location.pathname.includes(key)) {
              value = `${key ? `${key}/` : ''}${value}`;
            }
            if (swiper.params.history.keepQuery) {
              value += location.search;
            }
            const currentState = window.history.state;
            if (currentState && currentState.value === value) {
              return;
            }
            if (swiper.params.history.replaceState) {
              window.history.replaceState({
                value
              }, null, value);
            } else {
              window.history.pushState({
                value
              }, null, value);
            }
          };
          const scrollToSlide = (speed, value, runCallbacks) => {
            if (value) {
              for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
                const slide = swiper.slides[i];
                const slideHistory = slugify(slide.getAttribute('data-history'));
                if (slideHistory === value) {
                  const index = swiper.getSlideIndex(slide);
                  swiper.slideTo(index, speed, runCallbacks);
                }
              }
            } else {
              swiper.slideTo(0, speed, runCallbacks);
            }
          };
          const setHistoryPopState = () => {
            paths = getPathValues(swiper.params.url);
            scrollToSlide(swiper.params.speed, paths.value, false);
          };
          const init = () => {
            const window = getWindow();
            if (!swiper.params.history) return;
            if (!window.history || !window.history.pushState) {
              swiper.params.history.enabled = false;
              swiper.params.hashNavigation.enabled = true;
              return;
            }
            initialized = true;
            paths = getPathValues(swiper.params.url);
            if (!paths.key && !paths.value) {
              if (!swiper.params.history.replaceState) {
                window.addEventListener('popstate', setHistoryPopState);
              }
              return;
            }
            scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
            if (!swiper.params.history.replaceState) {
              window.addEventListener('popstate', setHistoryPopState);
            }
          };
          const destroy = () => {
            const window = getWindow();
            if (!swiper.params.history.replaceState) {
              window.removeEventListener('popstate', setHistoryPopState);
            }
          };
          on('init', () => {
            if (swiper.params.history.enabled) {
              init();
            }
          });
          on('destroy', () => {
            if (swiper.params.history.enabled) {
              destroy();
            }
          });
          on('transitionEnd _freeModeNoMomentumRelease', () => {
            if (initialized) {
              setHistory(swiper.params.history.key, swiper.activeIndex);
            }
          });
          on('slideChange', () => {
            if (initialized && swiper.params.cssMode) {
              setHistory(swiper.params.history.key, swiper.activeIndex);
            }
          });
        }
        function HashNavigation({
          swiper,
          extendParams,
          emit,
          on
        }) {
          let initialized = false;
          const document = getDocument();
          const window = getWindow();
          extendParams({
            hashNavigation: {
              enabled: false,
              replaceState: false,
              watchState: false,
              getSlideIndex(_s, hash) {
                if (swiper.virtual && swiper.params.virtual.enabled) {
                  const slideWithHash = swiper.slides.find(slideEl => slideEl.getAttribute('data-hash') === hash);
                  if (!slideWithHash) return 0;
                  const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);
                  return index;
                }
                return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash="${hash}"], swiper-slide[data-hash="${hash}"]`)[0]);
              }
            }
          });
          const onHashChange = () => {
            emit('hashChange');
            const newHash = document.location.hash.replace('#', '');
            const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
            const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';
            if (newHash !== activeSlideHash) {
              const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);
              if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;
              swiper.slideTo(newIndex);
            }
          };
          const setHash = () => {
            if (!initialized || !swiper.params.hashNavigation.enabled) return;
            const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
            const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';
            if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
              window.history.replaceState(null, null, `#${activeSlideHash}` || '');
              emit('hashSet');
            } else {
              document.location.hash = activeSlideHash || '';
              emit('hashSet');
            }
          };
          const init = () => {
            if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
            initialized = true;
            const hash = document.location.hash.replace('#', '');
            if (hash) {
              const speed = 0;
              const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);
              swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);
            }
            if (swiper.params.hashNavigation.watchState) {
              window.addEventListener('hashchange', onHashChange);
            }
          };
          const destroy = () => {
            if (swiper.params.hashNavigation.watchState) {
              window.removeEventListener('hashchange', onHashChange);
            }
          };
          on('init', () => {
            if (swiper.params.hashNavigation.enabled) {
              init();
            }
          });
          on('destroy', () => {
            if (swiper.params.hashNavigation.enabled) {
              destroy();
            }
          });
          on('transitionEnd _freeModeNoMomentumRelease', () => {
            if (initialized) {
              setHash();
            }
          });
          on('slideChange', () => {
            if (initialized && swiper.params.cssMode) {
              setHash();
            }
          });
        }

        /* eslint no-underscore-dangle: "off" */
        /* eslint no-use-before-define: "off" */
        function Autoplay({
          swiper,
          extendParams,
          on,
          emit,
          params
        }) {
          swiper.autoplay = {
            running: false,
            paused: false,
            timeLeft: 0
          };
          extendParams({
            autoplay: {
              enabled: false,
              delay: 3000,
              waitForTransition: true,
              disableOnInteraction: false,
              stopOnLastSlide: false,
              reverseDirection: false,
              pauseOnMouseEnter: false
            }
          });
          let timeout;
          let raf;
          let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;
          let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;
          let autoplayTimeLeft;
          let autoplayStartTime = new Date().getTime();
          let wasPaused;
          let isTouched;
          let pausedByTouch;
          let touchStartTimeout;
          let slideChanged;
          let pausedByInteraction;
          let pausedByPointerEnter;
          function onTransitionEnd(e) {
            if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
            if (e.target !== swiper.wrapperEl) return;
            swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);
            if (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) {
              return;
            }
            resume();
          }
          const calcTimeLeft = () => {
            if (swiper.destroyed || !swiper.autoplay.running) return;
            if (swiper.autoplay.paused) {
              wasPaused = true;
            } else if (wasPaused) {
              autoplayDelayCurrent = autoplayTimeLeft;
              wasPaused = false;
            }
            const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();
            swiper.autoplay.timeLeft = timeLeft;
            emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);
            raf = requestAnimationFrame(() => {
              calcTimeLeft();
            });
          };
          const getSlideDelay = () => {
            let activeSlideEl;
            if (swiper.virtual && swiper.params.virtual.enabled) {
              activeSlideEl = swiper.slides.find(slideEl => slideEl.classList.contains('swiper-slide-active'));
            } else {
              activeSlideEl = swiper.slides[swiper.activeIndex];
            }
            if (!activeSlideEl) return undefined;
            const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);
            return currentSlideDelay;
          };
          const run = delayForce => {
            if (swiper.destroyed || !swiper.autoplay.running) return;
            cancelAnimationFrame(raf);
            calcTimeLeft();
            let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;
            autoplayDelayTotal = swiper.params.autoplay.delay;
            autoplayDelayCurrent = swiper.params.autoplay.delay;
            const currentSlideDelay = getSlideDelay();
            if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {
              delay = currentSlideDelay;
              autoplayDelayTotal = currentSlideDelay;
              autoplayDelayCurrent = currentSlideDelay;
            }
            autoplayTimeLeft = delay;
            const speed = swiper.params.speed;
            const proceed = () => {
              if (!swiper || swiper.destroyed) return;
              if (swiper.params.autoplay.reverseDirection) {
                if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
                  swiper.slidePrev(speed, true, true);
                  emit('autoplay');
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                  swiper.slideTo(swiper.slides.length - 1, speed, true, true);
                  emit('autoplay');
                }
              } else {
                if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
                  swiper.slideNext(speed, true, true);
                  emit('autoplay');
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                  swiper.slideTo(0, speed, true, true);
                  emit('autoplay');
                }
              }
              if (swiper.params.cssMode) {
                autoplayStartTime = new Date().getTime();
                requestAnimationFrame(() => {
                  run();
                });
              }
            };
            if (delay > 0) {
              clearTimeout(timeout);
              timeout = setTimeout(() => {
                proceed();
              }, delay);
            } else {
              requestAnimationFrame(() => {
                proceed();
              });
            }

            // eslint-disable-next-line
            return delay;
          };
          const start = () => {
            autoplayStartTime = new Date().getTime();
            swiper.autoplay.running = true;
            run();
            emit('autoplayStart');
          };
          const stop = () => {
            swiper.autoplay.running = false;
            clearTimeout(timeout);
            cancelAnimationFrame(raf);
            emit('autoplayStop');
          };
          const pause = (internal, reset) => {
            if (swiper.destroyed || !swiper.autoplay.running) return;
            clearTimeout(timeout);
            if (!internal) {
              pausedByInteraction = true;
            }
            const proceed = () => {
              emit('autoplayPause');
              if (swiper.params.autoplay.waitForTransition) {
                swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);
              } else {
                resume();
              }
            };
            swiper.autoplay.paused = true;
            if (reset) {
              if (slideChanged) {
                autoplayTimeLeft = swiper.params.autoplay.delay;
              }
              slideChanged = false;
              proceed();
              return;
            }
            const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
            autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);
            if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
            if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
            proceed();
          };
          const resume = () => {
            if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
            autoplayStartTime = new Date().getTime();
            if (pausedByInteraction) {
              pausedByInteraction = false;
              run(autoplayTimeLeft);
            } else {
              run();
            }
            swiper.autoplay.paused = false;
            emit('autoplayResume');
          };
          const onVisibilityChange = () => {
            if (swiper.destroyed || !swiper.autoplay.running) return;
            const document = getDocument();
            if (document.visibilityState === 'hidden') {
              pausedByInteraction = true;
              pause(true);
            }
            if (document.visibilityState === 'visible') {
              resume();
            }
          };
          const onPointerEnter = e => {
            if (e.pointerType !== 'mouse') return;
            pausedByInteraction = true;
            pausedByPointerEnter = true;
            if (swiper.animating || swiper.autoplay.paused) return;
            pause(true);
          };
          const onPointerLeave = e => {
            if (e.pointerType !== 'mouse') return;
            pausedByPointerEnter = false;
            if (swiper.autoplay.paused) {
              resume();
            }
          };
          const attachMouseEvents = () => {
            if (swiper.params.autoplay.pauseOnMouseEnter) {
              swiper.el.addEventListener('pointerenter', onPointerEnter);
              swiper.el.addEventListener('pointerleave', onPointerLeave);
            }
          };
          const detachMouseEvents = () => {
            if (swiper.el && typeof swiper.el !== 'string') {
              swiper.el.removeEventListener('pointerenter', onPointerEnter);
              swiper.el.removeEventListener('pointerleave', onPointerLeave);
            }
          };
          const attachDocumentEvents = () => {
            const document = getDocument();
            document.addEventListener('visibilitychange', onVisibilityChange);
          };
          const detachDocumentEvents = () => {
            const document = getDocument();
            document.removeEventListener('visibilitychange', onVisibilityChange);
          };
          on('init', () => {
            if (swiper.params.autoplay.enabled) {
              attachMouseEvents();
              attachDocumentEvents();
              start();
            }
          });
          on('destroy', () => {
            detachMouseEvents();
            detachDocumentEvents();
            if (swiper.autoplay.running) {
              stop();
            }
          });
          on('_freeModeStaticRelease', () => {
            if (pausedByTouch || pausedByInteraction) {
              resume();
            }
          });
          on('_freeModeNoMomentumRelease', () => {
            if (!swiper.params.autoplay.disableOnInteraction) {
              pause(true, true);
            } else {
              stop();
            }
          });
          on('beforeTransitionStart', (_s, speed, internal) => {
            if (swiper.destroyed || !swiper.autoplay.running) return;
            if (internal || !swiper.params.autoplay.disableOnInteraction) {
              pause(true, true);
            } else {
              stop();
            }
          });
          on('sliderFirstMove', () => {
            if (swiper.destroyed || !swiper.autoplay.running) return;
            if (swiper.params.autoplay.disableOnInteraction) {
              stop();
              return;
            }
            isTouched = true;
            pausedByTouch = false;
            pausedByInteraction = false;
            touchStartTimeout = setTimeout(() => {
              pausedByInteraction = true;
              pausedByTouch = true;
              pause(true);
            }, 200);
          });
          on('touchEnd', () => {
            if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
            clearTimeout(touchStartTimeout);
            clearTimeout(timeout);
            if (swiper.params.autoplay.disableOnInteraction) {
              pausedByTouch = false;
              isTouched = false;
              return;
            }
            if (pausedByTouch && swiper.params.cssMode) resume();
            pausedByTouch = false;
            isTouched = false;
          });
          on('slideChange', () => {
            if (swiper.destroyed || !swiper.autoplay.running) return;
            slideChanged = true;
          });
          Object.assign(swiper.autoplay, {
            start,
            stop,
            pause,
            resume
          });
        }
        function Thumb({
          swiper,
          extendParams,
          on
        }) {
          extendParams({
            thumbs: {
              swiper: null,
              multipleActiveThumbs: true,
              autoScrollOffset: 0,
              slideThumbActiveClass: 'swiper-slide-thumb-active',
              thumbsContainerClass: 'swiper-thumbs'
            }
          });
          let initialized = false;
          let swiperCreated = false;
          swiper.thumbs = {
            swiper: null
          };
          function onThumbClick() {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            const clickedIndex = thumbsSwiper.clickedIndex;
            const clickedSlide = thumbsSwiper.clickedSlide;
            if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;
            if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
            let slideToIndex;
            if (thumbsSwiper.params.loop) {
              slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
            } else {
              slideToIndex = clickedIndex;
            }
            if (swiper.params.loop) {
              swiper.slideToLoop(slideToIndex);
            } else {
              swiper.slideTo(slideToIndex);
            }
          }
          function init() {
            const {
              thumbs: thumbsParams
            } = swiper.params;
            if (initialized) return false;
            initialized = true;
            const SwiperClass = swiper.constructor;
            if (thumbsParams.swiper instanceof SwiperClass) {
              if (thumbsParams.swiper.destroyed) {
                initialized = false;
                return false;
              }
              swiper.thumbs.swiper = thumbsParams.swiper;
              Object.assign(swiper.thumbs.swiper.originalParams, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
              });
              Object.assign(swiper.thumbs.swiper.params, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
              });
              swiper.thumbs.swiper.update();
            } else if (isObject$2(thumbsParams.swiper)) {
              const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
              Object.assign(thumbsSwiperParams, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
              });
              swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
              swiperCreated = true;
            }
            swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
            swiper.thumbs.swiper.on('tap', onThumbClick);
            return true;
          }
          function update(initial) {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;

            // Activate thumbs
            let thumbsToActivate = 1;
            const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
            if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
              thumbsToActivate = swiper.params.slidesPerView;
            }
            if (!swiper.params.thumbs.multipleActiveThumbs) {
              thumbsToActivate = 1;
            }
            thumbsToActivate = Math.floor(thumbsToActivate);
            thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));
            if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
              for (let i = 0; i < thumbsToActivate; i += 1) {
                elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index="${swiper.realIndex + i}"]`).forEach(slideEl => {
                  slideEl.classList.add(thumbActiveClass);
                });
              }
            } else {
              for (let i = 0; i < thumbsToActivate; i += 1) {
                if (thumbsSwiper.slides[swiper.realIndex + i]) {
                  thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);
                }
              }
            }
            const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
            const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
            if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
              const currentThumbsIndex = thumbsSwiper.activeIndex;
              let newThumbsIndex;
              let direction;
              if (thumbsSwiper.params.loop) {
                const newThumbsSlide = thumbsSwiper.slides.find(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`);
                newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
                direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
              } else {
                newThumbsIndex = swiper.realIndex;
                direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
              }
              if (useOffset) {
                newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
              }
              if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                if (thumbsSwiper.params.centeredSlides) {
                  if (newThumbsIndex > currentThumbsIndex) {
                    newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                  } else {
                    newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                  }
                } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;
                thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
              }
            }
          }
          on('beforeInit', () => {
            const {
              thumbs
            } = swiper.params;
            if (!thumbs || !thumbs.swiper) return;
            if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {
              const document = getDocument();
              const getThumbsElementAndInit = () => {
                const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;
                if (thumbsElement && thumbsElement.swiper) {
                  thumbs.swiper = thumbsElement.swiper;
                  init();
                  update(true);
                } else if (thumbsElement) {
                  const eventName = `${swiper.params.eventsPrefix}init`;
                  const onThumbsSwiper = e => {
                    thumbs.swiper = e.detail[0];
                    thumbsElement.removeEventListener(eventName, onThumbsSwiper);
                    init();
                    update(true);
                    thumbs.swiper.update();
                    swiper.update();
                  };
                  thumbsElement.addEventListener(eventName, onThumbsSwiper);
                }
                return thumbsElement;
              };
              const watchForThumbsToAppear = () => {
                if (swiper.destroyed) return;
                const thumbsElement = getThumbsElementAndInit();
                if (!thumbsElement) {
                  requestAnimationFrame(watchForThumbsToAppear);
                }
              };
              requestAnimationFrame(watchForThumbsToAppear);
            } else {
              init();
              update(true);
            }
          });
          on('slideChange update resize observerUpdate', () => {
            update();
          });
          on('setTransition', (_s, duration) => {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            thumbsSwiper.setTransition(duration);
          });
          on('beforeDestroy', () => {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            if (swiperCreated) {
              thumbsSwiper.destroy();
            }
          });
          Object.assign(swiper.thumbs, {
            init,
            update
          });
        }
        function freeMode({
          swiper,
          extendParams,
          emit,
          once
        }) {
          extendParams({
            freeMode: {
              enabled: false,
              momentum: true,
              momentumRatio: 1,
              momentumBounce: true,
              momentumBounceRatio: 1,
              momentumVelocityRatio: 1,
              sticky: false,
              minimumVelocity: 0.02
            }
          });
          function onTouchStart() {
            if (swiper.params.cssMode) return;
            const translate = swiper.getTranslate();
            swiper.setTranslate(translate);
            swiper.setTransition(0);
            swiper.touchEventsData.velocities.length = 0;
            swiper.freeMode.onTouchEnd({
              currentPos: swiper.rtl ? swiper.translate : -swiper.translate
            });
          }
          function onTouchMove() {
            if (swiper.params.cssMode) return;
            const {
              touchEventsData: data,
              touches
            } = swiper;
            // Velocity
            if (data.velocities.length === 0) {
              data.velocities.push({
                position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
                time: data.touchStartTime
              });
            }
            data.velocities.push({
              position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
              time: now()
            });
          }
          function onTouchEnd({
            currentPos
          }) {
            if (swiper.params.cssMode) return;
            const {
              params,
              wrapperEl,
              rtlTranslate: rtl,
              snapGrid,
              touchEventsData: data
            } = swiper;
            // Time diff
            const touchEndTime = now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (currentPos < -swiper.minTranslate()) {
              swiper.slideTo(swiper.activeIndex);
              return;
            }
            if (currentPos > -swiper.maxTranslate()) {
              if (swiper.slides.length < snapGrid.length) {
                swiper.slideTo(snapGrid.length - 1);
              } else {
                swiper.slideTo(swiper.slides.length - 1);
              }
              return;
            }
            if (params.freeMode.momentum) {
              if (data.velocities.length > 1) {
                const lastMoveEvent = data.velocities.pop();
                const velocityEvent = data.velocities.pop();
                const distance = lastMoveEvent.position - velocityEvent.position;
                const time = lastMoveEvent.time - velocityEvent.time;
                swiper.velocity = distance / time;
                swiper.velocity /= 2;
                if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
                  swiper.velocity = 0;
                }
                // this implies that the user stopped moving a finger then released.
                // There would be no events with distance zero, so the last event is stale.
                if (time > 150 || now() - lastMoveEvent.time > 300) {
                  swiper.velocity = 0;
                }
              } else {
                swiper.velocity = 0;
              }
              swiper.velocity *= params.freeMode.momentumVelocityRatio;
              data.velocities.length = 0;
              let momentumDuration = 1000 * params.freeMode.momentumRatio;
              const momentumDistance = swiper.velocity * momentumDuration;
              let newPosition = swiper.translate + momentumDistance;
              if (rtl) newPosition = -newPosition;
              let doBounce = false;
              let afterBouncePosition;
              const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
              let needsLoopFix;
              if (newPosition < swiper.maxTranslate()) {
                if (params.freeMode.momentumBounce) {
                  if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                    newPosition = swiper.maxTranslate() - bounceAmount;
                  }
                  afterBouncePosition = swiper.maxTranslate();
                  doBounce = true;
                  data.allowMomentumBounce = true;
                } else {
                  newPosition = swiper.maxTranslate();
                }
                if (params.loop && params.centeredSlides) needsLoopFix = true;
              } else if (newPosition > swiper.minTranslate()) {
                if (params.freeMode.momentumBounce) {
                  if (newPosition - swiper.minTranslate() > bounceAmount) {
                    newPosition = swiper.minTranslate() + bounceAmount;
                  }
                  afterBouncePosition = swiper.minTranslate();
                  doBounce = true;
                  data.allowMomentumBounce = true;
                } else {
                  newPosition = swiper.minTranslate();
                }
                if (params.loop && params.centeredSlides) needsLoopFix = true;
              } else if (params.freeMode.sticky) {
                let nextSlide;
                for (let j = 0; j < snapGrid.length; j += 1) {
                  if (snapGrid[j] > -newPosition) {
                    nextSlide = j;
                    break;
                  }
                }
                if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
                  newPosition = snapGrid[nextSlide];
                } else {
                  newPosition = snapGrid[nextSlide - 1];
                }
                newPosition = -newPosition;
              }
              if (needsLoopFix) {
                once('transitionEnd', () => {
                  swiper.loopFix();
                });
              }
              // Fix duration
              if (swiper.velocity !== 0) {
                if (rtl) {
                  momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
                } else {
                  momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                }
                if (params.freeMode.sticky) {
                  // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
                  // event, then durations can be 20+ seconds to slide one (or zero!) slides.
                  // It's easy to see this when simulating touch with mouse events. To fix this,
                  // limit single-slide swipes to the default slide duration. This also has the
                  // nice side effect of matching slide speed if the user stopped moving before
                  // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
                  // For faster swipes, also apply limits (albeit higher ones).
                  const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                  const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                  if (moveDistance < currentSlideSize) {
                    momentumDuration = params.speed;
                  } else if (moveDistance < 2 * currentSlideSize) {
                    momentumDuration = params.speed * 1.5;
                  } else {
                    momentumDuration = params.speed * 2.5;
                  }
                }
              } else if (params.freeMode.sticky) {
                swiper.slideToClosest();
                return;
              }
              if (params.freeMode.momentumBounce && doBounce) {
                swiper.updateProgress(afterBouncePosition);
                swiper.setTransition(momentumDuration);
                swiper.setTranslate(newPosition);
                swiper.transitionStart(true, swiper.swipeDirection);
                swiper.animating = true;
                elementTransitionEnd(wrapperEl, () => {
                  if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
                  emit('momentumBounce');
                  swiper.setTransition(params.speed);
                  setTimeout(() => {
                    swiper.setTranslate(afterBouncePosition);
                    elementTransitionEnd(wrapperEl, () => {
                      if (!swiper || swiper.destroyed) return;
                      swiper.transitionEnd();
                    });
                  }, 0);
                });
              } else if (swiper.velocity) {
                emit('_freeModeNoMomentumRelease');
                swiper.updateProgress(newPosition);
                swiper.setTransition(momentumDuration);
                swiper.setTranslate(newPosition);
                swiper.transitionStart(true, swiper.swipeDirection);
                if (!swiper.animating) {
                  swiper.animating = true;
                  elementTransitionEnd(wrapperEl, () => {
                    if (!swiper || swiper.destroyed) return;
                    swiper.transitionEnd();
                  });
                }
              } else {
                swiper.updateProgress(newPosition);
              }
              swiper.updateActiveIndex();
              swiper.updateSlidesClasses();
            } else if (params.freeMode.sticky) {
              swiper.slideToClosest();
              return;
            } else if (params.freeMode) {
              emit('_freeModeNoMomentumRelease');
            }
            if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
              emit('_freeModeStaticRelease');
              swiper.updateProgress();
              swiper.updateActiveIndex();
              swiper.updateSlidesClasses();
            }
          }
          Object.assign(swiper, {
            freeMode: {
              onTouchStart,
              onTouchMove,
              onTouchEnd
            }
          });
        }
        function Grid({
          swiper,
          extendParams,
          on
        }) {
          extendParams({
            grid: {
              rows: 1,
              fill: 'column'
            }
          });
          let slidesNumberEvenToRows;
          let slidesPerRow;
          let numFullColumns;
          let wasMultiRow;
          const getSpaceBetween = () => {
            let spaceBetween = swiper.params.spaceBetween;
            if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
              spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
            } else if (typeof spaceBetween === 'string') {
              spaceBetween = parseFloat(spaceBetween);
            }
            return spaceBetween;
          };
          const initSlides = slides => {
            const {
              slidesPerView
            } = swiper.params;
            const {
              rows,
              fill
            } = swiper.params.grid;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
            numFullColumns = Math.floor(slidesLength / rows);
            if (Math.floor(slidesLength / rows) === slidesLength / rows) {
              slidesNumberEvenToRows = slidesLength;
            } else {
              slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
            }
            if (slidesPerView !== 'auto' && fill === 'row') {
              slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
            }
            slidesPerRow = slidesNumberEvenToRows / rows;
          };
          const unsetSlides = () => {
            if (swiper.slides) {
              swiper.slides.forEach(slide => {
                if (slide.swiperSlideGridSet) {
                  slide.style.height = '';
                  slide.style[swiper.getDirectionLabel('margin-top')] = '';
                }
              });
            }
          };
          const updateSlide = (i, slide, slides) => {
            const {
              slidesPerGroup
            } = swiper.params;
            const spaceBetween = getSpaceBetween();
            const {
              rows,
              fill
            } = swiper.params.grid;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
            // Set slides order
            let newSlideOrderIndex;
            let column;
            let row;
            if (fill === 'row' && slidesPerGroup > 1) {
              const groupIndex = Math.floor(i / (slidesPerGroup * rows));
              const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
              const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
              row = Math.floor(slideIndexInGroup / columnsInGroup);
              column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
              newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
              slide.style.order = newSlideOrderIndex;
            } else if (fill === 'column') {
              column = Math.floor(i / rows);
              row = i - column * rows;
              if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
                row += 1;
                if (row >= rows) {
                  row = 0;
                  column += 1;
                }
              }
            } else {
              row = Math.floor(i / slidesPerRow);
              column = i - row * slidesPerRow;
            }
            slide.row = row;
            slide.column = column;
            slide.style.height = `calc((100% - ${(rows - 1) * spaceBetween}px) / ${rows})`;
            slide.style[swiper.getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';
            slide.swiperSlideGridSet = true;
          };
          const updateWrapperSize = (slideSize, snapGrid) => {
            const {
              centeredSlides,
              roundLengths
            } = swiper.params;
            const spaceBetween = getSpaceBetween();
            const {
              rows
            } = swiper.params.grid;
            swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
            swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
            if (!swiper.params.cssMode) {
              swiper.wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
            }
            if (centeredSlides) {
              const newSlidesGrid = [];
              for (let i = 0; i < snapGrid.length; i += 1) {
                let slidesGridItem = snapGrid[i];
                if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
              }
              snapGrid.splice(0, snapGrid.length);
              snapGrid.push(...newSlidesGrid);
            }
          };
          const onInit = () => {
            wasMultiRow = swiper.params.grid && swiper.params.grid.rows > 1;
          };
          const onUpdate = () => {
            const {
              params,
              el
            } = swiper;
            const isMultiRow = params.grid && params.grid.rows > 1;
            if (wasMultiRow && !isMultiRow) {
              el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
              numFullColumns = 1;
              swiper.emitContainerClasses();
            } else if (!wasMultiRow && isMultiRow) {
              el.classList.add(`${params.containerModifierClass}grid`);
              if (params.grid.fill === 'column') {
                el.classList.add(`${params.containerModifierClass}grid-column`);
              }
              swiper.emitContainerClasses();
            }
            wasMultiRow = isMultiRow;
          };
          on('init', onInit);
          on('update', onUpdate);
          swiper.grid = {
            initSlides,
            unsetSlides,
            updateSlide,
            updateWrapperSize
          };
        }
        function appendSlide(slides) {
          const swiper = this;
          const {
            params,
            slidesEl
          } = swiper;
          if (params.loop) {
            swiper.loopDestroy();
          }
          const appendElement = slideEl => {
            if (typeof slideEl === 'string') {
              const tempDOM = document.createElement('div');
              setInnerHTML(tempDOM, slideEl);
              slidesEl.append(tempDOM.children[0]);
              setInnerHTML(tempDOM, '');
            } else {
              slidesEl.append(slideEl);
            }
          };
          if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
              if (slides[i]) appendElement(slides[i]);
            }
          } else {
            appendElement(slides);
          }
          swiper.recalcSlides();
          if (params.loop) {
            swiper.loopCreate();
          }
          if (!params.observer || swiper.isElement) {
            swiper.update();
          }
        }
        function prependSlide(slides) {
          const swiper = this;
          const {
            params,
            activeIndex,
            slidesEl
          } = swiper;
          if (params.loop) {
            swiper.loopDestroy();
          }
          let newActiveIndex = activeIndex + 1;
          const prependElement = slideEl => {
            if (typeof slideEl === 'string') {
              const tempDOM = document.createElement('div');
              setInnerHTML(tempDOM, slideEl);
              slidesEl.prepend(tempDOM.children[0]);
              setInnerHTML(tempDOM, '');
            } else {
              slidesEl.prepend(slideEl);
            }
          };
          if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
              if (slides[i]) prependElement(slides[i]);
            }
            newActiveIndex = activeIndex + slides.length;
          } else {
            prependElement(slides);
          }
          swiper.recalcSlides();
          if (params.loop) {
            swiper.loopCreate();
          }
          if (!params.observer || swiper.isElement) {
            swiper.update();
          }
          swiper.slideTo(newActiveIndex, 0, false);
        }
        function addSlide(index, slides) {
          const swiper = this;
          const {
            params,
            activeIndex,
            slidesEl
          } = swiper;
          let activeIndexBuffer = activeIndex;
          if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.recalcSlides();
          }
          const baseLength = swiper.slides.length;
          if (index <= 0) {
            swiper.prependSlide(slides);
            return;
          }
          if (index >= baseLength) {
            swiper.appendSlide(slides);
            return;
          }
          let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
          const slidesBuffer = [];
          for (let i = baseLength - 1; i >= index; i -= 1) {
            const currentSlide = swiper.slides[i];
            currentSlide.remove();
            slidesBuffer.unshift(currentSlide);
          }
          if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
              if (slides[i]) slidesEl.append(slides[i]);
            }
            newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
          } else {
            slidesEl.append(slides);
          }
          for (let i = 0; i < slidesBuffer.length; i += 1) {
            slidesEl.append(slidesBuffer[i]);
          }
          swiper.recalcSlides();
          if (params.loop) {
            swiper.loopCreate();
          }
          if (!params.observer || swiper.isElement) {
            swiper.update();
          }
          if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
          } else {
            swiper.slideTo(newActiveIndex, 0, false);
          }
        }
        function removeSlide(slidesIndexes) {
          const swiper = this;
          const {
            params,
            activeIndex
          } = swiper;
          let activeIndexBuffer = activeIndex;
          if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
          }
          let newActiveIndex = activeIndexBuffer;
          let indexToRemove;
          if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
            for (let i = 0; i < slidesIndexes.length; i += 1) {
              indexToRemove = slidesIndexes[i];
              if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
              if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
            }
            newActiveIndex = Math.max(newActiveIndex, 0);
          } else {
            indexToRemove = slidesIndexes;
            if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
            newActiveIndex = Math.max(newActiveIndex, 0);
          }
          swiper.recalcSlides();
          if (params.loop) {
            swiper.loopCreate();
          }
          if (!params.observer || swiper.isElement) {
            swiper.update();
          }
          if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
          } else {
            swiper.slideTo(newActiveIndex, 0, false);
          }
        }
        function removeAllSlides() {
          const swiper = this;
          const slidesIndexes = [];
          for (let i = 0; i < swiper.slides.length; i += 1) {
            slidesIndexes.push(i);
          }
          swiper.removeSlide(slidesIndexes);
        }
        function Manipulation({
          swiper
        }) {
          Object.assign(swiper, {
            appendSlide: appendSlide.bind(swiper),
            prependSlide: prependSlide.bind(swiper),
            addSlide: addSlide.bind(swiper),
            removeSlide: removeSlide.bind(swiper),
            removeAllSlides: removeAllSlides.bind(swiper)
          });
        }
        function effectInit(params) {
          const {
            effect,
            swiper,
            on,
            setTranslate,
            setTransition,
            overwriteParams,
            perspective,
            recreateShadows,
            getEffectParams
          } = params;
          on('beforeInit', () => {
            if (swiper.params.effect !== effect) return;
            swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
            if (perspective && perspective()) {
              swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
            }
            const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
            Object.assign(swiper.params, overwriteParamsResult);
            Object.assign(swiper.originalParams, overwriteParamsResult);
          });
          on('setTranslate _virtualUpdated', () => {
            if (swiper.params.effect !== effect) return;
            setTranslate();
          });
          on('setTransition', (_s, duration) => {
            if (swiper.params.effect !== effect) return;
            setTransition(duration);
          });
          on('transitionEnd', () => {
            if (swiper.params.effect !== effect) return;
            if (recreateShadows) {
              if (!getEffectParams || !getEffectParams().slideShadows) return;
              // remove shadows
              swiper.slides.forEach(slideEl => {
                slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());
              });
              // create new one
              recreateShadows();
            }
          });
          let requireUpdateOnVirtual;
          on('virtualUpdate', () => {
            if (swiper.params.effect !== effect) return;
            if (!swiper.slides.length) {
              requireUpdateOnVirtual = true;
            }
            requestAnimationFrame(() => {
              if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
                setTranslate();
                requireUpdateOnVirtual = false;
              }
            });
          });
        }
        function effectTarget(effectParams, slideEl) {
          const transformEl = getSlideTransformEl(slideEl);
          if (transformEl !== slideEl) {
            transformEl.style.backfaceVisibility = 'hidden';
            transformEl.style['-webkit-backface-visibility'] = 'hidden';
          }
          return transformEl;
        }
        function effectVirtualTransitionEnd({
          swiper,
          duration,
          transformElements,
          allSlides
        }) {
          const {
            activeIndex
          } = swiper;
          const getSlide = el => {
            if (!el.parentElement) {
              // assume shadow root
              const slide = swiper.slides.find(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode);
              return slide;
            }
            return el.parentElement;
          };
          if (swiper.params.virtualTranslate && duration !== 0) {
            let eventTriggered = false;
            let transitionEndTarget;
            if (allSlides) {
              transitionEndTarget = transformElements;
            } else {
              transitionEndTarget = transformElements.filter(transformEl => {
                const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;
                return swiper.getSlideIndex(el) === activeIndex;
              });
            }
            transitionEndTarget.forEach(el => {
              elementTransitionEnd(el, () => {
                if (eventTriggered) return;
                if (!swiper || swiper.destroyed) return;
                eventTriggered = true;
                swiper.animating = false;
                const evt = new window.CustomEvent('transitionend', {
                  bubbles: true,
                  cancelable: true
                });
                swiper.wrapperEl.dispatchEvent(evt);
              });
            });
          }
        }
        function EffectFade({
          swiper,
          extendParams,
          on
        }) {
          extendParams({
            fadeEffect: {
              crossFade: false
            }
          });
          const setTranslate = () => {
            const {
              slides
            } = swiper;
            const params = swiper.params.fadeEffect;
            for (let i = 0; i < slides.length; i += 1) {
              const slideEl = swiper.slides[i];
              const offset = slideEl.swiperSlideOffset;
              let tx = -offset;
              if (!swiper.params.virtualTranslate) tx -= swiper.translate;
              let ty = 0;
              if (!swiper.isHorizontal()) {
                ty = tx;
                tx = 0;
              }
              const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
              const targetEl = effectTarget(params, slideEl);
              targetEl.style.opacity = slideOpacity;
              targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
            }
          };
          const setTransition = duration => {
            const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
            transformElements.forEach(el => {
              el.style.transitionDuration = `${duration}ms`;
            });
            effectVirtualTransitionEnd({
              swiper,
              duration,
              transformElements,
              allSlides: true
            });
          };
          effectInit({
            effect: 'fade',
            swiper,
            on,
            setTranslate,
            setTransition,
            overwriteParams: () => ({
              slidesPerView: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: true,
              spaceBetween: 0,
              virtualTranslate: !swiper.params.cssMode
            })
          });
        }
        function EffectCube({
          swiper,
          extendParams,
          on
        }) {
          extendParams({
            cubeEffect: {
              slideShadows: true,
              shadow: true,
              shadowOffset: 20,
              shadowScale: 0.94
            }
          });
          const createSlideShadows = (slideEl, progress, isHorizontal) => {
            let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
            let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
            if (!shadowBefore) {
              shadowBefore = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));
              slideEl.append(shadowBefore);
            }
            if (!shadowAfter) {
              shadowAfter = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));
              slideEl.append(shadowAfter);
            }
            if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
            if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
          };
          const recreateShadows = () => {
            // create new ones
            const isHorizontal = swiper.isHorizontal();
            swiper.slides.forEach(slideEl => {
              const progress = Math.max(Math.min(slideEl.progress, 1), -1);
              createSlideShadows(slideEl, progress, isHorizontal);
            });
          };
          const setTranslate = () => {
            const {
              el,
              wrapperEl,
              slides,
              width: swiperWidth,
              height: swiperHeight,
              rtlTranslate: rtl,
              size: swiperSize,
              browser
            } = swiper;
            const r = getRotateFix(swiper);
            const params = swiper.params.cubeEffect;
            const isHorizontal = swiper.isHorizontal();
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let wrapperRotate = 0;
            let cubeShadowEl;
            if (params.shadow) {
              if (isHorizontal) {
                cubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');
                if (!cubeShadowEl) {
                  cubeShadowEl = createElement('div', 'swiper-cube-shadow');
                  swiper.wrapperEl.append(cubeShadowEl);
                }
                cubeShadowEl.style.height = `${swiperWidth}px`;
              } else {
                cubeShadowEl = el.querySelector('.swiper-cube-shadow');
                if (!cubeShadowEl) {
                  cubeShadowEl = createElement('div', 'swiper-cube-shadow');
                  el.append(cubeShadowEl);
                }
              }
            }
            for (let i = 0; i < slides.length; i += 1) {
              const slideEl = slides[i];
              let slideIndex = i;
              if (isVirtual) {
                slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);
              }
              let slideAngle = slideIndex * 90;
              let round = Math.floor(slideAngle / 360);
              if (rtl) {
                slideAngle = -slideAngle;
                round = Math.floor(-slideAngle / 360);
              }
              const progress = Math.max(Math.min(slideEl.progress, 1), -1);
              let tx = 0;
              let ty = 0;
              let tz = 0;
              if (slideIndex % 4 === 0) {
                tx = -round * 4 * swiperSize;
                tz = 0;
              } else if ((slideIndex - 1) % 4 === 0) {
                tx = 0;
                tz = -round * 4 * swiperSize;
              } else if ((slideIndex - 2) % 4 === 0) {
                tx = swiperSize + round * 4 * swiperSize;
                tz = swiperSize;
              } else if ((slideIndex - 3) % 4 === 0) {
                tx = -swiperSize;
                tz = 3 * swiperSize + swiperSize * 4 * round;
              }
              if (rtl) {
                tx = -tx;
              }
              if (!isHorizontal) {
                ty = tx;
                tx = 0;
              }
              const transform = `rotateX(${r(isHorizontal ? 0 : -slideAngle)}deg) rotateY(${r(isHorizontal ? slideAngle : 0)}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
              if (progress <= 1 && progress > -1) {
                wrapperRotate = slideIndex * 90 + progress * 90;
                if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
              }
              slideEl.style.transform = transform;
              if (params.slideShadows) {
                createSlideShadows(slideEl, progress, isHorizontal);
              }
            }
            wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;
            wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;
            if (params.shadow) {
              if (isHorizontal) {
                cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${params.shadowScale})`;
              } else {
                const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                const scale1 = params.shadowScale;
                const scale2 = params.shadowScale / multiplier;
                const offset = params.shadowOffset;
                cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-89.99deg)`;
              }
            }
            const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;
            wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${r(swiper.isHorizontal() ? 0 : wrapperRotate)}deg) rotateY(${r(swiper.isHorizontal() ? -wrapperRotate : 0)}deg)`;
            wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);
          };
          const setTransition = duration => {
            const {
              el,
              slides
            } = swiper;
            slides.forEach(slideEl => {
              slideEl.style.transitionDuration = `${duration}ms`;
              slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {
                subEl.style.transitionDuration = `${duration}ms`;
              });
            });
            if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
              const shadowEl = el.querySelector('.swiper-cube-shadow');
              if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;
            }
          };
          effectInit({
            effect: 'cube',
            swiper,
            on,
            setTranslate,
            setTransition,
            recreateShadows,
            getEffectParams: () => swiper.params.cubeEffect,
            perspective: () => true,
            overwriteParams: () => ({
              slidesPerView: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: true,
              resistanceRatio: 0,
              spaceBetween: 0,
              centeredSlides: false,
              virtualTranslate: true
            })
          });
        }
        function createShadow(suffix, slideEl, side) {
          const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}${suffix ? ` swiper-slide-shadow-${suffix}` : ''}`;
          const shadowContainer = getSlideTransformEl(slideEl);
          let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(' ').join('.')}`);
          if (!shadowEl) {
            shadowEl = createElement('div', shadowClass.split(' '));
            shadowContainer.append(shadowEl);
          }
          return shadowEl;
        }
        function EffectFlip({
          swiper,
          extendParams,
          on
        }) {
          extendParams({
            flipEffect: {
              slideShadows: true,
              limitRotation: true
            }
          });
          const createSlideShadows = (slideEl, progress) => {
            let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
            let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
            if (!shadowBefore) {
              shadowBefore = createShadow('flip', slideEl, swiper.isHorizontal() ? 'left' : 'top');
            }
            if (!shadowAfter) {
              shadowAfter = createShadow('flip', slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
            }
            if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
            if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
          };
          const recreateShadows = () => {
            // Set shadows
            swiper.params.flipEffect;
            swiper.slides.forEach(slideEl => {
              let progress = slideEl.progress;
              if (swiper.params.flipEffect.limitRotation) {
                progress = Math.max(Math.min(slideEl.progress, 1), -1);
              }
              createSlideShadows(slideEl, progress);
            });
          };
          const setTranslate = () => {
            const {
              slides,
              rtlTranslate: rtl
            } = swiper;
            const params = swiper.params.flipEffect;
            const rotateFix = getRotateFix(swiper);
            for (let i = 0; i < slides.length; i += 1) {
              const slideEl = slides[i];
              let progress = slideEl.progress;
              if (swiper.params.flipEffect.limitRotation) {
                progress = Math.max(Math.min(slideEl.progress, 1), -1);
              }
              const offset = slideEl.swiperSlideOffset;
              const rotate = -180 * progress;
              let rotateY = rotate;
              let rotateX = 0;
              let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
              let ty = 0;
              if (!swiper.isHorizontal()) {
                ty = tx;
                tx = 0;
                rotateX = -rotateY;
                rotateY = 0;
              } else if (rtl) {
                rotateY = -rotateY;
              }
              slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
              if (params.slideShadows) {
                createSlideShadows(slideEl, progress);
              }
              const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateFix(rotateX)}deg) rotateY(${rotateFix(rotateY)}deg)`;
              const targetEl = effectTarget(params, slideEl);
              targetEl.style.transform = transform;
            }
          };
          const setTransition = duration => {
            const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
            transformElements.forEach(el => {
              el.style.transitionDuration = `${duration}ms`;
              el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {
                shadowEl.style.transitionDuration = `${duration}ms`;
              });
            });
            effectVirtualTransitionEnd({
              swiper,
              duration,
              transformElements
            });
          };
          effectInit({
            effect: 'flip',
            swiper,
            on,
            setTranslate,
            setTransition,
            recreateShadows,
            getEffectParams: () => swiper.params.flipEffect,
            perspective: () => true,
            overwriteParams: () => ({
              slidesPerView: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: true,
              spaceBetween: 0,
              virtualTranslate: !swiper.params.cssMode
            })
          });
        }
        function EffectCoverflow({
          swiper,
          extendParams,
          on
        }) {
          extendParams({
            coverflowEffect: {
              rotate: 50,
              stretch: 0,
              depth: 100,
              scale: 1,
              modifier: 1,
              slideShadows: true
            }
          });
          const setTranslate = () => {
            const {
              width: swiperWidth,
              height: swiperHeight,
              slides,
              slidesSizesGrid
            } = swiper;
            const params = swiper.params.coverflowEffect;
            const isHorizontal = swiper.isHorizontal();
            const transform = swiper.translate;
            const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
            const rotate = isHorizontal ? params.rotate : -params.rotate;
            const translate = params.depth;
            const r = getRotateFix(swiper);
            // Each slide offset from center
            for (let i = 0, length = slides.length; i < length; i += 1) {
              const slideEl = slides[i];
              const slideSize = slidesSizesGrid[i];
              const slideOffset = slideEl.swiperSlideOffset;
              const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
              const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;
              let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
              let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
              // var rotateZ = 0
              let translateZ = -translate * Math.abs(offsetMultiplier);
              let stretch = params.stretch;
              // Allow percentage to make a relative stretch for responsive sliders
              if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
                stretch = parseFloat(params.stretch) / 100 * slideSize;
              }
              let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
              let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
              let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);

              // Fix for ultra small values
              if (Math.abs(translateX) < 0.001) translateX = 0;
              if (Math.abs(translateY) < 0.001) translateY = 0;
              if (Math.abs(translateZ) < 0.001) translateZ = 0;
              if (Math.abs(rotateY) < 0.001) rotateY = 0;
              if (Math.abs(rotateX) < 0.001) rotateX = 0;
              if (Math.abs(scale) < 0.001) scale = 0;
              const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${r(rotateX)}deg) rotateY(${r(rotateY)}deg) scale(${scale})`;
              const targetEl = effectTarget(params, slideEl);
              targetEl.style.transform = slideTransform;
              slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
              if (params.slideShadows) {
                // Set shadows
                let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
                let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
                if (!shadowBeforeEl) {
                  shadowBeforeEl = createShadow('coverflow', slideEl, isHorizontal ? 'left' : 'top');
                }
                if (!shadowAfterEl) {
                  shadowAfterEl = createShadow('coverflow', slideEl, isHorizontal ? 'right' : 'bottom');
                }
                if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
              }
            }
          };
          const setTransition = duration => {
            const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
            transformElements.forEach(el => {
              el.style.transitionDuration = `${duration}ms`;
              el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {
                shadowEl.style.transitionDuration = `${duration}ms`;
              });
            });
          };
          effectInit({
            effect: 'coverflow',
            swiper,
            on,
            setTranslate,
            setTransition,
            perspective: () => true,
            overwriteParams: () => ({
              watchSlidesProgress: true
            })
          });
        }
        function EffectCreative({
          swiper,
          extendParams,
          on
        }) {
          extendParams({
            creativeEffect: {
              limitProgress: 1,
              shadowPerProgress: false,
              progressMultiplier: 1,
              perspective: true,
              prev: {
                translate: [0, 0, 0],
                rotate: [0, 0, 0],
                opacity: 1,
                scale: 1
              },
              next: {
                translate: [0, 0, 0],
                rotate: [0, 0, 0],
                opacity: 1,
                scale: 1
              }
            }
          });
          const getTranslateValue = value => {
            if (typeof value === 'string') return value;
            return `${value}px`;
          };
          const setTranslate = () => {
            const {
              slides,
              wrapperEl,
              slidesSizesGrid
            } = swiper;
            const params = swiper.params.creativeEffect;
            const {
              progressMultiplier: multiplier
            } = params;
            const isCenteredSlides = swiper.params.centeredSlides;
            const rotateFix = getRotateFix(swiper);
            if (isCenteredSlides) {
              const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
              wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;
            }
            for (let i = 0; i < slides.length; i += 1) {
              const slideEl = slides[i];
              const slideProgress = slideEl.progress;
              const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);
              let originalProgress = progress;
              if (!isCenteredSlides) {
                originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);
              }
              const offset = slideEl.swiperSlideOffset;
              const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
              const r = [0, 0, 0];
              let custom = false;
              if (!swiper.isHorizontal()) {
                t[1] = t[0];
                t[0] = 0;
              }
              let data = {
                translate: [0, 0, 0],
                rotate: [0, 0, 0],
                scale: 1,
                opacity: 1
              };
              if (progress < 0) {
                data = params.next;
                custom = true;
              } else if (progress > 0) {
                data = params.prev;
                custom = true;
              }
              // set translate
              t.forEach((value, index) => {
                t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
              });
              // set rotates
              r.forEach((value, index) => {
                let val = data.rotate[index] * Math.abs(progress * multiplier);
                r[index] = val;
              });
              slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
              const translateString = t.join(', ');
              const rotateString = `rotateX(${rotateFix(r[0])}deg) rotateY(${rotateFix(r[1])}deg) rotateZ(${rotateFix(r[2])}deg)`;
              const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
              const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
              const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;

              // Set shadows
              if (custom && data.shadow || !custom) {
                let shadowEl = slideEl.querySelector('.swiper-slide-shadow');
                if (!shadowEl && data.shadow) {
                  shadowEl = createShadow('creative', slideEl);
                }
                if (shadowEl) {
                  const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
                  shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
                }
              }
              const targetEl = effectTarget(params, slideEl);
              targetEl.style.transform = transform;
              targetEl.style.opacity = opacityString;
              if (data.origin) {
                targetEl.style.transformOrigin = data.origin;
              }
            }
          };
          const setTransition = duration => {
            const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
            transformElements.forEach(el => {
              el.style.transitionDuration = `${duration}ms`;
              el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {
                shadowEl.style.transitionDuration = `${duration}ms`;
              });
            });
            effectVirtualTransitionEnd({
              swiper,
              duration,
              transformElements,
              allSlides: true
            });
          };
          effectInit({
            effect: 'creative',
            swiper,
            on,
            setTranslate,
            setTransition,
            perspective: () => swiper.params.creativeEffect.perspective,
            overwriteParams: () => ({
              watchSlidesProgress: true,
              virtualTranslate: !swiper.params.cssMode
            })
          });
        }
        function EffectCards({
          swiper,
          extendParams,
          on
        }) {
          extendParams({
            cardsEffect: {
              slideShadows: true,
              rotate: true,
              perSlideRotate: 2,
              perSlideOffset: 8
            }
          });
          const setTranslate = () => {
            const {
              slides,
              activeIndex,
              rtlTranslate: rtl
            } = swiper;
            const params = swiper.params.cardsEffect;
            const {
              startTranslate,
              isTouched
            } = swiper.touchEventsData;
            const currentTranslate = rtl ? -swiper.translate : swiper.translate;
            for (let i = 0; i < slides.length; i += 1) {
              const slideEl = slides[i];
              const slideProgress = slideEl.progress;
              const progress = Math.min(Math.max(slideProgress, -4), 4);
              let offset = slideEl.swiperSlideOffset;
              if (swiper.params.centeredSlides && !swiper.params.cssMode) {
                swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;
              }
              if (swiper.params.centeredSlides && swiper.params.cssMode) {
                offset -= slides[0].swiperSlideOffset;
              }
              let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
              let tY = 0;
              const tZ = -100 * Math.abs(progress);
              let scale = 1;
              let rotate = -params.perSlideRotate * progress;
              let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
              const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
              const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
              const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
              if (isSwipeToNext || isSwipeToPrev) {
                const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
                rotate += -28 * progress * subProgress;
                scale += -0.5 * subProgress;
                tXAdd += 96 * subProgress;
                tY = `${(params.rotate || swiper.isHorizontal() ? -25 : 0) * subProgress * Math.abs(progress)}%`;
              }
              if (progress < 0) {
                // next
                tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;
              } else if (progress > 0) {
                // prev
                tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;
              } else {
                tX = `${tX}px`;
              }
              if (!swiper.isHorizontal()) {
                const prevY = tY;
                tY = tX;
                tX = prevY;
              }
              const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;

              /* eslint-disable */
              const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)
        scale(${scaleString})
      `;
              /* eslint-enable */

              if (params.slideShadows) {
                // Set shadows
                let shadowEl = slideEl.querySelector('.swiper-slide-shadow');
                if (!shadowEl) {
                  shadowEl = createShadow('cards', slideEl);
                }
                if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
              }
              slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
              const targetEl = effectTarget(params, slideEl);
              targetEl.style.transform = transform;
            }
          };
          const setTransition = duration => {
            const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
            transformElements.forEach(el => {
              el.style.transitionDuration = `${duration}ms`;
              el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {
                shadowEl.style.transitionDuration = `${duration}ms`;
              });
            });
            effectVirtualTransitionEnd({
              swiper,
              duration,
              transformElements
            });
          };
          effectInit({
            effect: 'cards',
            swiper,
            on,
            setTranslate,
            setTransition,
            perspective: () => true,
            overwriteParams: () => ({
              _loopSwapReset: false,
              watchSlidesProgress: true,
              loopAdditionalSlides: swiper.params.cardsEffect.rotate ? 3 : 2,
              centeredSlides: true,
              virtualTranslate: !swiper.params.cssMode
            })
          });
        }

        /**
         * Swiper 12.0.2
         * Most modern mobile touch slider and framework with hardware accelerated transitions
         * https://swiperjs.com
         *
         * Copyright 2014-2025 Vladimir Kharlampidi
         *
         * Released under the MIT License
         *
         * Released on: September 18, 2025
         */

        // Swiper Class
        const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
        Swiper$1.use(modules);
        const formatValue = val => {
          if (parseFloat(val) === Number(val)) return Number(val);
          if (val === 'true') return true;
          if (val === '') return true;
          if (val === 'false') return false;
          if (val === 'null') return null;
          if (val === 'undefined') return undefined;
          if (typeof val === 'string' && val.includes('{') && val.includes('}') && val.includes('"')) {
            let v;
            try {
              v = JSON.parse(val);
            } catch (err) {
              v = val;
            }
            return v;
          }
          return val;
        };
        const modulesParamsList = ['a11y', 'autoplay', 'controller', 'cards-effect', 'coverflow-effect', 'creative-effect', 'cube-effect', 'fade-effect', 'flip-effect', 'free-mode', 'grid', 'hash-navigation', 'history', 'keyboard', 'mousewheel', 'navigation', 'pagination', 'parallax', 'scrollbar', 'thumbs', 'virtual', 'zoom'];
        function getParams(element, propName, propValue) {
          const params = {};
          const passedParams = {};
          extend(params, defaults);
          const localParamsList = [...paramsList, 'on'];
          const allowedParams = localParamsList.map(key => key.replace(/_/, ''));

          // First check props
          localParamsList.forEach(paramName => {
            paramName = paramName.replace('_', '');
            if (typeof element[paramName] !== 'undefined') {
              passedParams[paramName] = element[paramName];
            }
          });

          // Attributes
          const attrsList = [...element.attributes];
          if (typeof propName === 'string' && typeof propValue !== 'undefined') {
            attrsList.push({
              name: propName,
              value: isObject$1(propValue) ? {
                ...propValue
              } : propValue
            });
          }
          attrsList.forEach(attr => {
            const moduleParam = modulesParamsList.find(mParam => attr.name.startsWith(`${mParam}-`));
            if (moduleParam) {
              const parentObjName = attrToProp(moduleParam);
              const subObjName = attrToProp(attr.name.split(`${moduleParam}-`)[1]);
              if (typeof passedParams[parentObjName] === 'undefined') {
                passedParams[parentObjName] = {};
              }
              if (passedParams[parentObjName] === true) {
                passedParams[parentObjName] = {
                  enabled: true
                };
              }
              if (passedParams[parentObjName] === false) {
                passedParams[parentObjName] = {
                  enabled: false
                };
              }
              passedParams[parentObjName][subObjName] = formatValue(attr.value);
            } else {
              const name = attrToProp(attr.name);
              if (!allowedParams.includes(name)) return;
              const value = formatValue(attr.value);
              if (passedParams[name] && modulesParamsList.includes(attr.name) && !isObject$1(value)) {
                if (passedParams[name].constructor !== Object) {
                  passedParams[name] = {};
                }
                passedParams[name].enabled = !!value;
              } else {
                passedParams[name] = value;
              }
            }
          });
          extend(params, passedParams);
          if (params.navigation) {
            params.navigation = {
              prevEl: '.swiper-button-prev',
              nextEl: '.swiper-button-next',
              ...(params.navigation !== true ? params.navigation : {})
            };
          } else if (params.navigation === false) {
            delete params.navigation;
          }
          if (params.scrollbar) {
            params.scrollbar = {
              el: '.swiper-scrollbar',
              ...(params.scrollbar !== true ? params.scrollbar : {})
            };
          } else if (params.scrollbar === false) {
            delete params.scrollbar;
          }
          if (params.pagination) {
            params.pagination = {
              el: '.swiper-pagination',
              ...(params.pagination !== true ? params.pagination : {})
            };
          } else if (params.pagination === false) {
            delete params.pagination;
          }
          return {
            params,
            passedParams
          };
        }

        /**
         * Swiper Custom Element 12.0.2
         * Most modern mobile touch slider and framework with hardware accelerated transitions
         * https://swiperjs.com
         *
         * Copyright 2014-2025 Vladimir Kharlampidi
         *
         * Released under the MIT License
         *
         * Released on: September 18, 2025
         */

        /* eslint-disable spaced-comment */

        const SwiperCSS = `:host{--swiper-theme-color:#007aff}:host{display:block;margin-left:auto;margin-right:auto;position:relative;z-index:1}.swiper{display:block;height:100%;list-style:none;margin-left:auto;margin-right:auto;overflow:hidden;padding:0;position:relative;width:100%;z-index:1}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{box-sizing:initial;display:flex;height:100%;position:relative;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);width:100%;z-index:1}.swiper-android ::slotted(swiper-slide),.swiper-ios ::slotted(swiper-slide),.swiper-wrapper{transform:translateZ(0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}::slotted(swiper-slide){display:block;flex-shrink:0;height:100%;position:relative;transition-property:transform;width:100%}::slotted(.swiper-slide-invisible-blank){visibility:hidden}.swiper-autoheight,.swiper-autoheight ::slotted(swiper-slide){height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden ::slotted(swiper-slide){backface-visibility:hidden;transform:translateZ(0)}.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d ::slotted(swiper-slide){transform-style:preserve-3d}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode ::slotted(swiper-slide){scroll-snap-align:start start}.swiper-css-mode.swiper-horizontal>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-css-mode.swiper-vertical>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-css-mode.swiper-free-mode>.swiper-wrapper{scroll-snap-type:none}.swiper-css-mode.swiper-free-mode ::slotted(swiper-slide){scroll-snap-align:none}.swiper-css-mode.swiper-centered>.swiper-wrapper:before{content:"";flex-shrink:0;order:9999}.swiper-css-mode.swiper-centered ::slotted(swiper-slide){scroll-snap-align:center center;scroll-snap-stop:always}.swiper-css-mode.swiper-centered.swiper-horizontal ::slotted(swiper-slide):first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper:before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-css-mode.swiper-centered.swiper-vertical ::slotted(swiper-slide):first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper:before{height:var(--swiper-centered-offset-after);min-width:1px;width:100%}.swiper-virtual ::slotted(swiper-slide){-webkit-backface-visibility:hidden;transform:translateZ(0)}.swiper-virtual.swiper-css-mode .swiper-wrapper:after{content:"";left:0;pointer-events:none;position:absolute;top:0}.swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper:after{height:1px;width:var(--swiper-virtual-size)}.swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper:after{height:var(--swiper-virtual-size);width:1px}:host{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{align-items:center;color:var(--swiper-navigation-color,var(--swiper-theme-color));cursor:pointer;display:flex;height:var(--swiper-navigation-size);justify-content:center;position:absolute;width:var(--swiper-navigation-size);z-index:10}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{cursor:auto;opacity:.35;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{cursor:auto;opacity:0;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next svg,.swiper-button-prev svg{height:100%;object-fit:contain;transform-origin:center;width:100%;fill:currentColor;pointer-events:none}.swiper-button-lock{display:none}.swiper-button-next,.swiper-button-prev{margin-top:calc(0px - var(--swiper-navigation-size)/2);top:var(--swiper-navigation-top-offset,50%)}.swiper-button-prev{left:var(--swiper-navigation-sides-offset,4px);right:auto}.swiper-button-prev .swiper-navigation-icon{transform:rotate(180deg)}.swiper-button-next{left:auto;right:var(--swiper-navigation-sides-offset,4px)}.swiper-horizontal .swiper-button-next,.swiper-horizontal .swiper-button-prev,.swiper-horizontal~.swiper-button-next,.swiper-horizontal~.swiper-button-prev{margin-left:0;margin-top:calc(0px - var(--swiper-navigation-size)/2);top:var(--swiper-navigation-top-offset,50%)}.swiper-horizontal .swiper-button-prev,.swiper-horizontal.swiper-rtl .swiper-button-next,.swiper-horizontal.swiper-rtl~.swiper-button-next,.swiper-horizontal~.swiper-button-prev{left:var(--swiper-navigation-sides-offset,4px);right:auto}.swiper-horizontal .swiper-button-next,.swiper-horizontal.swiper-rtl .swiper-button-prev,.swiper-horizontal.swiper-rtl~.swiper-button-prev,.swiper-horizontal~.swiper-button-next{left:auto;right:var(--swiper-navigation-sides-offset,4px)}.swiper-horizontal .swiper-button-prev .swiper-navigation-icon,.swiper-horizontal.swiper-rtl .swiper-button-next .swiper-navigation-icon,.swiper-horizontal.swiper-rtl~.swiper-button-next .swiper-navigation-icon,.swiper-horizontal~.swiper-button-prev .swiper-navigation-icon{transform:rotate(180deg)}.swiper-horizontal.swiper-rtl .swiper-button-prev .swiper-navigation-icon,.swiper-horizontal.swiper-rtl~.swiper-button-prev .swiper-navigation-icon{transform:rotate(0deg)}.swiper-vertical .swiper-button-next,.swiper-vertical .swiper-button-prev,.swiper-vertical~.swiper-button-next,.swiper-vertical~.swiper-button-prev{left:var(--swiper-navigation-top-offset,50%);margin-left:calc(0px - var(--swiper-navigation-size)/2);margin-top:0;right:auto}.swiper-vertical .swiper-button-prev,.swiper-vertical~.swiper-button-prev{bottom:auto;top:var(--swiper-navigation-sides-offset,4px)}.swiper-vertical .swiper-button-prev .swiper-navigation-icon,.swiper-vertical~.swiper-button-prev .swiper-navigation-icon{transform:rotate(-90deg)}.swiper-vertical .swiper-button-next,.swiper-vertical~.swiper-button-next{bottom:var(--swiper-navigation-sides-offset,4px);top:auto}.swiper-vertical .swiper-button-next .swiper-navigation-icon,.swiper-vertical~.swiper-button-next .swiper-navigation-icon{transform:rotate(90deg)}.swiper-pagination{position:absolute;text-align:center;transform:translateZ(0);transition:opacity .3s;z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:var(--swiper-pagination-bottom,8px);left:0;top:var(--swiper-pagination-top,auto);width:100%}.swiper-pagination-bullets-dynamic{font-size:0;overflow:hidden}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{position:relative;transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active,.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{background:var(--swiper-pagination-bullet-inactive-color,#000);border-radius:var(--swiper-pagination-bullet-border-radius,50%);display:inline-block;height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));opacity:var(--swiper-pagination-bullet-inactive-opacity,.2);width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px))}button.swiper-pagination-bullet{appearance:none;border:none;box-shadow:none;margin:0;padding:0}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{background:var(--swiper-pagination-color,var(--swiper-theme-color));opacity:var(--swiper-pagination-bullet-opacity,1)}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{left:var(--swiper-pagination-left,auto);right:var(--swiper-pagination-right,8px);top:50%;transform:translate3d(0,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{display:block;margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:transform .2s,top .2s}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:transform .2s,left .2s}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:transform .2s,right .2s}.swiper-pagination-fraction{color:var(--swiper-pagination-fraction-color,inherit)}.swiper-pagination-progressbar{background:var(--swiper-pagination-progressbar-bg-color,#00000040);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));height:100%;left:0;position:absolute;top:0;transform:scale(0);transform-origin:left top;width:100%}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{height:var(--swiper-pagination-progressbar-size,4px);left:0;top:0;width:100%}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{height:100%;left:0;top:0;width:var(--swiper-pagination-progressbar-size,4px)}.swiper-pagination-lock{display:none}.swiper-scrollbar{background:var(--swiper-scrollbar-bg-color,#0000001a);border-radius:var(--swiper-scrollbar-border-radius,10px);position:relative;touch-action:none}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{bottom:var(--swiper-scrollbar-bottom,4px);height:var(--swiper-scrollbar-size,4px);left:var(--swiper-scrollbar-sides-offset,1%);position:absolute;top:var(--swiper-scrollbar-top,auto);width:calc(100% - var(--swiper-scrollbar-sides-offset, 1%)*2);z-index:50}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{height:calc(100% - var(--swiper-scrollbar-sides-offset, 1%)*2);left:var(--swiper-scrollbar-left,auto);position:absolute;right:var(--swiper-scrollbar-right,4px);top:var(--swiper-scrollbar-sides-offset,1%);width:var(--swiper-scrollbar-size,4px);z-index:50}.swiper-scrollbar-drag{background:var(--swiper-scrollbar-drag-bg-color,#00000080);border-radius:var(--swiper-scrollbar-border-radius,10px);height:100%;left:0;position:relative;top:0;width:100%}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}::slotted(.swiper-slide-zoomed){cursor:move;touch-action:none}.swiper .swiper-notification{left:0;opacity:0;pointer-events:none;position:absolute;top:0;z-index:-1000}.swiper-free-mode>.swiper-wrapper{margin:0 auto;transition-timing-function:ease-out}.swiper-grid>.swiper-wrapper{flex-wrap:wrap}.swiper-grid-column>.swiper-wrapper{flex-direction:column;flex-wrap:wrap}.swiper-fade.swiper-free-mode ::slotted(swiper-slide){transition-timing-function:ease-out}.swiper-fade ::slotted(swiper-slide){pointer-events:none;transition-property:opacity}.swiper-fade ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-fade ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-fade ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper.swiper-cube{overflow:visible}.swiper-cube ::slotted(swiper-slide){backface-visibility:hidden;height:100%;pointer-events:none;transform-origin:0 0;visibility:hidden;width:100%;z-index:1}.swiper-cube ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-cube.swiper-rtl ::slotted(swiper-slide){transform-origin:100% 0}.swiper-cube ::slotted(.swiper-slide-active),.swiper-cube ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-cube ::slotted(.swiper-slide-active),.swiper-cube ::slotted(.swiper-slide-next),.swiper-cube ::slotted(.swiper-slide-prev){pointer-events:auto;visibility:visible}.swiper-cube .swiper-cube-shadow{bottom:0;height:100%;left:0;opacity:.6;position:absolute;width:100%;z-index:0}.swiper-cube .swiper-cube-shadow:before{background:#000;bottom:0;content:"";filter:blur(50px);left:0;position:absolute;right:0;top:0}.swiper-cube ::slotted(.swiper-slide-next)+::slotted(swiper-slide){pointer-events:auto;visibility:visible}.swiper.swiper-flip{overflow:visible}.swiper-flip ::slotted(swiper-slide){backface-visibility:hidden;pointer-events:none;z-index:1}.swiper-flip ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-flip ::slotted(.swiper-slide-active),.swiper-flip ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-creative ::slotted(swiper-slide){backface-visibility:hidden;overflow:hidden;transition-property:transform,opacity,height}.swiper.swiper-cards{overflow:visible}.swiper-cards ::slotted(swiper-slide){backface-visibility:hidden;overflow:hidden;transform-origin:center bottom}`;
        const SwiperSlideCSS = `::slotted(.swiper-slide-shadow),::slotted(.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-top){height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%;z-index:10}::slotted(.swiper-slide-shadow){background:#00000026}::slotted(.swiper-slide-shadow-left){background-image:linear-gradient(270deg,#00000080,#0000)}::slotted(.swiper-slide-shadow-right){background-image:linear-gradient(90deg,#00000080,#0000)}::slotted(.swiper-slide-shadow-top){background-image:linear-gradient(0deg,#00000080,#0000)}::slotted(.swiper-slide-shadow-bottom){background-image:linear-gradient(180deg,#00000080,#0000)}.swiper-lazy-preloader{animation:swiper-preloader-spin 1s linear infinite;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top:4px solid #0000;box-sizing:border-box;height:42px;left:50%;margin-left:-21px;margin-top:-21px;position:absolute;top:50%;transform-origin:50%;width:42px;z-index:10}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-top){backface-visibility:hidden;z-index:0}::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-top){backface-visibility:hidden;z-index:0}::slotted(.swiper-zoom-container){align-items:center;display:flex;height:100%;justify-content:center;text-align:center;width:100%}::slotted(.swiper-zoom-container)>canvas,::slotted(.swiper-zoom-container)>img,::slotted(.swiper-zoom-container)>svg{max-height:100%;max-width:100%;object-fit:contain}`;
        class DummyHTMLElement {}
        const ClassToExtend = typeof window === 'undefined' || typeof HTMLElement === 'undefined' ? DummyHTMLElement : HTMLElement;
        const addStyle = (shadowRoot, styles) => {
          if (typeof CSSStyleSheet !== 'undefined' && shadowRoot.adoptedStyleSheets) {
            const styleSheet = new CSSStyleSheet();
            styleSheet.replaceSync(styles);
            shadowRoot.adoptedStyleSheets = [styleSheet];
          } else {
            const style = document.createElement('style');
            style.rel = 'stylesheet';
            style.textContent = styles;
            shadowRoot.appendChild(style);
          }
        };
        class SwiperContainer extends ClassToExtend {
          constructor() {
            super();
            this.attachShadow({
              mode: 'open'
            });
          }
          static get nextButtonSvg() {
            return arrowSvg;
          }
          static get prevButtonSvg() {
            return arrowSvg.replace('/></svg>', ' transform-origin="center" transform="rotate(180)"/></svg>');
          }
          cssStyles() {
            return [SwiperCSS,
            // eslint-disable-line
            ...(this.injectStyles && Array.isArray(this.injectStyles) ? this.injectStyles : [])].join('\n');
          }
          cssLinks() {
            return this.injectStylesUrls || [];
          }
          calcSlideSlots() {
            const currentSideSlots = this.slideSlots || 0;
            // slide slots
            const slideSlotChildren = [...this.querySelectorAll(`[slot^=slide-]`)].map(child => {
              return parseInt(child.getAttribute('slot').split('slide-')[1], 10);
            });
            this.slideSlots = slideSlotChildren.length ? Math.max(...slideSlotChildren) + 1 : 0;
            if (!this.rendered) return;
            if (this.slideSlots > currentSideSlots) {
              for (let i = currentSideSlots; i < this.slideSlots; i += 1) {
                const slideEl = document.createElement('swiper-slide');
                slideEl.setAttribute('part', `slide slide-${i + 1}`);
                const slotEl = document.createElement('slot');
                slotEl.setAttribute('name', `slide-${i + 1}`);
                slideEl.appendChild(slotEl);
                this.shadowRoot.querySelector('.swiper-wrapper').appendChild(slideEl);
              }
            } else if (this.slideSlots < currentSideSlots) {
              const slides = this.swiper.slides;
              for (let i = slides.length - 1; i >= 0; i -= 1) {
                if (i > this.slideSlots) {
                  slides[i].remove();
                }
              }
            }
          }
          render() {
            if (this.rendered) return;
            this.calcSlideSlots();

            // local styles
            let localStyles = this.cssStyles();
            if (this.slideSlots > 0) {
              localStyles = localStyles.replace(/::slotted\(([a-z-0-9.]*)\)/g, '$1');
            }
            if (localStyles.length) {
              addStyle(this.shadowRoot, localStyles);
            }
            this.cssLinks().forEach(url => {
              const linkExists = this.shadowRoot.querySelector(`link[href="${url}"]`);
              if (linkExists) return;
              const linkEl = document.createElement('link');
              linkEl.rel = 'stylesheet';
              linkEl.href = url;
              this.shadowRoot.appendChild(linkEl);
            });
            // prettier-ignore
            const el = document.createElement('div');
            el.classList.add('swiper');
            el.part = 'container';

            // prettier-ignore
            setInnerHTML(el, `
      <slot name="container-start"></slot>
      <div class="swiper-wrapper" part="wrapper">
        <slot></slot>
        ${Array.from({
              length: this.slideSlots
            }).map((_, index) => `
        <swiper-slide part="slide slide-${index}">
          <slot name="slide-${index}"></slot>
        </swiper-slide>
        `).join('')}
      </div>
      <slot name="container-end"></slot>
      ${needsNavigation(this.passedParams) ? `
        <div part="button-prev" class="swiper-button-prev"></div>
        <div part="button-next" class="swiper-button-next"></div>
      ` : ''}
      ${needsPagination(this.passedParams) ? `
        <div part="pagination" class="swiper-pagination"></div>
      ` : ''}
      ${needsScrollbar(this.passedParams) ? `
        <div part="scrollbar" class="swiper-scrollbar"></div>
      ` : ''}
    `);
            this.shadowRoot.appendChild(el);
            this.rendered = true;
          }
          initialize() {
            if (this.swiper && this.swiper.initialized) return;
            const {
              params: swiperParams,
              passedParams
            } = getParams(this);
            this.swiperParams = swiperParams;
            this.passedParams = passedParams;
            delete this.swiperParams.init;
            this.render();

            // eslint-disable-next-line
            this.swiper = new Swiper$1(this.shadowRoot.querySelector('.swiper'), {
              ...(swiperParams.virtual ? {} : {
                observer: true
              }),
              ...swiperParams,
              touchEventsTarget: 'container',
              onAny: (name, ...args) => {
                if (name === 'observerUpdate') {
                  this.calcSlideSlots();
                }
                const eventName = swiperParams.eventsPrefix ? `${swiperParams.eventsPrefix}${name.toLowerCase()}` : name.toLowerCase();
                const event = new CustomEvent(eventName, {
                  detail: args,
                  bubbles: name !== 'hashChange',
                  cancelable: true
                });
                this.dispatchEvent(event);
              }
            });
          }
          connectedCallback() {
            if (this.swiper && this.swiper.initialized && this.nested && this.closest('swiper-slide') && this.closest('swiper-slide').swiperLoopMoveDOM) {
              return;
            }
            if (this.init === false || this.getAttribute('init') === 'false') {
              return;
            }
            this.initialize();
          }
          disconnectedCallback() {
            if (this.nested && this.closest('swiper-slide') && this.closest('swiper-slide').swiperLoopMoveDOM) {
              return;
            }
            if (this.swiper && this.swiper.destroy) {
              this.swiper.destroy();
            }
          }
          updateSwiperOnPropChange(propName, propValue) {
            const {
              params: swiperParams,
              passedParams
            } = getParams(this, propName, propValue);
            this.passedParams = passedParams;
            this.swiperParams = swiperParams;
            if (this.swiper && this.swiper.params[propName] === propValue) {
              return;
            }
            updateSwiper({
              swiper: this.swiper,
              passedParams: this.passedParams,
              changedParams: [attrToProp(propName)],
              ...(propName === 'navigation' && passedParams[propName] ? {
                prevEl: '.swiper-button-prev',
                nextEl: '.swiper-button-next'
              } : {}),
              ...(propName === 'pagination' && passedParams[propName] ? {
                paginationEl: '.swiper-pagination'
              } : {}),
              ...(propName === 'scrollbar' && passedParams[propName] ? {
                scrollbarEl: '.swiper-scrollbar'
              } : {})
            });
          }
          attributeChangedCallback(attr, prevValue, newValue) {
            if (!(this.swiper && this.swiper.initialized)) return;
            if (prevValue === 'true' && newValue === null) {
              newValue = false;
            }
            this.updateSwiperOnPropChange(attr, newValue);
          }
          static get observedAttributes() {
            const attrs = paramsList.filter(param => param.includes('_')).map(param => param.replace(/[A-Z]/g, v => `-${v}`).replace('_', '').toLowerCase());
            return attrs;
          }
        }
        paramsList.forEach(paramName => {
          if (paramName === 'init') return;
          paramName = paramName.replace('_', '');
          Object.defineProperty(SwiperContainer.prototype, paramName, {
            configurable: true,
            get() {
              return (this.passedParams || {})[paramName];
            },
            set(value) {
              if (!this.passedParams) this.passedParams = {};
              this.passedParams[paramName] = value;
              if (!(this.swiper && this.swiper.initialized)) return;
              this.updateSwiperOnPropChange(paramName, value);
            }
          });
        });
        class SwiperSlide extends ClassToExtend {
          constructor() {
            super();
            this.attachShadow({
              mode: 'open'
            });
          }
          render() {
            const lazy = this.lazy || this.getAttribute('lazy') === '' || this.getAttribute('lazy') === 'true';
            addStyle(this.shadowRoot, SwiperSlideCSS);
            this.shadowRoot.appendChild(document.createElement('slot'));
            if (lazy) {
              const lazyDiv = document.createElement('div');
              lazyDiv.classList.add('swiper-lazy-preloader');
              lazyDiv.part.add('preloader');
              this.shadowRoot.appendChild(lazyDiv);
            }
          }
          initialize() {
            this.render();
          }
          connectedCallback() {
            if (this.swiperLoopMoveDOM) {
              return;
            }
            this.initialize();
          }
        }

        // eslint-disable-next-line
        const register = exports("af", () => {
          if (typeof window === 'undefined') return;
          if (!window.customElements.get('swiper-container')) window.customElements.define('swiper-container', SwiperContainer);
          if (!window.customElements.get('swiper-slide')) window.customElements.define('swiper-slide', SwiperSlide);
        });
        if (typeof window !== 'undefined') {
          window.SwiperElementRegisterParams = params => {
            paramsList.push(...params);
          };
        }

        /*!
         * Cropper.js v1.6.2
         * https://fengyuanchen.github.io/cropperjs
         *
         * Copyright 2015-present Chen Fengyuan
         * Released under the MIT license
         *
         * Date: 2024-04-21T07:43:05.335Z
         */
        function ownKeys$3(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r2) {
              return Object.getOwnPropertyDescriptor(e, r2).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread2(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$3(Object(t), true).forEach(function (r2) {
              _defineProperty$4(e, r2, t[r2]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r2) {
              Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
            });
          }
          return e;
        }
        function _toPrimitive(t, r) {
          if ("object" != typeof t || !t) return t;
          var e = t[Symbol.toPrimitive];
          if (void 0 !== e) {
            var i = e.call(t, r);
            if ("object" != typeof i) return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t);
        }
        function _toPropertyKey(t) {
          var i = _toPrimitive(t, "string");
          return "symbol" == typeof i ? i : i + "";
        }
        function _typeof$2(o) {
          "@babel/helpers - typeof";

          return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o2) {
            return typeof o2;
          } : function (o2) {
            return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, _typeof$2(o);
        }
        function _classCallCheck$1(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties$1(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
          }
        }
        function _createClass$1(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties$1(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", {
            writable: false
          });
          return Constructor;
        }
        function _defineProperty$4(obj, key, value) {
          key = _toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _toConsumableArray$1(arr) {
          return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread$1();
        }
        function _arrayWithoutHoles$1(arr) {
          if (Array.isArray(arr)) return _arrayLikeToArray(arr);
        }
        function _iterableToArray$1(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function _nonIterableSpread$1() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined";
        var WINDOW = IS_BROWSER ? window : {};
        var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? "ontouchstart" in WINDOW.document.documentElement : false;
        var HAS_POINTER_EVENT = IS_BROWSER ? "PointerEvent" in WINDOW : false;
        var NAMESPACE = "cropper";
        var ACTION_ALL = "all";
        var ACTION_CROP = "crop";
        var ACTION_MOVE = "move";
        var ACTION_ZOOM = "zoom";
        var ACTION_EAST = "e";
        var ACTION_WEST = "w";
        var ACTION_SOUTH = "s";
        var ACTION_NORTH = "n";
        var ACTION_NORTH_EAST = "ne";
        var ACTION_NORTH_WEST = "nw";
        var ACTION_SOUTH_EAST = "se";
        var ACTION_SOUTH_WEST = "sw";
        var CLASS_CROP = "".concat(NAMESPACE, "-crop");
        var CLASS_DISABLED = "".concat(NAMESPACE, "-disabled");
        var CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden");
        var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
        var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
        var CLASS_MODAL = "".concat(NAMESPACE, "-modal");
        var CLASS_MOVE = "".concat(NAMESPACE, "-move");
        var DATA_ACTION = "".concat(NAMESPACE, "Action");
        var DATA_PREVIEW = "".concat(NAMESPACE, "Preview");
        var DRAG_MODE_CROP = "crop";
        var DRAG_MODE_MOVE = "move";
        var DRAG_MODE_NONE = "none";
        var EVENT_CROP = "crop";
        var EVENT_CROP_END = "cropend";
        var EVENT_CROP_MOVE = "cropmove";
        var EVENT_CROP_START = "cropstart";
        var EVENT_DBLCLICK = "dblclick";
        var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? "touchstart" : "mousedown";
        var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? "touchmove" : "mousemove";
        var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? "touchend touchcancel" : "mouseup";
        var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? "pointerdown" : EVENT_TOUCH_START;
        var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? "pointermove" : EVENT_TOUCH_MOVE;
        var EVENT_POINTER_UP = HAS_POINTER_EVENT ? "pointerup pointercancel" : EVENT_TOUCH_END;
        var EVENT_READY = "ready";
        var EVENT_RESIZE = "resize";
        var EVENT_WHEEL = "wheel";
        var EVENT_ZOOM = "zoom";
        var MIME_TYPE_JPEG = "image/jpeg";
        var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;
        var REGEXP_DATA_URL = /^data:/;
        var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
        var REGEXP_TAG_NAME = /^img|canvas$/i;
        var MIN_CONTAINER_WIDTH = 200;
        var MIN_CONTAINER_HEIGHT = 100;
        var DEFAULTS = {
          // Define the view mode of the cropper
          viewMode: 0,
          // 0, 1, 2, 3
          // Define the dragging mode of the cropper
          dragMode: DRAG_MODE_CROP,
          // 'crop', 'move' or 'none'
          // Define the initial aspect ratio of the crop box
          initialAspectRatio: NaN,
          // Define the aspect ratio of the crop box
          aspectRatio: NaN,
          // An object with the previous cropping result data
          data: null,
          // A selector for adding extra containers to preview
          preview: "",
          // Re-render the cropper when resize the window
          responsive: true,
          // Restore the cropped area after resize the window
          restore: true,
          // Check if the current image is a cross-origin image
          checkCrossOrigin: true,
          // Check the current image's Exif Orientation information
          checkOrientation: true,
          // Show the black modal
          modal: true,
          // Show the dashed lines for guiding
          guides: true,
          // Show the center indicator for guiding
          center: true,
          // Show the white modal to highlight the crop box
          highlight: true,
          // Show the grid background
          background: true,
          // Enable to crop the image automatically when initialize
          autoCrop: true,
          // Define the percentage of automatic cropping area when initializes
          autoCropArea: 0.8,
          // Enable to move the image
          movable: true,
          // Enable to rotate the image
          rotatable: true,
          // Enable to scale the image
          scalable: true,
          // Enable to zoom the image
          zoomable: true,
          // Enable to zoom the image by dragging touch
          zoomOnTouch: true,
          // Enable to zoom the image by wheeling mouse
          zoomOnWheel: true,
          // Define zoom ratio when zoom the image by wheeling mouse
          wheelZoomRatio: 0.1,
          // Enable to move the crop box
          cropBoxMovable: true,
          // Enable to resize the crop box
          cropBoxResizable: true,
          // Toggle drag mode between "crop" and "move" when click twice on the cropper
          toggleDragModeOnDblclick: true,
          // Size limitation
          minCanvasWidth: 0,
          minCanvasHeight: 0,
          minCropBoxWidth: 0,
          minCropBoxHeight: 0,
          minContainerWidth: MIN_CONTAINER_WIDTH,
          minContainerHeight: MIN_CONTAINER_HEIGHT,
          // Shortcuts of events
          ready: null,
          cropstart: null,
          cropmove: null,
          cropend: null,
          crop: null,
          zoom: null
        };
        var TEMPLATE = '<div class="cropper-container" touch-action="none"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-cropper-action="e"></span><span class="cropper-line line-n" data-cropper-action="n"></span><span class="cropper-line line-w" data-cropper-action="w"></span><span class="cropper-line line-s" data-cropper-action="s"></span><span class="cropper-point point-e" data-cropper-action="e"></span><span class="cropper-point point-n" data-cropper-action="n"></span><span class="cropper-point point-w" data-cropper-action="w"></span><span class="cropper-point point-s" data-cropper-action="s"></span><span class="cropper-point point-ne" data-cropper-action="ne"></span><span class="cropper-point point-nw" data-cropper-action="nw"></span><span class="cropper-point point-sw" data-cropper-action="sw"></span><span class="cropper-point point-se" data-cropper-action="se"></span></div></div>';
        var isNaN$1 = Number.isNaN || WINDOW.isNaN;
        function isNumber(value) {
          return typeof value === "number" && !isNaN$1(value);
        }
        var isPositiveNumber = function isPositiveNumber2(value) {
          return value > 0 && value < Infinity;
        };
        function isUndefined(value) {
          return typeof value === "undefined";
        }
        function isObject(value) {
          return _typeof$2(value) === "object" && value !== null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function isPlainObject(value) {
          if (!isObject(value)) {
            return false;
          }
          try {
            var _constructor = value.constructor;
            var prototype = _constructor.prototype;
            return _constructor && prototype && hasOwnProperty.call(prototype, "isPrototypeOf");
          } catch (error) {
            return false;
          }
        }
        function isFunction(value) {
          return typeof value === "function";
        }
        var slice = Array.prototype.slice;
        function toArray(value) {
          return Array.from ? Array.from(value) : slice.call(value);
        }
        function forEach(data, callback) {
          if (data && isFunction(callback)) {
            if (Array.isArray(data) || isNumber(data.length)) {
              toArray(data).forEach(function (value, key) {
                callback.call(data, value, key, data);
              });
            } else if (isObject(data)) {
              Object.keys(data).forEach(function (key) {
                callback.call(data, data[key], key, data);
              });
            }
          }
          return data;
        }
        var assign = Object.assign || function assign2(target) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (isObject(target) && args.length > 0) {
            args.forEach(function (arg) {
              if (isObject(arg)) {
                Object.keys(arg).forEach(function (key) {
                  target[key] = arg[key];
                });
              }
            });
          }
          return target;
        };
        var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
        function normalizeDecimalNumber(value) {
          var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11;
          return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
        }
        var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;
        function setStyle(element, styles) {
          var style = element.style;
          forEach(styles, function (value, property) {
            if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
              value = "".concat(value, "px");
            }
            style[property] = value;
          });
        }
        function hasClass(element, value) {
          return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
        }
        function addClass(element, value) {
          if (!value) {
            return;
          }
          if (isNumber(element.length)) {
            forEach(element, function (elem) {
              addClass(elem, value);
            });
            return;
          }
          if (element.classList) {
            element.classList.add(value);
            return;
          }
          var className = element.className.trim();
          if (!className) {
            element.className = value;
          } else if (className.indexOf(value) < 0) {
            element.className = "".concat(className, " ").concat(value);
          }
        }
        function removeClass(element, value) {
          if (!value) {
            return;
          }
          if (isNumber(element.length)) {
            forEach(element, function (elem) {
              removeClass(elem, value);
            });
            return;
          }
          if (element.classList) {
            element.classList.remove(value);
            return;
          }
          if (element.className.indexOf(value) >= 0) {
            element.className = element.className.replace(value, "");
          }
        }
        function toggleClass(element, value, added) {
          if (!value) {
            return;
          }
          if (isNumber(element.length)) {
            forEach(element, function (elem) {
              toggleClass(elem, value, added);
            });
            return;
          }
          if (added) {
            addClass(element, value);
          } else {
            removeClass(element, value);
          }
        }
        var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g;
        function toParamCase(value) {
          return value.replace(REGEXP_CAMEL_CASE, "$1-$2").toLowerCase();
        }
        function getData(element, name) {
          if (isObject(element[name])) {
            return element[name];
          }
          if (element.dataset) {
            return element.dataset[name];
          }
          return element.getAttribute("data-".concat(toParamCase(name)));
        }
        function setData(element, name, data) {
          if (isObject(data)) {
            element[name] = data;
          } else if (element.dataset) {
            element.dataset[name] = data;
          } else {
            element.setAttribute("data-".concat(toParamCase(name)), data);
          }
        }
        function removeData(element, name) {
          if (isObject(element[name])) {
            try {
              delete element[name];
            } catch (error) {
              element[name] = void 0;
            }
          } else if (element.dataset) {
            try {
              delete element.dataset[name];
            } catch (error) {
              element.dataset[name] = void 0;
            }
          } else {
            element.removeAttribute("data-".concat(toParamCase(name)));
          }
        }
        var REGEXP_SPACES = /\s\s*/;
        var onceSupported = function () {
          var supported = false;
          if (IS_BROWSER) {
            var once = false;
            var listener = function listener2() {};
            var options = Object.defineProperty({}, "once", {
              get: function get() {
                supported = true;
                return once;
              },
              /**
               * This setter can fix a `TypeError` in strict mode
               * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
               * @param {boolean} value - The value to set
               */
              set: function set(value) {
                once = value;
              }
            });
            WINDOW.addEventListener("test", listener, options);
            WINDOW.removeEventListener("test", listener, options);
          }
          return supported;
        }();
        function removeListener(element, type, listener) {
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var handler = listener;
          type.trim().split(REGEXP_SPACES).forEach(function (event) {
            if (!onceSupported) {
              var listeners = element.listeners;
              if (listeners && listeners[event] && listeners[event][listener]) {
                handler = listeners[event][listener];
                delete listeners[event][listener];
                if (Object.keys(listeners[event]).length === 0) {
                  delete listeners[event];
                }
                if (Object.keys(listeners).length === 0) {
                  delete element.listeners;
                }
              }
            }
            element.removeEventListener(event, handler, options);
          });
        }
        function addListener(element, type, listener) {
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var _handler = listener;
          type.trim().split(REGEXP_SPACES).forEach(function (event) {
            if (options.once && !onceSupported) {
              var _element$listeners = element.listeners,
                listeners = _element$listeners === void 0 ? {} : _element$listeners;
              _handler = function handler() {
                delete listeners[event][listener];
                element.removeEventListener(event, _handler, options);
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                listener.apply(element, args);
              };
              if (!listeners[event]) {
                listeners[event] = {};
              }
              if (listeners[event][listener]) {
                element.removeEventListener(event, listeners[event][listener], options);
              }
              listeners[event][listener] = _handler;
              element.listeners = listeners;
            }
            element.addEventListener(event, _handler, options);
          });
        }
        function dispatchEvent(element, type, data) {
          var event;
          if (isFunction(Event) && isFunction(CustomEvent)) {
            event = new CustomEvent(type, {
              detail: data,
              bubbles: true,
              cancelable: true
            });
          } else {
            event = document.createEvent("CustomEvent");
            event.initCustomEvent(type, true, true, data);
          }
          return element.dispatchEvent(event);
        }
        function getOffset(element) {
          var box = element.getBoundingClientRect();
          return {
            left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
            top: box.top + (window.pageYOffset - document.documentElement.clientTop)
          };
        }
        var location = WINDOW.location;
        var REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
        function isCrossOriginURL(url) {
          var parts = url.match(REGEXP_ORIGINS);
          return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
        }
        function addTimestamp(url) {
          var timestamp = "timestamp=".concat((/* @__PURE__ */new Date()).getTime());
          return url + (url.indexOf("?") === -1 ? "?" : "&") + timestamp;
        }
        function getTransforms(_ref) {
          var rotate2 = _ref.rotate,
            scaleX2 = _ref.scaleX,
            scaleY2 = _ref.scaleY,
            translateX = _ref.translateX,
            translateY = _ref.translateY;
          var values = [];
          if (isNumber(translateX) && translateX !== 0) {
            values.push("translateX(".concat(translateX, "px)"));
          }
          if (isNumber(translateY) && translateY !== 0) {
            values.push("translateY(".concat(translateY, "px)"));
          }
          if (isNumber(rotate2) && rotate2 !== 0) {
            values.push("rotate(".concat(rotate2, "deg)"));
          }
          if (isNumber(scaleX2) && scaleX2 !== 1) {
            values.push("scaleX(".concat(scaleX2, ")"));
          }
          if (isNumber(scaleY2) && scaleY2 !== 1) {
            values.push("scaleY(".concat(scaleY2, ")"));
          }
          var transform = values.length ? values.join(" ") : "none";
          return {
            WebkitTransform: transform,
            msTransform: transform,
            transform
          };
        }
        function getMaxZoomRatio(pointers) {
          var pointers2 = _objectSpread2({}, pointers);
          var maxRatio = 0;
          forEach(pointers, function (pointer, pointerId) {
            delete pointers2[pointerId];
            forEach(pointers2, function (pointer2) {
              var x1 = Math.abs(pointer.startX - pointer2.startX);
              var y1 = Math.abs(pointer.startY - pointer2.startY);
              var x2 = Math.abs(pointer.endX - pointer2.endX);
              var y2 = Math.abs(pointer.endY - pointer2.endY);
              var z1 = Math.sqrt(x1 * x1 + y1 * y1);
              var z2 = Math.sqrt(x2 * x2 + y2 * y2);
              var ratio = (z2 - z1) / z1;
              if (Math.abs(ratio) > Math.abs(maxRatio)) {
                maxRatio = ratio;
              }
            });
          });
          return maxRatio;
        }
        function getPointer(_ref2, endOnly) {
          var pageX = _ref2.pageX,
            pageY = _ref2.pageY;
          var end = {
            endX: pageX,
            endY: pageY
          };
          return endOnly ? end : _objectSpread2({
            startX: pageX,
            startY: pageY
          }, end);
        }
        function getPointersCenter(pointers) {
          var pageX = 0;
          var pageY = 0;
          var count = 0;
          forEach(pointers, function (_ref3) {
            var startX = _ref3.startX,
              startY = _ref3.startY;
            pageX += startX;
            pageY += startY;
            count += 1;
          });
          pageX /= count;
          pageY /= count;
          return {
            pageX,
            pageY
          };
        }
        function getAdjustedSizes(_ref4) {
          var aspectRatio = _ref4.aspectRatio,
            height = _ref4.height,
            width = _ref4.width;
          var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "contain";
          var isValidWidth = isPositiveNumber(width);
          var isValidHeight = isPositiveNumber(height);
          if (isValidWidth && isValidHeight) {
            var adjustedWidth = height * aspectRatio;
            if (type === "contain" && adjustedWidth > width || type === "cover" && adjustedWidth < width) {
              height = width / aspectRatio;
            } else {
              width = height * aspectRatio;
            }
          } else if (isValidWidth) {
            height = width / aspectRatio;
          } else if (isValidHeight) {
            width = height * aspectRatio;
          }
          return {
            width,
            height
          };
        }
        function getRotatedSizes(_ref5) {
          var width = _ref5.width,
            height = _ref5.height,
            degree = _ref5.degree;
          degree = Math.abs(degree) % 180;
          if (degree === 90) {
            return {
              width: height,
              height: width
            };
          }
          var arc = degree % 90 * Math.PI / 180;
          var sinArc = Math.sin(arc);
          var cosArc = Math.cos(arc);
          var newWidth = width * cosArc + height * sinArc;
          var newHeight = width * sinArc + height * cosArc;
          return degree > 90 ? {
            width: newHeight,
            height: newWidth
          } : {
            width: newWidth,
            height: newHeight
          };
        }
        function getSourceCanvas(image, _ref6, _ref7, _ref8) {
          var imageAspectRatio = _ref6.aspectRatio,
            imageNaturalWidth = _ref6.naturalWidth,
            imageNaturalHeight = _ref6.naturalHeight,
            _ref6$rotate = _ref6.rotate,
            rotate2 = _ref6$rotate === void 0 ? 0 : _ref6$rotate,
            _ref6$scaleX = _ref6.scaleX,
            scaleX2 = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX,
            _ref6$scaleY = _ref6.scaleY,
            scaleY2 = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;
          var aspectRatio = _ref7.aspectRatio,
            naturalWidth = _ref7.naturalWidth,
            naturalHeight = _ref7.naturalHeight;
          var _ref8$fillColor = _ref8.fillColor,
            fillColor = _ref8$fillColor === void 0 ? "transparent" : _ref8$fillColor,
            _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,
            imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE,
            _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,
            imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? "low" : _ref8$imageSmoothingQ,
            _ref8$maxWidth = _ref8.maxWidth,
            maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth,
            _ref8$maxHeight = _ref8.maxHeight,
            maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight,
            _ref8$minWidth = _ref8.minWidth,
            minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth,
            _ref8$minHeight = _ref8.minHeight,
            minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;
          var canvas = document.createElement("canvas");
          var context = canvas.getContext("2d");
          var maxSizes = getAdjustedSizes({
            aspectRatio,
            width: maxWidth,
            height: maxHeight
          });
          var minSizes = getAdjustedSizes({
            aspectRatio,
            width: minWidth,
            height: minHeight
          }, "cover");
          var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
          var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight));
          var destMaxSizes = getAdjustedSizes({
            aspectRatio: imageAspectRatio,
            width: maxWidth,
            height: maxHeight
          });
          var destMinSizes = getAdjustedSizes({
            aspectRatio: imageAspectRatio,
            width: minWidth,
            height: minHeight
          }, "cover");
          var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));
          var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));
          var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];
          canvas.width = normalizeDecimalNumber(width);
          canvas.height = normalizeDecimalNumber(height);
          context.fillStyle = fillColor;
          context.fillRect(0, 0, width, height);
          context.save();
          context.translate(width / 2, height / 2);
          context.rotate(rotate2 * Math.PI / 180);
          context.scale(scaleX2, scaleY2);
          context.imageSmoothingEnabled = imageSmoothingEnabled;
          context.imageSmoothingQuality = imageSmoothingQuality;
          context.drawImage.apply(context, [image].concat(_toConsumableArray$1(params.map(function (param) {
            return Math.floor(normalizeDecimalNumber(param));
          }))));
          context.restore();
          return canvas;
        }
        var fromCharCode = String.fromCharCode;
        function getStringFromCharCode(dataView, start, length) {
          var str = "";
          length += start;
          for (var i = start; i < length; i += 1) {
            str += fromCharCode(dataView.getUint8(i));
          }
          return str;
        }
        var REGEXP_DATA_URL_HEAD = /^data:.*,/;
        function dataURLToArrayBuffer(dataURL) {
          var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, "");
          var binary = atob(base64);
          var arrayBuffer = new ArrayBuffer(binary.length);
          var uint8 = new Uint8Array(arrayBuffer);
          forEach(uint8, function (value, i) {
            uint8[i] = binary.charCodeAt(i);
          });
          return arrayBuffer;
        }
        function arrayBufferToDataURL(arrayBuffer, mimeType) {
          var chunks = [];
          var chunkSize = 8192;
          var uint8 = new Uint8Array(arrayBuffer);
          while (uint8.length > 0) {
            chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));
            uint8 = uint8.subarray(chunkSize);
          }
          return "data:".concat(mimeType, ";base64,").concat(btoa(chunks.join("")));
        }
        function resetAndGetOrientation(arrayBuffer) {
          var dataView = new DataView(arrayBuffer);
          var orientation;
          try {
            var littleEndian;
            var app1Start;
            var ifdStart;
            if (dataView.getUint8(0) === 255 && dataView.getUint8(1) === 216) {
              var length = dataView.byteLength;
              var offset = 2;
              while (offset + 1 < length) {
                if (dataView.getUint8(offset) === 255 && dataView.getUint8(offset + 1) === 225) {
                  app1Start = offset;
                  break;
                }
                offset += 1;
              }
            }
            if (app1Start) {
              var exifIDCode = app1Start + 4;
              var tiffOffset = app1Start + 10;
              if (getStringFromCharCode(dataView, exifIDCode, 4) === "Exif") {
                var endianness = dataView.getUint16(tiffOffset);
                littleEndian = endianness === 18761;
                if (littleEndian || endianness === 19789) {
                  if (dataView.getUint16(tiffOffset + 2, littleEndian) === 42) {
                    var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
                    if (firstIFDOffset >= 8) {
                      ifdStart = tiffOffset + firstIFDOffset;
                    }
                  }
                }
              }
            }
            if (ifdStart) {
              var _length = dataView.getUint16(ifdStart, littleEndian);
              var _offset;
              var i;
              for (i = 0; i < _length; i += 1) {
                _offset = ifdStart + i * 12 + 2;
                if (dataView.getUint16(_offset, littleEndian) === 274) {
                  _offset += 8;
                  orientation = dataView.getUint16(_offset, littleEndian);
                  dataView.setUint16(_offset, 1, littleEndian);
                  break;
                }
              }
            }
          } catch (error) {
            orientation = 1;
          }
          return orientation;
        }
        function parseOrientation(orientation) {
          var rotate2 = 0;
          var scaleX2 = 1;
          var scaleY2 = 1;
          switch (orientation) {
            // Flip horizontal
            case 2:
              scaleX2 = -1;
              break;
            // Rotate left 180
            case 3:
              rotate2 = -180;
              break;
            // Flip vertical
            case 4:
              scaleY2 = -1;
              break;
            // Flip vertical and rotate right 90
            case 5:
              rotate2 = 90;
              scaleY2 = -1;
              break;
            // Rotate right 90
            case 6:
              rotate2 = 90;
              break;
            // Flip horizontal and rotate right 90
            case 7:
              rotate2 = 90;
              scaleX2 = -1;
              break;
            // Rotate left 90
            case 8:
              rotate2 = -90;
              break;
          }
          return {
            rotate: rotate2,
            scaleX: scaleX2,
            scaleY: scaleY2
          };
        }
        var render = {
          render: function render2() {
            this.initContainer();
            this.initCanvas();
            this.initCropBox();
            this.renderCanvas();
            if (this.cropped) {
              this.renderCropBox();
            }
          },
          initContainer: function initContainer() {
            var element = this.element,
              options = this.options,
              container = this.container,
              cropper = this.cropper;
            var minWidth = Number(options.minContainerWidth);
            var minHeight = Number(options.minContainerHeight);
            addClass(cropper, CLASS_HIDDEN);
            removeClass(element, CLASS_HIDDEN);
            var containerData = {
              width: Math.max(container.offsetWidth, minWidth >= 0 ? minWidth : MIN_CONTAINER_WIDTH),
              height: Math.max(container.offsetHeight, minHeight >= 0 ? minHeight : MIN_CONTAINER_HEIGHT)
            };
            this.containerData = containerData;
            setStyle(cropper, {
              width: containerData.width,
              height: containerData.height
            });
            addClass(element, CLASS_HIDDEN);
            removeClass(cropper, CLASS_HIDDEN);
          },
          // Canvas (image wrapper)
          initCanvas: function initCanvas() {
            var containerData = this.containerData,
              imageData = this.imageData;
            var viewMode = this.options.viewMode;
            var rotated = Math.abs(imageData.rotate) % 180 === 90;
            var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
            var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
            var aspectRatio = naturalWidth / naturalHeight;
            var canvasWidth = containerData.width;
            var canvasHeight = containerData.height;
            if (containerData.height * aspectRatio > containerData.width) {
              if (viewMode === 3) {
                canvasWidth = containerData.height * aspectRatio;
              } else {
                canvasHeight = containerData.width / aspectRatio;
              }
            } else if (viewMode === 3) {
              canvasHeight = containerData.width / aspectRatio;
            } else {
              canvasWidth = containerData.height * aspectRatio;
            }
            var canvasData = {
              aspectRatio,
              naturalWidth,
              naturalHeight,
              width: canvasWidth,
              height: canvasHeight
            };
            this.canvasData = canvasData;
            this.limited = viewMode === 1 || viewMode === 2;
            this.limitCanvas(true, true);
            canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
            canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
            canvasData.left = (containerData.width - canvasData.width) / 2;
            canvasData.top = (containerData.height - canvasData.height) / 2;
            canvasData.oldLeft = canvasData.left;
            canvasData.oldTop = canvasData.top;
            this.initialCanvasData = assign({}, canvasData);
          },
          limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
            var options = this.options,
              containerData = this.containerData,
              canvasData = this.canvasData,
              cropBoxData = this.cropBoxData;
            var viewMode = options.viewMode;
            var aspectRatio = canvasData.aspectRatio;
            var cropped = this.cropped && cropBoxData;
            if (sizeLimited) {
              var minCanvasWidth = Number(options.minCanvasWidth) || 0;
              var minCanvasHeight = Number(options.minCanvasHeight) || 0;
              if (viewMode > 1) {
                minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
                minCanvasHeight = Math.max(minCanvasHeight, containerData.height);
                if (viewMode === 3) {
                  if (minCanvasHeight * aspectRatio > minCanvasWidth) {
                    minCanvasWidth = minCanvasHeight * aspectRatio;
                  } else {
                    minCanvasHeight = minCanvasWidth / aspectRatio;
                  }
                }
              } else if (viewMode > 0) {
                if (minCanvasWidth) {
                  minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
                } else if (minCanvasHeight) {
                  minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
                } else if (cropped) {
                  minCanvasWidth = cropBoxData.width;
                  minCanvasHeight = cropBoxData.height;
                  if (minCanvasHeight * aspectRatio > minCanvasWidth) {
                    minCanvasWidth = minCanvasHeight * aspectRatio;
                  } else {
                    minCanvasHeight = minCanvasWidth / aspectRatio;
                  }
                }
              }
              var _getAdjustedSizes = getAdjustedSizes({
                aspectRatio,
                width: minCanvasWidth,
                height: minCanvasHeight
              });
              minCanvasWidth = _getAdjustedSizes.width;
              minCanvasHeight = _getAdjustedSizes.height;
              canvasData.minWidth = minCanvasWidth;
              canvasData.minHeight = minCanvasHeight;
              canvasData.maxWidth = Infinity;
              canvasData.maxHeight = Infinity;
            }
            if (positionLimited) {
              if (viewMode > (cropped ? 0 : 1)) {
                var newCanvasLeft = containerData.width - canvasData.width;
                var newCanvasTop = containerData.height - canvasData.height;
                canvasData.minLeft = Math.min(0, newCanvasLeft);
                canvasData.minTop = Math.min(0, newCanvasTop);
                canvasData.maxLeft = Math.max(0, newCanvasLeft);
                canvasData.maxTop = Math.max(0, newCanvasTop);
                if (cropped && this.limited) {
                  canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
                  canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
                  canvasData.maxLeft = cropBoxData.left;
                  canvasData.maxTop = cropBoxData.top;
                  if (viewMode === 2) {
                    if (canvasData.width >= containerData.width) {
                      canvasData.minLeft = Math.min(0, newCanvasLeft);
                      canvasData.maxLeft = Math.max(0, newCanvasLeft);
                    }
                    if (canvasData.height >= containerData.height) {
                      canvasData.minTop = Math.min(0, newCanvasTop);
                      canvasData.maxTop = Math.max(0, newCanvasTop);
                    }
                  }
                }
              } else {
                canvasData.minLeft = -canvasData.width;
                canvasData.minTop = -canvasData.height;
                canvasData.maxLeft = containerData.width;
                canvasData.maxTop = containerData.height;
              }
            }
          },
          renderCanvas: function renderCanvas(changed, transformed) {
            var canvasData = this.canvasData,
              imageData = this.imageData;
            if (transformed) {
              var _getRotatedSizes = getRotatedSizes({
                  width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),
                  height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),
                  degree: imageData.rotate || 0
                }),
                naturalWidth = _getRotatedSizes.width,
                naturalHeight = _getRotatedSizes.height;
              var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);
              var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);
              canvasData.left -= (width - canvasData.width) / 2;
              canvasData.top -= (height - canvasData.height) / 2;
              canvasData.width = width;
              canvasData.height = height;
              canvasData.aspectRatio = naturalWidth / naturalHeight;
              canvasData.naturalWidth = naturalWidth;
              canvasData.naturalHeight = naturalHeight;
              this.limitCanvas(true, false);
            }
            if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
              canvasData.left = canvasData.oldLeft;
            }
            if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
              canvasData.top = canvasData.oldTop;
            }
            canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
            canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
            this.limitCanvas(false, true);
            canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
            canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
            canvasData.oldLeft = canvasData.left;
            canvasData.oldTop = canvasData.top;
            setStyle(this.canvas, assign({
              width: canvasData.width,
              height: canvasData.height
            }, getTransforms({
              translateX: canvasData.left,
              translateY: canvasData.top
            })));
            this.renderImage(changed);
            if (this.cropped && this.limited) {
              this.limitCropBox(true, true);
            }
          },
          renderImage: function renderImage(changed) {
            var canvasData = this.canvasData,
              imageData = this.imageData;
            var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);
            var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);
            assign(imageData, {
              width,
              height,
              left: (canvasData.width - width) / 2,
              top: (canvasData.height - height) / 2
            });
            setStyle(this.image, assign({
              width: imageData.width,
              height: imageData.height
            }, getTransforms(assign({
              translateX: imageData.left,
              translateY: imageData.top
            }, imageData))));
            if (changed) {
              this.output();
            }
          },
          initCropBox: function initCropBox() {
            var options = this.options,
              canvasData = this.canvasData;
            var aspectRatio = options.aspectRatio || options.initialAspectRatio;
            var autoCropArea = Number(options.autoCropArea) || 0.8;
            var cropBoxData = {
              width: canvasData.width,
              height: canvasData.height
            };
            if (aspectRatio) {
              if (canvasData.height * aspectRatio > canvasData.width) {
                cropBoxData.height = cropBoxData.width / aspectRatio;
              } else {
                cropBoxData.width = cropBoxData.height * aspectRatio;
              }
            }
            this.cropBoxData = cropBoxData;
            this.limitCropBox(true, true);
            cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
            cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
            cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
            cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
            cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
            cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
            cropBoxData.oldLeft = cropBoxData.left;
            cropBoxData.oldTop = cropBoxData.top;
            this.initialCropBoxData = assign({}, cropBoxData);
          },
          limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
            var options = this.options,
              containerData = this.containerData,
              canvasData = this.canvasData,
              cropBoxData = this.cropBoxData,
              limited = this.limited;
            var aspectRatio = options.aspectRatio;
            if (sizeLimited) {
              var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
              var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
              var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;
              var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height;
              minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
              minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);
              if (aspectRatio) {
                if (minCropBoxWidth && minCropBoxHeight) {
                  if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
                    minCropBoxHeight = minCropBoxWidth / aspectRatio;
                  } else {
                    minCropBoxWidth = minCropBoxHeight * aspectRatio;
                  }
                } else if (minCropBoxWidth) {
                  minCropBoxHeight = minCropBoxWidth / aspectRatio;
                } else if (minCropBoxHeight) {
                  minCropBoxWidth = minCropBoxHeight * aspectRatio;
                }
                if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
                  maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
                } else {
                  maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
                }
              }
              cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
              cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
              cropBoxData.maxWidth = maxCropBoxWidth;
              cropBoxData.maxHeight = maxCropBoxHeight;
            }
            if (positionLimited) {
              if (limited) {
                cropBoxData.minLeft = Math.max(0, canvasData.left);
                cropBoxData.minTop = Math.max(0, canvasData.top);
                cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
                cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
              } else {
                cropBoxData.minLeft = 0;
                cropBoxData.minTop = 0;
                cropBoxData.maxLeft = containerData.width - cropBoxData.width;
                cropBoxData.maxTop = containerData.height - cropBoxData.height;
              }
            }
          },
          renderCropBox: function renderCropBox() {
            var options = this.options,
              containerData = this.containerData,
              cropBoxData = this.cropBoxData;
            if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
              cropBoxData.left = cropBoxData.oldLeft;
            }
            if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
              cropBoxData.top = cropBoxData.oldTop;
            }
            cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
            cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
            this.limitCropBox(false, true);
            cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
            cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
            cropBoxData.oldLeft = cropBoxData.left;
            cropBoxData.oldTop = cropBoxData.top;
            if (options.movable && options.cropBoxMovable) {
              setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);
            }
            setStyle(this.cropBox, assign({
              width: cropBoxData.width,
              height: cropBoxData.height
            }, getTransforms({
              translateX: cropBoxData.left,
              translateY: cropBoxData.top
            })));
            if (this.cropped && this.limited) {
              this.limitCanvas(true, true);
            }
            if (!this.disabled) {
              this.output();
            }
          },
          output: function output() {
            this.preview();
            dispatchEvent(this.element, EVENT_CROP, this.getData());
          }
        };
        var preview = {
          initPreview: function initPreview() {
            var element = this.element,
              crossOrigin = this.crossOrigin;
            var preview3 = this.options.preview;
            var url = crossOrigin ? this.crossOriginUrl : this.url;
            var alt = element.alt || "The image to preview";
            var image = document.createElement("img");
            if (crossOrigin) {
              image.crossOrigin = crossOrigin;
            }
            image.src = url;
            image.alt = alt;
            this.viewBox.appendChild(image);
            this.viewBoxImage = image;
            if (!preview3) {
              return;
            }
            var previews = preview3;
            if (typeof preview3 === "string") {
              previews = element.ownerDocument.querySelectorAll(preview3);
            } else if (preview3.querySelector) {
              previews = [preview3];
            }
            this.previews = previews;
            forEach(previews, function (el) {
              var img = document.createElement("img");
              setData(el, DATA_PREVIEW, {
                width: el.offsetWidth,
                height: el.offsetHeight,
                html: el.innerHTML
              });
              if (crossOrigin) {
                img.crossOrigin = crossOrigin;
              }
              img.src = url;
              img.alt = alt;
              img.style.cssText = 'display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;"';
              el.innerHTML = "";
              el.appendChild(img);
            });
          },
          resetPreview: function resetPreview() {
            forEach(this.previews, function (element) {
              var data = getData(element, DATA_PREVIEW);
              setStyle(element, {
                width: data.width,
                height: data.height
              });
              element.innerHTML = data.html;
              removeData(element, DATA_PREVIEW);
            });
          },
          preview: function preview2() {
            var imageData = this.imageData,
              canvasData = this.canvasData,
              cropBoxData = this.cropBoxData;
            var cropBoxWidth = cropBoxData.width,
              cropBoxHeight = cropBoxData.height;
            var width = imageData.width,
              height = imageData.height;
            var left = cropBoxData.left - canvasData.left - imageData.left;
            var top = cropBoxData.top - canvasData.top - imageData.top;
            if (!this.cropped || this.disabled) {
              return;
            }
            setStyle(this.viewBoxImage, assign({
              width,
              height
            }, getTransforms(assign({
              translateX: -left,
              translateY: -top
            }, imageData))));
            forEach(this.previews, function (element) {
              var data = getData(element, DATA_PREVIEW);
              var originalWidth = data.width;
              var originalHeight = data.height;
              var newWidth = originalWidth;
              var newHeight = originalHeight;
              var ratio = 1;
              if (cropBoxWidth) {
                ratio = originalWidth / cropBoxWidth;
                newHeight = cropBoxHeight * ratio;
              }
              if (cropBoxHeight && newHeight > originalHeight) {
                ratio = originalHeight / cropBoxHeight;
                newWidth = cropBoxWidth * ratio;
                newHeight = originalHeight;
              }
              setStyle(element, {
                width: newWidth,
                height: newHeight
              });
              setStyle(element.getElementsByTagName("img")[0], assign({
                width: width * ratio,
                height: height * ratio
              }, getTransforms(assign({
                translateX: -left * ratio,
                translateY: -top * ratio
              }, imageData))));
            });
          }
        };
        var events = {
          bind: function bind() {
            var element = this.element,
              options = this.options,
              cropper = this.cropper;
            if (isFunction(options.cropstart)) {
              addListener(element, EVENT_CROP_START, options.cropstart);
            }
            if (isFunction(options.cropmove)) {
              addListener(element, EVENT_CROP_MOVE, options.cropmove);
            }
            if (isFunction(options.cropend)) {
              addListener(element, EVENT_CROP_END, options.cropend);
            }
            if (isFunction(options.crop)) {
              addListener(element, EVENT_CROP, options.crop);
            }
            if (isFunction(options.zoom)) {
              addListener(element, EVENT_ZOOM, options.zoom);
            }
            addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));
            if (options.zoomable && options.zoomOnWheel) {
              addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
                passive: false,
                capture: true
              });
            }
            if (options.toggleDragModeOnDblclick) {
              addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
            }
            addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));
            addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));
            if (options.responsive) {
              addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
            }
          },
          unbind: function unbind() {
            var element = this.element,
              options = this.options,
              cropper = this.cropper;
            if (isFunction(options.cropstart)) {
              removeListener(element, EVENT_CROP_START, options.cropstart);
            }
            if (isFunction(options.cropmove)) {
              removeListener(element, EVENT_CROP_MOVE, options.cropmove);
            }
            if (isFunction(options.cropend)) {
              removeListener(element, EVENT_CROP_END, options.cropend);
            }
            if (isFunction(options.crop)) {
              removeListener(element, EVENT_CROP, options.crop);
            }
            if (isFunction(options.zoom)) {
              removeListener(element, EVENT_ZOOM, options.zoom);
            }
            removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);
            if (options.zoomable && options.zoomOnWheel) {
              removeListener(cropper, EVENT_WHEEL, this.onWheel, {
                passive: false,
                capture: true
              });
            }
            if (options.toggleDragModeOnDblclick) {
              removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);
            }
            removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);
            removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);
            if (options.responsive) {
              removeListener(window, EVENT_RESIZE, this.onResize);
            }
          }
        };
        var handlers = {
          resize: function resize() {
            if (this.disabled) {
              return;
            }
            var options = this.options,
              container = this.container,
              containerData = this.containerData;
            var ratioX = container.offsetWidth / containerData.width;
            var ratioY = container.offsetHeight / containerData.height;
            var ratio = Math.abs(ratioX - 1) > Math.abs(ratioY - 1) ? ratioX : ratioY;
            if (ratio !== 1) {
              var canvasData;
              var cropBoxData;
              if (options.restore) {
                canvasData = this.getCanvasData();
                cropBoxData = this.getCropBoxData();
              }
              this.render();
              if (options.restore) {
                this.setCanvasData(forEach(canvasData, function (n, i) {
                  canvasData[i] = n * ratio;
                }));
                this.setCropBoxData(forEach(cropBoxData, function (n, i) {
                  cropBoxData[i] = n * ratio;
                }));
              }
            }
          },
          dblclick: function dblclick() {
            if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
              return;
            }
            this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
          },
          wheel: function wheel(event) {
            var _this = this;
            var ratio = Number(this.options.wheelZoomRatio) || 0.1;
            var delta = 1;
            if (this.disabled) {
              return;
            }
            event.preventDefault();
            if (this.wheeling) {
              return;
            }
            this.wheeling = true;
            setTimeout(function () {
              _this.wheeling = false;
            }, 50);
            if (event.deltaY) {
              delta = event.deltaY > 0 ? 1 : -1;
            } else if (event.wheelDelta) {
              delta = -event.wheelDelta / 120;
            } else if (event.detail) {
              delta = event.detail > 0 ? 1 : -1;
            }
            this.zoom(-delta * ratio, event);
          },
          cropStart: function cropStart(event) {
            var buttons = event.buttons,
              button = event.button;
            if (this.disabled || (event.type === "mousedown" || event.type === "pointerdown" && event.pointerType === "mouse") && (
            // No primary button (Usually the left button)
            isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 || event.ctrlKey)) {
              return;
            }
            var options = this.options,
              pointers = this.pointers;
            var action;
            if (event.changedTouches) {
              forEach(event.changedTouches, function (touch) {
                pointers[touch.identifier] = getPointer(touch);
              });
            } else {
              pointers[event.pointerId || 0] = getPointer(event);
            }
            if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
              action = ACTION_ZOOM;
            } else {
              action = getData(event.target, DATA_ACTION);
            }
            if (!REGEXP_ACTIONS.test(action)) {
              return;
            }
            if (dispatchEvent(this.element, EVENT_CROP_START, {
              originalEvent: event,
              action
            }) === false) {
              return;
            }
            event.preventDefault();
            this.action = action;
            this.cropping = false;
            if (action === ACTION_CROP) {
              this.cropping = true;
              addClass(this.dragBox, CLASS_MODAL);
            }
          },
          cropMove: function cropMove(event) {
            var action = this.action;
            if (this.disabled || !action) {
              return;
            }
            var pointers = this.pointers;
            event.preventDefault();
            if (dispatchEvent(this.element, EVENT_CROP_MOVE, {
              originalEvent: event,
              action
            }) === false) {
              return;
            }
            if (event.changedTouches) {
              forEach(event.changedTouches, function (touch) {
                assign(pointers[touch.identifier] || {}, getPointer(touch, true));
              });
            } else {
              assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));
            }
            this.change(event);
          },
          cropEnd: function cropEnd(event) {
            if (this.disabled) {
              return;
            }
            var action = this.action,
              pointers = this.pointers;
            if (event.changedTouches) {
              forEach(event.changedTouches, function (touch) {
                delete pointers[touch.identifier];
              });
            } else {
              delete pointers[event.pointerId || 0];
            }
            if (!action) {
              return;
            }
            event.preventDefault();
            if (!Object.keys(pointers).length) {
              this.action = "";
            }
            if (this.cropping) {
              this.cropping = false;
              toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);
            }
            dispatchEvent(this.element, EVENT_CROP_END, {
              originalEvent: event,
              action
            });
          }
        };
        var change = {
          change: function change2(event) {
            var options = this.options,
              canvasData = this.canvasData,
              containerData = this.containerData,
              cropBoxData = this.cropBoxData,
              pointers = this.pointers;
            var action = this.action;
            var aspectRatio = options.aspectRatio;
            var left = cropBoxData.left,
              top = cropBoxData.top,
              width = cropBoxData.width,
              height = cropBoxData.height;
            var right = left + width;
            var bottom = top + height;
            var minLeft = 0;
            var minTop = 0;
            var maxWidth = containerData.width;
            var maxHeight = containerData.height;
            var renderable = true;
            var offset;
            if (!aspectRatio && event.shiftKey) {
              aspectRatio = width && height ? width / height : 1;
            }
            if (this.limited) {
              minLeft = cropBoxData.minLeft;
              minTop = cropBoxData.minTop;
              maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
              maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
            }
            var pointer = pointers[Object.keys(pointers)[0]];
            var range = {
              x: pointer.endX - pointer.startX,
              y: pointer.endY - pointer.startY
            };
            var check = function check2(side) {
              switch (side) {
                case ACTION_EAST:
                  if (right + range.x > maxWidth) {
                    range.x = maxWidth - right;
                  }
                  break;
                case ACTION_WEST:
                  if (left + range.x < minLeft) {
                    range.x = minLeft - left;
                  }
                  break;
                case ACTION_NORTH:
                  if (top + range.y < minTop) {
                    range.y = minTop - top;
                  }
                  break;
                case ACTION_SOUTH:
                  if (bottom + range.y > maxHeight) {
                    range.y = maxHeight - bottom;
                  }
                  break;
              }
            };
            switch (action) {
              // Move crop box
              case ACTION_ALL:
                left += range.x;
                top += range.y;
                break;
              // Resize crop box
              case ACTION_EAST:
                if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
                  renderable = false;
                  break;
                }
                check(ACTION_EAST);
                width += range.x;
                if (width < 0) {
                  action = ACTION_WEST;
                  width = -width;
                  left -= width;
                }
                if (aspectRatio) {
                  height = width / aspectRatio;
                  top += (cropBoxData.height - height) / 2;
                }
                break;
              case ACTION_NORTH:
                if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
                  renderable = false;
                  break;
                }
                check(ACTION_NORTH);
                height -= range.y;
                top += range.y;
                if (height < 0) {
                  action = ACTION_SOUTH;
                  height = -height;
                  top -= height;
                }
                if (aspectRatio) {
                  width = height * aspectRatio;
                  left += (cropBoxData.width - width) / 2;
                }
                break;
              case ACTION_WEST:
                if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
                  renderable = false;
                  break;
                }
                check(ACTION_WEST);
                width -= range.x;
                left += range.x;
                if (width < 0) {
                  action = ACTION_EAST;
                  width = -width;
                  left -= width;
                }
                if (aspectRatio) {
                  height = width / aspectRatio;
                  top += (cropBoxData.height - height) / 2;
                }
                break;
              case ACTION_SOUTH:
                if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
                  renderable = false;
                  break;
                }
                check(ACTION_SOUTH);
                height += range.y;
                if (height < 0) {
                  action = ACTION_NORTH;
                  height = -height;
                  top -= height;
                }
                if (aspectRatio) {
                  width = height * aspectRatio;
                  left += (cropBoxData.width - width) / 2;
                }
                break;
              case ACTION_NORTH_EAST:
                if (aspectRatio) {
                  if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
                    renderable = false;
                    break;
                  }
                  check(ACTION_NORTH);
                  height -= range.y;
                  top += range.y;
                  width = height * aspectRatio;
                } else {
                  check(ACTION_NORTH);
                  check(ACTION_EAST);
                  if (range.x >= 0) {
                    if (right < maxWidth) {
                      width += range.x;
                    } else if (range.y <= 0 && top <= minTop) {
                      renderable = false;
                    }
                  } else {
                    width += range.x;
                  }
                  if (range.y <= 0) {
                    if (top > minTop) {
                      height -= range.y;
                      top += range.y;
                    }
                  } else {
                    height -= range.y;
                    top += range.y;
                  }
                }
                if (width < 0 && height < 0) {
                  action = ACTION_SOUTH_WEST;
                  height = -height;
                  width = -width;
                  top -= height;
                  left -= width;
                } else if (width < 0) {
                  action = ACTION_NORTH_WEST;
                  width = -width;
                  left -= width;
                } else if (height < 0) {
                  action = ACTION_SOUTH_EAST;
                  height = -height;
                  top -= height;
                }
                break;
              case ACTION_NORTH_WEST:
                if (aspectRatio) {
                  if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
                    renderable = false;
                    break;
                  }
                  check(ACTION_NORTH);
                  height -= range.y;
                  top += range.y;
                  width = height * aspectRatio;
                  left += cropBoxData.width - width;
                } else {
                  check(ACTION_NORTH);
                  check(ACTION_WEST);
                  if (range.x <= 0) {
                    if (left > minLeft) {
                      width -= range.x;
                      left += range.x;
                    } else if (range.y <= 0 && top <= minTop) {
                      renderable = false;
                    }
                  } else {
                    width -= range.x;
                    left += range.x;
                  }
                  if (range.y <= 0) {
                    if (top > minTop) {
                      height -= range.y;
                      top += range.y;
                    }
                  } else {
                    height -= range.y;
                    top += range.y;
                  }
                }
                if (width < 0 && height < 0) {
                  action = ACTION_SOUTH_EAST;
                  height = -height;
                  width = -width;
                  top -= height;
                  left -= width;
                } else if (width < 0) {
                  action = ACTION_NORTH_EAST;
                  width = -width;
                  left -= width;
                } else if (height < 0) {
                  action = ACTION_SOUTH_WEST;
                  height = -height;
                  top -= height;
                }
                break;
              case ACTION_SOUTH_WEST:
                if (aspectRatio) {
                  if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
                    renderable = false;
                    break;
                  }
                  check(ACTION_WEST);
                  width -= range.x;
                  left += range.x;
                  height = width / aspectRatio;
                } else {
                  check(ACTION_SOUTH);
                  check(ACTION_WEST);
                  if (range.x <= 0) {
                    if (left > minLeft) {
                      width -= range.x;
                      left += range.x;
                    } else if (range.y >= 0 && bottom >= maxHeight) {
                      renderable = false;
                    }
                  } else {
                    width -= range.x;
                    left += range.x;
                  }
                  if (range.y >= 0) {
                    if (bottom < maxHeight) {
                      height += range.y;
                    }
                  } else {
                    height += range.y;
                  }
                }
                if (width < 0 && height < 0) {
                  action = ACTION_NORTH_EAST;
                  height = -height;
                  width = -width;
                  top -= height;
                  left -= width;
                } else if (width < 0) {
                  action = ACTION_SOUTH_EAST;
                  width = -width;
                  left -= width;
                } else if (height < 0) {
                  action = ACTION_NORTH_WEST;
                  height = -height;
                  top -= height;
                }
                break;
              case ACTION_SOUTH_EAST:
                if (aspectRatio) {
                  if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
                    renderable = false;
                    break;
                  }
                  check(ACTION_EAST);
                  width += range.x;
                  height = width / aspectRatio;
                } else {
                  check(ACTION_SOUTH);
                  check(ACTION_EAST);
                  if (range.x >= 0) {
                    if (right < maxWidth) {
                      width += range.x;
                    } else if (range.y >= 0 && bottom >= maxHeight) {
                      renderable = false;
                    }
                  } else {
                    width += range.x;
                  }
                  if (range.y >= 0) {
                    if (bottom < maxHeight) {
                      height += range.y;
                    }
                  } else {
                    height += range.y;
                  }
                }
                if (width < 0 && height < 0) {
                  action = ACTION_NORTH_WEST;
                  height = -height;
                  width = -width;
                  top -= height;
                  left -= width;
                } else if (width < 0) {
                  action = ACTION_SOUTH_WEST;
                  width = -width;
                  left -= width;
                } else if (height < 0) {
                  action = ACTION_NORTH_EAST;
                  height = -height;
                  top -= height;
                }
                break;
              // Move canvas
              case ACTION_MOVE:
                this.move(range.x, range.y);
                renderable = false;
                break;
              // Zoom canvas
              case ACTION_ZOOM:
                this.zoom(getMaxZoomRatio(pointers), event);
                renderable = false;
                break;
              // Create crop box
              case ACTION_CROP:
                if (!range.x || !range.y) {
                  renderable = false;
                  break;
                }
                offset = getOffset(this.cropper);
                left = pointer.startX - offset.left;
                top = pointer.startY - offset.top;
                width = cropBoxData.minWidth;
                height = cropBoxData.minHeight;
                if (range.x > 0) {
                  action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
                } else if (range.x < 0) {
                  left -= width;
                  action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
                }
                if (range.y < 0) {
                  top -= height;
                }
                if (!this.cropped) {
                  removeClass(this.cropBox, CLASS_HIDDEN);
                  this.cropped = true;
                  if (this.limited) {
                    this.limitCropBox(true, true);
                  }
                }
                break;
            }
            if (renderable) {
              cropBoxData.width = width;
              cropBoxData.height = height;
              cropBoxData.left = left;
              cropBoxData.top = top;
              this.action = action;
              this.renderCropBox();
            }
            forEach(pointers, function (p) {
              p.startX = p.endX;
              p.startY = p.endY;
            });
          }
        };
        var methods = {
          // Show the crop box manually
          crop: function crop() {
            if (this.ready && !this.cropped && !this.disabled) {
              this.cropped = true;
              this.limitCropBox(true, true);
              if (this.options.modal) {
                addClass(this.dragBox, CLASS_MODAL);
              }
              removeClass(this.cropBox, CLASS_HIDDEN);
              this.setCropBoxData(this.initialCropBoxData);
            }
            return this;
          },
          // Reset the image and crop box to their initial states
          reset: function reset() {
            if (this.ready && !this.disabled) {
              this.imageData = assign({}, this.initialImageData);
              this.canvasData = assign({}, this.initialCanvasData);
              this.cropBoxData = assign({}, this.initialCropBoxData);
              this.renderCanvas();
              if (this.cropped) {
                this.renderCropBox();
              }
            }
            return this;
          },
          // Clear the crop box
          clear: function clear() {
            if (this.cropped && !this.disabled) {
              assign(this.cropBoxData, {
                left: 0,
                top: 0,
                width: 0,
                height: 0
              });
              this.cropped = false;
              this.renderCropBox();
              this.limitCanvas(true, true);
              this.renderCanvas();
              removeClass(this.dragBox, CLASS_MODAL);
              addClass(this.cropBox, CLASS_HIDDEN);
            }
            return this;
          },
          /**
           * Replace the image's src and rebuild the cropper
           * @param {string} url - The new URL.
           * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
           * @returns {Cropper} this
           */
          replace: function replace(url) {
            var hasSameSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            if (!this.disabled && url) {
              if (this.isImg) {
                this.element.src = url;
              }
              if (hasSameSize) {
                this.url = url;
                this.image.src = url;
                if (this.ready) {
                  this.viewBoxImage.src = url;
                  forEach(this.previews, function (element) {
                    element.getElementsByTagName("img")[0].src = url;
                  });
                }
              } else {
                if (this.isImg) {
                  this.replaced = true;
                }
                this.options.data = null;
                this.uncreate();
                this.load(url);
              }
            }
            return this;
          },
          // Enable (unfreeze) the cropper
          enable: function enable() {
            if (this.ready && this.disabled) {
              this.disabled = false;
              removeClass(this.cropper, CLASS_DISABLED);
            }
            return this;
          },
          // Disable (freeze) the cropper
          disable: function disable() {
            if (this.ready && !this.disabled) {
              this.disabled = true;
              addClass(this.cropper, CLASS_DISABLED);
            }
            return this;
          },
          /**
           * Destroy the cropper and remove the instance from the image
           * @returns {Cropper} this
           */
          destroy: function destroy() {
            var element = this.element;
            if (!element[NAMESPACE]) {
              return this;
            }
            element[NAMESPACE] = void 0;
            if (this.isImg && this.replaced) {
              element.src = this.originalUrl;
            }
            this.uncreate();
            return this;
          },
          /**
           * Move the canvas with relative offsets
           * @param {number} offsetX - The relative offset distance on the x-axis.
           * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
           * @returns {Cropper} this
           */
          move: function move(offsetX) {
            var offsetY = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : offsetX;
            var _this$canvasData = this.canvasData,
              left = _this$canvasData.left,
              top = _this$canvasData.top;
            return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));
          },
          /**
           * Move the canvas to an absolute point
           * @param {number} x - The x-axis coordinate.
           * @param {number} [y=x] - The y-axis coordinate.
           * @returns {Cropper} this
           */
          moveTo: function moveTo(x) {
            var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : x;
            var canvasData = this.canvasData;
            var changed = false;
            x = Number(x);
            y = Number(y);
            if (this.ready && !this.disabled && this.options.movable) {
              if (isNumber(x)) {
                canvasData.left = x;
                changed = true;
              }
              if (isNumber(y)) {
                canvasData.top = y;
                changed = true;
              }
              if (changed) {
                this.renderCanvas(true);
              }
            }
            return this;
          },
          /**
           * Zoom the canvas with a relative ratio
           * @param {number} ratio - The target ratio.
           * @param {Event} _originalEvent - The original event if any.
           * @returns {Cropper} this
           */
          zoom: function zoom(ratio, _originalEvent) {
            var canvasData = this.canvasData;
            ratio = Number(ratio);
            if (ratio < 0) {
              ratio = 1 / (1 - ratio);
            } else {
              ratio = 1 + ratio;
            }
            return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);
          },
          /**
           * Zoom the canvas to an absolute ratio
           * @param {number} ratio - The target ratio.
           * @param {Object} pivot - The zoom pivot point coordinate.
           * @param {Event} _originalEvent - The original event if any.
           * @returns {Cropper} this
           */
          zoomTo: function zoomTo(ratio, pivot, _originalEvent) {
            var options = this.options,
              canvasData = this.canvasData;
            var width = canvasData.width,
              height = canvasData.height,
              naturalWidth = canvasData.naturalWidth,
              naturalHeight = canvasData.naturalHeight;
            ratio = Number(ratio);
            if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
              var newWidth = naturalWidth * ratio;
              var newHeight = naturalHeight * ratio;
              if (dispatchEvent(this.element, EVENT_ZOOM, {
                ratio,
                oldRatio: width / naturalWidth,
                originalEvent: _originalEvent
              }) === false) {
                return this;
              }
              if (_originalEvent) {
                var pointers = this.pointers;
                var offset = getOffset(this.cropper);
                var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
                  pageX: _originalEvent.pageX,
                  pageY: _originalEvent.pageY
                };
                canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);
                canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);
              } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {
                canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);
                canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);
              } else {
                canvasData.left -= (newWidth - width) / 2;
                canvasData.top -= (newHeight - height) / 2;
              }
              canvasData.width = newWidth;
              canvasData.height = newHeight;
              this.renderCanvas(true);
            }
            return this;
          },
          /**
           * Rotate the canvas with a relative degree
           * @param {number} degree - The rotate degree.
           * @returns {Cropper} this
           */
          rotate: function rotate(degree) {
            return this.rotateTo((this.imageData.rotate || 0) + Number(degree));
          },
          /**
           * Rotate the canvas to an absolute degree
           * @param {number} degree - The rotate degree.
           * @returns {Cropper} this
           */
          rotateTo: function rotateTo(degree) {
            degree = Number(degree);
            if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {
              this.imageData.rotate = degree % 360;
              this.renderCanvas(true, true);
            }
            return this;
          },
          /**
           * Scale the image on the x-axis.
           * @param {number} scaleX - The scale ratio on the x-axis.
           * @returns {Cropper} this
           */
          scaleX: function scaleX(_scaleX) {
            var scaleY2 = this.imageData.scaleY;
            return this.scale(_scaleX, isNumber(scaleY2) ? scaleY2 : 1);
          },
          /**
           * Scale the image on the y-axis.
           * @param {number} scaleY - The scale ratio on the y-axis.
           * @returns {Cropper} this
           */
          scaleY: function scaleY(_scaleY) {
            var scaleX2 = this.imageData.scaleX;
            return this.scale(isNumber(scaleX2) ? scaleX2 : 1, _scaleY);
          },
          /**
           * Scale the image
           * @param {number} scaleX - The scale ratio on the x-axis.
           * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
           * @returns {Cropper} this
           */
          scale: function scale(scaleX2) {
            var scaleY2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : scaleX2;
            var imageData = this.imageData;
            var transformed = false;
            scaleX2 = Number(scaleX2);
            scaleY2 = Number(scaleY2);
            if (this.ready && !this.disabled && this.options.scalable) {
              if (isNumber(scaleX2)) {
                imageData.scaleX = scaleX2;
                transformed = true;
              }
              if (isNumber(scaleY2)) {
                imageData.scaleY = scaleY2;
                transformed = true;
              }
              if (transformed) {
                this.renderCanvas(true, true);
              }
            }
            return this;
          },
          /**
           * Get the cropped area position and size data (base on the original image)
           * @param {boolean} [rounded=false] - Indicate if round the data values or not.
           * @returns {Object} The result cropped data.
           */
          getData: function getData2() {
            var rounded = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
            var options = this.options,
              imageData = this.imageData,
              canvasData = this.canvasData,
              cropBoxData = this.cropBoxData;
            var data;
            if (this.ready && this.cropped) {
              data = {
                x: cropBoxData.left - canvasData.left,
                y: cropBoxData.top - canvasData.top,
                width: cropBoxData.width,
                height: cropBoxData.height
              };
              var ratio = imageData.width / imageData.naturalWidth;
              forEach(data, function (n, i) {
                data[i] = n / ratio;
              });
              if (rounded) {
                var bottom = Math.round(data.y + data.height);
                var right = Math.round(data.x + data.width);
                data.x = Math.round(data.x);
                data.y = Math.round(data.y);
                data.width = right - data.x;
                data.height = bottom - data.y;
              }
            } else {
              data = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
              };
            }
            if (options.rotatable) {
              data.rotate = imageData.rotate || 0;
            }
            if (options.scalable) {
              data.scaleX = imageData.scaleX || 1;
              data.scaleY = imageData.scaleY || 1;
            }
            return data;
          },
          /**
           * Set the cropped area position and size with new data
           * @param {Object} data - The new data.
           * @returns {Cropper} this
           */
          setData: function setData2(data) {
            var options = this.options,
              imageData = this.imageData,
              canvasData = this.canvasData;
            var cropBoxData = {};
            if (this.ready && !this.disabled && isPlainObject(data)) {
              var transformed = false;
              if (options.rotatable) {
                if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
                  imageData.rotate = data.rotate;
                  transformed = true;
                }
              }
              if (options.scalable) {
                if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
                  imageData.scaleX = data.scaleX;
                  transformed = true;
                }
                if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
                  imageData.scaleY = data.scaleY;
                  transformed = true;
                }
              }
              if (transformed) {
                this.renderCanvas(true, true);
              }
              var ratio = imageData.width / imageData.naturalWidth;
              if (isNumber(data.x)) {
                cropBoxData.left = data.x * ratio + canvasData.left;
              }
              if (isNumber(data.y)) {
                cropBoxData.top = data.y * ratio + canvasData.top;
              }
              if (isNumber(data.width)) {
                cropBoxData.width = data.width * ratio;
              }
              if (isNumber(data.height)) {
                cropBoxData.height = data.height * ratio;
              }
              this.setCropBoxData(cropBoxData);
            }
            return this;
          },
          /**
           * Get the container size data.
           * @returns {Object} The result container data.
           */
          getContainerData: function getContainerData() {
            return this.ready ? assign({}, this.containerData) : {};
          },
          /**
           * Get the image position and size data.
           * @returns {Object} The result image data.
           */
          getImageData: function getImageData() {
            return this.sized ? assign({}, this.imageData) : {};
          },
          /**
           * Get the canvas position and size data.
           * @returns {Object} The result canvas data.
           */
          getCanvasData: function getCanvasData() {
            var canvasData = this.canvasData;
            var data = {};
            if (this.ready) {
              forEach(["left", "top", "width", "height", "naturalWidth", "naturalHeight"], function (n) {
                data[n] = canvasData[n];
              });
            }
            return data;
          },
          /**
           * Set the canvas position and size with new data.
           * @param {Object} data - The new canvas data.
           * @returns {Cropper} this
           */
          setCanvasData: function setCanvasData(data) {
            var canvasData = this.canvasData;
            var aspectRatio = canvasData.aspectRatio;
            if (this.ready && !this.disabled && isPlainObject(data)) {
              if (isNumber(data.left)) {
                canvasData.left = data.left;
              }
              if (isNumber(data.top)) {
                canvasData.top = data.top;
              }
              if (isNumber(data.width)) {
                canvasData.width = data.width;
                canvasData.height = data.width / aspectRatio;
              } else if (isNumber(data.height)) {
                canvasData.height = data.height;
                canvasData.width = data.height * aspectRatio;
              }
              this.renderCanvas(true);
            }
            return this;
          },
          /**
           * Get the crop box position and size data.
           * @returns {Object} The result crop box data.
           */
          getCropBoxData: function getCropBoxData() {
            var cropBoxData = this.cropBoxData;
            var data;
            if (this.ready && this.cropped) {
              data = {
                left: cropBoxData.left,
                top: cropBoxData.top,
                width: cropBoxData.width,
                height: cropBoxData.height
              };
            }
            return data || {};
          },
          /**
           * Set the crop box position and size with new data.
           * @param {Object} data - The new crop box data.
           * @returns {Cropper} this
           */
          setCropBoxData: function setCropBoxData(data) {
            var cropBoxData = this.cropBoxData;
            var aspectRatio = this.options.aspectRatio;
            var widthChanged;
            var heightChanged;
            if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {
              if (isNumber(data.left)) {
                cropBoxData.left = data.left;
              }
              if (isNumber(data.top)) {
                cropBoxData.top = data.top;
              }
              if (isNumber(data.width) && data.width !== cropBoxData.width) {
                widthChanged = true;
                cropBoxData.width = data.width;
              }
              if (isNumber(data.height) && data.height !== cropBoxData.height) {
                heightChanged = true;
                cropBoxData.height = data.height;
              }
              if (aspectRatio) {
                if (widthChanged) {
                  cropBoxData.height = cropBoxData.width / aspectRatio;
                } else if (heightChanged) {
                  cropBoxData.width = cropBoxData.height * aspectRatio;
                }
              }
              this.renderCropBox();
            }
            return this;
          },
          /**
           * Get a canvas drawn the cropped image.
           * @param {Object} [options={}] - The config options.
           * @returns {HTMLCanvasElement} - The result canvas.
           */
          getCroppedCanvas: function getCroppedCanvas() {
            var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            if (!this.ready || !window.HTMLCanvasElement) {
              return null;
            }
            var canvasData = this.canvasData;
            var source = getSourceCanvas(this.image, this.imageData, canvasData, options);
            if (!this.cropped) {
              return source;
            }
            var _this$getData = this.getData(options.rounded),
              initialX = _this$getData.x,
              initialY = _this$getData.y,
              initialWidth = _this$getData.width,
              initialHeight = _this$getData.height;
            var ratio = source.width / Math.floor(canvasData.naturalWidth);
            if (ratio !== 1) {
              initialX *= ratio;
              initialY *= ratio;
              initialWidth *= ratio;
              initialHeight *= ratio;
            }
            var aspectRatio = initialWidth / initialHeight;
            var maxSizes = getAdjustedSizes({
              aspectRatio,
              width: options.maxWidth || Infinity,
              height: options.maxHeight || Infinity
            });
            var minSizes = getAdjustedSizes({
              aspectRatio,
              width: options.minWidth || 0,
              height: options.minHeight || 0
            }, "cover");
            var _getAdjustedSizes = getAdjustedSizes({
                aspectRatio,
                width: options.width || (ratio !== 1 ? source.width : initialWidth),
                height: options.height || (ratio !== 1 ? source.height : initialHeight)
              }),
              width = _getAdjustedSizes.width,
              height = _getAdjustedSizes.height;
            width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
            height = Math.min(maxSizes.height, Math.max(minSizes.height, height));
            var canvas = document.createElement("canvas");
            var context = canvas.getContext("2d");
            canvas.width = normalizeDecimalNumber(width);
            canvas.height = normalizeDecimalNumber(height);
            context.fillStyle = options.fillColor || "transparent";
            context.fillRect(0, 0, width, height);
            var _options$imageSmoothi = options.imageSmoothingEnabled,
              imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi,
              imageSmoothingQuality = options.imageSmoothingQuality;
            context.imageSmoothingEnabled = imageSmoothingEnabled;
            if (imageSmoothingQuality) {
              context.imageSmoothingQuality = imageSmoothingQuality;
            }
            var sourceWidth = source.width;
            var sourceHeight = source.height;
            var srcX = initialX;
            var srcY = initialY;
            var srcWidth;
            var srcHeight;
            var dstX;
            var dstY;
            var dstWidth;
            var dstHeight;
            if (srcX <= -initialWidth || srcX > sourceWidth) {
              srcX = 0;
              srcWidth = 0;
              dstX = 0;
              dstWidth = 0;
            } else if (srcX <= 0) {
              dstX = -srcX;
              srcX = 0;
              srcWidth = Math.min(sourceWidth, initialWidth + srcX);
              dstWidth = srcWidth;
            } else if (srcX <= sourceWidth) {
              dstX = 0;
              srcWidth = Math.min(initialWidth, sourceWidth - srcX);
              dstWidth = srcWidth;
            }
            if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
              srcY = 0;
              srcHeight = 0;
              dstY = 0;
              dstHeight = 0;
            } else if (srcY <= 0) {
              dstY = -srcY;
              srcY = 0;
              srcHeight = Math.min(sourceHeight, initialHeight + srcY);
              dstHeight = srcHeight;
            } else if (srcY <= sourceHeight) {
              dstY = 0;
              srcHeight = Math.min(initialHeight, sourceHeight - srcY);
              dstHeight = srcHeight;
            }
            var params = [srcX, srcY, srcWidth, srcHeight];
            if (dstWidth > 0 && dstHeight > 0) {
              var scale2 = width / initialWidth;
              params.push(dstX * scale2, dstY * scale2, dstWidth * scale2, dstHeight * scale2);
            }
            context.drawImage.apply(context, [source].concat(_toConsumableArray$1(params.map(function (param) {
              return Math.floor(normalizeDecimalNumber(param));
            }))));
            return canvas;
          },
          /**
           * Change the aspect ratio of the crop box.
           * @param {number} aspectRatio - The new aspect ratio.
           * @returns {Cropper} this
           */
          setAspectRatio: function setAspectRatio(aspectRatio) {
            var options = this.options;
            if (!this.disabled && !isUndefined(aspectRatio)) {
              options.aspectRatio = Math.max(0, aspectRatio) || NaN;
              if (this.ready) {
                this.initCropBox();
                if (this.cropped) {
                  this.renderCropBox();
                }
              }
            }
            return this;
          },
          /**
           * Change the drag mode.
           * @param {string} mode - The new drag mode.
           * @returns {Cropper} this
           */
          setDragMode: function setDragMode(mode) {
            var options = this.options,
              dragBox = this.dragBox,
              face = this.face;
            if (this.ready && !this.disabled) {
              var croppable = mode === DRAG_MODE_CROP;
              var movable = options.movable && mode === DRAG_MODE_MOVE;
              mode = croppable || movable ? mode : DRAG_MODE_NONE;
              options.dragMode = mode;
              setData(dragBox, DATA_ACTION, mode);
              toggleClass(dragBox, CLASS_CROP, croppable);
              toggleClass(dragBox, CLASS_MOVE, movable);
              if (!options.cropBoxMovable) {
                setData(face, DATA_ACTION, mode);
                toggleClass(face, CLASS_CROP, croppable);
                toggleClass(face, CLASS_MOVE, movable);
              }
            }
            return this;
          }
        };
        var AnotherCropper = WINDOW.Cropper;
        var Cropper = /* @__PURE__ */function () {
          function Cropper2(element) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            _classCallCheck$1(this, Cropper2);
            if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
              throw new Error("The first argument is required and must be an <img> or <canvas> element.");
            }
            this.element = element;
            this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
            this.cropped = false;
            this.disabled = false;
            this.pointers = {};
            this.ready = false;
            this.reloading = false;
            this.replaced = false;
            this.sized = false;
            this.sizing = false;
            this.init();
          }
          return _createClass$1(Cropper2, [{
            key: "init",
            value: function init() {
              var element = this.element;
              var tagName = element.tagName.toLowerCase();
              var url;
              if (element[NAMESPACE]) {
                return;
              }
              element[NAMESPACE] = this;
              if (tagName === "img") {
                this.isImg = true;
                url = element.getAttribute("src") || "";
                this.originalUrl = url;
                if (!url) {
                  return;
                }
                url = element.src;
              } else if (tagName === "canvas" && window.HTMLCanvasElement) {
                url = element.toDataURL();
              }
              this.load(url);
            }
          }, {
            key: "load",
            value: function load(url) {
              var _this = this;
              if (!url) {
                return;
              }
              this.url = url;
              this.imageData = {};
              var element = this.element,
                options = this.options;
              if (!options.rotatable && !options.scalable) {
                options.checkOrientation = false;
              }
              if (!options.checkOrientation || !window.ArrayBuffer) {
                this.clone();
                return;
              }
              if (REGEXP_DATA_URL.test(url)) {
                if (REGEXP_DATA_URL_JPEG.test(url)) {
                  this.read(dataURLToArrayBuffer(url));
                } else {
                  this.clone();
                }
                return;
              }
              var xhr = new XMLHttpRequest();
              var clone = this.clone.bind(this);
              this.reloading = true;
              this.xhr = xhr;
              xhr.onabort = clone;
              xhr.onerror = clone;
              xhr.ontimeout = clone;
              xhr.onprogress = function () {
                if (xhr.getResponseHeader("content-type") !== MIME_TYPE_JPEG) {
                  xhr.abort();
                }
              };
              xhr.onload = function () {
                _this.read(xhr.response);
              };
              xhr.onloadend = function () {
                _this.reloading = false;
                _this.xhr = null;
              };
              if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
                url = addTimestamp(url);
              }
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.withCredentials = element.crossOrigin === "use-credentials";
              xhr.send();
            }
          }, {
            key: "read",
            value: function read(arrayBuffer) {
              var options = this.options,
                imageData = this.imageData;
              var orientation = resetAndGetOrientation(arrayBuffer);
              var rotate2 = 0;
              var scaleX2 = 1;
              var scaleY2 = 1;
              if (orientation > 1) {
                this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);
                var _parseOrientation = parseOrientation(orientation);
                rotate2 = _parseOrientation.rotate;
                scaleX2 = _parseOrientation.scaleX;
                scaleY2 = _parseOrientation.scaleY;
              }
              if (options.rotatable) {
                imageData.rotate = rotate2;
              }
              if (options.scalable) {
                imageData.scaleX = scaleX2;
                imageData.scaleY = scaleY2;
              }
              this.clone();
            }
          }, {
            key: "clone",
            value: function clone() {
              var element = this.element,
                url = this.url;
              var crossOrigin = element.crossOrigin;
              var crossOriginUrl = url;
              if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {
                if (!crossOrigin) {
                  crossOrigin = "anonymous";
                }
                crossOriginUrl = addTimestamp(url);
              }
              this.crossOrigin = crossOrigin;
              this.crossOriginUrl = crossOriginUrl;
              var image = document.createElement("img");
              if (crossOrigin) {
                image.crossOrigin = crossOrigin;
              }
              image.src = crossOriginUrl || url;
              image.alt = element.alt || "The image to crop";
              this.image = image;
              image.onload = this.start.bind(this);
              image.onerror = this.stop.bind(this);
              addClass(image, CLASS_HIDE);
              element.parentNode.insertBefore(image, element.nextSibling);
            }
          }, {
            key: "start",
            value: function start() {
              var _this2 = this;
              var image = this.image;
              image.onload = null;
              image.onerror = null;
              this.sizing = true;
              var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);
              var done = function done2(naturalWidth, naturalHeight) {
                assign(_this2.imageData, {
                  naturalWidth,
                  naturalHeight,
                  aspectRatio: naturalWidth / naturalHeight
                });
                _this2.initialImageData = assign({}, _this2.imageData);
                _this2.sizing = false;
                _this2.sized = true;
                _this2.build();
              };
              if (image.naturalWidth && !isIOSWebKit) {
                done(image.naturalWidth, image.naturalHeight);
                return;
              }
              var sizingImage = document.createElement("img");
              var body = document.body || document.documentElement;
              this.sizingImage = sizingImage;
              sizingImage.onload = function () {
                done(sizingImage.width, sizingImage.height);
                if (!isIOSWebKit) {
                  body.removeChild(sizingImage);
                }
              };
              sizingImage.src = image.src;
              if (!isIOSWebKit) {
                sizingImage.style.cssText = "left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;";
                body.appendChild(sizingImage);
              }
            }
          }, {
            key: "stop",
            value: function stop() {
              var image = this.image;
              image.onload = null;
              image.onerror = null;
              image.parentNode.removeChild(image);
              this.image = null;
            }
          }, {
            key: "build",
            value: function build() {
              if (!this.sized || this.ready) {
                return;
              }
              var element = this.element,
                options = this.options,
                image = this.image;
              var container = element.parentNode;
              var template = document.createElement("div");
              template.innerHTML = TEMPLATE;
              var cropper = template.querySelector(".".concat(NAMESPACE, "-container"));
              var canvas = cropper.querySelector(".".concat(NAMESPACE, "-canvas"));
              var dragBox = cropper.querySelector(".".concat(NAMESPACE, "-drag-box"));
              var cropBox = cropper.querySelector(".".concat(NAMESPACE, "-crop-box"));
              var face = cropBox.querySelector(".".concat(NAMESPACE, "-face"));
              this.container = container;
              this.cropper = cropper;
              this.canvas = canvas;
              this.dragBox = dragBox;
              this.cropBox = cropBox;
              this.viewBox = cropper.querySelector(".".concat(NAMESPACE, "-view-box"));
              this.face = face;
              canvas.appendChild(image);
              addClass(element, CLASS_HIDDEN);
              container.insertBefore(cropper, element.nextSibling);
              removeClass(image, CLASS_HIDE);
              this.initPreview();
              this.bind();
              options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;
              options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
              options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
              addClass(cropBox, CLASS_HIDDEN);
              if (!options.guides) {
                addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN);
              }
              if (!options.center) {
                addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN);
              }
              if (options.background) {
                addClass(cropper, "".concat(NAMESPACE, "-bg"));
              }
              if (!options.highlight) {
                addClass(face, CLASS_INVISIBLE);
              }
              if (options.cropBoxMovable) {
                addClass(face, CLASS_MOVE);
                setData(face, DATA_ACTION, ACTION_ALL);
              }
              if (!options.cropBoxResizable) {
                addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN);
                addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN);
              }
              this.render();
              this.ready = true;
              this.setDragMode(options.dragMode);
              if (options.autoCrop) {
                this.crop();
              }
              this.setData(options.data);
              if (isFunction(options.ready)) {
                addListener(element, EVENT_READY, options.ready, {
                  once: true
                });
              }
              dispatchEvent(element, EVENT_READY);
            }
          }, {
            key: "unbuild",
            value: function unbuild() {
              if (!this.ready) {
                return;
              }
              this.ready = false;
              this.unbind();
              this.resetPreview();
              var parentNode = this.cropper.parentNode;
              if (parentNode) {
                parentNode.removeChild(this.cropper);
              }
              removeClass(this.element, CLASS_HIDDEN);
            }
          }, {
            key: "uncreate",
            value: function uncreate() {
              if (this.ready) {
                this.unbuild();
                this.ready = false;
                this.cropped = false;
              } else if (this.sizing) {
                this.sizingImage.onload = null;
                this.sizing = false;
                this.sized = false;
              } else if (this.reloading) {
                this.xhr.onabort = null;
                this.xhr.abort();
              } else if (this.image) {
                this.stop();
              }
            }
            /**
             * Get the no conflict cropper class.
             * @returns {Cropper} The cropper class.
             */
          }], [{
            key: "noConflict",
            value: function noConflict() {
              window.Cropper = AnotherCropper;
              return Cropper2;
            }
            /**
             * Change the default options.
             * @param {Object} options - The new default options.
             */
          }, {
            key: "setDefaults",
            value: function setDefaults(options) {
              assign(DEFAULTS, isPlainObject(options) && options);
            }
          }]);
        }();
        assign(Cropper.prototype, render, preview, events, handlers, change, methods);
        var n$1 = function () {
          return n$1 = Object.assign || function (e) {
            for (var r, o = 1, t = arguments.length; o < t; o++) for (var n in r = arguments[o]) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
            return e;
          }, n$1.apply(this, arguments);
        };
        function a$1(e, r) {
          var o = {};
          for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && r.indexOf(t) < 0 && (o[t] = e[t]);
          if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
            var n = 0;
            for (t = Object.getOwnPropertySymbols(e); n < t.length; n++) r.indexOf(t[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, t[n]) && (o[t[n]] = e[t[n]]);
          }
          return o;
        }
        var c$2 = ["aspectRatio", "autoCrop", "autoCropArea", "background", "center", "checkCrossOrigin", "checkOrientation", "cropBoxMovable", "cropBoxResizable", "data", "dragMode", "guides", "highlight", "initialAspectRatio", "minCanvasHeight", "minCanvasWidth", "minContainerHeight", "minContainerWidth", "minCropBoxHeight", "minCropBoxWidth", "modal", "movable", "preview", "responsive", "restore", "rotatable", "scalable", "toggleDragModeOnDblclick", "viewMode", "wheelZoomRatio", "zoomOnTouch", "zoomOnWheel", "zoomable", "cropstart", "cropmove", "cropend", "crop", "zoom", "ready"],
          i$1 = {
            opacity: 0,
            maxWidth: "100%"
          },
          l$2 = exports("ac", React.forwardRef(function (l, s) {
            var u = a$1(l, []),
              p = u.dragMode,
              d = void 0 === p ? "crop" : p,
              v = u.src,
              f = u.style,
              m = u.className,
              g = u.crossOrigin,
              y = u.scaleX,
              b = u.scaleY,
              h = u.enable,
              O = u.zoomTo,
              T = u.rotateTo,
              z = u.alt,
              C = void 0 === z ? "picture" : z,
              w = u.ready,
              x = u.onInitialized,
              j = a$1(u, ["dragMode", "src", "style", "className", "crossOrigin", "scaleX", "scaleY", "enable", "zoomTo", "rotateTo", "alt", "ready", "onInitialized"]),
              M = {
                scaleY: b,
                scaleX: y,
                enable: h,
                zoomTo: O,
                rotateTo: T
              },
              E = function () {
                for (var o = [], t = 0; t < arguments.length; t++) o[t] = arguments[t];
                var n = reactExports.useRef(null);
                return React.useEffect(function () {
                  o.forEach(function (e) {
                    e && ("function" == typeof e ? e(n.current) : e.current = n.current);
                  });
                }, [o]), n;
              }(s, reactExports.useRef(null));
            reactExports.useEffect(function () {
              var e;
              (null === (e = E.current) || void 0 === e ? void 0 : e.cropper) && "number" == typeof O && E.current.cropper.zoomTo(O);
            }, [u.zoomTo]), reactExports.useEffect(function () {
              var e;
              (null === (e = E.current) || void 0 === e ? void 0 : e.cropper) && void 0 !== v && E.current.cropper.reset().clear().replace(v);
            }, [v]), reactExports.useEffect(function () {
              if (null !== E.current) {
                var e = new Cropper(E.current, n$1(n$1({
                  dragMode: d
                }, j), {
                  ready: function (e) {
                    null !== e.currentTarget && function (e, r) {
                      void 0 === r && (r = {});
                      var o = r.enable,
                        t = void 0 === o || o,
                        n = r.scaleX,
                        a = void 0 === n ? 1 : n,
                        c = r.scaleY,
                        i = void 0 === c ? 1 : c,
                        l = r.zoomTo,
                        s = void 0 === l ? 0 : l,
                        u = r.rotateTo;
                      t ? e.enable() : e.disable(), e.scaleX(a), e.scaleY(i), void 0 !== u && e.rotateTo(u), s > 0 && e.zoomTo(s);
                    }(e.currentTarget.cropper, M), w && w(e);
                  }
                }));
                x && x(e);
              }
              return function () {
                var e, r;
                null === (r = null === (e = E.current) || void 0 === e ? void 0 : e.cropper) || void 0 === r || r.destroy();
              };
            }, [E]);
            var R = function (e) {
              return c$2.reduce(function (e, r) {
                var o = e,
                  t = r;
                return o[t], a$1(o, ["symbol" == typeof t ? t : t + ""]);
              }, e);
            }(n$1(n$1({}, j), {
              crossOrigin: g,
              src: v,
              alt: C
            }));
            return React.createElement("div", {
              style: f,
              className: m
            }, React.createElement("img", n$1({}, R, {
              style: i$1,
              ref: E
            })));
          }));
        function c$1(n, u = 300, r = {}) {
          const e = reactExports.useRef(null),
            i = reactExports.useCallback(t => {
              e.current ? (clearTimeout(e.current), e.current = null, n && n(t)) : e.current = setTimeout(() => {
                r.onSingleTap && r.onSingleTap(t), e.current = null;
              }, u);
            },
            // eslint-disable-next-line react-hooks/exhaustive-deps
            [n, u, r.onSingleTap]);
          return n ? {
            onClick: i
          } : {};
        }
        var Action;
        (function (Action) {
          Action["DragStart"] = "dragStart";
          Action["DragMove"] = "dragMove";
          Action["DragEnd"] = "dragEnd";
          Action["DragCancel"] = "dragCancel";
          Action["DragOver"] = "dragOver";
          Action["RegisterDroppable"] = "registerDroppable";
          Action["SetDroppableDisabled"] = "setDroppableDisabled";
          Action["UnregisterDroppable"] = "unregisterDroppable";
        })(Action || (Action = {}));
        const defaultCoordinates = /*#__PURE__*/Object.freeze({
          x: 0,
          y: 0
        });
        var Direction;
        (function (Direction) {
          Direction[Direction["Forward"] = 1] = "Forward";
          Direction[Direction["Backward"] = -1] = "Backward";
        })(Direction || (Direction = {}));
        var EventName;
        (function (EventName) {
          EventName["Click"] = "click";
          EventName["DragStart"] = "dragstart";
          EventName["Keydown"] = "keydown";
          EventName["ContextMenu"] = "contextmenu";
          EventName["Resize"] = "resize";
          EventName["SelectionChange"] = "selectionchange";
          EventName["VisibilityChange"] = "visibilitychange";
        })(EventName || (EventName = {}));
        var KeyboardCode;
        (function (KeyboardCode) {
          KeyboardCode["Space"] = "Space";
          KeyboardCode["Down"] = "ArrowDown";
          KeyboardCode["Right"] = "ArrowRight";
          KeyboardCode["Left"] = "ArrowLeft";
          KeyboardCode["Up"] = "ArrowUp";
          KeyboardCode["Esc"] = "Escape";
          KeyboardCode["Enter"] = "Enter";
          KeyboardCode["Tab"] = "Tab";
        })(KeyboardCode || (KeyboardCode = {}));
        ({
          start: [KeyboardCode.Space, KeyboardCode.Enter],
          cancel: [KeyboardCode.Esc],
          end: [KeyboardCode.Space, KeyboardCode.Enter, KeyboardCode.Tab]
        });
        var MouseButton;
        (function (MouseButton) {
          MouseButton[MouseButton["RightClick"] = 2] = "RightClick";
        })(MouseButton || (MouseButton = {}));
        var AutoScrollActivator;
        (function (AutoScrollActivator) {
          AutoScrollActivator[AutoScrollActivator["Pointer"] = 0] = "Pointer";
          AutoScrollActivator[AutoScrollActivator["DraggableRect"] = 1] = "DraggableRect";
        })(AutoScrollActivator || (AutoScrollActivator = {}));
        var TraversalOrder;
        (function (TraversalOrder) {
          TraversalOrder[TraversalOrder["TreeOrder"] = 0] = "TreeOrder";
          TraversalOrder[TraversalOrder["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
        })(TraversalOrder || (TraversalOrder = {}));
        ({
          x: {
            [Direction.Backward]: false,
            [Direction.Forward]: false
          },
          y: {
            [Direction.Backward]: false,
            [Direction.Forward]: false
          }
        });
        var MeasuringStrategy;
        (function (MeasuringStrategy) {
          MeasuringStrategy[MeasuringStrategy["Always"] = 0] = "Always";
          MeasuringStrategy[MeasuringStrategy["BeforeDragging"] = 1] = "BeforeDragging";
          MeasuringStrategy[MeasuringStrategy["WhileDragging"] = 2] = "WhileDragging";
        })(MeasuringStrategy || (MeasuringStrategy = {}));
        var MeasuringFrequency;
        (function (MeasuringFrequency) {
          MeasuringFrequency["Optimized"] = "optimized";
        })(MeasuringFrequency || (MeasuringFrequency = {}));
        ({
          droppable: {
            strategy: MeasuringStrategy.WhileDragging,
            frequency: MeasuringFrequency.Optimized
          }
        });

        /*#__PURE__*/
        reactExports.createContext({
          ...defaultCoordinates,
          scaleX: 1,
          scaleY: 1
        });
        var Status;
        (function (Status) {
          Status[Status["Uninitialized"] = 0] = "Uninitialized";
          Status[Status["Initializing"] = 1] = "Initializing";
          Status[Status["Initialized"] = 2] = "Initialized";
        })(Status || (Status = {}));
        function arrayMove(array, from, to) {
          const newArray = array.slice();
          newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);
          return newArray;
        }
        [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
        var f$1 = /* @__PURE__ */(e => (e.Mouse = "mouse", e.Touch = "touch", e.Pointer = "pointer", e))(f$1 || {}),
          l$1 = /* @__PURE__ */(e => (e.CancelledByMovement = "cancelled-by-movement", e.CancelledByRelease = "cancelled-by-release", e.CancelledOutsideElement = "cancelled-outside-element", e))(l$1 || {});
        const b$1 = ["mousedown", "mousemove", "mouseup", "mouseleave", "mouseout"],
          q = ["touchstart", "touchmove", "touchend", "touchcancel"],
          z = ["pointerdown", "pointermove", "pointerup", "pointerleave", "pointerout"];
        function G(e) {
          return typeof e == "object" && e !== null && "pageX" in e && typeof e.pageX == "number" && "pageY" in e && typeof e.pageY == "number";
        }
        function J(e) {
          var u;
          return b$1.includes((u = e == null ? void 0 : e.nativeEvent) == null ? void 0 : u.type);
        }
        function U(e) {
          var u;
          return q.includes((u = e == null ? void 0 : e.nativeEvent) == null ? void 0 : u.type) || "touches" in e;
        }
        function K(e) {
          const {
            nativeEvent: u
          } = e;
          return u ? z.includes(u == null ? void 0 : u.type) || "pointerId" in u : false;
        }
        function D(e) {
          return J(e) || U(e) || K(e);
        }
        function A(e) {
          var s;
          const u = U(e) ? (s = e == null ? void 0 : e.touches) == null ? void 0 : s[0] : e;
          return G(u) ? {
            x: u.pageX,
            y: u.pageY
          } : null;
        }
        function N(e) {
          return {
            target: e.target,
            currentTarget: e.currentTarget,
            nativeEvent: e,
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            persist: () => {}
          };
        }
        function V(e, {
          threshold: u = 400,
          captureEvent: s = false,
          detect: R = f$1.Pointer,
          cancelOnMovement: p = false,
          cancelOutsideElement: T = true,
          filterEvents: M,
          onStart: m,
          onMove: w,
          onFinish: g,
          onCancel: h
        } = {}) {
          const L = reactExports.useRef(false),
            c = reactExports.useRef(false),
            H = reactExports.useRef(),
            d = reactExports.useRef(),
            B = reactExports.useRef(e),
            a = reactExports.useRef(null),
            y = reactExports.useCallback(r => t => {
              c.current || D(t) && (M !== void 0 && !M(t) || (s && t.persist(), m == null || m(t, {
                context: r
              }), a.current = A(t), c.current = true, H.current = t.currentTarget, d.current = setTimeout(() => {
                B.current && (B.current(t, {
                  context: r
                }), L.current = true);
              }, u)));
            }, [s, M, m, u]),
            o = reactExports.useCallback(r => (t, n) => {
              D(t) && c.current && (a.current = null, s && t.persist(), L.current ? g == null || g(t, {
                context: r
              }) : c.current && (h == null || h(t, {
                context: r,
                reason: n ?? l$1.CancelledByRelease
              })), L.current = false, c.current = false, d.current !== void 0 && clearTimeout(d.current));
            }, [s, g, h]),
            E = reactExports.useCallback(r => t => {
              if (D(t) && (w == null || w(t, {
                context: r
              }), p !== false && a.current)) {
                const n = A(t);
                if (n) {
                  const X = p === true ? 25 : p,
                    Y = {
                      x: Math.abs(n.x - a.current.x),
                      y: Math.abs(n.y - a.current.y)
                    };
                  (Y.x > X || Y.y > X) && o(r)(t, l$1.CancelledByMovement);
                }
              }
            }, [o, p, w]),
            I = reactExports.useCallback(r => {
              if (e === null) return {};
              switch (R) {
                case f$1.Mouse:
                  {
                    const t = {
                      onMouseDown: y(r),
                      onMouseMove: E(r),
                      onMouseUp: o(r)
                    };
                    return T && (t.onMouseLeave = n => {
                      o(r)(n, l$1.CancelledOutsideElement);
                    }), t;
                  }
                case f$1.Touch:
                  return {
                    onTouchStart: y(r),
                    onTouchMove: E(r),
                    onTouchEnd: o(r)
                  };
                case f$1.Pointer:
                  {
                    const t = {
                      onPointerDown: y(r),
                      onPointerMove: E(r),
                      onPointerUp: o(r)
                    };
                    return T && (t.onPointerLeave = n => o(r)(n, l$1.CancelledOutsideElement)), t;
                  }
              }
            }, [e, o, T, R, E, y]);
          return reactExports.useEffect(() => {
            function r(t) {
              const n = N(t);
              o()(n);
            }
            return window.addEventListener("mouseup", r), window.addEventListener("touchend", r), window.addEventListener("pointerup", r), () => {
              window.removeEventListener("mouseup", r), window.removeEventListener("touchend", r), window.removeEventListener("pointerup", r);
            };
          }, [o]), reactExports.useEffect(() => () => {
            d.current !== void 0 && clearTimeout(d.current);
          }, []), reactExports.useEffect(() => {
            B.current = e;
          }, [e]), I;
        }

        /**
         * @module constants
         * @summary Useful constants
         * @description
         * Collection of useful date constants.
         *
         * The constants could be imported from `date-fns/constants`:
         *
         * ```ts
         * import { maxTime, minTime } from "./constants/date-fns/constants";
         *
         * function isAllowedTime(time) {
         *   return time <= maxTime && time >= minTime;
         * }
         * ```
         */

        /**
         * @constant
         * @name millisecondsInWeek
         * @summary Milliseconds in 1 week.
         */
        const millisecondsInWeek = 604800000;

        /**
         * @constant
         * @name millisecondsInDay
         * @summary Milliseconds in 1 day.
         */
        const millisecondsInDay = 86400000;

        /**
         * @constant
         * @name millisecondsInMinute
         * @summary Milliseconds in 1 minute
         */
        const millisecondsInMinute = 60000;

        /**
         * @constant
         * @name millisecondsInHour
         * @summary Milliseconds in 1 hour
         */
        const millisecondsInHour = 3600000;

        /**
         * @constant
         * @name millisecondsInSecond
         * @summary Milliseconds in 1 second
         */
        const millisecondsInSecond = 1000;

        /**
         * @constant
         * @name constructFromSymbol
         * @summary Symbol enabling Date extensions to inherit properties from the reference date.
         *
         * The symbol is used to enable the `constructFrom` function to construct a date
         * using a reference date and a value. It allows to transfer extra properties
         * from the reference date to the new date. It's useful for extensions like
         * [`TZDate`](https://github.com/date-fns/tz) that accept a time zone as
         * a constructor argument.
         */
        const constructFromSymbol = Symbol.for("constructDateFrom");

        /**
         * @name constructFrom
         * @category Generic Helpers
         * @summary Constructs a date using the reference date and the value
         *
         * @description
         * The function constructs a new date using the constructor from the reference
         * date and the given value. It helps to build generic functions that accept
         * date extensions.
         *
         * It defaults to `Date` if the passed reference date is a number or a string.
         *
         * Starting from v3.7.0, it allows to construct a date using `[Symbol.for("constructDateFrom")]`
         * enabling to transfer extra properties from the reference date to the new date.
         * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
         * that accept a time zone as a constructor argument.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         *
         * @param date - The reference date to take constructor from
         * @param value - The value to create the date
         *
         * @returns Date initialized using the given date and value
         *
         * @example
         * import { constructFrom } from "./constructFrom/date-fns";
         *
         * // A function that clones a date preserving the original type
         * function cloneDate<DateType extends Date>(date: DateType): DateType {
         *   return constructFrom(
         *     date, // Use constructor from the given date
         *     date.getTime() // Use the date value to create a new date
         *   );
         * }
         */
        function constructFrom(date, value) {
          if (typeof date === "function") return date(value);
          if (date && typeof date === "object" && constructFromSymbol in date) return date[constructFromSymbol](value);
          if (date instanceof Date) return new date.constructor(value);
          return new Date(value);
        }

        /**
         * @name toDate
         * @category Common Helpers
         * @summary Convert the given argument to an instance of Date.
         *
         * @description
         * Convert the given argument to an instance of Date.
         *
         * If the argument is an instance of Date, the function returns its clone.
         *
         * If the argument is a number, it is treated as a timestamp.
         *
         * If the argument is none of the above, the function returns Invalid Date.
         *
         * Starting from v3.7.0, it clones a date using `[Symbol.for("constructDateFrom")]`
         * enabling to transfer extra properties from the reference date to the new date.
         * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
         * that accept a time zone as a constructor argument.
         *
         * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param argument - The value to convert
         *
         * @returns The parsed date in the local time zone
         *
         * @example
         * // Clone the date:
         * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
         * //=> Tue Feb 11 2014 11:30:30
         *
         * @example
         * // Convert the timestamp to date:
         * const result = toDate(1392098430000)
         * //=> Tue Feb 11 2014 11:30:30
         */
        function toDate$1(argument, context) {
          // [TODO] Get rid of `toDate` or `constructFrom`?
          return constructFrom(context || argument, argument);
        }

        /**
         * The {@link addDays} function options.
         */

        /**
         * @name addDays
         * @category Day Helpers
         * @summary Add the specified number of days to the given date.
         *
         * @description
         * Add the specified number of days to the given date.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The date to be changed
         * @param amount - The amount of days to be added.
         * @param options - An object with options
         *
         * @returns The new date with the days added
         *
         * @example
         * // Add 10 days to 1 September 2014:
         * const result = addDays(new Date(2014, 8, 1), 10)
         * //=> Thu Sep 11 2014 00:00:00
         */
        function addDays(date, amount, options) {
          const _date = toDate$1(date, options?.in);
          if (isNaN(amount)) return constructFrom(options?.in || date, NaN);

          // If 0 days, no-op to avoid changing times in the hour before end of DST
          if (!amount) return _date;
          _date.setDate(_date.getDate() + amount);
          return _date;
        }

        /**
         * The {@link addMonths} function options.
         */

        /**
         * @name addMonths
         * @category Month Helpers
         * @summary Add the specified number of months to the given date.
         *
         * @description
         * Add the specified number of months to the given date.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The date to be changed
         * @param amount - The amount of months to be added.
         * @param options - The options object
         *
         * @returns The new date with the months added
         *
         * @example
         * // Add 5 months to 1 September 2014:
         * const result = addMonths(new Date(2014, 8, 1), 5)
         * //=> Sun Feb 01 2015 00:00:00
         *
         * // Add one month to 30 January 2023:
         * const result = addMonths(new Date(2023, 0, 30), 1)
         * //=> Tue Feb 28 2023 00:00:00
         */
        function addMonths(date, amount, options) {
          const _date = toDate$1(date, options?.in);
          if (isNaN(amount)) return constructFrom(date, NaN);
          if (!amount) {
            // If 0 months, no-op to avoid changing times in the hour before end of DST
            return _date;
          }
          const dayOfMonth = _date.getDate();

          // The JS Date object supports date math by accepting out-of-bounds values for
          // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
          // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
          // want except that dates will wrap around the end of a month, meaning that
          // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
          // we'll default to the end of the desired month by adding 1 to the desired
          // month and using a date of 0 to back up one day to the end of the desired
          // month.
          const endOfDesiredMonth = constructFrom(date, _date.getTime());
          endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
          const daysInMonth = endOfDesiredMonth.getDate();
          if (dayOfMonth >= daysInMonth) {
            // If we're already at the end of the month, then this is the correct date
            // and we're done.
            return endOfDesiredMonth;
          } else {
            // Otherwise, we now know that setting the original day-of-month value won't
            // cause an overflow, so set the desired day-of-month. Note that we can't
            // just set the date of `endOfDesiredMonth` because that object may have had
            // its time changed in the unusual case where where a DST transition was on
            // the last day of the month and its local time was in the hour skipped or
            // repeated next to a DST transition.  So we use `date` instead which is
            // guaranteed to still have the original time.
            _date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
            return _date;
          }
        }
        let defaultOptions = {};
        function getDefaultOptions$1() {
          return defaultOptions;
        }

        /**
         * The {@link startOfWeek} function options.
         */

        /**
         * @name startOfWeek
         * @category Week Helpers
         * @summary Return the start of a week for the given date.
         *
         * @description
         * Return the start of a week for the given date.
         * The result will be in the local timezone.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The original date
         * @param options - An object with options
         *
         * @returns The start of a week
         *
         * @example
         * // The start of a week for 2 September 2014 11:55:00:
         * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
         * //=> Sun Aug 31 2014 00:00:00
         *
         * @example
         * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
         * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
         * //=> Mon Sep 01 2014 00:00:00
         */
        function startOfWeek(date, options) {
          const defaultOptions = getDefaultOptions$1();
          const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
          const _date = toDate$1(date, options?.in);
          const day = _date.getDay();
          const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
          _date.setDate(_date.getDate() - diff);
          _date.setHours(0, 0, 0, 0);
          return _date;
        }

        /**
         * The {@link startOfISOWeek} function options.
         */

        /**
         * @name startOfISOWeek
         * @category ISO Week Helpers
         * @summary Return the start of an ISO week for the given date.
         *
         * @description
         * Return the start of an ISO week for the given date.
         * The result will be in the local timezone.
         *
         * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The original date
         * @param options - An object with options
         *
         * @returns The start of an ISO week
         *
         * @example
         * // The start of an ISO week for 2 September 2014 11:55:00:
         * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
         * //=> Mon Sep 01 2014 00:00:00
         */
        function startOfISOWeek(date, options) {
          return startOfWeek(date, {
            ...options,
            weekStartsOn: 1
          });
        }

        /**
         * The {@link getISOWeekYear} function options.
         */

        /**
         * @name getISOWeekYear
         * @category ISO Week-Numbering Year Helpers
         * @summary Get the ISO week-numbering year of the given date.
         *
         * @description
         * Get the ISO week-numbering year of the given date,
         * which always starts 3 days before the year's first Thursday.
         *
         * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
         *
         * @param date - The given date
         *
         * @returns The ISO week-numbering year
         *
         * @example
         * // Which ISO-week numbering year is 2 January 2005?
         * const result = getISOWeekYear(new Date(2005, 0, 2))
         * //=> 2004
         */
        function getISOWeekYear(date, options) {
          const _date = toDate$1(date, options?.in);
          const year = _date.getFullYear();
          const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
          fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
          fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
          const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
          const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
          fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
          fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
          const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
          if (_date.getTime() >= startOfNextYear.getTime()) {
            return year + 1;
          } else if (_date.getTime() >= startOfThisYear.getTime()) {
            return year;
          } else {
            return year - 1;
          }
        }

        /**
         * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
         * They usually appear for dates that denote time before the timezones were introduced
         * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
         * and GMT+01:00:00 after that date)
         *
         * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
         * which would lead to incorrect calculations.
         *
         * This function returns the timezone offset in milliseconds that takes seconds in account.
         */
        function getTimezoneOffsetInMilliseconds$1(date) {
          const _date = toDate$1(date);
          const utcDate = new Date(Date.UTC(_date.getFullYear(), _date.getMonth(), _date.getDate(), _date.getHours(), _date.getMinutes(), _date.getSeconds(), _date.getMilliseconds()));
          utcDate.setUTCFullYear(_date.getFullYear());
          return +date - +utcDate;
        }
        function normalizeDates(context, ...dates) {
          const normalize = constructFrom.bind(null, dates.find(date => typeof date === "object"));
          return dates.map(normalize);
        }

        /**
         * The {@link startOfDay} function options.
         */

        /**
         * @name startOfDay
         * @category Day Helpers
         * @summary Return the start of a day for the given date.
         *
         * @description
         * Return the start of a day for the given date.
         * The result will be in the local timezone.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The original date
         * @param options - The options
         *
         * @returns The start of a day
         *
         * @example
         * // The start of a day for 2 September 2014 11:55:00:
         * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
         * //=> Tue Sep 02 2014 00:00:00
         */
        function startOfDay(date, options) {
          const _date = toDate$1(date, options?.in);
          _date.setHours(0, 0, 0, 0);
          return _date;
        }

        /**
         * The {@link differenceInCalendarDays} function options.
         */

        /**
         * @name differenceInCalendarDays
         * @category Day Helpers
         * @summary Get the number of calendar days between the given dates.
         *
         * @description
         * Get the number of calendar days between the given dates. This means that the times are removed
         * from the dates and then the difference in days is calculated.
         *
         * @param laterDate - The later date
         * @param earlierDate - The earlier date
         * @param options - The options object
         *
         * @returns The number of calendar days
         *
         * @example
         * // How many calendar days are between
         * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
         * const result = differenceInCalendarDays(
         *   new Date(2012, 6, 2, 0, 0),
         *   new Date(2011, 6, 2, 23, 0)
         * )
         * //=> 366
         * // How many calendar days are between
         * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
         * const result = differenceInCalendarDays(
         *   new Date(2011, 6, 3, 0, 1),
         *   new Date(2011, 6, 2, 23, 59)
         * )
         * //=> 1
         */
        function differenceInCalendarDays(laterDate, earlierDate, options) {
          const [laterDate_, earlierDate_] = normalizeDates(options?.in, laterDate, earlierDate);
          const laterStartOfDay = startOfDay(laterDate_);
          const earlierStartOfDay = startOfDay(earlierDate_);
          const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds$1(laterStartOfDay);
          const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds$1(earlierStartOfDay);

          // Round the number of days to the nearest integer because the number of
          // milliseconds in a day is not constant (e.g. it's different in the week of
          // the daylight saving time clock shift).
          return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
        }

        /**
         * The {@link startOfISOWeekYear} function options.
         */

        /**
         * @name startOfISOWeekYear
         * @category ISO Week-Numbering Year Helpers
         * @summary Return the start of an ISO week-numbering year for the given date.
         *
         * @description
         * Return the start of an ISO week-numbering year,
         * which always starts 3 days before the year's first Thursday.
         * The result will be in the local timezone.
         *
         * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The original date
         * @param options - An object with options
         *
         * @returns The start of an ISO week-numbering year
         *
         * @example
         * // The start of an ISO week-numbering year for 2 July 2005:
         * const result = startOfISOWeekYear(new Date(2005, 6, 2))
         * //=> Mon Jan 03 2005 00:00:00
         */
        function startOfISOWeekYear(date, options) {
          const year = getISOWeekYear(date, options);
          const fourthOfJanuary = constructFrom(date, 0);
          fourthOfJanuary.setFullYear(year, 0, 4);
          fourthOfJanuary.setHours(0, 0, 0, 0);
          return startOfISOWeek(fourthOfJanuary);
        }

        /**
         * The {@link addMinutes} function options.
         */

        /**
         * @name addMinutes
         * @category Minute Helpers
         * @summary Add the specified number of minutes to the given date.
         *
         * @description
         * Add the specified number of minutes to the given date.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The date to be changed
         * @param amount - The amount of minutes to be added.
         * @param options - An object with options
         *
         * @returns The new date with the minutes added
         *
         * @example
         * // Add 30 minutes to 10 July 2014 12:00:00:
         * const result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
         * //=> Thu Jul 10 2014 12:30:00
         */
        function addMinutes(date, amount, options) {
          const _date = toDate$1(date, options?.in);
          _date.setTime(_date.getTime() + amount * millisecondsInMinute);
          return _date;
        }

        /**
         * @name isDate
         * @category Common Helpers
         * @summary Is the given value a date?
         *
         * @description
         * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
         *
         * @param value - The value to check
         *
         * @returns True if the given value is a date
         *
         * @example
         * // For a valid date:
         * const result = isDate(new Date())
         * //=> true
         *
         * @example
         * // For an invalid date:
         * const result = isDate(new Date(NaN))
         * //=> true
         *
         * @example
         * // For some value:
         * const result = isDate('2014-02-31')
         * //=> false
         *
         * @example
         * // For an object:
         * const result = isDate({})
         * //=> false
         */
        function isDate(value) {
          return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
        }

        /**
         * @name isValid
         * @category Common Helpers
         * @summary Is the given date valid?
         *
         * @description
         * Returns false if argument is Invalid Date and true otherwise.
         * Argument is converted to Date using `toDate`. See [toDate](https://date-fns.org/docs/toDate)
         * Invalid Date is a Date, whose time value is NaN.
         *
         * Time value of Date: http://es5.github.io/#x15.9.1.1
         *
         * @param date - The date to check
         *
         * @returns The date is valid
         *
         * @example
         * // For the valid date:
         * const result = isValid(new Date(2014, 1, 31))
         * //=> true
         *
         * @example
         * // For the value, convertible into a date:
         * const result = isValid(1393804800000)
         * //=> true
         *
         * @example
         * // For the invalid date:
         * const result = isValid(new Date(''))
         * //=> false
         */
        function isValid(date) {
          return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate$1(date)));
        }

        /**
         * The {@link differenceInCalendarMonths} function options.
         */

        /**
         * @name differenceInCalendarMonths
         * @category Month Helpers
         * @summary Get the number of calendar months between the given dates.
         *
         * @description
         * Get the number of calendar months between the given dates.
         *
         * @param laterDate - The later date
         * @param earlierDate - The earlier date
         * @param options - An object with options
         *
         * @returns The number of calendar months
         *
         * @example
         * // How many calendar months are between 31 January 2014 and 1 September 2014?
         * const result = differenceInCalendarMonths(
         *   new Date(2014, 8, 1),
         *   new Date(2014, 0, 31)
         * )
         * //=> 8
         */
        function differenceInCalendarMonths(laterDate, earlierDate, options) {
          const [laterDate_, earlierDate_] = normalizeDates(options?.in, laterDate, earlierDate);
          const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
          const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
          return yearsDiff * 12 + monthsDiff;
        }
        function getRoundingMethod(method) {
          return number => {
            const round = method ? Math[method] : Math.trunc;
            const result = round(number);
            // Prevent negative zero
            return result === 0 ? 0 : result;
          };
        }

        /**
         * @name differenceInMilliseconds
         * @category Millisecond Helpers
         * @summary Get the number of milliseconds between the given dates.
         *
         * @description
         * Get the number of milliseconds between the given dates.
         *
         * @param laterDate - The later date
         * @param earlierDate - The earlier date
         *
         * @returns The number of milliseconds
         *
         * @example
         * // How many milliseconds are between
         * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
         * const result = differenceInMilliseconds(
         *   new Date(2014, 6, 2, 12, 30, 21, 700),
         *   new Date(2014, 6, 2, 12, 30, 20, 600)
         * )
         * //=> 1100
         */
        function differenceInMilliseconds(laterDate, earlierDate) {
          return +toDate$1(laterDate) - +toDate$1(earlierDate);
        }

        /**
         * The {@link differenceInMinutes} function options.
         */

        /**
         * @name differenceInMinutes
         * @category Minute Helpers
         * @summary Get the number of minutes between the given dates.
         *
         * @description
         * Get the signed number of full (rounded towards 0) minutes between the given dates.
         *
         * @param dateLeft - The later date
         * @param dateRight - The earlier date
         * @param options - An object with options.
         *
         * @returns The number of minutes
         *
         * @example
         * // How many minutes are between 2 July 2014 12:07:59 and 2 July 2014 12:20:00?
         * const result = differenceInMinutes(
         *   new Date(2014, 6, 2, 12, 20, 0),
         *   new Date(2014, 6, 2, 12, 7, 59)
         * )
         * //=> 12
         *
         * @example
         * // How many minutes are between 10:01:59 and 10:00:00
         * const result = differenceInMinutes(
         *   new Date(2000, 0, 1, 10, 0, 0),
         *   new Date(2000, 0, 1, 10, 1, 59)
         * )
         * //=> -1
         */
        function differenceInMinutes(dateLeft, dateRight, options) {
          const diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
          return getRoundingMethod(options?.roundingMethod)(diff);
        }

        /**
         * The {@link endOfMonth} function options.
         */

        /**
         * @name endOfMonth
         * @category Month Helpers
         * @summary Return the end of a month for the given date.
         *
         * @description
         * Return the end of a month for the given date.
         * The result will be in the local timezone.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The original date
         * @param options - An object with options
         *
         * @returns The end of a month
         *
         * @example
         * // The end of a month for 2 September 2014 11:55:00:
         * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
         * //=> Tue Sep 30 2014 23:59:59.999
         */
        function endOfMonth(date, options) {
          const _date = toDate$1(date, options?.in);
          const month = _date.getMonth();
          _date.setFullYear(_date.getFullYear(), month + 1, 0);
          _date.setHours(23, 59, 59, 999);
          return _date;
        }
        function normalizeInterval(context, interval) {
          const [start, end] = normalizeDates(context, interval.start, interval.end);
          return {
            start,
            end
          };
        }

        /**
         * The {@link eachDayOfInterval} function options.
         */

        /**
         * The {@link eachDayOfInterval} function result type. It resolves the proper data type.
         * It uses the first argument date object type, starting from the date argument,
         * then the start interval date, and finally the end interval date. If
         * a context function is passed, it uses the context function return type.
         */

        /**
         * @name eachDayOfInterval
         * @category Interval Helpers
         * @summary Return the array of dates within the specified time interval.
         *
         * @description
         * Return the array of dates within the specified time interval.
         *
         * @typeParam IntervalType - Interval type.
         * @typeParam Options - Options type.
         *
         * @param interval - The interval.
         * @param options - An object with options.
         *
         * @returns The array with starts of days from the day of the interval start to the day of the interval end
         *
         * @example
         * // Each day between 6 October 2014 and 10 October 2014:
         * const result = eachDayOfInterval({
         *   start: new Date(2014, 9, 6),
         *   end: new Date(2014, 9, 10)
         * })
         * //=> [
         * //   Mon Oct 06 2014 00:00:00,
         * //   Tue Oct 07 2014 00:00:00,
         * //   Wed Oct 08 2014 00:00:00,
         * //   Thu Oct 09 2014 00:00:00,
         * //   Fri Oct 10 2014 00:00:00
         * // ]
         */
        function eachDayOfInterval(interval, options) {
          const {
            start,
            end
          } = normalizeInterval(options?.in, interval);
          let reversed = +start > +end;
          const endTime = reversed ? +start : +end;
          const date = reversed ? end : start;
          date.setHours(0, 0, 0, 0);
          let step = 1;
          const dates = [];
          while (+date <= endTime) {
            dates.push(constructFrom(start, date));
            date.setDate(date.getDate() + step);
            date.setHours(0, 0, 0, 0);
          }
          return reversed ? dates.reverse() : dates;
        }

        /**
         * The {@link startOfMonth} function options.
         */

        /**
         * @name startOfMonth
         * @category Month Helpers
         * @summary Return the start of a month for the given date.
         *
         * @description
         * Return the start of a month for the given date. The result will be in the local timezone.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments.
         * Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed,
         * or inferred from the arguments.
         *
         * @param date - The original date
         * @param options - An object with options
         *
         * @returns The start of a month
         *
         * @example
         * // The start of a month for 2 September 2014 11:55:00:
         * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
         * //=> Mon Sep 01 2014 00:00:00
         */
        function startOfMonth(date, options) {
          const _date = toDate$1(date, options?.in);
          _date.setDate(1);
          _date.setHours(0, 0, 0, 0);
          return _date;
        }

        /**
         * The {@link startOfYear} function options.
         */

        /**
         * @name startOfYear
         * @category Year Helpers
         * @summary Return the start of a year for the given date.
         *
         * @description
         * Return the start of a year for the given date.
         * The result will be in the local timezone.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The original date
         * @param options - The options
         *
         * @returns The start of a year
         *
         * @example
         * // The start of a year for 2 September 2014 11:55:00:
         * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
         * //=> Wed Jan 01 2014 00:00:00
         */
        function startOfYear(date, options) {
          const date_ = toDate$1(date, options?.in);
          date_.setFullYear(date_.getFullYear(), 0, 1);
          date_.setHours(0, 0, 0, 0);
          return date_;
        }
        const formatDistanceLocale = {
          lessThanXSeconds: {
            one: "less than a second",
            other: "less than {{count}} seconds"
          },
          xSeconds: {
            one: "1 second",
            other: "{{count}} seconds"
          },
          halfAMinute: "half a minute",
          lessThanXMinutes: {
            one: "less than a minute",
            other: "less than {{count}} minutes"
          },
          xMinutes: {
            one: "1 minute",
            other: "{{count}} minutes"
          },
          aboutXHours: {
            one: "about 1 hour",
            other: "about {{count}} hours"
          },
          xHours: {
            one: "1 hour",
            other: "{{count}} hours"
          },
          xDays: {
            one: "1 day",
            other: "{{count}} days"
          },
          aboutXWeeks: {
            one: "about 1 week",
            other: "about {{count}} weeks"
          },
          xWeeks: {
            one: "1 week",
            other: "{{count}} weeks"
          },
          aboutXMonths: {
            one: "about 1 month",
            other: "about {{count}} months"
          },
          xMonths: {
            one: "1 month",
            other: "{{count}} months"
          },
          aboutXYears: {
            one: "about 1 year",
            other: "about {{count}} years"
          },
          xYears: {
            one: "1 year",
            other: "{{count}} years"
          },
          overXYears: {
            one: "over 1 year",
            other: "over {{count}} years"
          },
          almostXYears: {
            one: "almost 1 year",
            other: "almost {{count}} years"
          }
        };
        const formatDistance = (token, count, options) => {
          let result;
          const tokenValue = formatDistanceLocale[token];
          if (typeof tokenValue === "string") {
            result = tokenValue;
          } else if (count === 1) {
            result = tokenValue.one;
          } else {
            result = tokenValue.other.replace("{{count}}", count.toString());
          }
          if (options?.addSuffix) {
            if (options.comparison && options.comparison > 0) {
              return "in " + result;
            } else {
              return result + " ago";
            }
          }
          return result;
        };
        function buildFormatLongFn(args) {
          return (options = {}) => {
            // TODO: Remove String()
            const width = options.width ? String(options.width) : args.defaultWidth;
            const format = args.formats[width] || args.formats[args.defaultWidth];
            return format;
          };
        }
        const dateFormats = {
          full: "EEEE, MMMM do, y",
          long: "MMMM do, y",
          medium: "MMM d, y",
          short: "MM/dd/yyyy"
        };
        const timeFormats = {
          full: "h:mm:ss a zzzz",
          long: "h:mm:ss a z",
          medium: "h:mm:ss a",
          short: "h:mm a"
        };
        const dateTimeFormats = {
          full: "{{date}} 'at' {{time}}",
          long: "{{date}} 'at' {{time}}",
          medium: "{{date}}, {{time}}",
          short: "{{date}}, {{time}}"
        };
        const formatLong = {
          date: buildFormatLongFn({
            formats: dateFormats,
            defaultWidth: "full"
          }),
          time: buildFormatLongFn({
            formats: timeFormats,
            defaultWidth: "full"
          }),
          dateTime: buildFormatLongFn({
            formats: dateTimeFormats,
            defaultWidth: "full"
          })
        };
        const formatRelativeLocale = {
          lastWeek: "'last' eeee 'at' p",
          yesterday: "'yesterday at' p",
          today: "'today at' p",
          tomorrow: "'tomorrow at' p",
          nextWeek: "eeee 'at' p",
          other: "P"
        };
        const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];

        /**
         * The localize function argument callback which allows to convert raw value to
         * the actual type.
         *
         * @param value - The value to convert
         *
         * @returns The converted value
         */

        /**
         * The map of localized values for each width.
         */

        /**
         * The index type of the locale unit value. It types conversion of units of
         * values that don't start at 0 (i.e. quarters).
         */

        /**
         * Converts the unit value to the tuple of values.
         */

        /**
         * The tuple of localized era values. The first element represents BC,
         * the second element represents AD.
         */

        /**
         * The tuple of localized quarter values. The first element represents Q1.
         */

        /**
         * The tuple of localized day values. The first element represents Sunday.
         */

        /**
         * The tuple of localized month values. The first element represents January.
         */

        function buildLocalizeFn(args) {
          return (value, options) => {
            const context = options?.context ? String(options.context) : "standalone";
            let valuesArray;
            if (context === "formatting" && args.formattingValues) {
              const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
              const width = options?.width ? String(options.width) : defaultWidth;
              valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
            } else {
              const defaultWidth = args.defaultWidth;
              const width = options?.width ? String(options.width) : args.defaultWidth;
              valuesArray = args.values[width] || args.values[defaultWidth];
            }
            const index = args.argumentCallback ? args.argumentCallback(value) : value;

            // @ts-expect-error - For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
            return valuesArray[index];
          };
        }
        const eraValues = {
          narrow: ["B", "A"],
          abbreviated: ["BC", "AD"],
          wide: ["Before Christ", "Anno Domini"]
        };
        const quarterValues = {
          narrow: ["1", "2", "3", "4"],
          abbreviated: ["Q1", "Q2", "Q3", "Q4"],
          wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
        };

        // Note: in English, the names of days of the week and months are capitalized.
        // If you are making a new locale based on this one, check if the same is true for the language you're working on.
        // Generally, formatted dates should look like they are in the middle of a sentence,
        // e.g. in Spanish language the weekdays and months should be in the lowercase.
        const monthValues = {
          narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
          abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        };
        const dayValues = {
          narrow: ["S", "M", "T", "W", "T", "F", "S"],
          short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
          abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        };
        const dayPeriodValues = {
          narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
          },
          abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
          },
          wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
          }
        };
        const formattingDayPeriodValues = {
          narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
          },
          abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
          },
          wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
          }
        };
        const ordinalNumber = (dirtyNumber, _options) => {
          const number = Number(dirtyNumber);

          // If ordinal numbers depend on context, for example,
          // if they are different for different grammatical genders,
          // use `options.unit`.
          //
          // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
          // 'day', 'hour', 'minute', 'second'.

          const rem100 = number % 100;
          if (rem100 > 20 || rem100 < 10) {
            switch (rem100 % 10) {
              case 1:
                return number + "st";
              case 2:
                return number + "nd";
              case 3:
                return number + "rd";
            }
          }
          return number + "th";
        };
        const localize = {
          ordinalNumber,
          era: buildLocalizeFn({
            values: eraValues,
            defaultWidth: "wide"
          }),
          quarter: buildLocalizeFn({
            values: quarterValues,
            defaultWidth: "wide",
            argumentCallback: quarter => quarter - 1
          }),
          month: buildLocalizeFn({
            values: monthValues,
            defaultWidth: "wide"
          }),
          day: buildLocalizeFn({
            values: dayValues,
            defaultWidth: "wide"
          }),
          dayPeriod: buildLocalizeFn({
            values: dayPeriodValues,
            defaultWidth: "wide",
            formattingValues: formattingDayPeriodValues,
            defaultFormattingWidth: "wide"
          })
        };
        function buildMatchFn(args) {
          return (string, options = {}) => {
            const width = options.width;
            const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
            const matchResult = string.match(matchPattern);
            if (!matchResult) {
              return null;
            }
            const matchedString = matchResult[0];
            const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
            const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, pattern => pattern.test(matchedString)) :
            // [TODO] -- I challenge you to fix the type
            findKey(parsePatterns, pattern => pattern.test(matchedString));
            let value;
            value = args.valueCallback ? args.valueCallback(key) : key;
            value = options.valueCallback ?
            // [TODO] -- I challenge you to fix the type
            options.valueCallback(value) : value;
            const rest = string.slice(matchedString.length);
            return {
              value,
              rest
            };
          };
        }
        function findKey(object, predicate) {
          for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
              return key;
            }
          }
          return undefined;
        }
        function findIndex(array, predicate) {
          for (let key = 0; key < array.length; key++) {
            if (predicate(array[key])) {
              return key;
            }
          }
          return undefined;
        }
        function buildMatchPatternFn(args) {
          return (string, options = {}) => {
            const matchResult = string.match(args.matchPattern);
            if (!matchResult) return null;
            const matchedString = matchResult[0];
            const parseResult = string.match(args.parsePattern);
            if (!parseResult) return null;
            let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];

            // [TODO] I challenge you to fix the type
            value = options.valueCallback ? options.valueCallback(value) : value;
            const rest = string.slice(matchedString.length);
            return {
              value,
              rest
            };
          };
        }
        const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
        const parseOrdinalNumberPattern = /\d+/i;
        const matchEraPatterns = {
          narrow: /^(b|a)/i,
          abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
          wide: /^(before christ|before common era|anno domini|common era)/i
        };
        const parseEraPatterns = {
          any: [/^b/i, /^(a|c)/i]
        };
        const matchQuarterPatterns = {
          narrow: /^[1234]/i,
          abbreviated: /^q[1234]/i,
          wide: /^[1234](th|st|nd|rd)? quarter/i
        };
        const parseQuarterPatterns = {
          any: [/1/i, /2/i, /3/i, /4/i]
        };
        const matchMonthPatterns = {
          narrow: /^[jfmasond]/i,
          abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
          wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
        };
        const parseMonthPatterns = {
          narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
          any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
        };
        const matchDayPatterns = {
          narrow: /^[smtwf]/i,
          short: /^(su|mo|tu|we|th|fr|sa)/i,
          abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
          wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
        };
        const parseDayPatterns = {
          narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
          any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
        };
        const matchDayPeriodPatterns = {
          narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
          any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
        };
        const parseDayPeriodPatterns = {
          any: {
            am: /^a/i,
            pm: /^p/i,
            midnight: /^mi/i,
            noon: /^no/i,
            morning: /morning/i,
            afternoon: /afternoon/i,
            evening: /evening/i,
            night: /night/i
          }
        };
        const match = {
          ordinalNumber: buildMatchPatternFn({
            matchPattern: matchOrdinalNumberPattern,
            parsePattern: parseOrdinalNumberPattern,
            valueCallback: value => parseInt(value, 10)
          }),
          era: buildMatchFn({
            matchPatterns: matchEraPatterns,
            defaultMatchWidth: "wide",
            parsePatterns: parseEraPatterns,
            defaultParseWidth: "any"
          }),
          quarter: buildMatchFn({
            matchPatterns: matchQuarterPatterns,
            defaultMatchWidth: "wide",
            parsePatterns: parseQuarterPatterns,
            defaultParseWidth: "any",
            valueCallback: index => index + 1
          }),
          month: buildMatchFn({
            matchPatterns: matchMonthPatterns,
            defaultMatchWidth: "wide",
            parsePatterns: parseMonthPatterns,
            defaultParseWidth: "any"
          }),
          day: buildMatchFn({
            matchPatterns: matchDayPatterns,
            defaultMatchWidth: "wide",
            parsePatterns: parseDayPatterns,
            defaultParseWidth: "any"
          }),
          dayPeriod: buildMatchFn({
            matchPatterns: matchDayPeriodPatterns,
            defaultMatchWidth: "any",
            parsePatterns: parseDayPeriodPatterns,
            defaultParseWidth: "any"
          })
        };

        /**
         * @category Locales
         * @summary English locale (United States).
         * @language English
         * @iso-639-2 eng
         * @author Sasha Koss [@kossnocorp](https://github.com/kossnocorp)
         * @author Lesha Koss [@leshakoss](https://github.com/leshakoss)
         */
        const enUS = {
          code: "en-US",
          formatDistance: formatDistance,
          formatLong: formatLong,
          formatRelative: formatRelative,
          localize: localize,
          match: match,
          options: {
            weekStartsOn: 0 /* Sunday */,
            firstWeekContainsDate: 1
          }
        };

        /**
         * The {@link getDayOfYear} function options.
         */

        /**
         * @name getDayOfYear
         * @category Day Helpers
         * @summary Get the day of the year of the given date.
         *
         * @description
         * Get the day of the year of the given date.
         *
         * @param date - The given date
         * @param options - The options
         *
         * @returns The day of year
         *
         * @example
         * // Which day of the year is 2 July 2014?
         * const result = getDayOfYear(new Date(2014, 6, 2))
         * //=> 183
         */
        function getDayOfYear(date, options) {
          const _date = toDate$1(date, options?.in);
          const diff = differenceInCalendarDays(_date, startOfYear(_date));
          const dayOfYear = diff + 1;
          return dayOfYear;
        }

        /**
         * The {@link getISOWeek} function options.
         */

        /**
         * @name getISOWeek
         * @category ISO Week Helpers
         * @summary Get the ISO week of the given date.
         *
         * @description
         * Get the ISO week of the given date.
         *
         * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
         *
         * @param date - The given date
         * @param options - The options
         *
         * @returns The ISO week
         *
         * @example
         * // Which week of the ISO-week numbering year is 2 January 2005?
         * const result = getISOWeek(new Date(2005, 0, 2))
         * //=> 53
         */
        function getISOWeek(date, options) {
          const _date = toDate$1(date, options?.in);
          const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);

          // Round the number of weeks to the nearest integer because the number of
          // milliseconds in a week is not constant (e.g. it's different in the week of
          // the daylight saving time clock shift).
          return Math.round(diff / millisecondsInWeek) + 1;
        }

        /**
         * The {@link getWeekYear} function options.
         */

        /**
         * @name getWeekYear
         * @category Week-Numbering Year Helpers
         * @summary Get the local week-numbering year of the given date.
         *
         * @description
         * Get the local week-numbering year of the given date.
         * The exact calculation depends on the values of
         * `options.weekStartsOn` (which is the index of the first day of the week)
         * and `options.firstWeekContainsDate` (which is the day of January, which is always in
         * the first week of the week-numbering year)
         *
         * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
         *
         * @param date - The given date
         * @param options - An object with options.
         *
         * @returns The local week-numbering year
         *
         * @example
         * // Which week numbering year is 26 December 2004 with the default settings?
         * const result = getWeekYear(new Date(2004, 11, 26))
         * //=> 2005
         *
         * @example
         * // Which week numbering year is 26 December 2004 if week starts on Saturday?
         * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
         * //=> 2004
         *
         * @example
         * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
         * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
         * //=> 2004
         */
        function getWeekYear(date, options) {
          const _date = toDate$1(date, options?.in);
          const year = _date.getFullYear();
          const defaultOptions = getDefaultOptions$1();
          const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions.firstWeekContainsDate ?? defaultOptions.locale?.options?.firstWeekContainsDate ?? 1;
          const firstWeekOfNextYear = constructFrom(options?.in || date, 0);
          firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
          firstWeekOfNextYear.setHours(0, 0, 0, 0);
          const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
          const firstWeekOfThisYear = constructFrom(options?.in || date, 0);
          firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
          firstWeekOfThisYear.setHours(0, 0, 0, 0);
          const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
          if (+_date >= +startOfNextYear) {
            return year + 1;
          } else if (+_date >= +startOfThisYear) {
            return year;
          } else {
            return year - 1;
          }
        }

        /**
         * The {@link startOfWeekYear} function options.
         */

        /**
         * @name startOfWeekYear
         * @category Week-Numbering Year Helpers
         * @summary Return the start of a local week-numbering year for the given date.
         *
         * @description
         * Return the start of a local week-numbering year.
         * The exact calculation depends on the values of
         * `options.weekStartsOn` (which is the index of the first day of the week)
         * and `options.firstWeekContainsDate` (which is the day of January, which is always in
         * the first week of the week-numbering year)
         *
         * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type.
         *
         * @param date - The original date
         * @param options - An object with options
         *
         * @returns The start of a week-numbering year
         *
         * @example
         * // The start of an a week-numbering year for 2 July 2005 with default settings:
         * const result = startOfWeekYear(new Date(2005, 6, 2))
         * //=> Sun Dec 26 2004 00:00:00
         *
         * @example
         * // The start of a week-numbering year for 2 July 2005
         * // if Monday is the first day of week
         * // and 4 January is always in the first week of the year:
         * const result = startOfWeekYear(new Date(2005, 6, 2), {
         *   weekStartsOn: 1,
         *   firstWeekContainsDate: 4
         * })
         * //=> Mon Jan 03 2005 00:00:00
         */
        function startOfWeekYear(date, options) {
          const defaultOptions = getDefaultOptions$1();
          const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions.firstWeekContainsDate ?? defaultOptions.locale?.options?.firstWeekContainsDate ?? 1;
          const year = getWeekYear(date, options);
          const firstWeek = constructFrom(options?.in || date, 0);
          firstWeek.setFullYear(year, 0, firstWeekContainsDate);
          firstWeek.setHours(0, 0, 0, 0);
          const _date = startOfWeek(firstWeek, options);
          return _date;
        }

        /**
         * The {@link getWeek} function options.
         */

        /**
         * @name getWeek
         * @category Week Helpers
         * @summary Get the local week index of the given date.
         *
         * @description
         * Get the local week index of the given date.
         * The exact calculation depends on the values of
         * `options.weekStartsOn` (which is the index of the first day of the week)
         * and `options.firstWeekContainsDate` (which is the day of January, which is always in
         * the first week of the week-numbering year)
         *
         * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
         *
         * @param date - The given date
         * @param options - An object with options
         *
         * @returns The week
         *
         * @example
         * // Which week of the local week numbering year is 2 January 2005 with default options?
         * const result = getWeek(new Date(2005, 0, 2))
         * //=> 2
         *
         * @example
         * // Which week of the local week numbering year is 2 January 2005,
         * // if Monday is the first day of the week,
         * // and the first week of the year always contains 4 January?
         * const result = getWeek(new Date(2005, 0, 2), {
         *   weekStartsOn: 1,
         *   firstWeekContainsDate: 4
         * })
         * //=> 53
         */
        function getWeek(date, options) {
          const _date = toDate$1(date, options?.in);
          const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);

          // Round the number of weeks to the nearest integer because the number of
          // milliseconds in a week is not constant (e.g. it's different in the week of
          // the daylight saving time clock shift).
          return Math.round(diff / millisecondsInWeek) + 1;
        }
        function addLeadingZeros$1(number, targetLength) {
          const sign = number < 0 ? "-" : "";
          const output = Math.abs(number).toString().padStart(targetLength, "0");
          return sign + output;
        }

        /*
         * |     | Unit                           |     | Unit                           |
         * |-----|--------------------------------|-----|--------------------------------|
         * |  a  | AM, PM                         |  A* |                                |
         * |  d  | Day of month                   |  D  |                                |
         * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
         * |  m  | Minute                         |  M  | Month                          |
         * |  s  | Second                         |  S  | Fraction of second             |
         * |  y  | Year (abs)                     |  Y  |                                |
         *
         * Letters marked by * are not implemented but reserved by Unicode standard.
         */

        const lightFormatters = {
          // Year
          y(date, token) {
            // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
            // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
            // |----------|-------|----|-------|-------|-------|
            // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
            // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
            // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
            // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
            // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

            const signedYear = date.getFullYear();
            // Returns 1 for 1 BC (which is year 0 in JavaScript)
            const year = signedYear > 0 ? signedYear : 1 - signedYear;
            return addLeadingZeros$1(token === "yy" ? year % 100 : year, token.length);
          },
          // Month
          M(date, token) {
            const month = date.getMonth();
            return token === "M" ? String(month + 1) : addLeadingZeros$1(month + 1, 2);
          },
          // Day of the month
          d(date, token) {
            return addLeadingZeros$1(date.getDate(), token.length);
          },
          // AM or PM
          a(date, token) {
            const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
            switch (token) {
              case "a":
              case "aa":
                return dayPeriodEnumValue.toUpperCase();
              case "aaa":
                return dayPeriodEnumValue;
              case "aaaaa":
                return dayPeriodEnumValue[0];
              case "aaaa":
              default:
                return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
            }
          },
          // Hour [1-12]
          h(date, token) {
            return addLeadingZeros$1(date.getHours() % 12 || 12, token.length);
          },
          // Hour [0-23]
          H(date, token) {
            return addLeadingZeros$1(date.getHours(), token.length);
          },
          // Minute
          m(date, token) {
            return addLeadingZeros$1(date.getMinutes(), token.length);
          },
          // Second
          s(date, token) {
            return addLeadingZeros$1(date.getSeconds(), token.length);
          },
          // Fraction of second
          S(date, token) {
            const numberOfDigits = token.length;
            const milliseconds = date.getMilliseconds();
            const fractionalSeconds = Math.trunc(milliseconds * Math.pow(10, numberOfDigits - 3));
            return addLeadingZeros$1(fractionalSeconds, token.length);
          }
        };
        const dayPeriodEnum = {
          midnight: "midnight",
          noon: "noon",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        };

        /*
         * |     | Unit                           |     | Unit                           |
         * |-----|--------------------------------|-----|--------------------------------|
         * |  a  | AM, PM                         |  A* | Milliseconds in day            |
         * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
         * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
         * |  d  | Day of month                   |  D  | Day of year                    |
         * |  e  | Local day of week              |  E  | Day of week                    |
         * |  f  |                                |  F* | Day of week in month           |
         * |  g* | Modified Julian day            |  G  | Era                            |
         * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
         * |  i! | ISO day of week                |  I! | ISO week of year               |
         * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
         * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
         * |  l* | (deprecated)                   |  L  | Stand-alone month              |
         * |  m  | Minute                         |  M  | Month                          |
         * |  n  |                                |  N  |                                |
         * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
         * |  p! | Long localized time            |  P! | Long localized date            |
         * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
         * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
         * |  s  | Second                         |  S  | Fraction of second             |
         * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
         * |  u  | Extended year                  |  U* | Cyclic year                    |
         * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
         * |  w  | Local week of year             |  W* | Week of month                  |
         * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
         * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
         * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
         *
         * Letters marked by * are not implemented but reserved by Unicode standard.
         *
         * Letters marked by ! are non-standard, but implemented by date-fns:
         * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
         * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
         *   i.e. 7 for Sunday, 1 for Monday, etc.
         * - `I` is ISO week of year, as opposed to `w` which is local week of year.
         * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
         *   `R` is supposed to be used in conjunction with `I` and `i`
         *   for universal ISO week-numbering date, whereas
         *   `Y` is supposed to be used in conjunction with `w` and `e`
         *   for week-numbering date specific to the locale.
         * - `P` is long localized date format
         * - `p` is long localized time format
         */

        const formatters$1 = {
          // Era
          G: function (date, token, localize) {
            const era = date.getFullYear() > 0 ? 1 : 0;
            switch (token) {
              // AD, BC
              case "G":
              case "GG":
              case "GGG":
                return localize.era(era, {
                  width: "abbreviated"
                });
              // A, B
              case "GGGGG":
                return localize.era(era, {
                  width: "narrow"
                });
              // Anno Domini, Before Christ
              case "GGGG":
              default:
                return localize.era(era, {
                  width: "wide"
                });
            }
          },
          // Year
          y: function (date, token, localize) {
            // Ordinal number
            if (token === "yo") {
              const signedYear = date.getFullYear();
              // Returns 1 for 1 BC (which is year 0 in JavaScript)
              const year = signedYear > 0 ? signedYear : 1 - signedYear;
              return localize.ordinalNumber(year, {
                unit: "year"
              });
            }
            return lightFormatters.y(date, token);
          },
          // Local week-numbering year
          Y: function (date, token, localize, options) {
            const signedWeekYear = getWeekYear(date, options);
            // Returns 1 for 1 BC (which is year 0 in JavaScript)
            const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

            // Two digit year
            if (token === "YY") {
              const twoDigitYear = weekYear % 100;
              return addLeadingZeros$1(twoDigitYear, 2);
            }

            // Ordinal number
            if (token === "Yo") {
              return localize.ordinalNumber(weekYear, {
                unit: "year"
              });
            }

            // Padding
            return addLeadingZeros$1(weekYear, token.length);
          },
          // ISO week-numbering year
          R: function (date, token) {
            const isoWeekYear = getISOWeekYear(date);

            // Padding
            return addLeadingZeros$1(isoWeekYear, token.length);
          },
          // Extended year. This is a single number designating the year of this calendar system.
          // The main difference between `y` and `u` localizers are B.C. years:
          // | Year | `y` | `u` |
          // |------|-----|-----|
          // | AC 1 |   1 |   1 |
          // | BC 1 |   1 |   0 |
          // | BC 2 |   2 |  -1 |
          // Also `yy` always returns the last two digits of a year,
          // while `uu` pads single digit years to 2 characters and returns other years unchanged.
          u: function (date, token) {
            const year = date.getFullYear();
            return addLeadingZeros$1(year, token.length);
          },
          // Quarter
          Q: function (date, token, localize) {
            const quarter = Math.ceil((date.getMonth() + 1) / 3);
            switch (token) {
              // 1, 2, 3, 4
              case "Q":
                return String(quarter);
              // 01, 02, 03, 04
              case "QQ":
                return addLeadingZeros$1(quarter, 2);
              // 1st, 2nd, 3rd, 4th
              case "Qo":
                return localize.ordinalNumber(quarter, {
                  unit: "quarter"
                });
              // Q1, Q2, Q3, Q4
              case "QQQ":
                return localize.quarter(quarter, {
                  width: "abbreviated",
                  context: "formatting"
                });
              // 1, 2, 3, 4 (narrow quarter; could be not numerical)
              case "QQQQQ":
                return localize.quarter(quarter, {
                  width: "narrow",
                  context: "formatting"
                });
              // 1st quarter, 2nd quarter, ...
              case "QQQQ":
              default:
                return localize.quarter(quarter, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // Stand-alone quarter
          q: function (date, token, localize) {
            const quarter = Math.ceil((date.getMonth() + 1) / 3);
            switch (token) {
              // 1, 2, 3, 4
              case "q":
                return String(quarter);
              // 01, 02, 03, 04
              case "qq":
                return addLeadingZeros$1(quarter, 2);
              // 1st, 2nd, 3rd, 4th
              case "qo":
                return localize.ordinalNumber(quarter, {
                  unit: "quarter"
                });
              // Q1, Q2, Q3, Q4
              case "qqq":
                return localize.quarter(quarter, {
                  width: "abbreviated",
                  context: "standalone"
                });
              // 1, 2, 3, 4 (narrow quarter; could be not numerical)
              case "qqqqq":
                return localize.quarter(quarter, {
                  width: "narrow",
                  context: "standalone"
                });
              // 1st quarter, 2nd quarter, ...
              case "qqqq":
              default:
                return localize.quarter(quarter, {
                  width: "wide",
                  context: "standalone"
                });
            }
          },
          // Month
          M: function (date, token, localize) {
            const month = date.getMonth();
            switch (token) {
              case "M":
              case "MM":
                return lightFormatters.M(date, token);
              // 1st, 2nd, ..., 12th
              case "Mo":
                return localize.ordinalNumber(month + 1, {
                  unit: "month"
                });
              // Jan, Feb, ..., Dec
              case "MMM":
                return localize.month(month, {
                  width: "abbreviated",
                  context: "formatting"
                });
              // J, F, ..., D
              case "MMMMM":
                return localize.month(month, {
                  width: "narrow",
                  context: "formatting"
                });
              // January, February, ..., December
              case "MMMM":
              default:
                return localize.month(month, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // Stand-alone month
          L: function (date, token, localize) {
            const month = date.getMonth();
            switch (token) {
              // 1, 2, ..., 12
              case "L":
                return String(month + 1);
              // 01, 02, ..., 12
              case "LL":
                return addLeadingZeros$1(month + 1, 2);
              // 1st, 2nd, ..., 12th
              case "Lo":
                return localize.ordinalNumber(month + 1, {
                  unit: "month"
                });
              // Jan, Feb, ..., Dec
              case "LLL":
                return localize.month(month, {
                  width: "abbreviated",
                  context: "standalone"
                });
              // J, F, ..., D
              case "LLLLL":
                return localize.month(month, {
                  width: "narrow",
                  context: "standalone"
                });
              // January, February, ..., December
              case "LLLL":
              default:
                return localize.month(month, {
                  width: "wide",
                  context: "standalone"
                });
            }
          },
          // Local week of year
          w: function (date, token, localize, options) {
            const week = getWeek(date, options);
            if (token === "wo") {
              return localize.ordinalNumber(week, {
                unit: "week"
              });
            }
            return addLeadingZeros$1(week, token.length);
          },
          // ISO week of year
          I: function (date, token, localize) {
            const isoWeek = getISOWeek(date);
            if (token === "Io") {
              return localize.ordinalNumber(isoWeek, {
                unit: "week"
              });
            }
            return addLeadingZeros$1(isoWeek, token.length);
          },
          // Day of the month
          d: function (date, token, localize) {
            if (token === "do") {
              return localize.ordinalNumber(date.getDate(), {
                unit: "date"
              });
            }
            return lightFormatters.d(date, token);
          },
          // Day of year
          D: function (date, token, localize) {
            const dayOfYear = getDayOfYear(date);
            if (token === "Do") {
              return localize.ordinalNumber(dayOfYear, {
                unit: "dayOfYear"
              });
            }
            return addLeadingZeros$1(dayOfYear, token.length);
          },
          // Day of week
          E: function (date, token, localize) {
            const dayOfWeek = date.getDay();
            switch (token) {
              // Tue
              case "E":
              case "EE":
              case "EEE":
                return localize.day(dayOfWeek, {
                  width: "abbreviated",
                  context: "formatting"
                });
              // T
              case "EEEEE":
                return localize.day(dayOfWeek, {
                  width: "narrow",
                  context: "formatting"
                });
              // Tu
              case "EEEEEE":
                return localize.day(dayOfWeek, {
                  width: "short",
                  context: "formatting"
                });
              // Tuesday
              case "EEEE":
              default:
                return localize.day(dayOfWeek, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // Local day of week
          e: function (date, token, localize, options) {
            const dayOfWeek = date.getDay();
            const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
            switch (token) {
              // Numerical value (Nth day of week with current locale or weekStartsOn)
              case "e":
                return String(localDayOfWeek);
              // Padded numerical value
              case "ee":
                return addLeadingZeros$1(localDayOfWeek, 2);
              // 1st, 2nd, ..., 7th
              case "eo":
                return localize.ordinalNumber(localDayOfWeek, {
                  unit: "day"
                });
              case "eee":
                return localize.day(dayOfWeek, {
                  width: "abbreviated",
                  context: "formatting"
                });
              // T
              case "eeeee":
                return localize.day(dayOfWeek, {
                  width: "narrow",
                  context: "formatting"
                });
              // Tu
              case "eeeeee":
                return localize.day(dayOfWeek, {
                  width: "short",
                  context: "formatting"
                });
              // Tuesday
              case "eeee":
              default:
                return localize.day(dayOfWeek, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // Stand-alone local day of week
          c: function (date, token, localize, options) {
            const dayOfWeek = date.getDay();
            const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
            switch (token) {
              // Numerical value (same as in `e`)
              case "c":
                return String(localDayOfWeek);
              // Padded numerical value
              case "cc":
                return addLeadingZeros$1(localDayOfWeek, token.length);
              // 1st, 2nd, ..., 7th
              case "co":
                return localize.ordinalNumber(localDayOfWeek, {
                  unit: "day"
                });
              case "ccc":
                return localize.day(dayOfWeek, {
                  width: "abbreviated",
                  context: "standalone"
                });
              // T
              case "ccccc":
                return localize.day(dayOfWeek, {
                  width: "narrow",
                  context: "standalone"
                });
              // Tu
              case "cccccc":
                return localize.day(dayOfWeek, {
                  width: "short",
                  context: "standalone"
                });
              // Tuesday
              case "cccc":
              default:
                return localize.day(dayOfWeek, {
                  width: "wide",
                  context: "standalone"
                });
            }
          },
          // ISO day of week
          i: function (date, token, localize) {
            const dayOfWeek = date.getDay();
            const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
            switch (token) {
              // 2
              case "i":
                return String(isoDayOfWeek);
              // 02
              case "ii":
                return addLeadingZeros$1(isoDayOfWeek, token.length);
              // 2nd
              case "io":
                return localize.ordinalNumber(isoDayOfWeek, {
                  unit: "day"
                });
              // Tue
              case "iii":
                return localize.day(dayOfWeek, {
                  width: "abbreviated",
                  context: "formatting"
                });
              // T
              case "iiiii":
                return localize.day(dayOfWeek, {
                  width: "narrow",
                  context: "formatting"
                });
              // Tu
              case "iiiiii":
                return localize.day(dayOfWeek, {
                  width: "short",
                  context: "formatting"
                });
              // Tuesday
              case "iiii":
              default:
                return localize.day(dayOfWeek, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // AM or PM
          a: function (date, token, localize) {
            const hours = date.getHours();
            const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
            switch (token) {
              case "a":
              case "aa":
                return localize.dayPeriod(dayPeriodEnumValue, {
                  width: "abbreviated",
                  context: "formatting"
                });
              case "aaa":
                return localize.dayPeriod(dayPeriodEnumValue, {
                  width: "abbreviated",
                  context: "formatting"
                }).toLowerCase();
              case "aaaaa":
                return localize.dayPeriod(dayPeriodEnumValue, {
                  width: "narrow",
                  context: "formatting"
                });
              case "aaaa":
              default:
                return localize.dayPeriod(dayPeriodEnumValue, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // AM, PM, midnight, noon
          b: function (date, token, localize) {
            const hours = date.getHours();
            let dayPeriodEnumValue;
            if (hours === 12) {
              dayPeriodEnumValue = dayPeriodEnum.noon;
            } else if (hours === 0) {
              dayPeriodEnumValue = dayPeriodEnum.midnight;
            } else {
              dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
            }
            switch (token) {
              case "b":
              case "bb":
                return localize.dayPeriod(dayPeriodEnumValue, {
                  width: "abbreviated",
                  context: "formatting"
                });
              case "bbb":
                return localize.dayPeriod(dayPeriodEnumValue, {
                  width: "abbreviated",
                  context: "formatting"
                }).toLowerCase();
              case "bbbbb":
                return localize.dayPeriod(dayPeriodEnumValue, {
                  width: "narrow",
                  context: "formatting"
                });
              case "bbbb":
              default:
                return localize.dayPeriod(dayPeriodEnumValue, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // in the morning, in the afternoon, in the evening, at night
          B: function (date, token, localize) {
            const hours = date.getHours();
            let dayPeriodEnumValue;
            if (hours >= 17) {
              dayPeriodEnumValue = dayPeriodEnum.evening;
            } else if (hours >= 12) {
              dayPeriodEnumValue = dayPeriodEnum.afternoon;
            } else if (hours >= 4) {
              dayPeriodEnumValue = dayPeriodEnum.morning;
            } else {
              dayPeriodEnumValue = dayPeriodEnum.night;
            }
            switch (token) {
              case "B":
              case "BB":
              case "BBB":
                return localize.dayPeriod(dayPeriodEnumValue, {
                  width: "abbreviated",
                  context: "formatting"
                });
              case "BBBBB":
                return localize.dayPeriod(dayPeriodEnumValue, {
                  width: "narrow",
                  context: "formatting"
                });
              case "BBBB":
              default:
                return localize.dayPeriod(dayPeriodEnumValue, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // Hour [1-12]
          h: function (date, token, localize) {
            if (token === "ho") {
              let hours = date.getHours() % 12;
              if (hours === 0) hours = 12;
              return localize.ordinalNumber(hours, {
                unit: "hour"
              });
            }
            return lightFormatters.h(date, token);
          },
          // Hour [0-23]
          H: function (date, token, localize) {
            if (token === "Ho") {
              return localize.ordinalNumber(date.getHours(), {
                unit: "hour"
              });
            }
            return lightFormatters.H(date, token);
          },
          // Hour [0-11]
          K: function (date, token, localize) {
            const hours = date.getHours() % 12;
            if (token === "Ko") {
              return localize.ordinalNumber(hours, {
                unit: "hour"
              });
            }
            return addLeadingZeros$1(hours, token.length);
          },
          // Hour [1-24]
          k: function (date, token, localize) {
            let hours = date.getHours();
            if (hours === 0) hours = 24;
            if (token === "ko") {
              return localize.ordinalNumber(hours, {
                unit: "hour"
              });
            }
            return addLeadingZeros$1(hours, token.length);
          },
          // Minute
          m: function (date, token, localize) {
            if (token === "mo") {
              return localize.ordinalNumber(date.getMinutes(), {
                unit: "minute"
              });
            }
            return lightFormatters.m(date, token);
          },
          // Second
          s: function (date, token, localize) {
            if (token === "so") {
              return localize.ordinalNumber(date.getSeconds(), {
                unit: "second"
              });
            }
            return lightFormatters.s(date, token);
          },
          // Fraction of second
          S: function (date, token) {
            return lightFormatters.S(date, token);
          },
          // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
          X: function (date, token, _localize) {
            const timezoneOffset = date.getTimezoneOffset();
            if (timezoneOffset === 0) {
              return "Z";
            }
            switch (token) {
              // Hours and optional minutes
              case "X":
                return formatTimezoneWithOptionalMinutes$1(timezoneOffset);

              // Hours, minutes and optional seconds without `:` delimiter
              // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
              // so this token always has the same output as `XX`
              case "XXXX":
              case "XX":
                // Hours and minutes without `:` delimiter
                return formatTimezone$1(timezoneOffset);

              // Hours, minutes and optional seconds with `:` delimiter
              // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
              // so this token always has the same output as `XXX`
              case "XXXXX":
              case "XXX": // Hours and minutes with `:` delimiter
              default:
                return formatTimezone$1(timezoneOffset, ":");
            }
          },
          // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
          x: function (date, token, _localize) {
            const timezoneOffset = date.getTimezoneOffset();
            switch (token) {
              // Hours and optional minutes
              case "x":
                return formatTimezoneWithOptionalMinutes$1(timezoneOffset);

              // Hours, minutes and optional seconds without `:` delimiter
              // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
              // so this token always has the same output as `xx`
              case "xxxx":
              case "xx":
                // Hours and minutes without `:` delimiter
                return formatTimezone$1(timezoneOffset);

              // Hours, minutes and optional seconds with `:` delimiter
              // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
              // so this token always has the same output as `xxx`
              case "xxxxx":
              case "xxx": // Hours and minutes with `:` delimiter
              default:
                return formatTimezone$1(timezoneOffset, ":");
            }
          },
          // Timezone (GMT)
          O: function (date, token, _localize) {
            const timezoneOffset = date.getTimezoneOffset();
            switch (token) {
              // Short
              case "O":
              case "OO":
              case "OOO":
                return "GMT" + formatTimezoneShort$1(timezoneOffset, ":");
              // Long
              case "OOOO":
              default:
                return "GMT" + formatTimezone$1(timezoneOffset, ":");
            }
          },
          // Timezone (specific non-location)
          z: function (date, token, _localize) {
            const timezoneOffset = date.getTimezoneOffset();
            switch (token) {
              // Short
              case "z":
              case "zz":
              case "zzz":
                return "GMT" + formatTimezoneShort$1(timezoneOffset, ":");
              // Long
              case "zzzz":
              default:
                return "GMT" + formatTimezone$1(timezoneOffset, ":");
            }
          },
          // Seconds timestamp
          t: function (date, token, _localize) {
            const timestamp = Math.trunc(+date / 1000);
            return addLeadingZeros$1(timestamp, token.length);
          },
          // Milliseconds timestamp
          T: function (date, token, _localize) {
            return addLeadingZeros$1(+date, token.length);
          }
        };
        function formatTimezoneShort$1(offset, delimiter = "") {
          const sign = offset > 0 ? "-" : "+";
          const absOffset = Math.abs(offset);
          const hours = Math.trunc(absOffset / 60);
          const minutes = absOffset % 60;
          if (minutes === 0) {
            return sign + String(hours);
          }
          return sign + String(hours) + delimiter + addLeadingZeros$1(minutes, 2);
        }
        function formatTimezoneWithOptionalMinutes$1(offset, delimiter) {
          if (offset % 60 === 0) {
            const sign = offset > 0 ? "-" : "+";
            return sign + addLeadingZeros$1(Math.abs(offset) / 60, 2);
          }
          return formatTimezone$1(offset, delimiter);
        }
        function formatTimezone$1(offset, delimiter = "") {
          const sign = offset > 0 ? "-" : "+";
          const absOffset = Math.abs(offset);
          const hours = addLeadingZeros$1(Math.trunc(absOffset / 60), 2);
          const minutes = addLeadingZeros$1(absOffset % 60, 2);
          return sign + hours + delimiter + minutes;
        }
        const dateLongFormatter = (pattern, formatLong) => {
          switch (pattern) {
            case "P":
              return formatLong.date({
                width: "short"
              });
            case "PP":
              return formatLong.date({
                width: "medium"
              });
            case "PPP":
              return formatLong.date({
                width: "long"
              });
            case "PPPP":
            default:
              return formatLong.date({
                width: "full"
              });
          }
        };
        const timeLongFormatter = (pattern, formatLong) => {
          switch (pattern) {
            case "p":
              return formatLong.time({
                width: "short"
              });
            case "pp":
              return formatLong.time({
                width: "medium"
              });
            case "ppp":
              return formatLong.time({
                width: "long"
              });
            case "pppp":
            default:
              return formatLong.time({
                width: "full"
              });
          }
        };
        const dateTimeLongFormatter = (pattern, formatLong) => {
          const matchResult = pattern.match(/(P+)(p+)?/) || [];
          const datePattern = matchResult[1];
          const timePattern = matchResult[2];
          if (!timePattern) {
            return dateLongFormatter(pattern, formatLong);
          }
          let dateTimeFormat;
          switch (datePattern) {
            case "P":
              dateTimeFormat = formatLong.dateTime({
                width: "short"
              });
              break;
            case "PP":
              dateTimeFormat = formatLong.dateTime({
                width: "medium"
              });
              break;
            case "PPP":
              dateTimeFormat = formatLong.dateTime({
                width: "long"
              });
              break;
            case "PPPP":
            default:
              dateTimeFormat = formatLong.dateTime({
                width: "full"
              });
              break;
          }
          return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong)).replace("{{time}}", timeLongFormatter(timePattern, formatLong));
        };
        const longFormatters = {
          p: timeLongFormatter,
          P: dateTimeLongFormatter
        };
        const dayOfYearTokenRE = /^D+$/;
        const weekYearTokenRE = /^Y+$/;
        const throwTokens = ["D", "DD", "YY", "YYYY"];
        function isProtectedDayOfYearToken(token) {
          return dayOfYearTokenRE.test(token);
        }
        function isProtectedWeekYearToken(token) {
          return weekYearTokenRE.test(token);
        }
        function warnOrThrowProtectedError(token, format, input) {
          const _message = message(token, format, input);
          console.warn(_message);
          if (throwTokens.includes(token)) throw new RangeError(_message);
        }
        function message(token, format, input) {
          const subject = token[0] === "Y" ? "years" : "days of the month";
          return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
        }

        // This RegExp consists of three parts separated by `|`:
        // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
        //   (one of the certain letters followed by `o`)
        // - (\w)\1* matches any sequences of the same letter
        // - '' matches two quote characters in a row
        // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
        //   except a single quote symbol, which ends the sequence.
        //   Two quote characters do not end the sequence.
        //   If there is no matching single quote
        //   then the sequence will continue until the end of the string.
        // - . matches any single character unmatched by previous parts of the RegExps
        const formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

        // This RegExp catches symbols escaped by quotes, and also
        // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
        const longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
        const escapedStringRegExp$1 = /^'([^]*?)'?$/;
        const doubleQuoteRegExp$1 = /''/g;
        const unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;

        /**
         * The {@link format} function options.
         */

        /**
         * @name format
         * @alias formatDate
         * @category Common Helpers
         * @summary Format the date.
         *
         * @description
         * Return the formatted date string in the given format. The result may vary by locale.
         *
         * >  Please note that the `format` tokens differ from Moment.js and other libraries.
         * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         *
         * The characters wrapped between two single quotes characters (') are escaped.
         * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
         * (see the last example)
         *
         * Format of the string is based on Unicode Technical Standard #35:
         * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
         * with a few additions (see note 7 below the table).
         *
         * Accepted patterns:
         * | Unit                            | Pattern | Result examples                   | Notes |
         * |---------------------------------|---------|-----------------------------------|-------|
         * | Era                             | G..GGG  | AD, BC                            |       |
         * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
         * |                                 | GGGGG   | A, B                              |       |
         * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
         * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
         * |                                 | yy      | 44, 01, 00, 17                    | 5     |
         * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
         * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
         * |                                 | yyyyy   | ...                               | 3,5   |
         * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
         * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
         * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
         * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
         * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
         * |                                 | YYYYY   | ...                               | 3,5   |
         * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
         * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
         * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
         * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
         * |                                 | RRRRR   | ...                               | 3,5,7 |
         * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
         * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
         * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
         * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
         * |                                 | uuuuu   | ...                               | 3,5   |
         * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
         * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
         * |                                 | QQ      | 01, 02, 03, 04                    |       |
         * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
         * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
         * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
         * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
         * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
         * |                                 | qq      | 01, 02, 03, 04                    |       |
         * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
         * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
         * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
         * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
         * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
         * |                                 | MM      | 01, 02, ..., 12                   |       |
         * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
         * |                                 | MMMM    | January, February, ..., December  | 2     |
         * |                                 | MMMMM   | J, F, ..., D                      |       |
         * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
         * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
         * |                                 | LL      | 01, 02, ..., 12                   |       |
         * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
         * |                                 | LLLL    | January, February, ..., December  | 2     |
         * |                                 | LLLLL   | J, F, ..., D                      |       |
         * | Local week of year              | w       | 1, 2, ..., 53                     |       |
         * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
         * |                                 | ww      | 01, 02, ..., 53                   |       |
         * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
         * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
         * |                                 | II      | 01, 02, ..., 53                   | 7     |
         * | Day of month                    | d       | 1, 2, ..., 31                     |       |
         * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
         * |                                 | dd      | 01, 02, ..., 31                   |       |
         * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
         * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
         * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
         * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
         * |                                 | DDDD    | ...                               | 3     |
         * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
         * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
         * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
         * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
         * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
         * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
         * |                                 | ii      | 01, 02, ..., 07                   | 7     |
         * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
         * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
         * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
         * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
         * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
         * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
         * |                                 | ee      | 02, 03, ..., 01                   |       |
         * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
         * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
         * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
         * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
         * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
         * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
         * |                                 | cc      | 02, 03, ..., 01                   |       |
         * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
         * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
         * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
         * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
         * | AM, PM                          | a..aa   | AM, PM                            |       |
         * |                                 | aaa     | am, pm                            |       |
         * |                                 | aaaa    | a.m., p.m.                        | 2     |
         * |                                 | aaaaa   | a, p                              |       |
         * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
         * |                                 | bbb     | am, pm, noon, midnight            |       |
         * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
         * |                                 | bbbbb   | a, p, n, mi                       |       |
         * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
         * |                                 | BBBB    | at night, in the morning, ...     | 2     |
         * |                                 | BBBBB   | at night, in the morning, ...     |       |
         * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
         * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
         * |                                 | hh      | 01, 02, ..., 11, 12               |       |
         * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
         * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
         * |                                 | HH      | 00, 01, 02, ..., 23               |       |
         * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
         * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
         * |                                 | KK      | 01, 02, ..., 11, 00               |       |
         * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
         * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
         * |                                 | kk      | 24, 01, 02, ..., 23               |       |
         * | Minute                          | m       | 0, 1, ..., 59                     |       |
         * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
         * |                                 | mm      | 00, 01, ..., 59                   |       |
         * | Second                          | s       | 0, 1, ..., 59                     |       |
         * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
         * |                                 | ss      | 00, 01, ..., 59                   |       |
         * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
         * |                                 | SS      | 00, 01, ..., 99                   |       |
         * |                                 | SSS     | 000, 001, ..., 999                |       |
         * |                                 | SSSS    | ...                               | 3     |
         * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
         * |                                 | XX      | -0800, +0530, Z                   |       |
         * |                                 | XXX     | -08:00, +05:30, Z                 |       |
         * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
         * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
         * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
         * |                                 | xx      | -0800, +0530, +0000               |       |
         * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
         * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
         * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
         * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
         * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
         * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
         * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
         * | Seconds timestamp               | t       | 512969520                         | 7     |
         * |                                 | tt      | ...                               | 3,7   |
         * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
         * |                                 | TT      | ...                               | 3,7   |
         * | Long localized date             | P       | 04/29/1453                        | 7     |
         * |                                 | PP      | Apr 29, 1453                      | 7     |
         * |                                 | PPP     | April 29th, 1453                  | 7     |
         * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
         * | Long localized time             | p       | 12:00 AM                          | 7     |
         * |                                 | pp      | 12:00:00 AM                       | 7     |
         * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
         * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
         * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
         * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
         * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
         * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
         * Notes:
         * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
         *    are the same as "stand-alone" units, but are different in some languages.
         *    "Formatting" units are declined according to the rules of the language
         *    in the context of a date. "Stand-alone" units are always nominative singular:
         *
         *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
         *
         *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
         *
         * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
         *    the single quote characters (see below).
         *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
         *    the output will be the same as default pattern for this unit, usually
         *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
         *    are marked with "2" in the last column of the table.
         *
         *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
         *
         *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
         *
         *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
         *
         *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
         *
         *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
         *
         * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
         *    The output will be padded with zeros to match the length of the pattern.
         *
         *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
         *
         * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
         *    These tokens represent the shortest form of the quarter.
         *
         * 5. The main difference between `y` and `u` patterns are B.C. years:
         *
         *    | Year | `y` | `u` |
         *    |------|-----|-----|
         *    | AC 1 |   1 |   1 |
         *    | BC 1 |   1 |   0 |
         *    | BC 2 |   2 |  -1 |
         *
         *    Also `yy` always returns the last two digits of a year,
         *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
         *
         *    | Year | `yy` | `uu` |
         *    |------|------|------|
         *    | 1    |   01 |   01 |
         *    | 14   |   14 |   14 |
         *    | 376  |   76 |  376 |
         *    | 1453 |   53 | 1453 |
         *
         *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
         *    except local week-numbering years are dependent on `options.weekStartsOn`
         *    and `options.firstWeekContainsDate` (compare [getISOWeekYear](https://date-fns.org/docs/getISOWeekYear)
         *    and [getWeekYear](https://date-fns.org/docs/getWeekYear)).
         *
         * 6. Specific non-location timezones are currently unavailable in `date-fns`,
         *    so right now these tokens fall back to GMT timezones.
         *
         * 7. These patterns are not in the Unicode Technical Standard #35:
         *    - `i`: ISO day of week
         *    - `I`: ISO week of year
         *    - `R`: ISO week-numbering year
         *    - `t`: seconds timestamp
         *    - `T`: milliseconds timestamp
         *    - `o`: ordinal number modifier
         *    - `P`: long localized date
         *    - `p`: long localized time
         *
         * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
         *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         *
         * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
         *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         *
         * @param date - The original date
         * @param format - The string of tokens
         * @param options - An object with options
         *
         * @returns The formatted date string
         *
         * @throws `date` must not be Invalid Date
         * @throws `options.locale` must contain `localize` property
         * @throws `options.locale` must contain `formatLong` property
         * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         * @throws format string contains an unescaped latin alphabet character
         *
         * @example
         * // Represent 11 February 2014 in middle-endian format:
         * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
         * //=> '02/11/2014'
         *
         * @example
         * // Represent 2 July 2014 in Esperanto:
         * import { eoLocale } from 'date-fns/locale/eo'
         * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
         *   locale: eoLocale
         * })
         * //=> '2-a de julio 2014'
         *
         * @example
         * // Escape string by single quote characters:
         * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
         * //=> "3 o'clock"
         */
        function format$1(date, formatStr, options) {
          const defaultOptions = getDefaultOptions$1();
          const locale = options?.locale ?? defaultOptions.locale ?? enUS;
          const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions.firstWeekContainsDate ?? defaultOptions.locale?.options?.firstWeekContainsDate ?? 1;
          const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
          const originalDate = toDate$1(date, options?.in);
          if (!isValid(originalDate)) {
            throw new RangeError("Invalid time value");
          }
          let parts = formatStr.match(longFormattingTokensRegExp$1).map(substring => {
            const firstCharacter = substring[0];
            if (firstCharacter === "p" || firstCharacter === "P") {
              const longFormatter = longFormatters[firstCharacter];
              return longFormatter(substring, locale.formatLong);
            }
            return substring;
          }).join("").match(formattingTokensRegExp$1).map(substring => {
            // Replace two single quote characters with one single quote character
            if (substring === "''") {
              return {
                isToken: false,
                value: "'"
              };
            }
            const firstCharacter = substring[0];
            if (firstCharacter === "'") {
              return {
                isToken: false,
                value: cleanEscapedString$1(substring)
              };
            }
            if (formatters$1[firstCharacter]) {
              return {
                isToken: true,
                value: substring
              };
            }
            if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
              throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
            }
            return {
              isToken: false,
              value: substring
            };
          });

          // invoke localize preprocessor (only for french locales at the moment)
          if (locale.localize.preprocessor) {
            parts = locale.localize.preprocessor(originalDate, parts);
          }
          const formatterOptions = {
            firstWeekContainsDate,
            weekStartsOn,
            locale
          };
          return parts.map(part => {
            if (!part.isToken) return part.value;
            const token = part.value;
            if (!options?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token) || !options?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
              warnOrThrowProtectedError(token, formatStr, String(date));
            }
            const formatter = formatters$1[token[0]];
            return formatter(originalDate, token, locale.localize, formatterOptions);
          }).join("");
        }
        function cleanEscapedString$1(input) {
          const matched = input.match(escapedStringRegExp$1);
          if (!matched) {
            return input;
          }
          return matched[1].replace(doubleQuoteRegExp$1, "'");
        }

        /**
         * @name getDefaultOptions
         * @category Common Helpers
         * @summary Get default options.
         * @pure false
         *
         * @description
         * Returns an object that contains defaults for
         * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
         * arguments for all functions.
         *
         * You can change these with [setDefaultOptions](https://date-fns.org/docs/setDefaultOptions).
         *
         * @returns The default options
         *
         * @example
         * const result = getDefaultOptions()
         * //=> {}
         *
         * @example
         * setDefaultOptions({ weekStarsOn: 1, firstWeekContainsDate: 4 })
         * const result = getDefaultOptions()
         * //=> { weekStarsOn: 1, firstWeekContainsDate: 4 }
         */
        function getDefaultOptions() {
          return Object.assign({}, getDefaultOptions$1());
        }

        /**
         * The {@link getISODay} function options.
         */

        /**
         * @name getISODay
         * @category Weekday Helpers
         * @summary Get the day of the ISO week of the given date.
         *
         * @description
         * Get the day of the ISO week of the given date,
         * which is 7 for Sunday, 1 for Monday etc.
         *
         * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
         *
         * @param date - The given date
         * @param options - An object with options
         *
         * @returns The day of ISO week
         *
         * @example
         * // Which day of the ISO week is 26 February 2012?
         * const result = getISODay(new Date(2012, 1, 26))
         * //=> 7
         */
        function getISODay(date, options) {
          const day = toDate$1(date, options?.in).getDay();
          return day === 0 ? 7 : day;
        }

        /**
         * The {@link getMonth} function options.
         */

        /**
         * @name getMonth
         * @category Month Helpers
         * @summary Get the month of the given date.
         *
         * @description
         * Get the month of the given date.
         *
         * @param date - The given date
         * @param options - An object with options
         *
         * @returns The month index (0-11)
         *
         * @example
         * // Which month is 29 February 2012?
         * const result = getMonth(new Date(2012, 1, 29))
         * //=> 1
         */
        function getMonth(date, options) {
          return toDate$1(date, options?.in).getMonth();
        }

        /**
         * @name transpose
         * @category Generic Helpers
         * @summary Transpose the date to the given constructor.
         *
         * @description
         * The function transposes the date to the given constructor. It helps you
         * to transpose the date in the system time zone to say `UTCDate` or any other
         * date extension.
         *
         * @typeParam InputDate - The input `Date` type derived from the passed argument.
         * @typeParam ResultDate - The result `Date` type derived from the passed constructor.
         *
         * @param date - The date to use values from
         * @param constructor - The date constructor to use
         *
         * @returns Date transposed to the given constructor
         *
         * @example
         * // Create July 10, 2022 00:00 in locale time zone
         * const date = new Date(2022, 6, 10)
         * //=> 'Sun Jul 10 2022 00:00:00 GMT+0800 (Singapore Standard Time)'
         *
         * @example
         * // Transpose the date to July 10, 2022 00:00 in UTC
         * transpose(date, UTCDate)
         * //=> 'Sun Jul 10 2022 00:00:00 GMT+0000 (Coordinated Universal Time)'
         */
        function transpose(date, constructor) {
          const date_ = isConstructor(constructor) ? new constructor(0) : constructFrom(constructor, 0);
          date_.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
          date_.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
          return date_;
        }
        function isConstructor(constructor) {
          return typeof constructor === "function" && constructor.prototype?.constructor === constructor;
        }
        const TIMEZONE_UNIT_PRIORITY = 10;
        class Setter {
          subPriority = 0;
          validate(_utcDate, _options) {
            return true;
          }
        }
        class ValueSetter extends Setter {
          constructor(value, validateValue, setValue, priority, subPriority) {
            super();
            this.value = value;
            this.validateValue = validateValue;
            this.setValue = setValue;
            this.priority = priority;
            if (subPriority) {
              this.subPriority = subPriority;
            }
          }
          validate(date, options) {
            return this.validateValue(date, this.value, options);
          }
          set(date, flags, options) {
            return this.setValue(date, flags, this.value, options);
          }
        }
        class DateTimezoneSetter extends Setter {
          priority = TIMEZONE_UNIT_PRIORITY;
          subPriority = -1;
          constructor(context, reference) {
            super();
            this.context = context || (date => constructFrom(reference, date));
          }
          set(date, flags) {
            if (flags.timestampIsSet) return date;
            return constructFrom(date, transpose(date, this.context));
          }
        }
        class Parser {
          run(dateString, token, match, options) {
            const result = this.parse(dateString, token, match, options);
            if (!result) {
              return null;
            }
            return {
              setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
              rest: result.rest
            };
          }
          validate(_utcDate, _value, _options) {
            return true;
          }
        }
        class EraParser extends Parser {
          priority = 140;
          parse(dateString, token, match) {
            switch (token) {
              // AD, BC
              case "G":
              case "GG":
              case "GGG":
                return match.era(dateString, {
                  width: "abbreviated"
                }) || match.era(dateString, {
                  width: "narrow"
                });

              // A, B
              case "GGGGG":
                return match.era(dateString, {
                  width: "narrow"
                });
              // Anno Domini, Before Christ
              case "GGGG":
              default:
                return match.era(dateString, {
                  width: "wide"
                }) || match.era(dateString, {
                  width: "abbreviated"
                }) || match.era(dateString, {
                  width: "narrow"
                });
            }
          }
          set(date, flags, value) {
            flags.era = value;
            date.setFullYear(value, 0, 1);
            date.setHours(0, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["R", "u", "t", "T"];
        }
        const numericPatterns = {
          month: /^(1[0-2]|0?\d)/,
          // 0 to 12
          date: /^(3[0-1]|[0-2]?\d)/,
          // 0 to 31
          dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
          // 0 to 366
          week: /^(5[0-3]|[0-4]?\d)/,
          // 0 to 53
          hour23h: /^(2[0-3]|[0-1]?\d)/,
          // 0 to 23
          hour24h: /^(2[0-4]|[0-1]?\d)/,
          // 0 to 24
          hour11h: /^(1[0-1]|0?\d)/,
          // 0 to 11
          hour12h: /^(1[0-2]|0?\d)/,
          // 0 to 12
          minute: /^[0-5]?\d/,
          // 0 to 59
          second: /^[0-5]?\d/,
          // 0 to 59

          singleDigit: /^\d/,
          // 0 to 9
          twoDigits: /^\d{1,2}/,
          // 0 to 99
          threeDigits: /^\d{1,3}/,
          // 0 to 999
          fourDigits: /^\d{1,4}/,
          // 0 to 9999

          anyDigitsSigned: /^-?\d+/,
          singleDigitSigned: /^-?\d/,
          // 0 to 9, -0 to -9
          twoDigitsSigned: /^-?\d{1,2}/,
          // 0 to 99, -0 to -99
          threeDigitsSigned: /^-?\d{1,3}/,
          // 0 to 999, -0 to -999
          fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999
        };
        const timezonePatterns = {
          basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
          basic: /^([+-])(\d{2})(\d{2})|Z/,
          basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
          extended: /^([+-])(\d{2}):(\d{2})|Z/,
          extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
        };
        function mapValue(parseFnResult, mapFn) {
          if (!parseFnResult) {
            return parseFnResult;
          }
          return {
            value: mapFn(parseFnResult.value),
            rest: parseFnResult.rest
          };
        }
        function parseNumericPattern(pattern, dateString) {
          const matchResult = dateString.match(pattern);
          if (!matchResult) {
            return null;
          }
          return {
            value: parseInt(matchResult[0], 10),
            rest: dateString.slice(matchResult[0].length)
          };
        }
        function parseTimezonePattern(pattern, dateString) {
          const matchResult = dateString.match(pattern);
          if (!matchResult) {
            return null;
          }

          // Input is 'Z'
          if (matchResult[0] === "Z") {
            return {
              value: 0,
              rest: dateString.slice(1)
            };
          }
          const sign = matchResult[1] === "+" ? 1 : -1;
          const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
          const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
          const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
          return {
            value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
            rest: dateString.slice(matchResult[0].length)
          };
        }
        function parseAnyDigitsSigned(dateString) {
          return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
        }
        function parseNDigits(n, dateString) {
          switch (n) {
            case 1:
              return parseNumericPattern(numericPatterns.singleDigit, dateString);
            case 2:
              return parseNumericPattern(numericPatterns.twoDigits, dateString);
            case 3:
              return parseNumericPattern(numericPatterns.threeDigits, dateString);
            case 4:
              return parseNumericPattern(numericPatterns.fourDigits, dateString);
            default:
              return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
          }
        }
        function parseNDigitsSigned(n, dateString) {
          switch (n) {
            case 1:
              return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
            case 2:
              return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
            case 3:
              return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
            case 4:
              return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
            default:
              return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
          }
        }
        function dayPeriodEnumToHours(dayPeriod) {
          switch (dayPeriod) {
            case "morning":
              return 4;
            case "evening":
              return 17;
            case "pm":
            case "noon":
            case "afternoon":
              return 12;
            case "am":
            case "midnight":
            case "night":
            default:
              return 0;
          }
        }
        function normalizeTwoDigitYear(twoDigitYear, currentYear) {
          const isCommonEra = currentYear > 0;
          // Absolute number of the current year:
          // 1 -> 1 AC
          // 0 -> 1 BC
          // -1 -> 2 BC
          const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
          let result;
          if (absCurrentYear <= 50) {
            result = twoDigitYear || 100;
          } else {
            const rangeEnd = absCurrentYear + 50;
            const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
            const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
            result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
          }
          return isCommonEra ? result : 1 - result;
        }
        function isLeapYearIndex$2(year) {
          return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
        }

        // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
        // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
        // |----------|-------|----|-------|-------|-------|
        // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
        // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
        // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
        // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
        // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
        class YearParser extends Parser {
          priority = 130;
          incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];
          parse(dateString, token, match) {
            const valueCallback = year => ({
              year,
              isTwoDigitYear: token === "yy"
            });
            switch (token) {
              case "y":
                return mapValue(parseNDigits(4, dateString), valueCallback);
              case "yo":
                return mapValue(match.ordinalNumber(dateString, {
                  unit: "year"
                }), valueCallback);
              default:
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
            }
          }
          validate(_date, value) {
            return value.isTwoDigitYear || value.year > 0;
          }
          set(date, flags, value) {
            const currentYear = date.getFullYear();
            if (value.isTwoDigitYear) {
              const normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
              date.setFullYear(normalizedTwoDigitYear, 0, 1);
              date.setHours(0, 0, 0, 0);
              return date;
            }
            const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
            date.setFullYear(year, 0, 1);
            date.setHours(0, 0, 0, 0);
            return date;
          }
        }

        // Local week-numbering year
        class LocalWeekYearParser extends Parser {
          priority = 130;
          parse(dateString, token, match) {
            const valueCallback = year => ({
              year,
              isTwoDigitYear: token === "YY"
            });
            switch (token) {
              case "Y":
                return mapValue(parseNDigits(4, dateString), valueCallback);
              case "Yo":
                return mapValue(match.ordinalNumber(dateString, {
                  unit: "year"
                }), valueCallback);
              default:
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
            }
          }
          validate(_date, value) {
            return value.isTwoDigitYear || value.year > 0;
          }
          set(date, flags, value, options) {
            const currentYear = getWeekYear(date, options);
            if (value.isTwoDigitYear) {
              const normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
              date.setFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
              date.setHours(0, 0, 0, 0);
              return startOfWeek(date, options);
            }
            const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
            date.setFullYear(year, 0, options.firstWeekContainsDate);
            date.setHours(0, 0, 0, 0);
            return startOfWeek(date, options);
          }
          incompatibleTokens = ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"];
        }

        // ISO week-numbering year
        class ISOWeekYearParser extends Parser {
          priority = 130;
          parse(dateString, token) {
            if (token === "R") {
              return parseNDigitsSigned(4, dateString);
            }
            return parseNDigitsSigned(token.length, dateString);
          }
          set(date, _flags, value) {
            const firstWeekOfYear = constructFrom(date, 0);
            firstWeekOfYear.setFullYear(value, 0, 4);
            firstWeekOfYear.setHours(0, 0, 0, 0);
            return startOfISOWeek(firstWeekOfYear);
          }
          incompatibleTokens = ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"];
        }
        class ExtendedYearParser extends Parser {
          priority = 130;
          parse(dateString, token) {
            if (token === "u") {
              return parseNDigitsSigned(4, dateString);
            }
            return parseNDigitsSigned(token.length, dateString);
          }
          set(date, _flags, value) {
            date.setFullYear(value, 0, 1);
            date.setHours(0, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"];
        }
        class QuarterParser extends Parser {
          priority = 120;
          parse(dateString, token, match) {
            switch (token) {
              // 1, 2, 3, 4
              case "Q":
              case "QQ":
                // 01, 02, 03, 04
                return parseNDigits(token.length, dateString);
              // 1st, 2nd, 3rd, 4th
              case "Qo":
                return match.ordinalNumber(dateString, {
                  unit: "quarter"
                });
              // Q1, Q2, Q3, Q4
              case "QQQ":
                return match.quarter(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.quarter(dateString, {
                  width: "narrow",
                  context: "formatting"
                });

              // 1, 2, 3, 4 (narrow quarter; could be not numerical)
              case "QQQQQ":
                return match.quarter(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              // 1st quarter, 2nd quarter, ...
              case "QQQQ":
              default:
                return match.quarter(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match.quarter(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.quarter(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
          validate(_date, value) {
            return value >= 1 && value <= 4;
          }
          set(date, _flags, value) {
            date.setMonth((value - 1) * 3, 1);
            date.setHours(0, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"];
        }
        class StandAloneQuarterParser extends Parser {
          priority = 120;
          parse(dateString, token, match) {
            switch (token) {
              // 1, 2, 3, 4
              case "q":
              case "qq":
                // 01, 02, 03, 04
                return parseNDigits(token.length, dateString);
              // 1st, 2nd, 3rd, 4th
              case "qo":
                return match.ordinalNumber(dateString, {
                  unit: "quarter"
                });
              // Q1, Q2, Q3, Q4
              case "qqq":
                return match.quarter(dateString, {
                  width: "abbreviated",
                  context: "standalone"
                }) || match.quarter(dateString, {
                  width: "narrow",
                  context: "standalone"
                });

              // 1, 2, 3, 4 (narrow quarter; could be not numerical)
              case "qqqqq":
                return match.quarter(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
              // 1st quarter, 2nd quarter, ...
              case "qqqq":
              default:
                return match.quarter(dateString, {
                  width: "wide",
                  context: "standalone"
                }) || match.quarter(dateString, {
                  width: "abbreviated",
                  context: "standalone"
                }) || match.quarter(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
            }
          }
          validate(_date, value) {
            return value >= 1 && value <= 4;
          }
          set(date, _flags, value) {
            date.setMonth((value - 1) * 3, 1);
            date.setHours(0, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"];
        }
        class MonthParser extends Parser {
          incompatibleTokens = ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"];
          priority = 110;
          parse(dateString, token, match) {
            const valueCallback = value => value - 1;
            switch (token) {
              // 1, 2, ..., 12
              case "M":
                return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
              // 01, 02, ..., 12
              case "MM":
                return mapValue(parseNDigits(2, dateString), valueCallback);
              // 1st, 2nd, ..., 12th
              case "Mo":
                return mapValue(match.ordinalNumber(dateString, {
                  unit: "month"
                }), valueCallback);
              // Jan, Feb, ..., Dec
              case "MMM":
                return match.month(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.month(dateString, {
                  width: "narrow",
                  context: "formatting"
                });

              // J, F, ..., D
              case "MMMMM":
                return match.month(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              // January, February, ..., December
              case "MMMM":
              default:
                return match.month(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match.month(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.month(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
          validate(_date, value) {
            return value >= 0 && value <= 11;
          }
          set(date, _flags, value) {
            date.setMonth(value, 1);
            date.setHours(0, 0, 0, 0);
            return date;
          }
        }
        class StandAloneMonthParser extends Parser {
          priority = 110;
          parse(dateString, token, match) {
            const valueCallback = value => value - 1;
            switch (token) {
              // 1, 2, ..., 12
              case "L":
                return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
              // 01, 02, ..., 12
              case "LL":
                return mapValue(parseNDigits(2, dateString), valueCallback);
              // 1st, 2nd, ..., 12th
              case "Lo":
                return mapValue(match.ordinalNumber(dateString, {
                  unit: "month"
                }), valueCallback);
              // Jan, Feb, ..., Dec
              case "LLL":
                return match.month(dateString, {
                  width: "abbreviated",
                  context: "standalone"
                }) || match.month(dateString, {
                  width: "narrow",
                  context: "standalone"
                });

              // J, F, ..., D
              case "LLLLL":
                return match.month(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
              // January, February, ..., December
              case "LLLL":
              default:
                return match.month(dateString, {
                  width: "wide",
                  context: "standalone"
                }) || match.month(dateString, {
                  width: "abbreviated",
                  context: "standalone"
                }) || match.month(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
            }
          }
          validate(_date, value) {
            return value >= 0 && value <= 11;
          }
          set(date, _flags, value) {
            date.setMonth(value, 1);
            date.setHours(0, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"];
        }

        /**
         * The {@link setWeek} function options.
         */

        /**
         * @name setWeek
         * @category Week Helpers
         * @summary Set the local week to the given date.
         *
         * @description
         * Set the local week to the given date, saving the weekday number.
         * The exact calculation depends on the values of
         * `options.weekStartsOn` (which is the index of the first day of the week)
         * and `options.firstWeekContainsDate` (which is the day of January, which is always in
         * the first week of the week-numbering year)
         *
         * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The date to be changed
         * @param week - The week of the new date
         * @param options - An object with options
         *
         * @returns The new date with the local week set
         *
         * @example
         * // Set the 1st week to 2 January 2005 with default options:
         * const result = setWeek(new Date(2005, 0, 2), 1)
         * //=> Sun Dec 26 2004 00:00:00
         *
         * @example
         * // Set the 1st week to 2 January 2005,
         * // if Monday is the first day of the week,
         * // and the first week of the year always contains 4 January:
         * const result = setWeek(new Date(2005, 0, 2), 1, {
         *   weekStartsOn: 1,
         *   firstWeekContainsDate: 4
         * })
         * //=> Sun Jan 4 2004 00:00:00
         */
        function setWeek(date, week, options) {
          const date_ = toDate$1(date, options?.in);
          const diff = getWeek(date_, options) - week;
          date_.setDate(date_.getDate() - diff * 7);
          return toDate$1(date_, options?.in);
        }

        // Local week of year
        class LocalWeekParser extends Parser {
          priority = 100;
          parse(dateString, token, match) {
            switch (token) {
              case "w":
                return parseNumericPattern(numericPatterns.week, dateString);
              case "wo":
                return match.ordinalNumber(dateString, {
                  unit: "week"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
          validate(_date, value) {
            return value >= 1 && value <= 53;
          }
          set(date, _flags, value, options) {
            return startOfWeek(setWeek(date, value, options), options);
          }
          incompatibleTokens = ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"];
        }

        /**
         * The {@link setISOWeek} function options.
         */

        /**
         * @name setISOWeek
         * @category ISO Week Helpers
         * @summary Set the ISO week to the given date.
         *
         * @description
         * Set the ISO week to the given date, saving the weekday number.
         *
         * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The `Date` type of the context function.
         *
         * @param date - The date to be changed
         * @param week - The ISO week of the new date
         * @param options - An object with options
         *
         * @returns The new date with the ISO week set
         *
         * @example
         * // Set the 53rd ISO week to 7 August 2004:
         * const result = setISOWeek(new Date(2004, 7, 7), 53)
         * //=> Sat Jan 01 2005 00:00:00
         */
        function setISOWeek(date, week, options) {
          const _date = toDate$1(date, options?.in);
          const diff = getISOWeek(_date, options) - week;
          _date.setDate(_date.getDate() - diff * 7);
          return _date;
        }

        // ISO week of year
        class ISOWeekParser extends Parser {
          priority = 100;
          parse(dateString, token, match) {
            switch (token) {
              case "I":
                return parseNumericPattern(numericPatterns.week, dateString);
              case "Io":
                return match.ordinalNumber(dateString, {
                  unit: "week"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
          validate(_date, value) {
            return value >= 1 && value <= 53;
          }
          set(date, _flags, value) {
            return startOfISOWeek(setISOWeek(date, value));
          }
          incompatibleTokens = ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"];
        }
        const DAYS_IN_MONTH$1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        const DAYS_IN_MONTH_LEAP_YEAR$1 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

        // Day of the month
        class DateParser extends Parser {
          priority = 90;
          subPriority = 1;
          parse(dateString, token, match) {
            switch (token) {
              case "d":
                return parseNumericPattern(numericPatterns.date, dateString);
              case "do":
                return match.ordinalNumber(dateString, {
                  unit: "date"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
          validate(date, value) {
            const year = date.getFullYear();
            const isLeapYear = isLeapYearIndex$2(year);
            const month = date.getMonth();
            if (isLeapYear) {
              return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR$1[month];
            } else {
              return value >= 1 && value <= DAYS_IN_MONTH$1[month];
            }
          }
          set(date, _flags, value) {
            date.setDate(value);
            date.setHours(0, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"];
        }
        class DayOfYearParser extends Parser {
          priority = 90;
          subpriority = 1;
          parse(dateString, token, match) {
            switch (token) {
              case "D":
              case "DD":
                return parseNumericPattern(numericPatterns.dayOfYear, dateString);
              case "Do":
                return match.ordinalNumber(dateString, {
                  unit: "date"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
          validate(date, value) {
            const year = date.getFullYear();
            const isLeapYear = isLeapYearIndex$2(year);
            if (isLeapYear) {
              return value >= 1 && value <= 366;
            } else {
              return value >= 1 && value <= 365;
            }
          }
          set(date, _flags, value) {
            date.setMonth(0, value);
            date.setHours(0, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"];
        }

        /**
         * The {@link setDay} function options.
         */

        /**
         * @name setDay
         * @category Weekday Helpers
         * @summary Set the day of the week to the given date.
         *
         * @description
         * Set the day of the week to the given date.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The date to be changed
         * @param day - The day of the week of the new date
         * @param options - An object with options.
         *
         * @returns The new date with the day of the week set
         *
         * @example
         * // Set week day to Sunday, with the default weekStartsOn of Sunday:
         * const result = setDay(new Date(2014, 8, 1), 0)
         * //=> Sun Aug 31 2014 00:00:00
         *
         * @example
         * // Set week day to Sunday, with a weekStartsOn of Monday:
         * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })
         * //=> Sun Sep 07 2014 00:00:00
         */
        function setDay(date, day, options) {
          const defaultOptions = getDefaultOptions$1();
          const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
          const date_ = toDate$1(date, options?.in);
          const currentDay = date_.getDay();
          const remainder = day % 7;
          const dayIndex = (remainder + 7) % 7;
          const delta = 7 - weekStartsOn;
          const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
          return addDays(date_, diff, options);
        }

        // Day of week
        class DayParser extends Parser {
          priority = 90;
          parse(dateString, token, match) {
            switch (token) {
              // Tue
              case "E":
              case "EE":
              case "EEE":
                return match.day(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });

              // T
              case "EEEEE":
                return match.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              // Tu
              case "EEEEEE":
                return match.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });

              // Tuesday
              case "EEEE":
              default:
                return match.day(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
          validate(_date, value) {
            return value >= 0 && value <= 6;
          }
          set(date, _flags, value, options) {
            date = setDay(date, value, options);
            date.setHours(0, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["D", "i", "e", "c", "t", "T"];
        }

        // Local day of week
        class LocalDayParser extends Parser {
          priority = 90;
          parse(dateString, token, match, options) {
            const valueCallback = value => {
              // We want here floor instead of trunc, so we get -7 for value 0 instead of 0
              const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
              return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
            };
            switch (token) {
              // 3
              case "e":
              case "ee":
                // 03
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
              // 3rd
              case "eo":
                return mapValue(match.ordinalNumber(dateString, {
                  unit: "day"
                }), valueCallback);
              // Tue
              case "eee":
                return match.day(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });

              // T
              case "eeeee":
                return match.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              // Tu
              case "eeeeee":
                return match.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });

              // Tuesday
              case "eeee":
              default:
                return match.day(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
          validate(_date, value) {
            return value >= 0 && value <= 6;
          }
          set(date, _flags, value, options) {
            date = setDay(date, value, options);
            date.setHours(0, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"];
        }

        // Stand-alone local day of week
        class StandAloneLocalDayParser extends Parser {
          priority = 90;
          parse(dateString, token, match, options) {
            const valueCallback = value => {
              // We want here floor instead of trunc, so we get -7 for value 0 instead of 0
              const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
              return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
            };
            switch (token) {
              // 3
              case "c":
              case "cc":
                // 03
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
              // 3rd
              case "co":
                return mapValue(match.ordinalNumber(dateString, {
                  unit: "day"
                }), valueCallback);
              // Tue
              case "ccc":
                return match.day(dateString, {
                  width: "abbreviated",
                  context: "standalone"
                }) || match.day(dateString, {
                  width: "short",
                  context: "standalone"
                }) || match.day(dateString, {
                  width: "narrow",
                  context: "standalone"
                });

              // T
              case "ccccc":
                return match.day(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
              // Tu
              case "cccccc":
                return match.day(dateString, {
                  width: "short",
                  context: "standalone"
                }) || match.day(dateString, {
                  width: "narrow",
                  context: "standalone"
                });

              // Tuesday
              case "cccc":
              default:
                return match.day(dateString, {
                  width: "wide",
                  context: "standalone"
                }) || match.day(dateString, {
                  width: "abbreviated",
                  context: "standalone"
                }) || match.day(dateString, {
                  width: "short",
                  context: "standalone"
                }) || match.day(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
            }
          }
          validate(_date, value) {
            return value >= 0 && value <= 6;
          }
          set(date, _flags, value, options) {
            date = setDay(date, value, options);
            date.setHours(0, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"];
        }

        /**
         * The {@link setISODay} function options.
         */

        /**
         * @name setISODay
         * @category Weekday Helpers
         * @summary Set the day of the ISO week to the given date.
         *
         * @description
         * Set the day of the ISO week to the given date.
         * ISO week starts with Monday.
         * 7 is the index of Sunday, 1 is the index of Monday, etc.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The date to be changed
         * @param day - The day of the ISO week of the new date
         * @param options - An object with options
         *
         * @returns The new date with the day of the ISO week set
         *
         * @example
         * // Set Sunday to 1 September 2014:
         * const result = setISODay(new Date(2014, 8, 1), 7)
         * //=> Sun Sep 07 2014 00:00:00
         */
        function setISODay(date, day, options) {
          const date_ = toDate$1(date, options?.in);
          const currentDay = getISODay(date_, options);
          const diff = day - currentDay;
          return addDays(date_, diff, options);
        }

        // ISO day of week
        class ISODayParser extends Parser {
          priority = 90;
          parse(dateString, token, match) {
            const valueCallback = value => {
              if (value === 0) {
                return 7;
              }
              return value;
            };
            switch (token) {
              // 2
              case "i":
              case "ii":
                // 02
                return parseNDigits(token.length, dateString);
              // 2nd
              case "io":
                return match.ordinalNumber(dateString, {
                  unit: "day"
                });
              // Tue
              case "iii":
                return mapValue(match.day(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                }), valueCallback);
              // T
              case "iiiii":
                return mapValue(match.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                }), valueCallback);
              // Tu
              case "iiiiii":
                return mapValue(match.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                }), valueCallback);
              // Tuesday
              case "iiii":
              default:
                return mapValue(match.day(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                }), valueCallback);
            }
          }
          validate(_date, value) {
            return value >= 1 && value <= 7;
          }
          set(date, _flags, value) {
            date = setISODay(date, value);
            date.setHours(0, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"];
        }
        class AMPMParser extends Parser {
          priority = 80;
          parse(dateString, token, match) {
            switch (token) {
              case "a":
              case "aa":
              case "aaa":
                return match.dayPeriod(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "aaaaa":
                return match.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "aaaa":
              default:
                return match.dayPeriod(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match.dayPeriod(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
          set(date, _flags, value) {
            date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["b", "B", "H", "k", "t", "T"];
        }
        class AMPMMidnightParser extends Parser {
          priority = 80;
          parse(dateString, token, match) {
            switch (token) {
              case "b":
              case "bb":
              case "bbb":
                return match.dayPeriod(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "bbbbb":
                return match.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "bbbb":
              default:
                return match.dayPeriod(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match.dayPeriod(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
          set(date, _flags, value) {
            date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["a", "B", "H", "k", "t", "T"];
        }

        // in the morning, in the afternoon, in the evening, at night
        class DayPeriodParser extends Parser {
          priority = 80;
          parse(dateString, token, match) {
            switch (token) {
              case "B":
              case "BB":
              case "BBB":
                return match.dayPeriod(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "BBBBB":
                return match.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "BBBB":
              default:
                return match.dayPeriod(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match.dayPeriod(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
          set(date, _flags, value) {
            date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["a", "b", "t", "T"];
        }
        class Hour1to12Parser extends Parser {
          priority = 70;
          parse(dateString, token, match) {
            switch (token) {
              case "h":
                return parseNumericPattern(numericPatterns.hour12h, dateString);
              case "ho":
                return match.ordinalNumber(dateString, {
                  unit: "hour"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
          validate(_date, value) {
            return value >= 1 && value <= 12;
          }
          set(date, _flags, value) {
            const isPM = date.getHours() >= 12;
            if (isPM && value < 12) {
              date.setHours(value + 12, 0, 0, 0);
            } else if (!isPM && value === 12) {
              date.setHours(0, 0, 0, 0);
            } else {
              date.setHours(value, 0, 0, 0);
            }
            return date;
          }
          incompatibleTokens = ["H", "K", "k", "t", "T"];
        }
        class Hour0to23Parser extends Parser {
          priority = 70;
          parse(dateString, token, match) {
            switch (token) {
              case "H":
                return parseNumericPattern(numericPatterns.hour23h, dateString);
              case "Ho":
                return match.ordinalNumber(dateString, {
                  unit: "hour"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
          validate(_date, value) {
            return value >= 0 && value <= 23;
          }
          set(date, _flags, value) {
            date.setHours(value, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"];
        }
        class Hour0To11Parser extends Parser {
          priority = 70;
          parse(dateString, token, match) {
            switch (token) {
              case "K":
                return parseNumericPattern(numericPatterns.hour11h, dateString);
              case "Ko":
                return match.ordinalNumber(dateString, {
                  unit: "hour"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
          validate(_date, value) {
            return value >= 0 && value <= 11;
          }
          set(date, _flags, value) {
            const isPM = date.getHours() >= 12;
            if (isPM && value < 12) {
              date.setHours(value + 12, 0, 0, 0);
            } else {
              date.setHours(value, 0, 0, 0);
            }
            return date;
          }
          incompatibleTokens = ["h", "H", "k", "t", "T"];
        }
        class Hour1To24Parser extends Parser {
          priority = 70;
          parse(dateString, token, match) {
            switch (token) {
              case "k":
                return parseNumericPattern(numericPatterns.hour24h, dateString);
              case "ko":
                return match.ordinalNumber(dateString, {
                  unit: "hour"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
          validate(_date, value) {
            return value >= 1 && value <= 24;
          }
          set(date, _flags, value) {
            const hours = value <= 24 ? value % 24 : value;
            date.setHours(hours, 0, 0, 0);
            return date;
          }
          incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"];
        }
        class MinuteParser extends Parser {
          priority = 60;
          parse(dateString, token, match) {
            switch (token) {
              case "m":
                return parseNumericPattern(numericPatterns.minute, dateString);
              case "mo":
                return match.ordinalNumber(dateString, {
                  unit: "minute"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
          validate(_date, value) {
            return value >= 0 && value <= 59;
          }
          set(date, _flags, value) {
            date.setMinutes(value, 0, 0);
            return date;
          }
          incompatibleTokens = ["t", "T"];
        }
        class SecondParser extends Parser {
          priority = 50;
          parse(dateString, token, match) {
            switch (token) {
              case "s":
                return parseNumericPattern(numericPatterns.second, dateString);
              case "so":
                return match.ordinalNumber(dateString, {
                  unit: "second"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
          validate(_date, value) {
            return value >= 0 && value <= 59;
          }
          set(date, _flags, value) {
            date.setSeconds(value, 0);
            return date;
          }
          incompatibleTokens = ["t", "T"];
        }
        class FractionOfSecondParser extends Parser {
          priority = 30;
          parse(dateString, token) {
            const valueCallback = value => Math.trunc(value * Math.pow(10, -token.length + 3));
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
          }
          set(date, _flags, value) {
            date.setMilliseconds(value);
            return date;
          }
          incompatibleTokens = ["t", "T"];
        }

        // Timezone (ISO-8601. +00:00 is `'Z'`)
        class ISOTimezoneWithZParser extends Parser {
          priority = 10;
          parse(dateString, token) {
            switch (token) {
              case "X":
                return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
              case "XX":
                return parseTimezonePattern(timezonePatterns.basic, dateString);
              case "XXXX":
                return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
              case "XXXXX":
                return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
              case "XXX":
              default:
                return parseTimezonePattern(timezonePatterns.extended, dateString);
            }
          }
          set(date, flags, value) {
            if (flags.timestampIsSet) return date;
            return constructFrom(date, date.getTime() - getTimezoneOffsetInMilliseconds$1(date) - value);
          }
          incompatibleTokens = ["t", "T", "x"];
        }

        // Timezone (ISO-8601)
        class ISOTimezoneParser extends Parser {
          priority = 10;
          parse(dateString, token) {
            switch (token) {
              case "x":
                return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
              case "xx":
                return parseTimezonePattern(timezonePatterns.basic, dateString);
              case "xxxx":
                return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
              case "xxxxx":
                return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
              case "xxx":
              default:
                return parseTimezonePattern(timezonePatterns.extended, dateString);
            }
          }
          set(date, flags, value) {
            if (flags.timestampIsSet) return date;
            return constructFrom(date, date.getTime() - getTimezoneOffsetInMilliseconds$1(date) - value);
          }
          incompatibleTokens = ["t", "T", "X"];
        }
        class TimestampSecondsParser extends Parser {
          priority = 40;
          parse(dateString) {
            return parseAnyDigitsSigned(dateString);
          }
          set(date, _flags, value) {
            return [constructFrom(date, value * 1000), {
              timestampIsSet: true
            }];
          }
          incompatibleTokens = "*";
        }
        class TimestampMillisecondsParser extends Parser {
          priority = 20;
          parse(dateString) {
            return parseAnyDigitsSigned(dateString);
          }
          set(date, _flags, value) {
            return [constructFrom(date, value), {
              timestampIsSet: true
            }];
          }
          incompatibleTokens = "*";
        }

        /*
         * |     | Unit                           |     | Unit                           |
         * |-----|--------------------------------|-----|--------------------------------|
         * |  a  | AM, PM                         |  A* | Milliseconds in day            |
         * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
         * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
         * |  d  | Day of month                   |  D  | Day of year                    |
         * |  e  | Local day of week              |  E  | Day of week                    |
         * |  f  |                                |  F* | Day of week in month           |
         * |  g* | Modified Julian day            |  G  | Era                            |
         * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
         * |  i! | ISO day of week                |  I! | ISO week of year               |
         * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
         * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
         * |  l* | (deprecated)                   |  L  | Stand-alone month              |
         * |  m  | Minute                         |  M  | Month                          |
         * |  n  |                                |  N  |                                |
         * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
         * |  p  |                                |  P  |                                |
         * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
         * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
         * |  s  | Second                         |  S  | Fraction of second             |
         * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
         * |  u  | Extended year                  |  U* | Cyclic year                    |
         * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
         * |  w  | Local week of year             |  W* | Week of month                  |
         * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
         * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
         * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
         *
         * Letters marked by * are not implemented but reserved by Unicode standard.
         *
         * Letters marked by ! are non-standard, but implemented by date-fns:
         * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
         * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
         *   i.e. 7 for Sunday, 1 for Monday, etc.
         * - `I` is ISO week of year, as opposed to `w` which is local week of year.
         * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
         *   `R` is supposed to be used in conjunction with `I` and `i`
         *   for universal ISO week-numbering date, whereas
         *   `Y` is supposed to be used in conjunction with `w` and `e`
         *   for week-numbering date specific to the locale.
         */
        const parsers = {
          G: new EraParser(),
          y: new YearParser(),
          Y: new LocalWeekYearParser(),
          R: new ISOWeekYearParser(),
          u: new ExtendedYearParser(),
          Q: new QuarterParser(),
          q: new StandAloneQuarterParser(),
          M: new MonthParser(),
          L: new StandAloneMonthParser(),
          w: new LocalWeekParser(),
          I: new ISOWeekParser(),
          d: new DateParser(),
          D: new DayOfYearParser(),
          E: new DayParser(),
          e: new LocalDayParser(),
          c: new StandAloneLocalDayParser(),
          i: new ISODayParser(),
          a: new AMPMParser(),
          b: new AMPMMidnightParser(),
          B: new DayPeriodParser(),
          h: new Hour1to12Parser(),
          H: new Hour0to23Parser(),
          K: new Hour0To11Parser(),
          k: new Hour1To24Parser(),
          m: new MinuteParser(),
          s: new SecondParser(),
          S: new FractionOfSecondParser(),
          X: new ISOTimezoneWithZParser(),
          x: new ISOTimezoneParser(),
          t: new TimestampSecondsParser(),
          T: new TimestampMillisecondsParser()
        };

        /**
         * The {@link parse} function options.
         */

        // This RegExp consists of three parts separated by `|`:
        // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
        //   (one of the certain letters followed by `o`)
        // - (\w)\1* matches any sequences of the same letter
        // - '' matches two quote characters in a row
        // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
        //   except a single quote symbol, which ends the sequence.
        //   Two quote characters do not end the sequence.
        //   If there is no matching single quote
        //   then the sequence will continue until the end of the string.
        // - . matches any single character unmatched by previous parts of the RegExps
        const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

        // This RegExp catches symbols escaped by quotes, and also
        // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
        const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
        const escapedStringRegExp = /^'([^]*?)'?$/;
        const doubleQuoteRegExp = /''/g;
        const notWhitespaceRegExp = /\S/;
        const unescapedLatinCharacterRegExp = /[a-zA-Z]/;

        /**
         * @name parse
         * @category Common Helpers
         * @summary Parse the date.
         *
         * @description
         * Return the date parsed from string using the given format string.
         *
         * >  Please note that the `format` tokens differ from Moment.js and other libraries.
         * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         *
         * The characters in the format string wrapped between two single quotes characters (') are escaped.
         * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
         *
         * Format of the format string is based on Unicode Technical Standard #35:
         * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
         * with a few additions (see note 5 below the table).
         *
         * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
         * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
         *
         * ```javascript
         * parse('23 AM', 'HH a', new Date())
         * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
         * ```
         *
         * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
         *
         * Accepted format string patterns:
         * | Unit                            |Prior| Pattern | Result examples                   | Notes |
         * |---------------------------------|-----|---------|-----------------------------------|-------|
         * | Era                             | 140 | G..GGG  | AD, BC                            |       |
         * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
         * |                                 |     | GGGGG   | A, B                              |       |
         * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
         * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
         * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
         * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
         * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
         * |                                 |     | yyyyy   | ...                               | 2,4   |
         * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
         * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
         * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
         * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
         * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
         * |                                 |     | YYYYY   | ...                               | 2,4   |
         * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
         * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
         * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
         * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
         * |                                 |     | RRRRR   | ...                               | 2,4,5 |
         * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
         * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
         * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
         * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
         * |                                 |     | uuuuu   | ...                               | 2,4   |
         * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
         * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
         * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
         * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
         * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
         * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
         * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
         * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
         * |                                 |     | qq      | 01, 02, 03, 04                    |       |
         * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
         * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
         * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
         * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
         * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
         * |                                 |     | MM      | 01, 02, ..., 12                   |       |
         * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
         * |                                 |     | MMMM    | January, February, ..., December  | 2     |
         * |                                 |     | MMMMM   | J, F, ..., D                      |       |
         * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
         * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
         * |                                 |     | LL      | 01, 02, ..., 12                   |       |
         * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
         * |                                 |     | LLLL    | January, February, ..., December  | 2     |
         * |                                 |     | LLLLL   | J, F, ..., D                      |       |
         * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
         * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
         * |                                 |     | ww      | 01, 02, ..., 53                   |       |
         * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
         * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
         * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
         * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
         * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
         * |                                 |     | dd      | 01, 02, ..., 31                   |       |
         * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
         * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
         * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
         * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
         * |                                 |     | DDDD    | ...                               | 2     |
         * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
         * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
         * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
         * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
         * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
         * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
         * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
         * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
         * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
         * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
         * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
         * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
         * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
         * |                                 |     | ee      | 02, 03, ..., 01                   |       |
         * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
         * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
         * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
         * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
         * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
         * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
         * |                                 |     | cc      | 02, 03, ..., 01                   |       |
         * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
         * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
         * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
         * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
         * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
         * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
         * |                                 |     | aaaaa   | a, p                              |       |
         * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
         * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
         * |                                 |     | bbbbb   | a, p, n, mi                       |       |
         * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
         * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
         * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
         * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
         * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
         * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
         * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
         * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
         * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
         * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
         * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
         * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
         * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
         * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
         * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
         * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
         * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
         * |                                 |     | mm      | 00, 01, ..., 59                   |       |
         * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
         * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
         * |                                 |     | ss      | 00, 01, ..., 59                   |       |
         * | Seconds timestamp               |  40 | t       | 512969520                         |       |
         * |                                 |     | tt      | ...                               | 2     |
         * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
         * |                                 |     | SS      | 00, 01, ..., 99                   |       |
         * |                                 |     | SSS     | 000, 001, ..., 999                |       |
         * |                                 |     | SSSS    | ...                               | 2     |
         * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
         * |                                 |     | TT      | ...                               | 2     |
         * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
         * |                                 |     | XX      | -0800, +0530, Z                   |       |
         * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
         * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
         * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
         * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
         * |                                 |     | xx      | -0800, +0530, +0000               |       |
         * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
         * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
         * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
         * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
         * |                                 |     | PP      | May 29, 1453                      |       |
         * |                                 |     | PPP     | May 29th, 1453                    |       |
         * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
         * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
         * |                                 |     | pp      | 12:00:00 AM                       |       |
         * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
         * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
         * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
         * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
         * Notes:
         * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
         *    are the same as "stand-alone" units, but are different in some languages.
         *    "Formatting" units are declined according to the rules of the language
         *    in the context of a date. "Stand-alone" units are always nominative singular.
         *    In `format` function, they will produce different result:
         *
         *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
         *
         *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
         *
         *    `parse` will try to match both formatting and stand-alone units interchangeably.
         *
         * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
         *    the single quote characters (see below).
         *    If the sequence is longer than listed in table:
         *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
         *      as wide as the sequence
         *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
         *      These variations are marked with "2" in the last column of the table.
         *
         * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
         *    These tokens represent the shortest form of the quarter.
         *
         * 4. The main difference between `y` and `u` patterns are B.C. years:
         *
         *    | Year | `y` | `u` |
         *    |------|-----|-----|
         *    | AC 1 |   1 |   1 |
         *    | BC 1 |   1 |   0 |
         *    | BC 2 |   2 |  -1 |
         *
         *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
         *
         *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
         *
         *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
         *
         *    while `uu` will just assign the year as is:
         *
         *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
         *
         *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
         *
         *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
         *    except local week-numbering years are dependent on `options.weekStartsOn`
         *    and `options.firstWeekContainsDate` (compare [setISOWeekYear](https://date-fns.org/docs/setISOWeekYear)
         *    and [setWeekYear](https://date-fns.org/docs/setWeekYear)).
         *
         * 5. These patterns are not in the Unicode Technical Standard #35:
         *    - `i`: ISO day of week
         *    - `I`: ISO week of year
         *    - `R`: ISO week-numbering year
         *    - `o`: ordinal number modifier
         *    - `P`: long localized date
         *    - `p`: long localized time
         *
         * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
         *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         *
         * 7. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
         *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         *
         * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
         *    on the given locale.
         *
         *    using `en-US` locale: `P` => `MM/dd/yyyy`
         *    using `en-US` locale: `p` => `hh:mm a`
         *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
         *    using `pt-BR` locale: `p` => `HH:mm`
         *
         * Values will be assigned to the date in the descending order of its unit's priority.
         * Units of an equal priority overwrite each other in the order of appearance.
         *
         * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
         * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
         *
         * `referenceDate` must be passed for correct work of the function.
         * If you're not sure which `referenceDate` to supply, create a new instance of Date:
         * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
         * In this case parsing will be done in the context of the current date.
         * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
         * then `Invalid Date` will be returned.
         *
         * The result may vary by locale.
         *
         * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
         *
         * If parsing failed, `Invalid Date` will be returned.
         * Invalid Date is a Date, whose time value is NaN.
         * Time value of Date: http://es5.github.io/#x15.9.1.1
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param dateStr - The string to parse
         * @param formatStr - The string of tokens
         * @param referenceDate - defines values missing from the parsed dateString
         * @param options - An object with options.
         *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         *
         * @returns The parsed date
         *
         * @throws `options.locale` must contain `match` property
         * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
         * @throws format string contains an unescaped latin alphabet character
         *
         * @example
         * // Parse 11 February 2014 from middle-endian format:
         * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
         * //=> Tue Feb 11 2014 00:00:00
         *
         * @example
         * // Parse 28th of February in Esperanto locale in the context of 2010 year:
         * import eo from 'date-fns/locale/eo'
         * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
         *   locale: eo
         * })
         * //=> Sun Feb 28 2010 00:00:00
         */
        function parse(dateStr, formatStr, referenceDate, options) {
          const invalidDate = () => constructFrom(referenceDate, NaN);
          const defaultOptions = getDefaultOptions();
          const locale = defaultOptions.locale ?? enUS;
          const firstWeekContainsDate = defaultOptions.firstWeekContainsDate ?? defaultOptions.locale?.options?.firstWeekContainsDate ?? 1;
          const weekStartsOn = defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
          if (!formatStr) return dateStr ? invalidDate() : toDate$1(referenceDate, options?.in);
          const subFnOptions = {
            firstWeekContainsDate,
            weekStartsOn,
            locale
          };

          // If timezone isn't specified, it will try to use the context or
          // the reference date and fallback to the system time zone.
          const setters = [new DateTimezoneSetter(options?.in, referenceDate)];
          const tokens = formatStr.match(longFormattingTokensRegExp).map(substring => {
            const firstCharacter = substring[0];
            if (firstCharacter in longFormatters) {
              const longFormatter = longFormatters[firstCharacter];
              return longFormatter(substring, locale.formatLong);
            }
            return substring;
          }).join("").match(formattingTokensRegExp);
          const usedTokens = [];
          for (let token of tokens) {
            if (isProtectedWeekYearToken(token)) {
              warnOrThrowProtectedError(token, formatStr, dateStr);
            }
            if (isProtectedDayOfYearToken(token)) {
              warnOrThrowProtectedError(token, formatStr, dateStr);
            }
            const firstCharacter = token[0];
            const parser = parsers[firstCharacter];
            if (parser) {
              const {
                incompatibleTokens
              } = parser;
              if (Array.isArray(incompatibleTokens)) {
                const incompatibleToken = usedTokens.find(usedToken => incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter);
                if (incompatibleToken) {
                  throw new RangeError(`The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`);
                }
              } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
                throw new RangeError(`The format string mustn't contain \`${token}\` and any other token at the same time`);
              }
              usedTokens.push({
                token: firstCharacter,
                fullToken: token
              });
              const parseResult = parser.run(dateStr, token, locale.match, subFnOptions);
              if (!parseResult) {
                return invalidDate();
              }
              setters.push(parseResult.setter);
              dateStr = parseResult.rest;
            } else {
              if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
                throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
              }

              // Replace two single quote characters with one single quote character
              if (token === "''") {
                token = "'";
              } else if (firstCharacter === "'") {
                token = cleanEscapedString(token);
              }

              // Cut token from string, or, if string doesn't match the token, return Invalid Date
              if (dateStr.indexOf(token) === 0) {
                dateStr = dateStr.slice(token.length);
              } else {
                return invalidDate();
              }
            }
          }

          // Check if the remaining input contains something other than whitespace
          if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
            return invalidDate();
          }
          const uniquePrioritySetters = setters.map(setter => setter.priority).sort((a, b) => b - a).filter((priority, index, array) => array.indexOf(priority) === index).map(priority => setters.filter(setter => setter.priority === priority).sort((a, b) => b.subPriority - a.subPriority)).map(setterArray => setterArray[0]);
          let date = toDate$1(referenceDate, options?.in);
          if (isNaN(+date)) return invalidDate();
          const flags = {};
          for (const setter of uniquePrioritySetters) {
            if (!setter.validate(date, subFnOptions)) {
              return invalidDate();
            }
            const result = setter.set(date, flags, subFnOptions);
            // Result is tuple (date, flags)
            if (Array.isArray(result)) {
              date = result[0];
              Object.assign(flags, result[1]);
              // Result is date
            } else {
              date = result;
            }
          }
          return date;
        }
        function cleanEscapedString(input) {
          return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
        }

        /**
         * @name isPast
         * @category Common Helpers
         * @summary Is the given date in the past?
         * @pure false
         *
         * @description
         * Is the given date in the past?
         *
         * @param date - The date to check
         *
         * @returns The date is in the past
         *
         * @example
         * // If today is 6 October 2014, is 2 July 2014 in the past?
         * const result = isPast(new Date(2014, 6, 2))
         * //=> true
         */
        function isPast(date) {
          return +toDate$1(date) < Date.now();
        }

        /**
         * The {@link isWithinInterval} function options.
         */

        /**
         * @name isWithinInterval
         * @category Interval Helpers
         * @summary Is the given date within the interval?
         *
         * @description
         * Is the given date within the interval? (Including start and end.)
         *
         * @param date - The date to check
         * @param interval - The interval to check
         * @param options - An object with options
         *
         * @returns The date is within the interval
         *
         * @example
         * // For the date within the interval:
         * isWithinInterval(new Date(2014, 0, 3), {
         *   start: new Date(2014, 0, 1),
         *   end: new Date(2014, 0, 7)
         * })
         * // => true
         *
         * @example
         * // For the date outside of the interval:
         * isWithinInterval(new Date(2014, 0, 10), {
         *   start: new Date(2014, 0, 1),
         *   end: new Date(2014, 0, 7)
         * })
         * // => false
         *
         * @example
         * // For date equal to the interval start:
         * isWithinInterval(date, { start, end: date })
         * // => true
         *
         * @example
         * // For date equal to the interval end:
         * isWithinInterval(date, { start: date, end })
         * // => true
         */
        function isWithinInterval(date, interval, options) {
          const time = +toDate$1(date, options?.in);
          const [startTime, endTime] = [+toDate$1(interval.start, options?.in), +toDate$1(interval.end, options?.in)].sort((a, b) => a - b);
          return time >= startTime && time <= endTime;
        }

        /**
         * The {@link parseISO} function options.
         */

        /**
         * @name parseISO
         * @category Common Helpers
         * @summary Parse ISO string
         *
         * @description
         * Parse the given string in ISO 8601 format and return an instance of Date.
         *
         * Function accepts complete ISO 8601 formats as well as partial implementations.
         * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
         *
         * If the argument isn't a string, the function cannot parse the string or
         * the values are invalid, it returns Invalid Date.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param argument - The value to convert
         * @param options - An object with options
         *
         * @returns The parsed date in the local time zone
         *
         * @example
         * // Convert string '2014-02-11T11:30:30' to date:
         * const result = parseISO('2014-02-11T11:30:30')
         * //=> Tue Feb 11 2014 11:30:30
         *
         * @example
         * // Convert string '+02014101' to date,
         * // if the additional number of digits in the extended year format is 1:
         * const result = parseISO('+02014101', { additionalDigits: 1 })
         * //=> Fri Apr 11 2014 00:00:00
         */
        function parseISO(argument, options) {
          const invalidDate = () => constructFrom(options?.in, NaN);
          const additionalDigits = 2;
          const dateStrings = splitDateString$1(argument);
          let date;
          if (dateStrings.date) {
            const parseYearResult = parseYear$1(dateStrings.date, additionalDigits);
            date = parseDate$1(parseYearResult.restDateString, parseYearResult.year);
          }
          if (!date || isNaN(+date)) return invalidDate();
          const timestamp = +date;
          let time = 0;
          let offset;
          if (dateStrings.time) {
            time = parseTime$1(dateStrings.time);
            if (isNaN(time)) return invalidDate();
          }
          if (dateStrings.timezone) {
            offset = parseTimezone(dateStrings.timezone);
            if (isNaN(offset)) return invalidDate();
          } else {
            const tmpDate = new Date(timestamp + time);
            const result = toDate$1(0, options?.in);
            result.setFullYear(tmpDate.getUTCFullYear(), tmpDate.getUTCMonth(), tmpDate.getUTCDate());
            result.setHours(tmpDate.getUTCHours(), tmpDate.getUTCMinutes(), tmpDate.getUTCSeconds(), tmpDate.getUTCMilliseconds());
            return result;
          }
          return toDate$1(timestamp + time + offset, options?.in);
        }
        const patterns$2 = {
          dateTimeDelimiter: /[T ]/,
          timeZoneDelimiter: /[Z ]/i,
          timezone: /([Z+-].*)$/
        };
        const dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
        const timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
        const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
        function splitDateString$1(dateString) {
          const dateStrings = {};
          const array = dateString.split(patterns$2.dateTimeDelimiter);
          let timeString;

          // The regex match should only return at maximum two array elements.
          // [date], [time], or [date, time].
          if (array.length > 2) {
            return dateStrings;
          }
          if (/:/.test(array[0])) {
            timeString = array[0];
          } else {
            dateStrings.date = array[0];
            timeString = array[1];
            if (patterns$2.timeZoneDelimiter.test(dateStrings.date)) {
              dateStrings.date = dateString.split(patterns$2.timeZoneDelimiter)[0];
              timeString = dateString.substr(dateStrings.date.length, dateString.length);
            }
          }
          if (timeString) {
            const token = patterns$2.timezone.exec(timeString);
            if (token) {
              dateStrings.time = timeString.replace(token[1], "");
              dateStrings.timezone = token[1];
            } else {
              dateStrings.time = timeString;
            }
          }
          return dateStrings;
        }
        function parseYear$1(dateString, additionalDigits) {
          const regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
          const captures = dateString.match(regex);
          // Invalid ISO-formatted year
          if (!captures) return {
            year: NaN,
            restDateString: ""
          };
          const year = captures[1] ? parseInt(captures[1]) : null;
          const century = captures[2] ? parseInt(captures[2]) : null;

          // either year or century is null, not both
          return {
            year: century === null ? year : century * 100,
            restDateString: dateString.slice((captures[1] || captures[2]).length)
          };
        }
        function parseDate$1(dateString, year) {
          // Invalid ISO-formatted year
          if (year === null) return new Date(NaN);
          const captures = dateString.match(dateRegex);
          // Invalid ISO-formatted string
          if (!captures) return new Date(NaN);
          const isWeekDate = !!captures[4];
          const dayOfYear = parseDateUnit(captures[1]);
          const month = parseDateUnit(captures[2]) - 1;
          const day = parseDateUnit(captures[3]);
          const week = parseDateUnit(captures[4]);
          const dayOfWeek = parseDateUnit(captures[5]) - 1;
          if (isWeekDate) {
            if (!validateWeekDate$1(year, week, dayOfWeek)) {
              return new Date(NaN);
            }
            return dayOfISOWeekYear$1(year, week, dayOfWeek);
          } else {
            const date = new Date(0);
            if (!validateDate$1(year, month, day) || !validateDayOfYearDate$1(year, dayOfYear)) {
              return new Date(NaN);
            }
            date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
            return date;
          }
        }
        function parseDateUnit(value) {
          return value ? parseInt(value) : 1;
        }
        function parseTime$1(timeString) {
          const captures = timeString.match(timeRegex);
          if (!captures) return NaN; // Invalid ISO-formatted time

          const hours = parseTimeUnit(captures[1]);
          const minutes = parseTimeUnit(captures[2]);
          const seconds = parseTimeUnit(captures[3]);
          if (!validateTime$1(hours, minutes, seconds)) {
            return NaN;
          }
          return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1000;
        }
        function parseTimeUnit(value) {
          return value && parseFloat(value.replace(",", ".")) || 0;
        }
        function parseTimezone(timezoneString) {
          if (timezoneString === "Z") return 0;
          const captures = timezoneString.match(timezoneRegex);
          if (!captures) return 0;
          const sign = captures[1] === "+" ? -1 : 1;
          const hours = parseInt(captures[2]);
          const minutes = captures[3] && parseInt(captures[3]) || 0;
          if (!validateTimezone$1(hours, minutes)) {
            return NaN;
          }
          return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
        }
        function dayOfISOWeekYear$1(isoWeekYear, week, day) {
          const date = new Date(0);
          date.setUTCFullYear(isoWeekYear, 0, 4);
          const fourthOfJanuaryDay = date.getUTCDay() || 7;
          const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
          date.setUTCDate(date.getUTCDate() + diff);
          return date;
        }

        // Validation functions

        // February is null to handle the leap year (using ||)
        const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function isLeapYearIndex$1(year) {
          return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
        }
        function validateDate$1(year, month, date) {
          return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex$1(year) ? 29 : 28));
        }
        function validateDayOfYearDate$1(year, dayOfYear) {
          return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex$1(year) ? 366 : 365);
        }
        function validateWeekDate$1(_year, week, day) {
          return week >= 1 && week <= 53 && day >= 0 && day <= 6;
        }
        function validateTime$1(hours, minutes, seconds) {
          if (hours === 24) {
            return minutes === 0 && seconds === 0;
          }
          return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
        }
        function validateTimezone$1(_hours, minutes) {
          return minutes >= 0 && minutes <= 59;
        }

        /**
         * The subMonths function options.
         */

        /**
         * @name subMonths
         * @category Month Helpers
         * @summary Subtract the specified number of months from the given date.
         *
         * @description
         * Subtract the specified number of months from the given date.
         *
         * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
         * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
         *
         * @param date - The date to be changed
         * @param amount - The amount of months to be subtracted.
         * @param options - An object with options
         *
         * @returns The new date with the months subtracted
         *
         * @example
         * // Subtract 5 months from 1 February 2015:
         * const result = subMonths(new Date(2015, 1, 1), 5)
         * //=> Mon Sep 01 2014 00:00:00
         */
        function subMonths(date, amount, options) {
          return addMonths(date, -1, options);
        }

        /**
         * Returns the formatted time zone name of the provided `timeZone` or the current
         * system time zone if omitted, accounting for DST according to the UTC value of
         * the date.
         */
        function tzIntlTimeZoneName(length, date, options) {
          const defaultOptions = getDefaultOptions();
          const dtf = getDTF(length, options.timeZone, options.locale ?? defaultOptions.locale);
          return 'formatToParts' in dtf ? partsTimeZone(dtf, date) : hackyTimeZone(dtf, date);
        }
        function partsTimeZone(dtf, date) {
          const formatted = dtf.formatToParts(date);
          for (let i = formatted.length - 1; i >= 0; --i) {
            if (formatted[i].type === 'timeZoneName') {
              return formatted[i].value;
            }
          }
          return undefined;
        }
        function hackyTimeZone(dtf, date) {
          const formatted = dtf.format(date).replace(/\u200E/g, '');
          const tzNameMatch = / [\w-+ ]+$/.exec(formatted);
          return tzNameMatch ? tzNameMatch[0].substr(1) : '';
        }
        // If a locale has been provided `en-US` is used as a fallback in case it is an
        // invalid locale, otherwise the locale is left undefined to use the system locale.
        function getDTF(length, timeZone, locale) {
          return new Intl.DateTimeFormat(locale ? [locale.code, 'en-US'] : undefined, {
            timeZone: timeZone,
            timeZoneName: length
          });
        }

        /**
         * Returns the [year, month, day, hour, minute, seconds] tokens of the provided
         * `date` as it will be rendered in the `timeZone`.
         */
        function tzTokenizeDate(date, timeZone) {
          const dtf = getDateTimeFormat(timeZone);
          return 'formatToParts' in dtf ? partsOffset(dtf, date) : hackyOffset(dtf, date);
        }
        const typeToPos = {
          year: 0,
          month: 1,
          day: 2,
          hour: 3,
          minute: 4,
          second: 5
        };
        function partsOffset(dtf, date) {
          try {
            const formatted = dtf.formatToParts(date);
            const filled = [];
            for (let i = 0; i < formatted.length; i++) {
              const pos = typeToPos[formatted[i].type];
              if (pos !== undefined) {
                filled[pos] = parseInt(formatted[i].value, 10);
              }
            }
            return filled;
          } catch (error) {
            if (error instanceof RangeError) {
              return [NaN];
            }
            throw error;
          }
        }
        function hackyOffset(dtf, date) {
          const formatted = dtf.format(date);
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
          // const [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed
          // return [fYear, fMonth, fDay, fHour, fMinute, fSecond]
          return [parseInt(parsed[3], 10), parseInt(parsed[1], 10), parseInt(parsed[2], 10), parseInt(parsed[4], 10), parseInt(parsed[5], 10), parseInt(parsed[6], 10)];
        }
        // Get a cached Intl.DateTimeFormat instance for the IANA `timeZone`. This can be used
        // to get deterministic local date/time output according to the `en-US` locale which
        // can be used to extract local time parts as necessary.
        const dtfCache = {};
        // New browsers use `hourCycle`, IE and Chrome <73 does not support it and uses `hour12`
        const testDateFormatted = new Intl.DateTimeFormat('en-US', {
          hourCycle: 'h23',
          timeZone: 'America/New_York',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        }).format(new Date('2014-06-25T04:00:00.123Z'));
        const hourCycleSupported = testDateFormatted === '06/25/2014, 00:00:00' || testDateFormatted === '06/25/2014 00:00:00';
        function getDateTimeFormat(timeZone) {
          if (!dtfCache[timeZone]) {
            dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat('en-US', {
              hourCycle: 'h23',
              timeZone: timeZone,
              year: 'numeric',
              month: 'numeric',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit'
            }) : new Intl.DateTimeFormat('en-US', {
              hour12: false,
              timeZone: timeZone,
              year: 'numeric',
              month: 'numeric',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit'
            });
          }
          return dtfCache[timeZone];
        }

        /**
         * Use instead of `new Date(Date.UTC(...))` to support years below 100 which doesn't work
         * otherwise due to the nature of the
         * [`Date` constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years.
         *
         * For `Date.UTC(...)`, use `newDateUTC(...).getTime()`.
         */
        function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {
          const utcDate = new Date(0);
          utcDate.setUTCFullYear(fullYear, month, day);
          utcDate.setUTCHours(hour, minute, second, millisecond);
          return utcDate;
        }
        const MILLISECONDS_IN_HOUR$1 = 3600000;
        const MILLISECONDS_IN_MINUTE$2 = 60000;
        const patterns$1 = {
          timezoneZ: /^(Z)$/,
          timezoneHH: /^([+-]\d{2})$/,
          timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
        };
        // Parse constious time zone offset formats to an offset in milliseconds
        function tzParseTimezone(timezoneString, date, isUtcDate) {
          // Empty string
          if (!timezoneString) {
            return 0;
          }
          // Z
          let token = patterns$1.timezoneZ.exec(timezoneString);
          if (token) {
            return 0;
          }
          let hours;
          let absoluteOffset;
          // hh
          token = patterns$1.timezoneHH.exec(timezoneString);
          if (token) {
            hours = parseInt(token[1], 10);
            if (!validateTimezone(hours)) {
              return NaN;
            }
            return -(hours * MILLISECONDS_IN_HOUR$1);
          }
          // hh:mm or hhmm
          token = patterns$1.timezoneHHMM.exec(timezoneString);
          if (token) {
            hours = parseInt(token[2], 10);
            const minutes = parseInt(token[3], 10);
            if (!validateTimezone(hours, minutes)) {
              return NaN;
            }
            absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2;
            return token[1] === '+' ? -absoluteOffset : absoluteOffset;
          }
          // IANA time zone
          if (isValidTimezoneIANAString(timezoneString)) {
            date = new Date(date || Date.now());
            const utcDate = isUtcDate ? date : toUtcDate(date);
            const offset = calcOffset(utcDate, timezoneString);
            const fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);
            return -fixedOffset;
          }
          return NaN;
        }
        function toUtcDate(date) {
          return newDateUTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        function calcOffset(date, timezoneString) {
          const tokens = tzTokenizeDate(date, timezoneString);
          // ms dropped because it's not provided by tzTokenizeDate
          const asUTC = newDateUTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5], 0).getTime();
          let asTS = date.getTime();
          const over = asTS % 1000;
          asTS -= over >= 0 ? over : 1000 + over;
          return asUTC - asTS;
        }
        function fixOffset(date, offset, timezoneString) {
          const localTS = date.getTime();
          // Our UTC time is just a guess because our offset is just a guess
          let utcGuess = localTS - offset;
          // Test whether the zone matches the offset for this ts
          const o2 = calcOffset(new Date(utcGuess), timezoneString);
          // If so, offset didn't change, and we're done
          if (offset === o2) {
            return offset;
          }
          // If not, change the ts by the difference in the offset
          utcGuess -= o2 - offset;
          // If that gives us the local time we want, we're done
          const o3 = calcOffset(new Date(utcGuess), timezoneString);
          if (o2 === o3) {
            return o2;
          }
          // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time
          return Math.max(o2, o3);
        }
        function validateTimezone(hours, minutes) {
          return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);
        }
        const validIANATimezoneCache = {};
        function isValidTimezoneIANAString(timeZoneString) {
          if (validIANATimezoneCache[timeZoneString]) return true;
          try {
            new Intl.DateTimeFormat(undefined, {
              timeZone: timeZoneString
            });
            validIANATimezoneCache[timeZoneString] = true;
            return true;
          } catch (error) {
            return false;
          }
        }
        const MILLISECONDS_IN_MINUTE$1 = 60 * 1000;
        const formatters = {
          // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
          X: function (date, token, options) {
            const timezoneOffset = getTimeZoneOffset(options.timeZone, date);
            if (timezoneOffset === 0) {
              return 'Z';
            }
            switch (token) {
              // Hours and optional minutes
              case 'X':
                return formatTimezoneWithOptionalMinutes(timezoneOffset);
              // Hours, minutes and optional seconds without `:` delimeter
              // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
              // so this token always has the same output as `XX`
              case 'XXXX':
              case 'XX':
                // Hours and minutes without `:` delimeter
                return formatTimezone(timezoneOffset);
              // Hours, minutes and optional seconds with `:` delimeter
              // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
              // so this token always has the same output as `XXX`
              case 'XXXXX':
              case 'XXX': // Hours and minutes with `:` delimeter
              default:
                return formatTimezone(timezoneOffset, ':');
            }
          },
          // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
          x: function (date, token, options) {
            const timezoneOffset = getTimeZoneOffset(options.timeZone, date);
            switch (token) {
              // Hours and optional minutes
              case 'x':
                return formatTimezoneWithOptionalMinutes(timezoneOffset);
              // Hours, minutes and optional seconds without `:` delimeter
              // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
              // so this token always has the same output as `xx`
              case 'xxxx':
              case 'xx':
                // Hours and minutes without `:` delimeter
                return formatTimezone(timezoneOffset);
              // Hours, minutes and optional seconds with `:` delimeter
              // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
              // so this token always has the same output as `xxx`
              case 'xxxxx':
              case 'xxx': // Hours and minutes with `:` delimeter
              default:
                return formatTimezone(timezoneOffset, ':');
            }
          },
          // Timezone (GMT)
          O: function (date, token, options) {
            const timezoneOffset = getTimeZoneOffset(options.timeZone, date);
            switch (token) {
              // Short
              case 'O':
              case 'OO':
              case 'OOO':
                return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
              // Long
              case 'OOOO':
              default:
                return 'GMT' + formatTimezone(timezoneOffset, ':');
            }
          },
          // Timezone (specific non-location)
          z: function (date, token, options) {
            switch (token) {
              // Short
              case 'z':
              case 'zz':
              case 'zzz':
                return tzIntlTimeZoneName('short', date, options);
              // Long
              case 'zzzz':
              default:
                return tzIntlTimeZoneName('long', date, options);
            }
          }
        };
        function getTimeZoneOffset(timeZone, originalDate) {
          const timeZoneOffset = timeZone ? tzParseTimezone(timeZone, originalDate, true) / MILLISECONDS_IN_MINUTE$1 : originalDate?.getTimezoneOffset() ?? 0;
          if (Number.isNaN(timeZoneOffset)) {
            throw new RangeError('Invalid time zone specified: ' + timeZone);
          }
          return timeZoneOffset;
        }
        function addLeadingZeros(number, targetLength) {
          const sign = number < 0 ? '-' : '';
          let output = Math.abs(number).toString();
          while (output.length < targetLength) {
            output = '0' + output;
          }
          return sign + output;
        }
        function formatTimezone(offset, delimiter = '') {
          const sign = offset > 0 ? '-' : '+';
          const absOffset = Math.abs(offset);
          const hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
          const minutes = addLeadingZeros(Math.floor(absOffset % 60), 2);
          return sign + hours + delimiter + minutes;
        }
        function formatTimezoneWithOptionalMinutes(offset, delimiter) {
          if (offset % 60 === 0) {
            const sign = offset > 0 ? '-' : '+';
            return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
          }
          return formatTimezone(offset, delimiter);
        }
        function formatTimezoneShort(offset, delimiter = '') {
          const sign = offset > 0 ? '-' : '+';
          const absOffset = Math.abs(offset);
          const hours = Math.floor(absOffset / 60);
          const minutes = absOffset % 60;
          if (minutes === 0) {
            return sign + String(hours);
          }
          return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
        }

        /**
         * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
         * They usually appear for dates that denote time before the timezones were introduced
         * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
         * and GMT+01:00:00 after that date)
         *
         * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
         * which would lead to incorrect calculations.
         *
         * This function returns the timezone offset in milliseconds that takes seconds in account.
         */
        function getTimezoneOffsetInMilliseconds(date) {
          const utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
          utcDate.setUTCFullYear(date.getFullYear());
          return +date - +utcDate;
        }

        /** Regex to identify the presence of a time zone specifier in a date string */
        const tzPattern = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;
        const MILLISECONDS_IN_HOUR = 3600000;
        const MILLISECONDS_IN_MINUTE = 60000;
        const DEFAULT_ADDITIONAL_DIGITS = 2;
        const patterns = {
          dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
          datePattern: /^([0-9W+-]+)(.*)/,
          // year tokens
          YY: /^(\d{2})$/,
          YYY: [/^([+-]\d{2})$/,
          // 0 additional digits
          /^([+-]\d{3})$/,
          // 1 additional digit
          /^([+-]\d{4})$/ // 2 additional digits
          ],
          YYYY: /^(\d{4})/,
          YYYYY: [/^([+-]\d{4})/,
          // 0 additional digits
          /^([+-]\d{5})/,
          // 1 additional digit
          /^([+-]\d{6})/ // 2 additional digits
          ],
          // date tokens
          MM: /^-(\d{2})$/,
          DDD: /^-?(\d{3})$/,
          MMDD: /^-?(\d{2})-?(\d{2})$/,
          Www: /^-?W(\d{2})$/,
          WwwD: /^-?W(\d{2})-?(\d{1})$/,
          HH: /^(\d{2}([.,]\d*)?)$/,
          HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
          HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
          // time zone tokens (to identify the presence of a tz)
          timeZone: tzPattern
        };
        /**
         * @name toDate
         * @category Common Helpers
         * @summary Convert the given argument to an instance of Date.
         *
         * @description
         * Convert the given argument to an instance of Date.
         *
         * If the argument is an instance of Date, the function returns its clone.
         *
         * If the argument is a number, it is treated as a timestamp.
         *
         * If an argument is a string, the function tries to parse it.
         * Function accepts complete ISO 8601 formats as well as partial implementations.
         * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
         * If the function cannot parse the string or the values are invalid, it returns Invalid Date.
         *
         * If the argument is none of the above, the function returns Invalid Date.
         *
         * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
         * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
         *
         * @param argument the value to convert
         * @param options the object with options. See [Options]{@link https://date-fns.org/docs/Options}
         * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
         * @param {string} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
         *
         * @returns the parsed date in the local time zone
         * @throws {TypeError} 1 argument required
         * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
         *
         * @example
         * // Convert string '2014-02-11T11:30:30' to date:
         * const result = toDate('2014-02-11T11:30:30')
         * //=> Tue Feb 11 2014 11:30:30
         *
         * @example
         * // Convert string '+02014101' to date,
         * // if the additional number of digits in the extended year format is 1:
         * const result = toDate('+02014101', {additionalDigits: 1})
         * //=> Fri Apr 11 2014 00:00:00
         */
        function toDate(argument, options = {}) {
          if (arguments.length < 1) {
            throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
          }
          if (argument === null) {
            return new Date(NaN);
          }
          const additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);
          if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
            throw new RangeError('additionalDigits must be 0, 1 or 2');
          }
          // Clone the date
          if (argument instanceof Date || typeof argument === 'object' && Object.prototype.toString.call(argument) === '[object Date]') {
            // Prevent the date to lose the milliseconds when passed to new Date() in IE10
            return new Date(argument.getTime());
          } else if (typeof argument === 'number' || Object.prototype.toString.call(argument) === '[object Number]') {
            return new Date(argument);
          } else if (!(Object.prototype.toString.call(argument) === '[object String]')) {
            return new Date(NaN);
          }
          const dateStrings = splitDateString(argument);
          const {
            year,
            restDateString
          } = parseYear(dateStrings.date, additionalDigits);
          const date = parseDate(restDateString, year);
          if (date === null || isNaN(date.getTime())) {
            return new Date(NaN);
          }
          if (date) {
            const timestamp = date.getTime();
            let time = 0;
            let offset;
            if (dateStrings.time) {
              time = parseTime(dateStrings.time);
              if (time === null || isNaN(time)) {
                return new Date(NaN);
              }
            }
            if (dateStrings.timeZone || options.timeZone) {
              offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));
              if (isNaN(offset)) {
                return new Date(NaN);
              }
            } else {
              // get offset accurate to hour in time zones that change offset
              offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));
              offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset));
            }
            return new Date(timestamp + time + offset);
          } else {
            return new Date(NaN);
          }
        }
        function splitDateString(dateString) {
          const dateStrings = {};
          let parts = patterns.dateTimePattern.exec(dateString);
          let timeString;
          if (!parts) {
            parts = patterns.datePattern.exec(dateString);
            if (parts) {
              dateStrings.date = parts[1];
              timeString = parts[2];
            } else {
              dateStrings.date = null;
              timeString = dateString;
            }
          } else {
            dateStrings.date = parts[1];
            timeString = parts[3];
          }
          if (timeString) {
            const token = patterns.timeZone.exec(timeString);
            if (token) {
              dateStrings.time = timeString.replace(token[1], '');
              dateStrings.timeZone = token[1].trim();
            } else {
              dateStrings.time = timeString;
            }
          }
          return dateStrings;
        }
        function parseYear(dateString, additionalDigits) {
          if (dateString) {
            const patternYYY = patterns.YYY[additionalDigits];
            const patternYYYYY = patterns.YYYYY[additionalDigits];
            // YYYY or YYYYY
            let token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
            if (token) {
              const yearString = token[1];
              return {
                year: parseInt(yearString, 10),
                restDateString: dateString.slice(yearString.length)
              };
            }
            // YY or YYY
            token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);
            if (token) {
              const centuryString = token[1];
              return {
                year: parseInt(centuryString, 10) * 100,
                restDateString: dateString.slice(centuryString.length)
              };
            }
          }
          // Invalid ISO-formatted year
          return {
            year: null
          };
        }
        function parseDate(dateString, year) {
          // Invalid ISO-formatted year
          if (year === null) {
            return null;
          }
          let date;
          let month;
          let week;
          // YYYY
          if (!dateString || !dateString.length) {
            date = new Date(0);
            date.setUTCFullYear(year);
            return date;
          }
          // YYYY-MM
          let token = patterns.MM.exec(dateString);
          if (token) {
            date = new Date(0);
            month = parseInt(token[1], 10) - 1;
            if (!validateDate(year, month)) {
              return new Date(NaN);
            }
            date.setUTCFullYear(year, month);
            return date;
          }
          // YYYY-DDD or YYYYDDD
          token = patterns.DDD.exec(dateString);
          if (token) {
            date = new Date(0);
            const dayOfYear = parseInt(token[1], 10);
            if (!validateDayOfYearDate(year, dayOfYear)) {
              return new Date(NaN);
            }
            date.setUTCFullYear(year, 0, dayOfYear);
            return date;
          }
          // yyyy-MM-dd or YYYYMMDD
          token = patterns.MMDD.exec(dateString);
          if (token) {
            date = new Date(0);
            month = parseInt(token[1], 10) - 1;
            const day = parseInt(token[2], 10);
            if (!validateDate(year, month, day)) {
              return new Date(NaN);
            }
            date.setUTCFullYear(year, month, day);
            return date;
          }
          // YYYY-Www or YYYYWww
          token = patterns.Www.exec(dateString);
          if (token) {
            week = parseInt(token[1], 10) - 1;
            if (!validateWeekDate(week)) {
              return new Date(NaN);
            }
            return dayOfISOWeekYear(year, week);
          }
          // YYYY-Www-D or YYYYWwwD
          token = patterns.WwwD.exec(dateString);
          if (token) {
            week = parseInt(token[1], 10) - 1;
            const dayOfWeek = parseInt(token[2], 10) - 1;
            if (!validateWeekDate(week, dayOfWeek)) {
              return new Date(NaN);
            }
            return dayOfISOWeekYear(year, week, dayOfWeek);
          }
          // Invalid ISO-formatted date
          return null;
        }
        function parseTime(timeString) {
          let hours;
          let minutes;
          // hh
          let token = patterns.HH.exec(timeString);
          if (token) {
            hours = parseFloat(token[1].replace(',', '.'));
            if (!validateTime(hours)) {
              return NaN;
            }
            return hours % 24 * MILLISECONDS_IN_HOUR;
          }
          // hh:mm or hhmm
          token = patterns.HHMM.exec(timeString);
          if (token) {
            hours = parseInt(token[1], 10);
            minutes = parseFloat(token[2].replace(',', '.'));
            if (!validateTime(hours, minutes)) {
              return NaN;
            }
            return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
          }
          // hh:mm:ss or hhmmss
          token = patterns.HHMMSS.exec(timeString);
          if (token) {
            hours = parseInt(token[1], 10);
            minutes = parseInt(token[2], 10);
            const seconds = parseFloat(token[3].replace(',', '.'));
            if (!validateTime(hours, minutes, seconds)) {
              return NaN;
            }
            return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;
          }
          // Invalid ISO-formatted time
          return null;
        }
        function dayOfISOWeekYear(isoWeekYear, week, day) {
          week = week || 0;
          day = day || 0;
          const date = new Date(0);
          date.setUTCFullYear(isoWeekYear, 0, 4);
          const fourthOfJanuaryDay = date.getUTCDay() || 7;
          const diff = week * 7 + day + 1 - fourthOfJanuaryDay;
          date.setUTCDate(date.getUTCDate() + diff);
          return date;
        }
        // Validation functions
        const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        const DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function isLeapYearIndex(year) {
          return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
        }
        function validateDate(year, month, date) {
          if (month < 0 || month > 11) {
            return false;
          }
          if (date != null) {
            if (date < 1) {
              return false;
            }
            const isLeapYear = isLeapYearIndex(year);
            if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
              return false;
            }
            if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
              return false;
            }
          }
          return true;
        }
        function validateDayOfYearDate(year, dayOfYear) {
          if (dayOfYear < 1) {
            return false;
          }
          const isLeapYear = isLeapYearIndex(year);
          if (isLeapYear && dayOfYear > 366) {
            return false;
          }
          if (!isLeapYear && dayOfYear > 365) {
            return false;
          }
          return true;
        }
        function validateWeekDate(week, day) {
          if (week < 0 || week > 52) {
            return false;
          }
          if (day != null && (day < 0 || day > 6)) {
            return false;
          }
          return true;
        }
        function validateTime(hours, minutes, seconds) {
          if (hours < 0 || hours >= 25) {
            return false;
          }
          if (minutes != null && (minutes < 0 || minutes >= 60)) {
            return false;
          }
          if (seconds != null && (seconds < 0 || seconds >= 60)) {
            return false;
          }
          return true;
        }
        const tzFormattingTokensRegExp = /([xXOz]+)|''|'(''|[^'])+('|$)/g;
        /**
         * @name format
         * @category Common Helpers
         * @summary Format the date.
         *
         * @description
         * Return the formatted date string in the given format. The result may consty by locale.
         *
         * >  Please note that the `format` tokens differ from Moment.js and other libraries.
         * > See: https://git.io/fxCyr
         *
         * The characters wrapped between two single quotes characters (') are escaped.
         * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
         * (see the last example)
         *
         * Format of the string is based on Unicode Technical Standard #35:
         * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
         * with a few additions (see note 7 below the table).
         *
         * Accepted patterns:
         * | Unit                            | Pattern | Result examples                   | Notes |
         * |---------------------------------|---------|-----------------------------------|-------|
         * | Era                             | G..GGG  | AD, BC                            |       |
         * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
         * |                                 | GGGGG   | A, B                              |       |
         * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
         * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
         * |                                 | yy      | 44, 01, 00, 17                    | 5     |
         * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
         * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
         * |                                 | yyyyy   | ...                               | 3,5   |
         * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
         * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
         * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
         * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
         * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
         * |                                 | YYYYY   | ...                               | 3,5   |
         * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
         * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
         * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
         * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
         * |                                 | RRRRR   | ...                               | 3,5,7 |
         * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
         * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
         * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
         * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
         * |                                 | uuuuu   | ...                               | 3,5   |
         * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
         * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
         * |                                 | QQ      | 01, 02, 03, 04                    |       |
         * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
         * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
         * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
         * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
         * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
         * |                                 | qq      | 01, 02, 03, 04                    |       |
         * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
         * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
         * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
         * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
         * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
         * |                                 | MM      | 01, 02, ..., 12                   |       |
         * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
         * |                                 | MMMM    | January, February, ..., December  | 2     |
         * |                                 | MMMMM   | J, F, ..., D                      |       |
         * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
         * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
         * |                                 | LL      | 01, 02, ..., 12                   |       |
         * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
         * |                                 | LLLL    | January, February, ..., December  | 2     |
         * |                                 | LLLLL   | J, F, ..., D                      |       |
         * | Local week of year              | w       | 1, 2, ..., 53                     |       |
         * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
         * |                                 | ww      | 01, 02, ..., 53                   |       |
         * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
         * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
         * |                                 | II      | 01, 02, ..., 53                   | 7     |
         * | Day of month                    | d       | 1, 2, ..., 31                     |       |
         * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
         * |                                 | dd      | 01, 02, ..., 31                   |       |
         * | Day of year                     | D       | 1, 2, ..., 365, 366               | 8     |
         * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
         * |                                 | DD      | 01, 02, ..., 365, 366             | 8     |
         * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
         * |                                 | DDDD    | ...                               | 3     |
         * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
         * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
         * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
         * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
         * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
         * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
         * |                                 | ii      | 01, 02, ..., 07                   | 7     |
         * |                                 | iii     | Mon, Tue, Wed, ..., Su            | 7     |
         * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
         * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
         * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |
         * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
         * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
         * |                                 | ee      | 02, 03, ..., 01                   |       |
         * |                                 | eee     | Mon, Tue, Wed, ..., Su            |       |
         * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
         * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
         * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
         * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
         * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
         * |                                 | cc      | 02, 03, ..., 01                   |       |
         * |                                 | ccc     | Mon, Tue, Wed, ..., Su            |       |
         * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
         * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
         * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
         * | AM, PM                          | a..aaa  | AM, PM                            |       |
         * |                                 | aaaa    | a.m., p.m.                        | 2     |
         * |                                 | aaaaa   | a, p                              |       |
         * | AM, PM, noon, midnight          | b..bbb  | AM, PM, noon, midnight            |       |
         * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
         * |                                 | bbbbb   | a, p, n, mi                       |       |
         * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
         * |                                 | BBBB    | at night, in the morning, ...     | 2     |
         * |                                 | BBBBB   | at night, in the morning, ...     |       |
         * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
         * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
         * |                                 | hh      | 01, 02, ..., 11, 12               |       |
         * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
         * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
         * |                                 | HH      | 00, 01, 02, ..., 23               |       |
         * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
         * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
         * |                                 | KK      | 1, 2, ..., 11, 0                  |       |
         * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
         * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
         * |                                 | kk      | 24, 01, 02, ..., 23               |       |
         * | Minute                          | m       | 0, 1, ..., 59                     |       |
         * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
         * |                                 | mm      | 00, 01, ..., 59                   |       |
         * | Second                          | s       | 0, 1, ..., 59                     |       |
         * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
         * |                                 | ss      | 00, 01, ..., 59                   |       |
         * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
         * |                                 | SS      | 00, 01, ..., 99                   |       |
         * |                                 | SSS     | 000, 0001, ..., 999               |       |
         * |                                 | SSSS    | ...                               | 3     |
         * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
         * |                                 | XX      | -0800, +0530, Z                   |       |
         * |                                 | XXX     | -08:00, +05:30, Z                 |       |
         * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
         * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
         * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
         * |                                 | xx      | -0800, +0530, +0000               |       |
         * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
         * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
         * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
         * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
         * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
         * | Timezone (specific non-locat.)  | z...zzz | PDT, EST, CEST                    | 6     |
         * |                                 | zzzz    | Pacific Daylight Time             | 2,6   |
         * | Seconds timestamp               | t       | 512969520                         | 7     |
         * |                                 | tt      | ...                               | 3,7   |
         * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
         * |                                 | TT      | ...                               | 3,7   |
         * | Long localized date             | P       | 05/29/1453                        | 7     |
         * |                                 | PP      | May 29, 1453                      | 7     |
         * |                                 | PPP     | May 29th, 1453                    | 7     |
         * |                                 | PPPP    | Sunday, May 29th, 1453            | 2,7   |
         * | Long localized time             | p       | 12:00 AM                          | 7     |
         * |                                 | pp      | 12:00:00 AM                       | 7     |
         * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
         * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
         * | Combination of date and time    | Pp      | 05/29/1453, 12:00 AM              | 7     |
         * |                                 | PPpp    | May 29, 1453, 12:00:00 AM         | 7     |
         * |                                 | PPPppp  | May 29th, 1453 at ...             | 7     |
         * |                                 | PPPPpppp| Sunday, May 29th, 1453 at ...     | 2,7   |
         * Notes:
         * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
         *    are the same as "stand-alone" units, but are different in some languages.
         *    "Formatting" units are declined according to the rules of the language
         *    in the context of a date. "Stand-alone" units are always nominative singular:
         *
         *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
         *
         *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
         *
         * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
         *    the single quote characters (see below).
         *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
         *    the output will be the same as default pattern for this unit, usually
         *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
         *    are marked with "2" in the last column of the table.
         *
         *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
         *
         *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
         *
         *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
         *
         *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
         *
         *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
         *
         * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
         *    The output will be padded with zeros to match the length of the pattern.
         *
         *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
         *
         * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
         *    These tokens represent the shortest form of the quarter.
         *
         * 5. The main difference between `y` and `u` patterns are B.C. years:
         *
         *    | Year | `y` | `u` |
         *    |------|-----|-----|
         *    | AC 1 |   1 |   1 |
         *    | BC 1 |   1 |   0 |
         *    | BC 2 |   2 |  -1 |
         *
         *    Also `yy` always returns the last two digits of a year,
         *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
         *
         *    | Year | `yy` | `uu` |
         *    |------|------|------|
         *    | 1    |   01 |   01 |
         *    | 14   |   14 |   14 |
         *    | 376  |   76 |  376 |
         *    | 1453 |   53 | 1453 |
         *
         *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
         *    except local week-numbering years are dependent on `options.weekStartsOn`
         *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
         *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
         *
         * 6. Specific non-location timezones are created using the Intl browser API. The output is determined by the
         *    preferred standard of the current locale (en-US by default) which may not always give the expected result.
         *    For this reason it is recommended to supply a `locale` in the format options when formatting a time zone name.
         *
         * 7. These patterns are not in the Unicode Technical Standard #35:
         *    - `i`: ISO day of week
         *    - `I`: ISO week of year
         *    - `R`: ISO week-numbering year
         *    - `t`: seconds timestamp
         *    - `T`: milliseconds timestamp
         *    - `o`: ordinal number modifier
         *    - `P`: long localized date
         *    - `p`: long localized time
         *
         * 8. These tokens are often confused with others. See: https://git.io/fxCyr
         *
         *
         * ### v2.0.0 breaking changes:
         *
         * - [Changes that are common for the whole
         *   library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
         *
         * - The second argument is now required for the sake of explicitness.
         *
         *   ```javascript
         *   // Before v2.0.0
         *   format(new Date(2016, 0, 1))
         *
         *   // v2.0.0 onward
         *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
         *   ```
         *
         * - New format string API for `format` function
         *   which is based on [Unicode Technical Standard
         *   #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table). See [this
         *   post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
         *
         * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
         *
         * @param date the original date
         * @param formatStr the string of tokens
         * @param options the object with options. See [Options]{@link https://date-fns.org/docs/Options}
         * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link
         *   https://date-fns.org/docs/toDate}
         * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
         * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
         * @param {Locale} [options.locale=defaultLocale] - the locale object. See
         *   [Locale]{@link https://date-fns.org/docs/Locale}
         * @param {Boolean} [options.awareOfUnicodeTokens=false] - if true, allows usage of Unicode tokens causes confusion:
         *   - Some of the day of year tokens (`D`, `DD`) that are confused with the day of month tokens (`d`, `dd`).
         *   - Some of the local week-numbering year tokens (`YY`, `YYYY`) that are confused with the calendar year tokens
         *   (`yy`, `yyyy`). See: https://git.io/fxCyr
         * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
         * @param {Date|Number} [options.originalDate] - can be used to pass the original unmodified date to `format` to
         *   improve correctness of the replaced timezone token close to the DST threshold.
         * @throws {TypeError} 2 arguments required
         * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
         * @throws {RangeError} `options.locale` must contain `localize` property
         * @throws {RangeError} `options.locale` must contain `formatLong` property
         * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
         * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
         * @throws {RangeError} `options.awareOfUnicodeTokens` must be set to `true` to use `XX` token; see:
         *   https://git.io/fxCyr
         *
         * @example
         * // Represent 11 February 2014 in middle-endian format:
         * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
         * //=> '02/11/2014'
         *
         * @example
         * // Represent 2 July 2014 in Esperanto:
         * import { eoLocale } from 'date-fns/locale/eo'
         * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
         *   locale: eoLocale
         * })
         * //=> '2-a de julio 2014'
         *
         * @example
         * // Escape string by single quote characters:
         * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
         * //=> "3 o'clock"
         */
        function format(date, formatStr, options = {}) {
          formatStr = String(formatStr);
          const matches = formatStr.match(tzFormattingTokensRegExp);
          if (matches) {
            const d = toDate(options.originalDate || date, options);
            // Work through each match and replace the tz token in the format string with the quoted
            // formatted time zone so the remaining tokens can be filled in by date-fns#format.
            formatStr = matches.reduce(function (result, token) {
              if (token[0] === "'") {
                return result; // This is a quoted portion, matched only to ensure we don't match inside it
              }
              const pos = result.indexOf(token);
              const precededByQuotedSection = result[pos - 1] === "'";
              const replaced = result.replace(token, "'" + formatters[token[0]](d, token, options) + "'");
              // If the replacement results in two adjoining quoted strings, the back to back quotes
              // are removed, so it doesn't look like an escaped quote.
              return precededByQuotedSection ? replaced.substring(0, pos - 1) + replaced.substring(pos + 1) : replaced;
            }, formatStr);
          }
          return format$1(date, formatStr, options);
        }

        /**
         * @name toZonedTime
         * @category Time Zone Helpers
         * @summary Get a date/time representing local time in a given time zone from the UTC date
         *
         * @description
         * Returns a date instance with values representing the local time in the time zone
         * specified of the UTC time from the date provided. In other words, when the new date
         * is formatted it will show the equivalent hours in the target time zone regardless
         * of the current system time zone.
         *
         * @param date the date with the relevant UTC time
         * @param timeZone the time zone to get local time for, can be an offset or IANA time zone
         * @param options the object with options. See [Options]{@link https://date-fns.org/docs/Options}
         * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
         *
         * @throws {TypeError} 2 arguments required
         * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
         *
         * @example
         * // In June 10am UTC is 6am in New York (-04:00)
         * const result = toZonedTime('2014-06-25T10:00:00.000Z', 'America/New_York')
         * //=> Jun 25 2014 06:00:00
         */
        function toZonedTime(date, timeZone, options) {
          date = toDate(date, options);
          const offsetMilliseconds = tzParseTimezone(timeZone, date, true);
          const d = new Date(date.getTime() - offsetMilliseconds);
          const resultDate = new Date(0);
          resultDate.setFullYear(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
          resultDate.setHours(d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
          return resultDate;
        }

        /**
         * @name formatInTimeZone
         * @category Time Zone Helpers
         * @summary Gets the offset in milliseconds between the time zone and Universal Coordinated Time (UTC)
         *
         * @param date the date representing the local time / real UTC time
         * @param timeZone the time zone this date should be formatted for; can be an offset or IANA time zone
         * @param formatStr the string of tokens
         * @param options the object with options. See [Options]{@link https://date-fns.org/docs/Options}
         * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link
         *   https://date-fns.org/docs/toDate}
         * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
         * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
         * @param {Locale} [options.locale=defaultLocale] - the locale object. See
         *   [Locale]{@link https://date-fns.org/docs/Locale}
         * @param {Boolean} [options.awareOfUnicodeTokens=false] - if true, allows usage of Unicode tokens causes confusion:
         *   - Some of the day of year tokens (`D`, `DD`) that are confused with the day of month tokens (`d`, `dd`).
         *   - Some of the local week-numbering year tokens (`YY`, `YYYY`) that are confused with the calendar year tokens
         *   (`yy`, `yyyy`). See: https://git.io/fxCyr
         * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
         */
        function formatInTimeZone(date, timeZone, formatStr, options) {
          options = {
            ...options,
            timeZone,
            originalDate: date
          };
          return format(toZonedTime(date, timeZone, {
            timeZone: options.timeZone
          }), formatStr, options);
        }

        /*! Capacitor: https://capacitorjs.com/ - MIT License */
        var ExceptionCode;
        (function (ExceptionCode2) {
          ExceptionCode2["Unimplemented"] = "UNIMPLEMENTED";
          ExceptionCode2["Unavailable"] = "UNAVAILABLE";
        })(ExceptionCode || (ExceptionCode = {}));
        class CapacitorException extends Error {
          constructor(message, code, data) {
            super(message);
            this.message = message;
            this.code = code;
            this.data = data;
          }
        }
        const getPlatformId = win => {
          var _a, _b;
          if (win === null || win === void 0 ? void 0 : win.androidBridge) {
            return "android";
          } else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
            return "ios";
          } else {
            return "web";
          }
        };
        const createCapacitor = win => {
          const capCustomPlatform = win.CapacitorCustomPlatform || null;
          const cap = win.Capacitor || {};
          const Plugins = cap.Plugins = cap.Plugins || {};
          const getPlatform = () => {
            return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);
          };
          const isNativePlatform = () => getPlatform() !== "web";
          const isPluginAvailable = pluginName => {
            const plugin = registeredPlugins.get(pluginName);
            if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
              return true;
            }
            if (getPluginHeader(pluginName)) {
              return true;
            }
            return false;
          };
          const getPluginHeader = pluginName => {
            var _a;
            return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find(h => h.name === pluginName);
          };
          const handleError = err => win.console.error(err);
          const registeredPlugins = /* @__PURE__ */new Map();
          const registerPlugin2 = (pluginName, jsImplementations = {}) => {
            const registeredPlugin = registeredPlugins.get(pluginName);
            if (registeredPlugin) {
              console.warn(`Capacitor plugin "${pluginName}" already registered. Cannot register plugins twice.`);
              return registeredPlugin.proxy;
            }
            const platform = getPlatform();
            const pluginHeader = getPluginHeader(pluginName);
            let jsImplementation;
            const loadPluginImplementation = async () => {
              if (!jsImplementation && platform in jsImplementations) {
                jsImplementation = typeof jsImplementations[platform] === "function" ? jsImplementation = await jsImplementations[platform]() : jsImplementation = jsImplementations[platform];
              } else if (capCustomPlatform !== null && !jsImplementation && "web" in jsImplementations) {
                jsImplementation = typeof jsImplementations["web"] === "function" ? jsImplementation = await jsImplementations["web"]() : jsImplementation = jsImplementations["web"];
              }
              return jsImplementation;
            };
            const createPluginMethod = (impl, prop) => {
              var _a, _b;
              if (pluginHeader) {
                const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find(m => prop === m.name);
                if (methodHeader) {
                  if (methodHeader.rtype === "promise") {
                    return options => cap.nativePromise(pluginName, prop.toString(), options);
                  } else {
                    return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
                  }
                } else if (impl) {
                  return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);
                }
              } else if (impl) {
                return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);
              } else {
                throw new CapacitorException(`"${pluginName}" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);
              }
            };
            const createPluginMethodWrapper = prop => {
              let remove;
              const wrapper = (...args) => {
                const p = loadPluginImplementation().then(impl => {
                  const fn = createPluginMethod(impl, prop);
                  if (fn) {
                    const p2 = fn(...args);
                    remove = p2 === null || p2 === void 0 ? void 0 : p2.remove;
                    return p2;
                  } else {
                    throw new CapacitorException(`"${pluginName}.${prop}()" is not implemented on ${platform}`, ExceptionCode.Unimplemented);
                  }
                });
                if (prop === "addListener") {
                  p.remove = async () => remove();
                }
                return p;
              };
              wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;
              Object.defineProperty(wrapper, "name", {
                value: prop,
                writable: false,
                configurable: false
              });
              return wrapper;
            };
            const addListener = createPluginMethodWrapper("addListener");
            const removeListener = createPluginMethodWrapper("removeListener");
            const addListenerNative = (eventName, callback) => {
              const call = addListener({
                eventName
              }, callback);
              const remove = async () => {
                const callbackId = await call;
                removeListener({
                  eventName,
                  callbackId
                }, callback);
              };
              const p = new Promise(resolve => call.then(() => resolve({
                remove
              })));
              p.remove = async () => {
                console.warn(`Using addListener() without 'await' is deprecated.`);
                await remove();
              };
              return p;
            };
            const proxy = new Proxy({}, {
              get(_, prop) {
                switch (prop) {
                  // https://github.com/facebook/react/issues/20030
                  case "$$typeof":
                    return void 0;
                  case "toJSON":
                    return () => ({});
                  case "addListener":
                    return pluginHeader ? addListenerNative : addListener;
                  case "removeListener":
                    return removeListener;
                  default:
                    return createPluginMethodWrapper(prop);
                }
              }
            });
            Plugins[pluginName] = proxy;
            registeredPlugins.set(pluginName, {
              name: pluginName,
              proxy,
              platforms: /* @__PURE__ */new Set([...Object.keys(jsImplementations), ...(pluginHeader ? [platform] : [])])
            });
            return proxy;
          };
          if (!cap.convertFileSrc) {
            cap.convertFileSrc = filePath => filePath;
          }
          cap.getPlatform = getPlatform;
          cap.handleError = handleError;
          cap.isNativePlatform = isNativePlatform;
          cap.isPluginAvailable = isPluginAvailable;
          cap.registerPlugin = registerPlugin2;
          cap.Exception = CapacitorException;
          cap.DEBUG = !!cap.DEBUG;
          cap.isLoggingEnabled = !!cap.isLoggingEnabled;
          return cap;
        };
        const initCapacitorGlobal = win => win.Capacitor = createCapacitor(win);
        const Capacitor = /* @__PURE__ */initCapacitorGlobal(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {});
        const registerPlugin = Capacitor.registerPlugin;
        class WebPlugin {
          constructor() {
            this.listeners = {};
            this.retainedEventArguments = {};
            this.windowListeners = {};
          }
          addListener(eventName, listenerFunc) {
            let firstListener = false;
            const listeners = this.listeners[eventName];
            if (!listeners) {
              this.listeners[eventName] = [];
              firstListener = true;
            }
            this.listeners[eventName].push(listenerFunc);
            const windowListener = this.windowListeners[eventName];
            if (windowListener && !windowListener.registered) {
              this.addWindowListener(windowListener);
            }
            if (firstListener) {
              this.sendRetainedArgumentsForEvent(eventName);
            }
            const remove = async () => this.removeListener(eventName, listenerFunc);
            const p = Promise.resolve({
              remove
            });
            return p;
          }
          async removeAllListeners() {
            this.listeners = {};
            for (const listener in this.windowListeners) {
              this.removeWindowListener(this.windowListeners[listener]);
            }
            this.windowListeners = {};
          }
          notifyListeners(eventName, data, retainUntilConsumed) {
            const listeners = this.listeners[eventName];
            if (!listeners) {
              if (retainUntilConsumed) {
                let args = this.retainedEventArguments[eventName];
                if (!args) {
                  args = [];
                }
                args.push(data);
                this.retainedEventArguments[eventName] = args;
              }
              return;
            }
            listeners.forEach(listener => listener(data));
          }
          hasListeners(eventName) {
            var _a;
            return !!((_a = this.listeners[eventName]) === null || _a === void 0 ? void 0 : _a.length);
          }
          registerWindowListener(windowEventName, pluginEventName) {
            this.windowListeners[pluginEventName] = {
              registered: false,
              windowEventName,
              pluginEventName,
              handler: event => {
                this.notifyListeners(pluginEventName, event);
              }
            };
          }
          unimplemented(msg = "not implemented") {
            return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
          }
          unavailable(msg = "not available") {
            return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
          }
          async removeListener(eventName, listenerFunc) {
            const listeners = this.listeners[eventName];
            if (!listeners) {
              return;
            }
            const index = listeners.indexOf(listenerFunc);
            this.listeners[eventName].splice(index, 1);
            if (!this.listeners[eventName].length) {
              this.removeWindowListener(this.windowListeners[eventName]);
            }
          }
          addWindowListener(handle) {
            window.addEventListener(handle.windowEventName, handle.handler);
            handle.registered = true;
          }
          removeWindowListener(handle) {
            if (!handle) {
              return;
            }
            window.removeEventListener(handle.windowEventName, handle.handler);
            handle.registered = false;
          }
          sendRetainedArgumentsForEvent(eventName) {
            const args = this.retainedEventArguments[eventName];
            if (!args) {
              return;
            }
            delete this.retainedEventArguments[eventName];
            args.forEach(arg => {
              this.notifyListeners(eventName, arg);
            });
          }
        }
        const encode = str => encodeURIComponent(str).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
        const decode = str => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
        class CapacitorCookiesPluginWeb extends WebPlugin {
          async getCookies() {
            const cookies = document.cookie;
            const cookieMap = {};
            cookies.split(";").forEach(cookie => {
              if (cookie.length <= 0) return;
              let [key, value] = cookie.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
              key = decode(key).trim();
              value = decode(value).trim();
              cookieMap[key] = value;
            });
            return cookieMap;
          }
          async setCookie(options) {
            try {
              const encodedKey = encode(options.key);
              const encodedValue = encode(options.value);
              const expires = `; expires=${(options.expires || "").replace("expires=", "")}`;
              const path = (options.path || "/").replace("path=", "");
              const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : "";
              document.cookie = `${encodedKey}=${encodedValue || ""}${expires}; path=${path}; ${domain};`;
            } catch (error) {
              return Promise.reject(error);
            }
          }
          async deleteCookie(options) {
            try {
              document.cookie = `${options.key}=; Max-Age=0`;
            } catch (error) {
              return Promise.reject(error);
            }
          }
          async clearCookies() {
            try {
              const cookies = document.cookie.split(";") || [];
              for (const cookie of cookies) {
                document.cookie = cookie.replace(/^ +/, "").replace(/=.*/, `=;expires=${(/* @__PURE__ */new Date()).toUTCString()};path=/`);
              }
            } catch (error) {
              return Promise.reject(error);
            }
          }
          async clearAllCookies() {
            try {
              await this.clearCookies();
            } catch (error) {
              return Promise.reject(error);
            }
          }
        }
        registerPlugin("CapacitorCookies", {
          web: () => new CapacitorCookiesPluginWeb()
        });
        const readBlobAsBase64 = async blob => new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            const base64String = reader.result;
            resolve(base64String.indexOf(",") >= 0 ? base64String.split(",")[1] : base64String);
          };
          reader.onerror = error => reject(error);
          reader.readAsDataURL(blob);
        });
        const normalizeHttpHeaders = (headers = {}) => {
          const originalKeys = Object.keys(headers);
          const loweredKeys = Object.keys(headers).map(k => k.toLocaleLowerCase());
          const normalized = loweredKeys.reduce((acc, key, index) => {
            acc[key] = headers[originalKeys[index]];
            return acc;
          }, {});
          return normalized;
        };
        const buildUrlParams = (params, shouldEncode = true) => {
          if (!params) return null;
          const output = Object.entries(params).reduce((accumulator, entry) => {
            const [key, value] = entry;
            let encodedValue;
            let item;
            if (Array.isArray(value)) {
              item = "";
              value.forEach(str => {
                encodedValue = shouldEncode ? encodeURIComponent(str) : str;
                item += `${key}=${encodedValue}&`;
              });
              item.slice(0, -1);
            } else {
              encodedValue = shouldEncode ? encodeURIComponent(value) : value;
              item = `${key}=${encodedValue}`;
            }
            return `${accumulator}&${item}`;
          }, "");
          return output.substr(1);
        };
        const buildRequestInit = (options, extra = {}) => {
          const output = Object.assign({
            method: options.method || "GET",
            headers: options.headers
          }, extra);
          const headers = normalizeHttpHeaders(options.headers);
          const type = headers["content-type"] || "";
          if (typeof options.data === "string") {
            output.body = options.data;
          } else if (type.includes("application/x-www-form-urlencoded")) {
            const params = new URLSearchParams();
            for (const [key, value] of Object.entries(options.data || {})) {
              params.set(key, value);
            }
            output.body = params.toString();
          } else if (type.includes("multipart/form-data") || options.data instanceof FormData) {
            const form = new FormData();
            if (options.data instanceof FormData) {
              options.data.forEach((value, key) => {
                form.append(key, value);
              });
            } else {
              for (const key of Object.keys(options.data)) {
                form.append(key, options.data[key]);
              }
            }
            output.body = form;
            const headers2 = new Headers(output.headers);
            headers2.delete("content-type");
            output.headers = headers2;
          } else if (type.includes("application/json") || typeof options.data === "object") {
            output.body = JSON.stringify(options.data);
          }
          return output;
        };
        class CapacitorHttpPluginWeb extends WebPlugin {
          /**
           * Perform an Http request given a set of options
           * @param options Options to build the HTTP request
           */
          async request(options) {
            const requestInit = buildRequestInit(options, options.webFetchExtra);
            const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
            const url = urlParams ? `${options.url}?${urlParams}` : options.url;
            const response = await fetch(url, requestInit);
            const contentType = response.headers.get("content-type") || "";
            let {
              responseType = "text"
            } = response.ok ? options : {};
            if (contentType.includes("application/json")) {
              responseType = "json";
            }
            let data;
            let blob;
            switch (responseType) {
              case "arraybuffer":
              case "blob":
                blob = await response.blob();
                data = await readBlobAsBase64(blob);
                break;
              case "json":
                data = await response.json();
                break;
              case "document":
              case "text":
              default:
                data = await response.text();
            }
            const headers = {};
            response.headers.forEach((value, key) => {
              headers[key] = value;
            });
            return {
              data,
              headers,
              status: response.status,
              url: response.url
            };
          }
          /**
           * Perform an Http GET request given a set of options
           * @param options Options to build the HTTP request
           */
          async get(options) {
            return this.request(Object.assign(Object.assign({}, options), {
              method: "GET"
            }));
          }
          /**
           * Perform an Http POST request given a set of options
           * @param options Options to build the HTTP request
           */
          async post(options) {
            return this.request(Object.assign(Object.assign({}, options), {
              method: "POST"
            }));
          }
          /**
           * Perform an Http PUT request given a set of options
           * @param options Options to build the HTTP request
           */
          async put(options) {
            return this.request(Object.assign(Object.assign({}, options), {
              method: "PUT"
            }));
          }
          /**
           * Perform an Http PATCH request given a set of options
           * @param options Options to build the HTTP request
           */
          async patch(options) {
            return this.request(Object.assign(Object.assign({}, options), {
              method: "PATCH"
            }));
          }
          /**
           * Perform an Http DELETE request given a set of options
           * @param options Options to build the HTTP request
           */
          async delete(options) {
            return this.request(Object.assign(Object.assign({}, options), {
              method: "DELETE"
            }));
          }
        }
        registerPlugin("CapacitorHttp", {
          web: () => new CapacitorHttpPluginWeb()
        });
        function _inheritsLoose(t, o) {
          t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf$1(t, o);
        }
        var propTypes = {
          exports: {}
        };

        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var ReactPropTypesSecret_1;
        var hasRequiredReactPropTypesSecret;
        function requireReactPropTypesSecret() {
          if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
          hasRequiredReactPropTypesSecret = 1;
          var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
          ReactPropTypesSecret_1 = ReactPropTypesSecret;
          return ReactPropTypesSecret_1;
        }

        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var factoryWithThrowingShims;
        var hasRequiredFactoryWithThrowingShims;
        function requireFactoryWithThrowingShims() {
          if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
          hasRequiredFactoryWithThrowingShims = 1;
          var ReactPropTypesSecret = /*@__PURE__*/requireReactPropTypesSecret();
          function emptyFunction() {}
          function emptyFunctionWithReset() {}
          emptyFunctionWithReset.resetWarningCache = emptyFunction;
          factoryWithThrowingShims = function () {
            function shim(props, propName, componentName, location, propFullName, secret) {
              if (secret === ReactPropTypesSecret) {
                // It is still safe when called from React.
                return;
              }
              var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
              err.name = 'Invariant Violation';
              throw err;
            }
            shim.isRequired = shim;
            function getShim() {
              return shim;
            } // Important!
            // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
            var ReactPropTypes = {
              array: shim,
              bigint: shim,
              bool: shim,
              func: shim,
              number: shim,
              object: shim,
              string: shim,
              symbol: shim,
              any: shim,
              arrayOf: getShim,
              element: shim,
              elementType: shim,
              instanceOf: getShim,
              node: shim,
              objectOf: getShim,
              oneOf: getShim,
              oneOfType: getShim,
              shape: getShim,
              exact: getShim,
              checkPropTypes: emptyFunctionWithReset,
              resetWarningCache: emptyFunction
            };
            ReactPropTypes.PropTypes = ReactPropTypes;
            return ReactPropTypes;
          };
          return factoryWithThrowingShims;
        }
        var hasRequiredPropTypes;
        function requirePropTypes() {
          if (hasRequiredPropTypes) return propTypes.exports;
          hasRequiredPropTypes = 1;
          {
            propTypes.exports = /*@__PURE__*/requireFactoryWithThrowingShims()();
          }
          return propTypes.exports;
        }
        var propTypesExports = /*@__PURE__*/requirePropTypes();
        const PropTypes = /*@__PURE__*/getDefaultExportFromCjs(propTypesExports);
        function isAbsolute(pathname) {
          return pathname.charAt(0) === '/';
        }

        // About 1.5x faster than the two-arg version of Array#splice()
        function spliceOne(list, index) {
          for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
            list[i] = list[k];
          }
          list.pop();
        }

        // This implementation is based heavily on node's url.parse
        function resolvePathname(to, from) {
          if (from === undefined) from = '';
          var toParts = to && to.split('/') || [];
          var fromParts = from && from.split('/') || [];
          var isToAbs = to && isAbsolute(to);
          var isFromAbs = from && isAbsolute(from);
          var mustEndAbs = isToAbs || isFromAbs;
          if (to && isAbsolute(to)) {
            // to is absolute
            fromParts = toParts;
          } else if (toParts.length) {
            // to is relative, drop the filename
            fromParts.pop();
            fromParts = fromParts.concat(toParts);
          }
          if (!fromParts.length) return '/';
          var hasTrailingSlash;
          if (fromParts.length) {
            var last = fromParts[fromParts.length - 1];
            hasTrailingSlash = last === '.' || last === '..' || last === '';
          } else {
            hasTrailingSlash = false;
          }
          var up = 0;
          for (var i = fromParts.length; i >= 0; i--) {
            var part = fromParts[i];
            if (part === '.') {
              spliceOne(fromParts, i);
            } else if (part === '..') {
              spliceOne(fromParts, i);
              up++;
            } else if (up) {
              spliceOne(fromParts, i);
              up--;
            }
          }
          if (!mustEndAbs) for (; up--; up) fromParts.unshift('..');
          if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');
          var result = fromParts.join('/');
          if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';
          return result;
        }
        function valueOf(obj) {
          return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);
        }
        function valueEqual(a, b) {
          // Test for strict equality first.
          if (a === b) return true;

          // Otherwise, if either of them == null they are not equal.
          if (a == null || b == null) return false;
          if (Array.isArray(a)) {
            return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
              return valueEqual(item, b[index]);
            });
          }
          if (typeof a === 'object' || typeof b === 'object') {
            var aValue = valueOf(a);
            var bValue = valueOf(b);
            if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);
            return Object.keys(Object.assign({}, a, b)).every(function (key) {
              return valueEqual(a[key], b[key]);
            });
          }
          return false;
        }
        var prefix = "Invariant failed";
        function invariant(condition, message) {
          {
            throw new Error(prefix);
          }
        }
        function addLeadingSlash$1(path) {
          return path.charAt(0) === "/" ? path : "/" + path;
        }
        function stripLeadingSlash(path) {
          return path.charAt(0) === "/" ? path.substr(1) : path;
        }
        function hasBasename(path, prefix) {
          return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && "/?#".indexOf(path.charAt(prefix.length)) !== -1;
        }
        function stripBasename$1(path, prefix) {
          return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
        }
        function stripTrailingSlash(path) {
          return path.charAt(path.length - 1) === "/" ? path.slice(0, -1) : path;
        }
        function parsePath(path) {
          var pathname = path || "/";
          var search = "";
          var hash = "";
          var hashIndex = pathname.indexOf("#");
          if (hashIndex !== -1) {
            hash = pathname.substr(hashIndex);
            pathname = pathname.substr(0, hashIndex);
          }
          var searchIndex = pathname.indexOf("?");
          if (searchIndex !== -1) {
            search = pathname.substr(searchIndex);
            pathname = pathname.substr(0, searchIndex);
          }
          return {
            pathname,
            search: search === "?" ? "" : search,
            hash: hash === "#" ? "" : hash
          };
        }
        function createPath(location) {
          var pathname = location.pathname,
            search = location.search,
            hash = location.hash;
          var path = pathname || "/";
          if (search && search !== "?") path += search.charAt(0) === "?" ? search : "?" + search;
          if (hash && hash !== "#") path += hash.charAt(0) === "#" ? hash : "#" + hash;
          return path;
        }
        function createLocation(path, state, key, currentLocation) {
          var location;
          if (typeof path === "string") {
            location = parsePath(path);
            location.state = state;
          } else {
            location = _extends$2({}, path);
            if (location.pathname === void 0) location.pathname = "";
            if (location.search) {
              if (location.search.charAt(0) !== "?") location.search = "?" + location.search;
            } else {
              location.search = "";
            }
            if (location.hash) {
              if (location.hash.charAt(0) !== "#") location.hash = "#" + location.hash;
            } else {
              location.hash = "";
            }
            if (state !== void 0 && location.state === void 0) location.state = state;
          }
          try {
            location.pathname = decodeURI(location.pathname);
          } catch (e) {
            if (e instanceof URIError) {
              throw new URIError('Pathname "' + location.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
            } else {
              throw e;
            }
          }
          if (key) location.key = key;
          if (currentLocation) {
            if (!location.pathname) {
              location.pathname = currentLocation.pathname;
            } else if (location.pathname.charAt(0) !== "/") {
              location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
            }
          } else {
            if (!location.pathname) {
              location.pathname = "/";
            }
          }
          return location;
        }
        function locationsAreEqual(a, b) {
          return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);
        }
        function createTransitionManager() {
          var prompt = null;
          function setPrompt(nextPrompt) {
            prompt = nextPrompt;
            return function () {
              if (prompt === nextPrompt) prompt = null;
            };
          }
          function confirmTransitionTo(location, action, getUserConfirmation, callback) {
            if (prompt != null) {
              var result = typeof prompt === "function" ? prompt(location, action) : prompt;
              if (typeof result === "string") {
                if (typeof getUserConfirmation === "function") {
                  getUserConfirmation(result, callback);
                } else {
                  callback(true);
                }
              } else {
                callback(result !== false);
              }
            } else {
              callback(true);
            }
          }
          var listeners = [];
          function appendListener(fn) {
            var isActive = true;
            function listener() {
              if (isActive) fn.apply(void 0, arguments);
            }
            listeners.push(listener);
            return function () {
              isActive = false;
              listeners = listeners.filter(function (item) {
                return item !== listener;
              });
            };
          }
          function notifyListeners() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            listeners.forEach(function (listener) {
              return listener.apply(void 0, args);
            });
          }
          return {
            setPrompt,
            confirmTransitionTo,
            appendListener,
            notifyListeners
          };
        }
        var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
        function getConfirmation(message, callback) {
          callback(window.confirm(message));
        }
        function supportsHistory() {
          var ua = window.navigator.userAgent;
          if ((ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) && ua.indexOf("Mobile Safari") !== -1 && ua.indexOf("Chrome") === -1 && ua.indexOf("Windows Phone") === -1) return false;
          return window.history && "pushState" in window.history;
        }
        function supportsPopStateOnHashChange() {
          return window.navigator.userAgent.indexOf("Trident") === -1;
        }
        function supportsGoWithoutReloadUsingHash() {
          return window.navigator.userAgent.indexOf("Firefox") === -1;
        }
        function isExtraneousPopstateEvent(event) {
          return event.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
        }
        var PopStateEvent = "popstate";
        var HashChangeEvent = "hashchange";
        function getHistoryState() {
          try {
            return window.history.state || {};
          } catch (e) {
            return {};
          }
        }
        function createBrowserHistory(props) {
          if (props === void 0) {
            props = {};
          }
          !canUseDOM ? invariant() : void 0;
          var globalHistory = window.history;
          var canUseHistory = supportsHistory();
          var needsHashChangeListener = !supportsPopStateOnHashChange();
          var _props = props,
            _props$forceRefresh = _props.forceRefresh,
            forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
            _props$getUserConfirm = _props.getUserConfirmation,
            getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
            _props$keyLength = _props.keyLength,
            keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
          var basename = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : "";
          function getDOMLocation(historyState) {
            var _ref = historyState || {},
              key = _ref.key,
              state = _ref.state;
            var _window$location = window.location,
              pathname = _window$location.pathname,
              search = _window$location.search,
              hash = _window$location.hash;
            var path = pathname + search + hash;
            if (basename) path = stripBasename$1(path, basename);
            return createLocation(path, state, key);
          }
          function createKey() {
            return Math.random().toString(36).substr(2, keyLength);
          }
          var transitionManager = createTransitionManager();
          function setState(nextState) {
            _extends$2(history, nextState);
            history.length = globalHistory.length;
            transitionManager.notifyListeners(history.location, history.action);
          }
          function handlePopState(event) {
            if (isExtraneousPopstateEvent(event)) return;
            handlePop(getDOMLocation(event.state));
          }
          function handleHashChange() {
            handlePop(getDOMLocation(getHistoryState()));
          }
          var forceNextPop = false;
          function handlePop(location) {
            if (forceNextPop) {
              forceNextPop = false;
              setState();
            } else {
              var action = "POP";
              transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
                if (ok) {
                  setState({
                    action,
                    location
                  });
                } else {
                  revertPop(location);
                }
              });
            }
          }
          function revertPop(fromLocation) {
            var toLocation = history.location;
            var toIndex = allKeys.indexOf(toLocation.key);
            if (toIndex === -1) toIndex = 0;
            var fromIndex = allKeys.indexOf(fromLocation.key);
            if (fromIndex === -1) fromIndex = 0;
            var delta = toIndex - fromIndex;
            if (delta) {
              forceNextPop = true;
              go(delta);
            }
          }
          var initialLocation = getDOMLocation(getHistoryState());
          var allKeys = [initialLocation.key];
          function createHref(location) {
            return basename + createPath(location);
          }
          function push(path, state) {
            var action = "PUSH";
            var location = createLocation(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
              if (!ok) return;
              var href = createHref(location);
              var key = location.key,
                state2 = location.state;
              if (canUseHistory) {
                globalHistory.pushState({
                  key,
                  state: state2
                }, null, href);
                if (forceRefresh) {
                  window.location.href = href;
                } else {
                  var prevIndex = allKeys.indexOf(history.location.key);
                  var nextKeys = allKeys.slice(0, prevIndex + 1);
                  nextKeys.push(location.key);
                  allKeys = nextKeys;
                  setState({
                    action,
                    location
                  });
                }
              } else {
                window.location.href = href;
              }
            });
          }
          function replace(path, state) {
            var action = "REPLACE";
            var location = createLocation(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
              if (!ok) return;
              var href = createHref(location);
              var key = location.key,
                state2 = location.state;
              if (canUseHistory) {
                globalHistory.replaceState({
                  key,
                  state: state2
                }, null, href);
                if (forceRefresh) {
                  window.location.replace(href);
                } else {
                  var prevIndex = allKeys.indexOf(history.location.key);
                  if (prevIndex !== -1) allKeys[prevIndex] = location.key;
                  setState({
                    action,
                    location
                  });
                }
              } else {
                window.location.replace(href);
              }
            });
          }
          function go(n) {
            globalHistory.go(n);
          }
          function goBack() {
            go(-1);
          }
          function goForward() {
            go(1);
          }
          var listenerCount = 0;
          function checkDOMListeners(delta) {
            listenerCount += delta;
            if (listenerCount === 1 && delta === 1) {
              window.addEventListener(PopStateEvent, handlePopState);
              if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
            } else if (listenerCount === 0) {
              window.removeEventListener(PopStateEvent, handlePopState);
              if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
            }
          }
          var isBlocked = false;
          function block(prompt) {
            if (prompt === void 0) {
              prompt = false;
            }
            var unblock = transitionManager.setPrompt(prompt);
            if (!isBlocked) {
              checkDOMListeners(1);
              isBlocked = true;
            }
            return function () {
              if (isBlocked) {
                isBlocked = false;
                checkDOMListeners(-1);
              }
              return unblock();
            };
          }
          function listen(listener) {
            var unlisten = transitionManager.appendListener(listener);
            checkDOMListeners(1);
            return function () {
              checkDOMListeners(-1);
              unlisten();
            };
          }
          var history = {
            length: globalHistory.length,
            action: "POP",
            location: initialLocation,
            createHref,
            push,
            replace,
            go,
            goBack,
            goForward,
            block,
            listen
          };
          return history;
        }
        var HashChangeEvent$1 = "hashchange";
        var HashPathCoders = {
          hashbang: {
            encodePath: function encodePath(path) {
              return path.charAt(0) === "!" ? path : "!/" + stripLeadingSlash(path);
            },
            decodePath: function decodePath(path) {
              return path.charAt(0) === "!" ? path.substr(1) : path;
            }
          },
          noslash: {
            encodePath: stripLeadingSlash,
            decodePath: addLeadingSlash$1
          },
          slash: {
            encodePath: addLeadingSlash$1,
            decodePath: addLeadingSlash$1
          }
        };
        function stripHash(url) {
          var hashIndex = url.indexOf("#");
          return hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        function getHashPath() {
          var href = window.location.href;
          var hashIndex = href.indexOf("#");
          return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
        }
        function pushHashPath(path) {
          window.location.hash = path;
        }
        function replaceHashPath(path) {
          window.location.replace(stripHash(window.location.href) + "#" + path);
        }
        function createHashHistory(props) {
          if (props === void 0) {
            props = {};
          }
          !canUseDOM ? invariant() : void 0;
          var globalHistory = window.history;
          supportsGoWithoutReloadUsingHash();
          var _props = props,
            _props$getUserConfirm = _props.getUserConfirmation,
            getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
            _props$hashType = _props.hashType,
            hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
          var basename = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : "";
          var _HashPathCoders$hashT = HashPathCoders[hashType],
            encodePath2 = _HashPathCoders$hashT.encodePath,
            decodePath2 = _HashPathCoders$hashT.decodePath;
          function getDOMLocation() {
            var path2 = decodePath2(getHashPath());
            if (basename) path2 = stripBasename$1(path2, basename);
            return createLocation(path2);
          }
          var transitionManager = createTransitionManager();
          function setState(nextState) {
            _extends$2(history, nextState);
            history.length = globalHistory.length;
            transitionManager.notifyListeners(history.location, history.action);
          }
          var forceNextPop = false;
          var ignorePath = null;
          function locationsAreEqual$$1(a, b) {
            return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
          }
          function handleHashChange() {
            var path2 = getHashPath();
            var encodedPath2 = encodePath2(path2);
            if (path2 !== encodedPath2) {
              replaceHashPath(encodedPath2);
            } else {
              var location = getDOMLocation();
              var prevLocation = history.location;
              if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return;
              if (ignorePath === createPath(location)) return;
              ignorePath = null;
              handlePop(location);
            }
          }
          function handlePop(location) {
            if (forceNextPop) {
              forceNextPop = false;
              setState();
            } else {
              var action = "POP";
              transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
                if (ok) {
                  setState({
                    action,
                    location
                  });
                } else {
                  revertPop(location);
                }
              });
            }
          }
          function revertPop(fromLocation) {
            var toLocation = history.location;
            var toIndex = allPaths.lastIndexOf(createPath(toLocation));
            if (toIndex === -1) toIndex = 0;
            var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
            if (fromIndex === -1) fromIndex = 0;
            var delta = toIndex - fromIndex;
            if (delta) {
              forceNextPop = true;
              go(delta);
            }
          }
          var path = getHashPath();
          var encodedPath = encodePath2(path);
          if (path !== encodedPath) replaceHashPath(encodedPath);
          var initialLocation = getDOMLocation();
          var allPaths = [createPath(initialLocation)];
          function createHref(location) {
            var baseTag = document.querySelector("base");
            var href = "";
            if (baseTag && baseTag.getAttribute("href")) {
              href = stripHash(window.location.href);
            }
            return href + "#" + encodePath2(basename + createPath(location));
          }
          function push(path2, state) {
            var action = "PUSH";
            var location = createLocation(path2, void 0, void 0, history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
              if (!ok) return;
              var path3 = createPath(location);
              var encodedPath2 = encodePath2(basename + path3);
              var hashChanged = getHashPath() !== encodedPath2;
              if (hashChanged) {
                ignorePath = path3;
                pushHashPath(encodedPath2);
                var prevIndex = allPaths.lastIndexOf(createPath(history.location));
                var nextPaths = allPaths.slice(0, prevIndex + 1);
                nextPaths.push(path3);
                allPaths = nextPaths;
                setState({
                  action,
                  location
                });
              } else {
                setState();
              }
            });
          }
          function replace(path2, state) {
            var action = "REPLACE";
            var location = createLocation(path2, void 0, void 0, history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
              if (!ok) return;
              var path3 = createPath(location);
              var encodedPath2 = encodePath2(basename + path3);
              var hashChanged = getHashPath() !== encodedPath2;
              if (hashChanged) {
                ignorePath = path3;
                replaceHashPath(encodedPath2);
              }
              var prevIndex = allPaths.indexOf(createPath(history.location));
              if (prevIndex !== -1) allPaths[prevIndex] = path3;
              setState({
                action,
                location
              });
            });
          }
          function go(n) {
            globalHistory.go(n);
          }
          function goBack() {
            go(-1);
          }
          function goForward() {
            go(1);
          }
          var listenerCount = 0;
          function checkDOMListeners(delta) {
            listenerCount += delta;
            if (listenerCount === 1 && delta === 1) {
              window.addEventListener(HashChangeEvent$1, handleHashChange);
            } else if (listenerCount === 0) {
              window.removeEventListener(HashChangeEvent$1, handleHashChange);
            }
          }
          var isBlocked = false;
          function block(prompt) {
            if (prompt === void 0) {
              prompt = false;
            }
            var unblock = transitionManager.setPrompt(prompt);
            if (!isBlocked) {
              checkDOMListeners(1);
              isBlocked = true;
            }
            return function () {
              if (isBlocked) {
                isBlocked = false;
                checkDOMListeners(-1);
              }
              return unblock();
            };
          }
          function listen(listener) {
            var unlisten = transitionManager.appendListener(listener);
            checkDOMListeners(1);
            return function () {
              checkDOMListeners(-1);
              unlisten();
            };
          }
          var history = {
            length: globalHistory.length,
            action: "POP",
            location: initialLocation,
            createHref,
            push,
            replace,
            go,
            goBack,
            goForward,
            block,
            listen
          };
          return history;
        }
        function clamp(n, lowerBound, upperBound) {
          return Math.min(Math.max(n, lowerBound), upperBound);
        }
        function createMemoryHistory(props) {
          if (props === void 0) {
            props = {};
          }
          var _props = props,
            getUserConfirmation = _props.getUserConfirmation,
            _props$initialEntries = _props.initialEntries,
            initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries,
            _props$initialIndex = _props.initialIndex,
            initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
            _props$keyLength = _props.keyLength,
            keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
          var transitionManager = createTransitionManager();
          function setState(nextState) {
            _extends$2(history, nextState);
            history.length = history.entries.length;
            transitionManager.notifyListeners(history.location, history.action);
          }
          function createKey() {
            return Math.random().toString(36).substr(2, keyLength);
          }
          var index = clamp(initialIndex, 0, initialEntries.length - 1);
          var entries = initialEntries.map(function (entry) {
            return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
          });
          var createHref = createPath;
          function push(path, state) {
            var action = "PUSH";
            var location = createLocation(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
              if (!ok) return;
              var prevIndex = history.index;
              var nextIndex = prevIndex + 1;
              var nextEntries = history.entries.slice(0);
              if (nextEntries.length > nextIndex) {
                nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
              } else {
                nextEntries.push(location);
              }
              setState({
                action,
                location,
                index: nextIndex,
                entries: nextEntries
              });
            });
          }
          function replace(path, state) {
            var action = "REPLACE";
            var location = createLocation(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
              if (!ok) return;
              history.entries[history.index] = location;
              setState({
                action,
                location
              });
            });
          }
          function go(n) {
            var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
            var action = "POP";
            var location = history.entries[nextIndex];
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
              if (ok) {
                setState({
                  action,
                  location,
                  index: nextIndex
                });
              } else {
                setState();
              }
            });
          }
          function goBack() {
            go(-1);
          }
          function goForward() {
            go(1);
          }
          function canGo(n) {
            var nextIndex = history.index + n;
            return nextIndex >= 0 && nextIndex < history.entries.length;
          }
          function block(prompt) {
            if (prompt === void 0) {
              prompt = false;
            }
            return transitionManager.setPrompt(prompt);
          }
          function listen(listener) {
            return transitionManager.appendListener(listener);
          }
          var history = {
            length: entries.length,
            action: "POP",
            location: entries[index],
            index,
            entries,
            createHref,
            push,
            replace,
            go,
            goBack,
            goForward,
            canGo,
            block,
            listen
          };
          return history;
        }
        var pathToRegexp$1 = {
          exports: {}
        };
        var isarray;
        var hasRequiredIsarray;
        function requireIsarray() {
          if (hasRequiredIsarray) return isarray;
          hasRequiredIsarray = 1;
          isarray = Array.isArray || function (arr) {
            return Object.prototype.toString.call(arr) == '[object Array]';
          };
          return isarray;
        }
        var hasRequiredPathToRegexp;
        function requirePathToRegexp() {
          if (hasRequiredPathToRegexp) return pathToRegexp$1.exports;
          hasRequiredPathToRegexp = 1;
          var isarray = requireIsarray();

          /**
           * Expose `pathToRegexp`.
           */
          pathToRegexp$1.exports = pathToRegexp;
          pathToRegexp$1.exports.parse = parse;
          pathToRegexp$1.exports.compile = compile;
          pathToRegexp$1.exports.tokensToFunction = tokensToFunction;
          pathToRegexp$1.exports.tokensToRegExp = tokensToRegExp;

          /**
           * The main path matching regexp utility.
           *
           * @type {RegExp}
           */
          var PATH_REGEXP = new RegExp([
          // Match escaped characters that would otherwise appear in future matches.
          // This allows the user to escape special characters that won't transform.
          '(\\\\.)',
          // Match Express-style parameters and un-named parameters with a prefix
          // and optional suffixes. Matches appear as:
          //
          // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
          // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
          // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
          '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

          /**
           * Parse a string for the raw tokens.
           *
           * @param  {string}  str
           * @param  {Object=} options
           * @return {!Array}
           */
          function parse(str, options) {
            var tokens = [];
            var key = 0;
            var index = 0;
            var path = '';
            var defaultDelimiter = options && options.delimiter || '/';
            var res;
            while ((res = PATH_REGEXP.exec(str)) != null) {
              var m = res[0];
              var escaped = res[1];
              var offset = res.index;
              path += str.slice(index, offset);
              index = offset + m.length;

              // Ignore already escaped sequences.
              if (escaped) {
                path += escaped[1];
                continue;
              }
              var next = str[index];
              var prefix = res[2];
              var name = res[3];
              var capture = res[4];
              var group = res[5];
              var modifier = res[6];
              var asterisk = res[7];

              // Push the current path onto the tokens.
              if (path) {
                tokens.push(path);
                path = '';
              }
              var partial = prefix != null && next != null && next !== prefix;
              var repeat = modifier === '+' || modifier === '*';
              var optional = modifier === '?' || modifier === '*';
              var delimiter = prefix || defaultDelimiter;
              var pattern = capture || group;
              var prevText = prefix || (typeof tokens[tokens.length - 1] === 'string' ? tokens[tokens.length - 1] : '');
              tokens.push({
                name: name || key++,
                prefix: prefix || '',
                delimiter: delimiter,
                optional: optional,
                repeat: repeat,
                partial: partial,
                asterisk: !!asterisk,
                pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : restrictBacktrack(delimiter, prevText)
              });
            }

            // Match any characters still remaining.
            if (index < str.length) {
              path += str.substr(index);
            }

            // If the path exists, push it onto the end.
            if (path) {
              tokens.push(path);
            }
            return tokens;
          }
          function restrictBacktrack(delimiter, prevText) {
            if (!prevText || prevText.indexOf(delimiter) > -1) {
              return '[^' + escapeString(delimiter) + ']+?';
            }
            return escapeString(prevText) + '|(?:(?!' + escapeString(prevText) + ')[^' + escapeString(delimiter) + '])+?';
          }

          /**
           * Compile a string to a template function for the path.
           *
           * @param  {string}             str
           * @param  {Object=}            options
           * @return {!function(Object=, Object=)}
           */
          function compile(str, options) {
            return tokensToFunction(parse(str, options), options);
          }

          /**
           * Prettier encoding of URI path segments.
           *
           * @param  {string}
           * @return {string}
           */
          function encodeURIComponentPretty(str) {
            return encodeURI(str).replace(/[\/?#]/g, function (c) {
              return '%' + c.charCodeAt(0).toString(16).toUpperCase();
            });
          }

          /**
           * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
           *
           * @param  {string}
           * @return {string}
           */
          function encodeAsterisk(str) {
            return encodeURI(str).replace(/[?#]/g, function (c) {
              return '%' + c.charCodeAt(0).toString(16).toUpperCase();
            });
          }

          /**
           * Expose a method for transforming tokens into the path function.
           */
          function tokensToFunction(tokens, options) {
            // Compile all the tokens into regexps.
            var matches = new Array(tokens.length);

            // Compile all the patterns before compilation.
            for (var i = 0; i < tokens.length; i++) {
              if (typeof tokens[i] === 'object') {
                matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));
              }
            }
            return function (obj, opts) {
              var path = '';
              var data = obj || {};
              var options = opts || {};
              var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;
              for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (typeof token === 'string') {
                  path += token;
                  continue;
                }
                var value = data[token.name];
                var segment;
                if (value == null) {
                  if (token.optional) {
                    // Prepend partial segment prefixes.
                    if (token.partial) {
                      path += token.prefix;
                    }
                    continue;
                  } else {
                    throw new TypeError('Expected "' + token.name + '" to be defined');
                  }
                }
                if (isarray(value)) {
                  if (!token.repeat) {
                    throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
                  }
                  if (value.length === 0) {
                    if (token.optional) {
                      continue;
                    } else {
                      throw new TypeError('Expected "' + token.name + '" to not be empty');
                    }
                  }
                  for (var j = 0; j < value.length; j++) {
                    segment = encode(value[j]);
                    if (!matches[i].test(segment)) {
                      throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
                    }
                    path += (j === 0 ? token.prefix : token.delimiter) + segment;
                  }
                  continue;
                }
                segment = token.asterisk ? encodeAsterisk(value) : encode(value);
                if (!matches[i].test(segment)) {
                  throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
                }
                path += token.prefix + segment;
              }
              return path;
            };
          }

          /**
           * Escape a regular expression string.
           *
           * @param  {string} str
           * @return {string}
           */
          function escapeString(str) {
            return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
          }

          /**
           * Escape the capturing group by escaping special characters and meaning.
           *
           * @param  {string} group
           * @return {string}
           */
          function escapeGroup(group) {
            return group.replace(/([=!:$\/()])/g, '\\$1');
          }

          /**
           * Attach the keys as a property of the regexp.
           *
           * @param  {!RegExp} re
           * @param  {Array}   keys
           * @return {!RegExp}
           */
          function attachKeys(re, keys) {
            re.keys = keys;
            return re;
          }

          /**
           * Get the flags for a regexp from the options.
           *
           * @param  {Object} options
           * @return {string}
           */
          function flags(options) {
            return options && options.sensitive ? '' : 'i';
          }

          /**
           * Pull out keys from a regexp.
           *
           * @param  {!RegExp} path
           * @param  {!Array}  keys
           * @return {!RegExp}
           */
          function regexpToRegexp(path, keys) {
            // Use a negative lookahead to match only capturing groups.
            var groups = path.source.match(/\((?!\?)/g);
            if (groups) {
              for (var i = 0; i < groups.length; i++) {
                keys.push({
                  name: i,
                  prefix: null,
                  delimiter: null,
                  optional: false,
                  repeat: false,
                  partial: false,
                  asterisk: false,
                  pattern: null
                });
              }
            }
            return attachKeys(path, keys);
          }

          /**
           * Transform an array into a regexp.
           *
           * @param  {!Array}  path
           * @param  {Array}   keys
           * @param  {!Object} options
           * @return {!RegExp}
           */
          function arrayToRegexp(path, keys, options) {
            var parts = [];
            for (var i = 0; i < path.length; i++) {
              parts.push(pathToRegexp(path[i], keys, options).source);
            }
            var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
            return attachKeys(regexp, keys);
          }

          /**
           * Create a path regexp from string input.
           *
           * @param  {string}  path
           * @param  {!Array}  keys
           * @param  {!Object} options
           * @return {!RegExp}
           */
          function stringToRegexp(path, keys, options) {
            return tokensToRegExp(parse(path, options), keys, options);
          }

          /**
           * Expose a function for taking tokens and returning a RegExp.
           *
           * @param  {!Array}          tokens
           * @param  {(Array|Object)=} keys
           * @param  {Object=}         options
           * @return {!RegExp}
           */
          function tokensToRegExp(tokens, keys, options) {
            if (!isarray(keys)) {
              options = /** @type {!Object} */keys || options;
              keys = [];
            }
            options = options || {};
            var strict = options.strict;
            var end = options.end !== false;
            var route = '';

            // Iterate over the tokens and create our regexp string.
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              if (typeof token === 'string') {
                route += escapeString(token);
              } else {
                var prefix = escapeString(token.prefix);
                var capture = '(?:' + token.pattern + ')';
                keys.push(token);
                if (token.repeat) {
                  capture += '(?:' + prefix + capture + ')*';
                }
                if (token.optional) {
                  if (!token.partial) {
                    capture = '(?:' + prefix + '(' + capture + '))?';
                  } else {
                    capture = prefix + '(' + capture + ')?';
                  }
                } else {
                  capture = prefix + '(' + capture + ')';
                }
                route += capture;
              }
            }
            var delimiter = escapeString(options.delimiter || '/');
            var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

            // In non-strict mode we allow a slash at the end of match. If the path to
            // match already ends with a slash, we remove it for consistency. The slash
            // is valid at the end of a path match, not in the middle. This is important
            // in non-ending mode, where "/test/" shouldn't match "/test//route".
            if (!strict) {
              route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
            }
            if (end) {
              route += '$';
            } else {
              // In non-ending mode, we need the capturing groups to match as much as
              // possible by using a positive lookahead to the end or next path segment.
              route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
            }
            return attachKeys(new RegExp('^' + route, flags(options)), keys);
          }

          /**
           * Normalize the given path string, returning a regular expression.
           *
           * An empty array can be passed in for the keys, which will hold the
           * placeholder key descriptions. For example, using `/user/:id`, `keys` will
           * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
           *
           * @param  {(string|RegExp|Array)} path
           * @param  {(Array|Object)=}       keys
           * @param  {Object=}               options
           * @return {!RegExp}
           */
          function pathToRegexp(path, keys, options) {
            if (!isarray(keys)) {
              options = /** @type {!Object} */keys || options;
              keys = [];
            }
            options = options || {};
            if (path instanceof RegExp) {
              return regexpToRegexp(path, /** @type {!Array} */keys);
            }
            if (isarray(path)) {
              return arrayToRegexp(/** @type {!Array} */path, /** @type {!Array} */keys, options);
            }
            return stringToRegexp(/** @type {string} */path, /** @type {!Array} */keys, options);
          }
          return pathToRegexp$1.exports;
        }
        var pathToRegexpExports = requirePathToRegexp();
        const pathToRegexp = /*@__PURE__*/getDefaultExportFromCjs(pathToRegexpExports);
        requireReactIs$1();
        var MAX_SIGNED_31_BIT_INT = 1073741823;
        var commonjsGlobal = typeof globalThis !== "undefined" ?
        // eslint-disable-next-line no-undef
        globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
        function getUniqueId() {
          var key = "__global_unique_id__";
          return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
        }
        function objectIs(x, y) {
          if (x === y) {
            return x !== 0 || 1 / x === 1 / y;
          } else {
            return x !== x && y !== y;
          }
        }
        function createEventEmitter(value) {
          var handlers = [];
          return {
            on: function on(handler) {
              handlers.push(handler);
            },
            off: function off(handler) {
              handlers = handlers.filter(function (h) {
                return h !== handler;
              });
            },
            get: function get() {
              return value;
            },
            set: function set(newValue, changedBits) {
              value = newValue;
              handlers.forEach(function (handler) {
                return handler(value, changedBits);
              });
            }
          };
        }
        function onlyChild(children) {
          return Array.isArray(children) ? children[0] : children;
        }
        function createReactContext(defaultValue, calculateChangedBits) {
          var _Provider$childContex, _Consumer$contextType;
          var contextProp = "__create-react-context-" + getUniqueId() + "__";
          var Provider = /* @__PURE__ */function (_React$Component) {
            _inheritsLoose(Provider2, _React$Component);
            function Provider2() {
              var _this;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
              _this.emitter = createEventEmitter(_this.props.value);
              return _this;
            }
            var _proto = Provider2.prototype;
            _proto.getChildContext = function getChildContext() {
              var _ref;
              return _ref = {}, _ref[contextProp] = this.emitter, _ref;
            };
            _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
              if (this.props.value !== nextProps.value) {
                var oldValue = this.props.value;
                var newValue = nextProps.value;
                var changedBits;
                if (objectIs(oldValue, newValue)) {
                  changedBits = 0;
                } else {
                  changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
                  changedBits |= 0;
                  if (changedBits !== 0) {
                    this.emitter.set(nextProps.value, changedBits);
                  }
                }
              }
            };
            _proto.render = function render() {
              return this.props.children;
            };
            return Provider2;
          }(React.Component);
          Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = PropTypes.object.isRequired, _Provider$childContex);
          var Consumer = /* @__PURE__ */function (_React$Component2) {
            _inheritsLoose(Consumer2, _React$Component2);
            function Consumer2() {
              var _this2;
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              _this2 = _React$Component2.call.apply(_React$Component2, [this].concat(args)) || this;
              _this2.observedBits = void 0;
              _this2.state = {
                value: _this2.getValue()
              };
              _this2.onUpdate = function (newValue, changedBits) {
                var observedBits = _this2.observedBits | 0;
                if ((observedBits & changedBits) !== 0) {
                  _this2.setState({
                    value: _this2.getValue()
                  });
                }
              };
              return _this2;
            }
            var _proto2 = Consumer2.prototype;
            _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
              var observedBits = nextProps.observedBits;
              this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
            };
            _proto2.componentDidMount = function componentDidMount() {
              if (this.context[contextProp]) {
                this.context[contextProp].on(this.onUpdate);
              }
              var observedBits = this.props.observedBits;
              this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
            };
            _proto2.componentWillUnmount = function componentWillUnmount() {
              if (this.context[contextProp]) {
                this.context[contextProp].off(this.onUpdate);
              }
            };
            _proto2.getValue = function getValue() {
              if (this.context[contextProp]) {
                return this.context[contextProp].get();
              } else {
                return defaultValue;
              }
            };
            _proto2.render = function render() {
              return onlyChild(this.props.children)(this.state.value);
            };
            return Consumer2;
          }(React.Component);
          Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = PropTypes.object, _Consumer$contextType);
          return {
            Provider,
            Consumer
          };
        }
        var createContext = React.createContext || createReactContext;
        var createNamedContext = function createNamedContext2(name) {
          var context2 = createContext();
          context2.displayName = name;
          return context2;
        };
        var historyContext = /* @__PURE__ */createNamedContext("Router-History");
        var context = /* @__PURE__ */createNamedContext("Router");
        var Router = exports("m", /* @__PURE__ */function (_React$Component) {
          _inheritsLoose(Router2, _React$Component);
          Router2.computeRootMatch = function computeRootMatch(pathname) {
            return {
              path: "/",
              url: "/",
              params: {},
              isExact: pathname === "/"
            };
          };
          function Router2(props) {
            var _this;
            _this = _React$Component.call(this, props) || this;
            _this.state = {
              location: props.history.location
            };
            _this._isMounted = false;
            _this._pendingLocation = null;
            if (!props.staticContext) {
              _this.unlisten = props.history.listen(function (location) {
                _this._pendingLocation = location;
              });
            }
            return _this;
          }
          var _proto = Router2.prototype;
          _proto.componentDidMount = function componentDidMount() {
            var _this2 = this;
            this._isMounted = true;
            if (this.unlisten) {
              this.unlisten();
            }
            if (!this.props.staticContext) {
              this.unlisten = this.props.history.listen(function (location) {
                if (_this2._isMounted) {
                  _this2.setState({
                    location
                  });
                }
              });
            }
            if (this._pendingLocation) {
              this.setState({
                location: this._pendingLocation
              });
            }
          };
          _proto.componentWillUnmount = function componentWillUnmount() {
            if (this.unlisten) {
              this.unlisten();
              this._isMounted = false;
              this._pendingLocation = null;
            }
          };
          _proto.render = function render() {
            return /* @__PURE__ */React.createElement(context.Provider, {
              value: {
                history: this.props.history,
                location: this.state.location,
                match: Router2.computeRootMatch(this.state.location.pathname),
                staticContext: this.props.staticContext
              }
            }, /* @__PURE__ */React.createElement(historyContext.Provider, {
              children: this.props.children || null,
              value: this.props.history
            }));
          };
          return Router2;
        }(React.Component));
        /* @__PURE__ */
        (function (_React$Component) {
          _inheritsLoose(MemoryRouter2, _React$Component);
          function MemoryRouter2() {
            var _this;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
            _this.history = createMemoryHistory(_this.props);
            return _this;
          }
          var _proto = MemoryRouter2.prototype;
          _proto.render = function render() {
            return /* @__PURE__ */React.createElement(Router, {
              history: this.history,
              children: this.props.children
            });
          };
          return MemoryRouter2;
        })(React.Component);
        var Lifecycle = /* @__PURE__ */function (_React$Component) {
          _inheritsLoose(Lifecycle2, _React$Component);
          function Lifecycle2() {
            return _React$Component.apply(this, arguments) || this;
          }
          var _proto = Lifecycle2.prototype;
          _proto.componentDidMount = function componentDidMount() {
            if (this.props.onMount) this.props.onMount.call(this, this);
          };
          _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
            if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
          };
          _proto.componentWillUnmount = function componentWillUnmount() {
            if (this.props.onUnmount) this.props.onUnmount.call(this, this);
          };
          _proto.render = function render() {
            return null;
          };
          return Lifecycle2;
        }(React.Component);
        var cache = {};
        var cacheLimit = 1e4;
        var cacheCount = 0;
        function compilePath(path) {
          if (cache[path]) return cache[path];
          var generator = pathToRegexp.compile(path);
          if (cacheCount < cacheLimit) {
            cache[path] = generator;
            cacheCount++;
          }
          return generator;
        }
        function generatePath(path, params) {
          if (path === void 0) {
            path = "/";
          }
          if (params === void 0) {
            params = {};
          }
          return path === "/" ? path : compilePath(path)(params, {
            pretty: true
          });
        }
        function Redirect(_ref) {
          var computedMatch = _ref.computedMatch,
            to = _ref.to,
            _ref$push = _ref.push,
            push = _ref$push === void 0 ? false : _ref$push;
          return /* @__PURE__ */React.createElement(context.Consumer, null, function (context2) {
            !context2 ? invariant() : void 0;
            var history = context2.history,
              staticContext = context2.staticContext;
            var method = push ? history.push : history.replace;
            var location = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends$2({}, to, {
              pathname: generatePath(to.pathname, computedMatch.params)
            }) : to);
            if (staticContext) {
              method(location);
              return null;
            }
            return /* @__PURE__ */React.createElement(Lifecycle, {
              onMount: function onMount() {
                method(location);
              },
              onUpdate: function onUpdate(self, prevProps) {
                var prevLocation = createLocation(prevProps.to);
                if (!locationsAreEqual(prevLocation, _extends$2({}, location, {
                  key: prevLocation.key
                }))) {
                  method(location);
                }
              },
              to
            });
          });
        }
        var cache$1 = {};
        var cacheLimit$1 = 1e4;
        var cacheCount$1 = 0;
        function compilePath$1(path, options) {
          var cacheKey = "" + options.end + options.strict + options.sensitive;
          var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
          if (pathCache[path]) return pathCache[path];
          var keys = [];
          var regexp = pathToRegexp(path, keys, options);
          var result = {
            regexp,
            keys
          };
          if (cacheCount$1 < cacheLimit$1) {
            pathCache[path] = result;
            cacheCount$1++;
          }
          return result;
        }
        function matchPath(pathname, options) {
          if (options === void 0) {
            options = {};
          }
          if (typeof options === "string" || Array.isArray(options)) {
            options = {
              path: options
            };
          }
          var _options = options,
            path = _options.path,
            _options$exact = _options.exact,
            exact = _options$exact === void 0 ? false : _options$exact,
            _options$strict = _options.strict,
            strict = _options$strict === void 0 ? false : _options$strict,
            _options$sensitive = _options.sensitive,
            sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
          var paths = [].concat(path);
          return paths.reduce(function (matched, path2) {
            if (!path2 && path2 !== "") return null;
            if (matched) return matched;
            var _compilePath = compilePath$1(path2, {
                end: exact,
                strict,
                sensitive
              }),
              regexp = _compilePath.regexp,
              keys = _compilePath.keys;
            var match = regexp.exec(pathname);
            if (!match) return null;
            var url = match[0],
              values = match.slice(1);
            var isExact = pathname === url;
            if (exact && !isExact) return null;
            return {
              path: path2,
              // the path used to match
              url: path2 === "/" && url === "" ? "/" : url,
              // the matched portion of the URL
              isExact,
              // whether or not we matched exactly
              params: keys.reduce(function (memo, key, index) {
                memo[key.name] = values[index];
                return memo;
              }, {})
            };
          }, null);
        }
        function isEmptyChildren(children) {
          return React.Children.count(children) === 0;
        }
        var Route = exports("q", /* @__PURE__ */function (_React$Component) {
          _inheritsLoose(Route2, _React$Component);
          function Route2() {
            return _React$Component.apply(this, arguments) || this;
          }
          var _proto = Route2.prototype;
          _proto.render = function render() {
            var _this = this;
            return /* @__PURE__ */React.createElement(context.Consumer, null, function (context$1) {
              !context$1 ? invariant() : void 0;
              var location = _this.props.location || context$1.location;
              var match = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;
              var props = _extends$2({}, context$1, {
                location,
                match
              });
              var _this$props = _this.props,
                children = _this$props.children,
                component = _this$props.component,
                render2 = _this$props.render;
              if (Array.isArray(children) && isEmptyChildren(children)) {
                children = null;
              }
              return /* @__PURE__ */React.createElement(context.Provider, {
                value: props
              }, props.match ? children ? typeof children === "function" ? children(props) : children : component ? /* @__PURE__ */React.createElement(component, props) : render2 ? render2(props) : null : typeof children === "function" ? children(props) : null);
            });
          };
          return Route2;
        }(React.Component));
        function addLeadingSlash(path) {
          return path.charAt(0) === "/" ? path : "/" + path;
        }
        function addBasename(basename, location) {
          if (!basename) return location;
          return _extends$2({}, location, {
            pathname: addLeadingSlash(basename) + location.pathname
          });
        }
        function stripBasename(basename, location) {
          if (!basename) return location;
          var base = addLeadingSlash(basename);
          if (location.pathname.indexOf(base) !== 0) return location;
          return _extends$2({}, location, {
            pathname: location.pathname.substr(base.length)
          });
        }
        function createURL(location) {
          return typeof location === "string" ? location : createPath(location);
        }
        function staticHandler(methodName) {
          return function () {
            invariant();
          };
        }
        function noop() {}
        /* @__PURE__ */
        (function (_React$Component) {
          _inheritsLoose(StaticRouter2, _React$Component);
          function StaticRouter2() {
            var _this;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
            _this.handlePush = function (location) {
              return _this.navigateTo(location, "PUSH");
            };
            _this.handleReplace = function (location) {
              return _this.navigateTo(location, "REPLACE");
            };
            _this.handleListen = function () {
              return noop;
            };
            _this.handleBlock = function () {
              return noop;
            };
            return _this;
          }
          var _proto = StaticRouter2.prototype;
          _proto.navigateTo = function navigateTo(location, action) {
            var _this$props = this.props,
              _this$props$basename = _this$props.basename,
              basename = _this$props$basename === void 0 ? "" : _this$props$basename,
              _this$props$context = _this$props.context,
              context2 = _this$props$context === void 0 ? {} : _this$props$context;
            context2.action = action;
            context2.location = addBasename(basename, createLocation(location));
            context2.url = createURL(context2.location);
          };
          _proto.render = function render() {
            var _this$props2 = this.props,
              _this$props2$basename = _this$props2.basename,
              basename = _this$props2$basename === void 0 ? "" : _this$props2$basename,
              _this$props2$context = _this$props2.context,
              context2 = _this$props2$context === void 0 ? {} : _this$props2$context,
              _this$props2$location = _this$props2.location,
              location = _this$props2$location === void 0 ? "/" : _this$props2$location,
              rest = _objectWithoutPropertiesLoose$1(_this$props2, ["basename", "context", "location"]);
            var history = {
              createHref: function createHref(path) {
                return addLeadingSlash(basename + createURL(path));
              },
              action: "POP",
              location: stripBasename(basename, createLocation(location)),
              push: this.handlePush,
              replace: this.handleReplace,
              go: staticHandler(),
              goBack: staticHandler(),
              goForward: staticHandler(),
              listen: this.handleListen,
              block: this.handleBlock
            };
            return /* @__PURE__ */React.createElement(Router, _extends$2({}, rest, {
              history,
              staticContext: context2
            }));
          };
          return StaticRouter2;
        })(React.Component);
        /* @__PURE__ */
        (function (_React$Component) {
          _inheritsLoose(Switch2, _React$Component);
          function Switch2() {
            return _React$Component.apply(this, arguments) || this;
          }
          var _proto = Switch2.prototype;
          _proto.render = function render() {
            var _this = this;
            return /* @__PURE__ */React.createElement(context.Consumer, null, function (context2) {
              !context2 ? invariant() : void 0;
              var location = _this.props.location || context2.location;
              var element, match;
              React.Children.forEach(_this.props.children, function (child) {
                if (match == null && /* @__PURE__ */React.isValidElement(child)) {
                  element = child;
                  var path = child.props.path || child.props.from;
                  match = path ? matchPath(location.pathname, _extends$2({}, child.props, {
                    path
                  })) : context2.match;
                }
              });
              return match ? /* @__PURE__ */React.cloneElement(element, {
                location,
                computedMatch: match
              }) : null;
            });
          };
          return Switch2;
        })(React.Component);
        function withRouter(Component) {
          var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";
          var C = function C2(props) {
            var wrappedComponentRef = props.wrappedComponentRef,
              remainingProps = _objectWithoutPropertiesLoose$1(props, ["wrappedComponentRef"]);
            return /* @__PURE__ */React.createElement(context.Consumer, null, function (context2) {
              !context2 ? invariant() : void 0;
              return /* @__PURE__ */React.createElement(Component, _extends$2({}, remainingProps, context2, {
                ref: wrappedComponentRef
              }));
            });
          };
          C.displayName = displayName;
          C.WrappedComponent = Component;
          return hoistStatics(C, Component);
        }
        var useContext = React.useContext;
        function useHistory() {
          return useContext(historyContext);
        }
        function useLocation() {
          return useContext(context).location;
        }
        function useParams() {
          var match = useContext(context).match;
          return match ? match.params : {};
        }
        function useLoadGsiScript(options = {}) {
          const {
            nonce,
            onScriptLoadSuccess,
            onScriptLoadError
          } = options;
          const [scriptLoadedSuccessfully, setScriptLoadedSuccessfully] = reactExports.useState(false);
          const onScriptLoadSuccessRef = reactExports.useRef(onScriptLoadSuccess);
          onScriptLoadSuccessRef.current = onScriptLoadSuccess;
          const onScriptLoadErrorRef = reactExports.useRef(onScriptLoadError);
          onScriptLoadErrorRef.current = onScriptLoadError;
          reactExports.useEffect(() => {
            const scriptTag = document.createElement('script');
            scriptTag.src = 'https://accounts.google.com/gsi/client';
            scriptTag.async = true;
            scriptTag.defer = true;
            scriptTag.nonce = nonce;
            scriptTag.onload = () => {
              var _a;
              setScriptLoadedSuccessfully(true);
              (_a = onScriptLoadSuccessRef.current) === null || _a === void 0 ? void 0 : _a.call(onScriptLoadSuccessRef);
            };
            scriptTag.onerror = () => {
              var _a;
              setScriptLoadedSuccessfully(false);
              (_a = onScriptLoadErrorRef.current) === null || _a === void 0 ? void 0 : _a.call(onScriptLoadErrorRef);
            };
            document.body.appendChild(scriptTag);
            return () => {
              document.body.removeChild(scriptTag);
            };
          }, [nonce]);
          return scriptLoadedSuccessfully;
        }
        const GoogleOAuthContext = reactExports.createContext(null);
        function GoogleOAuthProvider({
          clientId,
          nonce,
          onScriptLoadSuccess,
          onScriptLoadError,
          children
        }) {
          const scriptLoadedSuccessfully = useLoadGsiScript({
            nonce,
            onScriptLoadSuccess,
            onScriptLoadError
          });
          const contextValue = reactExports.useMemo(() => ({
            clientId,
            scriptLoadedSuccessfully
          }), [clientId, scriptLoadedSuccessfully]);
          return React.createElement(GoogleOAuthContext.Provider, {
            value: contextValue
          }, children);
        }
        function useGoogleOAuth() {
          const context = reactExports.useContext(GoogleOAuthContext);
          if (!context) {
            throw new Error('Google OAuth components must be used within GoogleOAuthProvider');
          }
          return context;
        }

        /* eslint-disable import/export */
        function useGoogleLogin({
          flow = 'implicit',
          scope = '',
          onSuccess,
          onError,
          onNonOAuthError,
          overrideScope,
          state,
          ...props
        }) {
          const {
            clientId,
            scriptLoadedSuccessfully
          } = useGoogleOAuth();
          const clientRef = reactExports.useRef();
          const onSuccessRef = reactExports.useRef(onSuccess);
          onSuccessRef.current = onSuccess;
          const onErrorRef = reactExports.useRef(onError);
          onErrorRef.current = onError;
          const onNonOAuthErrorRef = reactExports.useRef(onNonOAuthError);
          onNonOAuthErrorRef.current = onNonOAuthError;
          reactExports.useEffect(() => {
            var _a;
            if (!scriptLoadedSuccessfully) return;
            const clientMethod = flow === 'implicit' ? 'initTokenClient' : 'initCodeClient';
            const client = (_a = window === null || window === void 0 ? void 0 : window.google) === null || _a === void 0 ? void 0 : _a.accounts.oauth2[clientMethod]({
              client_id: clientId,
              scope: overrideScope ? scope : `openid profile email ${scope}`,
              callback: response => {
                var _a, _b;
                if (response.error) return (_a = onErrorRef.current) === null || _a === void 0 ? void 0 : _a.call(onErrorRef, response);
                (_b = onSuccessRef.current) === null || _b === void 0 ? void 0 : _b.call(onSuccessRef, response);
              },
              error_callback: nonOAuthError => {
                var _a;
                (_a = onNonOAuthErrorRef.current) === null || _a === void 0 ? void 0 : _a.call(onNonOAuthErrorRef, nonOAuthError);
              },
              state,
              ...props
            });
            clientRef.current = client;
            // eslint-disable-next-line react-hooks/exhaustive-deps
          }, [clientId, scriptLoadedSuccessfully, flow, scope, state]);
          const loginImplicitFlow = reactExports.useCallback(overrideConfig => {
            var _a;
            return (_a = clientRef.current) === null || _a === void 0 ? void 0 : _a.requestAccessToken(overrideConfig);
          }, []);
          const loginAuthCodeFlow = reactExports.useCallback(() => {
            var _a;
            return (_a = clientRef.current) === null || _a === void 0 ? void 0 : _a.requestCode();
          }, []);
          return flow === 'implicit' ? loginImplicitFlow : loginAuthCodeFlow;
        }
        const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);
        let idbProxyableTypes;
        let cursorAdvanceMethods;
        // This is a function to prevent it throwing up in node environments.
        function getIdbProxyableTypes() {
          return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);
        }
        // This is a function to prevent it throwing up in node environments.
        function getCursorAdvanceMethods() {
          return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);
        }
        const cursorRequestMap = new WeakMap();
        const transactionDoneMap = new WeakMap();
        const transactionStoreNamesMap = new WeakMap();
        const transformCache = new WeakMap();
        const reverseTransformCache = new WeakMap();
        function promisifyRequest(request) {
          const promise = new Promise((resolve, reject) => {
            const unlisten = () => {
              request.removeEventListener('success', success);
              request.removeEventListener('error', error);
            };
            const success = () => {
              resolve(wrap(request.result));
              unlisten();
            };
            const error = () => {
              reject(request.error);
              unlisten();
            };
            request.addEventListener('success', success);
            request.addEventListener('error', error);
          });
          promise.then(value => {
            // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
            // (see wrapFunction).
            if (value instanceof IDBCursor) {
              cursorRequestMap.set(value, request);
            }
            // Catching to avoid "Uncaught Promise exceptions"
          }).catch(() => {});
          // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
          // is because we create many promises from a single IDBRequest.
          reverseTransformCache.set(promise, request);
          return promise;
        }
        function cacheDonePromiseForTransaction(tx) {
          // Early bail if we've already created a done promise for this transaction.
          if (transactionDoneMap.has(tx)) return;
          const done = new Promise((resolve, reject) => {
            const unlisten = () => {
              tx.removeEventListener('complete', complete);
              tx.removeEventListener('error', error);
              tx.removeEventListener('abort', error);
            };
            const complete = () => {
              resolve();
              unlisten();
            };
            const error = () => {
              reject(tx.error || new DOMException('AbortError', 'AbortError'));
              unlisten();
            };
            tx.addEventListener('complete', complete);
            tx.addEventListener('error', error);
            tx.addEventListener('abort', error);
          });
          // Cache it for later retrieval.
          transactionDoneMap.set(tx, done);
        }
        let idbProxyTraps = {
          get(target, prop, receiver) {
            if (target instanceof IDBTransaction) {
              // Special handling for transaction.done.
              if (prop === 'done') return transactionDoneMap.get(target);
              // Polyfill for objectStoreNames because of Edge.
              if (prop === 'objectStoreNames') {
                return target.objectStoreNames || transactionStoreNamesMap.get(target);
              }
              // Make tx.store return the only store in the transaction, or undefined if there are many.
              if (prop === 'store') {
                return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);
              }
            }
            // Else transform whatever we get back.
            return wrap(target[prop]);
          },
          set(target, prop, value) {
            target[prop] = value;
            return true;
          },
          has(target, prop) {
            if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {
              return true;
            }
            return prop in target;
          }
        };
        function replaceTraps(callback) {
          idbProxyTraps = callback(idbProxyTraps);
        }
        function wrapFunction(func) {
          // Due to expected object equality (which is enforced by the caching in `wrap`), we
          // only create one new func per func.
          // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
          if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {
            return function (storeNames, ...args) {
              const tx = func.call(unwrap(this), storeNames, ...args);
              transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
              return wrap(tx);
            };
          }
          // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
          // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
          // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
          // with real promises, so each advance methods returns a new promise for the cursor object, or
          // undefined if the end of the cursor has been reached.
          if (getCursorAdvanceMethods().includes(func)) {
            return function (...args) {
              // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
              // the original object.
              func.apply(unwrap(this), args);
              return wrap(cursorRequestMap.get(this));
            };
          }
          return function (...args) {
            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
            // the original object.
            return wrap(func.apply(unwrap(this), args));
          };
        }
        function transformCachableValue(value) {
          if (typeof value === 'function') return wrapFunction(value);
          // This doesn't return, it just creates a 'done' promise for the transaction,
          // which is later returned for transaction.done (see idbObjectHandler).
          if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);
          if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);
          // Return the same value back if we're not going to transform it.
          return value;
        }
        function wrap(value) {
          // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
          // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
          if (value instanceof IDBRequest) return promisifyRequest(value);
          // If we've already transformed this value before, reuse the transformed value.
          // This is faster, but it also provides object equality.
          if (transformCache.has(value)) return transformCache.get(value);
          const newValue = transformCachableValue(value);
          // Not all types are transformed.
          // These may be primitive types, so they can't be WeakMap keys.
          if (newValue !== value) {
            transformCache.set(value, newValue);
            reverseTransformCache.set(newValue, value);
          }
          return newValue;
        }
        const unwrap = value => reverseTransformCache.get(value);

        /**
         * Open a database.
         *
         * @param name Name of the database.
         * @param version Schema version.
         * @param callbacks Additional callbacks.
         */
        function openDB(name, version, {
          blocked,
          upgrade,
          blocking,
          terminated
        } = {}) {
          const request = indexedDB.open(name, version);
          const openPromise = wrap(request);
          if (upgrade) {
            request.addEventListener('upgradeneeded', event => {
              upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
            });
          }
          if (blocked) {
            request.addEventListener('blocked', event => blocked(
            // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
            event.oldVersion, event.newVersion, event));
          }
          openPromise.then(db => {
            if (terminated) db.addEventListener('close', () => terminated());
            if (blocking) {
              db.addEventListener('versionchange', event => blocking(event.oldVersion, event.newVersion, event));
            }
          }).catch(() => {});
          return openPromise;
        }
        /**
         * Delete a database.
         *
         * @param name Name of the database.
         */
        function deleteDB(name, {
          blocked
        } = {}) {
          const request = indexedDB.deleteDatabase(name);
          if (blocked) {
            request.addEventListener('blocked', event => blocked(
            // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
            event.oldVersion, event));
          }
          return wrap(request).then(() => undefined);
        }
        const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
        const writeMethods = ['put', 'add', 'delete', 'clear'];
        const cachedMethods = new Map();
        function getMethod(target, prop) {
          if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {
            return;
          }
          if (cachedMethods.get(prop)) return cachedMethods.get(prop);
          const targetFuncName = prop.replace(/FromIndex$/, '');
          const useIndex = prop !== targetFuncName;
          const isWrite = writeMethods.includes(targetFuncName);
          if (
          // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
          !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
            return;
          }
          const method = async function (storeName, ...args) {
            // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
            const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
            let target = tx.store;
            if (useIndex) target = target.index(args.shift());
            // Must reject if op rejects.
            // If it's a write operation, must reject if tx.done rejects.
            // Must reject with op rejection first.
            // Must resolve with op value.
            // Must handle both promises (no unhandled rejections)
            return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];
          };
          cachedMethods.set(prop, method);
          return method;
        }
        replaceTraps(oldTraps => ({
          ...oldTraps,
          get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
          has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
        }));
        const ErrorBoundaryContext$1 = reactExports.createContext(null);
        const initialState$2 = {
          didCatch: false,
          error: null
        };
        let ErrorBoundary$1 = class ErrorBoundary extends reactExports.Component {
          constructor(props) {
            super(props);
            this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
            this.state = initialState$2;
          }
          static getDerivedStateFromError(error) {
            return {
              didCatch: true,
              error
            };
          }
          resetErrorBoundary() {
            const {
              error
            } = this.state;
            if (error !== null) {
              var _this$props$onReset, _this$props;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
                args,
                reason: "imperative-api"
              });
              this.setState(initialState$2);
            }
          }
          componentDidCatch(error, info) {
            var _this$props$onError, _this$props2;
            (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);
          }
          componentDidUpdate(prevProps, prevState) {
            const {
              didCatch
            } = this.state;
            const {
              resetKeys
            } = this.props;

            // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,
            // we'd end up resetting the error boundary immediately.
            // This would likely trigger a second error to be thrown.
            // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.

            if (didCatch && prevState.error !== null && hasArrayChanged$1(prevProps.resetKeys, resetKeys)) {
              var _this$props$onReset2, _this$props3;
              (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
                next: resetKeys,
                prev: prevProps.resetKeys,
                reason: "keys"
              });
              this.setState(initialState$2);
            }
          }
          render() {
            const {
              children,
              fallbackRender,
              FallbackComponent,
              fallback
            } = this.props;
            const {
              didCatch,
              error
            } = this.state;
            let childToRender = children;
            if (didCatch) {
              const props = {
                error,
                resetErrorBoundary: this.resetErrorBoundary
              };
              if (typeof fallbackRender === "function") {
                childToRender = fallbackRender(props);
              } else if (FallbackComponent) {
                childToRender = reactExports.createElement(FallbackComponent, props);
              } else if (fallback !== undefined) {
                childToRender = fallback;
              } else {
                throw error;
              }
            }
            return reactExports.createElement(ErrorBoundaryContext$1.Provider, {
              value: {
                didCatch,
                error,
                resetErrorBoundary: this.resetErrorBoundary
              }
            }, childToRender);
          }
        };
        exports("at", ErrorBoundary$1);
        function hasArrayChanged$1() {
          let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));
        }
        class ClipboardWeb extends WebPlugin {
          async write(options) {
            if (typeof navigator === 'undefined' || !navigator.clipboard) {
              throw this.unavailable('Clipboard API not available in this browser');
            }
            if (options.string !== undefined) {
              await this.writeText(options.string);
            } else if (options.url) {
              await this.writeText(options.url);
            } else if (options.image) {
              if (typeof ClipboardItem !== 'undefined') {
                try {
                  const blob = await (await fetch(options.image)).blob();
                  const clipboardItemInput = new ClipboardItem({
                    [blob.type]: blob
                  });
                  await navigator.clipboard.write([clipboardItemInput]);
                } catch (err) {
                  throw new Error('Failed to write image');
                }
              } else {
                throw this.unavailable('Writing images to the clipboard is not supported in this browser');
              }
            } else {
              throw new Error('Nothing to write');
            }
          }
          async read() {
            if (typeof navigator === 'undefined' || !navigator.clipboard) {
              throw this.unavailable('Clipboard API not available in this browser');
            }
            if (typeof ClipboardItem !== 'undefined') {
              try {
                const clipboardItems = await navigator.clipboard.read();
                const type = clipboardItems[0].types[0];
                const clipboardBlob = await clipboardItems[0].getType(type);
                const data = await this._getBlobData(clipboardBlob, type);
                return {
                  value: data,
                  type
                };
              } catch (err) {
                return this.readText();
              }
            } else {
              return this.readText();
            }
          }
          async readText() {
            if (typeof navigator === 'undefined' || !navigator.clipboard || !navigator.clipboard.readText) {
              throw this.unavailable('Reading from clipboard not supported in this browser');
            }
            const text = await navigator.clipboard.readText();
            return {
              value: text,
              type: 'text/plain'
            };
          }
          async writeText(text) {
            if (typeof navigator === 'undefined' || !navigator.clipboard || !navigator.clipboard.writeText) {
              throw this.unavailable('Writting to clipboard not supported in this browser');
            }
            await navigator.clipboard.writeText(text);
          }
          _getBlobData(clipboardBlob, type) {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              if (type.includes('image')) {
                reader.readAsDataURL(clipboardBlob);
              } else {
                reader.readAsText(clipboardBlob);
              }
              reader.onloadend = () => {
                const r = reader.result;
                resolve(r);
              };
              reader.onerror = e => {
                reject(e);
              };
            });
          }
        }
        const Clipboard = exports("au", registerPlugin('Clipboard', {
          web: () => new ClipboardWeb()
        }));
        function __rest(s, e) {
          var t = {};
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
          }
          return t;
        }
        typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
          var e = new Error(message);
          return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
        };
        function useAttribution(map, attribution) {
          const attributionRef = reactExports.useRef(attribution);
          reactExports.useEffect(function updateAttribution() {
            if (attribution !== attributionRef.current && map.attributionControl != null) {
              if (attributionRef.current != null) {
                map.attributionControl.removeAttribution(attributionRef.current);
              }
              if (attribution != null) {
                map.attributionControl.addAttribution(attribution);
              }
            }
            attributionRef.current = attribution;
          }, [map, attribution]);
        }
        const CONTEXT_VERSION = 1;
        function createLeafletContext(map) {
          return Object.freeze({
            __version: CONTEXT_VERSION,
            map
          });
        }
        const LeafletContext = reactExports.createContext(null);
        const LeafletProvider = LeafletContext.Provider;
        function useLeafletContext() {
          const context = reactExports.useContext(LeafletContext);
          if (context == null) {
            throw new Error('No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>');
          }
          return context;
        }
        function createLeafComponent(useElement) {
          function LeafComponent(props, forwardedRef) {
            const {
              instance
            } = useElement(props).current;
            reactExports.useImperativeHandle(forwardedRef, () => instance);
            return null;
          }
          return /*#__PURE__*/reactExports.forwardRef(LeafComponent);
        }
        function useEventHandlers(element, eventHandlers) {
          const eventHandlersRef = reactExports.useRef();
          reactExports.useEffect(function addEventHandlers() {
            if (eventHandlers != null) {
              element.instance.on(eventHandlers);
            }
            eventHandlersRef.current = eventHandlers;
            return function removeEventHandlers() {
              if (eventHandlersRef.current != null) {
                element.instance.off(eventHandlersRef.current);
              }
              eventHandlersRef.current = null;
            };
          }, [element, eventHandlers]);
        }
        function withPane(props, context) {
          const pane = props.pane ?? context.pane;
          return pane ? {
            ...props,
            pane
          } : props;
        }
        function createElementObject(instance, context, container) {
          return Object.freeze({
            instance,
            context,
            container
          });
        }
        function createElementHook(createElement, updateElement) {
          if (updateElement == null) {
            return function useImmutableLeafletElement(props, context) {
              const elementRef = reactExports.useRef();
              if (!elementRef.current) elementRef.current = createElement(props, context);
              return elementRef;
            };
          }
          return function useMutableLeafletElement(props, context) {
            const elementRef = reactExports.useRef();
            if (!elementRef.current) elementRef.current = createElement(props, context);
            const propsRef = reactExports.useRef(props);
            const {
              instance
            } = elementRef.current;
            reactExports.useEffect(function updateElementProps() {
              if (propsRef.current !== props) {
                updateElement(instance, props, propsRef.current);
                propsRef.current = props;
              }
            }, [instance, props, context]);
            return elementRef;
          };
        }
        function useLayerLifecycle(element, context) {
          reactExports.useEffect(function addLayer() {
            const container = context.layerContainer ?? context.map;
            container.addLayer(element.instance);
            return function removeLayer() {
              context.layerContainer?.removeLayer(element.instance);
              context.map.removeLayer(element.instance);
            };
          }, [context, element]);
        }
        function createLayerHook(useElement) {
          return function useLayer(props) {
            const context = useLeafletContext();
            const elementRef = useElement(withPane(props, context), context);
            useAttribution(context.map, props.attribution);
            useEventHandlers(elementRef.current, props.eventHandlers);
            useLayerLifecycle(elementRef.current, context);
            return elementRef;
          };
        }
        function createTileLayerComponent(createElement, updateElement) {
          const useElement = createElementHook(createElement, updateElement);
          const useLayer = createLayerHook(useElement);
          return createLeafComponent(useLayer);
        }
        function updateGridLayer(layer, props, prevProps) {
          const {
            opacity,
            zIndex
          } = props;
          if (opacity != null && opacity !== prevProps.opacity) {
            layer.setOpacity(opacity);
          }
          if (zIndex != null && zIndex !== prevProps.zIndex) {
            layer.setZIndex(zIndex);
          }
        }
        function useMap() {
          return useLeafletContext().map;
        }
        function _extends() {
          _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends.apply(this, arguments);
        }
        function MapContainerComponent({
          bounds,
          boundsOptions,
          center,
          children,
          className,
          id,
          placeholder,
          style,
          whenReady,
          zoom,
          ...options
        }, forwardedRef) {
          const [props] = reactExports.useState({
            className,
            id,
            style
          });
          const [context, setContext] = reactExports.useState(null);
          reactExports.useImperativeHandle(forwardedRef, () => context?.map ?? null, [context]);
          const mapRef = reactExports.useCallback(node => {
            if (node !== null && context === null) {
              const map = new leafletSrcExports.Map(node, options);
              if (center != null && zoom != null) {
                map.setView(center, zoom);
              } else if (bounds != null) {
                map.fitBounds(bounds, boundsOptions);
              }
              if (whenReady != null) {
                map.whenReady(whenReady);
              }
              setContext(createLeafletContext(map));
            }
            // eslint-disable-next-line react-hooks/exhaustive-deps
          }, []);
          reactExports.useEffect(() => {
            return () => {
              context?.map.remove();
            };
          }, [context]);
          const contents = context ? /*#__PURE__*/React.createElement(LeafletProvider, {
            value: context
          }, children) : placeholder ?? null;
          return /*#__PURE__*/React.createElement("div", _extends({}, props, {
            ref: mapRef
          }), contents);
        }
        const MapContainer = exports("aS", /*#__PURE__*/reactExports.forwardRef(MapContainerComponent));
        const TileLayer = exports("aT", createTileLayerComponent(function createTileLayer({
          url,
          ...options
        }, context) {
          const layer = new leafletSrcExports.TileLayer(url, withPane(options, context));
          return createElementObject(layer, context);
        }, function updateTileLayer(layer, props, prevProps) {
          updateGridLayer(layer, props, prevProps);
          const {
            url
          } = props;
          if (url != null && url !== prevProps.url) {
            layer.setUrl(url);
          }
        }));
        function e() {
          return e = Object.assign ? Object.assign.bind() : function (t) {
            for (var e = 1; e < arguments.length; e++) {
              var r = arguments[e];
              for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
            }
            return t;
          }, e.apply(this, arguments);
        }
        function r(t, e) {
          t.prototype = Object.create(e.prototype), t.prototype.constructor = t, n(t, e);
        }
        function n(t, e) {
          return n = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
            return t.__proto__ = e, t;
          }, n(t, e);
        }
        function o() {
          if ("undefined" == typeof Reflect || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if ("function" == typeof Proxy) return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return false;
          }
        }
        function i(t, e, r) {
          return i = o() ? Reflect.construct.bind() : function (t, e, r) {
            var o = [null];
            o.push.apply(o, e);
            var i = new (Function.bind.apply(t, o))();
            return r && n(i, r.prototype), i;
          }, i.apply(null, arguments);
        }
        function s(t, e, r, n) {
          void 0 === e && (e = ""), void 0 === n && (n = {});
          var o = document.createElement(t);
          return e && (o.className = e), Object.keys(n).forEach(function (t) {
            if ("function" == typeof n[t]) {
              var e = 0 === t.indexOf("on") ? t.substr(2).toLowerCase() : t;
              o.addEventListener(e, n[t]);
            } else "html" === t ? o.innerHTML = n[t] : "text" === t ? o.innerText = n[t] : o.setAttribute(t, n[t]);
          }), r && r.appendChild(o), o;
        }
        function a(t) {
          t.preventDefault(), t.stopPropagation();
        }
        var l = function () {
          return [].slice.call(arguments).filter(Boolean).join(" ").trim();
        };
        function c(t, e) {
          t && t.classList && (Array.isArray(e) ? e : [e]).forEach(function (e) {
            t.classList.contains(e) || t.classList.add(e);
          });
        }
        function u(t, e) {
          t && t.classList && (Array.isArray(e) ? e : [e]).forEach(function (e) {
            t.classList.contains(e) && t.classList.remove(e);
          });
        }
        var h,
          p = 13,
          d = 40,
          f = 38,
          m = [p, 27, d, f, 37, 39],
          v = /*#__PURE__*/function () {
            function t(t) {
              var e = this,
                r = t.handleSubmit,
                n = t.searchLabel,
                o = t.classNames,
                i = void 0 === o ? {} : o;
              this.container = void 0, this.form = void 0, this.input = void 0, this.handleSubmit = void 0, this.hasError = false, this.container = s("div", l("geosearch", i.container)), this.form = s("form", ["", i.form].join(" "), this.container, {
                autocomplete: "none",
                onClick: a,
                onDblClick: a,
                touchStart: a,
                touchEnd: a
              }), this.input = s("input", ["glass", i.input].join(" "), this.form, {
                type: "text",
                placeholder: n || "search",
                onInput: this.onInput,
                onKeyUp: function (t) {
                  return e.onKeyUp(t);
                },
                onKeyPress: function (t) {
                  return e.onKeyPress(t);
                },
                onFocus: this.onFocus,
                onBlur: this.onBlur,
                onClick: function () {
                  e.input.focus(), e.input.dispatchEvent(new Event("focus"));
                }
              }), this.handleSubmit = r;
            }
            var e = t.prototype;
            return e.onFocus = function () {
              c(this.form, "active");
            }, e.onBlur = function () {
              u(this.form, "active");
            }, e.onSubmit = function (t) {
              try {
                var e = this;
                return a(t), u(r = e.container, "error"), c(r, "pending"), Promise.resolve(e.handleSubmit({
                  query: e.input.value
                })).then(function () {
                  u(e.container, "pending");
                });
              } catch (t) {
                return Promise.reject(t);
              }
              var r;
            }, e.onInput = function () {
              this.hasError && (u(this.container, "error"), this.hasError = false);
            }, e.onKeyUp = function (t) {
              27 === t.keyCode && (u(this.container, ["pending", "active"]), this.input.value = "", document.body.focus(), document.body.blur());
            }, e.onKeyPress = function (t) {
              t.keyCode === p && this.onSubmit(t);
            }, e.setQuery = function (t) {
              this.input.value = t;
            }, t;
          }(),
          g = /*#__PURE__*/function () {
            function t(t) {
              var e = this,
                r = t.handleClick,
                n = t.classNames,
                o = void 0 === n ? {} : n,
                i = t.notFoundMessage;
              this.handleClick = void 0, this.selected = -1, this.results = [], this.container = void 0, this.resultItem = void 0, this.notFoundMessage = void 0, this.onClick = function (t) {
                if ("function" == typeof e.handleClick) {
                  var r = t.target;
                  if (r && e.container.contains(r) && r.hasAttribute("data-key")) {
                    var n = Number(r.getAttribute("data-key"));
                    e.handleClick({
                      result: e.results[n]
                    });
                  }
                }
              }, this.handleClick = r, this.notFoundMessage = i ? s("div", l(o.notfound), void 0, {
                html: i
              }) : void 0, this.container = s("div", l("results", o.resultlist)), this.container.addEventListener("click", this.onClick, true), this.resultItem = s("div", l(o.item));
            }
            var e = t.prototype;
            return e.render = function (t, e) {
              var r = this;
              void 0 === t && (t = []), this.clear(), t.forEach(function (t, n) {
                var o = r.resultItem.cloneNode(true);
                o.setAttribute("data-key", "" + n), o.innerHTML = e({
                  result: t
                }), r.container.appendChild(o);
              }), t.length > 0 ? (c(this.container.parentElement, "open"), c(this.container, "active")) : this.notFoundMessage && (this.container.appendChild(this.notFoundMessage), c(this.container.parentElement, "open")), this.results = t;
            }, e.select = function (t) {
              return Array.from(this.container.children).forEach(function (e, r) {
                return r === t ? c(e, "active") : u(e, "active");
              }), this.selected = t, this.results[t];
            }, e.count = function () {
              return this.results ? this.results.length : 0;
            }, e.clear = function () {
              for (this.selected = -1; this.container.lastChild;) this.container.removeChild(this.container.lastChild);
              u(this.container.parentElement, "open"), u(this.container, "active");
            }, t;
          }(),
          y = {
            position: "topleft",
            style: "button",
            showMarker: true,
            showPopup: false,
            popupFormat: function (t) {
              return "" + t.result.label;
            },
            resultFormat: function (t) {
              return "" + t.result.label;
            },
            marker: {
              icon: t$1 && leafletSrcExports.Icon ? new leafletSrcExports.Icon.Default() : void 0,
              draggable: false
            },
            maxMarkers: 1,
            maxSuggestions: 5,
            retainZoomLevel: false,
            animateZoom: true,
            searchLabel: "Enter address",
            clearSearchLabel: "Clear search",
            notFoundMessage: "",
            messageHideDelay: 3e3,
            zoomLevel: 18,
            classNames: {
              container: "leaflet-bar leaflet-control leaflet-control-geosearch",
              button: "leaflet-bar-part leaflet-bar-part-single",
              resetButton: "reset",
              msgbox: "leaflet-bar message",
              form: "",
              input: "",
              resultlist: "",
              item: "",
              notfound: "leaflet-bar-notfound"
            },
            autoComplete: true,
            autoCompleteDelay: 250,
            autoClose: false,
            keepResult: false,
            updateMap: true
          },
          b = "Leaflet must be loaded before instantiating the GeoSearch control",
          E = {
            options: e({}, y),
            classNames: e({}, y.classNames),
            initialize: function (r) {
              var n,
                o,
                i,
                a,
                l = this;
              if (!t$1) throw new Error(b);
              if (!r.provider) throw new Error("Provider is missing from options");
              this.options = e({}, y, r), this.classNames = e({}, this.classNames, r.classNames), this.markers = new leafletSrcExports.FeatureGroup(), this.classNames.container += " leaflet-geosearch-" + this.options.style, this.searchElement = new v({
                searchLabel: this.options.searchLabel,
                classNames: {
                  container: this.classNames.container,
                  form: this.classNames.form,
                  input: this.classNames.input
                },
                handleSubmit: function (t) {
                  return l.onSubmit(t);
                }
              }), this.button = s("a", this.classNames.button, this.searchElement.container, {
                title: this.options.searchLabel,
                href: "#",
                onClick: function (t) {
                  return l.onClick(t);
                }
              }), leafletSrcExports.DomEvent.disableClickPropagation(this.button), this.resetButton = s("button", this.classNames.resetButton, this.searchElement.form, {
                text: "",
                "aria-label": this.options.clearSearchLabel,
                onClick: function () {
                  "" === l.searchElement.input.value ? l.close() : l.clearResults(null, true);
                }
              }), leafletSrcExports.DomEvent.disableClickPropagation(this.resetButton), this.options.autoComplete && (this.resultList = new g({
                handleClick: function (t) {
                  var e = t.result;
                  l.searchElement.input.value = e.label, l.onSubmit({
                    query: e.label,
                    data: e
                  });
                },
                classNames: {
                  resultlist: this.classNames.resultlist,
                  item: this.classNames.item,
                  notfound: this.classNames.notfound
                },
                notFoundMessage: this.options.notFoundMessage
              }), this.searchElement.form.appendChild(this.resultList.container), this.searchElement.input.addEventListener("keyup", (n = function (t) {
                return l.autoSearch(t);
              }, void 0 === (o = this.options.autoCompleteDelay) && (o = 250), void 0 === i && (i = false), function () {
                var t = [].slice.call(arguments);
                a && clearTimeout(a), a = setTimeout(function () {
                  a = null, i || n.apply(void 0, t);
                }, o), i && !a && n.apply(void 0, t);
              }), true), this.searchElement.input.addEventListener("keydown", function (t) {
                return l.selectResult(t);
              }, true), this.searchElement.input.addEventListener("keydown", function (t) {
                return l.clearResults(t, true);
              }, true)), this.searchElement.form.addEventListener("click", function (t) {
                t.preventDefault();
              }, false);
            },
            onAdd: function (e) {
              var r = this.options,
                n = r.showMarker,
                o = r.style;
              if (this.map = e, n && this.markers.addTo(e), "bar" === o) {
                var i = e.getContainer().querySelector(".leaflet-control-container");
                this.container = s("div", "leaflet-control-geosearch leaflet-geosearch-bar"), this.container.appendChild(this.searchElement.form), i.appendChild(this.container);
              }
              return leafletSrcExports.DomEvent.disableClickPropagation(this.searchElement.form), this.searchElement.container;
            },
            onRemove: function () {
              var t;
              return null == (t = this.container) || t.remove(), this;
            },
            open: function () {
              var t = this.searchElement,
                e = t.input;
              c(t.container, "active"), e.focus();
            },
            close: function () {
              u(this.searchElement.container, "active"), this.clearResults();
            },
            onClick: function (t) {
              t.preventDefault(), t.stopPropagation(), this.searchElement.container.classList.contains("active") ? this.close() : this.open();
            },
            selectResult: function (t) {
              if (-1 !== [p, d, f].indexOf(t.keyCode)) if (t.preventDefault(), t.keyCode !== p) {
                var e = this.resultList.count() - 1;
                if (!(e < 0)) {
                  var r = this.resultList.selected,
                    n = t.keyCode === d ? r + 1 : r - 1,
                    o = this.resultList.select(n < 0 ? e : n > e ? 0 : n);
                  this.searchElement.input.value = o.label;
                }
              } else {
                var i = this.resultList.select(this.resultList.selected);
                this.onSubmit({
                  query: this.searchElement.input.value,
                  data: i
                });
              }
            },
            clearResults: function (t, e) {
              if (void 0 === e && (e = false), !t || 27 === t.keyCode) {
                var r = this.options,
                  n = r.autoComplete;
                !e && r.keepResult || (this.searchElement.input.value = "", this.markers.clearLayers()), n && this.resultList.clear();
              }
            },
            autoSearch: function (t) {
              try {
                var e = this;
                if (m.indexOf(t.keyCode) > -1) return Promise.resolve();
                var r = t.target.value,
                  n = e.options.provider,
                  o = function () {
                    if (r.length) return Promise.resolve(n.search({
                      query: r
                    })).then(function (t) {
                      t = t.slice(0, e.options.maxSuggestions), e.resultList.render(t, e.options.resultFormat);
                    });
                    e.resultList.clear();
                  }();
                return Promise.resolve(o && o.then ? o.then(function () {}) : void 0);
              } catch (t) {
                return Promise.reject(t);
              }
            },
            onSubmit: function (t) {
              try {
                var e = this;
                return e.resultList.clear(), Promise.resolve(e.options.provider.search(t)).then(function (r) {
                  r && r.length > 0 && e.showResult(r[0], t);
                });
              } catch (t) {
                return Promise.reject(t);
              }
            },
            showResult: function (t, e) {
              var r = this.options,
                n = r.autoClose,
                o = r.updateMap,
                i = this.markers.getLayers();
              i.length >= this.options.maxMarkers && this.markers.removeLayer(i[0]);
              var s = this.addMarker(t, e);
              o && this.centerMap(t), this.map.fireEvent("geosearch/showlocation", {
                location: t,
                marker: s
              }), n && this.closeResults();
            },
            closeResults: function () {
              var t = this.searchElement.container;
              t.classList.contains("active") && u(t, "active"), this.clearResults();
            },
            addMarker: function (e, r) {
              var n = this,
                o = this.options,
                i = o.marker,
                s = o.showPopup,
                a = o.popupFormat,
                l = new leafletSrcExports.Marker([e.y, e.x], i),
                c = e.label;
              return "function" == typeof a && (c = a({
                query: r,
                result: e
              })), l.bindPopup(c), this.markers.addLayer(l), s && l.openPopup(), i.draggable && l.on("dragend", function (t) {
                n.map.fireEvent("geosearch/marker/dragend", {
                  location: l.getLatLng(),
                  event: t
                });
              }), l;
            },
            centerMap: function (e) {
              var r = this.options,
                n = r.retainZoomLevel,
                o = r.animateZoom,
                i = e.bounds ? new leafletSrcExports.LatLngBounds(e.bounds) : new leafletSrcExports.LatLng(e.y, e.x).toBounds(10),
                s = i.isValid() ? i : this.markers.getBounds();
              !n && i.isValid() && !e.bounds || n || !i.isValid() ? this.map.setView(s.getCenter(), this.getZoom(), {
                animate: o
              }) : this.map.fitBounds(s, {
                animate: o
              });
            },
            getZoom: function () {
              var t = this.options,
                e = t.zoomLevel;
              return t.retainZoomLevel ? this.map.getZoom() : e;
            }
          };
        function w() {
          if (!t$1) throw new Error(b);
          var e = leafletSrcExports.Control.extend(E);
          return i(e, [].slice.call(arguments));
        }
        !function (t) {
          t[t.SEARCH = 0] = "SEARCH", t[t.REVERSE = 1] = "REVERSE";
        }(h || (h = {}));
        var x,
          k = /*#__PURE__*/function () {
            function t(t) {
              void 0 === t && (t = {}), this.options = void 0, this.options = t;
            }
            var r = t.prototype;
            return r.getParamString = function (t) {
              void 0 === t && (t = {});
              var r = e({}, this.options.params, t);
              return Object.keys(r).map(function (t) {
                return encodeURIComponent(t) + "=" + encodeURIComponent(r[t]);
              }).join("&");
            }, r.getUrl = function (t, e) {
              return t + "?" + this.getParamString(e);
            }, r.search = function (t) {
              try {
                var e = this,
                  r = e.endpoint({
                    query: t.query,
                    type: h.SEARCH
                  });
                return Promise.resolve(fetch(r)).then(function (t) {
                  return Promise.resolve(t.json()).then(function (t) {
                    return e.parse({
                      data: t
                    });
                  });
                });
              } catch (t) {
                return Promise.reject(t);
              }
            }, t;
          }();
        !function (t) {
          t[t.INITIALIZED = 0] = "INITIALIZED", t[t.LOADING = 1] = "LOADING", t[t.SUCCESS = 2] = "SUCCESS", t[t.FAILURE = 3] = "FAILURE";
        }(x || (x = {}));
        var O = exports("aP", /*#__PURE__*/function (t) {
          function e(e) {
            var r;
            void 0 === e && (e = {}), (r = t.call(this, e) || this).searchUrl = void 0, r.reverseUrl = void 0;
            var n = "https://nominatim.openstreetmap.org";
            return r.searchUrl = e.searchUrl || n + "/search", r.reverseUrl = e.reverseUrl || n + "/reverse", r;
          }
          r(e, t);
          var n = e.prototype;
          return n.endpoint = function (t) {
            var e = t.query,
              r = t.type,
              n = "string" == typeof e ? {
                q: e
              } : e;
            return n.format = "json", this.getUrl(r === h.REVERSE ? this.reverseUrl : this.searchUrl, n);
          }, n.parse = function (t) {
            return (Array.isArray(t.data) ? t.data : [t.data]).map(function (t) {
              return {
                x: Number(t.lon),
                y: Number(t.lat),
                label: t.display_name,
                bounds: [[parseFloat(t.boundingbox[0]), parseFloat(t.boundingbox[2])], [parseFloat(t.boundingbox[1]), parseFloat(t.boundingbox[3])]],
                raw: t
              };
            });
          }, e;
        }(k));
        var build = {
          exports: {}
        };
        var hasRequiredBuild;
        function requireBuild() {
          if (hasRequiredBuild) return build.exports;
          hasRequiredBuild = 1;
          (() => {
            var e = {
                296: (e2, t2, r2) => {
                  var o2 = /^\s+|\s+$/g,
                    n = /^[-+]0x[0-9a-f]+$/i,
                    i = /^0b[01]+$/i,
                    c = /^0o[0-7]+$/i,
                    u = parseInt,
                    s = "object" == typeof r2.g && r2.g && r2.g.Object === Object && r2.g,
                    l = "object" == typeof self && self && self.Object === Object && self,
                    a = s || l || Function("return this")(),
                    f = Object.prototype.toString,
                    p = Math.max,
                    y = Math.min,
                    b = function () {
                      return a.Date.now();
                    };
                  function d(e3) {
                    var t3 = typeof e3;
                    return !!e3 && ("object" == t3 || "function" == t3);
                  }
                  function h(e3) {
                    if ("number" == typeof e3) return e3;
                    if (function (e4) {
                      return "symbol" == typeof e4 || /* @__PURE__ */function (e5) {
                        return !!e5 && "object" == typeof e5;
                      }(e4) && "[object Symbol]" == f.call(e4);
                    }(e3)) return NaN;
                    if (d(e3)) {
                      var t3 = "function" == typeof e3.valueOf ? e3.valueOf() : e3;
                      e3 = d(t3) ? t3 + "" : t3;
                    }
                    if ("string" != typeof e3) return 0 === e3 ? e3 : +e3;
                    e3 = e3.replace(o2, "");
                    var r3 = i.test(e3);
                    return r3 || c.test(e3) ? u(e3.slice(2), r3 ? 2 : 8) : n.test(e3) ? NaN : +e3;
                  }
                  e2.exports = function (e3, t3, r3) {
                    var o3,
                      n2,
                      i2,
                      c2,
                      u2,
                      s2,
                      l2 = 0,
                      a2 = false,
                      f2 = false,
                      v = true;
                    if ("function" != typeof e3) throw new TypeError("Expected a function");
                    function m(t4) {
                      var r4 = o3,
                        i3 = n2;
                      return o3 = n2 = void 0, l2 = t4, c2 = e3.apply(i3, r4);
                    }
                    function O(e4) {
                      var r4 = e4 - s2;
                      return void 0 === s2 || r4 >= t3 || r4 < 0 || f2 && e4 - l2 >= i2;
                    }
                    function w() {
                      var e4 = b();
                      if (O(e4)) return g(e4);
                      u2 = setTimeout(w, function (e5) {
                        var r4 = t3 - (e5 - s2);
                        return f2 ? y(r4, i2 - (e5 - l2)) : r4;
                      }(e4));
                    }
                    function g(e4) {
                      return u2 = void 0, v && o3 ? m(e4) : (o3 = n2 = void 0, c2);
                    }
                    function P() {
                      var e4 = b(),
                        r4 = O(e4);
                      if (o3 = arguments, n2 = this, s2 = e4, r4) {
                        if (void 0 === u2) return function (e5) {
                          return l2 = e5, u2 = setTimeout(w, t3), a2 ? m(e5) : c2;
                        }(s2);
                        if (f2) return u2 = setTimeout(w, t3), m(s2);
                      }
                      return void 0 === u2 && (u2 = setTimeout(w, t3)), c2;
                    }
                    return t3 = h(t3) || 0, d(r3) && (a2 = !!r3.leading, i2 = (f2 = "maxWait" in r3) ? p(h(r3.maxWait) || 0, t3) : i2, v = "trailing" in r3 ? !!r3.trailing : v), P.cancel = function () {
                      void 0 !== u2 && clearTimeout(u2), l2 = 0, o3 = s2 = n2 = u2 = void 0;
                    }, P.flush = function () {
                      return void 0 === u2 ? c2 : g(b());
                    }, P;
                  };
                },
                96: (e2, t2, r2) => {
                  var o2 = "Expected a function",
                    n = NaN,
                    i = "[object Symbol]",
                    c = /^\s+|\s+$/g,
                    u = /^[-+]0x[0-9a-f]+$/i,
                    s = /^0b[01]+$/i,
                    l = /^0o[0-7]+$/i,
                    a = parseInt,
                    f = "object" == typeof r2.g && r2.g && r2.g.Object === Object && r2.g,
                    p = "object" == typeof self && self && self.Object === Object && self,
                    y = f || p || Function("return this")(),
                    b = Object.prototype.toString,
                    d = Math.max,
                    h = Math.min,
                    v = function () {
                      return y.Date.now();
                    };
                  function m(e3) {
                    var t3 = typeof e3;
                    return !!e3 && ("object" == t3 || "function" == t3);
                  }
                  function O(e3) {
                    if ("number" == typeof e3) return e3;
                    if (function (e4) {
                      return "symbol" == typeof e4 || /* @__PURE__ */function (e5) {
                        return !!e5 && "object" == typeof e5;
                      }(e4) && b.call(e4) == i;
                    }(e3)) return n;
                    if (m(e3)) {
                      var t3 = "function" == typeof e3.valueOf ? e3.valueOf() : e3;
                      e3 = m(t3) ? t3 + "" : t3;
                    }
                    if ("string" != typeof e3) return 0 === e3 ? e3 : +e3;
                    e3 = e3.replace(c, "");
                    var r3 = s.test(e3);
                    return r3 || l.test(e3) ? a(e3.slice(2), r3 ? 2 : 8) : u.test(e3) ? n : +e3;
                  }
                  e2.exports = function (e3, t3, r3) {
                    var n2 = true,
                      i2 = true;
                    if ("function" != typeof e3) throw new TypeError(o2);
                    return m(r3) && (n2 = "leading" in r3 ? !!r3.leading : n2, i2 = "trailing" in r3 ? !!r3.trailing : i2), function (e4, t4, r4) {
                      var n3,
                        i3,
                        c2,
                        u2,
                        s2,
                        l2,
                        a2 = 0,
                        f2 = false,
                        p2 = false,
                        y2 = true;
                      if ("function" != typeof e4) throw new TypeError(o2);
                      function b2(t5) {
                        var r5 = n3,
                          o3 = i3;
                        return n3 = i3 = void 0, a2 = t5, u2 = e4.apply(o3, r5);
                      }
                      function w(e5) {
                        var r5 = e5 - l2;
                        return void 0 === l2 || r5 >= t4 || r5 < 0 || p2 && e5 - a2 >= c2;
                      }
                      function g() {
                        var e5 = v();
                        if (w(e5)) return P(e5);
                        s2 = setTimeout(g, function (e6) {
                          var r5 = t4 - (e6 - l2);
                          return p2 ? h(r5, c2 - (e6 - a2)) : r5;
                        }(e5));
                      }
                      function P(e5) {
                        return s2 = void 0, y2 && n3 ? b2(e5) : (n3 = i3 = void 0, u2);
                      }
                      function j() {
                        var e5 = v(),
                          r5 = w(e5);
                        if (n3 = arguments, i3 = this, l2 = e5, r5) {
                          if (void 0 === s2) return function (e6) {
                            return a2 = e6, s2 = setTimeout(g, t4), f2 ? b2(e6) : u2;
                          }(l2);
                          if (p2) return s2 = setTimeout(g, t4), b2(l2);
                        }
                        return void 0 === s2 && (s2 = setTimeout(g, t4)), u2;
                      }
                      return t4 = O(t4) || 0, m(r4) && (f2 = !!r4.leading, c2 = (p2 = "maxWait" in r4) ? d(O(r4.maxWait) || 0, t4) : c2, y2 = "trailing" in r4 ? !!r4.trailing : y2), j.cancel = function () {
                        void 0 !== s2 && clearTimeout(s2), a2 = 0, n3 = l2 = i3 = s2 = void 0;
                      }, j.flush = function () {
                        return void 0 === s2 ? u2 : P(v());
                      }, j;
                    }(e3, t3, {
                      leading: n2,
                      maxWait: t3,
                      trailing: i2
                    });
                  };
                },
                703: (e2, t2, r2) => {
                  var o2 = r2(414);
                  function n() {}
                  function i() {}
                  i.resetWarningCache = n, e2.exports = function () {
                    function e3(e4, t4, r4, n2, i2, c) {
                      if (c !== o2) {
                        var u = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                        throw u.name = "Invariant Violation", u;
                      }
                    }
                    function t3() {
                      return e3;
                    }
                    e3.isRequired = e3;
                    var r3 = {
                      array: e3,
                      bigint: e3,
                      bool: e3,
                      func: e3,
                      number: e3,
                      object: e3,
                      string: e3,
                      symbol: e3,
                      any: e3,
                      arrayOf: t3,
                      element: e3,
                      elementType: e3,
                      instanceOf: t3,
                      node: e3,
                      objectOf: t3,
                      oneOf: t3,
                      oneOfType: t3,
                      shape: t3,
                      exact: t3,
                      checkPropTypes: i,
                      resetWarningCache: n
                    };
                    return r3.PropTypes = r3, r3;
                  };
                },
                697: (e2, t2, r2) => {
                  e2.exports = r2(703)();
                },
                414: e2 => {
                  e2.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
                }
              },
              t = {};
            function r(o2) {
              var n = t[o2];
              if (void 0 !== n) return n.exports;
              var i = t[o2] = {
                exports: {}
              };
              return e[o2](i, i.exports, r), i.exports;
            }
            r.n = e2 => {
              var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
              return r.d(t2, {
                a: t2
              }), t2;
            }, r.d = (e2, t2) => {
              for (var o2 in t2) r.o(t2, o2) && !r.o(e2, o2) && Object.defineProperty(e2, o2, {
                enumerable: true,
                get: t2[o2]
              });
            }, r.g = function () {
              if ("object" == typeof globalThis) return globalThis;
              try {
                return this || new Function("return this")();
              } catch (e2) {
                if ("object" == typeof window) return window;
              }
            }(), r.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r.r = e2 => {
              "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, {
                value: "Module"
              }), Object.defineProperty(e2, "__esModule", {
                value: true
              });
            };
            var o = {};
            (() => {
              r.r(o), r.d(o, {
                LazyLoadComponent: () => Y,
                LazyLoadImage: () => ne,
                trackWindowScroll: () => D
              });
              const e2 = requireReact();
              var t2 = r.n(e2),
                n = r(697);
              function i() {
                return "undefined" != typeof window && "IntersectionObserver" in window && "isIntersecting" in window.IntersectionObserverEntry.prototype;
              }
              function c(e3) {
                return c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e4) {
                  return typeof e4;
                } : function (e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, c(e3);
              }
              function u(e3, t3) {
                var r2 = Object.keys(e3);
                if (Object.getOwnPropertySymbols) {
                  var o2 = Object.getOwnPropertySymbols(e3);
                  t3 && (o2 = o2.filter(function (t4) {
                    return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
                  })), r2.push.apply(r2, o2);
                }
                return r2;
              }
              function s(e3, t3, r2) {
                return (t3 = a(t3)) in e3 ? Object.defineProperty(e3, t3, {
                  value: r2,
                  enumerable: true,
                  configurable: true,
                  writable: true
                }) : e3[t3] = r2, e3;
              }
              function l(e3, t3) {
                for (var r2 = 0; r2 < t3.length; r2++) {
                  var o2 = t3[r2];
                  o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e3, a(o2.key), o2);
                }
              }
              function a(e3) {
                var t3 = function (e4, t4) {
                  if ("object" !== c(e4) || null === e4) return e4;
                  var r2 = e4[Symbol.toPrimitive];
                  if (void 0 !== r2) {
                    var o2 = r2.call(e4, "string");
                    if ("object" !== c(o2)) return o2;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e4);
                }(e3);
                return "symbol" === c(t3) ? t3 : String(t3);
              }
              function f(e3, t3) {
                return f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e4, t4) {
                  return e4.__proto__ = t4, e4;
                }, f(e3, t3);
              }
              function p(e3) {
                return p = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e4) {
                  return e4.__proto__ || Object.getPrototypeOf(e4);
                }, p(e3);
              }
              var y = function (e3) {
                  e3.forEach(function (e4) {
                    e4.isIntersecting && e4.target.onVisible();
                  });
                },
                b = {},
                d = function (e3) {
                  !function (e4, t3) {
                    if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
                    e4.prototype = Object.create(t3 && t3.prototype, {
                      constructor: {
                        value: e4,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(e4, "prototype", {
                      writable: false
                    }), t3 && f(e4, t3);
                  }(h2, e3);
                  var r2,
                    o2,
                    n2,
                    a2,
                    d2 = (n2 = h2, a2 = function () {
                      if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                      if (Reflect.construct.sham) return false;
                      if ("function" == typeof Proxy) return true;
                      try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), true;
                      } catch (e4) {
                        return false;
                      }
                    }(), function () {
                      var e4,
                        t3 = p(n2);
                      if (a2) {
                        var r3 = p(this).constructor;
                        e4 = Reflect.construct(t3, arguments, r3);
                      } else e4 = t3.apply(this, arguments);
                      return function (e5, t4) {
                        if (t4 && ("object" === c(t4) || "function" == typeof t4)) return t4;
                        if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
                        return function (e6) {
                          if (void 0 === e6) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                          return e6;
                        }(e5);
                      }(this, e4);
                    });
                  function h2(e4) {
                    var t3;
                    if (function (e5, t4) {
                      if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
                    }(this, h2), (t3 = d2.call(this, e4)).supportsObserver = !e4.scrollPosition && e4.useIntersectionObserver && i(), t3.supportsObserver) {
                      var r3 = e4.threshold;
                      t3.observer = function (e5) {
                        return b[e5] = b[e5] || new IntersectionObserver(y, {
                          rootMargin: e5 + "px"
                        }), b[e5];
                      }(r3);
                    }
                    return t3;
                  }
                  return r2 = h2, o2 = [{
                    key: "componentDidMount",
                    value: function () {
                      this.placeholder && this.observer && (this.placeholder.onVisible = this.props.onVisible, this.observer.observe(this.placeholder)), this.supportsObserver || this.updateVisibility();
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.observer && this.placeholder && this.observer.unobserve(this.placeholder);
                    }
                  }, {
                    key: "componentDidUpdate",
                    value: function () {
                      this.supportsObserver || this.updateVisibility();
                    }
                  }, {
                    key: "getPlaceholderBoundingBox",
                    value: function () {
                      var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props.scrollPosition,
                        t3 = this.placeholder.getBoundingClientRect(),
                        r3 = this.placeholder.style,
                        o3 = parseInt(r3.getPropertyValue("margin-left"), 10) || 0,
                        n3 = parseInt(r3.getPropertyValue("margin-top"), 10) || 0;
                      return {
                        bottom: e4.y + t3.bottom + n3,
                        left: e4.x + t3.left + o3,
                        right: e4.x + t3.right + o3,
                        top: e4.y + t3.top + n3
                      };
                    }
                  }, {
                    key: "isPlaceholderInViewport",
                    value: function () {
                      if ("undefined" == typeof window || !this.placeholder) return false;
                      var e4 = this.props,
                        t3 = e4.scrollPosition,
                        r3 = e4.threshold,
                        o3 = this.getPlaceholderBoundingBox(t3),
                        n3 = t3.y + window.innerHeight,
                        i2 = t3.x,
                        c2 = t3.x + window.innerWidth,
                        u2 = t3.y;
                      return Boolean(u2 - r3 <= o3.bottom && n3 + r3 >= o3.top && i2 - r3 <= o3.right && c2 + r3 >= o3.left);
                    }
                  }, {
                    key: "updateVisibility",
                    value: function () {
                      this.isPlaceholderInViewport() && this.props.onVisible();
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var e4 = this,
                        r3 = this.props,
                        o3 = r3.className,
                        n3 = r3.height,
                        i2 = r3.placeholder,
                        c2 = r3.style,
                        l2 = r3.width;
                      if (i2 && "function" != typeof i2.type) return t2().cloneElement(i2, {
                        ref: function (t3) {
                          return e4.placeholder = t3;
                        }
                      });
                      var a3 = function (e5) {
                        for (var t3 = 1; t3 < arguments.length; t3++) {
                          var r4 = null != arguments[t3] ? arguments[t3] : {};
                          t3 % 2 ? u(Object(r4), true).forEach(function (t4) {
                            s(e5, t4, r4[t4]);
                          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(r4)) : u(Object(r4)).forEach(function (t4) {
                            Object.defineProperty(e5, t4, Object.getOwnPropertyDescriptor(r4, t4));
                          });
                        }
                        return e5;
                      }({
                        display: "inline-block"
                      }, c2);
                      return void 0 !== l2 && (a3.width = l2), void 0 !== n3 && (a3.height = n3), t2().createElement("span", {
                        className: o3,
                        ref: function (t3) {
                          return e4.placeholder = t3;
                        },
                        style: a3
                      }, i2);
                    }
                  }], o2 && l(r2.prototype, o2), Object.defineProperty(r2, "prototype", {
                    writable: false
                  }), h2;
                }(t2().Component);
              d.propTypes = {
                onVisible: n.PropTypes.func.isRequired,
                className: n.PropTypes.string,
                height: n.PropTypes.oneOfType([n.PropTypes.number, n.PropTypes.string]),
                placeholder: n.PropTypes.element,
                threshold: n.PropTypes.number,
                useIntersectionObserver: n.PropTypes.bool,
                scrollPosition: n.PropTypes.shape({
                  x: n.PropTypes.number.isRequired,
                  y: n.PropTypes.number.isRequired
                }),
                width: n.PropTypes.oneOfType([n.PropTypes.number, n.PropTypes.string])
              }, d.defaultProps = {
                className: "",
                placeholder: null,
                threshold: 100,
                useIntersectionObserver: true
              };
              const h = d;
              var v = r(296),
                m = r.n(v),
                O = r(96),
                w = r.n(O),
                g = function (e3) {
                  var t3 = getComputedStyle(e3, null);
                  return t3.getPropertyValue("overflow") + t3.getPropertyValue("overflow-y") + t3.getPropertyValue("overflow-x");
                };
              const P = function (e3) {
                if (!(e3 instanceof HTMLElement)) return window;
                for (var t3 = e3; t3 && t3 instanceof HTMLElement;) {
                  if (/(scroll|auto)/.test(g(t3))) return t3;
                  t3 = t3.parentNode;
                }
                return window;
              };
              function j(e3) {
                return j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e4) {
                  return typeof e4;
                } : function (e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, j(e3);
              }
              var T = ["delayMethod", "delayTime"];
              function S() {
                return S = Object.assign ? Object.assign.bind() : function (e3) {
                  for (var t3 = 1; t3 < arguments.length; t3++) {
                    var r2 = arguments[t3];
                    for (var o2 in r2) Object.prototype.hasOwnProperty.call(r2, o2) && (e3[o2] = r2[o2]);
                  }
                  return e3;
                }, S.apply(this, arguments);
              }
              function E(e3, t3) {
                for (var r2 = 0; r2 < t3.length; r2++) {
                  var o2 = t3[r2];
                  o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e3, (n2 = function (e4, t4) {
                    if ("object" !== j(e4) || null === e4) return e4;
                    var r3 = e4[Symbol.toPrimitive];
                    if (void 0 !== r3) {
                      var o3 = r3.call(e4, "string");
                      if ("object" !== j(o3)) return o3;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return String(e4);
                  }(o2.key), "symbol" === j(n2) ? n2 : String(n2)), o2);
                }
                var n2;
              }
              function L(e3, t3) {
                return L = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e4, t4) {
                  return e4.__proto__ = t4, e4;
                }, L(e3, t3);
              }
              function _(e3, t3) {
                if (t3 && ("object" === j(t3) || "function" == typeof t3)) return t3;
                if (void 0 !== t3) throw new TypeError("Derived constructors may only return object or undefined");
                return I(e3);
              }
              function I(e3) {
                if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e3;
              }
              function x(e3) {
                return x = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e4) {
                  return e4.__proto__ || Object.getPrototypeOf(e4);
                }, x(e3);
              }
              var R = function () {
                  return "undefined" == typeof window ? 0 : window.scrollX || window.pageXOffset;
                },
                k = function () {
                  return "undefined" == typeof window ? 0 : window.scrollY || window.pageYOffset;
                };
              const D = function (e3) {
                var r2 = function (r3) {
                  !function (e4, t3) {
                    if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
                    e4.prototype = Object.create(t3 && t3.prototype, {
                      constructor: {
                        value: e4,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(e4, "prototype", {
                      writable: false
                    }), t3 && L(e4, t3);
                  }(l2, r3);
                  var o2,
                    n2,
                    c2,
                    u2,
                    s2 = (c2 = l2, u2 = function () {
                      if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                      if (Reflect.construct.sham) return false;
                      if ("function" == typeof Proxy) return true;
                      try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), true;
                      } catch (e4) {
                        return false;
                      }
                    }(), function () {
                      var e4,
                        t3 = x(c2);
                      if (u2) {
                        var r4 = x(this).constructor;
                        e4 = Reflect.construct(t3, arguments, r4);
                      } else e4 = t3.apply(this, arguments);
                      return _(this, e4);
                    });
                  function l2(e4) {
                    var r4;
                    if (function (e5, t3) {
                      if (!(e5 instanceof t3)) throw new TypeError("Cannot call a class as a function");
                    }(this, l2), (r4 = s2.call(this, e4)).useIntersectionObserver = e4.useIntersectionObserver && i(), r4.useIntersectionObserver) return _(r4);
                    var o3 = r4.onChangeScroll.bind(I(r4));
                    return "debounce" === e4.delayMethod ? r4.delayedScroll = m()(o3, e4.delayTime) : "throttle" === e4.delayMethod && (r4.delayedScroll = w()(o3, e4.delayTime)), r4.state = {
                      scrollPosition: {
                        x: R(),
                        y: k()
                      }
                    }, r4.baseComponentRef = t2().createRef(), r4;
                  }
                  return o2 = l2, (n2 = [{
                    key: "componentDidMount",
                    value: function () {
                      this.addListeners();
                    }
                  }, {
                    key: "componentWillUnmount",
                    value: function () {
                      this.removeListeners();
                    }
                  }, {
                    key: "componentDidUpdate",
                    value: function () {
                      "undefined" == typeof window || this.useIntersectionObserver || P(this.baseComponentRef.current) !== this.scrollElement && (this.removeListeners(), this.addListeners());
                    }
                  }, {
                    key: "addListeners",
                    value: function () {
                      "undefined" == typeof window || this.useIntersectionObserver || (this.scrollElement = P(this.baseComponentRef.current), this.scrollElement.addEventListener("scroll", this.delayedScroll, {
                        passive: true
                      }), window.addEventListener("resize", this.delayedScroll, {
                        passive: true
                      }), this.scrollElement !== window && window.addEventListener("scroll", this.delayedScroll, {
                        passive: true
                      }));
                    }
                  }, {
                    key: "removeListeners",
                    value: function () {
                      "undefined" == typeof window || this.useIntersectionObserver || (this.scrollElement.removeEventListener("scroll", this.delayedScroll), window.removeEventListener("resize", this.delayedScroll), this.scrollElement !== window && window.removeEventListener("scroll", this.delayedScroll));
                    }
                  }, {
                    key: "onChangeScroll",
                    value: function () {
                      this.useIntersectionObserver || this.setState({
                        scrollPosition: {
                          x: R(),
                          y: k()
                        }
                      });
                    }
                  }, {
                    key: "render",
                    value: function () {
                      var r4 = this.props,
                        o3 = (r4.delayMethod, r4.delayTime, function (e4, t3) {
                          if (null == e4) return {};
                          var r5,
                            o4,
                            n4 = function (e5, t4) {
                              if (null == e5) return {};
                              var r6,
                                o5,
                                n5 = {},
                                i3 = Object.keys(e5);
                              for (o5 = 0; o5 < i3.length; o5++) r6 = i3[o5], t4.indexOf(r6) >= 0 || (n5[r6] = e5[r6]);
                              return n5;
                            }(e4, t3);
                          if (Object.getOwnPropertySymbols) {
                            var i2 = Object.getOwnPropertySymbols(e4);
                            for (o4 = 0; o4 < i2.length; o4++) r5 = i2[o4], t3.indexOf(r5) >= 0 || Object.prototype.propertyIsEnumerable.call(e4, r5) && (n4[r5] = e4[r5]);
                          }
                          return n4;
                        }(r4, T)),
                        n3 = this.useIntersectionObserver ? null : this.state.scrollPosition;
                      return t2().createElement(e3, S({
                        forwardRef: this.baseComponentRef,
                        scrollPosition: n3
                      }, o3));
                    }
                  }]) && E(o2.prototype, n2), Object.defineProperty(o2, "prototype", {
                    writable: false
                  }), l2;
                }(t2().Component);
                return r2.propTypes = {
                  delayMethod: n.PropTypes.oneOf(["debounce", "throttle"]),
                  delayTime: n.PropTypes.number,
                  useIntersectionObserver: n.PropTypes.bool
                }, r2.defaultProps = {
                  delayMethod: "throttle",
                  delayTime: 300,
                  useIntersectionObserver: true
                }, r2;
              };
              function C(e3) {
                return C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e4) {
                  return typeof e4;
                } : function (e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, C(e3);
              }
              function B(e3, t3) {
                for (var r2 = 0; r2 < t3.length; r2++) {
                  var o2 = t3[r2];
                  o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e3, (n2 = function (e4, t4) {
                    if ("object" !== C(e4) || null === e4) return e4;
                    var r3 = e4[Symbol.toPrimitive];
                    if (void 0 !== r3) {
                      var o3 = r3.call(e4, "string");
                      if ("object" !== C(o3)) return o3;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return String(e4);
                  }(o2.key), "symbol" === C(n2) ? n2 : String(n2)), o2);
                }
                var n2;
              }
              function M(e3, t3) {
                return M = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e4, t4) {
                  return e4.__proto__ = t4, e4;
                }, M(e3, t3);
              }
              function N(e3) {
                return N = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e4) {
                  return e4.__proto__ || Object.getPrototypeOf(e4);
                }, N(e3);
              }
              var V = function (e3) {
                !function (e4, t3) {
                  if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
                  e4.prototype = Object.create(t3 && t3.prototype, {
                    constructor: {
                      value: e4,
                      writable: true,
                      configurable: true
                    }
                  }), Object.defineProperty(e4, "prototype", {
                    writable: false
                  }), t3 && M(e4, t3);
                }(u2, e3);
                var r2,
                  o2,
                  n2,
                  i2,
                  c2 = (n2 = u2, i2 = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), true;
                    } catch (e4) {
                      return false;
                    }
                  }(), function () {
                    var e4,
                      t3 = N(n2);
                    if (i2) {
                      var r3 = N(this).constructor;
                      e4 = Reflect.construct(t3, arguments, r3);
                    } else e4 = t3.apply(this, arguments);
                    return function (e5, t4) {
                      if (t4 && ("object" === C(t4) || "function" == typeof t4)) return t4;
                      if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
                      return function (e6) {
                        if (void 0 === e6) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e6;
                      }(e5);
                    }(this, e4);
                  });
                function u2(e4) {
                  return function (e5, t3) {
                    if (!(e5 instanceof t3)) throw new TypeError("Cannot call a class as a function");
                  }(this, u2), c2.call(this, e4);
                }
                return r2 = u2, (o2 = [{
                  key: "render",
                  value: function () {
                    return t2().createElement(h, this.props);
                  }
                }]) && B(r2.prototype, o2), Object.defineProperty(r2, "prototype", {
                  writable: false
                }), u2;
              }(t2().Component);
              const W = D(V);
              function z(e3) {
                return z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e4) {
                  return typeof e4;
                } : function (e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, z(e3);
              }
              function $(e3, t3) {
                for (var r2 = 0; r2 < t3.length; r2++) {
                  var o2 = t3[r2];
                  o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e3, (n2 = function (e4, t4) {
                    if ("object" !== z(e4) || null === e4) return e4;
                    var r3 = e4[Symbol.toPrimitive];
                    if (void 0 !== r3) {
                      var o3 = r3.call(e4, "string");
                      if ("object" !== z(o3)) return o3;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return String(e4);
                  }(o2.key), "symbol" === z(n2) ? n2 : String(n2)), o2);
                }
                var n2;
              }
              function U(e3, t3) {
                return U = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e4, t4) {
                  return e4.__proto__ = t4, e4;
                }, U(e3, t3);
              }
              function F(e3) {
                if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e3;
              }
              function q(e3) {
                return q = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e4) {
                  return e4.__proto__ || Object.getPrototypeOf(e4);
                }, q(e3);
              }
              var H = function (e3) {
                !function (e4, t3) {
                  if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
                  e4.prototype = Object.create(t3 && t3.prototype, {
                    constructor: {
                      value: e4,
                      writable: true,
                      configurable: true
                    }
                  }), Object.defineProperty(e4, "prototype", {
                    writable: false
                  }), t3 && U(e4, t3);
                }(s2, e3);
                var r2,
                  o2,
                  n2,
                  c2,
                  u2 = (n2 = s2, c2 = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), true;
                    } catch (e4) {
                      return false;
                    }
                  }(), function () {
                    var e4,
                      t3 = q(n2);
                    if (c2) {
                      var r3 = q(this).constructor;
                      e4 = Reflect.construct(t3, arguments, r3);
                    } else e4 = t3.apply(this, arguments);
                    return function (e5, t4) {
                      if (t4 && ("object" === z(t4) || "function" == typeof t4)) return t4;
                      if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
                      return F(e5);
                    }(this, e4);
                  });
                function s2(e4) {
                  var t3;
                  !function (e5, t4) {
                    if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
                  }(this, s2), t3 = u2.call(this, e4);
                  var r3 = e4.afterLoad,
                    o3 = e4.beforeLoad,
                    n3 = e4.scrollPosition,
                    i2 = e4.visibleByDefault;
                  return t3.state = {
                    visible: i2
                  }, i2 && (o3(), r3()), t3.onVisible = t3.onVisible.bind(F(t3)), t3.isScrollTracked = Boolean(n3 && Number.isFinite(n3.x) && n3.x >= 0 && Number.isFinite(n3.y) && n3.y >= 0), t3;
                }
                return r2 = s2, (o2 = [{
                  key: "componentDidUpdate",
                  value: function (e4, t3) {
                    t3.visible !== this.state.visible && this.props.afterLoad();
                  }
                }, {
                  key: "onVisible",
                  value: function () {
                    this.props.beforeLoad(), this.setState({
                      visible: true
                    });
                  }
                }, {
                  key: "render",
                  value: function () {
                    if (this.state.visible) return this.props.children;
                    var e4 = this.props,
                      r3 = e4.className,
                      o3 = e4.delayMethod,
                      n3 = e4.delayTime,
                      c3 = e4.height,
                      u3 = e4.placeholder,
                      s3 = e4.scrollPosition,
                      l2 = e4.style,
                      a2 = e4.threshold,
                      f2 = e4.useIntersectionObserver,
                      p2 = e4.width;
                    return this.isScrollTracked || f2 && i() ? t2().createElement(h, {
                      className: r3,
                      height: c3,
                      onVisible: this.onVisible,
                      placeholder: u3,
                      scrollPosition: s3,
                      style: l2,
                      threshold: a2,
                      useIntersectionObserver: f2,
                      width: p2
                    }) : t2().createElement(W, {
                      className: r3,
                      delayMethod: o3,
                      delayTime: n3,
                      height: c3,
                      onVisible: this.onVisible,
                      placeholder: u3,
                      style: l2,
                      threshold: a2,
                      width: p2
                    });
                  }
                }]) && $(r2.prototype, o2), Object.defineProperty(r2, "prototype", {
                  writable: false
                }), s2;
              }(t2().Component);
              H.propTypes = {
                afterLoad: n.PropTypes.func,
                beforeLoad: n.PropTypes.func,
                useIntersectionObserver: n.PropTypes.bool,
                visibleByDefault: n.PropTypes.bool
              }, H.defaultProps = {
                afterLoad: function () {
                  return {};
                },
                beforeLoad: function () {
                  return {};
                },
                useIntersectionObserver: true,
                visibleByDefault: false
              };
              const Y = H;
              function X(e3) {
                return X = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e4) {
                  return typeof e4;
                } : function (e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, X(e3);
              }
              var A = ["afterLoad", "beforeLoad", "delayMethod", "delayTime", "effect", "placeholder", "placeholderSrc", "scrollPosition", "threshold", "useIntersectionObserver", "visibleByDefault", "wrapperClassName", "wrapperProps"];
              function G(e3, t3) {
                var r2 = Object.keys(e3);
                if (Object.getOwnPropertySymbols) {
                  var o2 = Object.getOwnPropertySymbols(e3);
                  t3 && (o2 = o2.filter(function (t4) {
                    return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
                  })), r2.push.apply(r2, o2);
                }
                return r2;
              }
              function J(e3) {
                for (var t3 = 1; t3 < arguments.length; t3++) {
                  var r2 = null != arguments[t3] ? arguments[t3] : {};
                  t3 % 2 ? G(Object(r2), true).forEach(function (t4) {
                    K(e3, t4, r2[t4]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r2)) : G(Object(r2)).forEach(function (t4) {
                    Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r2, t4));
                  });
                }
                return e3;
              }
              function K(e3, t3, r2) {
                return (t3 = ee(t3)) in e3 ? Object.defineProperty(e3, t3, {
                  value: r2,
                  enumerable: true,
                  configurable: true,
                  writable: true
                }) : e3[t3] = r2, e3;
              }
              function Q() {
                return Q = Object.assign ? Object.assign.bind() : function (e3) {
                  for (var t3 = 1; t3 < arguments.length; t3++) {
                    var r2 = arguments[t3];
                    for (var o2 in r2) Object.prototype.hasOwnProperty.call(r2, o2) && (e3[o2] = r2[o2]);
                  }
                  return e3;
                }, Q.apply(this, arguments);
              }
              function Z(e3, t3) {
                for (var r2 = 0; r2 < t3.length; r2++) {
                  var o2 = t3[r2];
                  o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e3, ee(o2.key), o2);
                }
              }
              function ee(e3) {
                var t3 = function (e4, t4) {
                  if ("object" !== X(e4) || null === e4) return e4;
                  var r2 = e4[Symbol.toPrimitive];
                  if (void 0 !== r2) {
                    var o2 = r2.call(e4, "string");
                    if ("object" !== X(o2)) return o2;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e4);
                }(e3);
                return "symbol" === X(t3) ? t3 : String(t3);
              }
              function te(e3, t3) {
                return te = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e4, t4) {
                  return e4.__proto__ = t4, e4;
                }, te(e3, t3);
              }
              function re(e3) {
                return re = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e4) {
                  return e4.__proto__ || Object.getPrototypeOf(e4);
                }, re(e3);
              }
              var oe = function (e3) {
                !function (e4, t3) {
                  if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
                  e4.prototype = Object.create(t3 && t3.prototype, {
                    constructor: {
                      value: e4,
                      writable: true,
                      configurable: true
                    }
                  }), Object.defineProperty(e4, "prototype", {
                    writable: false
                  }), t3 && te(e4, t3);
                }(u2, e3);
                var r2,
                  o2,
                  n2,
                  i2,
                  c2 = (n2 = u2, i2 = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if ("function" == typeof Proxy) return true;
                    try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), true;
                    } catch (e4) {
                      return false;
                    }
                  }(), function () {
                    var e4,
                      t3 = re(n2);
                    if (i2) {
                      var r3 = re(this).constructor;
                      e4 = Reflect.construct(t3, arguments, r3);
                    } else e4 = t3.apply(this, arguments);
                    return function (e5, t4) {
                      if (t4 && ("object" === X(t4) || "function" == typeof t4)) return t4;
                      if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
                      return function (e6) {
                        if (void 0 === e6) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e6;
                      }(e5);
                    }(this, e4);
                  });
                function u2(e4) {
                  var t3;
                  return function (e5, t4) {
                    if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
                  }(this, u2), (t3 = c2.call(this, e4)).state = {
                    loaded: false
                  }, t3;
                }
                return r2 = u2, (o2 = [{
                  key: "onImageLoad",
                  value: function () {
                    var e4 = this;
                    return this.state.loaded ? null : function (t3) {
                      e4.props.onLoad(t3), e4.props.afterLoad(), e4.setState({
                        loaded: true
                      });
                    };
                  }
                }, {
                  key: "getImg",
                  value: function () {
                    var e4 = this.props,
                      r3 = (e4.afterLoad, e4.beforeLoad, e4.delayMethod, e4.delayTime, e4.effect, e4.placeholder, e4.placeholderSrc, e4.scrollPosition, e4.threshold, e4.useIntersectionObserver, e4.visibleByDefault, e4.wrapperClassName, e4.wrapperProps, function (e5, t3) {
                        if (null == e5) return {};
                        var r4,
                          o3,
                          n3 = function (e6, t4) {
                            if (null == e6) return {};
                            var r5,
                              o4,
                              n4 = {},
                              i4 = Object.keys(e6);
                            for (o4 = 0; o4 < i4.length; o4++) r5 = i4[o4], t4.indexOf(r5) >= 0 || (n4[r5] = e6[r5]);
                            return n4;
                          }(e5, t3);
                        if (Object.getOwnPropertySymbols) {
                          var i3 = Object.getOwnPropertySymbols(e5);
                          for (o3 = 0; o3 < i3.length; o3++) r4 = i3[o3], t3.indexOf(r4) >= 0 || Object.prototype.propertyIsEnumerable.call(e5, r4) && (n3[r4] = e5[r4]);
                        }
                        return n3;
                      }(e4, A));
                    return t2().createElement("img", Q({}, r3, {
                      onLoad: this.onImageLoad()
                    }));
                  }
                }, {
                  key: "getLazyLoadImage",
                  value: function () {
                    var e4 = this.props,
                      r3 = e4.beforeLoad,
                      o3 = e4.className,
                      n3 = e4.delayMethod,
                      i3 = e4.delayTime,
                      c3 = e4.height,
                      u3 = e4.placeholder,
                      s2 = e4.scrollPosition,
                      l2 = e4.style,
                      a2 = e4.threshold,
                      f2 = e4.useIntersectionObserver,
                      p2 = e4.visibleByDefault,
                      y2 = e4.width;
                    return t2().createElement(Y, {
                      beforeLoad: r3,
                      className: o3,
                      delayMethod: n3,
                      delayTime: i3,
                      height: c3,
                      placeholder: u3,
                      scrollPosition: s2,
                      style: l2,
                      threshold: a2,
                      useIntersectionObserver: f2,
                      visibleByDefault: p2,
                      width: y2
                    }, this.getImg());
                  }
                }, {
                  key: "getWrappedLazyLoadImage",
                  value: function (e4) {
                    var r3 = this.props,
                      o3 = r3.effect,
                      n3 = r3.height,
                      i3 = r3.placeholderSrc,
                      c3 = r3.width,
                      u3 = r3.wrapperClassName,
                      s2 = r3.wrapperProps,
                      l2 = this.state.loaded,
                      a2 = l2 ? " lazy-load-image-loaded" : "",
                      f2 = l2 || !i3 ? {} : {
                        backgroundImage: "url(".concat(i3, ")"),
                        backgroundSize: "100% 100%"
                      };
                    return t2().createElement("span", Q({
                      className: u3 + " lazy-load-image-background " + o3 + a2,
                      style: J(J({}, f2), {}, {
                        color: "transparent",
                        display: "inline-block",
                        height: n3,
                        width: c3
                      })
                    }, s2), e4);
                  }
                }, {
                  key: "render",
                  value: function () {
                    var e4 = this.props,
                      t3 = e4.effect,
                      r3 = e4.placeholderSrc,
                      o3 = e4.visibleByDefault,
                      n3 = e4.wrapperClassName,
                      i3 = e4.wrapperProps,
                      c3 = this.getLazyLoadImage();
                    return (t3 || r3) && !o3 || n3 || i3 ? this.getWrappedLazyLoadImage(c3) : c3;
                  }
                }]) && Z(r2.prototype, o2), Object.defineProperty(r2, "prototype", {
                  writable: false
                }), u2;
              }(t2().Component);
              oe.propTypes = {
                onLoad: n.PropTypes.func,
                afterLoad: n.PropTypes.func,
                beforeLoad: n.PropTypes.func,
                delayMethod: n.PropTypes.string,
                delayTime: n.PropTypes.number,
                effect: n.PropTypes.string,
                placeholderSrc: n.PropTypes.string,
                threshold: n.PropTypes.number,
                useIntersectionObserver: n.PropTypes.bool,
                visibleByDefault: n.PropTypes.bool,
                wrapperClassName: n.PropTypes.string,
                wrapperProps: n.PropTypes.object
              }, oe.defaultProps = {
                onLoad: function () {},
                afterLoad: function () {
                  return {};
                },
                beforeLoad: function () {
                  return {};
                },
                delayMethod: "throttle",
                delayTime: 300,
                effect: "",
                placeholderSrc: null,
                threshold: 100,
                useIntersectionObserver: true,
                visibleByDefault: false,
                wrapperClassName: ""
              };
              const ne = oe;
            })(), build.exports = o;
          })();
          return build.exports;
        }
        var buildExports = exports("av", requireBuild());
        function _typeof$1(obj) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$1 = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$1 = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$1(obj);
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          return Constructor;
        }
        function _possibleConstructorReturn(self, call) {
          if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
            return call;
          }
          return _assertThisInitialized(self);
        }
        function _getPrototypeOf(o) {
          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          };
          return _getPrototypeOf(o);
        }
        function _assertThisInitialized(self) {
          if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              writable: true,
              configurable: true
            }
          });
          if (superClass) _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        function _defineProperty$3(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var PersistGate = exports("X", /* @__PURE__ */function (_PureComponent) {
          _inherits(PersistGate2, _PureComponent);
          function PersistGate2() {
            var _getPrototypeOf2;
            var _this;
            _classCallCheck(this, PersistGate2);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PersistGate2)).call.apply(_getPrototypeOf2, [this].concat(args)));
            _defineProperty$3(_assertThisInitialized(_this), "state", {
              bootstrapped: false
            });
            _defineProperty$3(_assertThisInitialized(_this), "_unsubscribe", void 0);
            _defineProperty$3(_assertThisInitialized(_this), "handlePersistorState", function () {
              var persistor = _this.props.persistor;
              var _persistor$getState = persistor.getState(),
                bootstrapped = _persistor$getState.bootstrapped;
              if (bootstrapped) {
                if (_this.props.onBeforeLift) {
                  Promise.resolve(_this.props.onBeforeLift()).finally(function () {
                    return _this.setState({
                      bootstrapped: true
                    });
                  });
                } else {
                  _this.setState({
                    bootstrapped: true
                  });
                }
                _this._unsubscribe && _this._unsubscribe();
              }
            });
            return _this;
          }
          _createClass(PersistGate2, [{
            key: "componentDidMount",
            value: function componentDidMount() {
              this._unsubscribe = this.props.persistor.subscribe(this.handlePersistorState);
              this.handlePersistorState();
            }
          }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
              this._unsubscribe && this._unsubscribe();
            }
          }, {
            key: "render",
            value: function render() {
              if (typeof this.props.children === "function") {
                return this.props.children(this.state.bootstrapped);
              }
              return this.state.bootstrapped ? this.props.children : this.props.loading;
            }
          }]);
          return PersistGate2;
        }(reactExports.PureComponent));
        _defineProperty$3(PersistGate, "defaultProps", {
          children: null,
          loading: null
        });
        var KEY_PREFIX = 'persist:';
        var FLUSH = exports("N", 'persist/FLUSH');
        var REHYDRATE = exports("O", 'persist/REHYDRATE');
        var PAUSE = exports("P", 'persist/PAUSE');
        var PERSIST = exports("Q", 'persist/PERSIST');
        var PURGE = exports("S", 'persist/PURGE');
        var REGISTER = exports("T", 'persist/REGISTER');
        var DEFAULT_VERSION = -1;
        function _typeof(obj) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof(obj);
        }
        function ownKeys$2(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$2(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$2(source, true).forEach(function (key) {
                _defineProperty$2(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$2(source).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function _defineProperty$2(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function autoMergeLevel1(inboundState, originalState, reducedState, _ref) {
          _ref.debug;
          var newState = _objectSpread$2({}, reducedState);
          if (inboundState && _typeof(inboundState) === "object") {
            Object.keys(inboundState).forEach(function (key) {
              if (key === "_persist") return;
              if (originalState[key] !== reducedState[key]) {
                return;
              }
              newState[key] = inboundState[key];
            });
          }
          return newState;
        }
        function createPersistoid(config) {
          var blacklist = config.blacklist || null;
          var whitelist = config.whitelist || null;
          var transforms = config.transforms || [];
          var throttle = config.throttle || 0;
          var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
          var storage = config.storage;
          var serialize;
          if (config.serialize === false) {
            serialize = function serialize2(x) {
              return x;
            };
          } else if (typeof config.serialize === "function") {
            serialize = config.serialize;
          } else {
            serialize = defaultSerialize;
          }
          var writeFailHandler = config.writeFailHandler || null;
          var lastState = {};
          var stagedState = {};
          var keysToProcess = [];
          var timeIterator = null;
          var writePromise = null;
          var update = function update2(state) {
            Object.keys(state).forEach(function (key) {
              if (!passWhitelistBlacklist(key)) return;
              if (lastState[key] === state[key]) return;
              if (keysToProcess.indexOf(key) !== -1) return;
              keysToProcess.push(key);
            });
            Object.keys(lastState).forEach(function (key) {
              if (state[key] === void 0 && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== void 0) {
                keysToProcess.push(key);
              }
            });
            if (timeIterator === null) {
              timeIterator = setInterval(processNextKey, throttle);
            }
            lastState = state;
          };
          function processNextKey() {
            if (keysToProcess.length === 0) {
              if (timeIterator) clearInterval(timeIterator);
              timeIterator = null;
              return;
            }
            var key = keysToProcess.shift();
            var endState = transforms.reduce(function (subState, transformer) {
              return transformer.in(subState, key, lastState);
            }, lastState[key]);
            if (endState !== void 0) {
              try {
                stagedState[key] = serialize(endState);
              } catch (err) {
                console.error("redux-persist/createPersistoid: error serializing state", err);
              }
            } else {
              delete stagedState[key];
            }
            if (keysToProcess.length === 0) {
              writeStagedState();
            }
          }
          function writeStagedState() {
            Object.keys(stagedState).forEach(function (key) {
              if (lastState[key] === void 0) {
                delete stagedState[key];
              }
            });
            writePromise = storage.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);
          }
          function passWhitelistBlacklist(key) {
            if (whitelist && whitelist.indexOf(key) === -1 && key !== "_persist") return false;
            if (blacklist && blacklist.indexOf(key) !== -1) return false;
            return true;
          }
          function onWriteFail(err) {
            if (writeFailHandler) writeFailHandler(err);
          }
          var flush = function flush2() {
            while (keysToProcess.length !== 0) {
              processNextKey();
            }
            return writePromise || Promise.resolve();
          };
          return {
            update,
            flush
          };
        }
        function defaultSerialize(data) {
          return JSON.stringify(data);
        }
        function getStoredState(config) {
          var transforms = config.transforms || [];
          var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
          var storage = config.storage;
          config.debug;
          var deserialize;
          if (config.deserialize === false) {
            deserialize = function deserialize2(x) {
              return x;
            };
          } else if (typeof config.deserialize === "function") {
            deserialize = config.deserialize;
          } else {
            deserialize = defaultDeserialize;
          }
          return storage.getItem(storageKey).then(function (serialized) {
            if (!serialized) return void 0;else {
              try {
                var state = {};
                var rawState = deserialize(serialized);
                Object.keys(rawState).forEach(function (key) {
                  state[key] = transforms.reduceRight(function (subState, transformer) {
                    return transformer.out(subState, key, rawState);
                  }, deserialize(rawState[key]));
                });
                return state;
              } catch (err) {
                throw err;
              }
            }
          });
        }
        function defaultDeserialize(serial) {
          return JSON.parse(serial);
        }
        function purgeStoredState(config) {
          var storage = config.storage;
          var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
          return storage.removeItem(storageKey, warnIfRemoveError);
        }
        function warnIfRemoveError(err) {}
        function ownKeys$1(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$1(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$1(source, true).forEach(function (key) {
                _defineProperty$1(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$1(source).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function _defineProperty$1(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _objectWithoutProperties(source, excluded) {
          if (source == null) return {};
          var target = _objectWithoutPropertiesLoose(source, excluded);
          var key, i;
          if (Object.getOwnPropertySymbols) {
            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
            for (i = 0; i < sourceSymbolKeys.length; i++) {
              key = sourceSymbolKeys[i];
              if (excluded.indexOf(key) >= 0) continue;
              if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
              target[key] = source[key];
            }
          }
          return target;
        }
        function _objectWithoutPropertiesLoose(source, excluded) {
          if (source == null) return {};
          var target = {};
          var sourceKeys = Object.keys(source);
          var key, i;
          for (i = 0; i < sourceKeys.length; i++) {
            key = sourceKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            target[key] = source[key];
          }
          return target;
        }
        var DEFAULT_TIMEOUT = 5e3;
        function persistReducer(config, baseReducer) {
          var version = config.version !== void 0 ? config.version : DEFAULT_VERSION;
          config.debug || false;
          var stateReconciler = config.stateReconciler === void 0 ? autoMergeLevel1 : config.stateReconciler;
          var getStoredState$1 = config.getStoredState || getStoredState;
          var timeout = config.timeout !== void 0 ? config.timeout : DEFAULT_TIMEOUT;
          var _persistoid = null;
          var _purge = false;
          var _paused = true;
          var conditionalUpdate = function conditionalUpdate2(state) {
            state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state);
            return state;
          };
          return function (state, action) {
            var _ref = state || {},
              _persist = _ref._persist,
              rest = _objectWithoutProperties(_ref, ["_persist"]);
            var restState = rest;
            if (action.type === PERSIST) {
              var _sealed = false;
              var _rehydrate = function _rehydrate2(payload, err) {
                if (!_sealed) {
                  action.rehydrate(config.key, payload, err);
                  _sealed = true;
                }
              };
              timeout && setTimeout(function () {
                !_sealed && _rehydrate(void 0, new Error('redux-persist: persist timed out for persist key "'.concat(config.key, '"')));
              }, timeout);
              _paused = false;
              if (!_persistoid) _persistoid = createPersistoid(config);
              if (_persist) {
                return _objectSpread$1({}, baseReducer(restState, action), {
                  _persist
                });
              }
              if (typeof action.rehydrate !== "function" || typeof action.register !== "function") throw new Error("redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.");
              action.register(config.key);
              getStoredState$1(config).then(function (restoredState) {
                var migrate = config.migrate || function (s, v) {
                  return Promise.resolve(s);
                };
                migrate(restoredState, version).then(function (migratedState) {
                  _rehydrate(migratedState);
                }, function (migrateErr) {
                  _rehydrate(void 0, migrateErr);
                });
              }, function (err) {
                _rehydrate(void 0, err);
              });
              return _objectSpread$1({}, baseReducer(restState, action), {
                _persist: {
                  version,
                  rehydrated: false
                }
              });
            } else if (action.type === PURGE) {
              _purge = true;
              action.result(purgeStoredState(config));
              return _objectSpread$1({}, baseReducer(restState, action), {
                _persist
              });
            } else if (action.type === FLUSH) {
              action.result(_persistoid && _persistoid.flush());
              return _objectSpread$1({}, baseReducer(restState, action), {
                _persist
              });
            } else if (action.type === PAUSE) {
              _paused = true;
            } else if (action.type === REHYDRATE) {
              if (_purge) return _objectSpread$1({}, restState, {
                _persist: _objectSpread$1({}, _persist, {
                  rehydrated: true
                })
                // @NOTE if key does not match, will continue to default else below
              });
              if (action.key === config.key) {
                var reducedState = baseReducer(restState, action);
                var inboundState = action.payload;
                var reconciledRest = stateReconciler !== false && inboundState !== void 0 ? stateReconciler(inboundState, state, reducedState, config) : reducedState;
                var _newState = _objectSpread$1({}, reconciledRest, {
                  _persist: _objectSpread$1({}, _persist, {
                    rehydrated: true
                  })
                });
                return conditionalUpdate(_newState);
              }
            }
            if (!_persist) return baseReducer(state, action);
            var newState = baseReducer(restState, action);
            if (newState === restState) return state;
            return conditionalUpdate(_objectSpread$1({}, newState, {
              _persist
            }));
          };
        }
        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
        }
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }
        function _iterableToArray(iter) {
          if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
        }
        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          }
        }
        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys(source, true).forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys(source).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var initialState$1 = {
          registry: [],
          bootstrapped: false
        };
        var persistorReducer = function persistorReducer2() {
          var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState$1;
          var action = arguments.length > 1 ? arguments[1] : void 0;
          switch (action.type) {
            case REGISTER:
              return _objectSpread({}, state, {
                registry: [].concat(_toConsumableArray(state.registry), [action.key])
              });
            case REHYDRATE:
              var firstIndex = state.registry.indexOf(action.key);
              var registry = _toConsumableArray(state.registry);
              registry.splice(firstIndex, 1);
              return _objectSpread({}, state, {
                registry,
                bootstrapped: registry.length === 0
              });
            default:
              return state;
          }
        };
        function persistStore(store, options, cb) {
          var _pStore = createStore(persistorReducer, initialState$1, void 0);
          var register = function register2(key) {
            _pStore.dispatch({
              type: REGISTER,
              key
            });
          };
          var rehydrate = function rehydrate2(key, payload, err) {
            var rehydrateAction = {
              type: REHYDRATE,
              payload,
              err,
              key
              // dispatch to `store` to rehydrate and `persistor` to track result
            };
            store.dispatch(rehydrateAction);
            _pStore.dispatch(rehydrateAction);
          };
          var persistor = _objectSpread({}, _pStore, {
            purge: function purge() {
              var results = [];
              store.dispatch({
                type: PURGE,
                result: function result(purgeResult) {
                  results.push(purgeResult);
                }
              });
              return Promise.all(results);
            },
            flush: function flush() {
              var results = [];
              store.dispatch({
                type: FLUSH,
                result: function result(flushResult) {
                  results.push(flushResult);
                }
              });
              return Promise.all(results);
            },
            pause: function pause() {
              store.dispatch({
                type: PAUSE
              });
            },
            persist: function persist() {
              store.dispatch({
                type: PERSIST,
                register,
                rehydrate
              });
            }
          });
          {
            persistor.persist();
          }
          return persistor;
        }
        var storage$1 = {};
        var createWebStorage = {};
        var getStorage = {};
        var hasRequiredGetStorage;
        function requireGetStorage() {
          if (hasRequiredGetStorage) return getStorage;
          hasRequiredGetStorage = 1;
          getStorage.__esModule = true;
          getStorage.default = getStorage$1;
          function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function noop() {}
          var noopStorage = {
            getItem: noop,
            setItem: noop,
            removeItem: noop
          };
          function hasStorage(storageType) {
            if ((typeof self === "undefined" ? "undefined" : _typeof(self)) !== "object" || !(storageType in self)) {
              return false;
            }
            try {
              var storage = self[storageType];
              var testKey = "redux-persist ".concat(storageType, " test");
              storage.setItem(testKey, "test");
              storage.getItem(testKey);
              storage.removeItem(testKey);
            } catch (e) {
              return false;
            }
            return true;
          }
          function getStorage$1(type) {
            var storageType = "".concat(type, "Storage");
            if (hasStorage(storageType)) return self[storageType];else {
              return noopStorage;
            }
          }
          return getStorage;
        }
        var hasRequiredCreateWebStorage;
        function requireCreateWebStorage() {
          if (hasRequiredCreateWebStorage) return createWebStorage;
          hasRequiredCreateWebStorage = 1;
          createWebStorage.__esModule = true;
          createWebStorage.default = createWebStorage$1;
          var _getStorage = _interopRequireDefault(requireGetStorage());
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }
          function createWebStorage$1(type) {
            var storage = (0, _getStorage.default)(type);
            return {
              getItem: function getItem(key) {
                return new Promise(function (resolve, reject) {
                  resolve(storage.getItem(key));
                });
              },
              setItem: function setItem(key, item) {
                return new Promise(function (resolve, reject) {
                  resolve(storage.setItem(key, item));
                });
              },
              removeItem: function removeItem(key) {
                return new Promise(function (resolve, reject) {
                  resolve(storage.removeItem(key));
                });
              }
            };
          }
          return createWebStorage;
        }
        var hasRequiredStorage;
        function requireStorage() {
          if (hasRequiredStorage) return storage$1;
          hasRequiredStorage = 1;
          storage$1.__esModule = true;
          storage$1.default = void 0;
          var _createWebStorage = _interopRequireDefault(requireCreateWebStorage());
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }
          var _default = (0, _createWebStorage.default)('local');
          storage$1.default = _default;
          return storage$1;
        }
        var storageExports = requireStorage();
        const storage = exports("U", /*@__PURE__*/getDefaultExportFromCjs(storageExports));
        const ErrorBoundaryContext = reactExports.createContext(null);
        const initialState = {
          didCatch: false,
          error: null
        };
        class ErrorBoundary extends reactExports.Component {
          constructor(props) {
            super(props);
            this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
            this.state = initialState;
          }
          static getDerivedStateFromError(error) {
            return {
              didCatch: true,
              error
            };
          }
          resetErrorBoundary() {
            const {
              error
            } = this.state;
            if (error !== null) {
              var _this$props$onReset, _this$props;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
                args,
                reason: "imperative-api"
              });
              this.setState(initialState);
            }
          }
          componentDidCatch(error, info) {
            var _this$props$onError, _this$props2;
            (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);
          }
          componentDidUpdate(prevProps, prevState) {
            const {
              didCatch
            } = this.state;
            const {
              resetKeys
            } = this.props;

            // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,
            // we'd end up resetting the error boundary immediately.
            // This would likely trigger a second error to be thrown.
            // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.

            if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
              var _this$props$onReset2, _this$props3;
              (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
                next: resetKeys,
                prev: prevProps.resetKeys,
                reason: "keys"
              });
              this.setState(initialState);
            }
          }
          render() {
            const {
              children,
              fallbackRender,
              FallbackComponent,
              fallback
            } = this.props;
            const {
              didCatch,
              error
            } = this.state;
            let childToRender = children;
            if (didCatch) {
              const props = {
                error,
                resetErrorBoundary: this.resetErrorBoundary
              };
              if (typeof fallbackRender === "function") {
                childToRender = fallbackRender(props);
              } else if (FallbackComponent) {
                childToRender = reactExports.createElement(FallbackComponent, props);
              } else if (fallback !== undefined) {
                childToRender = fallback;
              } else {
                throw error;
              }
            }
            return reactExports.createElement(ErrorBoundaryContext.Provider, {
              value: {
                didCatch,
                error,
                resetErrorBoundary: this.resetErrorBoundary
              }
            }, childToRender);
          }
        }
        exports("Y", ErrorBoundary);
        function hasArrayChanged() {
          let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));
        }
      }
    };
  });
})();
