const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/ListIonIcons-CYR4Oy7Y.js","assets/vendor_react-CwmcyK5O.js","assets/vendor_ionic-Bx5nIVFZ.js","assets/vendor_ionic-CbIbgj2R.css","assets/vendor_leaflet-ibnEmoJR.js","assets/vendor_leaflet-Bvr-Ab8i.css","assets/vendor_react-Z09ODb1v.css","assets/index-W17eQ_hQ.js","assets/index-DpIKjTf5.css","assets/vendor_firebase-O9nGtifs.js","assets/PublicProfilePage-CqaO_eRj.js","assets/LocationWorkingTimePage-CLzoQKU8.js","assets/LocationEditPage-v87AmeK2.js","assets/location-settings.data-qUYjjce9.js","assets/LocationWorkersPage-BnHlXwhR.js","assets/LocationSettingsPage-1DBKXZI1.js","assets/ServicesPage-ZWdKQ5N4.js","assets/ServiceGroupEditPage-DI-UwQEs.js","assets/ServiceEditPage-CUbold2D.js","assets/LocationWorkerCreatePage-dPw7zkh5.js","assets/Menu-D0TrHqe7.js","assets/Menu-BF-_LQ0F.css"])))=>i.map(i=>d[i]);
var _a, _b, _c, _d, _e, _f, _g, _h, _i;
import { I as IonModal, b as IonHeader, c as IonToolbar, e as IonTitle, f as IonButtons, h as IonButton, i as IonIcon, j as closeOutline, k as IonContent, l as IonSpinner, m as IonFooter, s as saveOutline, n as languageOutline, o as IonItem, p as IonInput, q as eye, r as eyeOff, t as logoGoogle, u as IonText, v as IonSelect, w as IonSelectOption, x as videocam, y as videocamOff, z as IonGrid, A as IonRow, B as IonCol, C as IonSearchbar, D as IonLabel, E as IonList, F as IonCheckbox, G as arrowUndoOutline, H as IonPage, J as createAnimation, K as useIonModal, L as useIonLoading, M as useIonAlert, N as useIonActionSheet, O as trashOutline, P as IonImg, Q as cropOutline, R as optionsOutline, S as cloudUploadOutline, T as funnelOutline, U as listCircleSharp, V as IonItemSliding, W as IonItemOptions, X as IonThumbnail, Y as IonReorder, Z as menuOutline, $ as chevronForwardOutline, a0 as IonItemOption, a1 as constructOutline, a2 as checkboxOutline, a3 as squareOutline, a4 as IonReorderGroup, a5 as checkmarkOutline, a6 as addOutline, a7 as isPlatform, a8 as icons, a9 as useIonToast, aa as IonTextarea, ab as IonDatetime, ac as IonToggle, _ as __vitePreload, ad as calendarOutline, ae as timeOutline, af as IonChip, ag as IonLoading, ah as mailOutline, ai as keyOutline, aj as useIonRouter, ak as IonToast, al as IonListHeader, am as IonSkeletonText, an as exitOutline, ao as logoApple, ap as logoAndroid, aq as IonMenuButton, ar as chevronBackOutline, as as ellipsisVertical, at as ellipsisHorizontal, au as IonRefresher, av as IonRefresherContent, aw as IonPopover, ax as IonAlert, ay as lockClosedOutline, az as logInOutline, aA as chevronBack, aB as chevronForward, aC as IonCard, aD as IonCardHeader, aE as IonCardContent, aF as megaphoneOutline, aG as cutOutline, aH as IonSegment, aI as IonSegmentButton, aJ as IonAvatar, aK as IonCardTitle, aL as checkmarkCircleOutline, aM as closeCircleOutline, aN as walletOutline, aO as refreshOutline, aP as IonAccordionGroup, aQ as IonAccordion, aR as callOutline, aS as personOutline, aT as pencilOutline, aU as notificationsCircle, aV as closeCircle, aW as checkmarkCircle, aX as notificationsOffOutline, aY as peopleOutline, aZ as settingsOutline, a_ as IonActionSheet, a$ as createOutline, b0 as giftOutline, b1 as cashOutline, b2 as IonTabs, b3 as IonRouterOutlet, b4 as IonTabBar, b5 as IonTabButton, b6 as alarmOutline, b7 as notificationsOutline, b8 as removeOutline, b9 as IonBadge, ba as calendarClearOutline, bb as arrowBack, bc as arrowForward, bd as useIonViewDidLeave, be as pricetagOutline, bf as alertCircleOutline, bg as hourglassOutline, bh as helpOutline, bi as alertOutline, bj as IonApp, bk as IonReactRouter, bl as IonSplitPane, bm as setupIonicReact } from "./vendor_ionic-Bx5nIVFZ.js";
import { j as jsxRuntimeExports, Z as useForm, $ as o, E as humpsExports, a0 as t, e as reactExports, a1 as create$3, a2 as create$6, R as React, a3 as Controller, a4 as yup, a5 as setLocale, a6 as useWatch, a7 as DraftExports, a8 as reactDraftWysiwygExports, a9 as draftToHtml, aa as qr, ab as Swiper, G as createSlice, ac as l, J as combineReducers, K as configureStore, ad as c, ae as SwiperSlide, af as register, ag as V, ah as arrayMove, ai as useSensors, aj as useSensor, ak as DndContext, al as closestCenter, am as SortableContext, an as verticalListSortingStrategy, ao as TouchSensor, ap as sortableKeyboardCoordinates, aq as KeyboardSensor, ar as PointerSensor, as as useSortable, at as CSS, au as parseISO, av as formatInTimeZone, aw as toZonedTime, ax as format, ay as fromZonedTime, az as isValid, aA as useDispatch, aB as useSelector, aC as useTranslation, aD as useHistory, aE as GoogleOAuthProvider, aF as useGoogleLogin, aG as ErrorBoundary, aH as Clipboard, q as Route, aI as buildExports, v as instance, aJ as differenceInCalendarMonths, aK as getMonth, aL as startOfMonth, aM as addDays, aN as endOfMonth, aO as eachDayOfInterval, aP as subMonths, aQ as addMonths, aR as parse, aS as addMinutes, aT as isWithinInterval, aU as differenceInMinutes, aV as Redirect, aW as useLocation, aX as isPast, aY as create$7, aZ as create$5, a_ as useParams, a$ as create$2, Y as ErrorBoundary$1 } from "./vendor_react-CwmcyK5O.js";
import { s as sharedApi, T as TagType, a as sharedApiPrefix, U as UploadType, b as TagId, c as setShowCompleteProfileModal, d as setUser, e as setUiData, g as getImageModalData, f as closeImageModal, h as getShowLoginModal, i as getShowImageModal, j as setShowLoginModal, k as getDeviceData, l as setDeviceData, m as getUser, n as logoutAction, r as rzrApi, o as TagType$1, p as TagId$1, q as getInitialData } from "./index-W17eQ_hQ.js";
import { i as initializeApp, g as getMessagingInWindow, a as getAnalytics, o as onMessage, b as getToken } from "./vendor_firebase-O9nGtifs.js";
const ConditionalComponent = ({
  condition,
  render,
  elseCondition = true,
  renderElse
}) => {
  if (!!condition) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: render() });
  }
  if (elseCondition && renderElse) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderElse() });
  }
  return null;
};
var FieldType = /* @__PURE__ */ ((FieldType2) => {
  FieldType2["Text"] = "TextField";
  FieldType2["TextArea"] = "TextArea";
  FieldType2["Password"] = "Password";
  FieldType2["Number"] = "NumberField";
  FieldType2["Switch"] = "Switch";
  FieldType2["Select"] = "Select";
  FieldType2["Autocomplete"] = "Autocomplete";
  FieldType2["Checkbox"] = "Checkbox";
  FieldType2["MultiCheckbox"] = "MultiCheckbox";
  FieldType2["List"] = "List";
  FieldType2["DateTime"] = "DateTime";
  FieldType2["Date"] = "Date";
  FieldType2["Time"] = "Time";
  FieldType2["WorkingHours"] = "WorkingHours";
  FieldType2["WorkingHoursSingle"] = "WorkingHoursSingle";
  FieldType2["Callback"] = "Callback";
  FieldType2["RichEditor"] = "RichEditor";
  FieldType2["PhotoUploader"] = "PhotoUploader";
  FieldType2["GalleryArea"] = "GalleryArea";
  FieldType2["Coordinates"] = "Coordinates";
  FieldType2["IonIcon"] = "IonIcon";
  FieldType2["ChangeRequest"] = "ChangeRequest";
  FieldType2["Slug"] = "Slug";
  return FieldType2;
})(FieldType || {});
function useFormWithSchema(schema2, useFormProps) {
  return useForm({ ...useFormProps, resolver: o(schema2) });
}
const transformPaginationResponseToCamelCase = (response) => humpsExports.camelizeKeys(response.data);
const transformStandardResponseToCamelCase = (response) => humpsExports.camelizeKeys(response);
const translationsApi = sharedApi.injectEndpoints({
  endpoints: (builder) => ({
    getTranslations: builder.query({
      query: (params) => ({
        url: "translations",
        method: "GET",
        params
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType.TRANSLATIONS]
    }),
    createTranslation: builder.mutation({
      query: (body) => ({
        url: "translations",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType.TRANSLATIONS]
    })
  })
});
const { useGetTranslationsQuery, useCreateTranslationMutation } = translationsApi;
const getTranslationFormFields = (fieldType, label) => {
  const fields = [
    {
      keyName: "language",
      name: t("Jezik"),
      data: {
        type: FieldType.Select,
        label: t("Jezik"),
        options: [
          { text: t("Engleski"), value: "eng" },
          { text: t("Srpski"), value: "rs" }
        ]
      },
      gridSize: { size: "12" }
    }
  ];
  switch (fieldType) {
    case FieldType.Text:
      fields.push({
        keyName: "translationValue",
        name: t("Prevod"),
        data: {
          type: FieldType.Text,
          label
        },
        gridSize: { size: "12" },
        newRow: true
      });
      break;
    case FieldType.TextArea:
      fields.push({
        keyName: "translationValue",
        name: t("Prevod"),
        data: {
          type: FieldType.TextArea,
          label
        },
        gridSize: { size: "12" },
        newRow: true
      });
      break;
    case FieldType.RichEditor:
      fields.push({
        keyName: "translationValue",
        name: t("Prevod"),
        data: {
          type: FieldType.RichEditor,
          label
        },
        gridSize: { size: "12" },
        newRow: true
      });
      break;
  }
  return fields;
};
const LANGUAGE_MAPPING = {
  eng: "eng",
  en: "eng",
  rs: "sr"
};
function frontendToBackendLang(frontendLang) {
  return LANGUAGE_MAPPING[frontendLang] || frontendLang;
}
const schema$4 = create$3().shape({
  language: create$6().required(t("Jezik je obavezan")),
  translationValue: create$6().required(t("Prevod je obavezan"))
});
function TranslationEditor({
  isOpen,
  onClose,
  translation,
  fieldType,
  label,
  currentValue
}) {
  const [formKey, setFormKey] = reactExports.useState("");
  const [selectedLanguage, setSelectedLanguage] = reactExports.useState("eng");
  const { data: translationData, isLoading: isLoadingTranslations } = useGetTranslationsQuery({
    entityType: translation.type,
    entityId: translation.dataId
  });
  const [createTranslation, { isLoading: isCreating }] = useCreateTranslationMutation();
  const form = useFormWithSchema(schema$4, {
    defaultValues: {
      language: "eng",
      translationValue: ""
    }
  });
  const { handleSubmit, watch, setValue } = form;
  const watchedLanguage = watch("language");
  const formFields = reactExports.useMemo(
    () => getTranslationFormFields(fieldType, label),
    [fieldType, label]
  );
  const isLoading = isCreating || isLoadingTranslations;
  reactExports.useEffect(() => {
    if ((translationData == null ? void 0 : translationData.success) && translationData.data) {
      const backendLanguage = frontendToBackendLang(watchedLanguage);
      const languageData = translationData.data[backendLanguage];
      console.log(
        "languageData",
        languageData,
        backendLanguage,
        watchedLanguage
      );
      if (languageData && languageData[translation.fieldName]) {
        setValue("translationValue", languageData[translation.fieldName]);
        setFormKey(watchedLanguage);
      } else {
        setValue("translationValue", "");
        setFormKey(watchedLanguage);
      }
    }
  }, [translationData, watchedLanguage, translation.fieldName, setValue]);
  reactExports.useEffect(() => {
    if (isOpen) {
      setSelectedLanguage("eng");
      setValue("language", "eng");
    }
  }, [isOpen, setValue]);
  const handleSaveTranslation = async (formData) => {
    try {
      const backendLanguage = frontendToBackendLang(formData.language);
      const translationPayload = {
        entityType: translation.type,
        entityId: translation.dataId,
        language: backendLanguage,
        fieldName: translation.fieldName,
        fieldValue: formData.translationValue
      };
      await createTranslation(translationPayload).unwrap();
      onClose();
    } catch (error) {
      console.error("Error saving translation:", error);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonModal, { isOpen, onDidDismiss: onClose, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTitle, { children: [
        t("Prevod"),
        " - ",
        label
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: onClose, fill: "clear", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { className: "ion-padding", children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-center items-center p-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2", children: t("U훾itavanje...") })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields: formFields, form }, formKey) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 p-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { fill: "outline", onClick: onClose, disabled: isLoading, children: t("Otka탑i") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          onClick: handleSubmit(handleSaveTranslation),
          disabled: isLoading,
          className: "flex-1",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "start" }),
            isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { name: "crescent" }) : t("Sa훾uvaj prevod")
          ]
        }
      )
    ] }) }) })
  ] });
}
const TranslationEditor$1 = reactExports.memo(TranslationEditor);
function TranslationButton({
  translation,
  fieldName,
  fieldType,
  label,
  currentValue,
  buttonProps = {}
}) {
  const [showTranslationEditor, setShowTranslationEditor] = reactExports.useState(false);
  const openTranslationEditor = () => {
    setShowTranslationEditor(true);
  };
  const closeTranslationEditor = () => {
    setShowTranslationEditor(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonButton,
      {
        fill: buttonProps.fill || "clear",
        size: buttonProps.size || "small",
        slot: "end",
        onClick: openTranslationEditor,
        className: buttonProps.className,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: languageOutline })
      }
    ),
    showTranslationEditor && /* @__PURE__ */ jsxRuntimeExports.jsx(
      TranslationEditor$1,
      {
        isOpen: showTranslationEditor,
        onClose: closeTranslationEditor,
        translation,
        fieldType,
        label,
        currentValue
      }
    )
  ] });
}
function CommonIonicInput(props) {
  const { label, labelPlacement = "floating", type, register: register2, error } = props;
  const { itemProps, inputProps, control } = props;
  const { showEye, googleIt, translation } = props;
  const [showPassword, setShowPassword] = React.useState(false);
  const togglePasswordVisibility = () => {
    setShowPassword(!showPassword);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { ...itemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonInput,
          {
            label,
            type: showPassword ? "text" : type,
            labelPlacement,
            onIonBlur: register2.onBlur,
            onKeyUp: register2.onBlur,
            step: "any",
            ...inputProps,
            ...register2,
            children: [
              showEye && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  fill: "clear",
                  slot: "end",
                  onClick: togglePasswordVisibility,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: showPassword ? eye : eyeOff })
                }
              ),
              translation && /* @__PURE__ */ jsxRuntimeExports.jsx(
                TranslationButton,
                {
                  translation,
                  fieldName: register2.name,
                  fieldType: FieldType.Text,
                  label,
                  currentValue: field.value || ""
                }
              ),
              !!(googleIt == null ? void 0 : googleIt.length) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  fill: "clear",
                  slot: "end",
                  onClick: () => window.open(
                    "https://www.google.com/search?q=".concat(googleIt),
                    "_blank"
                  ),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: logoGoogle })
                }
              )
            ]
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
function CommonIonicSelect(props) {
  const {
    ariaLabel,
    interfaceProp = "action-sheet",
    selectProps,
    placeholder,
    multiple,
    register: register2,
    options = [],
    control,
    error,
    labelPlacement = "floating",
    emptyOption
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => {
          var _a2;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            IonSelect,
            {
              ...selectProps,
              label: ariaLabel,
              interface: interfaceProp,
              placeholder,
              multiple: !!multiple,
              onIonBlur: register2.onBlur,
              onIonChange: register2.onChange,
              labelPlacement,
              value: (_a2 = field.value) == null ? void 0 : _a2.toString(),
              ...register2,
              children: [
                emptyOption && /* @__PURE__ */ jsxRuntimeExports.jsx(IonSelectOption, { value: null, children: emptyOption }),
                options.map((option, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(IonSelectOption, { ...option, children: option.text }, index))
              ]
            }
          );
        }
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const commonValidationMessages = {
  required: "Obavezno polje",
  min: "minimalno ${min}",
  max: "maksimalno ${max}",
  email: "Neispravan email"
};
const tV = (key) => {
  return t(commonValidationMessages[key]);
};
setLocale({
  number: {
    min: tV("min")
  },
  array: {
    min: tV("min")
  },
  string: {
    min: tV("min")
  },
  mixed: {
    required: tV("required")
  }
});
const generateSlugForValidation = (text) => {
  return text.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
};
const validatePhotosHaveId = (photos) => {
  if (!photos || photos.length === 0) {
    return true;
  }
  return photos.every((photo) => (photo == null ? void 0 : photo.id) !== void 0 && (photo == null ? void 0 : photo.id) !== null);
};
const photosArrayWithIdYup = (errorMsg) => yup.array().nullable().defined().test("all-photos-have-id", "", function(value) {
  return validatePhotosHaveId(value);
});
function CommonIonicSlug(props) {
  const { label, labelPlacement = "floating", register: register2, error } = props;
  const {
    itemProps,
    inputProps,
    control,
    sourceField,
    placeholder,
    isWatched,
    isWatchedDefault
  } = props;
  const [isWatchedState, setIsWatchedState] = reactExports.useState(isWatchedDefault != null ? isWatchedDefault : true);
  const fieldOnChangeRef = reactExports.useRef(null);
  const watchSourceField = useWatch({ control, name: sourceField });
  const handleToggleWatched = () => {
    setIsWatchedState(!isWatchedState);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { ...itemProps, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => {
          fieldOnChangeRef.current = field.onChange;
          const sourceValue = watchSourceField || "";
          const shouldAutoGenerate = (isWatched != null ? isWatched : isWatchedState) && sourceValue;
          if (shouldAutoGenerate) {
            const slug = generateSlugForValidation(sourceValue);
            if (slug && slug !== field.value) {
              field.onChange(slug);
            }
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: { display: "flex", alignItems: "center", width: "100%" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonInput,
                  {
                    ...field,
                    ...inputProps,
                    label,
                    labelPlacement,
                    placeholder,
                    readonly: !!shouldAutoGenerate,
                    className: error ? "ion-invalid" : "",
                    style: { flex: 1 }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonButton,
                  {
                    fill: "clear",
                    size: "small",
                    color: isWatchedState ? "success" : "danger",
                    onClick: handleToggleWatched,
                    style: { marginLeft: "8px" },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: isWatchedState ? videocam : videocamOff })
                  }
                )
              ]
            }
          );
        }
      }
    ),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-margin-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ion-text-wrap", children: error.message }) })
  ] });
}
function MultiSelectAutocomplete(props) {
  var _a2;
  const { selectedItems } = props;
  const [filteredItems, setFilteredItems] = reactExports.useState([
    ...props.items
  ]);
  const [workingSelectedValues, setWorkingSelectedValues] = reactExports.useState([
    ...selectedItems
  ]);
  const dataRowClassNames = (_a2 = props.dataRowClassNames) != null ? _a2 : "ion-no-padding";
  const isChecked = (value) => {
    return workingSelectedValues.find((item) => item === value) !== void 0;
  };
  const cancelChanges = () => {
    const { onSelectionCancel } = props;
    if (onSelectionCancel !== void 0) {
      onSelectionCancel();
    }
  };
  const confirmChanges = () => {
    const { onSelectionChange } = props;
    if (onSelectionChange !== void 0) {
      onSelectionChange(workingSelectedValues);
    }
  };
  const searchbarInput = (ev) => {
    filterList(ev.target.value);
  };
  const filterList = (searchQuery) => {
    if (searchQuery === void 0 || searchQuery === null) {
      setFilteredItems([...props.items]);
    } else {
      const normalizedQuery = searchQuery.toLowerCase();
      setFilteredItems(
        props.items.filter((item) => {
          return item.text.toLowerCase().includes(normalizedQuery);
        })
      );
    }
  };
  const checkboxChange = (ev) => {
    const { checked, value } = ev.detail;
    if (checked) {
      setWorkingSelectedValues([...workingSelectedValues, value]);
    } else {
      setWorkingSelectedValues(
        workingSelectedValues.filter((item) => item !== value)
      );
    }
  };
  const checkSelectedValuesHasDiff = reactExports.useCallback(() => {
    if (workingSelectedValues.length === 0 && selectedItems.length === 0) {
      return false;
    }
    if (workingSelectedValues.length !== selectedItems.length || workingSelectedValues.length === 0) {
      return true;
    }
    return workingSelectedValues.filter((x) => !selectedItems.includes(x)).length;
  }, [workingSelectedValues, selectedItems]);
  reactExports.useEffect(() => {
    if (props.hideSearchbar && checkSelectedValuesHasDiff()) {
      confirmChanges();
    }
  }, [workingSelectedValues, selectedItems]);
  reactExports.useEffect(() => {
    setFilteredItems([...props.items]);
  }, [props.items]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonGrid, { className: "ion-no-padding", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { className: "ion-no-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: !props.hideSearchbar ? /* @__PURE__ */ jsxRuntimeExports.jsxs(IonHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: cancelChanges, children: "Cancel" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: props.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: confirmChanges, children: "Done" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSearchbar, { onIonInput: searchbarInput }) })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "ion-no-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: props.title }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { className: dataRowClassNames, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { className: "ion-no-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonList, { className: "ion-no-margin", children: filteredItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { disabled: props.disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonCheckbox,
      {
        value: item.value,
        checked: isChecked(item.value),
        onIonChange: checkboxChange,
        disabled: item.disabled || props.disabled,
        children: item.text
      }
    ) }, item.value)) }) }) })
  ] }) });
}
function CommonIonicMultiCheckbox(props) {
  const {
    disabled,
    register: register2,
    control,
    error,
    showSearchbar = true,
    label,
    dataRowClassNames,
    interfaceProp = "action-sheet",
    labelPlacement = "floating",
    options = []
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field: { onChange, value } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          MultiSelectAutocomplete,
          {
            disabled,
            items: options.map((option) => {
              var _a2;
              return {
                value: option.value,
                text: (_a2 = option.text) != null ? _a2 : option.value,
                disabled: option.disabled
              };
            }),
            selectedItems: value != null ? value : [],
            onSelectionChange: (items) => onChange(items),
            hideSearchbar: !showSearchbar,
            title: label,
            dataRowClassNames
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const RichEditor = ({ onChange, value, label, children, ...other }, ref) => {
  var _a2;
  const initialVal = DraftExports.convertFromHTML(String(value != null ? value : ""));
  const wrapperClassName = (_a2 = other.wrapperClassName) != null ? _a2 : "rich-editor-wrapper";
  const [editorState, setEditorState] = reactExports.useState(
    value ? DraftExports.EditorState.createWithContent(
      DraftExports.ContentState.createFromBlockArray(initialVal.contentBlocks)
    ) : DraftExports.EditorState.createEmpty()
  );
  const [text, setText] = reactExports.useState();
  const onEditorStateChange = function(editorState2) {
    setEditorState(editorState2);
    const { blocks } = DraftExports.convertToRaw(editorState2.getCurrentContent());
    const rawContentState = DraftExports.convertToRaw(editorState2.getCurrentContent());
    const markup = draftToHtml(rawContentState);
    setText(markup);
    onChange(markup);
  };
  reactExports.useEffect(() => {
    if (value && !editorState.getLastChangeType()) {
      const val = DraftExports.convertFromHTML(String(value));
      setEditorState(
        DraftExports.EditorState.createWithContent(
          DraftExports.ContentState.createFromBlockArray(val.contentBlocks)
        )
      );
    }
  }, [value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-5 w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: label }),
      children
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: wrapperClassName, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      reactDraftWysiwygExports.Editor,
      {
        editorState,
        onEditorStateChange,
        toolbarClassName: "toolbarClassName",
        wrapperClassName: "wrapperClassName",
        editorClassName: "editorClassName",
        toolbar: {
          options: [
            "inline",
            "blockType",
            "list",
            "textAlign",
            "link",
            "emoji",
            "image",
            "history"
          ]
        }
      }
    ) })
  ] });
};
const RichEditor$1 = reactExports.memo(reactExports.forwardRef(RichEditor));
function FormRichEditor(props) {
  const { register: register2, error, label } = props;
  const { itemProps, control, translation } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { ...itemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsx(RichEditor$1, { ...field, label, children: translation && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TranslationButton,
          {
            translation,
            fieldName: register2.name,
            fieldType: FieldType.RichEditor,
            label,
            currentValue: field.value || ""
          }
        ) })
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
function SelectAutocomplete(props) {
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  const { items, handleAddNewOption } = props;
  const [filteredItems, setFilteredItems] = reactExports.useState([
    ...items
  ]);
  const cancelChanges = () => {
    const { onSelectionCancel } = props;
    if (onSelectionCancel !== void 0) {
      onSelectionCancel();
    }
  };
  const searchbarInput = (ev) => {
    filterList(ev.target.value);
    setSearchQuery(ev.target.value);
  };
  const filterList = (searchQuery2) => {
    if (searchQuery2 === void 0 || searchQuery2 === null) {
      setFilteredItems([...props.items]);
    } else {
      const normalizedQuery = searchQuery2.toLowerCase();
      setFilteredItems(
        props.items.filter((item) => {
          return item.filterField === false || item.text.toLowerCase().includes(normalizedQuery);
        })
      );
    }
  };
  const handleSelected = (item) => () => {
    var _a2;
    (_a2 = props.onSelectionChange) == null ? void 0 : _a2.call(props, item);
  };
  const handleSelectAddNew = () => {
    if (searchQuery) {
      handleAddNewOption == null ? void 0 : handleAddNewOption(searchQuery);
      cancelChanges();
    }
  };
  reactExports.useEffect(() => {
    setFilteredItems(items);
  }, [items]);
  const searchPlaceholder = handleAddNewOption ? t("Pretra탑i / Dodaj novo") : t("Pretraga");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonGrid, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: !props.hideSearchbar ? /* @__PURE__ */ jsxRuntimeExports.jsxs(IonHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: props.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleSelected(void 0), children: t("Resetuj") }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonSearchbar,
        {
          onIonInput: searchbarInput,
          placeholder: searchPlaceholder
        }
      ) })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "ion-no-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: props.title }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { id: "modal-list", inset: true, children: [
      handleAddNewOption && searchQuery && /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { button: true, onClick: handleSelectAddNew, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { color: "primary", children: [
        t("Dodaj novo:"),
        " ",
        searchQuery
      ] }) }) }),
      items.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        qr,
        {
          totalCount: filteredItems.length,
          style: { height: "400px" },
          itemContent: (index) => {
            var _a2;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonItem,
              {
                disabled: props.disabled,
                onClick: handleSelected(filteredItems[index].value),
                button: true,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: (_a2 = filteredItems[index].childNode) != null ? _a2 : filteredItems[index].text })
              },
              filteredItems[index].value
            );
          }
        }
      )
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { button: true, onClick: cancelChanges, detail: false, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline, className: "mr-2", slot: "end" }),
      t("Zatvori")
    ] }) }) })
  ] }) });
}
function SelectAutocompleteModal({
  onSelectionChanged,
  selectedItemValue,
  handleAddNewOption,
  options,
  title,
  startIcon,
  endIcon,
  hideInput,
  hideOnSelection = true
}) {
  var _a2;
  const [isNewSelected, setIsNewSelected] = reactExports.useState(false);
  const modal = reactExports.useRef(null);
  selectedItemValue = selectedItemValue == null ? void 0 : selectedItemValue.toString();
  const selectedItemText = isNewSelected ? selectedItemValue : (_a2 = options.find((option) => option.value === selectedItemValue)) == null ? void 0 : _a2.text;
  const [showModal, setShowModal] = reactExports.useState(false);
  const handleSelectChange = (item, isNewSelected2) => {
    var _a3;
    onSelectionChanged == null ? void 0 : onSelectionChanged(item);
    if (hideOnSelection || options.length <= 1) {
      (_a3 = modal.current) == null ? void 0 : _a3.dismiss();
    }
    setIsNewSelected(!!isNewSelected2);
  };
  const handleAddNewSelectedOption = (value) => {
    handleAddNewOption == null ? void 0 : handleAddNewOption(value);
    handleSelectChange(value, true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonItem,
      {
        onClick: () => setShowModal(true),
        button: true,
        hidden: hideInput,
        children: [
          startIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "start", icon: startIcon }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonInput,
            {
              label: title,
              readonly: true,
              value: selectedItemText,
              labelPlacement: "floating"
            }
          ),
          endIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "end", icon: endIcon })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonModal,
      {
        ref: modal,
        isOpen: showModal,
        onDidDismiss: () => setShowModal(false),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectAutocomplete,
          {
            title,
            items: options,
            selectedItem: selectedItemValue,
            onSelectionCancel: () => {
              var _a3;
              return (_a3 = modal.current) == null ? void 0 : _a3.dismiss();
            },
            onSelectionChange: handleSelectChange,
            handleAddNewOption: handleAddNewOption ? handleAddNewSelectedOption : void 0
          }
        ) })
      }
    )
  ] });
}
function CommonIonicAutocompleteSelect(props) {
  const { register: register2, options, control, error, label, handleAddNewOption } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field: { onChange, value } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectAutocompleteModal,
          {
            selectedItemValue: value,
            onSelectionChanged: (item) => {
              var _a2, _b2;
              onChange(
                item !== void 0 ? item : (_b2 = (_a2 = control._defaultValues) == null ? void 0 : _a2[register2.name]) != null ? _b2 : null
              );
            },
            options,
            title: label,
            handleAddNewOption
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
function SwiperWrapper(props, ref) {
  const { currentStep, ...swiperProps } = props;
  const swiperRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (currentStep !== void 0) {
      const timeout = setTimeout(() => {
        var _a2, _b2, _c2, _d2;
        if (((_b2 = (_a2 = swiperRef == null ? void 0 : swiperRef.current) == null ? void 0 : _a2.swiper) == null ? void 0 : _b2.activeIndex) !== currentStep) {
          (_d2 = (_c2 = swiperRef == null ? void 0 : swiperRef.current) == null ? void 0 : _c2.swiper) == null ? void 0 : _d2.slideTo(currentStep);
        }
      }, 100);
      return () => clearTimeout(timeout);
    }
  }, [currentStep]);
  reactExports.useImperativeHandle(ref, () => {
    var _a2;
    return {
      swiper: (_a2 = swiperRef.current) == null ? void 0 : _a2.swiper
    };
  });
  const onSlideChange = reactExports.useMemo(() => {
    return currentStep !== void 0 ? (swiper) => {
      var _a2, _b2;
      if (currentStep !== void 0 && swiper.activeIndex !== currentStep) {
        (_b2 = (_a2 = swiperRef.current) == null ? void 0 : _a2.swiper) == null ? void 0 : _b2.slideTo(currentStep);
      }
    } : void 0;
  }, [currentStep]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Swiper,
    {
      onSlideChange,
      watchSlidesProgress: true,
      ...swiperProps,
      initialSlide: currentStep,
      ref: swiperRef
    }
  ) });
}
const SwiperWrapper$1 = reactExports.memo(reactExports.forwardRef(SwiperWrapper));
const getFirstUploadedFileIdSortedBehindIndex = (manageDataItems, fileIndex) => {
  var _a2, _b2;
  return (_b2 = (_a2 = manageDataItems == null ? void 0 : manageDataItems.find(
    (item, itemIndex) => itemIndex > fileIndex && item.id !== void 0
  )) == null ? void 0 : _a2.id) != null ? _b2 : "";
};
const fixManageDataItemsIndexes = (manageDataItems, fromIndex = 0) => manageDataItems.map((item, index) => ({
  ...item,
  index: fromIndex + index,
  sortOrder: index + fromIndex + 1,
  image: item.image ? { ...item.image, index: fromIndex + index } : void 0
}));
const initialState = {
  data: {
    manageDataItems: [],
    itemsReorderFromTo: [],
    showSortItemsModal: void 0,
    showManageListModal: void 0
  }
};
const manageDataSlices = createSlice({
  name: "manageItems",
  initialState,
  reducers: {
    setManageData(state, action) {
      const manageDataItems = action.payload.manageDataItems ? fixManageDataItemsIndexes(action.payload.manageDataItems) : state.data.manageDataItems;
      state.data = {
        ...state.data,
        ...action.payload,
        manageDataItems
      };
    },
    setShowSortDataModal(state, action) {
      state.data.showSortItemsModal = action.payload;
    },
    setShowManageListModal(state, action) {
      state.data.showManageListModal = action.payload;
    },
    setManageDataItems(state, action) {
      state.data.manageDataItems = fixManageDataItemsIndexes(action.payload);
    },
    updateManageDataItemPhoto(state, action) {
      const itemIndex = action.payload.index;
      if (state.data.manageDataItems && state.data.manageDataItems[itemIndex]) {
        state.data.manageDataItems[itemIndex].image = action.payload.image;
      }
    },
    updateManageDataItemProductPhoto(state, action) {
      const itemIndex = action.payload.index;
      if (state.data.manageDataItems && state.data.manageDataItems[itemIndex]) {
        const existingImage = state.data.manageDataItems[itemIndex].image;
        if (existingImage) {
          state.data.manageDataItems[itemIndex].image = {
            ...existingImage,
            id: action.payload.productImage.id
          };
        }
      }
    },
    updateManageDataItems(state, action) {
      action.payload.forEach((item) => {
        const itemIndex = item.index;
        if (state.data.manageDataItems && state.data.manageDataItems[itemIndex]) {
          state.data.manageDataItems[itemIndex] = item.data;
        }
      });
    },
    addManageDataItems(state, action) {
      var _a2, _b2;
      (_b2 = state.data.manageDataItems) == null ? void 0 : _b2.push(
        ...fixManageDataItemsIndexes(
          action.payload,
          (_a2 = state.data.manageDataItems) == null ? void 0 : _a2.length
        )
      );
    },
    removeManageDataItems(state, action) {
      var _a2, _b2;
      state.data.manageDataItems = fixManageDataItemsIndexes(
        (_b2 = (_a2 = state.data.manageDataItems) == null ? void 0 : _a2.filter(
          (item, index) => !action.payload.includes(index)
        )) != null ? _b2 : []
      );
    },
    resetManageDataItems(state) {
      state.data.manageDataItems = [];
    },
    addReorderFromTo(state, action) {
      var _a2;
      (_a2 = state.data.itemsReorderFromTo) == null ? void 0 : _a2.push(action.payload);
    },
    resetReorderFromTo(state) {
      state.data.itemsReorderFromTo = [];
    },
    removeReorderFromToItems(state, action) {
      var _a2;
      state.data.itemsReorderFromTo = (_a2 = state.data.itemsReorderFromTo) == null ? void 0 : _a2.filter(
        (item) => !action.payload.includes(item)
      );
    }
  }
});
const isCroppedItemImage = (item, aspectRatioStr) => {
  var _a2, _b2;
  return ((_b2 = (_a2 = item.image) == null ? void 0 : _a2.croppedUrls) == null ? void 0 : _b2[aspectRatioStr]) !== void 0 || item.id !== void 0;
};
const getManageItems = (state) => state.manageData.data.manageDataItems;
const manageItemsMaxSortOrder = (state) => {
  var _a2, _b2;
  return ((_a2 = state.manageData.data.manageDataItems) == null ? void 0 : _a2.length) ? Math.max(
    ...((_b2 = state.manageData.data.manageDataItems) == null ? void 0 : _b2.map(
      (item) => {
        var _a3;
        return (_a3 = item.sortOrder) != null ? _a3 : 0;
      }
    )) || []
  ) : 0;
};
const getNonCroppedItems = (aspectRatioStr) => (state) => {
  var _a2;
  return (_a2 = state.manageData.data.manageDataItems) == null ? void 0 : _a2.filter(
    (item) => !isCroppedItemImage(item, aspectRatioStr)
  );
};
const getItemsReorderFromTo = (state) => state.manageData.data.itemsReorderFromTo;
const {
  setManageData,
  setShowSortDataModal,
  setManageDataItems,
  updateManageDataItemPhoto,
  updateManageDataItemProductPhoto,
  updateManageDataItems,
  addManageDataItems,
  removeManageDataItems,
  setShowManageListModal,
  addReorderFromTo,
  resetReorderFromTo,
  removeReorderFromToItems,
  resetManageDataItems
} = manageDataSlices.actions;
const CropView = (props, ref) => {
  var _a2;
  const aspectRatioSizes = (_a2 = props.aspectRatio) != null ? _a2 : {
    width: 4,
    height: 5
  };
  const { image, hideActions } = props;
  const { autoCrop, autoCropIndex, onAutoCrop } = props;
  const { onSave, onDiscard } = props;
  const cropperRef = reactExports.useRef(null);
  const [cropData, setCropData] = React.useState();
  let loadingPreview = false;
  const [resizedImage, setResizedImage] = React.useState(
    void 0
  );
  const handleCrop = () => {
    var _a3;
    try {
      const cropper = (_a3 = cropperRef.current) == null ? void 0 : _a3.cropper;
      const cropData2 = cropper == null ? void 0 : cropper.getCroppedCanvas().toDataURL();
      handleSave(cropData2);
    } catch (e) {
      setTimeout(() => {
        handleCrop();
      }, 200);
    }
  };
  const onZoom = () => {
    if (!loadingPreview) {
      loadingPreview = true;
      setTimeout(() => {
        var _a3;
        const cropper = (_a3 = cropperRef.current) == null ? void 0 : _a3.cropper;
        setCropData(cropper == null ? void 0 : cropper.getCroppedCanvas().toDataURL());
        loadingPreview = false;
      }, 1e3);
    }
  };
  reactExports.useImperativeHandle(ref, () => ({
    handleSave: () => {
      handleSave();
    }
  }));
  const handleDiscard = () => {
    onDiscard == null ? void 0 : onDiscard();
  };
  const handleSave = (cropData2) => {
    if (cropData2) {
      if (autoCrop) {
        onAutoCrop == null ? void 0 : onAutoCrop(cropData2, autoCropIndex);
      } else {
        onSave == null ? void 0 : onSave(cropData2);
      }
    }
  };
  const handleSetCropData = (src) => {
    if (autoCrop) {
      setTimeout(() => {
        handleCrop();
      }, 500);
    } else {
      setCropData(src);
    }
  };
  const handleCropInit = () => {
    handleSetCropData(resizedImage);
  };
  reactExports.useEffect(() => {
    const existingImage = new Image();
    existingImage.onload = function() {
      const aspectRatio = (aspectRatioSizes == null ? void 0 : aspectRatioSizes.height) / (aspectRatioSizes == null ? void 0 : aspectRatioSizes.width);
      if (existingImage.height > existingImage.width * aspectRatio) {
        setResizedImage(image.url);
        return null;
      }
      const canvas = document.createElement("canvas");
      const canvasWidth = existingImage.width;
      const canvasHeight = existingImage.width * aspectRatio;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext("2d");
      const verticalOffset = (canvasHeight - existingImage.height) / 2;
      ctx.drawImage(
        existingImage,
        0,
        verticalOffset,
        existingImage.width,
        existingImage.height
      );
      const newImage = new Image();
      newImage.src = canvas.toDataURL();
      setTimeout(() => {
        setResizedImage(newImage.src);
      }, 200);
    };
    existingImage.src = image.url;
  }, [image.url]);
  reactExports.useEffect(() => {
    if (resizedImage && autoCrop && autoCropIndex) {
      handleSetCropData(resizedImage);
    }
  }, [resizedImage, autoCropIndex]);
  if (!resizedImage) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: image.url, alt: "cropped" });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      l,
      {
        src: resizedImage,
        style: { height: 400, width: "100%" },
        viewMode: 1,
        initialAspectRatio: aspectRatioSizes.width / aspectRatioSizes.height,
        dragMode: "move",
        aspectRatio: aspectRatioSizes.width / aspectRatioSizes.height,
        autoCrop: true,
        guides: false,
        scalable: false,
        cropBoxResizable: false,
        cropBoxMovable: false,
        minCropBoxHeight: 700,
        movable: true,
        zoom: onZoom,
        onInitialized: handleCropInit,
        ref: cropperRef
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { hidden: hideActions, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButton, { onClick: handleDiscard, color: "danger", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "start", icon: arrowUndoOutline }),
        t("Odustani")
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButton, { onClick: handleCrop, color: "secondary", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "start", icon: saveOutline }),
        t("Primeni")
      ] }) })
    ] }) })
  ] });
};
const CropView$1 = reactExports.memo(reactExports.forwardRef(CropView));
function AutoCropControllerModal(props, ref) {
  const { image, aspectRatio } = props;
  const { handleClose, cropViewProps } = props;
  const cropViewRef = reactExports.useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonPage, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: aspectRatio && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      aspectRatio.width,
      " x ",
      aspectRatio.height
    ] }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { fullscreen: true, className: "ion-padding ion-text-center", children: image && /* @__PURE__ */ jsxRuntimeExports.jsx(
      CropView$1,
      {
        ref: cropViewRef,
        image,
        onDiscard: handleClose,
        hideActions: true,
        aspectRatio,
        ...cropViewProps
      }
    ) })
  ] });
}
const AutoCropControllerModal$1 = reactExports.memo(reactExports.forwardRef(AutoCropControllerModal));
const modalEnterAnimation = (baseEl) => {
  const root = baseEl.shadowRoot;
  const backdropAnimation = createAnimation().addElement(root == null ? void 0 : root.querySelector("ion-backdrop")).fromTo("opacity", "0.01", "var(--backdrop-opacity)");
  const wrapperAnimation = createAnimation().addElement(root == null ? void 0 : root.querySelector(".modal-wrapper")).keyframes([
    { offset: 0, opacity: "0", transform: "scale(0)" },
    { offset: 1, opacity: "0.99", transform: "scale(1)" }
  ]);
  return createAnimation().addElement(baseEl).duration(350).addAnimation([backdropAnimation, wrapperAnimation]);
};
const manageDataReducers = {
  manageData: manageDataSlices.reducer
};
const rootReducer = combineReducers(manageDataReducers);
configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware()
});
function withManageDataWrapper(WrappedComponent) {
  return class extends React.Component {
    render() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ManageDataWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedComponent, { ...this.props }) });
    }
  };
}
const DataContext = reactExports.createContext(void 0);
const DispatchContext = reactExports.createContext(void 0);
function useManageDataSelector(selector) {
  const manageDataState = React.useContext(DataContext);
  if (!manageDataState) {
    throw new Error(
      "useManageDataSelector must be used within a ManageDataProvider"
    );
  }
  return selector(manageDataState);
}
function useManageDataDispatch() {
  const dispatchContext = React.useContext(DispatchContext);
  if ((dispatchContext == null ? void 0 : dispatchContext.dispatch) === void 0) {
    throw new Error(
      "useManageDataDispatch must be used within a ManageDataWrapper"
    );
  }
  return (action) => {
    dispatchContext.dispatch(action);
    dispatchContext.reRender();
  };
}
function ManageDataWrapper({ children }) {
  const manageDataStore = reactExports.useMemo(
    () => configureStore({
      reducer: combineReducers(manageDataReducers)
    }),
    []
  );
  const storeState = manageDataStore.getState();
  const dispatch = manageDataStore.dispatch;
  const [render, setRender] = reactExports.useState(false);
  const reRender = reactExports.useCallback(() => {
    setRender(!render);
  }, [render]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DataContext.Provider, { value: storeState, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DispatchContext.Provider, { value: { dispatch, reRender }, children }) });
}
reactExports.memo(ManageDataWrapper);
const useAutoCropModalController = (props) => {
  const { cropAspectRatio } = props;
  const [images, setImages] = React.useState([]);
  const [image, setImage] = React.useState(void 0);
  const [activeIndex, setActiveIndex] = React.useState(
    void 0
  );
  const [croppedIndexes, setCroppedIndexes] = React.useState([]);
  const dispatch = useManageDataDispatch();
  const cropAspectRatioStr = "".concat(cropAspectRatio.width, "x").concat(cropAspectRatio.height);
  const AutoCropControllerModalWrapper = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      AutoCropControllerModal$1,
      {
        image,
        handleClose: function() {
          setActiveIndex((activeIndex != null ? activeIndex : 0) + 1);
        },
        aspectRatio: cropAspectRatio,
        cropViewProps: {
          autoCropIndex: activeIndex,
          autoCrop: true,
          onAutoCrop: (croppedSrc, autoCropIndex) => {
            if (autoCropIndex !== void 0) {
              updateSelectedImage(croppedSrc, autoCropIndex).then(() => {
                setActiveIndex(autoCropIndex + 1);
              });
            }
          }
        }
      }
    );
  };
  const updateSelectedImage = async (croppedSrc, autoCropIndex) => {
    const selectedImage = images[autoCropIndex];
    if (!croppedIndexes.includes(autoCropIndex)) {
      setCroppedIndexes([...croppedIndexes, autoCropIndex]);
      dispatch(
        updateManageDataItemPhoto({
          index: selectedImage.index,
          image: {
            ...selectedImage,
            croppedUrls: {
              [cropAspectRatioStr]: croppedSrc
            }
          }
        })
      );
    }
  };
  const [present, dismiss] = useIonModal(AutoCropControllerModalWrapper, {
    onDismiss: (data, role) => dismiss(data, role)
  });
  const [presentLoader, dismissLoader] = useIonLoading();
  reactExports.useEffect(() => {
    if (activeIndex !== void 0) {
      if (activeIndex >= images.length) {
        dismiss();
        dismissLoader();
        setActiveIndex(void 0);
        setCroppedIndexes([]);
      } else {
        setImage(images[activeIndex]);
      }
    }
  }, [activeIndex]);
  const startAutoCrop = (images2) => {
    setImages(images2);
    setActiveIndex(0);
    present({
      enterAnimation: modalEnterAnimation
    });
    presentLoader({
      message: t("Auto-cropping images...")
    });
  };
  return { startAutoCrop };
};
const useConfirmationAlert = (callbacks, options) => {
  const [presentAlert, dismiss] = useIonAlert();
  return [
    (overrideOptions) => {
      var _a2, _b2;
      const {
        cancelCallback,
        confirmCallback,
        buttonsTextsKeys,
        ...presentOptions
      } = {
        ...options,
        ...callbacks,
        ...overrideOptions
      };
      const cancelKey = (_a2 = buttonsTextsKeys == null ? void 0 : buttonsTextsKeys.cancel) != null ? _a2 : "Odustani";
      const confirmKey = (_b2 = buttonsTextsKeys == null ? void 0 : buttonsTextsKeys.confirm) != null ? _b2 : "OK";
      return presentAlert({
        header: t("Potvrda"),
        buttons: [
          {
            text: t(cancelKey),
            role: "cancel",
            handler: cancelCallback
          },
          {
            text: t(confirmKey),
            role: "confirm",
            handler: confirmCallback
          }
        ],
        ...presentOptions
      });
    },
    dismiss
  ];
};
const formatBytes = (bytes) => {
  if (bytes === 0) return "0 Bytes";
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return Math.round(bytes / Math.pow(k, i) * 100) / 100 + " " + sizes[i];
};
const getFileSizeFromUrl = async (url) => {
  try {
    if (url.startsWith("data:")) {
      const base64String = url.split(",")[1];
      if (base64String) {
        return base64String.length * 3 / 4;
      }
    } else if (url.startsWith("blob:")) {
      const response = await fetch(url);
      const blob = await response.blob();
      return blob.size;
    }
    return 0;
  } catch (e) {
    return 0;
  }
};
const ImageSizeDisplay = ({
  url,
  maxSize = 10 * 1024 * 1024
}) => {
  const [size, setSize] = reactExports.useState(null);
  reactExports.useEffect(() => {
    const fetchSize = async () => {
      const fileSize = await getFileSizeFromUrl(url);
      if (fileSize > 0) {
        setSize(fileSize);
      }
    };
    fetchSize();
  }, [url]);
  if (!size) return null;
  const isOverLimit = size > maxSize;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: isOverLimit ? "animate-pulse" : "",
      style: {
        position: "absolute",
        bottom: "8px",
        right: "8px",
        padding: "4px 8px",
        backgroundColor: "rgba(0, 0, 0, 0.85)",
        borderRadius: "4px",
        zIndex: 10
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            alignItems: "flex-end"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonText,
              {
                color: isOverLimit ? "danger" : "light",
                style: {
                  fontSize: "12px",
                  color: isOverLimit ? "#ff6b6b" : "#ffffff",
                  fontWeight: isOverLimit ? "bold" : "normal"
                },
                children: formatBytes(size)
              }
            ),
            isOverLimit && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonText,
              {
                color: "danger",
                style: {
                  fontSize: "10px",
                  color: "#ff6b6b",
                  fontWeight: "normal"
                },
                children: [
                  "Max: ",
                  formatBytes(maxSize)
                ]
              }
            )
          ]
        }
      )
    }
  );
};
register();
function PhotoGallery(props, ref) {
  const { defaultActiveSlide, photos, setSelectedImageIndex } = props;
  const { cropAspectRatio, notCroppedPhotos, editOnSelect } = props;
  const {
    handleRemoveImages,
    handleOnManageAction,
    handleOnSortAction,
    pendingUploadCount = 0,
    onUploadClick
  } = props;
  const availableActions = {
    ...{
      crop: true,
      sort: true
    },
    ...props.availableActions
  };
  const [presentRemovePhoto] = useConfirmationAlert({
    confirmCallback: () => {
      removePhoto();
    }
  });
  const cropAspectRatioStr = "".concat(cropAspectRatio.width, "x").concat(cropAspectRatio.height);
  const [presentActions] = useIonActionSheet();
  const [activeSlide, setActiveSlide] = React.useState(
    defaultActiveSlide != null ? defaultActiveSlide : 0
  );
  const swiperRef = React.useRef(null);
  const dispatch = useManageDataDispatch();
  const { startAutoCrop } = useAutoCropModalController({
    cropAspectRatio
  });
  reactExports.useImperativeHandle(ref, () => ({
    setGalleryStep: (step) => {
      setActiveSlide(step);
    },
    handleStartAutoCrop: () => {
      handleOnAutoCrop();
    }
  }));
  const handleImageClick = () => {
    canCrop && editOnSelect && setSelectedImageIndex(activeSlide != null ? activeSlide : 0);
  };
  const handleSlideChange = (swiper) => {
    setActiveSlide(swiper.activeIndex);
  };
  const handleOnSort = () => handleOnSortAction ? handleOnSortAction() : dispatch(setShowSortDataModal(true));
  const handleOnManage = () => handleOnManageAction ? handleOnManageAction() : dispatch(setShowManageListModal(true));
  const handleOnCrop = () => {
    setSelectedImageIndex(activeSlide != null ? activeSlide : 0);
  };
  const handleOnAutoCrop = () => {
    if (notCroppedPhotos == null ? void 0 : notCroppedPhotos.length) {
      startAutoCrop(notCroppedPhotos);
    }
  };
  const presentAdditionActions = () => {
    presentActions({
      header: t("Dodatne opcije"),
      buttons: [
        {
          icon: funnelOutline,
          text: t("Sortiraj"),
          data: {
            action: "sort"
          },
          cssClass: photos.length < 2 ? "cursor-not-allowed focus:outline-none opacity-25" : void 0,
          handler: () => {
            if (photos.length >= 2) {
              handleOnSort();
            }
          }
        },
        {
          icon: cropOutline,
          text: t("Auto Crop (".concat(notCroppedPhotos == null ? void 0 : notCroppedPhotos.length, ")")),
          data: {
            action: "crop"
          },
          cssClass: !(notCroppedPhotos == null ? void 0 : notCroppedPhotos.length) ? "cursor-not-allowed focus:outline-none opacity-25" : void 0,
          handler: () => {
            if (notCroppedPhotos == null ? void 0 : notCroppedPhotos.length) {
              handleOnAutoCrop();
            }
          }
        },
        {
          icon: listCircleSharp,
          text: t("Upravljanje slikama"),
          data: {
            action: "sort"
          },
          handler: () => {
            handleOnManage();
          }
        },
        {
          text: t("Obri큄i"),
          role: "destructive",
          data: {
            action: "delete"
          },
          handler: () => {
            handleRemovePhoto();
          }
        },
        {
          text: t("Cancel"),
          role: "cancel",
          data: {
            action: "cancel"
          }
        }
      ]
    });
  };
  const removePhotoLocally = (photoIndex) => {
    dispatch(removeManageDataItems([photoIndex]));
  };
  const removePhoto = () => {
    var _a2;
    if (activeSlide !== void 0) {
      if (photos[activeSlide].id !== void 0 && handleRemoveImages) {
        (_a2 = handleRemoveImages == null ? void 0 : handleRemoveImages([photos[activeSlide]])) == null ? void 0 : _a2.then((response) => {
          if ("data" in response && response.data.success) {
            removePhotoLocally(activeSlide);
          }
        });
      } else {
        removePhotoLocally(activeSlide);
      }
    }
  };
  const handleRemovePhoto = () => {
    if (photos.length === 1 && props.handleClose) {
      props.handleClose();
    } else {
      presentRemovePhoto({
        message: t("Da li ste sigurni da 탑elite da obri큄ete sliku?")
      });
    }
  };
  const canCrop = reactExports.useMemo(() => {
    if (activeSlide !== void 0 && photos.length) {
      const photo = photos[activeSlide];
      return (photo == null ? void 0 : photo.id) === void 0 && availableActions.crop;
    }
    return false;
  }, [activeSlide, photos]);
  const bindDouble = c(
    () => {
      canCrop && handleOnCrop();
    },
    void 0,
    {
      onSingleTap: () => {
        handleImageClick();
      }
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonToolbar,
      {
        style: { position: "absolute" },
        color: "translucent",
        hidden: !photos.length,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleRemovePhoto, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "end", icon: trashOutline, color: "danger" }) }) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwiperWrapper$1,
      {
        ref: swiperRef,
        spaceBetween: 50,
        slidesPerView: 1,
        navigation: true,
        pagination: { clickable: true },
        scrollbar: { draggable: true },
        speed: 400,
        initialSlide: activeSlide,
        currentStep: activeSlide != null ? activeSlide : 0,
        onSlideChange: handleSlideChange,
        autoHeight: false,
        className: "photo-gallery-swiper",
        children: photos.map((photo, index) => {
          var _a2, _b2;
          const isNewImage = (photo == null ? void 0 : photo.id) === void 0;
          const imageUrl = cropAspectRatio && ((_a2 = photo.croppedUrls) == null ? void 0 : _a2[cropAspectRatioStr]) ? (_b2 = photo.croppedUrls) == null ? void 0 : _b2[cropAspectRatioStr] : photo.url;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwiperSlide, { style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonImg,
              {
                src: imageUrl,
                alt: photo.name,
                ...bindDouble,
                className: "photo-gallery-img"
              }
            ),
            isNewImage && /* @__PURE__ */ jsxRuntimeExports.jsx(ImageSizeDisplay, { url: imageUrl, maxSize: props.maxSize })
          ] }, "slide" + index);
        })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { className: "actions", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          color: "secondary",
          onClick: handleOnCrop,
          disabled: !canCrop,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "start", icon: cropOutline }),
            "Crop"
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: presentAdditionActions, disabled: !photos.length, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "icon-only", icon: optionsOutline }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          color: pendingUploadCount > 0 ? "warning" : "medium",
          onClick: onUploadClick,
          disabled: pendingUploadCount === 0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "start", icon: cloudUploadOutline }),
            pendingUploadCount > 0 ? "".concat(t("Upload"), " (").concat(pendingUploadCount, ")") : t("Upload")
          ]
        }
      ) })
    ] })
  ] });
}
const PhotoGallery$1 = reactExports.memo(reactExports.forwardRef(PhotoGallery));
function CropViewModal(props, ref) {
  const { isActive, image, aspectRatio } = props;
  const { handleClose, cropViewProps } = props;
  const cropViewRef = reactExports.useRef(null);
  const enterAnimation = (baseEl) => {
    const root = baseEl.shadowRoot;
    const backdropAnimation = createAnimation().addElement(root == null ? void 0 : root.querySelector("ion-backdrop")).fromTo("opacity", "0.01", "var(--backdrop-opacity)");
    const wrapperAnimation = createAnimation().addElement(root == null ? void 0 : root.querySelector(".modal-wrapper")).keyframes([
      { offset: 0, opacity: "0", transform: "scale(0)" },
      { offset: 1, opacity: "0.99", transform: "scale(1)" }
    ]);
    return createAnimation().addElement(baseEl).duration(350).addAnimation([backdropAnimation, wrapperAnimation]);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonModal,
    {
      isOpen: isActive,
      onDidDismiss: handleClose,
      enterAnimation,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: aspectRatio && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            aspectRatio.width,
            " x ",
            aspectRatio.height
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleClose, children: "Close" }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { fullscreen: true, className: "ion-padding ion-text-center", children: image && /* @__PURE__ */ jsxRuntimeExports.jsx(
          CropView$1,
          {
            ref: cropViewRef,
            image,
            onDiscard: handleClose,
            aspectRatio,
            ...cropViewProps
          }
        ) })
      ]
    }
  );
}
const CropViewModal$1 = reactExports.memo(reactExports.forwardRef(CropViewModal));
const getAspectRatioStr = (aspectRatio) => "".concat(aspectRatio.width, "x").concat(aspectRatio.height);
const windowWidth = window.innerWidth;
const commonPhotoAspectRatio = {
  width: 4,
  height: 5
};
const getPathBySize = (img) => {
  if (!img) {
    return "";
  }
  switch (true) {
    case windowWidth >= 1920:
      return img[
        "fullHd"
        /* fullHd */
      ];
    case windowWidth >= 1280:
      return img[
        "hd"
        /* hd */
      ];
    case windowWidth >= 768:
      return img[
        "small"
        /* small */
      ];
    default:
      return img[
        "mobile"
        /* mobile */
      ];
  }
};
function PhotoEditor(props, ref) {
  var _a2, _b2, _c2;
  const dispatch = useManageDataDispatch();
  const [selectedImageIndex, setSelectedImageIndex] = reactExports.useState(void 0);
  const manageDataItems = useManageDataSelector(getManageItems);
  const selectedImage = selectedImageIndex !== void 0 ? manageDataItems == null ? void 0 : manageDataItems[selectedImageIndex].image : void 0;
  const cropViewModalRef = reactExports.useRef(null);
  const photoGalleryRef = reactExports.useRef(null);
  const photos = reactExports.useMemo(
    () => (manageDataItems == null ? void 0 : manageDataItems.length) ? manageDataItems.map((manageDataItem) => manageDataItem.image) : [],
    [manageDataItems]
  );
  const photoAspectRatio = (_a2 = props.photoAspectRatio) != null ? _a2 : commonPhotoAspectRatio;
  const photoAspectRatioStr = getAspectRatioStr(photoAspectRatio);
  const notCroppedPhotos = (_c2 = (_b2 = useManageDataSelector(getNonCroppedItems(photoAspectRatioStr))) == null ? void 0 : _b2.map(
    (manageDataItem) => manageDataItem.image
  )) != null ? _c2 : [];
  const [uploadedImages, setUploadedImages] = reactExports.useState(photos);
  reactExports.useImperativeHandle(ref, () => ({
    setGalleryStep: (step) => {
      var _a3;
      (_a3 = photoGalleryRef.current) == null ? void 0 : _a3.setGalleryStep(step);
    },
    handleAutoCrop: () => {
      var _a3, _b3;
      (_b3 = (_a3 = photoGalleryRef.current) == null ? void 0 : _a3.handleStartAutoCrop) == null ? void 0 : _b3.call(_a3);
    }
  }));
  const updateSelectedImage = async (croppedSrc, removeSelected = true) => {
    if (selectedImageIndex !== void 0 && selectedImage) {
      dispatch(
        updateManageDataItemPhoto({
          index: selectedImageIndex,
          image: {
            ...selectedImage,
            croppedUrls: {
              [photoAspectRatioStr]: croppedSrc
            }
          }
        })
      );
      removeSelected && setSelectedImageIndex(void 0);
    }
  };
  const handleGalleryClose = props.onSetStep ? () => {
    var _a3;
    (_a3 = props.onSetStep) == null ? void 0 : _a3.call(props, 0);
  } : void 0;
  reactExports.useEffect(() => {
    setUploadedImages(photos);
  }, [photos]);
  reactExports.useEffect(() => {
    var _a3, _b3;
    dispatch(
      setManageDataItems(
        (_b3 = (_a3 = props.photos) == null ? void 0 : _a3.map((photo) => ({
          id: photo.id,
          index: photo.index,
          image: photo,
          sortOrder: photo.index
        }))) != null ? _b3 : []
      )
    );
  }, [props.photos]);
  reactExports.useEffect(() => {
    var _a3;
    if (props.onChangedPhotos) {
      props.onChangedPhotos(
        (_a3 = manageDataItems == null ? void 0 : manageDataItems.map((manageDataItem) => {
          var _a4, _b3, _c3, _d2, _e2;
          return {
            id: manageDataItem.id,
            url: (_c3 = (_b3 = (_a4 = manageDataItem.image) == null ? void 0 : _a4.croppedUrls) == null ? void 0 : _b3[photoAspectRatioStr]) != null ? _c3 : "",
            fileAfterId: getFirstUploadedFileIdSortedBehindIndex(
              manageDataItems != null ? manageDataItems : [],
              (_e2 = (_d2 = manageDataItem.image) == null ? void 0 : _d2.index) != null ? _e2 : 0
            )
          };
        }).filter((image) => image.url.length || image.id)) != null ? _a3 : []
      );
    }
  }, [manageDataItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PhotoGallery$1,
      {
        ref: photoGalleryRef,
        photos: uploadedImages,
        notCroppedPhotos,
        setSelectedImageIndex,
        cropAspectRatio: photoAspectRatio,
        handleClose: handleGalleryClose,
        ...props.galleryProps
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CropViewModal$1,
      {
        ref: cropViewModalRef,
        isActive: selectedImageIndex !== void 0,
        handleClose: () => {
          setSelectedImageIndex(void 0);
        },
        image: selectedImage,
        aspectRatio: photoAspectRatio,
        cropViewProps: {
          onSave: updateSelectedImage
        }
      }
    )
  ] });
}
const PhotoEditor$1 = reactExports.memo(reactExports.forwardRef(PhotoEditor));
var ItemsActions = /* @__PURE__ */ ((ItemsActions2) => {
  ItemsActions2["Remove"] = "Remove";
  ItemsActions2["Edit"] = "Edit";
  ItemsActions2["Check"] = "Check";
  return ItemsActions2;
})(ItemsActions || {});
var ListActions = /* @__PURE__ */ ((ListActions2) => {
  ListActions2["Remove"] = "Remove";
  ListActions2["Add"] = "Add";
  ListActions2["SelectEnable"] = "SelectEnable";
  ListActions2["SelectAll"] = "SelectAll";
  ListActions2["AutoCrop"] = "AutoCrop";
  return ListActions2;
})(ListActions || {});
function ManageListItem(props) {
  var _a2, _b2, _c2, _d2, _e2;
  const { data, onHandleAction } = props;
  const { showCheckbox, setShowCheckbox, isSelected } = props;
  const { availableActions } = props;
  const [isChecked, setIsChecked] = React.useState(
    isSelected
  );
  const [preventToggle, setPreventToggle] = React.useState(false);
  const [isOptionsDisabled, setIsOptionsDisabled] = reactExports.useState(true);
  const slideRef = reactExports.useRef(null);
  const slideOptionRef = reactExports.useRef(null);
  const handleSlide = () => {
    var _a3, _b3;
    if ((_a3 = slideRef.current) == null ? void 0 : _a3.classList.contains("item-sliding-active-options-end")) {
      slideClose();
    } else {
      (_b3 = slideRef.current) == null ? void 0 : _b3.open("end");
      setIsOptionsDisabled(false);
    }
  };
  const slideClose = () => {
    var _a3;
    (_a3 = slideRef.current) == null ? void 0 : _a3.close();
    setIsOptionsDisabled(true);
  };
  const handleAction = (action) => (event) => {
    event.stopPropagation();
    onHandleAction == null ? void 0 : onHandleAction({ data, type: action });
  };
  const handleDragMove = (event) => {
    if (event.detail.amount < -30) {
      if (!showCheckbox) {
        setShowCheckbox(true);
      }
      if (!isChecked) {
        setIsChecked(true);
      }
      slideClose();
    } else if (event.detail.amount > 30 && showCheckbox) {
      setShowCheckbox(false);
      setIsChecked(false);
      slideClose();
    }
    if (event.detail.ratio === 1) {
      if (!showCheckbox) {
        setIsOptionsDisabled(false);
      }
    }
  };
  const toggleIsChecked = () => {
    setIsChecked(!isChecked);
  };
  const handleItemDoubleClick = () => {
    if (!showCheckbox) {
      setShowCheckbox(true);
      setIsChecked(true);
    }
  };
  reactExports.useEffect(() => {
    if (!showCheckbox && isChecked !== void 0) {
      setIsChecked(void 0);
    }
  }, [showCheckbox]);
  reactExports.useEffect(() => {
    if (isChecked !== void 0 && isChecked !== isSelected) {
      onHandleAction == null ? void 0 : onHandleAction({ data, type: ItemsActions.Check, isChecked });
    }
  }, [isChecked]);
  reactExports.useEffect(() => {
    if (isChecked !== isSelected) {
      setIsChecked(isSelected);
    }
  }, [isSelected]);
  const bindDouble = c(() => {
    handleItemDoubleClick();
  });
  const bindHold = V(
    showCheckbox ? null : () => {
      handleItemDoubleClick();
    },
    {
      threshold: 300,
      onStart: () => {
        setPreventToggle(true);
      },
      onCancel: () => {
        setTimeout(() => {
          setPreventToggle(false);
        });
      },
      onFinish: () => {
        setTimeout(() => {
          setPreventToggle(false);
        }, 200);
      }
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonItemSliding,
    {
      ref: slideRef,
      onIonDrag: handleDragMove,
      onAnimationEnd: () => console.log("animation end"),
      disabled: showCheckbox,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonItemOptions, { side: "start" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonThumbnail, { slot: "start", ...bindHold(), ...bindDouble, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { alt: "Silhouette of mountains", src: (_a2 = data.image) == null ? void 0 : _a2.url }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { ...bindDouble, children: showCheckbox ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonCheckbox,
            {
              checked: isChecked,
              onIonChange: toggleIsChecked,
              disabled: preventToggle,
              children: (_c2 = (_b2 = data.label) != null ? _b2 : data.id) != null ? _c2 : data.index
            }
          ) }) : (_e2 = (_d2 = data.label) != null ? _d2 : data.id) != null ? _e2 : data.index }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonReorder, { color: "light", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: menuOutline }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { onClick: handleSlide, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonIcon,
            {
              icon: chevronForwardOutline,
              slot: "end",
              role: "img"
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItemOptions, { side: "end", onClick: handleSlide, ref: slideOptionRef, children: [
          (availableActions == null ? void 0 : availableActions.includes(ItemsActions.Edit)) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonItemOption,
            {
              onClick: handleAction(ItemsActions.Edit),
              disabled: isOptionsDisabled,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "icon-only", icon: constructOutline })
            }
          ),
          (availableActions == null ? void 0 : availableActions.includes(ItemsActions.Remove)) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonItemOption,
            {
              onClick: handleAction(ItemsActions.Remove),
              color: "danger",
              disabled: isOptionsDisabled,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "icon-only", icon: trashOutline })
            }
          )
        ] })
      ]
    }
  );
}
const ManageListItem$1 = reactExports.memo(ManageListItem);
function ManageListActions(props) {
  const {
    showCheckbox,
    setShowCheckbox,
    selectedCount = 0,
    totalCount = 0
  } = props;
  const handleShowCheckbox = (show) => () => {
    setShowCheckbox(show);
  };
  const handleAction = (action) => () => {
    var _a2;
    (_a2 = props.handleListAction) == null ? void 0 : _a2.call(props, {
      type: action
      // todo remove any (fix ts)
    });
  };
  const allSelected = showCheckbox && selectedCount > 0 && selectedCount === totalCount;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        color: "light",
        size: "small",
        onClick: handleAction(ListActions.SelectAll),
        disabled: totalCount === 0,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: checkboxOutline, slot: "start" }),
          allSelected ? t("Poni큄ti sve") : t("Selektuj sve")
        ]
      }
    ),
    showCheckbox ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        color: "light",
        onClick: handleShowCheckbox(false),
        size: "small",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline, slot: "start" }),
          t("Zatvori selekciju")
        ]
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        color: "light",
        onClick: handleShowCheckbox(true),
        size: "small",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: squareOutline, slot: "start" }),
          t("Selektuj slike")
        ]
      }
    )
  ] });
}
const ManageListActions$1 = reactExports.memo(ManageListActions);
function List(props) {
  const { handleCallAction } = props;
  const {
    manageItems,
    callAddReorderFromTo,
    callRemoveManageDataItems,
    callSetManageDataItems
  } = props;
  const addNew = props.addNew ? {
    labelKey: "addNew",
    position: "top",
    ...props.addNew
  } : void 0;
  const [items, setItems] = reactExports.useState(manageItems != null ? manageItems : []);
  const [selectedItems, setSelectedItems] = reactExports.useState([]);
  const [showCheckboxes, setShowCheckboxes] = React.useState(false);
  const onSelectionChangeRef = reactExports.useRef(props.onSelectionChange);
  const handleDeleteItems = (selectedItems2) => {
    var _a2;
    if (selectedItems2.length) {
      const localSelected = selectedItems2.filter(
        (item) => item.id === void 0
      );
      const existingSelected = selectedItems2.filter(
        (item) => item.id !== void 0
      );
      if (existingSelected.length) {
        (_a2 = handleCallAction == null ? void 0 : handleCallAction({
          data: existingSelected,
          type: ItemsActions.Remove
        })) == null ? void 0 : _a2.then(() => {
          deleteSelectedItems(selectedItems2);
        });
      } else if (localSelected.length) {
        deleteSelectedItems(localSelected);
      }
    }
  };
  const deleteSelectedItems = (selectedItems2) => {
    callRemoveManageDataItems == null ? void 0 : callRemoveManageDataItems(selectedItems2.map((item) => item.index));
    setSelectedItems([]);
    setShowCheckboxes(false);
  };
  const [presentDeleteItems] = useConfirmationAlert({
    confirmCallback: () => {
      handleDeleteItems(selectedItems);
    }
  });
  const handleAction = (manageDataAction) => {
    switch (manageDataAction.type) {
      case ItemsActions.Remove:
        presentDeleteItems({
          confirmCallback: () => {
            const selectedItems2 = Array.isArray(manageDataAction.data) ? manageDataAction.data : [manageDataAction.data];
            handleDeleteItems(selectedItems2);
          }
        });
        break;
      case ItemsActions.Edit:
        break;
      case ItemsActions.Check:
        toggleSelectedItems(manageDataAction.data, !manageDataAction.isChecked);
        break;
    }
  };
  const handleListAction = (listAction) => {
    switch (listAction.type) {
      case ListActions.Remove:
        presentDeleteItems();
        break;
      case ListActions.SelectAll:
        if (showCheckboxes && selectedItems.length === items.length && items.length > 0) {
          setSelectedItems([]);
        } else {
          setSelectedItems(items);
          setShowCheckboxes(true);
        }
        break;
    }
  };
  const addToSelectedItems = (item, force = false) => {
    if (force || !selectedItems.includes(item)) {
      setSelectedItems((selectedItems2) => [...selectedItems2, item]);
    }
  };
  const removeFromSelectedItems = (item) => {
    setSelectedItems(
      (selectedItems2) => selectedItems2.filter((selectedItem) => selectedItem !== item)
    );
  };
  const toggleSelectedItems = (item, remove) => {
    if (remove && selectedItems.includes(item)) {
      removeFromSelectedItems(item);
    } else if (!remove) {
      addToSelectedItems(item, true);
    }
  };
  reactExports.useEffect(() => {
    setItems(manageItems != null ? manageItems : []);
  }, [manageItems]);
  reactExports.useEffect(() => {
    if (!showCheckboxes && selectedItems.length) {
      setSelectedItems([]);
    }
  }, [showCheckboxes]);
  function handleReorder(event) {
    const from = event.detail.from;
    const to = event.detail.to;
    const itemFrom = items[from];
    const itemTo = items[to];
    if (from !== to) {
      const newItems = ((sortItems) => {
        return arrayMove(sortItems, from, to);
      })(items);
      setItems(newItems);
      setTimeout(() => {
        callSetManageDataItems == null ? void 0 : callSetManageDataItems(newItems);
      });
      if (itemFrom.id && itemTo.id && itemFrom.id !== itemTo.id) {
        callAddReorderFromTo == null ? void 0 : callAddReorderFromTo({ from: itemFrom.id, to: itemTo.id });
      }
    }
    event.detail.complete();
  }
  const AddNewButton = reactExports.useMemo(
    () => addNew && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonButton,
      {
        expand: "full",
        fill: "outline",
        className: "mt-10",
        color: "dark",
        children: t(addNew.labelKey)
      }
    ),
    [addNew]
  );
  reactExports.useEffect(() => {
    onSelectionChangeRef.current = props.onSelectionChange;
  }, [props.onSelectionChange]);
  const handleDeleteClickRef = reactExports.useRef();
  const handleDeleteClick = reactExports.useCallback(() => {
    presentDeleteItems({
      confirmCallback: () => {
        handleDeleteItems(selectedItems);
      }
    });
  }, [selectedItems, presentDeleteItems, handleDeleteItems]);
  reactExports.useEffect(() => {
    handleDeleteClickRef.current = handleDeleteClick;
  }, [handleDeleteClick]);
  reactExports.useEffect(() => {
    var _a2;
    (_a2 = onSelectionChangeRef.current) == null ? void 0 : _a2.call(onSelectionChangeRef, {
      showCheckboxes,
      selectedCount: selectedItems.length,
      onDelete: () => {
        var _a3;
        (_a3 = handleDeleteClickRef.current) == null ? void 0 : _a3.call(handleDeleteClickRef);
      }
    });
  }, [showCheckboxes, selectedItems.length]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ManageListActions$1,
      {
        showCheckbox: showCheckboxes,
        setShowCheckbox: setShowCheckboxes,
        handleListAction,
        selectedCount: selectedItems.length,
        totalCount: items.length
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { children: [
      (addNew == null ? void 0 : addNew.position) === "top" && AddNewButton,
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonReorderGroup, { disabled: false, onIonItemReorder: handleReorder, children: items == null ? void 0 : items.map((sortItemData) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        ManageListItem$1,
        {
          data: sortItemData,
          showCheckbox: showCheckboxes,
          setShowCheckbox: setShowCheckboxes,
          isSelected: selectedItems.includes(sortItemData),
          availableActions: [ItemsActions.Edit, ItemsActions.Remove],
          onHandleAction: handleAction
        },
        sortItemData.sortOrder
      )) }),
      (addNew == null ? void 0 : addNew.position) === "bottom" && AddNewButton
    ] })
  ] });
}
const List$1 = reactExports.memo(List);
function ManageList(props) {
  const dispatch = useManageDataDispatch();
  const manageItems = useManageDataSelector(getManageItems);
  const handAddReorderFromTo = (data) => {
    dispatch(addReorderFromTo(data));
  };
  const handleRemoveManageDataItems = (data) => {
    dispatch(removeManageDataItems(data));
  };
  const handleSetManageDataItems = (data) => {
    dispatch(setManageDataItems(data));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    List$1,
    {
      ...props,
      manageItems,
      callAddReorderFromTo: handAddReorderFromTo,
      callRemoveManageDataItems: handleRemoveManageDataItems,
      callSetManageDataItems: handleSetManageDataItems
    }
  );
}
const ManageList$1 = reactExports.memo(ManageList);
function ManageListModal(props) {
  const { open, manageListProps, onHandleClose } = props;
  const [footerProps, setFooterProps] = reactExports.useState(null);
  const handleClose = () => {
    onHandleClose();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonModal, { isOpen: open, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: t("Upravljanje slikama") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleClose, children: t("Zatvori") }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ManageList$1,
      {
        ...manageListProps,
        onSelectionChange: (props2) => {
          setFooterProps(props2);
        }
      }
    ) }),
    (footerProps == null ? void 0 : footerProps.showCheckboxes) && /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        expand: "block",
        color: "danger",
        disabled: footerProps.selectedCount === 0,
        onClick: footerProps.onDelete,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline, slot: "start" }),
          t("Obri큄i selektovano"),
          " ",
          footerProps.selectedCount > 0 && "(".concat(footerProps.selectedCount, ")")
        ]
      }
    ) }) })
  ] });
}
function SortableImageItem({ photo, index }) {
  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: index });
  const style = {
    transform: CSS.Transform.toString(transform),
    touchAction: "none",
    transition
  };
  const imageUrl = photo.croppedUrls && Object.keys(photo.croppedUrls).length > 0 ? Object.values(photo.croppedUrls)[0] : photo.url;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { ref: setNodeRef, style, ...attributes, ...listeners, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonThumbnail, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { alt: photo.name || "Image ".concat(index + 1), src: imageUrl }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
      photo.name || "Slika ".concat(index + 1),
      photo.id && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        "ID: ",
        photo.id
      ] })
    ] })
  ] });
}
function SortImagesModal({
  open,
  photos,
  onClose,
  onSave
}) {
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates
    }),
    useSensor(TouchSensor)
  );
  const [sortedPhotos, setSortedPhotos] = reactExports.useState(photos);
  const [hasChanges, setHasChanges] = reactExports.useState(false);
  const [isSaving, setIsSaving] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setSortedPhotos(photos);
    setHasChanges(false);
  }, [photos, open]);
  const orderIds = reactExports.useMemo(
    () => sortedPhotos.map((_, index) => index),
    [sortedPhotos]
  );
  const handleDragEnd = (event) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      setSortedPhotos((items) => {
        const oldIndex = active.id;
        const newIndex = over.id;
        return arrayMove(items, oldIndex, newIndex);
      });
      setHasChanges(true);
    }
  };
  const handleSave = async () => {
    var _a2;
    if (!hasChanges) {
      onClose();
      return;
    }
    const reorderData = [];
    const photosWithIds = sortedPhotos.filter((photo) => photo.id);
    for (let i = 0; i < photosWithIds.length; i++) {
      const currentPhoto = photosWithIds[i];
      const originalIndex = photos.findIndex((p) => p.id === currentPhoto.id);
      if (originalIndex !== i && originalIndex !== -1) {
        if (i > 0) {
          const previousPhoto = photosWithIds[i - 1];
          if (previousPhoto == null ? void 0 : previousPhoto.id) {
            reorderData.push({
              from: Number(currentPhoto.id),
              to: Number(previousPhoto.id)
            });
          }
        } else {
          const originalPreviousIndex = originalIndex - 1;
          if (originalPreviousIndex >= 0 && ((_a2 = photos[originalPreviousIndex]) == null ? void 0 : _a2.id)) {
            reorderData.push({
              from: Number(currentPhoto.id),
              to: Number(photos[originalPreviousIndex].id)
            });
          }
        }
      }
    }
    if (reorderData.length > 0) {
      setIsSaving(true);
      try {
        await onSave(reorderData);
        setHasChanges(false);
        onClose();
      } catch (error) {
        console.error("Error saving sort order:", error);
      } finally {
        setIsSaving(false);
      }
    } else {
      onClose();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonModal, { isOpen: open, onDidDismiss: onClose, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: t("Sortiraj slike") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      DndContext,
      {
        sensors,
        collisionDetection: closestCenter,
        onDragEnd: handleDragEnd,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SortableContext,
          {
            items: orderIds,
            strategy: verticalListSortingStrategy,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonList, { children: sortedPhotos.map((photo, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              SortableImageItem,
              {
                photo,
                index
              },
              photo.id || index
            )) })
          }
        )
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: onClose, disabled: isSaving, children: t("Otka탑i") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          onClick: handleSave,
          disabled: isSaving || !hasChanges && sortedPhotos.length < 2,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: checkmarkOutline, slot: "start" }),
            isSaving ? t("훻uvanje...") : t("Sa훾uvaj")
          ]
        }
      ) })
    ] }) })
  ] });
}
function useOnReorder(props) {
  const { callReorderApi, callReorderApiResult } = props;
  const itemsReorderFromTo = useManageDataSelector(getItemsReorderFromTo);
  const debounce = 1500;
  const dispatch = useManageDataDispatch();
  const [toggleReorderDataCheck, setToggleReorderDataCheck] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const callReorder = () => {
      if (itemsReorderFromTo && itemsReorderFromTo.length && !(callReorderApiResult == null ? void 0 : callReorderApiResult.isLoading)) {
        return setTimeout(() => {
          var _a2;
          (_a2 = callReorderApi == null ? void 0 : callReorderApi(itemsReorderFromTo)) == null ? void 0 : _a2.then((response) => {
            if ("data" in response) {
              if (response.data.success) {
                setToggleReorderDataCheck(!toggleReorderDataCheck);
              }
            }
          });
          dispatch(resetReorderFromTo());
        }, debounce);
      }
      return void 0;
    };
    const timeout = callReorder();
    return () => timeout ? clearTimeout(timeout) : void 0;
  }, [itemsReorderFromTo, toggleReorderDataCheck]);
}
const resizeImageToFullHD = async (file) => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      reject(new Error("Could not get canvas context"));
      return;
    }
    img.onload = () => {
      const { width, height } = img;
      const maxWidth = 1920;
      const maxHeight = 1080;
      let newWidth = width;
      let newHeight = height;
      if (width > maxWidth || height > maxHeight) {
        const aspectRatio = width / height;
        if (width > height) {
          newWidth = Math.min(width, maxWidth);
          newHeight = newWidth / aspectRatio;
          if (newHeight > maxHeight) {
            newHeight = maxHeight;
            newWidth = newHeight * aspectRatio;
          }
        } else {
          newHeight = Math.min(height, maxHeight);
          newWidth = newHeight * aspectRatio;
          if (newWidth > maxWidth) {
            newWidth = maxWidth;
            newHeight = newWidth / aspectRatio;
          }
        }
      }
      canvas.width = newWidth;
      canvas.height = newHeight;
      ctx.drawImage(img, 0, 0, newWidth, newHeight);
      canvas.toBlob(
        (blob) => {
          if (blob) {
            const resizedFile = new File([blob], file.name, {
              type: file.type,
              lastModified: file.lastModified
            });
            resolve(resizedFile);
          } else {
            reject(new Error("Could not create blob from canvas"));
          }
        },
        file.type,
        0.9
        // Quality (0.9 = 90%)
      );
    };
    img.onerror = () => {
      reject(new Error("Could not load image"));
    };
    img.src = URL.createObjectURL(file);
  });
};
const resizeImagesToFullHD = async (files) => {
  const resizePromises = files.map((file) => resizeImageToFullHD(file));
  return Promise.all(resizePromises);
};
function PhotoUploader(props) {
  var _a2, _b2;
  const { error, label } = props;
  const { register: register2, control } = props;
  const [isManageListModalOpen, setIsManageListModalOpen] = React.useState(false);
  const [isSortModalOpen, setIsSortModalOpen] = React.useState(false);
  const {
    handleAddedPhotos,
    handleReorderImages,
    handleRemovedPhotos,
    handleUploadImages
  } = props.handlers;
  const handleOnSortAction = () => {
    setIsSortModalOpen(true);
  };
  const handleSortSave = async (reorderData) => {
    if (handleReorderImages) {
      await handleReorderImages(reorderData);
    }
  };
  const { reorderImagesResult, photos } = props;
  const { oneImage, cropAspectRatio } = props;
  const maxPhotos = oneImage ? 1 : (_a2 = props.maxPhotos) != null ? _a2 : 20;
  const maxSize = (_b2 = props.maxSize) != null ? _b2 : 10 * 1024 * 1024;
  const photoEditorRef = reactExports.useRef(null);
  const fileInputRef = reactExports.useRef(null);
  const dispatch = useManageDataDispatch();
  const manageDataItems = useManageDataSelector(getManageItems);
  const maxSortOrder = useManageDataSelector(manageItemsMaxSortOrder);
  const images = reactExports.useMemo(
    () => {
      var _a3;
      return (_a3 = manageDataItems == null ? void 0 : manageDataItems.map((manageDataItem) => manageDataItem.image)) != null ? _a3 : [];
    },
    [manageDataItems]
  );
  useOnReorder({
    callReorderApi: handleReorderImages,
    callReorderApiResult: reorderImagesResult
  });
  const handleSelectFile = async () => {
    var _a3, _b3, _c2, _d2;
    let files = Object.values((_b3 = (_a3 = fileInputRef == null ? void 0 : fileInputRef.current) == null ? void 0 : _a3.files) != null ? _b3 : []);
    const imagesLength = oneImage ? 0 : images.length;
    if (files.length && imagesLength + files.length <= maxPhotos) {
      files = files.slice(0, maxPhotos - imagesLength);
      try {
        const resizedFiles = await resizeImagesToFullHD(files);
        const manageDataItems2 = [
          ...Object.values(resizedFiles).map((file, index) => ({
            sortOrder: maxSortOrder + index + 1,
            index: imagesLength + index,
            image: {
              index: imagesLength + index,
              name: file.name,
              url: URL.createObjectURL(file)
            },
            label: file.name
          }))
        ];
        if (oneImage) {
          dispatch(setManageDataItems(manageDataItems2));
        } else {
          dispatch(addManageDataItems(manageDataItems2));
        }
        (_c2 = photoEditorRef == null ? void 0 : photoEditorRef.current) == null ? void 0 : _c2.setGalleryStep(imagesLength);
        setTimeout(() => {
          var _a4, _b4, _c3;
          handleAddedPhotos == null ? void 0 : handleAddedPhotos(resizedFiles, maxSortOrder);
          if ((_a4 = fileInputRef.current) == null ? void 0 : _a4.files) {
            fileInputRef.current.value = "";
          }
          (_c3 = (_b4 = photoEditorRef == null ? void 0 : photoEditorRef.current) == null ? void 0 : _b4.handleAutoCrop) == null ? void 0 : _c3.call(_b4);
        });
      } catch (error2) {
        console.error("Error resizing images:", error2);
        const manageDataItems2 = [
          ...Object.values(files).map((file, index) => ({
            sortOrder: maxSortOrder + index + 1,
            index: imagesLength + index,
            image: {
              index: imagesLength + index,
              name: file.name,
              url: URL.createObjectURL(file)
            },
            label: file.name
          }))
        ];
        if (oneImage) {
          dispatch(setManageDataItems(manageDataItems2));
        } else {
          dispatch(addManageDataItems(manageDataItems2));
        }
        (_d2 = photoEditorRef == null ? void 0 : photoEditorRef.current) == null ? void 0 : _d2.setGalleryStep(imagesLength);
        setTimeout(() => {
          var _a4, _b4, _c3;
          handleAddedPhotos == null ? void 0 : handleAddedPhotos(files, maxSortOrder);
          if ((_a4 = fileInputRef.current) == null ? void 0 : _a4.files) {
            fileInputRef.current.value = "";
          }
          (_c3 = (_b4 = photoEditorRef == null ? void 0 : photoEditorRef.current) == null ? void 0 : _b4.handleAutoCrop) == null ? void 0 : _c3.call(_b4);
        });
      }
    }
  };
  const handleAddPhotos = () => {
    setTimeout(() => {
      var _a3;
      return (_a3 = fileInputRef == null ? void 0 : fileInputRef.current) == null ? void 0 : _a3.click();
    }, 200);
  };
  const canAddPhotos = oneImage || images.length < maxPhotos;
  const oneImageAddPhotoTitle = images.length ? t("Izmeni sliku") : t("Dodaj sliku");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          ref: fileInputRef,
          hidden: true,
          type: "file",
          accept: "image/*",
          multiple: !oneImage,
          onChange: handleSelectFile
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { className: "actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "start", className: "pl-4", children: label }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonButton,
          {
            color: "medium",
            onClick: handleAddPhotos,
            disabled: !canAddPhotos,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline }),
              oneImage ? oneImageAddPhotoTitle : t("Dodaj slike")
            ]
          }
        ) })
      ] }) }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { position: "relative" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => {
          const photosWithoutId = (field.value || []).filter(
            (photo) => !(photo == null ? void 0 : photo.id) || photo.id === null || photo.id === void 0
          );
          const pendingUploadCount = photosWithoutId.length;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            PhotoEditor$1,
            {
              ref: photoEditorRef,
              galleryProps: {
                handleOnManageAction: () => {
                  setIsManageListModalOpen(true);
                },
                handleOnSortAction,
                handleRemoveImages: handleRemovedPhotos,
                maxSize,
                pendingUploadCount,
                onUploadClick: async () => {
                  if (pendingUploadCount > 0 && handleUploadImages) {
                    await handleUploadImages();
                  }
                }
              },
              photos,
              onChangedPhotos: field.onChange,
              photoAspectRatio: cropAspectRatio
            }
          );
        }
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ManageListModal,
      {
        open: isManageListModalOpen,
        onHandleClose: () => setIsManageListModalOpen(false),
        manageListProps: {
          handleCallAction: (manageDataAction) => {
            switch (manageDataAction.type) {
              case ItemsActions.Remove: {
                const images2 = Array.isArray(manageDataAction.data) ? manageDataAction.data.map((item) => item.image) : [manageDataAction.data.image];
                if (images2.length) {
                  return new Promise((resolve) => {
                    var _a3;
                    (_a3 = handleRemovedPhotos == null ? void 0 : handleRemovedPhotos(images2)) == null ? void 0 : _a3.then(() => {
                      resolve();
                    });
                  });
                }
                break;
              }
            }
          }
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SortImagesModal,
      {
        open: isSortModalOpen,
        photos: photos || [],
        onClose: () => setIsSortModalOpen(false),
        onSave: handleSortSave
      }
    )
  ] });
}
const PhotoUploader$1 = withManageDataWrapper(PhotoUploader);
let appTimezone = "Europe/Belgrade";
const utcTimezone = "UTC";
let cachedDate = null;
let cachedHour = -1;
const setAppTimezone = (timezone) => {
  appTimezone = timezone;
};
const getAppTimezone = () => {
  return appTimezone;
};
const getCurrentDateString = (tz) => {
  const timezone = tz || getAppTimezone();
  const now = /* @__PURE__ */ new Date();
  const currentHour = now.getHours();
  if (cachedDate && cachedHour === currentHour) {
    return cachedDate;
  }
  const dateInTimezone = formatInTimeZone(now, timezone, "yyyy-MM-dd");
  cachedDate = dateInTimezone;
  cachedHour = currentHour;
  return cachedDate;
};
const toUtc = (timeString, tz) => {
  const timezone = getAppTimezone();
  const today = /* @__PURE__ */ new Date();
  const timeParts = timeString.split(":");
  const hours = parseInt(timeParts[0], 10);
  const minutes = parseInt(timeParts[1], 10);
  const seconds = timeParts[2] ? parseInt(timeParts[2], 10) : 0;
  const localDateTime = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate(),
    hours,
    minutes,
    seconds
  );
  const utcDateTime = fromZonedTime(localDateTime, timezone);
  return formatInTimeZone(utcDateTime, utcTimezone, "HH:mm:ss");
};
const fromUtc = (utcTimeString, tz) => {
  const timezone = getAppTimezone();
  const currentDate = getCurrentDateString(timezone);
  const utcDate = parseISO("".concat(currentDate, "T").concat(utcTimeString, "Z"));
  return formatInTimeZone(utcDate, timezone, "HH:mm:ss");
};
const fromUtcHM = (utcTimeString, tz) => {
  const timezone = getAppTimezone();
  const timeWithSeconds = utcTimeString.split(":").length === 2 ? "".concat(utcTimeString, ":00") : utcTimeString;
  const currentDateUtc = getCurrentDateString(timezone);
  const utcDate = parseISO("".concat(currentDateUtc, "T").concat(timeWithSeconds, "Z"));
  return formatInTimeZone(utcDate, timezone, "HH:mm");
};
const toLocalISOStringForIonDatetime = (utcDateTimeString, tz) => {
  const timezone = getAppTimezone();
  const utcDate = parseISO(utcDateTimeString);
  const localDate = toZonedTime(utcDate, timezone);
  return localDate.toISOString();
};
const fromUtcDateTimeToTime = (utcDateTime, tz) => {
  const timezone = getAppTimezone();
  const localDate = toZonedTime(utcDateTime, timezone);
  return format(localDate, "HH:mm");
};
const parseUtcDate = (utcDateString, tz) => {
  const dateUtc = parseISO(utcDateString);
  if (!tz) {
    const dateFormatted2 = formatInTimeZone(dateUtc, utcTimezone, "yyyy-MM-dd");
    return { date: dateUtc, dateFormatted: dateFormatted2 };
  }
  const timezone = tz;
  const dateInTz = toZonedTime(dateUtc, timezone);
  const dateFormatted = formatInTimeZone(dateUtc, timezone, "yyyy-MM-dd");
  return { date: dateInTz, dateFormatted };
};
const getUtcDateFormattedInTz = (utcDateString, tz) => {
  const timezone = getAppTimezone();
  const parsedDate = parseISO(utcDateString);
  return formatInTimeZone(parsedDate, timezone, "yyyy-MM-dd");
};
const daysOfWeek = {
  mon: {
    label: "Pon",
    key: "mon"
  },
  tue: {
    label: "Uto",
    key: "tue",
    prevKey: "mon"
  },
  wed: {
    label: "Sre",
    key: "wed",
    prevKey: "tue"
  },
  thu: {
    label: "훻et",
    key: "thu",
    prevKey: "wed"
  },
  fri: {
    label: "Pet",
    key: "fri",
    prevKey: "thu"
  },
  sat: {
    label: "Sub",
    key: "sat",
    prevKey: "fri"
  },
  sun: {
    label: "Ned",
    key: "sun",
    prevKey: "sat",
    color: "danger"
  }
};
const defaultWorkTimeFrom = "2023-01-01T09:00:00";
const defaultWorkTimeTo = "2023-01-01T22:00:00";
const dayOfWeeksValues = Object.values(daysOfWeek);
const getSelectedWorkingHoursLabel = (selectedDays) => {
  const daysOfWeekArr = dayOfWeeksValues;
  let firstDay;
  let lastDay;
  const selectedDaysFormatted = [];
  const appendFirstAndLastDay = (firstDay2, lastDay2) => {
    const firstDayLabel = daysOfWeek[firstDay2].label;
    const lastDayLabel = daysOfWeek[lastDay2].label;
    if (firstDay2 === lastDay2) {
      selectedDaysFormatted.push(firstDayLabel);
    } else if (firstDay2 !== daysOfWeek[lastDay2].prevKey) {
      selectedDaysFormatted.push("".concat(firstDayLabel, " - ").concat(lastDayLabel));
    } else {
      selectedDaysFormatted.push(firstDayLabel, lastDayLabel);
    }
  };
  daysOfWeekArr.forEach((day) => {
    if (selectedDays.includes(day.key)) {
      if (!firstDay) {
        firstDay = day.key;
        lastDay = day.key;
      } else if (lastDay === day.prevKey) {
        lastDay = day.key;
      }
    } else if (firstDay && lastDay) {
      appendFirstAndLastDay(firstDay, lastDay);
      firstDay = lastDay = void 0;
    }
  });
  if (firstDay && lastDay) {
    appendFirstAndLastDay(firstDay, lastDay);
  }
  return selectedDaysFormatted.join(", ");
};
const formatWorkingTime = (workingTime) => workingTime ? format(parseISO(workingTime), "HH:mm") : void 0;
const timeToDateTime = (time) => {
  const date = parseISO(time);
  if (isValid(date)) {
    return time;
  }
  const currentTime = /* @__PURE__ */ new Date();
  const [hours, minutes] = time.split(":");
  currentTime.setHours(Number(hours));
  currentTime.setMinutes(Number(minutes));
  return format(currentTime, "yyyy-MM-dd'T'HH:mm:ss");
};
const dateTimeToTime = (dateTime) => {
  const date = parseISO(dateTime);
  if (isValid(date)) {
    return format(date, "HH:mm:ss");
  }
  return dateTime;
};
const isWebPlatform = isPlatform("desktop");
const isIos = isPlatform("ios");
const isPwa = isPlatform("pwa");
isPlatform("capacitor");
const getIsWebview = (userAgent) => {
  return /webview|wv|ip((?!.*Safari)|(?=.*like Safari))/i.test(userAgent);
};
const tabPosition = isWebPlatform ? "top" : "bottom";
const isWebView = (window == null ? void 0 : window.navigator) && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) ? getIsWebview(window.navigator.userAgent) : true;
const ionIconList = [];
const ionIcons = {};
const fetchIonIconsList = () => {
  if (!ionIconList.length) {
    ionIconList.push(
      ...Object.keys(icons).map((name, index) => {
        ionIcons[name] = {
          value: icons[name],
          key: name,
          index
        };
        return ionIcons[name];
      })
    );
  }
  return ionIconList;
};
const getIonIconByName = (name) => {
  if (!ionIconList.length) {
    fetchIonIconsList();
  }
  return ionIcons[name];
};
const generateSlug = (str) => {
  str = str.replace(/^\s+|\s+$/g, "");
  str = str.toLowerCase();
  const from = "횪찼채창챔챕챘챗챙챠챦챤챵처철척첫첬체청챰챌훾훶휃큄탑쨌/_,:;";
  const to = "aaaaeeeeiiiioooouuuuncccdsz------";
  for (let i = 0, l2 = from.length; i < l2; i++) {
    str = str.replace(new RegExp(from.charAt(i), "g"), to.charAt(i));
  }
  str = str.replace(/[^a-z0-9 -]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-");
  return str;
};
function DataURIToBlob(dataURI) {
  const splitDataURI = dataURI.split(",");
  const byteString = splitDataURI[0].indexOf("base64") >= 0 ? atob(splitDataURI[1]) : decodeURI(splitDataURI[1]);
  const mimeString = splitDataURI[0].split(":")[1].split(";")[0];
  const ia = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
  return new Blob([ia], { type: mimeString });
}
function createFormData(body, files) {
  const form = new FormData();
  const bodyKeys = Object.keys(body);
  bodyKeys.forEach((key) => {
    const item = body[key];
    if (files[key] && typeof item === "string") {
      const file = DataURIToBlob(item);
      form.append(key, file, files[key]);
    } else {
      form.append(key, item);
    }
  });
  return form;
}
const userHasRoles = (user, roles, all = false) => {
  var _a2;
  const userGroups = (_a2 = user.groups) == null ? void 0 : _a2.map((group) => group.code);
  return all ? roles.every((role) => userGroups == null ? void 0 : userGroups.includes(role)) : roles.some((role) => userGroups == null ? void 0 : userGroups.includes(role));
};
function useDefaultProps(props, defaultProps2) {
  return {
    ...defaultProps2,
    ...props
  };
}
const fixUrlPath = (url) => url[url.length - 1] !== "/" ? url : url.slice(0, url.length - 1);
const useAppDispatch$1 = () => useDispatch();
const useAppSelector$1 = useSelector;
const commonSharedApi = sharedApi.injectEndpoints({
  endpoints: (build) => ({
    uploadFile: build.mutation({
      query: (body) => ({
        url: body.meta.apiUrl,
        method: "POST",
        body: body.data
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    deleteFile: build.mutation({
      query: ({ apiUrl, attachmentId, ...rest }) => ({
        url: apiUrl,
        method: "DELETE",
        body: { attachmentId, ...rest }
        // Include all additional requestData
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    reorderFile: build.mutation({
      query: ({ apiUrl, reorderData, ...rest }) => ({
        url: apiUrl,
        method: "POST",
        body: { reorderData, ...rest }
        // Include all additional requestData
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    getCountries: build.query({
      query: () => ({
        url: "/countries"
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    getCities: build.query({
      query: (params) => ({
        url: "".concat(sharedApiPrefix, "/cities"),
        params: params != null ? params : {}
      }),
      transformResponse: transformStandardResponseToCamelCase
    })
  })
});
const {
  useUploadFileMutation,
  useDeleteFileMutation,
  useReorderFileMutation
} = commonSharedApi;
const useShowNotification = (options) => {
  const [presentToast, dismiss] = useIonToast();
  const memoOptions = reactExports.useMemo(() => options, []);
  const showNotification = reactExports.useCallback(
    (overrideOptions) => {
      return presentToast({
        position: "bottom",
        duration: 1500,
        ...memoOptions,
        ...overrideOptions
      });
    },
    [presentToast, memoOptions]
  );
  return [showNotification, dismiss];
};
const useFileUploader = (uploadRequestData, callbacks, alertOptions) => {
  const [presentLoader, dismiss] = useIonLoading();
  const [showNotification] = useShowNotification();
  const hasShownErrorRef = reactExports.useRef(false);
  const [filesDataToUpload, setFilesDataToUpload] = reactExports.useState([]);
  const [currentFileIndex, setCurrentFileIndex] = reactExports.useState(
    void 0
  );
  const [retryCount, setRetryCount] = reactExports.useState(0);
  const [fileKey, setFileKey] = reactExports.useState("file");
  const [isUploading, setIsUploading] = reactExports.useState(false);
  const retryCountLimit = 10;
  const { apiUrl, uploadType, bodyData, skipUpload } = uploadRequestData;
  const [uploadFile, uploadFileResult] = useUploadFileMutation();
  const { data, isSuccess, isError } = uploadFileResult;
  const setFiles = (files, fileKey2) => {
    setFilesDataToUpload(files != null ? files : []);
    if (fileKey2) {
      setFileKey(fileKey2);
    }
  };
  const handleUploadFile = async () => {
    if (apiUrl && uploadType && currentFileIndex !== void 0 && !skipUpload) {
      uploadFile({
        meta: {
          apiUrl,
          uploadType
        },
        data: createFormData(
          {
            ...bodyData,
            ...filesDataToUpload[currentFileIndex]
          },
          { [fileKey]: fileKey + currentFileIndex }
        )
      });
    }
  };
  const resetUploader = () => {
    setCurrentFileIndex(void 0);
    setFilesDataToUpload([]);
    setRetryCount(0);
    setIsUploading(false);
    hasShownErrorRef.current = false;
    dismiss();
  };
  reactExports.useEffect(() => {
    if (filesDataToUpload.length && !isUploading) {
      setIsUploading(true);
      presentLoader({
        message: "Uploading files..."
      });
      setCurrentFileIndex(0);
    }
  }, [filesDataToUpload, isUploading]);
  reactExports.useEffect(() => {
    if (currentFileIndex === void 0) {
      return;
    }
    if (currentFileIndex < filesDataToUpload.length) {
      handleUploadFile();
    }
  }, [currentFileIndex]);
  reactExports.useEffect(() => {
    var _a2, _b2, _c2;
    if (isSuccess && data) {
      if (currentFileIndex !== void 0 && currentFileIndex < filesDataToUpload.length - 1) {
        (_a2 = callbacks == null ? void 0 : callbacks.onUploadSuccessful) == null ? void 0 : _a2.call(
          callbacks,
          filesDataToUpload[currentFileIndex],
          data.data
        );
        setCurrentFileIndex(currentFileIndex + 1);
      } else {
        if (currentFileIndex !== void 0) {
          (_b2 = callbacks == null ? void 0 : callbacks.onUploadSuccessful) == null ? void 0 : _b2.call(
            callbacks,
            filesDataToUpload[currentFileIndex],
            data.data
          );
        }
        (_c2 = callbacks == null ? void 0 : callbacks.onSuccessful) == null ? void 0 : _c2.call(callbacks);
        resetUploader();
      }
    } else if (isSuccess && retryCount < retryCountLimit) {
      handleUploadFile();
      setRetryCount(retryCount + 1);
    }
  }, [isSuccess, uploadFileResult, retryCount]);
  reactExports.useEffect(() => {
    var _a2;
    if (isError && !hasShownErrorRef.current) {
      hasShownErrorRef.current = true;
      resetUploader();
      showNotification({
        message: t("Gre큄ka pri upload-u") || "Error uploading",
        color: "danger",
        duration: 3e3
      });
      (_a2 = callbacks == null ? void 0 : callbacks.onError) == null ? void 0 : _a2.call(callbacks);
    }
  }, [isError, t, showNotification]);
  return { setFiles };
};
const useFileDeleter = (deleteRequestData, callbacks, alertOptions) => {
  const [presentLoader, dismiss] = useIonLoading();
  const [showNotification] = useShowNotification();
  const hasShownErrorRef = reactExports.useRef(false);
  const [photosToDelete, setPhotosToDelete] = reactExports.useState([]);
  const [currentPhotoIndex, setCurrentPhotoIndex] = reactExports.useState(void 0);
  const [retryCount, setRetryCount] = reactExports.useState(0);
  const [isDeleting, setIsDeleting] = reactExports.useState(false);
  const retryCountLimit = 10;
  const { apiUrl, deleteRequestData: requestData } = deleteRequestData;
  const [deleteFile, deleteFileResult] = useDeleteFileMutation();
  const { data, isSuccess, isError } = deleteFileResult;
  const deletePhotos = (photoIds) => {
    setPhotosToDelete(photoIds != null ? photoIds : []);
  };
  const handleDeleteFile = async () => {
    if (apiUrl && currentPhotoIndex !== void 0) {
      deleteFile({
        apiUrl,
        attachmentId: photosToDelete[currentPhotoIndex],
        ...requestData || {}
      });
    }
  };
  const resetDeleter = () => {
    setCurrentPhotoIndex(void 0);
    setPhotosToDelete([]);
    setRetryCount(0);
    setIsDeleting(false);
    hasShownErrorRef.current = false;
    dismiss();
  };
  reactExports.useEffect(() => {
    if (photosToDelete.length && !isDeleting) {
      setIsDeleting(true);
      presentLoader({
        message: "Deleting files..."
      });
      setCurrentPhotoIndex(0);
    }
  }, [photosToDelete, isDeleting]);
  reactExports.useEffect(() => {
    if (currentPhotoIndex === void 0) {
      return;
    }
    if (currentPhotoIndex < photosToDelete.length) {
      handleDeleteFile();
    }
  }, [currentPhotoIndex]);
  reactExports.useEffect(() => {
    var _a2, _b2, _c2;
    if (isSuccess && data) {
      if (currentPhotoIndex !== void 0 && currentPhotoIndex < photosToDelete.length - 1) {
        (_a2 = callbacks == null ? void 0 : callbacks.onDeleteSuccessful) == null ? void 0 : _a2.call(callbacks, photosToDelete[currentPhotoIndex]);
        setCurrentPhotoIndex(currentPhotoIndex + 1);
      } else {
        if (currentPhotoIndex !== void 0) {
          (_b2 = callbacks == null ? void 0 : callbacks.onDeleteSuccessful) == null ? void 0 : _b2.call(callbacks, photosToDelete[currentPhotoIndex]);
        }
        (_c2 = callbacks == null ? void 0 : callbacks.onSuccessful) == null ? void 0 : _c2.call(callbacks);
        resetDeleter();
      }
    } else if (isSuccess && retryCount < retryCountLimit) {
      handleDeleteFile();
      setRetryCount(retryCount + 1);
    }
  }, [isSuccess, deleteFileResult, retryCount]);
  reactExports.useEffect(() => {
    var _a2;
    if (isError && !hasShownErrorRef.current) {
      hasShownErrorRef.current = true;
      resetDeleter();
      showNotification({
        message: t("Gre큄ka pri brisanju") || "Error deleting",
        color: "danger",
        duration: 3e3
      });
      (_a2 = callbacks == null ? void 0 : callbacks.onError) == null ? void 0 : _a2.call(callbacks);
    }
  }, [isError, t, showNotification]);
  return { deletePhotos };
};
function GalleryArea({
  field,
  register: register2,
  control,
  error,
  form
}) {
  const { t: t2 } = useTranslation();
  const [showNotification] = useShowNotification();
  const [reorderFile] = useReorderFileMutation();
  const [photos, setPhotos] = reactExports.useState(field.photos || []);
  const [pendingFiles, setPendingFiles] = reactExports.useState([]);
  const [isUploading, setIsUploading] = reactExports.useState(false);
  const uploadValidationFieldName = "_upload_" + register2.name;
  form == null ? void 0 : form.watch(register2.name);
  form ? useWatch({ control: form.control, name: uploadValidationFieldName }) : null;
  form == null ? void 0 : form.formState.errors;
  const { setFiles } = useFileUploader(
    {
      apiUrl: field.uploadUrl,
      uploadType: UploadType.PHOTO,
      bodyData: field.uploadRequestData
      // Merge requestData with upload data
    },
    {
      onUploadSuccessful: (file, uploadedPhoto) => {
        var _a2;
        const newPhoto = {
          id: uploadedPhoto.id,
          url: uploadedPhoto.path,
          name: uploadedPhoto.fileName,
          index: 0
        };
        if (field.oneImage) {
          setPhotos([newPhoto]);
        } else {
          setPhotos((prev) => [...prev, newPhoto]);
        }
        setPendingFiles((prev) => prev.filter((f) => f !== file));
        setIsUploading(false);
        (_a2 = field.onUploadSuccess) == null ? void 0 : _a2.call(field, newPhoto);
      },
      onError: (error2) => {
        var _a2, _b2;
        setIsUploading(false);
        const errorMessage = ((_a2 = error2 == null ? void 0 : error2.data) == null ? void 0 : _a2.message) || (error2 == null ? void 0 : error2.message) || "Upload failed";
        (_b2 = field.onUploadError) == null ? void 0 : _b2.call(field, errorMessage);
      }
    }
  );
  const { deletePhotos } = useFileDeleter(
    {
      apiUrl: field.deleteUrl || "",
      deleteRequestData: field.deleteRequestData
      // Merge requestData with delete data
    },
    {
      onDeleteSuccessful: (photoId) => {
        var _a2;
        setPhotos((prev) => prev.filter((p) => p.id !== photoId));
        (_a2 = field.onDeleteSuccess) == null ? void 0 : _a2.call(field, photoId);
      },
      onError: () => {
        var _a2;
        (_a2 = field.onDeleteError) == null ? void 0 : _a2.call(field, new Error("Delete failed"));
      }
    }
  );
  const handleAddedPhotos = reactExports.useCallback(
    (files) => {
      if (field.uploadBehavior === "immediate") {
        setIsUploading(true);
        setFiles(files.map((file) => ({ file })));
      } else {
        setPendingFiles((prev) => [...prev, ...files]);
      }
    },
    [field.uploadBehavior, setFiles]
  );
  const handleRemovedPhotos = reactExports.useCallback(
    async (photosToRemove) => {
      const photosWithIds = photosToRemove.filter((photo) => photo.id);
      const photosWithoutIds = photosToRemove.filter((photo) => !photo.id);
      photosWithoutIds.forEach((photo) => {
        setPendingFiles(
          (prev) => prev.filter((_, index) => index !== photosToRemove.indexOf(photo))
        );
      });
      if (photosWithIds.length > 0) {
        deletePhotos(photosWithIds.map((photo) => Number(photo.id)));
      }
    },
    [deletePhotos]
  );
  const handleReorderImages = reactExports.useCallback(
    async (reorderData) => {
      var _a2, _b2, _c2;
      try {
        if (field.reorderUrl && reorderData.length > 0) {
          const response = await reorderFile({
            apiUrl: field.reorderUrl,
            reorderData,
            ...field.reorderRequestData || {}
          }).unwrap();
          if (response == null ? void 0 : response.data) {
            const updatedPhotos = Array.isArray(response.data) ? response.data.map((photo, index) => ({
              id: photo.id,
              url: photo.path || photo.url,
              name: photo.fileName || photo.name,
              index
            })) : photos;
            setPhotos(updatedPhotos);
            (_a2 = field.onReorderSuccess) == null ? void 0 : _a2.call(field, updatedPhotos);
          } else {
            (_b2 = field.onReorderSuccess) == null ? void 0 : _b2.call(field, photos);
          }
        }
      } catch (error2) {
        showNotification({
          message: t2("Gre큄ka pri sortiranju slika") || "Error reordering images",
          color: "danger",
          duration: 3e3
        });
        (_c2 = field.onReorderError) == null ? void 0 : _c2.call(
          field,
          error2 instanceof Error ? error2 : new Error(String(error2))
        );
      }
    },
    [
      field.reorderUrl,
      field.reorderRequestData,
      field.onReorderSuccess,
      field.onReorderError,
      showNotification,
      t2,
      photos,
      reorderFile
    ]
  );
  const uploadPendingFiles = reactExports.useCallback(async () => {
    var _a2;
    if (form && pendingFiles.length > 0) {
      setIsUploading(true);
      const formPhotos = form.getValues(register2.name);
      const photosToUpload = ((_a2 = formPhotos == null ? void 0 : formPhotos.filter((photo) => !photo.id)) == null ? void 0 : _a2.map((photo) => ({
        file: photo.url,
        // This is already the cropped image URL
        fileAfterId: photo.fileAfterId
      }))) || [];
      if (photosToUpload.length > 0) {
        setFiles(photosToUpload);
      }
      return new Promise((resolve) => {
        const checkUpload = () => {
          if (pendingFiles.length === 0) {
            resolve();
          } else {
            setTimeout(checkUpload, 100);
          }
        };
        checkUpload();
      });
    }
  }, [pendingFiles, setFiles, form, register2.name]);
  const handlers = reactExports.useMemo(
    () => ({
      handleAddedPhotos: (files, startIndex) => {
        handleAddedPhotos(files);
      },
      handleRemovedPhotos: async (images) => {
        await handleRemovedPhotos(images);
        return { data: { data: null, success: true } };
      },
      handleReorderImages: async (reorderData) => {
        await handleReorderImages(reorderData);
        return { data: { data: null, success: true } };
      },
      handleUploadImages: async () => {
        await uploadPendingFiles();
      }
    }),
    [
      handleAddedPhotos,
      handleRemovedPhotos,
      handleReorderImages,
      uploadPendingFiles
    ]
  );
  reactExports.useEffect(() => {
    if (form && pendingFiles.length > 0 && (form == null ? void 0 : form.formState.isValidating)) {
      uploadPendingFiles();
    }
  }, [
    form == null ? void 0 : form.formState.isSubmitting,
    field.uploadBehavior,
    pendingFiles.length
    // Removed uploadPendingFiles from dependencies to prevent infinite loop
  ]);
  reactExports.useEffect(() => {
    if (field.onFormSave) {
      field.onFormSave();
    }
  }, [field.onFormSave]);
  reactExports.useEffect(() => {
    if (field.onFormError && error) {
      field.onFormError({ [register2.name]: error.message });
    }
  }, [field.onFormError, error, register2.name]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    PhotoUploader$1,
    {
      label: field.label,
      register: register2,
      error,
      control,
      handlers,
      photos,
      oneImage: field.oneImage,
      maxPhotos: field.maxPhotos,
      maxSize: field.maxSize,
      cropAspectRatio: field.cropAspectRatio
    }
  );
}
function CommonIonicTextarea(props) {
  const { label, labelPlacement = "floating", register: register2, error } = props;
  const { itemProps, inputProps, control } = props;
  const { maxlength, rows, translation } = props;
  const handleKeyPress = (event) => {
    if (props.preventEnter && event.key === "Enter") {
      event.preventDefault();
    }
  };
  const textAreaRef = reactExports.useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { ...itemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonTextarea,
          {
            ref: textAreaRef,
            label,
            labelPlacement,
            onIonInput: (event) => field.onChange(event),
            onIonBlur: field.onBlur,
            onKeyPress: handleKeyPress,
            onIonChange: register2.onBlur,
            value: field.value,
            autoGrow: true,
            counter: !!maxlength,
            maxlength,
            rows: rows != null ? rows : 5,
            className: "max-h-[500px] overflow-y-auto",
            ...inputProps,
            children: translation && /* @__PURE__ */ jsxRuntimeExports.jsx(
              TranslationButton,
              {
                translation,
                fieldName: register2.name,
                fieldType: FieldType.TextArea,
                label: label || "",
                currentValue: field.value || ""
              }
            )
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const IonModalExtended = reactExports.forwardRef(
  ({ name, onClose, isPresented, onDidPresent, onDidDismiss, ...props }, ref) => {
    const history = useHistory();
    const handlePresentModal = reactExports.useCallback(
      (event) => {
        if (isPresented === void 0) {
          const params = new URLSearchParams(window.location.search);
          if (!params.has(name)) {
            params.append(name, "show");
            history.push({ search: params.toString() });
          }
        }
        onDidPresent == null ? void 0 : onDidPresent(event);
      },
      [history, name, isPresented, onDidPresent]
    );
    const handleDismissModal = reactExports.useCallback(
      (event) => {
        if (isPresented === void 0) {
          const params = new URLSearchParams(window.location.search);
          if (params.has(name)) {
            history.goBack();
          }
        }
        onDidDismiss == null ? void 0 : onDidDismiss(event);
        onClose();
      },
      [history, name, isPresented, onDidDismiss, onClose]
    );
    reactExports.useEffect(() => {
      const handleBackNavigation = () => {
        const params = new URLSearchParams(window.location.search);
        if (!params.has(name)) {
          onClose();
        }
      };
      window.addEventListener("popstate", handleBackNavigation);
      return () => {
        window.removeEventListener("popstate", handleBackNavigation);
      };
    }, [history, onClose, name]);
    reactExports.useEffect(() => {
      const params = new URLSearchParams(window.location.search);
      if (params.has(name)) {
        params.delete(name);
        history.replace({ search: params.toString() });
      }
    }, [name]);
    reactExports.useEffect(() => {
      if (isPresented === void 0) return;
      const params = new URLSearchParams(window.location.search);
      if (isPresented) {
        if (!params.has(name)) {
          params.append(name, "show");
          history.push({ search: params.toString() });
        }
      } else {
        if (params.has(name)) {
          params.delete(name);
          history.replace({ search: params.toString() });
        }
      }
    }, [isPresented]);
    const propsExtended = {
      onDidPresent: handlePresentModal,
      onDidDismiss: handleDismissModal
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IonModal, { ...props, ...propsExtended, ref });
  }
);
const IonModalExtended$1 = reactExports.memo(IonModalExtended);
function ModalActionButtons({
  onSave,
  onCancel,
  onDelete,
  isSaving = false,
  isDeleting = false,
  isSaveDisabled = false,
  showDelete = false,
  saveText,
  cancelText,
  deleteText,
  saveColor = "primary",
  cancelColor = "dark",
  deleteColor = "danger",
  cancelFill = "clear",
  deleteFill = "clear",
  className = "ion-no-padding"
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { className, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        onClick: onCancel,
        color: cancelColor,
        fill: cancelFill,
        slot: "start",
        className: showDelete ? "pr-2" : "pl-2",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline, slot: "start" }),
          cancelText || t2("Otka탑i")
        ]
      }
    ),
    showDelete && onDelete && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonButton,
      {
        onClick: onDelete,
        color: deleteColor,
        fill: deleteFill,
        slot: "end",
        className: "pl-2",
        disabled: isDeleting,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline, slot: "start" })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        onClick: onSave,
        color: saveColor,
        slot: "end",
        className: "pr-2",
        disabled: isSaving || isSaveDisabled,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "start" }),
          isSaving ? t2("훻uvanje...") : saveText || t2("Sa훾uvaj")
        ]
      }
    )
  ] });
}
function WorkingTimeEditor({
  show,
  handleClose,
  handleSave,
  workingTime,
  modalTitle,
  defaultTimeFrom,
  defaultTimeTo,
  defaultDays
}) {
  var _a2;
  const getDefaultTimeFrom = () => {
    if (workingTime == null ? void 0 : workingTime.timeFromUtc) {
      return timeToDateTime(workingTime.timeFromUtc);
    }
    if (defaultTimeFrom) {
      return "2023-01-01T".concat(defaultTimeFrom, ":00");
    }
    return defaultWorkTimeFrom;
  };
  const getDefaultTimeTo = () => {
    if (workingTime == null ? void 0 : workingTime.timeToUtc) {
      return timeToDateTime(workingTime.timeToUtc);
    }
    if (defaultTimeTo) {
      return "2023-01-01T".concat(defaultTimeTo, ":00");
    }
    return defaultWorkTimeTo;
  };
  const [workingTimeFrom, setWorkingTimeFrom] = reactExports.useState(getDefaultTimeFrom());
  const [workingTimeTo, setWorkingTimeTo] = reactExports.useState(getDefaultTimeTo());
  const [selectedDays, setSelectedDays] = reactExports.useState(
    (workingTime == null ? void 0 : workingTime.daysCodes) || defaultDays || []
  );
  const [slotName, setSlotName] = reactExports.useState((_a2 = workingTime == null ? void 0 : workingTime.name) != null ? _a2 : "");
  const daysOfWeekArr = Object.values(daysOfWeek);
  const handleSelected = (key) => () => {
    if (!selectedDays.includes(key)) {
      setSelectedDays([...selectedDays, key]);
    } else {
      setSelectedDays(selectedDays.filter((day) => day !== key));
    }
  };
  const isSelected = (key) => selectedDays.includes(key);
  const canSave = workingTimeFrom && workingTimeTo && selectedDays.length;
  const selectedWorkingHoursLabel = reactExports.useMemo(
    () => getSelectedWorkingHoursLabel(selectedDays),
    [selectedDays]
  );
  const slotNameReal = slotName.length ? slotName : selectedWorkingHoursLabel;
  const resetData = () => {
    setWorkingTimeFrom(getDefaultTimeFrom());
    setWorkingTimeTo(getDefaultTimeTo());
    setSelectedDays(defaultDays || []);
    setSlotName("");
  };
  const onSave = () => {
    if (canSave) {
      const timeFromUtc = dateTimeToTime(workingTimeFrom);
      const timeToUtc = dateTimeToTime(workingTimeTo);
      handleSave == null ? void 0 : handleSave({
        name: slotNameReal,
        daysCodes: selectedDays,
        timeFromUtc,
        timeToUtc
      });
      resetData();
    }
  };
  const onClose = () => {
    handleClose();
    resetData();
  };
  const handleDateChangeFrom = (event) => {
    const newDate = event.detail.value;
    setWorkingTimeFrom(newDate);
  };
  const handleDateChangeTo = (event) => {
    const newDate = event.detail.value;
    setWorkingTimeTo(newDate);
  };
  const workingTimeFromFormatted = reactExports.useMemo(
    () => formatWorkingTime(workingTimeFrom),
    [workingTimeFrom]
  );
  const workingTimeToFormatted = reactExports.useMemo(
    () => formatWorkingTime(workingTimeTo),
    [workingTimeTo]
  );
  const handleSlotNameChange = (event) => {
    var _a3;
    const newSlotName = (_a3 = event.detail.value) != null ? _a3 : "";
    setSlotName(newSlotName);
  };
  reactExports.useEffect(() => {
    var _a3, _b2;
    if (workingTime) {
      setWorkingTimeFrom(timeToDateTime(workingTime.timeFromUtc));
      setWorkingTimeTo(timeToDateTime(workingTime.timeToUtc));
      setSelectedDays((_a3 = workingTime.daysCodes) != null ? _a3 : workingTime.days);
      const nameLabel = getSelectedWorkingHoursLabel(
        (_b2 = workingTime.daysCodes) != null ? _b2 : workingTime.days
      );
      setSlotName(nameLabel === workingTime.name ? "" : workingTime.name);
    }
  }, [workingTime]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonModalExtended$1,
    {
      name: "working-time-editor",
      isOpen: show,
      onClose,
      ...!isWebPlatform && {
        initialBreakpoint: 1,
        breakpoints: [0, 1]
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: workingTime ? modalTitle ? t("Izmena") + " " + modalTitle.toLowerCase() : t("Izmena radnog vremena") : modalTitle || t("Novo radno vreme") }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonGrid, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCol, { style: { textAlign: "-webkit-center" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("Vreme od") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonDatetime,
                {
                  itemType: "time",
                  presentation: "time",
                  preferWheel: true,
                  hourCycle: "h24",
                  minuteValues: "0,15,30,45",
                  onIonChange: handleDateChangeFrom,
                  value: workingTimeFrom
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCol, { style: { textAlign: "-webkit-center" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("Vreme do") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonDatetime,
                {
                  itemType: "time",
                  presentation: "time",
                  preferWheel: true,
                  hourCycle: "h24",
                  minuteValues: "0,15,30,45",
                  onIonChange: handleDateChangeTo,
                  value: workingTimeTo
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: daysOfWeekArr.map((day) => {
            var _a3;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonButton,
              {
                mode: "ios",
                fill: !isSelected(day.key) ? "outline" : "solid",
                color: "dark",
                onClick: handleSelected(day.key),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { color: (_a3 = day.color) != null ? _a3 : void 0, children: day.label }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ConditionalComponent,
                    {
                      condition: isSelected(day.key),
                      render: () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1 text-green-500 font-bold", children: "쐯" }),
                      renderElse: () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1 text-red-500 font-bold", children: "쐵" })
                    }
                  )
                ]
              }
            ) }, day.key);
          }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonFooter, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonGrid, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { size: "6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: selectedWorkingHoursLabel }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                workingTimeFromFormatted != null ? workingTimeFromFormatted : t("from"),
                " - ",
                workingTimeToFormatted != null ? workingTimeToFormatted : t("to")
              ] })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { size: "6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonInput,
              {
                label: "Naziv",
                labelPlacement: "floating",
                onIonChange: handleSlotNameChange,
                value: slotName.length ? slotName : selectedWorkingHoursLabel
              }
            ) }) })
          ] }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ModalActionButtons,
            {
              onSave,
              onCancel: onClose,
              isSaveDisabled: !canSave
            }
          )
        ] })
      ]
    }
  );
}
function WorkingTimeListItem({
  workingTime,
  editWorkingTime,
  handleRemoveItem
}) {
  const slideRef = reactExports.useRef(null);
  const ionItemOptionsRef = reactExports.useRef(null);
  const showItemActions = (event) => {
    var _a2;
    event.stopPropagation();
    (_a2 = slideRef.current) == null ? void 0 : _a2.open("end");
  };
  const handleSlotClick = (event) => {
    var _a2;
    if (event.target && event.target !== ionItemOptionsRef.current) {
      return;
    }
    (_a2 = slideRef.current) == null ? void 0 : _a2.close();
  };
  const onRemoveItem = () => {
    var _a2;
    handleRemoveItem == null ? void 0 : handleRemoveItem(workingTime);
    (_a2 = slideRef.current) == null ? void 0 : _a2.close();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItemSliding, { ref: slideRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonItem,
      {
        button: true,
        onClick: editWorkingTime(workingTime),
        detail: false,
        className: "ion-no-padding",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "start", children: workingTime.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { slot: "end", children: [
            formatWorkingTime(timeToDateTime(workingTime.timeFromUtc)),
            " -",
            " ",
            formatWorkingTime(timeToDateTime(workingTime.timeToUtc))
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonButton,
            {
              slot: "end",
              color: "default",
              onClick: showItemActions,
              size: "default",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronForwardOutline, className: "p-1" })
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonItemOptions,
      {
        side: "end",
        onClick: handleSlotClick,
        ref: ionItemOptionsRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonItemOption, { color: "danger", onClick: onRemoveItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "icon-only", icon: trashOutline }) })
      }
    )
  ] });
}
const transformWorkingHoursBack = (workingHours) => {
  return workingHours;
};
function WorkingTimeList({
  workingHours,
  onChange,
  label,
  addNewLabel,
  modalTitle,
  defaultTimeFrom,
  defaultTimeTo,
  defaultDays
}) {
  const [selectedWorkingTime, setSelectedWorkingTime] = reactExports.useState(void 0);
  const [showWorkingTimeEditor, setShowWorkingTimeEditor] = reactExports.useState(false);
  const handleClose = () => {
    setShowWorkingTimeEditor(false);
    selectedWorkingTime && setSelectedWorkingTime(void 0);
  };
  const handleOnChange = (workingHours2) => {
    onChange(transformWorkingHoursBack(workingHours2));
  };
  const handleSave = (workingTime) => {
    if (selectedWorkingTime) {
      const index = workingHours.findIndex(
        (wt) => wt.name === selectedWorkingTime.name
      );
      if (index > -1) {
        workingHours[index] = workingTime;
        handleOnChange([...workingHours]);
      }
    } else {
      handleOnChange([...workingHours, workingTime]);
    }
    setShowWorkingTimeEditor(false);
    selectedWorkingTime && setSelectedWorkingTime(void 0);
  };
  const handleRemove = (workingTime) => {
    const index = workingHours.findIndex((wt) => wt.name === workingTime.name);
    if (index > -1) {
      workingHours.splice(index, 1);
      handleOnChange([...workingHours]);
    }
  };
  const addWorkingTime = () => {
    selectedWorkingTime && setSelectedWorkingTime(void 0);
    setShowWorkingTimeEditor(true);
  };
  const editWorkingTime = (workingTime) => () => {
    setSelectedWorkingTime(workingTime);
    setShowWorkingTimeEditor(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { className: "w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { className: "py-2 border-b-2", children: label }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { button: true, onClick: addWorkingTime, className: "ion-no-padding", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline, className: "pr-2" }),
        addNewLabel || t("Dodaj novo radno vreme")
      ] }),
      workingHours.map((workingTime, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        WorkingTimeListItem,
        {
          workingTime,
          editWorkingTime,
          handleRemoveItem: handleRemove
        },
        index
      ))
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      WorkingTimeEditor,
      {
        show: showWorkingTimeEditor,
        workingTime: selectedWorkingTime,
        handleClose,
        handleSave,
        modalTitle,
        defaultTimeFrom,
        defaultTimeTo,
        defaultDays
      }
    )
  ] });
}
const transformWorkingHours = (workingHours) => {
  return workingHours;
};
function CommonWorkingTime(props) {
  const {
    register: register2,
    control,
    error,
    label,
    addNewLabel,
    modalTitle,
    defaultTimeFrom,
    defaultTimeTo,
    defaultDays
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field: { onChange, value } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          WorkingTimeList,
          {
            workingHours: value ? transformWorkingHours(value) : [],
            onChange,
            label,
            addNewLabel,
            modalTitle,
            defaultTimeFrom,
            defaultTimeTo,
            defaultDays
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
function WorkingTimeItem({
  workingTime,
  onChange,
  label,
  addNewLabel
}) {
  var _a2;
  const [showWorkingTimeEditor, setShowWorkingTimeEditor] = reactExports.useState(false);
  const [currentWorkingTime, setCurrentWorkingTime] = reactExports.useState(void 0);
  const handleClose = () => {
    setShowWorkingTimeEditor(false);
    setCurrentWorkingTime(void 0);
  };
  const handleSave = (newWorkingTime) => {
    onChange(newWorkingTime);
    setShowWorkingTimeEditor(false);
    setCurrentWorkingTime(void 0);
  };
  const handleAddWorkingTime = () => {
    setCurrentWorkingTime(void 0);
    setShowWorkingTimeEditor(true);
  };
  const handleEditWorkingTime = () => {
    setCurrentWorkingTime(workingTime);
    setShowWorkingTimeEditor(true);
  };
  workingTime ? getSelectedWorkingHoursLabel((_a2 = workingTime.daysCodes) != null ? _a2 : workingTime.days) : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-2 border-b-2", children: label }),
      workingTime ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonItem,
        {
          button: true,
          onClick: handleEditWorkingTime,
          detail: false,
          className: "ion-no-padding",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "start", children: workingTime.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { slot: "end", children: [
              formatWorkingTime(timeToDateTime(workingTime.timeFromUtc)),
              " -",
              " ",
              formatWorkingTime(timeToDateTime(workingTime.timeToUtc))
            ] })
          ]
        }
      ) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonItem,
        {
          button: true,
          onClick: handleAddWorkingTime,
          className: "ion-no-padding",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline, className: "pr-2" }),
            addNewLabel || t("Izaberite radno vreme")
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      WorkingTimeEditor,
      {
        show: showWorkingTimeEditor,
        workingTime: currentWorkingTime,
        handleClose,
        handleSave
      }
    )
  ] });
}
function CommonWorkingTimeSingle(props) {
  const { register: register2, control, error, label, addNewLabel } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field: { onChange, value } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          WorkingTimeItem,
          {
            workingTime: value,
            onChange,
            label,
            addNewLabel
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
function CommonListDataListItem(props) {
  var _a2, _b2;
  const { placeholder, isNewItem, inputType } = props;
  const [item, setItem] = reactExports.useState((_a2 = props.item) != null ? _a2 : "");
  const [editMode, setEditMode] = reactExports.useState(false);
  const minLength = (_b2 = props.minLength) != null ? _b2 : 3;
  const ionItemOptionsRef = reactExports.useRef(null);
  const handleChange = (event) => {
    setItem(event.currentTarget.value);
  };
  const handleEnter = (event) => {
    if (event.key === "Enter") {
      event.preventDefault();
      event.stopPropagation();
      if (item.length >= minLength) {
        handleSave();
      }
    }
  };
  const showEdit = () => {
    setEditMode(true);
    setTimeout(() => {
      var _a3;
      (_a3 = inputRef.current) == null ? void 0 : _a3.setFocus();
    }, 120);
  };
  const inputRef = reactExports.useRef(null);
  const slideRef = reactExports.useRef(null);
  const handleSave = () => {
    props.onSave(props.index, item);
    setEditMode(false);
    if (isNewItem) {
      setItem("");
    }
  };
  const handleCancel = () => {
    setTimeout(() => {
      if (editMode) {
        setEditMode(false);
        setItem(isNewItem ? "" : props.item);
      }
    }, 300);
  };
  const handleDelete = () => {
    var _a3;
    (_a3 = props.onRemove) == null ? void 0 : _a3.call(props, props.index);
    setEditMode(false);
  };
  const showItemActions = (event) => {
    var _a3;
    event.stopPropagation();
    (_a3 = slideRef.current) == null ? void 0 : _a3.open("end");
  };
  const handleSlotClick = (event) => {
    var _a3;
    if (event.target && event.target !== ionItemOptionsRef.current) {
      return;
    }
    (_a3 = slideRef.current) == null ? void 0 : _a3.close();
  };
  reactExports.useEffect(() => {
    if (props.item !== item) {
      setItem(props.item);
    }
  }, [props.item]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItemSliding, { ref: slideRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { button: true, detail: false, onClick: showEdit, children: editMode ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonInput,
        {
          value: item,
          onKeyUp: handleChange,
          onKeyPress: handleEnter,
          ref: inputRef,
          onIonBlur: handleCancel,
          type: inputType != null ? inputType : "text"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          onClick: handleSave,
          slot: "end",
          disabled: item.length < minLength,
          size: "default",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "icon-only" })
        }
      )
    ] }) : isNewItem ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { children: placeholder }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { slot: "end", color: "default", size: "default", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline, slot: "icon-only" }) })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { children: placeholder != null ? placeholder : item }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          slot: "end",
          color: "default",
          onClick: showItemActions,
          size: "default",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronForwardOutline, className: "p-1" })
        }
      )
    ] }) }),
    !isNewItem && !editMode && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonItemOptions,
      {
        side: "end",
        ref: ionItemOptionsRef,
        onClick: handleSlotClick,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonItemOption, { color: "danger", onClick: handleDelete, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "icon-only", icon: trashOutline }) })
      }
    )
  ] });
}
function CommonListDataList(props) {
  const { items, onChange, label, inputType, errors } = props;
  const handleSave = (itemIndex, item) => {
    items[itemIndex] = item;
    onChange([...items]);
  };
  const handleDelete = (itemIndex) => {
    items.splice(itemIndex, 1);
    onChange([...items]);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { className: "w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { className: "py-2 border-b-2", children: label }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CommonListDataListItem,
      {
        item: "",
        onSave: handleSave,
        index: items.length,
        placeholder: "Dodaj",
        isNewItem: true,
        inputType
      }
    ),
    items.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        CommonListDataListItem,
        {
          item,
          index,
          onSave: handleSave,
          onRemove: handleDelete,
          inputType
        }
      ),
      errors && errors[index] && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: errors[index].message }) })
    ] }, item + index))
  ] });
}
function CommonList(props) {
  const { register: register2, control, error, label, inputType } = props;
  const singleError = !Array.isArray(error) ? error : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field: { onChange, value } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonListDataList,
          {
            items: value != null ? value : [],
            onChange,
            label,
            inputType,
            errors: Array.isArray(error) ? error : void 0
          }
        )
      }
    ) }),
    singleError && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: singleError.message }) })
  ] });
}
const CommonList$1 = reactExports.memo(CommonList);
function CommonIonicSwitch(props) {
  const { label, labelPlacement, type, register: register2, error } = props;
  const { itemProps, inputProps, control } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { ...itemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonToggle,
          {
            checked: field.value,
            onIonChange: (e) => field.onChange(e.detail.checked ? 1 : 0),
            children: label
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const ListIonIcons = reactExports.lazy(() => __vitePreload(() => import("./ListIonIcons-CYR4Oy7Y.js"), true ? __vite__mapDeps([0,1,2,3,4,5,6,7,8,9]) : void 0));
function ListIonIconsModal({
  isOpen,
  setIsOpen,
  onSelectIcon
}) {
  const [searchIcon, setSearchIcon] = React.useState(
    void 0
  );
  const handleDismiss = () => {
    setIsOpen(false);
  };
  const handleSelectIcon = (icon) => {
    setIsOpen(false);
    onSelectIcon == null ? void 0 : onSelectIcon(icon);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonModal, { isOpen, onDidDismiss: handleDismiss, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: t("Ikonice") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleDismiss, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline }) }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonSearchbar,
        {
          debounce: 700,
          onIonInput: (ev) => {
            var _a2;
            return setSearchIcon((_a2 = ev.target) == null ? void 0 : _a2.value);
          },
          onIonClear: () => setSearchIcon(null),
          value: searchIcon
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: "U훶itavanje ikonica...", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ListIonIcons,
      {
        onSelectIcon: handleSelectIcon,
        searchIcon
      }
    ) }) })
  ] });
}
function SelectIonicIcon({
  onSelectionChanged,
  selectedItemValue,
  title
}) {
  const modal = reactExports.useRef(null);
  selectedItemValue = selectedItemValue == null ? void 0 : selectedItemValue.toString();
  const selectedIcon = selectedItemValue ? getIonIconByName(selectedItemValue) : void 0;
  const [showModal, setShowModal] = reactExports.useState(false);
  const handleSelectChange = (item) => {
    var _a2;
    onSelectionChanged == null ? void 0 : onSelectionChanged(item == null ? void 0 : item.key);
    (_a2 = modal.current) == null ? void 0 : _a2.dismiss();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { onClick: () => setShowModal(true), button: true, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonInput,
        {
          label: title,
          readonly: true,
          value: selectedIcon == null ? void 0 : selectedIcon.key,
          labelPlacement: "floating"
        }
      ),
      selectedIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "end", icon: selectedIcon.value })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ListIonIconsModal,
      {
        isOpen: showModal,
        setIsOpen: setShowModal,
        onSelectIcon: handleSelectChange
      }
    )
  ] });
}
function CommonIonicIconSelect(props) {
  const { register: register2, control, error, label } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field: { onChange, value } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectIonicIcon,
          {
            selectedItemValue: value,
            onSelectionChanged: (item) => {
              onChange(item);
            },
            title: label
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const formatDate$2 = (dateString) => {
  if (!dateString) return null;
  try {
    const date = parseISO(dateString);
    return format(date, "dd.MM.yyyy");
  } catch (e) {
    return dateString;
  }
};
function CommonIonicDatePicker({
  label,
  labelPlacement = "stacked",
  itemProps,
  inputProps,
  register: register2,
  error,
  control,
  defaultValue
}) {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const containerRef = reactExports.useRef(null);
  const handleToggle = () => {
    const newIsOpen = !isOpen;
    setIsOpen(newIsOpen);
    if (newIsOpen && containerRef.current) {
      setTimeout(() => {
        var _a2;
        (_a2 = containerRef.current) == null ? void 0 : _a2.scrollIntoView({
          behavior: "smooth",
          block: "center",
          inline: "nearest"
        });
      }, 100);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => {
          var _a2;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: containerRef, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonItem,
              {
                ...itemProps,
                button: true,
                detail: false,
                onClick: handleToggle,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: label }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { slot: "end", className: "ion-text-end", children: field.value ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: formatDate$2(field.value) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    IonIcon,
                    {
                      icon: calendarOutline,
                      color: "medium",
                      style: { fontSize: "1.2em" }
                    }
                  ) })
                ]
              }
            ),
            isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonDatetime,
              {
                presentation: "date",
                size: "cover",
                value: (_a2 = field.value) != null ? _a2 : defaultValue,
                onIonChange: (e) => {
                  field.onChange(e.detail.value || null);
                },
                ...inputProps
              }
            )
          ] });
        }
      }
    ),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const formatDateTime = (dateString) => {
  if (!dateString) return null;
  try {
    const date = parseISO(dateString);
    return format(date, "dd.MM.yyyy HH:mm");
  } catch (e) {
    return dateString;
  }
};
function CommonIonicDateTimePicker({
  label,
  labelPlacement = "stacked",
  itemProps,
  inputProps,
  register: register2,
  error,
  control,
  defaultValue
}) {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const containerRef = reactExports.useRef(null);
  const handleToggle = () => {
    const newIsOpen = !isOpen;
    setIsOpen(newIsOpen);
    if (newIsOpen && containerRef.current) {
      setTimeout(() => {
        var _a2;
        (_a2 = containerRef.current) == null ? void 0 : _a2.scrollIntoView({
          behavior: "smooth",
          block: "center",
          inline: "nearest"
        });
      }, 100);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: containerRef, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            IonItem,
            {
              ...itemProps,
              button: true,
              detail: false,
              onClick: handleToggle,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: label }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { slot: "end", className: "ion-text-end", children: field.value ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: formatDateTime(field.value) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonIcon,
                  {
                    icon: timeOutline,
                    color: "medium",
                    style: { fontSize: "1.2em" }
                  }
                ) })
              ]
            }
          ),
          isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonDatetime,
            {
              presentation: "date-time",
              size: "cover",
              value: field.value ? toLocalISOStringForIonDatetime(field.value) : defaultValue,
              onIonChange: (e) => {
                field.onChange(e.detail.value || null);
              },
              ...inputProps
            }
          )
        ] })
      }
    ),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const changeRequestApi = sharedApi.injectEndpoints({
  endpoints: (builder) => ({
    getPendingChangeRequests: builder.query({
      query: () => ({ url: "change-requests/pending", method: "GET" }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType.CHANGE_REQUESTS]
    }),
    getEntityChangeRequests: builder.query({
      query: ({ entityType, entityId }) => ({
        url: "change-requests/get-entity",
        method: "GET",
        params: { entityType, entityId }
      }),
      providesTags: [TagType.CHANGE_REQUESTS],
      transformResponse: transformStandardResponseToCamelCase
    }),
    approveChangeRequest: builder.mutation({
      query: ({ id }) => ({
        url: "change-requests/".concat(id, "/approve"),
        method: "POST"
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType.CHANGE_REQUESTS]
    }),
    rejectChangeRequest: builder.mutation({
      query: ({ id }) => ({
        url: "change-requests/".concat(id, "/reject"),
        method: "POST"
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType.CHANGE_REQUESTS]
    })
  })
});
const {
  useGetEntityChangeRequestsQuery
} = changeRequestApi;
function ChangeRequestList({
  changeRequests,
  onSelectChangeRequest,
  isLoading = false,
  entityType
}) {
  const { t: t2 } = useTranslation();
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { className: "ml-2", children: t2("U훾itavanje planiranih promena...") })
    ] });
  }
  if (!changeRequests || changeRequests.length === 0) {
    return null;
  }
  const formatDate2 = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString("sr-RS", {
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    });
  };
  const getStatusColor = (status) => {
    switch (status) {
      case "pending":
        return "warning";
      case "approved":
        return "success";
      case "rejected":
        return "danger";
      case "executed":
        return "primary";
      case "failed":
        return "danger";
      default:
        return "medium";
    }
  };
  const getStatusText = (status) => {
    switch (status) {
      case "pending":
        return t2("Na 훾ekanju");
      case "approved":
        return t2("Odobreno");
      case "rejected":
        return t2("Odbijeno");
      case "executed":
        return t2("Izvr큄eno");
      case "failed":
        return t2("Neuspe큄no");
      default:
        return status;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarOutline, className: "text-lg" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { className: "font-medium", children: [
        t2("Planirane promene"),
        " (",
        changeRequests.length,
        ")"
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: changeRequests.map((changeRequest) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-800 rounded-lg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonButton,
              {
                fill: "outline",
                size: "small",
                color: "warning",
                onClick: () => onSelectChangeRequest(changeRequest),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: timeOutline, className: "mr-2" }),
                  formatDate2(changeRequest.scheduledDateUtc)
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonChip, { color: getStatusColor(changeRequest.status), children: getStatusText(changeRequest.status) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { className: "text-sm text-gray-600 dark:text-gray-400", children: [
                t2("Tip"),
                ":",
                " ",
                changeRequest.changeType === "update" ? t2("A탑uriranje") : changeRequest.changeType === "create" ? t2("Kreiranje") : changeRequest.changeType === "delete" ? t2("Brisanje") : changeRequest.changeType
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500", children: new Date(changeRequest.createdAt).toLocaleDateString("sr-RS") })
        ]
      },
      changeRequest.id
    )) })
  ] });
}
function CommonIonicChangeRequest({
  label,
  name,
  control,
  disabled = false,
  required = false,
  placeholder = "",
  entityId,
  entityType,
  error,
  form
}) {
  const { t: t2 } = useTranslation();
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const [selectedDate, setSelectedDate] = reactExports.useState(() => {
    const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1e3);
    return tomorrow.toISOString().split("T")[0];
  });
  const { data: existingChangeRequests, isLoading: isLoadingChangeRequests } = useGetEntityChangeRequestsQuery(
    { entityType: entityType || "service", entityId: entityId || "" },
    { skip: !entityId || !entityType }
  );
  const openModal = () => setIsOpen(true);
  const closeModal = () => setIsOpen(false);
  const handleSubmit = (onChange) => {
    if (selectedDate) {
      onChange({
        isEnabled: true,
        scheduledDateUtc: selectedDate
      });
      setIsOpen(false);
    }
  };
  const handleDisable = (onChange) => {
    onChange({
      isEnabled: false,
      scheduledDateUtc: null
    });
    setIsOpen(false);
  };
  const handleSelectChangeRequest = (changeRequest) => {
    if (form && changeRequest.data) {
      Object.keys(changeRequest.data).forEach((key) => {
        if (key !== "changeRequest" && key !== "id") {
          const value = changeRequest.data[key];
          if (value !== void 0) {
            form.setValue(key, value);
          }
        }
      });
      form.setValue(name, {
        isEnabled: true,
        scheduledDateUtc: changeRequest.scheduledDateUtc
      });
      console.log("Change request data loaded into form:", changeRequest.data);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Controller,
    {
      name,
      control,
      defaultValue: { isEnabled: false, scheduledDateUtc: null },
      render: ({ field: { onChange, value } }) => {
        const isEnabled = (value == null ? void 0 : value.isEnabled) || false;
        const scheduledDate = (value == null ? void 0 : value.scheduledDateUtc) || null;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "ion-no-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { className: "mb-2 block", children: [
            label,
            required && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-500 ml-1", children: "*" })
          ] }),
          entityId && entityType && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ChangeRequestList,
            {
              changeRequests: (existingChangeRequests == null ? void 0 : existingChangeRequests.data) || [],
              onSelectChangeRequest: handleSelectChangeRequest,
              isLoading: isLoadingChangeRequests,
              entityType
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonButton,
              {
                fill: "outline",
                size: "small",
                onClick: openModal,
                disabled,
                color: error ? "danger" : isEnabled ? "warning" : "primary",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: timeOutline, className: "mr-2" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { children: isEnabled ? t2("Promeni datum") : t2("Podesi datum promena") })
                ]
              }
            ),
            isEnabled && scheduledDate && /* @__PURE__ */ jsxRuntimeExports.jsxs(IonChip, { color: "warning", outline: true, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: timeOutline }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: scheduledDate }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  fill: "clear",
                  size: "small",
                  onClick: () => handleDisable(onChange),
                  disabled,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline })
                }
              )
            ] })
          ] }),
          error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "text-sm", children: error.message }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonModal, { isOpen, onDidDismiss: closeModal, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: isEnabled ? t2("Promeni datum promena") : t2("Podesi datum promena") }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { className: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: t2("Izaberi datum") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonDatetime,
                  {
                    value: selectedDate,
                    onIonChange: (e) => setSelectedDate(e.detail.value || ""),
                    min: new Date(Date.now() + 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
                    presentation: "date"
                  }
                )
              ] }),
              isEnabled && scheduledDate && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm text-gray-600", children: [
                t2("Trenutno pode큄en datum"),
                ": ",
                scheduledDate
              ] })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 p-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { fill: "outline", onClick: closeModal, children: t2("Otka탑i") }),
              isEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  fill: "outline",
                  onClick: () => handleDisable(onChange),
                  color: "danger",
                  children: t2("Ukloni")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  onClick: () => handleSubmit(onChange),
                  disabled: !selectedDate,
                  children: isEnabled ? t2("Promeni") : t2("Podesi")
                }
              )
            ] }) }) })
          ] })
        ] }) });
      }
    }
  );
}
function DynamicForm(props) {
  const { fields, callback, itemProps } = props;
  const form = props.form;
  const errors = form.formState.errors;
  const getField = (field) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
    const keyName = field.keyNameChild ? "".concat(field.keyName, ".").concat(field.keyNameChild) : field.keyName;
    const register2 = form.register(keyName, {
      required: field.required,
      setValueAs: (value) => typeof value === "string" ? value.trim() : value
    });
    const fieldError = field.keyNameChild ? (_a2 = errors[field.keyName]) == null ? void 0 : _a2[field.keyNameChild] : errors[field.keyName];
    const label = "label" in field.data && field.data.label ? field.required ? "".concat(field.data.label, " *") : field.data.label : "";
    switch (field.data.type) {
      case FieldType.Text:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicInput,
          {
            label,
            type: "text",
            register: register2,
            error: fieldError,
            control: form.control,
            itemProps: {
              ...itemProps,
              disabled: field.disabled
            },
            inputProps: {
              readonly: field.readOnly
            },
            labelPlacement: field.data.labelPlacement,
            translation: field.data.translation,
            googleIt: field.data.googleIt
          }
        );
      case FieldType.Slug:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicSlug,
          {
            label,
            register: register2,
            error: fieldError,
            control: form.control,
            sourceField: field.data.sourceField,
            placeholder: field.data.placeholder,
            isWatched: field.data.isWatched,
            isWatchedDefault: field.data.isWatchedDefault,
            itemProps: {
              ...itemProps,
              disabled: field.disabled
            }
          }
        );
      case FieldType.Number:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicInput,
          {
            label,
            type: "number",
            itemProps: {
              ...itemProps,
              disabled: field.disabled
            },
            inputProps: {
              readonly: field.readOnly
            },
            register: register2,
            error: fieldError,
            control: form.control
          }
        );
      case FieldType.Switch:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicSwitch,
          {
            label,
            type: "number",
            register: register2,
            error: fieldError,
            control: form.control
          }
        );
      case FieldType.Password:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicInput,
          {
            label,
            type: "password",
            register: register2,
            error: fieldError,
            control: form.control,
            showEye: (_b2 = field.data.showEye) != null ? _b2 : true
          }
        );
      case FieldType.Select:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicSelect,
          {
            register: register2,
            options: (_c2 = field.data.options) != null ? _c2 : [],
            ariaLabel: (_d2 = field.data.label) != null ? _d2 : field.name,
            placeholder: field.data.placeholder,
            error: fieldError,
            control: form.control,
            selectProps: {
              ...field.data.selectProps,
              disabled: field.disabled
            }
          }
        );
      case FieldType.Callback:
        return callback == null ? void 0 : callback(field);
      case FieldType.MultiCheckbox:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicMultiCheckbox,
          {
            control: form.control,
            error: fieldError,
            register: register2,
            disabled: field.disabled,
            options: (_e2 = field.data.options) != null ? _e2 : [],
            showSearchbar: field.data.showSearchbar,
            label: field.name,
            dataRowClassNames: field.data.rowClassNames
          }
        );
      case FieldType.Autocomplete:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicAutocompleteSelect,
          {
            control: form.control,
            error: fieldError,
            options: (_f2 = field.data.options) != null ? _f2 : [],
            handleAddNewOption: field.data.handleAddNewOption,
            register: register2,
            label: (_g2 = field.data.label) != null ? _g2 : field.name,
            selectedItem: form.getValues(keyName)
          }
        );
      case FieldType.RichEditor:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormRichEditor,
          {
            label: field.data.label,
            register: register2,
            error: fieldError,
            control: form.control,
            translation: field.data.translation
          }
        );
      case FieldType.TextArea:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicTextarea,
          {
            control: form.control,
            label: field.data.label,
            error: fieldError,
            register: register2,
            maxlength: field.data.maxlength,
            itemProps: {
              ...itemProps
            },
            translation: field.data.translation
          }
        );
      case FieldType.PhotoUploader:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          PhotoUploader$1,
          {
            label: field.data.label,
            register: register2,
            error: fieldError,
            control: form.control,
            handlers: field.data.handlers,
            reorderImagesResult: field.data.reorderImagesResult,
            photos: field.data.photos,
            oneImage: field.data.oneImage,
            cropAspectRatio: field.data.cropAspectRatio,
            maxPhotos: field.data.maxPhotos
          }
        );
      case FieldType.GalleryArea:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          GalleryArea,
          {
            field: field.data,
            register: register2,
            error: fieldError,
            control: form.control,
            form
          }
        );
      case FieldType.WorkingHours:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonWorkingTime,
          {
            label: field.data.label,
            addNewLabel: field.data.addNewLabel,
            modalTitle: field.data.modalTitle,
            defaultTimeFrom: field.data.defaultTimeFrom,
            defaultTimeTo: field.data.defaultTimeTo,
            defaultDays: field.data.defaultDays,
            register: register2,
            error: fieldError,
            control: form.control
          }
        );
      case FieldType.WorkingHoursSingle:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonWorkingTimeSingle,
          {
            label: field.data.label,
            addNewLabel: field.data.addNewLabel,
            register: register2,
            error: fieldError,
            control: form.control
          }
        );
      case FieldType.List:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonList$1,
          {
            label: field.data.label,
            register: register2,
            error: fieldError,
            control: form.control,
            inputType: field.data.inputType
          }
        );
      case FieldType.IonIcon:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicIconSelect,
          {
            register: register2,
            error: fieldError,
            control: form.control,
            label: field.data.label
          }
        );
      case FieldType.Date:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicDatePicker,
          {
            label: field.data.label,
            register: register2,
            error: fieldError,
            control: form.control,
            itemProps: field.data.itemProps,
            inputProps: field.data.inputProps,
            defaultValue: field.data.defaultValue
          }
        );
      case FieldType.DateTime:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicDateTimePicker,
          {
            label: field.data.label,
            register: register2,
            error: fieldError,
            control: form.control,
            itemProps: field.data.itemProps,
            inputProps: field.data.inputProps,
            defaultValue: field.data.defaultValue
          }
        );
      case FieldType.ChangeRequest:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicChangeRequest,
          {
            label,
            name: keyName,
            control: form.control,
            disabled: field.disabled,
            required: field.required,
            entityId: field.data.entityId,
            entityType: field.data.entityType,
            error: fieldError,
            form
          }
        );
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {});
    }
  };
  const getFields = () => {
    const returnFields = [];
    let rowElements = [];
    fields.forEach((field, index) => {
      var _a2;
      const gridSize = (_a2 = field.gridSize) != null ? _a2 : {
        size: "12",
        sizeSm: "12",
        sizeMd: "6"
      };
      if (field.newRow && rowElements.length > 0) {
        returnFields.push(/* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: rowElements }, index));
        rowElements = [];
      }
      const fieldElement = getField(field);
      if (fieldElement && field.visible !== false) {
        rowElements.push(
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { ...gridSize, className: field.colClassNames, children: fieldElement }, index)
        );
      }
    });
    if (rowElements.length > 0) {
      returnFields.push(/* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: rowElements }, fields.length));
    }
    return returnFields;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonGrid, { children: getFields() });
}
const loginApi = sharedApi.injectEndpoints({
  endpoints: (build) => ({
    login: build.mutation({
      query: (body) => ({
        url: "/login",
        method: "POST",
        body
      })
    }),
    loginWithCode: build.mutation({
      query: (body) => ({
        url: "/user/login-with-code",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    prepareLoginRegister: build.mutation({
      query: (body) => ({
        url: "/user/prepare",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    loginGoogle: build.mutation({
      query: (body) => ({
        url: "/login/google",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    register: build.mutation({
      query: (body) => ({
        url: "/register",
        method: "POST",
        body
      })
    }),
    userCompleteRegistration: build.mutation({
      query: (body) => ({
        url: "/user/register/complete",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    getUserSettings: build.query({
      query: () => "/user/settings",
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [{ type: TagType.USER_SETTINGS, id: TagId.LIST }]
    }),
    updateUserSettings: build.mutation({
      query: (data) => ({
        url: "/user/settings",
        method: "PUT",
        body: { data: humpsExports.decamelizeKeys(data) }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [{ type: TagType.USER_SETTINGS, id: TagId.LIST }]
    }),
    getUserAddresses: build.query({
      query: () => "/user/addresses",
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [{ type: TagType.USER_ADDRESS, id: TagId.LIST }]
    }),
    createUserAddress: build.mutation({
      query: (data) => ({
        url: "/user/addresses",
        method: "POST",
        body: { data: humpsExports.decamelizeKeys(data) }
      }),
      invalidatesTags: [{ type: TagType.USER_ADDRESS, id: TagId.LIST }]
    }),
    deleteUserAddresses: build.mutation({
      query: (ids) => ({
        url: "/user/addresses",
        method: "DELETE",
        body: { ids }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [{ type: TagType.USER_ADDRESS, id: TagId.LIST }]
    })
  })
});
const {
  useLoginWithCodeMutation,
  usePrepareLoginRegisterMutation,
  useLoginGoogleMutation
} = loginApi;
var UserGroupCode = /* @__PURE__ */ ((UserGroupCode2) => {
  UserGroupCode2["Admin"] = "admin";
  UserGroupCode2["Registered"] = "registered";
  UserGroupCode2["Guest"] = "guest";
  UserGroupCode2["Agent"] = "agent";
  UserGroupCode2["Client"] = "client";
  UserGroupCode2["Worker"] = "worker";
  UserGroupCode2["SocialGoogle"] = "social-google";
  UserGroupCode2["Owner"] = "owner";
  return UserGroupCode2;
})(UserGroupCode || {});
function getLoginFields(t2) {
  return [
    {
      name: "email",
      keyName: "login",
      data: {
        type: FieldType.Text,
        label: t2("Email")
      },
      gridSize: {
        size: "12"
      }
    }
  ];
}
const schema$3 = yup.object({
  login: yup.string().email(t("Email nije validan")).required()
});
const defaultDuration = 20 * 1e3;
function CommonLoginForm(props) {
  var _a2, _b2, _c2;
  const { t: t2 } = useTranslation();
  const fields = getLoginFields(t2);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [showConfirmationCodeField, setShowConfirmationCodeField] = reactExports.useState(false);
  const [confirmationCode, setConfirmationCode] = reactExports.useState("");
  const [showLoadingDuration, setShowLoadingDuration] = reactExports.useState(defaultDuration);
  const [presentToast] = useIonToast();
  const form = useFormWithSchema(schema$3);
  const { handleSubmit } = form;
  const dispatch = useDispatch();
  const [prepareUser, prepareResult] = usePrepareLoginRegisterMutation();
  const [
    loginWithCode,
    {
      data: loginWithCodeResponse,
      isSuccess: isLoginWithCodeSuccess,
      isError: isLoginWithCodeError,
      error: loginWithCodeError
    }
  ] = useLoginWithCodeMutation();
  const [loginGoogle, loginGoogleResult] = useLoginGoogleMutation();
  const {
    data: googleUserData,
    isSuccess: isGoogleLoginSuccess,
    isError: isGoogleLoginError
  } = loginGoogleResult;
  const showLoading = (duration = 20) => {
    setShowLoadingDuration(duration * 1e3);
    setIsLoading(true);
  };
  const hideLoading = () => {
    setShowLoadingDuration(defaultDuration);
    setIsLoading(false);
  };
  const onSubmit = (data) => {
    prepareUser(data);
  };
  const handleSuccessfulLogin = (loginData) => {
    var _a3;
    dispatch(setUser(loginData));
    dispatch(setUiData({ showLoginModal: false }));
    hideLoading();
    (_a3 = props.onSuccessfulLogin) == null ? void 0 : _a3.call(props);
  };
  const {
    isSuccess: isPrepareSuccess,
    isLoading: isPrepareLoading,
    isError: isPrepareError,
    error
  } = prepareResult;
  reactExports.useEffect(() => {
    if (isPrepareSuccess) {
      setShowConfirmationCodeField(true);
    }
    if (isPrepareError) {
      showNotification(
        { message: errorMessage != null ? errorMessage : "Unknown error", color: "danger" },
        1
      );
      hideLoading();
    }
  }, [isPrepareSuccess, isPrepareError, error]);
  reactExports.useEffect(() => {
    var _a3, _b3, _c3;
    if (isLoginWithCodeSuccess && loginWithCodeResponse) {
      handleSuccessfulLogin(loginWithCodeResponse.data);
      if (!((_a3 = prepareResult == null ? void 0 : prepareResult.data) == null ? void 0 : _a3.data.isExistingUser)) {
        dispatch(setShowCompleteProfileModal(true));
      }
    }
    if (isLoginWithCodeError && loginWithCodeError) {
      const errorMessage2 = (_b3 = loginWithCodeError == null ? void 0 : loginWithCodeError.data) == null ? void 0 : _b3.message;
      showNotification(
        {
          message: (_c3 = errorMessage2 == "Invalid code" ? t2("Kod nije validan") : errorMessage2) != null ? _c3 : "Unknown error",
          color: "danger",
          position: "bottom"
        },
        1
      );
      hideLoading();
    }
  }, [loginWithCodeResponse]);
  reactExports.useEffect(() => {
    if (isGoogleLoginSuccess) {
      handleSuccessfulLogin(googleUserData.data);
    }
    if (isPrepareError) {
      hideLoading();
    }
  }, [googleUserData, isGoogleLoginSuccess, isGoogleLoginError]);
  const errorMessage = (_a2 = error == null ? void 0 : error.data) == null ? void 0 : _a2.message;
  const showNotification = (options, durationSec) => {
    presentToast({
      duration: durationSec * 1e3,
      position: "top",
      ...options
    });
  };
  const googleLogin = useGoogleLogin({
    onSuccess: (tokenResponse) => {
      showLoading();
      loginGoogle({ accessToken: tokenResponse.access_token });
    },
    onError: () => {
      hideLoading();
    },
    onNonOAuthError: () => {
      hideLoading();
    }
  });
  const onLogin = () => {
    showLoading(30);
    googleLogin();
  };
  const handleConfirmationCode = () => {
    showLoading();
    loginWithCode({
      code: confirmationCode,
      login: form.getValues().login
    });
  };
  const handleCodeInputChange = (e) => {
    setConfirmationCode((e.currentTarget.value || "").trim());
  };
  const codeValidationError = (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    (_c2 = (_b2 = loginWithCodeResponse == null ? void 0 : loginWithCodeResponse.error) == null ? void 0 : _b2.data) == null ? void 0 : _c2.message
  );
  const disabledCodeButton = !confirmationCode || confirmationCode.length < 4;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-padding", children: [
    isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonLoading,
      {
        isOpen: isLoading,
        onDidDismiss: hideLoading,
        message: "Login - Molim vas sa훾ekajte...",
        duration: showLoadingDuration
      }
    ),
    isPrepareLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonLoading,
      {
        isOpen: isPrepareLoading,
        onDidDismiss: hideLoading,
        message: "힋alje se mejl sa kodom za aktivaciju...",
        duration: showLoadingDuration
      }
    ),
    showConfirmationCodeField ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonIcon,
        {
          icon: mailOutline,
          style: {
            fontSize: "48px",
            color: "var(--ion-color-success)",
            marginBottom: "16px"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { color: "success", className: "ion-padding-bottom", children: t2("Proverite mejl sandu훾e") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "ion-margin-bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonInput,
        {
          label: t2("Kod za aktivaciju"),
          labelPlacement: "stacked",
          placeholder: t2("Unesite kod ovde"),
          onKeyUp: handleCodeInputChange,
          value: confirmationCode,
          className: "ion-margin-top"
        }
      ) }),
      codeValidationError && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: codeValidationError }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          onClick: handleConfirmationCode,
          disabled: disabledCodeButton,
          expand: "block",
          className: "ion-margin-top",
          children: t2("Potvrdi")
        }
      )
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "form",
        {
          onSubmit: handleSubmit(onSubmit),
          autoComplete: "off",
          className: "ion-padding",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields, form }),
            isPrepareError && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-top", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: errorMessage }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonButton,
              {
                type: "submit",
                expand: "block",
                className: "ion-margin-top",
                children: [
                  t2("Uloguj se"),
                  " / ",
                  t2("Registruj se")
                ]
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-padding", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-text-center ion-margin-bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("ili se prijavite sa") }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonButton,
          {
            fill: "solid",
            onClick: onLogin,
            color: "dark",
            expand: "block",
            className: "ion-margin-top",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonIcon,
                {
                  slot: "start",
                  icon: logoGoogle,
                  className: "ion-margin-end"
                }
              ),
              t2("Google Log In")
            ]
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-text-center ion-margin-bottom mt-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonIcon,
        {
          icon: keyOutline,
          style: {
            fontSize: "48px",
            color: "var(--ion-color-primary)",
            marginBottom: "16px"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("Dobro do큄li nazad!") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ion-color-medium", children: t2("Prijavite se ili registrujte za pristup") })
      ] })
    ] })
  ] });
}
const withGoogleOAuth = (Component) => {
  const WrappedComponent = (props) => {
    const googleApiKey = "528191814583-ovprc30ec231gtc7t24apkep4kqo7npo.apps.googleusercontent.com";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GoogleOAuthProvider, { clientId: googleApiKey, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ...props }) });
  };
  WrappedComponent.displayName = "withGoogleOAuth(".concat(Component.displayName || Component.name || "Component", ")");
  return WrappedComponent;
};
const CommonLoginForm$1 = withGoogleOAuth(CommonLoginForm);
function CommonLoginModal(props) {
  const { t: t2 } = useTranslation();
  const { showLoginModal, onClose } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonModalExtended$1,
    {
      name: "login-modal",
      isOpen: showLoginModal,
      onClose,
      initialBreakpoint: 0.9,
      breakpoints: [0, 0.9, 1],
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: t2("Log in / Registracija") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline }) }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CommonLoginForm$1, {}) })
      ]
    }
  );
}
const ImageModal = () => {
  const imageData = useAppSelector$1(getImageModalData);
  const dispatch = useAppDispatch$1();
  const [isBackgroundColorBlack, setIsBackgroundColorBlack] = React.useState(true);
  const handleClose = () => {
    dispatch(closeImageModal());
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonModal, { isOpen: imageData == null ? void 0 : imageData.showModal, onDidDismiss: handleClose, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleClose, children: "Close" }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonContent, { fullscreen: true, className: "ion-padding ion-text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: imageData == null ? void 0 : imageData.src,
          alt: imageData == null ? void 0 : imageData.alt,
          className: "inline modal-image-preview",
          style: {
            backgroundColor: isBackgroundColorBlack ? "black" : "white"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonToggle,
        {
          checked: isBackgroundColorBlack,
          labelPlacement: "start",
          onIonChange: () => setIsBackgroundColorBlack(!isBackgroundColorBlack),
          children: "Crna Pozadina"
        }
      )
    ] })
  ] });
};
function CommonModalWrappers() {
  const dispatch = useAppDispatch$1();
  const showLoginModal = useAppSelector$1(getShowLoginModal);
  const showImageModal = useAppSelector$1(getShowImageModal);
  const handleCloseLoginModal = reactExports.useCallback(() => {
    dispatch(setShowLoginModal(false));
  }, [dispatch]);
  const LoginModalWrapper = reactExports.useMemo(() => {
    if (showLoginModal !== void 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        CommonLoginModal,
        {
          showLoginModal,
          onClose: handleCloseLoginModal
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  }, [showLoginModal, handleCloseLoginModal]);
  const ImageModalWrapper = reactExports.useMemo(() => {
    if (showImageModal !== void 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageModal, {});
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  }, [showImageModal]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    LoginModalWrapper,
    ImageModalWrapper
  ] });
}
const CommonModalWrappers$1 = reactExports.memo(CommonModalWrappers);
const firebaseConfig = {
  apiKey: "AIzaSyBrqIvAMt2f_G4bZMV2GkkGCHYGdWOxVLU",
  authDomain: "rezervacije-417408.firebaseapp.com",
  projectId: "rezervacije-417408",
  storageBucket: "rezervacije-417408.appspot.com",
  messagingSenderId: "528191814583",
  appId: "1:528191814583:web:00b4a81579862dea1dc632",
  measurementId: "G-887PF27E5L"
};
let messagingTemp;
const firebaseApp = initializeApp(firebaseConfig);
try {
  messagingTemp = getMessagingInWindow(firebaseApp);
} catch (e) {
  console.error(e);
  messagingTemp = void 0;
}
getAnalytics(firebaseApp);
const messaging = messagingTemp;
const __vite_import_meta_env__ = { "LEGACY": false, "VITE_RZR_VAPID_KEY": "BLgl3XyX_NID8-aSxeMXjfw3I9dt0cHPtoTQRKX0kGSDgvSJ89UFaO2rUTsis2x4oYrqn-tN4X84WmpMyvX5e9Y" };
const { VITE_RZR_VAPID_KEY } = __vite_import_meta_env__;
function useDeviceNotification({
  handleMessage,
  onConnected,
  connectDeviceInit
}) {
  const deviceData = useAppSelector$1(getDeviceData);
  const dispatch = useAppDispatch$1();
  const [swNotReady, setSwNotReady] = reactExports.useState(false);
  if (!messaging) {
    return null;
  }
  if (handleMessage) {
    onMessage(messaging, (payload) => {
      handleMessage(payload);
    });
  }
  const handleConnectDevice = async (enabled) => {
    var _a2;
    if (!messaging) {
      return null;
    }
    if (!enabled && !deviceData.notificationsEnabled) {
      return;
    }
    const registration = await ((_a2 = navigator == null ? void 0 : navigator.serviceWorker) == null ? void 0 : _a2.getRegistration("/"));
    if (!registration) {
      !swNotReady && setSwNotReady(true);
      return;
    }
    const permission = await Notification.requestPermission();
    if (permission === "granted") {
      const token = await getToken(messaging, {
        serviceWorkerRegistration: registration,
        vapidKey: VITE_RZR_VAPID_KEY
      });
      if (deviceData.notificationsToken !== token) {
        onConnected(token);
        dispatch(setDeviceData({ notificationsToken: token }));
      }
    }
  };
  reactExports.useEffect(() => {
    if (connectDeviceInit) {
      handleConnectDevice(true);
    }
  }, [connectDeviceInit]);
  reactExports.useEffect(() => {
    var _a2;
    if (swNotReady) {
      (_a2 = navigator == null ? void 0 : navigator.serviceWorker) == null ? void 0 : _a2.ready.then(() => {
        setSwNotReady(false);
        handleConnectDevice(true);
      });
    }
  }, []);
  return {
    connectDevice: handleConnectDevice
  };
}
function useUser(props) {
  const user = useAppSelector$1(getUser);
  const [userId, setUserId] = reactExports.useState(user == null ? void 0 : user.id);
  const dispatch = useAppDispatch$1();
  const { roles } = {};
  const [presentToast] = useIonToast();
  const wrapUserLoginModal = reactExports.useCallback(
    (callbackFunc) => {
      const showLoginResponse = () => {
        dispatch(setShowLoginModal(true));
      };
      if (user) {
        if (roles && roles.length > 0) {
          const hasRole = userHasRoles(user, roles);
          if (!hasRole) {
            return showLoginResponse;
          }
        }
        return callbackFunc != null ? callbackFunc : (() => {
        });
      }
      return showLoginResponse;
    },
    [user, roles, dispatch]
  );
  const isGroup = (group) => {
    return user && userHasRoles(user, [group]);
  };
  const isOwner = isGroup(UserGroupCode.Owner);
  const isWorker = isGroup(UserGroupCode.Worker);
  const isAdmin = isGroup(UserGroupCode.Admin);
  const isOwnerOrWorker = isOwner || isWorker;
  const logoutUser = () => {
    var _a2;
    dispatch(logoutAction());
    dispatch((_a2 = sharedApi.util) == null ? void 0 : _a2.invalidateTags([TagType.USER]));
  };
  reactExports.useEffect(() => {
    if (!(user == null ? void 0 : user.id) && userId) {
      presentToast({
        message: t("Korisnik je izlogovan"),
        duration: 4e3,
        color: "warning"
      });
      setUserId(void 0);
    } else if ((user == null ? void 0 : user.id) && userId !== user.id) {
      setUserId(user.id);
    }
  }, [user]);
  return {
    wrapUserLoginModal,
    isOwner,
    isAdmin,
    isWorker,
    isGroup,
    isOwnerOrWorker,
    userData: user,
    logoutUser,
    skipNoUser: { skip: !user }
  };
}
function CommonNotificationWrapper() {
  const [addConnectedDevice] = useAddConnectedDeviceMutation();
  const { isOwner } = useUser();
  const [presentToast] = useIonToast();
  const { push } = useIonRouter();
  const deviceData = useAppSelector$1(getDeviceData);
  const activeLocation2 = "test";
  const deviceNotification = useDeviceNotification({
    handleMessage: (payload) => {
      var _a2, _b2, _c2;
      const notification = (_a2 = payload == null ? void 0 : payload.data) == null ? void 0 : _a2.notification;
      const data = (_b2 = payload == null ? void 0 : payload.data) == null ? void 0 : _b2.data;
      if (!data || !notification) return;
      presentToast({
        message: t("Obave큄tenje: ") + ((_c2 = notification.body) != null ? _c2 : t("nema poruke")),
        duration: 5e3,
        color: "warning",
        buttons: (data == null ? void 0 : data.url) ? [
          {
            text: t("Link"),
            role: "info",
            handler: () => {
              push(data.url);
            }
          }
        ] : void 0
      });
    },
    onConnected: (token) => {
      addConnectedDevice({ token, locationSlug: activeLocation2 });
    },
    connectDeviceInit: !!isOwner
  });
  reactExports.useEffect(() => {
    if (!!deviceNotification && !isOwner && deviceData.notificationsEnabled) {
      deviceNotification == null ? void 0 : deviceNotification.connectDevice(true);
    }
  }, [deviceData]);
  return null;
}
function useAddConnectedDeviceMutation() {
  throw new Error("Function not implemented.");
}
const NotificationToast = ({
  message,
  type,
  duration = 2500,
  position = "bottom",
  isOpen,
  onDidDismiss,
  cssClass
}) => {
  const { t: t2 } = useTranslation();
  const getColor = () => {
    switch (type) {
      case "success":
        return "success";
      case "error":
        return "danger";
      case "warning":
        return "warning";
      case "info":
        return "primary";
      default:
        return "primary";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonToast,
    {
      isOpen,
      onDidDismiss,
      message: t2(message),
      duration,
      color: getColor(),
      position,
      cssClass
    }
  );
};
function ShowLoading({
  message,
  otherProps
}) {
  if (!message) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonLoading,
    {
      isOpen: !!message,
      message: message === true ? "" : message.toString(),
      ...otherProps
    }
  );
}
const ShowLoading$1 = reactExports.memo(ShowLoading);
function SkeletonLoader() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonListHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonSkeletonText,
      {
        animated: true,
        style: { width: "80px" }
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonThumbnail, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSkeletonText, { animated: true }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonSkeletonText,
          {
            animated: true,
            style: { width: "80%" }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonSkeletonText,
          {
            animated: true,
            style: { width: "60%" }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonSkeletonText,
          {
            animated: true,
            style: { width: "30%" }
          }
        ) })
      ] })
    ] })
  ] });
}
const SceletonLoader = reactExports.memo(SkeletonLoader);
function InstallInstructionsIosModal({
  isOpen,
  onClose
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonModal,
    {
      isOpen,
      onDidDismiss: onClose,
      breakpoints: [0.9, 1],
      initialBreakpoint: 0.9,
      children: isWebView ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: t("Instalacija je mogu훶a samo preko pretra탑iva훾a") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "(Google Chrome, Safari, ...)" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { expand: "block", onClick: onClose, className: "mt-6", children: t("Zatvori") }) })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl border-b-2 pb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t("iOS uputstvo za instalaciju") }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonContent, { className: "ion-padding", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: " text-xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "mb-2", children: [
                t("1) Kliknite na ikonu"),
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonIcon,
                  {
                    icon: exitOutline,
                    className: "-rotate-90",
                    color: "secondary",
                    size: "large"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "mb-2", children: t("2) Izaberite 'Dodaj na po훾etni ekran'.") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "mb-2", children: t("3) Kliknite na 'Dodaj'.") })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { expand: "block", onClick: onClose, className: "mt-6", children: t("Zatvori") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mt-10", children: t("Ako vam je telefon na engleskom:") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "mb-2", children: t("2) Izaberite 'Add to Home Screen'.") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "mb-2", children: t("3) Kliknite na 'Add'.") })
            ] })
          ] })
        ] })
      ] })
    }
  );
}
function useInstallPrompt({
  onSuccess,
  onFailure
}) {
  const [installPrompt, setInstallPrompt] = reactExports.useState(
    null
  );
  reactExports.useEffect(() => {
    const handleBeforeInstallPrompt = (e) => {
      e.preventDefault();
      setInstallPrompt(e);
    };
    window.addEventListener("beforeinstallprompt", handleBeforeInstallPrompt);
    return () => {
      window.removeEventListener(
        "beforeinstallprompt",
        handleBeforeInstallPrompt
      );
    };
  }, []);
  const promptInstall = async () => {
    if (installPrompt) {
      installPrompt.prompt();
      const choiceResult = await installPrompt.userChoice;
      if (choiceResult.outcome === "accepted") {
        console.log("User accepted the A2HS prompt");
        setInstallPrompt(null);
        onSuccess == null ? void 0 : onSuccess();
      } else {
        console.log("User dismissed the A2HS prompt");
        onFailure == null ? void 0 : onFailure();
      }
    }
  };
  return { promptInstall };
}
const fallbackRenderContent = ({ error }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { role: "alert", className: "p-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-red-500", children: "Something went wrong:" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "mt-2 text-sm text-red-700", children: error.message })
  ] });
};
const formatPriceSimple = (price) => {
  const rounded = Math.round(price * 100) / 100;
  const hasDecimals = rounded % 1 !== 0;
  if (hasDecimals) {
    const parts = rounded.toFixed(2).split(".");
    const integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, " ");
    return "".concat(integerPart, ",").concat(parts[1]);
  } else {
    return Math.round(rounded).toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
  }
};
function useWindowSize() {
  const [windowSize, setWindowSize] = reactExports.useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  reactExports.useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    }
    window.addEventListener("resize", handleResize);
    handleResize();
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return windowSize;
}
const ContentDataContext = reactExports.createContext(null);
function useContentData() {
  return reactExports.useContext(ContentDataContext);
}
function ContentDataProvider({
  children,
  contentRef,
  scrollTop
}) {
  const isScrolled = scrollTop > 0;
  const scrollToTop = (duration = 300) => {
    var _a2;
    (_a2 = contentRef.current) == null ? void 0 : _a2.scrollToTop(duration);
  };
  const scrollToBottom = (duration = 300) => {
    var _a2;
    (_a2 = contentRef.current) == null ? void 0 : _a2.scrollToBottom(duration);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ContentDataContext.Provider,
    {
      value: {
        isScrolled,
        scrollTop,
        scrollToTop,
        scrollToBottom,
        contentRef
      },
      children
    }
  );
}
const ContentRefContext = reactExports.createContext(
  null
);
function useContentRefFunctions() {
  return reactExports.useContext(ContentRefContext);
}
function LayoutMainPage({
  hasPage,
  children,
  contentLoading,
  popoverChildren,
  popoverItem,
  headerEndActions,
  hideHeader,
  headerClasses,
  title,
  titleSlot,
  headerContent,
  hasBackButton,
  hasMenuButton = true,
  backButtonIcon,
  backButtonTitle,
  backButtonCss = "",
  additionalHeader,
  footer,
  backButtonUrl,
  showLoadingMessage,
  installAppHeaderHandle,
  contentClasses,
  hasRefresher = true
}) {
  var _a2;
  useTranslation();
  const [showPopover, setShowPopover] = reactExports.useState(false);
  const [popoverEvent, setPopoverEvent] = reactExports.useState();
  const [scrollTop, setScrollTop] = reactExports.useState(0);
  const router = useIonRouter();
  title = title && typeof title === "string" ? t(title) : title;
  hasPage = hasPage != null ? hasPage : true;
  const { width } = useWindowSize();
  const { userData } = useUser();
  const appKey = ((_a2 = userData == null ? void 0 : userData.email) != null ? _a2 : "no-user") + width.toString();
  const [showIosModal, setShowIosModal] = reactExports.useState(false);
  const { promptInstall } = useInstallPrompt({});
  const contentRef = reactExports.useRef(null);
  const presentPopover = (e) => {
    setPopoverEvent(e.nativeEvent);
    setShowPopover(true);
  };
  const handleBack = () => {
    if (backButtonUrl) {
      router.push(backButtonUrl, "back");
    } else {
      router.goBack();
    }
  };
  const PopoverChild = popoverChildren != null ? popoverChildren : void 0;
  const PopoverItem = popoverItem != null ? popoverItem : void 0;
  const scrollToTop = (duration) => {
    var _a3;
    (_a3 = contentRef.current) == null ? void 0 : _a3.scrollToTop(duration);
  };
  const scrollToBottom = (duration) => {
    var _a3;
    (_a3 = contentRef.current) == null ? void 0 : _a3.scrollToBottom(duration);
  };
  const handleInstallApp = () => {
    if (isIos || isWebView) {
      setShowIosModal(true);
    } else {
      promptInstall();
    }
  };
  const handleRefresh = (e) => {
    window.location.reload();
    e.detail.complete();
  };
  const responseNode = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ShowLoading$1, { message: showLoadingMessage }),
    installAppHeaderHandle && !isPwa && !isWebPlatform && /* @__PURE__ */ jsxRuntimeExports.jsxs(IonHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButton, { color: "dark", onClick: handleInstallApp, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonIcon,
          {
            icon: isIos ? logoApple : logoAndroid,
            className: "mr-2"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t("Instaliraj Aplikaciju") })
      ] }),
      (isIos || isWebView) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        InstallInstructionsIosModal,
        {
          isOpen: showIosModal,
          onClose: () => setShowIosModal(false)
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonHeader,
      {
        className: "ion-no-border ".concat(headerClasses != null ? headerClasses : ""),
        translucent: true,
        collapse: "fade",
        hidden: hideHeader,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ConditionalComponent,
            {
              condition: hasBackButton != null ? hasBackButton : false,
              render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                IonButton,
                {
                  onClick: handleBack,
                  className: "min-w-[41px] ".concat(backButtonCss),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      IonIcon,
                      {
                        slot: !backButtonTitle ? "icon-only" : "start",
                        icon: backButtonIcon != null ? backButtonIcon : chevronBackOutline
                      }
                    ),
                    backButtonTitle
                  ]
                }
              ),
              elseCondition: hasMenuButton,
              renderElse: () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "min-w-[41px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonMenuButton, { className: "my-2" }) })
            }
          ) }),
          headerContent,
          title && /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { ...titleSlot ? { slot: titleSlot } : {}, children: title }),
          PopoverChild && (PopoverItem ? PopoverItem : /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: presentPopover, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonIcon,
            {
              slot: "icon-only",
              ios: ellipsisHorizontal,
              md: ellipsisVertical
            }
          ) }) })),
          headerEndActions && /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: headerEndActions })
        ] })
      }
    ),
    additionalHeader && /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: additionalHeader }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(ContentDataProvider, { contentRef, scrollTop, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonContent,
        {
          ref: contentRef,
          className: contentClasses,
          scrollEvents: true,
          fullscreen: true,
          onIonScroll: (e) => {
            setScrollTop(e.detail.scrollTop);
          },
          children: [
            hasRefresher && /* @__PURE__ */ jsxRuntimeExports.jsx(IonRefresher, { slot: "fixed", onIonRefresh: handleRefresh, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonRefresherContent, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ContentRefContext.Provider,
              {
                value: {
                  scrollToTop,
                  scrollToBottom,
                  contentRef
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { fallbackRender: fallbackRenderContent, children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {}), children: contentLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {}) : children }) })
              }
            )
          ]
        }
      ),
      footer
    ] }),
    PopoverChild && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonPopover,
      {
        isOpen: showPopover,
        event: popoverEvent,
        onDidDismiss: () => setShowPopover(false),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverChild, { dismiss: () => setShowPopover(false) })
      }
    )
  ] }, appKey);
  return hasPage ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonPage, { children: responseNode }) : responseNode;
}
function PageNotFound() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonPage, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: "404 Page Not Found" }) });
}
function IonAlertConfirmation({
  confirmAction,
  cancelAction,
  cancelTextKey,
  confirmTextKey,
  confirmCssClass,
  cancelCssClass,
  ...alertProps
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonAlert,
    {
      backdropDismiss: false,
      buttons: [
        {
          text: t(cancelTextKey != null ? cancelTextKey : "Ne"),
          role: "cancel",
          cssClass: cancelCssClass,
          handler: cancelAction
        },
        {
          text: t(confirmTextKey != null ? confirmTextKey : "Da"),
          role: "confirm",
          cssClass: confirmCssClass,
          handler: confirmAction
        }
      ],
      ...alertProps
    }
  );
}
function useClipboard() {
  const [data, setData] = reactExports.useState();
  const [showCopyMessage] = useIonToast();
  async function getValue() {
    const ret = await Clipboard.read();
    setData(ret.value);
    return ret.value;
  }
  async function setValue(value) {
    await Clipboard.write({
      string: value
    });
    showCopyMessage({
      message: "Kopirano: " + value,
      duration: 1e3
    });
  }
  return {
    value: data,
    getValue,
    setValue
  };
}
const IonAlertConfirmationBtn = ({
  alertProps,
  onConfirm,
  children,
  ...btnProps
}) => {
  const [showAlert, setShowAlert] = reactExports.useState(false);
  const handleConfirm = async () => {
    setShowAlert(false);
    await onConfirm();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { ...btnProps, onClick: () => setShowAlert(true), children }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonAlertConfirmation,
      {
        isOpen: showAlert,
        confirmAction: handleConfirm,
        cancelAction: () => setShowAlert(false),
        onDidDismiss: () => setShowAlert(false),
        ...alertProps
      }
    )
  ] });
};
function FormActionButtons({
  onSave,
  isSaving = false,
  saveButtonProps = {},
  onDelete,
  isDeleting = false,
  showDelete = false,
  deleteButtonProps = {},
  deleteConfirmationProps = {},
  className = "mt-6 flex gap-2 justify-center"
}) {
  const { t: t2 } = useTranslation();
  const [showDeleteAlert, setShowDeleteAlert] = reactExports.useState(false);
  const handleDelete = () => {
    if (onDelete) {
      setShowDeleteAlert(true);
    }
  };
  const confirmDelete = async () => {
    if (onDelete) {
      await onDelete();
    }
    setShowDeleteAlert(false);
  };
  const defaultSaveText = saveButtonProps.children || t2("Sa훾uvaj");
  deleteButtonProps.children || t2("Obri큄i");
  const defaultDeleteHeader = deleteConfirmationProps.header || t2("Obri큄i?");
  const defaultDeleteMessage = deleteConfirmationProps.message || t2("Da li ste sigurni da 탑elite da obri큄ete ovaj podatak?");
  const defaultDeleteConfirmText = deleteConfirmationProps.confirmTextKey || t2("Da");
  const defaultDeleteCancelText = deleteConfirmationProps.cancelTextKey || t2("Ne");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className, children: [
      showDelete && onDelete && /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          type: "button",
          onClick: handleDelete,
          disabled: isDeleting,
          fill: "clear",
          color: "danger",
          ...deleteButtonProps,
          children: deleteButtonProps.children || /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline, slot: "icon-only", className: "px-4" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          onClick: onSave,
          disabled: isSaving,
          expand: "block",
          style: { flexGrow: 1, maxWidth: "300px" },
          ...saveButtonProps,
          children: [
            isSaving && /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { slot: "start" }),
            saveButtonProps.children || /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "start" }),
              defaultSaveText
            ] })
          ]
        }
      )
    ] }),
    showDelete && onDelete && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonAlertConfirmation,
      {
        isOpen: showDeleteAlert,
        header: defaultDeleteHeader,
        message: defaultDeleteMessage,
        confirmAction: confirmDelete,
        cancelAction: () => setShowDeleteAlert(false),
        onDidDismiss: () => setShowDeleteAlert(false),
        confirmTextKey: defaultDeleteConfirmText,
        cancelTextKey: defaultDeleteCancelText,
        confirmCssClass: "danger",
        ...deleteConfirmationProps
      }
    )
  ] });
}
const defaultProps = {
  minStep: 0,
  initialStep: 0
};
function FormStepper(props, ref) {
  const swiperRef = reactExports.useRef(null);
  const { renderSteps, onCurrentStepChange, returnQueryParams, swiperProps } = props;
  const { firstStepReset, initialStep } = useDefaultProps(props, defaultProps);
  const [formStep, setFormStep] = reactExports.useState(initialStep);
  const [keyIndex, setKeyIndex] = reactExports.useState(0);
  const { minStep } = useDefaultProps(props, defaultProps);
  const [presentAlert, dismiss] = useConfirmationAlert({
    cancelCallback: () => {
      dismiss();
      returnQueryParams == null ? void 0 : returnQueryParams();
    },
    confirmCallback: () => {
      var _a2;
      const finishCallback = () => {
        setKeyIndex(keyIndex + 1);
        setFormStep(0);
        dismiss();
      };
      if (firstStepReset == null ? void 0 : firstStepReset.callback) {
        if (!((_a2 = firstStepReset == null ? void 0 : firstStepReset.callback) == null ? void 0 : _a2.call(firstStepReset, finishCallback))) {
          finishCallback();
        }
      } else {
        finishCallback();
      }
    }
  });
  const resetStepper = () => {
    setKeyIndex(keyIndex + 1);
    setFormStep(0);
  };
  const handleReset = () => {
    var _a2;
    if (firstStepReset) {
      if (firstStepReset.confirmationAlertOptions) {
        presentAlert(firstStepReset.confirmationAlertOptions);
      } else {
        (_a2 = firstStepReset.callback) == null ? void 0 : _a2.call(firstStepReset);
      }
    }
  };
  const setStepBack = () => {
    setStep(formStep - 1);
    handleSlideChange(formStep + 1);
  };
  const setStepNext = () => {
    setStep(formStep + 1);
    handleSlideChange(formStep + 1);
  };
  const handleSlideChange = (slide) => {
    var _a2;
    (_a2 = swiperRef.current) == null ? void 0 : _a2.swiper.slideTo(slide);
  };
  const setStep = (step) => {
    if (step === minStep && firstStepReset) {
      handleReset();
    } else if (step <= maxStep2) {
      setFormStep(step);
      handleSlideChange(step);
    }
  };
  reactExports.useImperativeHandle(ref, () => ({
    handleStepBack() {
      setStepBack();
    },
    handleStepNext() {
      setStepNext();
    },
    getCurrentStep() {
      return formStep;
    },
    handleSetStep(step) {
      setStep(step);
    },
    resetStepper() {
      resetStepper();
    }
  }));
  reactExports.useEffect(() => {
    onCurrentStepChange(formStep);
  }, [formStep]);
  const steps = reactExports.useMemo(
    () => renderSteps({
      handleStepNext: setStepNext,
      handleStepBack: setStepBack,
      setStep,
      getCurrentStep: () => formStep
    }),
    [renderSteps]
  );
  const maxStep2 = steps.length - 1;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SwiperWrapper$1,
    {
      className: props.className,
      speed: 400,
      initialSlide: formStep,
      allowTouchMove: false,
      currentStep: formStep,
      ...swiperProps,
      ref: swiperRef,
      children: steps.map((stepWrapper, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { children: stepWrapper }, "slide" + index))
    }
  );
}
const FormStepper$1 = reactExports.memo(
  reactExports.forwardRef(FormStepper)
);
function NoAuthenticationPage() {
  const { t: t2 } = useTranslation();
  const dispatch = useAppDispatch$1();
  const handleLogin = () => {
    dispatch(setShowLoginModal(true));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonPage, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { className: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        height: "100%",
        textAlign: "center",
        padding: "20px"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonIcon,
          {
            icon: lockClosedOutline,
            style: {
              fontSize: "64px",
              color: "var(--ion-color-medium)",
              marginBottom: "20px"
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { marginBottom: "16px" }, children: t2("Potrebna je autorizacija") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                color: "var(--ion-color-medium)",
                marginBottom: "32px",
                fontSize: "16px",
                lineHeight: "1.5"
              },
              children: t2(
                "Da biste pristupili ovoj stranici, potrebno je da se prijavite ili registrujete."
              )
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonButton,
          {
            onClick: handleLogin,
            expand: "block",
            style: {
              maxWidth: "300px",
              margin: "0 auto"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: logInOutline, slot: "start" }),
              t2("Login / Registracija")
            ]
          }
        )
      ]
    }
  ) }) });
}
function UnauthorizedPage() {
  const { t: t2 } = useTranslation();
  const { goBack } = useIonRouter();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMainPage, { title: "Nemate pristup stranici", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { className: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
      "탐ao mi je, ali nemate pristup ovoj stranici.",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          style: {
            fontSize: "2em"
          },
          children: "윑"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { button: true, routerLink: "/", routerDirection: "back", children: t2("Nazad na po훾etnu") })
  ] }) }) });
}
const UnauthorizedPage$1 = reactExports.memo(UnauthorizedPage);
const GuardedRoute = ({
  roles,
  fallbackRender,
  hasFallbackWithoutUser,
  ...rest
}) => {
  const user = useAppSelector$1(getUser);
  roles = (roles == null ? void 0 : roles.length) ? roles : void 0;
  if (user && roles && roles.length > 0) {
    const hasRole = userHasRoles(user, roles);
    if (!hasRole) {
      rest.render = fallbackRender != null ? fallbackRender : void 0;
      rest.component = fallbackRender ? void 0 : UnauthorizedPage$1;
    }
  }
  if (!user) {
    rest.render = void 0;
    rest.component = NoAuthenticationPage;
    if (fallbackRender && hasFallbackWithoutUser) {
      rest.render = fallbackRender;
      rest.component = void 0;
    }
  }
  return /* @__PURE__ */ reactExports.createElement(Route, { ...rest, key: user == null ? void 0 : user.id });
};
const GuardedRoute$1 = reactExports.memo(GuardedRoute);
const preloadCoverImg$2 = "/app/assets/preload-cover-CPxF8vUC.webp";
const preloadSquareImg = "/app/assets/preload-square-DKFvohGs.webp";
const imageCache = {};
const preloadImage = (url) => {
  if (!imageCache[url]) {
    const img = new Image();
    img.src = url;
    imageCache[url] = img;
  }
};
const pl = (url) => {
  if (!url) {
    return void 0;
  }
  preloadImage(url);
  return imageCache[url].src;
};
function LazyLoadImgStandard({
  preloadRatio,
  preloadImg,
  ...props
}) {
  const [showEffect, setShowEffect] = reactExports.useState(true);
  const src = pl(props.src);
  preloadImg = preloadImg != null ? preloadImg : preloadRatio === "1-1" ? preloadSquareImg : preloadCoverImg$2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    buildExports.LazyLoadImage,
    {
      onLoad: () => showEffect && setShowEffect(false),
      effect: showEffect ? "blur" : void 0,
      placeholderSrc: preloadImg,
      ...props,
      src
    }
  );
}
const LazyLoadImgStandard$1 = reactExports.memo(LazyLoadImgStandard);
const Pagination = ({
  currentPage,
  totalPages,
  onPageChange,
  isLoading = false,
  className = ""
}) => {
  const handlePrevPage = () => {
    if (currentPage > 1 && !isLoading) {
      onPageChange(currentPage - 1);
    }
  };
  const handleNextPage = () => {
    if (currentPage < totalPages && !isLoading) {
      onPageChange(currentPage + 1);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center gap-4 ".concat(className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonButton,
      {
        fill: "clear",
        onClick: handlePrevPage,
        disabled: currentPage === 1 || isLoading,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronBack })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm", children: [
      currentPage,
      "/",
      totalPages
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonButton,
      {
        fill: "clear",
        onClick: handleNextPage,
        disabled: currentPage === totalPages || isLoading,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronForward })
      }
    )
  ] });
};
function useQueryParamsHook({
  beforeNavigation,
  afterNavigation
}) {
  const history = useHistory();
  const params = new URLSearchParams(window.location.search);
  const paramsData = Object.fromEntries(params.entries());
  const [queryParamsData, setQueryParamsData] = reactExports.useState(paramsData);
  const updateQueryParams = reactExports.useCallback(
    (name, value) => {
      beforeNavigation == null ? void 0 : beforeNavigation();
      const params2 = new URLSearchParams(window.location.search);
      if (!value) {
        if (Array.isArray(name)) {
          name.forEach((n) => {
            params2.delete(n);
          });
        } else {
          params2.delete(name);
        }
        setQueryParamsData((prev) => {
          if (Array.isArray(name)) {
            return name.reduce((acc, n) => {
              const { [n]: _, ...rest } = acc;
              return rest;
            }, prev);
          } else {
            const { [name]: _, ...rest } = prev;
            return rest;
          }
        });
      } else {
        if (Array.isArray(name)) {
          name.forEach((n) => {
            params2.set(n, value);
          });
        } else {
          params2.set(name, value);
        }
        setQueryParamsData((prev) => {
          if (Array.isArray(name)) {
            return name.reduce((acc, n) => {
              return { ...acc, [n]: value };
            }, prev);
          } else {
            return { ...prev, [name]: value };
          }
        });
      }
      history.replace({ search: params2.toString() });
      afterNavigation == null ? void 0 : afterNavigation();
    },
    [history]
  );
  const deleteQueryParams = reactExports.useCallback(
    (name) => {
      updateQueryParams(name, null);
    },
    [updateQueryParams]
  );
  return {
    update: updateQueryParams,
    delete: deleteQueryParams,
    data: queryParamsData
  };
}
const useAppFocus = (options = {}) => {
  const { onFocus, onVisibilityChange } = options;
  reactExports.useEffect(() => {
    const handleFocus = () => {
      onFocus == null ? void 0 : onFocus();
    };
    const handleVisibility = () => {
      const state = document.visibilityState;
      const isVisible = state === "visible";
      onVisibilityChange == null ? void 0 : onVisibilityChange(isVisible);
      if (isVisible) {
        handleFocus();
      }
    };
    window.addEventListener("focus", handleFocus);
    window.addEventListener("visibilitychange", handleVisibility);
    return () => {
      window.removeEventListener("focus", handleFocus);
      window.removeEventListener("visibilitychange", handleVisibility);
    };
  }, [onFocus, onVisibilityChange]);
};
const pingApi = sharedApi.injectEndpoints({
  endpoints: (build) => ({
    ping: build.query({
      query: (data) => ({
        url: "/ping",
        method: "POST",
        body: data,
        transformResponse: transformStandardResponseToCamelCase
      })
    })
  })
});
const { usePingQuery } = pingApi;
var PingType = /* @__PURE__ */ ((PingType2) => {
  PingType2["RESERVATIONS"] = "reservations";
  PingType2["WORKERS"] = "workers";
  PingType2["SERVICES"] = "services";
  PingType2["WORKING_HOURS"] = "working_hours";
  PingType2["NOTIFICATIONS"] = "notifications";
  return PingType2;
})(PingType || {});
const usePing = (types, requestData, onChangeHandler, options) => {
  var _a2, _b2;
  const [requestDataState, setRequestDataState] = reactExports.useState({
    lastChecks: {},
    types,
    hashes: {}
  });
  const [isActive, setIsActive] = reactExports.useState((_a2 = options == null ? void 0 : options.autoStart) != null ? _a2 : true);
  const [hasChanges, setHasChanges] = reactExports.useState(false);
  const handleChanges = reactExports.useCallback(
    (changes) => {
      var _a3;
      onChangeHandler(changes);
      (_a3 = options == null ? void 0 : options.onChanges) == null ? void 0 : _a3.call(options, changes);
    },
    [options, onChangeHandler]
  );
  const {
    data: pingResponse,
    error,
    isLoading
  } = usePingQuery(
    {
      lastChecks: requestDataState.lastChecks,
      types: requestDataState.types,
      hashes: requestDataState.hashes,
      ...requestData
    },
    {
      skip: !isActive || hasChanges,
      pollingInterval: (_b2 = options == null ? void 0 : options.interval) != null ? _b2 : 1e4
    }
  );
  const data = pingResponse == null ? void 0 : pingResponse.data;
  reactExports.useEffect(() => {
    var _a3;
    const newLastChecks = { ...requestDataState.lastChecks };
    if (!data) return;
    if (data.hasChanges || !Object.values(requestDataState.lastChecks).length) {
      let hasChanges2 = false;
      Object.keys(data.changes).forEach((type) => {
        var _a4;
        if (((_a4 = data.changes[type]) == null ? void 0 : _a4.hasChanges) || !requestDataState.lastChecks[type]) {
          newLastChecks[type] = data.changes[type].lastUpdated;
          hasChanges2 = true;
        }
      });
      if (hasChanges2) {
        setHasChanges(true);
        if (data.hasChanges) {
          handleChanges(data.changes);
        }
        const timeout = setTimeout(() => {
          setRequestDataState({
            ...requestDataState,
            lastChecks: newLastChecks,
            hashes: data.hashes
          });
          setHasChanges(false);
        }, (_a3 = options == null ? void 0 : options.interval) != null ? _a3 : 1e4);
        return () => clearTimeout(timeout);
      }
    }
  }, [data, handleChanges]);
  const start = reactExports.useCallback(() => setIsActive(true), []);
  const stop = reactExports.useCallback(() => setIsActive(false), []);
  return {
    data,
    error,
    isActive,
    start,
    stop,
    lastChecks: requestDataState.lastChecks,
    hashes: requestDataState.hashes
  };
};
const mainHeaderClasses = isWebPlatform ? "max-w-[80vw]" : "";
const locationApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getFeLocation: builder.query({
      query: ({ slug }) => ({
        url: "locations/data",
        method: "GET",
        params: { slug }
      }),
      providesTags: [TagType$1.LOCATION, TagType$1.APP_LANG],
      transformResponse: transformStandardResponseToCamelCase
    })
  })
});
const { useGetFeLocationQuery } = locationApi;
const locationWorkerApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getFeWorkers: builder.query({
      query: ({ locationSlug }) => ({
        url: "locations/workers",
        method: "GET",
        params: { locationSlug }
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [TagType$1.LOCATION_WORKERS]
    }),
    getFeWorker: builder.query({
      query: ({ workerId, locationSlug }) => ({
        url: "locations/worker/".concat(workerId),
        method: "GET",
        params: { locationSlug }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: (result, error, { workerId }) => [
        { type: TagType$1.LOCATION_WORKERS, id: workerId }
      ]
    }),
    createWorker: builder.mutation({
      query: ({ locationSlug, ...body }) => ({
        url: "locations/workers/create",
        method: "POST",
        body: {
          ...humpsExports.decamelizeKeys(body),
          locationSlug
        }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    }),
    updateWorker: builder.mutation({
      query: ({ id, locationSlug, ...body }) => ({
        url: "locations/workers/update",
        method: "POST",
        body: {
          ...humpsExports.decamelizeKeys(body),
          id,
          locationSlug
        }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    }),
    deleteWorker: builder.mutation({
      query: (body) => ({
        url: "locations/workers/delete",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    }),
    getAllWorkers: builder.query({
      query: ({ locationSlug }) => ({
        url: "locations/workers/all",
        method: "GET",
        params: { locationSlug }
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [TagType$1.LOCATION_WORKERS]
    }),
    // Worker Services
    getWorkerServices: builder.query({
      query: ({ locationSlug, workerId }) => ({
        url: "locations/worker/".concat(workerId, "/services"),
        method: "GET",
        params: { locationSlug, workerId }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.LOCATION_WORKERS]
    }),
    storeWorkerService: builder.mutation({
      query: ({ locationSlug, workerId, services }) => ({
        url: "locations/worker/".concat(workerId, "/services"),
        method: "POST",
        body: {
          locationSlug,
          workerId,
          services: services.map((service) => ({
            serviceId: service.serviceId,
            locationId: service.locationId,
            price: service.price,
            duration: service.duration,
            sortOrder: service.sortOrder,
            active: service.active
          }))
        }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    }),
    updateWorkerService: builder.mutation({
      query: ({ locationSlug, workerId, serviceId, ...body }) => ({
        url: "locations/worker/".concat(workerId, "/services/").concat(serviceId),
        method: "PUT",
        body: {
          ...humpsExports.decamelizeKeys(body),
          locationSlug
        }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    }),
    deleteWorkerService: builder.mutation({
      query: ({ locationSlug, workerId, serviceId }) => ({
        url: "locations/worker/".concat(workerId, "/services/").concat(serviceId),
        method: "DELETE",
        params: { locationSlug }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    }),
    deleteWorkerAvatar: builder.mutation({
      query: ({ workerId, locationSlug }) => ({
        url: "locations/workers/".concat(workerId, "/avatar"),
        method: "DELETE",
        params: { locationSlug }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    })
  })
});
const {
  useGetFeWorkersQuery,
  useGetFeWorkerQuery,
  useCreateWorkerMutation,
  useUpdateWorkerMutation,
  useDeleteWorkerMutation,
  useGetAllWorkersQuery,
  useGetWorkerServicesQuery,
  useStoreWorkerServiceMutation,
  useUpdateWorkerServiceMutation,
  useDeleteWorkerServiceMutation
} = locationWorkerApi;
function getReservationUrlWithParams(params) {
  const searchParams = new URLSearchParams(params);
  return "/zakazivanje/zakazi-novo?".concat(searchParams.toString());
}
function getReservationUrlWithSlot(workerId, slot, date) {
  return getReservationUrlWithParams({
    worker: workerId.toString(),
    step: "1",
    slot,
    date
  });
}
const preloadCoverImg$1 = "/app/assets/logo-square-Bsnn6NiG.webp";
function WorkerItem({ worker }) {
  var _a2;
  const { t: t2 } = useTranslation();
  const [isExpanded, setIsExpanded] = reactExports.useState(false);
  const [isOverflowing, setIsOverflowing] = reactExports.useState(false);
  const descriptionRef = reactExports.useRef(null);
  const { push } = useIonRouter();
  const reservationUrl = getReservationUrlWithParams({
    worker: worker.id.toString(),
    step: "1"
  });
  reactExports.useEffect(() => {
    if (descriptionRef.current) {
      setTimeout(() => {
        if (descriptionRef.current) {
          const { scrollHeight, clientHeight } = descriptionRef.current;
          setIsOverflowing(scrollHeight > clientHeight);
        }
      }, 100);
    }
  }, [worker.description]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { className: "m-0", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConditionalComponent,
      {
        condition: !!((_a2 = worker.avatar) == null ? void 0 : _a2.pathByResolution),
        render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { className: "ion-no-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          LazyLoadImgStandard$1,
          {
            src: getPathBySize(worker.avatar.pathByResolution),
            preloadImg: preloadCoverImg$1,
            className: "aspect-square min-h-[300px] w-full",
            onClick: () => {
              push(reservationUrl);
            }
          }
        ) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "border-b py-2", children: worker.fullName }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative pt-2 pb-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            ref: descriptionRef,
            className: "\n              overflow-hidden \n              transition-all duration-300 ease-in-out\n              ".concat(isExpanded ? "max-h-none" : "max-h-[3em]", "\n            "),
            style: { lineHeight: "1.5em", minHeight: "3em" },
            children: worker.description
          }
        ),
        isOverflowing && !isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-0 right-0 bg-transparent", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonButton,
          {
            fill: "clear",
            size: "small",
            onClick: (e) => {
              e.preventDefault();
              e.stopPropagation();
              setIsExpanded(true);
            },
            className: "opacity-80 bg-gray-800 ion-no-padding !px-2 !py-0",
            children: t2("Vi큄e")
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          color: "dark",
          className: "w-full mt-2",
          routerLink: reservationUrl,
          children: t2("Zaka탑ite")
        }
      )
    ] })
  ] });
}
const WorkerItem$1 = reactExports.memo(WorkerItem);
function WorkersList({ locationSlug }) {
  const { data: workersResult, isLoading: workersLoading } = useGetFeWorkersQuery({ locationSlug });
  if (workersLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SwiperWrapper$1,
    {
      spaceBetween: 10,
      slidesPerView: "auto",
      className: "w-full",
      autoplay: {
        delay: 2e3,
        disableOnInteraction: true,
        pauseOnMouseEnter: true
      },
      children: workersResult == null ? void 0 : workersResult.data.map((worker) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        SwiperSlide,
        {
          style: { width: "auto" },
          className: "max-w-[300px]",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(WorkerItem$1, { worker })
        },
        worker.id
      ))
    }
  );
}
const preloadCoverImg = "/app/assets/logo-16x9-CTehlU2H.webp";
const newsApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getNewsList: builder.query({
      query: ({ locationSlug, ...filters }) => ({
        url: "news",
        method: "GET",
        params: { locationSlug, ...filters }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.NEWS]
    }),
    getNewsOne: builder.query({
      query: ({ id }) => ({
        url: "news/".concat(id),
        method: "GET",
        params: { id }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.NEWS]
    }),
    getActiveNews: builder.query({
      query: ({ locationSlug }) => ({
        url: "news/active",
        method: "GET",
        params: { locationSlug }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.NEWS]
    }),
    createNews: builder.mutation(
      {
        query: (body) => ({
          url: "news",
          method: "POST",
          body: humpsExports.decamelizeKeys(body)
        }),
        transformResponse: transformStandardResponseToCamelCase,
        invalidatesTags: [TagType$1.NEWS]
      }
    ),
    updateNews: builder.mutation(
      {
        query: (body) => ({
          url: "news/".concat(body.id),
          method: "PUT",
          body: humpsExports.decamelizeKeys(body)
        }),
        transformResponse: transformStandardResponseToCamelCase,
        invalidatesTags: [TagType$1.NEWS]
      }
    ),
    deleteNews: builder.mutation({
      query: ({ id }) => ({
        url: "news/".concat(id),
        method: "DELETE"
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.NEWS]
    })
  })
});
const {
  useGetNewsListQuery,
  useGetNewsOneQuery,
  useGetActiveNewsQuery,
  useCreateNewsMutation,
  useUpdateNewsMutation
} = newsApi;
function NewsChyron({ className = "" }) {
  const { t: t2 } = useTranslation();
  const [currentNewsIndex, setCurrentNewsIndex] = reactExports.useState(0);
  const swiperRef = reactExports.useRef(null);
  const { data: activeNewsResponse, isLoading } = useGetActiveNewsQuery({
    locationSlug: activeLocation
  });
  const activeNews = (activeNewsResponse == null ? void 0 : activeNewsResponse.data) || [];
  if (isLoading) {
    return null;
  }
  if (activeNews.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonCard, { className: "news-chyron ".concat(className), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { className: "ion-padding-vertical text-left", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonIcon,
        {
          icon: megaphoneOutline,
          color: "warning",
          className: "text-2xl animate-pulse"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "warning", className: "text-sm font-medium", children: t2("Va탑na saop큄tenja") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwiperWrapper$1,
      {
        ref: swiperRef,
        slidesPerView: 1,
        spaceBetween: 0,
        autoplay: {
          delay: 5e3,
          disableOnInteraction: false,
          pauseOnMouseEnter: true
        },
        onSlideChange: (swiper) => setCurrentNewsIndex(swiper.activeIndex),
        className: "news-swiper",
        children: activeNews.map((news, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { className: "text-base block text-gray-300", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-2xl font-bold", children: news.title }),
          news.description && news.description.trim() !== "" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "ml-2 text-lg", children: [
            "- ",
            news.description
          ] })
        ] }) }, news.id || index))
      }
    ) }),
    activeNews.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center gap-1 mt-2", children: activeNews.map((_, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "w-3 h-3 rounded-full transition-colors duration-300 ".concat(index === currentNewsIndex ? "bg-gray-300" : "bg-gray-600"),
        onClick: () => {
          var _a2;
          return (_a2 = swiperRef.current) == null ? void 0 : _a2.swiper.slideTo(index);
        }
      },
      index
    )) })
  ] }) });
}
function HomePage() {
  var _a2, _b2;
  const { data: locationResponse } = useGetFeLocationQuery(
    {
      slug: activeLocation
    },
    { skip: !!(preloadedLocationData == null ? void 0 : preloadedLocationData.id) }
  );
  const locationData = preloadedLocationData != null ? preloadedLocationData : locationResponse == null ? void 0 : locationResponse.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    LayoutMainPage,
    {
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: (_a2 = locationData == null ? void 0 : locationData.title) != null ? _a2 : "..." }),
      headerClasses: mainHeaderClasses,
      installAppHeaderHandle: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(NewsChyron, { className: "ion-margin" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(WorkersList, { locationSlug: activeLocation }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonCard, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { className: "text-lg", children: locationData == null ? void 0 : locationData.description }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonCard, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: 'flex justify-center items-center w-full"', children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          LazyLoadImgStandard$1,
          {
            src: (_b2 = locationData == null ? void 0 : locationData.logo) == null ? void 0 : _b2.path,
            className: "max-h-[200px] w-auto min-h-[150px]",
            preloadImg: preloadCoverImg
          }
        ) }) }) })
      ]
    }
  );
}
const reservationApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    createFeReservation: builder.mutation({
      query: (body) => ({
        url: "locations/reservations/create-new",
        method: "POST",
        body
      }),
      invalidatesTags: [
        { type: TagType$1.RESERVATION, id: TagId$1.LIST },
        TagType$1.USER_NOTIFICATIONS
      ]
    }),
    updateFeReservation: builder.mutation({
      query: ({ clientData, ...body }) => ({
        url: "locations/reservations/update",
        method: "PUT",
        body: {
          ...body,
          clientData: humpsExports.decamelizeKeys(clientData)
        }
      }),
      invalidatesTags: (result) => {
        var _a2;
        return [
          { type: TagType$1.RESERVATION, id: TagId$1.LIST },
          { type: TagType$1.RESERVATION, id: (_a2 = result == null ? void 0 : result.data) == null ? void 0 : _a2.hash },
          TagType$1.USER_NOTIFICATIONS
        ];
      }
    }),
    getOneFeReservation: builder.query({
      query: (params) => ({
        url: "locations/reservations/get-one",
        method: "GET",
        params
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: (result) => {
        var _a2;
        return [
          { type: TagType$1.RESERVATION, id: (_a2 = result == null ? void 0 : result.data) == null ? void 0 : _a2.hash },
          TagType$1.USER
        ];
      }
    }),
    getFeLocationReservations: builder.query({
      query: (params) => ({
        url: "locations/reservations",
        method: "GET",
        params
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [
        { type: TagType$1.RESERVATION, id: TagId$1.LIST },
        TagType$1.USER
      ]
    }),
    getFeLocationClientReservations: builder.query({
      query: (params) => ({
        url: "locations/reservations/client",
        method: "GET",
        params
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [
        { type: TagType$1.RESERVATION, id: TagId$1.LIST },
        TagType$1.USER
      ]
    }),
    getFePromoCodeData: builder.query({
      query: (params) => ({
        url: "locations/promo-codes/find",
        method: "GET",
        params
      }),
      transformResponse: transformStandardResponseToCamelCase
    })
  })
});
const {
  useCreateFeReservationMutation,
  useGetOneFeReservationQuery,
  useUpdateFeReservationMutation,
  useGetFeLocationReservationsQuery,
  useGetFeLocationClientReservationsQuery,
  useGetFePromoCodeDataQuery
} = reservationApi;
var AppointmentStatus = /* @__PURE__ */ ((AppointmentStatus2) => {
  AppointmentStatus2[AppointmentStatus2["DRAFT"] = 0] = "DRAFT";
  AppointmentStatus2[AppointmentStatus2["PENDING"] = 1] = "PENDING";
  AppointmentStatus2[AppointmentStatus2["CONFIRMED"] = 2] = "CONFIRMED";
  AppointmentStatus2[AppointmentStatus2["CANCELLED"] = 3] = "CANCELLED";
  AppointmentStatus2[AppointmentStatus2["NO_SHOW"] = 4] = "NO_SHOW";
  return AppointmentStatus2;
})(AppointmentStatus || {});
const APPOINTMENT_STATUS_LABELS = {
  [
    0
    /* DRAFT */
  ]: "Nacrt",
  [
    1
    /* PENDING */
  ]: "Na 훾ekanju",
  [
    2
    /* CONFIRMED */
  ]: "Potvr휃en",
  [
    3
    /* CANCELLED */
  ]: "Otkazan",
  [
    4
    /* NO_SHOW */
  ]: "Nije se pojavio"
};
function AppointmentItem({ reservation, workersById }) {
  var _a2;
  const color = reactExports.useMemo(() => {
    switch (reservation.status) {
      case AppointmentStatus.DRAFT:
        return "secondary";
      case AppointmentStatus.PENDING:
        return "warning";
      case AppointmentStatus.CONFIRMED:
        return "success";
      case AppointmentStatus.CANCELLED:
        return "danger";
      default:
        return "primary";
    }
  }, [reservation]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonItem,
    {
      className: "border m-2",
      routerLink: "".concat(urlPrefix, "/r/").concat(reservation.hash),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: cutOutline, color, className: "mr-2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: (_a2 = workersById == null ? void 0 : workersById[reservation.locationWorkerId]) == null ? void 0 : _a2.fullName }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: format(parseISO(reservation.dateUtc), "dd.MM.yyyy HH:mm") })
      ]
    },
    reservation.hash
  );
}
function ActiveAppointmentsList() {
  const { t: t2 } = useTranslation();
  const { userData } = useUser();
  const { data: clientReservations, isLoading: isClientReservationsLoading } = useGetFeLocationClientReservationsQuery(
    {
      locationSlug: activeLocation,
      archive: 0
    },
    {
      skip: !(userData == null ? void 0 : userData.id)
      // pollingInterval: 15000,
    }
  );
  const { data: locationWorkers, isLoading: isWorkersLoading } = useGetFeWorkersQuery({
    locationSlug: activeLocation
  });
  const clientReservationsList = clientReservations == null ? void 0 : clientReservations.data;
  const workersById = reactExports.useMemo(
    () => {
      var _a2;
      return (_a2 = locationWorkers == null ? void 0 : locationWorkers.data) == null ? void 0 : _a2.reduce((acc, worker) => {
        acc[worker.id] = worker;
        return acc;
      }, {});
    },
    [locationWorkers]
  );
  if (isClientReservationsLoading || isWorkersLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {});
  }
  if (!workersById) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { children: [
    !(clientReservationsList == null ? void 0 : clientReservationsList.length) && /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "border-t mt-4", children: t2("Nema podataka") }),
    clientReservationsList == null ? void 0 : clientReservationsList.map((reservation) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      AppointmentItem,
      {
        reservation,
        workersById
      },
      reservation.hash
    ))
  ] });
}
function ArchivedAppointmentsList() {
  const { t: t2 } = useTranslation();
  const { userData } = useUser();
  const [page, setPage] = reactExports.useState(1);
  const { data: clientReservations, isLoading: isClientReservationsLoading } = useGetFeLocationClientReservationsQuery(
    {
      locationSlug: activeLocation,
      archive: 1,
      page,
      perPage: 10
    },
    {
      skip: !(userData == null ? void 0 : userData.id)
    }
  );
  const { data: locationWorkers, isLoading: isWorkersLoading } = useGetFeWorkersQuery({
    locationSlug: activeLocation
  });
  const clientReservationsList = clientReservations == null ? void 0 : clientReservations.data;
  const workersById = reactExports.useMemo(
    () => {
      var _a2;
      return (_a2 = locationWorkers == null ? void 0 : locationWorkers.data) == null ? void 0 : _a2.reduce((acc, worker) => {
        acc[worker.id] = worker;
        return acc;
      }, {});
    },
    [locationWorkers]
  );
  if (isClientReservationsLoading || isWorkersLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {});
  }
  if (!workersById) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { children: [
    !(clientReservationsList == null ? void 0 : clientReservationsList.length) && /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "border-t mt-4", children: t2("Nema podataka") }),
    clientReservationsList == null ? void 0 : clientReservationsList.map((reservation) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      AppointmentItem,
      {
        reservation,
        workersById
      },
      reservation.hash
    )),
    (clientReservations == null ? void 0 : clientReservations.total) && clientReservations.total > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Pagination,
      {
        currentPage: page,
        totalPages: clientReservations.lastPage,
        onPageChange: setPage
      }
    )
  ] });
}
function AppointmentPage() {
  const { t: t2 } = useTranslation();
  const [activeStep, handleSetStep] = reactExports.useState(0);
  const handleSegmentChange = (segment) => {
    if (activeStep !== segment.detail.value) {
      handleSetStep(segment.detail.value);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    LayoutMainPage,
    {
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Termini") }),
      headerClasses: mainHeaderClasses,
      footer: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          routerLink: "".concat(urlPrefix, "/zakazi-novo"),
          color: "dark",
          size: "large",
          className: "border border-gray-500 mb-8",
          children: t2("Zaka탑ite nov termin")
        }
      ),
      additionalHeader: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { className: "border-t", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonSegment, { value: activeStep, onIonChange: handleSegmentChange, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonSegmentButton, { value: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Aktivni termini") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonSegmentButton, { value: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Arhiva") }) })
      ] }) }),
      installAppHeaderHandle: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(NewsChyron, { className: "ion-margin" }),
        activeStep === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(ActiveAppointmentsList, {}),
        activeStep === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(ArchivedAppointmentsList, {})
      ]
    }
  );
}
const UserAvatar = ({
  fullName,
  size = 48
}) => {
  const getInitials = (name) => {
    const names = name.split(" ");
    if (names.length >= 2) {
      return "".concat(names[0][0]).concat(names[1][0]).toUpperCase();
    }
    return name.substring(0, 2).toUpperCase();
  };
  const getRandomColor = (name) => {
    const colors = [
      "#FF6B6B",
      // Red
      "#4ECDC4",
      // Teal
      "#45B7D1",
      // Blue
      "#96CEB4",
      // Green
      "#FFEEAD",
      // Yellow
      "#D4A5A5",
      // Pink
      "#9B59B6",
      // Purple
      "#3498DB"
      // Light Blue
    ];
    const index = name.split("").reduce((acc, char) => acc + char.charCodeAt(0), 0);
    return colors[index % colors.length];
  };
  const initials = getInitials(fullName);
  const backgroundColor = getRandomColor(fullName);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonAvatar,
    {
      style: {
        width: "".concat(size, "px"),
        height: "".concat(size, "px"),
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        backgroundColor,
        color: "#FFFFFF",
        fontSize: "".concat(size * 0.4, "px"),
        fontWeight: "bold"
      },
      children: initials
    }
  );
};
const statisticsApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getClientStatistics: builder.query({
      query: ({ clientId, locationSlug, forceUpdate }) => ({
        url: "statistics/client",
        method: "GET",
        params: { clientId, locationSlug, forceUpdate }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.CLIENT]
    }),
    getWorkerStatistics: builder.query({
      query: ({ workerId, locationSlug, forceUpdate }) => ({
        url: "statistics/worker",
        method: "GET",
        params: { workerId, locationSlug, forceUpdate }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.LOCATION_WORKERS]
    }),
    getLocationStatistics: builder.query({
      query: ({ locationSlug, forceUpdate }) => ({
        url: "statistics/location",
        method: "GET",
        params: { locationSlug, forceUpdate }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.LOCATION]
    })
  })
});
const {
  useGetClientStatisticsQuery,
  useGetWorkerStatisticsQuery,
  useGetLocationStatisticsQuery
} = statisticsApi;
const formatDate$1 = (dateString) => {
  if (!dateString) return null;
  try {
    const date = parseISO(dateString);
    return format(date, "dd.MM.yyyy HH:mm");
  } catch (e) {
    return dateString;
  }
};
const formatPrice$2 = (price) => {
  return new Intl.NumberFormat("sr-RS").format(price);
};
function ClientStatistics({
  clientId,
  locationSlug
}) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j;
  const [forceUpdate, setForceUpdate] = reactExports.useState(0);
  const { t: t2 } = useTranslation();
  const { data, isLoading } = useGetClientStatisticsQuery({
    clientId,
    locationSlug,
    forceUpdate
  });
  const handleForceRefresh = reactExports.useCallback(() => {
    setForceUpdate((prev) => prev + 1);
  }, []);
  if (isLoading) return /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {});
  if (!data) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t2("N/A") });
  const formattedLastVisit = formatDate$1((_b2 = (_a2 = data.data) == null ? void 0 : _a2.data) == null ? void 0 : _b2.lastVisit);
  const formattedCostSum = formatPrice$2(((_d2 = (_c2 = data.data) == null ? void 0 : _c2.data) == null ? void 0 : _d2.costSum) || 0);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardTitle, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-left", children: t2("Statistika") }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarOutline, slot: "start" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          t2("Ukupno rezervacija"),
          ":",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: ((_f2 = (_e2 = data.data) == null ? void 0 : _e2.data) == null ? void 0 : _f2.totalReservations) || 0 }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: checkmarkCircleOutline, slot: "start", color: "success" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          t2("Potvr휃ene rezervacije"),
          ":",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "success", children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: ((_h2 = (_g2 = data.data) == null ? void 0 : _g2.data) == null ? void 0 : _h2.confirmedReservationsCount) || 0 }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeCircleOutline, slot: "start", color: "danger" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          t2("Otkazane rezervacije"),
          ":",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: ((_j = (_i2 = data.data) == null ? void 0 : _i2.data) == null ? void 0 : _j.canceledReservationsCount) || 0 }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: timeOutline, slot: "start" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          t2("Poslednja poseta"),
          ":",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: formattedLastVisit || t2("N/A") }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: walletOutline, slot: "start" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          t2("Ukupan iznos kori큄훶enih usluga"),
          ":",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "primary", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
            formattedCostSum,
            " RSD"
          ] }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-text-center ion-padding-top", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButton, { fill: "clear", onClick: handleForceRefresh, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: refreshOutline, slot: "start" }),
        t2("Osve탑i")
      ] }) })
    ] })
  ] });
}
const clientApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getFeClientData: builder.query({
      query: () => ({
        url: "users/client-data",
        method: "GET"
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.CLIENT, TagType$1.USER]
    }),
    updateFeClientData: builder.mutation({
      query: (body) => ({
        url: "users/client",
        method: "POST",
        body: humpsExports.decamelizeKeys(body)
      }),
      invalidatesTags: [TagType$1.CLIENT]
    }),
    getFeLocationClients: builder.query({
      query: (params) => ({
        url: "locations/clients",
        method: "GET",
        params
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.USER]
    }),
    getUserNotifications: builder.query({
      query: (params) => ({
        url: "users/notifications",
        method: "GET",
        params
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [TagType$1.USER_NOTIFICATIONS]
    })
  })
});
const {
  useGetFeClientDataQuery,
  useUpdateFeClientDataMutation,
  useGetFeLocationClientsQuery,
  useGetUserNotificationsQuery
} = clientApi;
const useAppDispatch = () => useDispatch();
const useAppSelector = useSelector;
const getAdministrationClientFormFields = (isPhoneNumberDisabled, fullNameOptions, handleAddNewOption) => [
  {
    keyName: "id",
    name: "fullName",
    data: {
      type: FieldType.Autocomplete,
      label: t("Prona휃i korisnika"),
      options: fullNameOptions,
      handleAddNewOption
    },
    colClassNames: "border"
  }
];
const getClientFormFields = (isPhoneNumberDisabled, formDisabled = false) => [
  {
    keyName: "fullName",
    name: "fullName",
    data: {
      type: FieldType.Text,
      label: t("Ime i prezime")
    },
    gridSize: {
      size: "12"
    },
    disabled: formDisabled,
    required: true
  },
  {
    keyName: "phoneNumber",
    name: "phoneNumber",
    data: {
      type: FieldType.Text,
      label: t("Broj telefona")
    },
    gridSize: {
      size: "12"
    },
    disabled: isPhoneNumberDisabled || formDisabled,
    required: true
  },
  {
    keyName: "dateOfBirth",
    name: t("Datum ro휃enja"),
    data: {
      type: FieldType.Date,
      label: t("Datum ro휃enja"),
      inputProps: {
        presentation: "date",
        preferWheel: true,
        max: new Date(
          (/* @__PURE__ */ new Date()).setFullYear((/* @__PURE__ */ new Date()).getFullYear() - 15)
        ).toISOString(),
        locale: instance.language === "rs" ? "sr-Latn-RS" : "en-GB"
      },
      defaultValue: "1990-01-01"
    },
    gridSize: { size: "12" },
    disabled: formDisabled
  }
];
const clientSchema = yup.object().shape({
  id: yup.mixed().required().nullable(),
  fullName: yup.string().required("Ime i prezime je obavezno"),
  phoneNumber: yup.string().matches(/^[06]\d{6,11}$/, {
    message: t("Broj telefona mora po훾eti sa 06 i imati od 6 do 12 cifara")
  }).required("Broj telefona je obavezan"),
  dateOfBirth: yup.string().required().nullable()
});
function ClientDataModal({
  isOpen,
  onCancel,
  onSave,
  cancelLabel,
  saveLabel,
  initialData
}) {
  var _a2, _b2, _c2, _d2;
  const form = useFormWithSchema(clientSchema, {
    defaultValues: {
      id: (_a2 = initialData == null ? void 0 : initialData.id) != null ? _a2 : null,
      fullName: (_b2 = initialData == null ? void 0 : initialData.fullName) != null ? _b2 : "",
      phoneNumber: (_c2 = initialData == null ? void 0 : initialData.phoneNumber) != null ? _c2 : "",
      dateOfBirth: (_d2 = initialData == null ? void 0 : initialData.dateOfBirth) != null ? _d2 : null
    }
  });
  const { handleSubmit, formState } = form;
  const formFields = getClientFormFields(false, false);
  const modalRef = reactExports.useRef(null);
  const firstInputRef = reactExports.useRef(null);
  const handleDidPresent = reactExports.useCallback(() => {
    setTimeout(() => {
      var _a3;
      const inputEl = firstInputRef.current || ((_a3 = modalRef.current) == null ? void 0 : _a3.querySelector("input"));
      inputEl == null ? void 0 : inputEl.focus();
    }, 100);
  }, []);
  const handleSave = handleSubmit((data) => {
    onSave(data);
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonModalExtended$1,
    {
      ref: modalRef,
      isOpen,
      onClose: onCancel,
      name: "client-data-modal",
      initialBreakpoint: 1,
      breakpoints: [0, 1],
      onDidPresent: handleDidPresent,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { className: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx("form", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields: formFields, form }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { color: "medium", onClick: onCancel, children: cancelLabel != null ? cancelLabel : t("Odustani") }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { color: "success", onClick: handleSave, children: saveLabel != null ? saveLabel : t("Sa훾uvaj") }) })
        ] }) })
      ]
    }
  );
}
const formatDate = (dateString) => {
  if (!dateString) return null;
  try {
    const date = parseISO(dateString);
    return format(date, "dd.MM.yyyy HH:mm");
  } catch (e) {
    return dateString;
  }
};
const formatPrice$1 = (price) => {
  return new Intl.NumberFormat("sr-RS").format(price);
};
function WorkerStatistics({
  workerId,
  locationSlug
}) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j;
  const [forceUpdate, setForceUpdate] = reactExports.useState(0);
  const { t: t2 } = useTranslation();
  const { data, isLoading } = useGetWorkerStatisticsQuery({
    workerId,
    locationSlug,
    forceUpdate
  });
  const handleForceRefresh = reactExports.useCallback(() => {
    setForceUpdate((prev) => prev + 1);
  }, []);
  if (isLoading) return /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {});
  if (!data) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t2("N/A") });
  const formattedLastVisit = formatDate((_b2 = (_a2 = data.data) == null ? void 0 : _a2.data) == null ? void 0 : _b2.lastVisit);
  const formattedCostSum = formatPrice$1(((_d2 = (_c2 = data.data) == null ? void 0 : _c2.data) == null ? void 0 : _d2.costSum) || 0);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardTitle, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-left", children: t2("Statistika radnika") }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarOutline, slot: "start" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          t2("Ukupno rezervacija"),
          ":",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "primary", children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: ((_f2 = (_e2 = data.data) == null ? void 0 : _e2.data) == null ? void 0 : _f2.totalReservations) || 0 }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: checkmarkCircleOutline, slot: "start", color: "success" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          t2("Potvr휃ene rezervacije"),
          ":",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "success", children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: ((_h2 = (_g2 = data.data) == null ? void 0 : _g2.data) == null ? void 0 : _h2.confirmedReservationsCount) || 0 }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeCircleOutline, slot: "start", color: "danger" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          t2("Otkazane rezervacije"),
          ":",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: ((_j = (_i2 = data.data) == null ? void 0 : _i2.data) == null ? void 0 : _j.canceledReservationsCount) || 0 }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: timeOutline, slot: "start" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          t2("Poslednja usluga"),
          ":",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: formattedLastVisit || t2("N/A") }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: walletOutline, slot: "start" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          t2("Ukupan iznos kori큄훶enih usluga"),
          ":",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "primary", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
            formattedCostSum,
            " RSD"
          ] }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-text-center ion-padding-top", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButton, { fill: "clear", onClick: handleForceRefresh, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: refreshOutline, slot: "start" }),
        t2("Osve탑i")
      ] }) })
    ] })
  ] });
}
const clientProfileApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getClientProfiles: builder.query({
      query: ({ locationSlug, page = 1, perPage = 10 }) => ({
        url: "/workers/clients",
        method: "GET",
        params: {
          locationSlug,
          page,
          perPage
        }
      }),
      transformResponse: transformPaginationResponseToCamelCase
    }),
    getWorkerClientData: builder.query({
      query: ({ clientId }) => ({
        url: "/workers/client",
        method: "GET",
        params: {
          clientId
        }
      }),
      transformResponse: transformStandardResponseToCamelCase
    })
  })
});
const { useGetClientProfilesQuery, useGetWorkerClientDataQuery } = clientProfileApi;
const ITEMS_PER_PAGE$1 = 10;
function ClientProfilesList() {
  const { t: t2 } = useTranslation();
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const { setValue: copyToClipboard } = useClipboard();
  const { data, isLoading } = useGetClientProfilesQuery({
    locationSlug: activeLocation,
    page: currentPage,
    perPage: ITEMS_PER_PAGE$1
  });
  const handleEmailClick = (email) => {
    if (email) {
      copyToClipboard(email);
    }
  };
  const handlePhoneClick = (phoneNumber) => {
    if (phoneNumber) {
      window.location.href = "tel:".concat(phoneNumber);
    }
  };
  if (isLoading) return /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {});
  if (!(data == null ? void 0 : data.data)) return null;
  const totalPages = Math.ceil(data.total / ITEMS_PER_PAGE$1);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardTitle, { children: t2("Lista klijenata") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonAccordionGroup, { children: data.data.map((client) => {
        var _a2, _b2;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonAccordion, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { slot: "header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: client.fullName }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "ion-text-end flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarOutline, className: "mr-1" }),
              client.confirmedReservationsCount
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { slot: "content", className: "ion-padding", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonItem,
              {
                lines: "none",
                button: !!(client.email || ((_a2 = client.user) == null ? void 0 : _a2.email)),
                onClick: () => {
                  var _a3;
                  return handleEmailClick(client.email || ((_a3 = client.user) == null ? void 0 : _a3.email) || "");
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: mailOutline, slot: "start" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: client.email || ((_b2 = client.user) == null ? void 0 : _b2.email) || t2("Nije uneto") })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonItem,
              {
                lines: "none",
                button: !!client.phoneNumber,
                onClick: () => handlePhoneClick(client.phoneNumber || ""),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: callOutline, slot: "start" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: client.phoneNumber || t2("Nije uneto") })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-text-center ion-padding-top", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonButton,
              {
                fill: "clear",
                routerLink: "".concat(urlPrefix, "/public-profile/").concat(client.id),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: personOutline, slot: "start" }),
                  t2("Profil")
                ]
              }
            ) })
          ] })
        ] }, client.id);
      }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Pagination,
        {
          currentPage,
          totalPages,
          onPageChange: setCurrentPage,
          isLoading,
          className: "ion-padding-top"
        }
      )
    ] })
  ] });
}
function Profile() {
  const { t: t2 } = useTranslation();
  const { userData, isOwnerOrWorker, isAdmin } = useUser();
  const dispatch = useAppDispatch();
  const [isEditModalOpen, setIsEditModalOpen] = reactExports.useState(false);
  const { data: clientData, isLoading } = useGetFeClientDataQuery();
  const [updateClient] = useUpdateFeClientDataMutation();
  if (!userData) {
    dispatch(setShowLoginModal(true));
    return null;
  }
  const handleEditSubmit = async (formData) => {
    await updateClient({
      fullName: formData.fullName || "",
      phoneNumber: formData.phoneNumber,
      dateOfBirth: formData.dateOfBirth || void 0
    });
    setIsEditModalOpen(false);
  };
  const handleCancel = reactExports.useCallback(() => {
    setIsEditModalOpen(false);
  }, []);
  const client = clientData == null ? void 0 : clientData.data;
  reactExports.useEffect(() => {
    var _a2;
    if (isLoading) {
      return;
    }
    if (!client || ((_a2 = client.phoneNumber) == null ? void 0 : _a2.length) === 0) {
      setIsEditModalOpen(true);
    }
  }, [clientData == null ? void 0 : clientData.data, client == null ? void 0 : client.phoneNumber, isLoading]);
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-padding", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { className: "ion-text-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardTitle, { className: "ion-padding-top flex items-center justify-between", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-padding-left flex items-center", children: [
          (client == null ? void 0 : client.fullName) && /* @__PURE__ */ jsxRuntimeExports.jsx(UserAvatar, { fullName: client.fullName, size: 30 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-padding-left ml-2", children: (client == null ? void 0 : client.fullName) || t2("Nije uneto") })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: mailOutline, slot: "start" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: userData.email })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: callOutline, slot: "start" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: (client == null ? void 0 : client.phoneNumber) || t2("Nije uneto") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarOutline, slot: "start" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: (client == null ? void 0 : client.dateOfBirth) || t2("Nije unet datum ro휃enja") })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-text-center ion-padding-top", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButton, { onClick: () => setIsEditModalOpen(true), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: pencilOutline, slot: "start" }),
            t2("Uredi profil")
          ] }) })
        ] })
      ] }),
      activeLocation && client && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ConditionalComponent,
        {
          condition: isOwnerOrWorker != null ? isOwnerOrWorker : false,
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
            WorkerStatistics,
            {
              workerId: userData.id || 0,
              locationSlug: activeLocation
            }
          ),
          renderElse: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
            ClientStatistics,
            {
              clientId: client.id || 0,
              locationSlug: activeLocation
            }
          )
        }
      ),
      (isOwnerOrWorker || isAdmin) && /* @__PURE__ */ jsxRuntimeExports.jsx(ClientProfilesList, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ClientDataModal,
      {
        isOpen: isEditModalOpen,
        onCancel: handleCancel,
        onSave: handleEditSubmit,
        initialData: client
      }
    )
  ] });
}
function ProfilePage() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Profil") }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Profile, {})
    }
  );
}
function NotificationItem({ notification }) {
  var _a2;
  const reservation = (_a2 = notification.clientReservations) == null ? void 0 : _a2[0];
  const reservationLink = reservation ? "".concat(urlPrefix, "/r/").concat(reservation.hash) : void 0;
  const reservationStatus = reservation == null ? void 0 : reservation.status;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { routerLink: reservationLink, className: "border m-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonIcon,
      {
        icon: notificationsCircle,
        className: "mr-2",
        color: reservationStatus === AppointmentStatus.CONFIRMED ? "success" : reservationStatus === AppointmentStatus.CANCELLED ? "danger" : reservationStatus === AppointmentStatus.PENDING ? "warning" : "medium"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t("".concat(notification.description)) }),
    reservation && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: format(parseISO(reservation.dateUtc), "dd.MM.yyyy HH:mm") })
  ] });
}
function NotificationsList() {
  var _a2, _b2;
  const [currentPage, setCurrentPage] = reactExports.useState(0);
  const { data: notificationsResponse, isLoading: isNotificationsLoading } = useGetUserNotificationsQuery({
    locationSlug: activeLocation,
    page: currentPage
  });
  const notifications = notificationsResponse == null ? void 0 : notificationsResponse.data;
  const handlePageChange = (page) => {
    setCurrentPage(page);
  };
  if (isNotificationsLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { children: [
      !(notifications == null ? void 0 : notifications.length) && /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "border-t mt-4", children: t("Nema podataka") }),
      notifications == null ? void 0 : notifications.map((notification) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationItem, { notification }, notification.id))
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Pagination,
      {
        totalPages: (_a2 = notificationsResponse == null ? void 0 : notificationsResponse.lastPage) != null ? _a2 : 0,
        currentPage: (_b2 = notificationsResponse == null ? void 0 : notificationsResponse.currentPage) != null ? _b2 : 0,
        onPageChange: handlePageChange
      }
    )
  ] });
}
function NotificationPage() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t("Notifikacije") }),
      headerClasses: mainHeaderClasses,
      installAppHeaderHandle: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationsList, {})
    }
  );
}
function TimeSlotButtonWithLongPress({
  workingHour,
  dayDateUtc,
  isActive,
  onSelectShift,
  onLongPress,
  formatTime,
  disabled = false
}) {
  const longPressBind = V(
    () => {
      if (!disabled) {
        onLongPress(dayDateUtc, workingHour);
      }
    },
    {
      threshold: 500
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonButton,
    {
      fill: isActive ? "solid" : "outline",
      color: isActive ? "success" : "dark",
      onClick: onSelectShift(dayDateUtc, workingHour.shift, isActive),
      className: "whitespace-nowrap text-nowrap",
      disabled,
      ...longPressBind(),
      children: [
        formatTime(workingHour.timeFromUtc),
        " -",
        " ",
        formatTime(workingHour.timeToUtc)
      ]
    }
  );
}
function WorkingDayItem({
  day,
  workingHours,
  onDeleteShift,
  onSelectShift,
  onOpenOtherModal,
  onLongPressOnTimeSlot,
  getActiveShiftForDay,
  getCustomShift,
  getWorkingHoursForDay,
  isWorkingHourActive,
  formatTime,
  shouldShowRemoveButton,
  isUpdating = false,
  isRequestedDate = false
}) {
  const { t: t2 } = useTranslation();
  const activeShift = getActiveShiftForDay(day.dateUtc);
  const customShift = getCustomShift == null ? void 0 : getCustomShift(day.dateUtc);
  const showDeleteBtn = shouldShowRemoveButton(day);
  const showFullWidthColumn = day.hasWorkingHours || showDeleteBtn;
  const isDisabled = isUpdating && isRequestedDate;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "".concat(day.isLastDayOfWeek ? "border-white border-b-4" : "", " border-y border-gray-500 py-1"),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonGrid, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { className: "items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { size: showFullWidthColumn ? "12" : "6", sizeSm: "4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
            (activeShift == null ? void 0 : activeShift.shift) === null ? (
              // "Ne radim" is selected
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonIcon,
                {
                  icon: closeCircle,
                  color: "danger",
                  className: "text-xl"
                }
              )
            ) : activeShift && activeShift.shift !== null ? (
              // Some time is selected (standard or custom)
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonIcon,
                {
                  icon: checkmarkCircle,
                  color: "success",
                  className: "text-xl"
                }
              )
            ) : null,
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: day.hasWorkingHours ? "" : "text-gray-400 opacity-70",
                children: day.name
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { size: showFullWidthColumn ? "12" : "6", sizeSm: "8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 mb-2", children: [
            day.hasWorkingHours && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonButton,
              {
                className: "flex-1 min-w-0",
                color: day.activeShift === null ? "danger" : "dark",
                disabled: isDisabled,
                onClick: () => {
                  if (day.activeShift === null) {
                    onDeleteShift(day.dateUtc);
                  } else {
                    onSelectShift(day.dateUtc, null)();
                  }
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ConditionalComponent,
                    {
                      condition: day.activeShift === null,
                      render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline, className: "mr-2" }),
                      renderElse: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        IonIcon,
                        {
                          icon: notificationsOffOutline,
                          className: "mr-2"
                        }
                      )
                    }
                  ),
                  t2("Ne radim")
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonButton,
              {
                className: "flex-1 min-w-0",
                onClick: () => onOpenOtherModal(day.dateUtc),
                color: customShift ? "success" : "warning",
                size: "small",
                disabled: isDisabled,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: timeOutline, className: "mr-2" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "whitespace-nowrap", children: customShift ? "".concat(formatTime(customShift.timeFromUtc), " - ").concat(formatTime(
                    customShift.timeToUtc
                  )) : t2("Izaberi vreme") })
                ]
              }
            ),
            showDeleteBtn && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonButton,
              {
                color: "danger",
                onClick: () => onDeleteShift(day.dateUtc),
                disabled: isDisabled,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline, className: "mr-2" }),
                  t2("Ukloni")
                ]
              }
            )
          ] }) })
        ] }) }),
        day.hasWorkingHours && /* @__PURE__ */ jsxRuntimeExports.jsx(
          SwiperWrapper$1,
          {
            spaceBetween: 10,
            slidesPerView: "auto",
            freeMode: true,
            className: "w-full max-w-full",
            style: { width: "100%" },
            children: getWorkingHoursForDay(day.dateUtc).map(
              (workingHour) => {
                const isActive = isWorkingHourActive(day.dateUtc, workingHour);
                return /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { style: { width: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TimeSlotButtonWithLongPress,
                  {
                    workingHour,
                    dayDateUtc: day.dateUtc,
                    isActive,
                    onSelectShift,
                    onLongPress: onLongPressOnTimeSlot,
                    formatTime,
                    disabled: isDisabled
                  },
                  workingHour.id
                ) });
              }
            )
          }
        )
      ]
    }
  );
}
const workingShiftsApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getFeWorkingShiftsByDays: builder.query({
      query: (params) => ({
        url: "locations/working-shifts-days",
        method: "GET",
        params
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [{ type: TagType$1.SHIFT, id: "LIST" }, TagType$1.USER]
    }),
    getFeWorkerWorkingShiftsByDays: builder.query({
      query: (params) => ({
        url: "locations/workers/shifts-by-days",
        method: "GET",
        params
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [{ type: TagType$1.SHIFT_BY_DAYS, id: "LIST" }, TagType$1.USER]
    }),
    setFeWorkingDayShift: builder.mutation({
      query: (body) => ({
        url: "locations/set-working-day-shift",
        method: "POST",
        body
      }),
      invalidatesTags: [
        { type: TagType$1.SHIFT_BY_DAYS, id: "LIST" },
        { type: TagType$1.SHIFT, id: "LIST" },
        TagType$1.USER
      ]
    }),
    deleteFeWorkingDayShift: builder.mutation({
      query: (body) => ({
        url: "locations/delete-working-day-shift",
        method: "DELETE",
        body
      }),
      invalidatesTags: [
        { type: TagType$1.SHIFT_BY_DAYS, id: "LIST" },
        { type: TagType$1.SHIFT, id: "LIST" },
        TagType$1.USER
      ]
    }),
    getWorkingHours: builder.query({
      query: ({ locationSlug, workerId }) => ({
        url: "location/working-hours",
        params: {
          locationSlug,
          workerId
        },
        method: "GET"
      }),
      transformResponse: transformStandardResponseToCamelCase
    })
  })
});
const {
  useGetFeWorkingShiftsByDaysQuery,
  useGetFeWorkerWorkingShiftsByDaysQuery,
  useSetFeWorkingDayShiftMutation,
  useDeleteFeWorkingDayShiftMutation,
  useGetWorkingHoursQuery
} = workingShiftsApi;
const DEFAULT_TIME_FROM_UTC = "08:00:00";
const DEFAULT_TIME_TO_UTC = "16:00:00";
const MIN_TIME_DIFF_MINUTES = 30;
function WorkingDaysPlanCustomTime({
  isOpen,
  onClose,
  onSave,
  selectedDate,
  existingShift1000
}) {
  const { t: t2 } = useTranslation();
  const getTimeInAppTimezone = (utcTime) => {
    const timeWithSeconds = fromUtc(utcTime);
    return timeWithSeconds.substring(0, 5);
  };
  const [timeFromLocal, setTimeFromLocal] = reactExports.useState(() => {
    const utcTime = (existingShift1000 == null ? void 0 : existingShift1000.timeFromUtc) || DEFAULT_TIME_FROM_UTC;
    return getTimeInAppTimezone(utcTime);
  });
  const [timeToLocal, setTimeToLocal] = reactExports.useState(() => {
    const utcTime = (existingShift1000 == null ? void 0 : existingShift1000.timeToUtc) || DEFAULT_TIME_TO_UTC;
    return getTimeInAppTimezone(utcTime);
  });
  const [pauses, setPauses] = reactExports.useState(
    (existingShift1000 == null ? void 0 : existingShift1000.pausesUtc) || []
  );
  const [error, setError] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (existingShift1000) {
      setTimeFromLocal(getTimeInAppTimezone(existingShift1000.timeFromUtc));
      setTimeToLocal(getTimeInAppTimezone(existingShift1000.timeToUtc));
      setPauses(existingShift1000.pausesUtc || []);
    } else {
      setTimeFromLocal(getTimeInAppTimezone(DEFAULT_TIME_FROM_UTC));
      setTimeToLocal(getTimeInAppTimezone(DEFAULT_TIME_TO_UTC));
      setPauses([]);
    }
  }, [existingShift1000]);
  const isMidnight = (time) => {
    return time === "00:00:00" || time === "24:00:00";
  };
  const getTimeDifference = (timeFrom, timeTo) => {
    const from = /* @__PURE__ */ new Date("2000-01-01T".concat(timeFrom));
    const to = /* @__PURE__ */ new Date("2000-01-01T".concat(timeTo));
    return (to.getTime() - from.getTime()) / (1e3 * 60);
  };
  const validateTimeDifference = (timeFrom, timeTo) => {
    if (isMidnight(timeTo) || timeTo === "00:00") return true;
    const diff = getTimeDifference(timeFrom, timeTo);
    return diff >= MIN_TIME_DIFF_MINUTES;
  };
  const handleDateChangeFrom = (event) => {
    var _a2;
    const newTimeLocal = ((_a2 = event.detail.value) == null ? void 0 : _a2.substring(0, 5)) || "";
    setTimeFromLocal(newTimeLocal);
    if (newTimeLocal > timeToLocal && !isMidnight(timeToLocal)) {
      setTimeToLocal(newTimeLocal);
    }
    setError("");
  };
  const handleDateChangeTo = (event) => {
    var _a2;
    const newTimeLocal = ((_a2 = event.detail.value) == null ? void 0 : _a2.substring(0, 5)) || "";
    if (newTimeLocal < timeFromLocal && !isMidnight(newTimeLocal) && newTimeLocal !== "00:00") {
      setError(t2("Vreme zavr큄etka ne mo탑e biti manje od vremena po훾etka"));
      return;
    }
    if (!validateTimeDifference(timeFromLocal, newTimeLocal)) {
      setError(t2("Minimalna razlika izme휃u vremena mora biti 30 minuta"));
      return;
    }
    setTimeToLocal(newTimeLocal);
    setError("");
  };
  const addPause = () => {
    const defaultPauseFromUtc = toUtc("10:00:00");
    const defaultPauseToUtc = toUtc("11:00:00");
    setPauses([
      ...pauses,
      {
        timeFromUtc: defaultPauseFromUtc,
        timeToUtc: defaultPauseToUtc,
        daysCodes: [""]
      }
    ]);
  };
  const removePause = (index) => {
    setPauses(pauses.filter((_, i) => i !== index));
  };
  const updatePause = (index, field, value) => {
    const timeNormalized = (value == null ? void 0 : value.substring(0, 5)) + ":00";
    const utcValue = toUtc(timeNormalized);
    const updatedPauses = [...pauses];
    updatedPauses[index] = {
      ...updatedPauses[index],
      [field]: utcValue,
      daysCodes: [""]
    };
    setPauses(updatedPauses);
  };
  const handleSave = () => {
    if (timeFromLocal && timeToLocal) {
      if (timeToLocal < timeFromLocal && !isMidnight(timeToLocal)) {
        setError(t2("Vreme zavr큄etka ne mo탑e biti manje od vremena po훾etka"));
        return;
      }
      if (!validateTimeDifference(timeFromLocal, timeToLocal)) {
        setError(t2("Minimalna razlika izme휃u vremena mora biti 30 minuta"));
        return;
      }
      const timeFromUtc = toUtc(timeFromLocal + ":00");
      const timeToUtc = toUtc(timeToLocal + ":00");
      onSave(timeFromUtc, timeToUtc, pauses);
      setTimeout(() => {
        setTimeFromLocal(getTimeInAppTimezone(DEFAULT_TIME_FROM_UTC));
        setTimeToLocal(getTimeInAppTimezone(DEFAULT_TIME_TO_UTC));
        setPauses([]);
      }, 300);
      setError("");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonModalExtended$1,
    {
      name: "custom-working-hours",
      isOpen,
      onClose,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: t2("Izaberite radno vreme") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline }) }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonGrid, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCol, { style: { textAlign: "-webkit-center" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t2("Vreme od") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonDatetime,
                {
                  itemType: "time",
                  presentation: "time",
                  preferWheel: true,
                  hourCycle: "h23",
                  minuteValues: "0,30",
                  onIonChange: handleDateChangeFrom,
                  value: timeFromLocal
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-300 mt-2", children: timeFromLocal })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCol, { style: { textAlign: "-webkit-center" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t2("Vreme do") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonDatetime,
                {
                  itemType: "time",
                  presentation: "time",
                  preferWheel: true,
                  hourCycle: "h24",
                  minuteValues: "0,30",
                  onIonChange: handleDateChangeTo,
                  value: timeToLocal
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-300 mt-2", children: timeToLocal })
            ] })
          ] }),
          error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { className: "mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center text-sm text-red-500", children: error }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { className: "mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCol, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center text-lg font-semibold text-white mb-2", children: t2("Pauze") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { children: [
              pauses.map((pause, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonGrid, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCol, { size: "4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-300", children: t2("Od") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    IonDatetime,
                    {
                      itemType: "time",
                      presentation: "time",
                      preferWheel: true,
                      hourCycle: "h23",
                      minuteValues: "0,30",
                      onIonChange: (e) => updatePause(
                        index,
                        "timeFromUtc",
                        e.detail.value || ""
                      ),
                      value: getTimeInAppTimezone(pause.timeFromUtc)
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-400 mt-1", children: fromUtcHM(pause.timeFromUtc) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCol, { size: "4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-300", children: t2("Do") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    IonDatetime,
                    {
                      itemType: "time",
                      presentation: "time",
                      preferWheel: true,
                      hourCycle: "h23",
                      minuteValues: "0,30",
                      onIonChange: (e) => updatePause(
                        index,
                        "timeToUtc",
                        e.detail.value || ""
                      ),
                      value: getTimeInAppTimezone(pause.timeToUtc)
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-400 mt-1", children: fromUtcHM(pause.timeToUtc) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonCol,
                  {
                    size: "4",
                    className: "flex items-center justify-center",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      IonButton,
                      {
                        color: "danger",
                        size: "small",
                        onClick: () => removePause(index),
                        children: t2("Ukloni")
                      }
                    )
                  }
                )
              ] }) }) }, index)),
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  color: "success",
                  onClick: addPause,
                  className: "w-full",
                  children: t2("Dodaj pauzu")
                }
              ) })
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { className: "mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center text-sm text-gray-200", children: t2(
            "Izaberite vreme po훾etka i kraja radnog vremena. Vreme se bira u intervalima od 30 minuta."
          ) }) }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonButton,
            {
              onClick: onClose,
              color: "warning",
              className: "p-2",
              slot: "start",
              children: t2("Odustani")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonButton,
            {
              onClick: handleSave,
              color: "primary",
              className: "p-2",
              slot: "end",
              disabled: !timeFromLocal || !timeToLocal || !!error,
              children: t2("Sa훾uvaj")
            }
          )
        ] }) })
      ]
    }
  );
}
const CUSTOM_SHIFT = 1e3;
function WorkingDaysPlanList({ locationWorker }) {
  const today = toZonedTime(/* @__PURE__ */ new Date(), getAppTimezone());
  const { t: t2 } = useTranslation();
  const [currentDate, setCurrentDate] = reactExports.useState(today);
  const [requestedDate, setRequestedDate] = reactExports.useState([]);
  const [isOtherModalOpen, setIsOtherModalOpen] = reactExports.useState(false);
  const [selectedDate, setSelectedDate] = reactExports.useState("");
  const [selectedTimeFrom, setSelectedTimeFrom] = reactExports.useState("");
  const [selectedTimeTo, setSelectedTimeTo] = reactExports.useState("");
  const [selectedPauses, setSelectedPauses] = reactExports.useState([]);
  const monthOffset = reactExports.useMemo(() => {
    return differenceInCalendarMonths(currentDate, today);
  }, [currentDate]);
  const {
    data: workingShiftsByDays,
    isFetching: workingShiftsDaysFetching,
    isLoading: workingShiftsDaysLoading,
    refetch: workingShiftsReftech
  } = useGetFeWorkingShiftsByDaysQuery({
    locationSlug: activeLocation,
    monthOffset
  });
  const { data: workingHours } = useGetWorkingHoursQuery({
    locationSlug: activeLocation,
    workerId: locationWorker.id
  });
  const [setWorkingDayShift, setWorkingDayShiftResult] = useSetFeWorkingDayShiftMutation();
  const [deleteWorkingDayShift, deleteWorkingDayShiftResult] = useDeleteFeWorkingDayShiftMutation();
  const getShiftForDay = (date) => {
    if (workingShiftsByDays) {
      const shift = workingShiftsByDays == null ? void 0 : workingShiftsByDays.data.find(
        (day) => getUtcDateFormattedInTz(day.dateUtc) === date && day.locationWorkerId === locationWorker.id
      );
      return (shift == null ? void 0 : shift.shift) !== void 0 ? shift.shift : void 0;
    }
    return void 0;
  };
  const getSlotKey = (timeFromUtc, timeToUtc, pausesUtc) => {
    const pausesHash = (pausesUtc == null ? void 0 : pausesUtc.map((p) => "".concat(p.timeFromUtc, "-").concat(p.timeToUtc)).sort().join("|")) || "";
    return "".concat(timeFromUtc, "-").concat(timeToUtc, "-").concat(pausesHash);
  };
  const getActiveShiftForDay = (date) => {
    if (!workingShiftsByDays) return null;
    const shift = workingShiftsByDays.data.find(
      (day) => getUtcDateFormattedInTz(day.dateUtc) === date && day.locationWorkerId === locationWorker.id
    );
    return shift || null;
  };
  const getCustomShift = (date) => {
    var _a2;
    if (workingShiftsByDays) {
      const shift = workingShiftsByDays == null ? void 0 : workingShiftsByDays.data.find(
        (day) => getUtcDateFormattedInTz(day.dateUtc) === date && day.locationWorkerId === locationWorker.id && day.shift === CUSTOM_SHIFT
      );
      if (shift) {
        return {
          timeFromUtc: shift.timeFromUtc,
          timeToUtc: shift.timeToUtc,
          pausesUtc: ((_a2 = shift.pausesUtc) == null ? void 0 : _a2.map((pause) => ({
            timeFromUtc: pause.timeFromUtc,
            timeToUtc: pause.timeToUtc,
            daysCodes: []
            // DayShiftPause doesn't have daysCodes, so we provide empty array
          }))) || []
        };
      }
    }
    return void 0;
  };
  const getWorkingHoursForDay = (date) => {
    const dayApp = toZonedTime(date, getAppTimezone());
    const dayOfWeek = format(dayApp, "EEE").toLowerCase();
    return (workingHours == null ? void 0 : workingHours.data.filter(
      (workingHour) => {
        var _a2;
        return (_a2 = workingHour.daysCodes) == null ? void 0 : _a2.includes(dayOfWeek);
      }
    )) || [];
  };
  const isWorkingHourActive = (date, workingHour) => {
    var _a2;
    const activeShift = getActiveShiftForDay(date);
    if (!activeShift || activeShift.shift === null) return false;
    if (activeShift.shift === CUSTOM_SHIFT) {
      return false;
    }
    const dayOfWeek = format(new Date(date), "EEE").toLowerCase();
    const workingHourPauses = ((_a2 = workingHour.pausesUtc) == null ? void 0 : _a2.filter((pause) => {
      var _a3;
      return (_a3 = pause.daysCodes) == null ? void 0 : _a3.includes(dayOfWeek);
    }).map((pause) => ({
      timeFromUtc: pause.timeFromUtc,
      timeToUtc: pause.timeToUtc
    }))) || [];
    const activeShiftPauses = activeShift.pausesUtc || [];
    return activeShift.shift === workingHour.shift && activeShift.timeFromUtc === workingHour.timeFromUtc && activeShift.timeToUtc === workingHour.timeToUtc && getSlotKey(
      activeShift.timeFromUtc,
      activeShift.timeToUtc,
      activeShiftPauses
    ) === getSlotKey(
      workingHour.timeFromUtc,
      workingHour.timeToUtc,
      workingHourPauses
    );
  };
  const listOfDaysInSelectedMonth = reactExports.useMemo(() => {
    const start = getMonth(currentDate) !== getMonth(today) ? startOfMonth(currentDate) : addDays(today, 1);
    const end = endOfMonth(start);
    if (getMonth(start) !== getMonth(currentDate)) {
      return [];
    }
    return eachDayOfInterval({ start, end }).map((day) => {
      const dayInAppTz = toZonedTime(day, getAppTimezone());
      const dateString = format(dayInAppTz, "yyyy-MM-dd");
      const workingHoursForDay = getWorkingHoursForDay(dateString);
      const hasWorkingHours = workingHoursForDay.length > 0;
      return {
        name: t2("weeks.".concat(format(day, "EEEE"))) + ", " + format(day, "d."),
        dayOfWeekNumeric: format(day, "i"),
        dateUtc: dateString,
        isLastDayOfWeek: format(day, "i") === "7",
        // Sunday is the last day of the week (ISO: 1=Monday, 7=Sunday)
        activeShift: getShiftForDay(dateString),
        hasWorkingHours
      };
    });
  }, [currentDate, workingShiftsByDays, locationWorker, workingHours]);
  const handleSetNextMonth = () => {
    setCurrentDate((current) => addMonths(current, 1));
  };
  const prevDisabled = differenceInCalendarMonths(currentDate, today) === 0;
  const handleSetPreviousMonth = () => {
    if (!prevDisabled) {
      setCurrentDate((current) => subMonths(current));
    }
  };
  const isCurrentYear = reactExports.useMemo(() => {
    return format(currentDate, "yyyy") === format(today, "yyyy");
  }, [currentDate]);
  const formattedMonth = reactExports.useMemo(() => {
    return isCurrentYear ? t2("months.".concat(format(currentDate, "MMMM"))) : format(currentDate, "MMMM yyyy");
  }, [currentDate, isCurrentYear]);
  const formatTime = (timeUtc) => {
    return fromUtcHM(timeUtc);
  };
  const shouldShowRemoveButton = (day) => {
    if (day.hasWorkingHours) return false;
    const activeShift = getActiveShiftForDay(day.dateUtc);
    return activeShift && activeShift.shift !== null;
  };
  const handleDeleteShift = (date) => {
    setRequestedDate((prev) => [...prev, date]);
    deleteWorkingDayShift({
      locationSlug: activeLocation,
      workerId: locationWorker.id,
      dateUtc: date
    }).then(() => workingShiftsReftech());
  };
  const handleSelectShift = (date, shift, isDisabled) => () => {
    var _a2;
    if (isDisabled) return;
    const dayOfWeek = format(new Date(date), "EEE").toLowerCase();
    const workingHour = workingHours == null ? void 0 : workingHours.data.find((wh) => wh.shift === shift);
    const pausesForDay = ((_a2 = workingHour == null ? void 0 : workingHour.pausesUtc) == null ? void 0 : _a2.filter((pause) => {
      var _a3;
      return (_a3 = pause.daysCodes) == null ? void 0 : _a3.includes(dayOfWeek);
    }).map((pause) => ({
      timeFromUtc: pause.timeFromUtc,
      timeToUtc: pause.timeToUtc
    }))) || [];
    setRequestedDate((prev) => [...prev, date]);
    setWorkingDayShift({
      locationSlug: activeLocation,
      workerId: locationWorker.id,
      dateUtc: date,
      shift,
      pausesUtc: pausesForDay
    }).then(() => workingShiftsReftech());
  };
  const handleOpenOtherModal = (date, existingShift) => {
    setSelectedDate(date);
    if (existingShift) {
      setSelectedTimeFrom(existingShift.timeFromUtc);
      setSelectedTimeTo(existingShift.timeToUtc);
      setSelectedPauses(existingShift.pausesUtc || []);
    } else {
      setSelectedTimeFrom("");
      setSelectedTimeTo("");
      setSelectedPauses([]);
    }
    setIsOtherModalOpen(true);
  };
  const handleLongPressOnTimeSlot = (date, workingHour) => {
    var _a2;
    const dayOfWeek = format(new Date(date), "EEE").toLowerCase();
    const pausesForDay = ((_a2 = workingHour.pausesUtc) == null ? void 0 : _a2.filter((pause) => {
      var _a3;
      return (_a3 = pause.daysCodes) == null ? void 0 : _a3.includes(dayOfWeek);
    }).map((pause) => ({
      timeFromUtc: pause.timeFromUtc,
      timeToUtc: pause.timeToUtc,
      daysCodes: pause.daysCodes || []
    }))) || [];
    handleOpenOtherModal(date, {
      timeFromUtc: workingHour.timeFromUtc,
      timeToUtc: workingHour.timeToUtc,
      pausesUtc: pausesForDay
    });
  };
  const isLoading = workingShiftsDaysFetching || setWorkingDayShiftResult.isLoading || deleteWorkingDayShiftResult.isLoading;
  reactExports.useEffect(() => {
    if (!isLoading) setRequestedDate([]);
  }, [isLoading]);
  const handleSaveCustomTime = (timeFromUtc, timeToUtc, customPauses) => {
    setRequestedDate((prev) => [...prev, selectedDate]);
    setWorkingDayShift({
      locationSlug: activeLocation,
      workerId: locationWorker.id,
      dateUtc: selectedDate,
      shift: CUSTOM_SHIFT,
      timeFromUtc,
      timeToUtc,
      pausesUtc: customPauses
    }).then(() => {
      workingShiftsReftech();
      setIsOtherModalOpen(false);
    });
  };
  const handleCloseOtherModal = reactExports.useCallback(() => {
    setIsOtherModalOpen(false);
    setSelectedTimeFrom("");
    setSelectedTimeTo("");
    setSelectedPauses([]);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { className: "mt-4 sticky top-2 border-b-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleSetPreviousMonth, disabled: prevDisabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronBackOutline }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTitle, { children: [
        formattedMonth,
        workingShiftsDaysFetching && !setWorkingDayShiftResult.isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {})
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleSetNextMonth, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronForwardOutline }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: listOfDaysInSelectedMonth.map((day) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      WorkingDayItem,
      {
        ...{
          day,
          workingHours: workingHours == null ? void 0 : workingHours.data,
          onDeleteShift: handleDeleteShift,
          onSelectShift: handleSelectShift,
          onOpenOtherModal: handleOpenOtherModal,
          onLongPressOnTimeSlot: handleLongPressOnTimeSlot,
          getActiveShiftForDay,
          getCustomShift,
          getWorkingHoursForDay,
          isWorkingHourActive,
          formatTime,
          shouldShowRemoveButton,
          isUpdating: setWorkingDayShiftResult.isLoading || deleteWorkingDayShiftResult.isLoading,
          isRequestedDate: requestedDate.includes(day.dateUtc)
        }
      },
      day.name
    )) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      WorkingDaysPlanCustomTime,
      {
        isOpen: isOtherModalOpen,
        onClose: handleCloseOtherModal,
        onSave: handleSaveCustomTime,
        selectedDate,
        existingShift1000: selectedTimeFrom && selectedTimeTo ? {
          timeFromUtc: selectedTimeFrom,
          timeToUtc: selectedTimeTo,
          pausesUtc: selectedPauses
        } : getCustomShift(selectedDate)
      }
    )
  ] });
}
function SelectWorker({ onSelectWorker, selectedWorker }) {
  const { t: t2 } = useTranslation();
  const { data: workersResult, isLoading: workersLoading } = useGetFeWorkersQuery({ locationSlug: activeLocation });
  const userData = useAppSelector(getUser);
  const handleSelectWorker = (workerId) => {
    const selectedWorkerData = workersResult == null ? void 0 : workersResult.data.find(
      (worker) => worker.id.toString() === workerId.toString()
    );
    if (selectedWorkerData) {
      onSelectWorker(selectedWorkerData);
    }
  };
  reactExports.useEffect(() => {
    if (!selectedWorker && (workersResult == null ? void 0 : workersResult.data.length) && userData) {
      const worker = workersResult == null ? void 0 : workersResult.data.find(
        (worker2) => worker2.userId === userData.id
      );
      if (worker) {
        onSelectWorker(worker);
      }
    }
  }, [userData, workersResult]);
  if (workersLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "m-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonSelect,
    {
      placeholder: t2("Odaberite radnika"),
      labelPlacement: "fixed",
      interface: "action-sheet",
      onIonChange: (event) => handleSelectWorker(event.detail.value),
      value: selectedWorker == null ? void 0 : selectedWorker.id,
      children: workersResult == null ? void 0 : workersResult.data.map((worker) => /* @__PURE__ */ jsxRuntimeExports.jsx(IonSelectOption, { value: worker.id, children: worker.fullName }, worker.id))
    }
  ) });
}
function PrepareWorkingDaysShiftsPage() {
  const { t: t2 } = useTranslation();
  const { data: workersResult } = useGetFeWorkersQuery({
    locationSlug: activeLocation
  });
  const [selectedWorker, setSelectedWorker] = reactExports.useState(
    null
  );
  const handleSelectWorker = (worker) => {
    setSelectedWorker(worker);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    LayoutMainPage,
    {
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Radni dani - Izmene") }),
      hasBackButton: true,
      backButtonIcon: exitOutline,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectWorker,
          {
            onSelectWorker: handleSelectWorker,
            selectedWorker
          }
        ),
        selectedWorker && /* @__PURE__ */ jsxRuntimeExports.jsx(WorkingDaysPlanList, { locationWorker: selectedWorker })
      ]
    }
  );
}
const formatPrice = (price) => {
  return new Intl.NumberFormat("sr-RS", {
    style: "currency",
    currency: "RSD"
  }).format(price);
};
function LocationStatistics({ locationSlug }) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j, _k, _l;
  const [forceUpdate, setForceUpdate] = reactExports.useState(0);
  const { t: t2 } = useTranslation();
  const { data, isLoading } = useGetLocationStatisticsQuery({
    locationSlug,
    forceUpdate
  });
  const handleForceRefresh = reactExports.useCallback(() => {
    setForceUpdate((prev) => prev + 1);
  }, []);
  if (isLoading) return /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {});
  if (!data) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t2("N/A") });
  const formattedCostSum = formatPrice(((_b2 = (_a2 = data.data) == null ? void 0 : _a2.data) == null ? void 0 : _b2.costSum) || 0);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardTitle, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-left flex items-center justify-between", children: [
      t2("Statistika"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          fill: "clear",
          size: "small",
          onClick: handleForceRefresh,
          disabled: isLoading,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: refreshOutline })
        }
      )
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarOutline, slot: "start" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: t2("Ukupno rezervacija") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "end", className: "font-bold", children: ((_d2 = (_c2 = data.data) == null ? void 0 : _c2.data) == null ? void 0 : _d2.totalReservations) || 0 })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: checkmarkCircleOutline, slot: "start", color: "success" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: t2("Potvr휃ene rezervacije") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "end", className: "font-bold", color: "success", children: ((_f2 = (_e2 = data.data) == null ? void 0 : _e2.data) == null ? void 0 : _f2.confirmedReservationsCount) || 0 })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeCircleOutline, slot: "start", color: "danger" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: t2("Otkazane rezervacije") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "end", className: "font-bold", color: "danger", children: ((_h2 = (_g2 = data.data) == null ? void 0 : _g2.data) == null ? void 0 : _h2.canceledReservationsCount) || 0 })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: peopleOutline, slot: "start", color: "primary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: t2("Ukupno radnika") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "end", className: "font-bold", color: "primary", children: ((_j = (_i2 = data.data) == null ? void 0 : _i2.data) == null ? void 0 : _j.totalWorkers) || 0 })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: personOutline, slot: "start", color: "secondary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: t2("Ukupno klijenata") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "end", className: "font-bold", color: "secondary", children: ((_l = (_k = data.data) == null ? void 0 : _k.data) == null ? void 0 : _l.totalClients) || 0 })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { lines: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: walletOutline, slot: "start", color: "warning" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: t2("Ukupan prihod") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "end", className: "font-bold", color: "warning", children: formattedCostSum })
      ] })
    ] })
  ] });
}
function OwnerHomePage() {
  var _a2;
  const { t: t2 } = useTranslation();
  const [showActionSheet, setShowActionSheet] = reactExports.useState(false);
  const router = useIonRouter();
  const { data: locationResponse, isLoading } = useGetFeLocationQuery(
    {
      slug: activeLocation
    },
    { skip: !!(preloadedLocationData == null ? void 0 : preloadedLocationData.id) }
  );
  const locationData = preloadedLocationData != null ? preloadedLocationData : locationResponse == null ? void 0 : locationResponse.data;
  const handleActionSheetAction = (action) => {
    setShowActionSheet(false);
    switch (action) {
      case "prepare-day":
        router.push("".concat(urlPrefix, "/t/salon/pripremi"));
        break;
      case "edit-data":
        router.push("".concat(urlPrefix, "/podesavanja/podaci"));
        break;
      case "settings":
        router.push("".concat(urlPrefix, "/podesavanja/generalno"));
        break;
      case "working-hours":
        router.push("".concat(urlPrefix, "/podesavanja/radno-vreme"));
        break;
      case "workers":
        router.push("".concat(urlPrefix, "/podesavanja/radnici"));
        break;
      case "announcements":
        router.push("".concat(urlPrefix, "/podesavanja/vesti"));
        break;
      case "services":
        router.push("".concat(urlPrefix, "/podesavanja/usluge"));
        break;
      case "promo-codes":
        router.push("".concat(urlPrefix, "/podesavanja/promo-kodovi"));
        break;
    }
  };
  const headerEndActions = /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "primary", className: "justify-center mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonButton,
    {
      onClick: () => setShowActionSheet(true),
      color: "dark",
      className: "border-2 border-gray-300 rounded px-2 py-[2px]",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "start", children: t2("Pode큄avanja") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: settingsOutline, slot: "end" })
      ]
    }
  ) });
  const footer = /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 p-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonButton,
      {
        routerLink: "".concat(urlPrefix, "/zakazi-novo"),
        expand: "block",
        className: "flex-1",
        color: "dark",
        children: t2("Zaka탑ite")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonButton,
      {
        routerLink: "".concat(urlPrefix, "/t/salon/pripremi"),
        expand: "block",
        className: "flex-1",
        color: "dark",
        fill: "outline",
        children: t2("Priprema radnih dana")
      }
    )
  ] }) }) });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    LayoutMainPage,
    {
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: (_a2 = locationData == null ? void 0 : locationData.title) != null ? _a2 : "..." }),
      headerClasses: mainHeaderClasses,
      additionalHeader: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-2", children: headerEndActions }),
      installAppHeaderHandle: true,
      footer,
      children: [
        activeLocation && /* @__PURE__ */ jsxRuntimeExports.jsx(LocationStatistics, { locationSlug: activeLocation }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonActionSheet,
          {
            isOpen: showActionSheet,
            onDidDismiss: () => setShowActionSheet(false),
            header: t2("Pode큄avanja"),
            buttons: [
              {
                text: t2("Priprema radnih dana"),
                icon: timeOutline,
                handler: () => handleActionSheetAction("prepare-day")
              },
              {
                text: t2("Izmeni podatke i slike"),
                icon: createOutline,
                handler: () => handleActionSheetAction("edit-data")
              },
              {
                text: t2("Usluge"),
                icon: constructOutline,
                handler: () => handleActionSheetAction("services")
              },
              {
                text: t2("Promo kodovi"),
                icon: giftOutline,
                handler: () => handleActionSheetAction("promo-codes")
              },
              {
                text: t2("Op큄ta pode큄avanja"),
                icon: settingsOutline,
                handler: () => handleActionSheetAction("settings")
              },
              {
                text: t2("Podesi radno vreme"),
                icon: timeOutline,
                handler: () => handleActionSheetAction("working-hours")
              },
              {
                text: t2("Radnici"),
                icon: peopleOutline,
                handler: () => handleActionSheetAction("workers")
              },
              {
                text: t2("Vesti i va탑na saop큄tenja"),
                icon: megaphoneOutline,
                handler: () => handleActionSheetAction("announcements")
              },
              {
                text: t2("Otka탑i"),
                role: "cancel"
              }
            ]
          }
        )
      ]
    }
  );
}
const PAUSE_BETWEEN_SLOTS_MINUTES = 10;
const MIN_SLOT_DIFFERENCE_MINUTES = 15;
const generateTimeSlots = (date, timeFromUtc, timeToUtc, intervalMinutes, roundedSlotInterval2, locationReservations, servicesDuration, delay, pauses) => {
  const currentTime = /* @__PURE__ */ new Date();
  const dateIso = parseISO(date);
  const tz = getAppTimezone();
  const nowDate = formatInTimeZone(currentTime, tz, "yyyy-MM-dd") + "T00:00:00.000000Z";
  const nowDateIso = parseISO(nowDate);
  const nowTimeString = formatInTimeZone(currentTime, tz, "HH:mm:ss");
  const slots = [];
  let startTime = parse(timeFromUtc, "HH:mm:ss", dateIso);
  const endTime = parse(timeToUtc, "HH:mm:ss", dateIso);
  const currentTimeInTz = parse(nowTimeString, "HH:mm:ss", nowDateIso);
  if (startTime > endTime) {
    startTime = addMinutes(startTime, -24 * 60);
  }
  const interval = intervalMinutes;
  if (currentTimeInTz > endTime) {
    return slots;
  }
  if (isWithinInterval(currentTimeInTz, { start: startTime, end: endTime })) {
    const nowPlusDelay = addMinutes(currentTime, delay);
    const nextInterval = Math.ceil(nowPlusDelay.getMinutes() / intervalMinutes) * intervalMinutes;
    startTime = addMinutes(
      nowPlusDelay,
      nextInterval - nowPlusDelay.getMinutes()
    );
  }
  if (startTime > endTime) {
    return slots;
  }
  let dynamicTime = startTime;
  while (isWithinInterval(dynamicTime, { start: startTime, end: endTime })) {
    const appointmentEndTime = addMinutes(dynamicTime, servicesDuration);
    if (appointmentEndTime > endTime) {
      break;
    }
    const isCrossMidnight = parse(timeFromUtc, "HH:mm:ss", dateIso) > parse(timeToUtc, "HH:mm:ss", dateIso);
    const isPreviousDay = isCrossMidnight && dynamicTime.getDate() !== dateIso.getDate();
    const slotTime = format(dynamicTime, "HH:mm");
    const prefixedSlot = isPreviousDay ? "-".concat(slotTime) : slotTime;
    slots.push(prefixedSlot);
    const nextSlotStart = addMinutes(dynamicTime, interval);
    dynamicTime = nextSlotStart;
  }
  locationReservations.forEach((reservation) => {
    const reservationStartUtc = parseISO(reservation.dateUtc);
    const reservationEndUtc = addMinutes(
      reservationStartUtc,
      reservation.servicesDuration
    );
    const pauseStartUtc = addMinutes(
      reservationEndUtc,
      PAUSE_BETWEEN_SLOTS_MINUTES
    );
    const slotTime = formatInTimeZone(pauseStartUtc, "UTC", "HH:mm");
    const isPreviousDay = reservationEndUtc.getUTCDate() != dateIso.getUTCDate();
    const prefixedSlot = isPreviousDay ? "-".concat(slotTime) : slotTime;
    if (!slots.includes(prefixedSlot)) {
      slots.push(prefixedSlot);
    }
  });
  const slotsWithoutPauses = (pauses == null ? void 0 : pauses.length) ? slots.filter((slot) => {
    const slotStart = parse(slot, "HH:mm", dateIso);
    const slotEnd = addMinutes(slotStart, servicesDuration);
    format(dateIso, "EEE").toLowerCase();
    return !pauses.some((pause) => {
      const pauseStart = parse(pause.timeFromUtc, "HH:mm:ss", dateIso);
      const pauseEnd = parse(pause.timeToUtc, "HH:mm:ss", dateIso);
      const hasOverlap = isWithinInterval(pauseStart, {
        start: slotStart,
        end: slotEnd
      }) && differenceInMinutes(pauseStart, slotEnd) !== 0 || isWithinInterval(pauseEnd, {
        start: slotStart,
        end: slotEnd
      }) && differenceInMinutes(pauseEnd, slotStart) !== 0 || isWithinInterval(slotStart, {
        start: pauseStart,
        end: pauseEnd
      }) && differenceInMinutes(slotStart, pauseEnd) !== 0;
      return hasOverlap;
    });
  }) : slots;
  if (!locationReservations) {
    return slotsWithoutPauses;
  }
  const filteredSlots = slotsWithoutPauses.filter((slot) => {
    const isPreviousDay = slot.startsWith("-");
    const actualSlot = isPreviousDay ? slot.substring(1) : slot;
    const slotStart = parse(
      actualSlot,
      "HH:mm",
      isPreviousDay ? addMinutes(dateIso, -24 * 60) : dateIso
    );
    const slotEnd = addMinutes(slotStart, servicesDuration);
    return !locationReservations.some((reservation) => {
      const reservationStartUtc = parseISO(reservation.dateUtc);
      const reservationStartTimeUtc = formatInTimeZone(
        reservationStartUtc,
        "UTC",
        "HH:mm:ss"
      );
      const reservationStart = parse(
        reservationStartTimeUtc,
        "HH:mm:ss",
        isPreviousDay ? addMinutes(dateIso, -24 * 60) : dateIso
      );
      const reservationEnd = addMinutes(
        reservationStart,
        reservation.servicesDuration
      );
      const hasOverlap = isWithinInterval(reservationStart, {
        start: slotStart,
        end: slotEnd
      }) || isWithinInterval(reservationEnd, {
        start: slotStart,
        end: slotEnd
      }) || isWithinInterval(slotStart, {
        start: reservationStart,
        end: reservationEnd
      });
      if (hasOverlap) {
        return true;
      }
      const timeBetweenSlotEndAndReservationStart = differenceInMinutes(
        reservationStart,
        slotEnd
      );
      if (timeBetweenSlotEndAndReservationStart < PAUSE_BETWEEN_SLOTS_MINUTES && timeBetweenSlotEndAndReservationStart > 0) {
        return true;
      }
      const timeBetweenReservationEndAndSlotStart = differenceInMinutes(
        slotStart,
        reservationEnd
      );
      if (timeBetweenReservationEndAndSlotStart < PAUSE_BETWEEN_SLOTS_MINUTES && timeBetweenReservationEndAndSlotStart > 0) {
        return true;
      }
      return false;
    });
  });
  const additionalSlots = [];
  [...locationReservations].sort((a, b) => {
    const aStart = parseISO(a.dateUtc);
    const bStart = parseISO(b.dateUtc);
    return aStart.getTime() - bStart.getTime();
  });
  const allSlots = [...filteredSlots, ...additionalSlots].sort();
  const finalSlots = [];
  if (allSlots.length > 0) {
    const sortedSlots = [...allSlots].sort((a, b) => {
      const aTime = a.startsWith("-") ? a.substring(1) : a;
      const bTime = b.startsWith("-") ? b.substring(1) : b;
      if (!a.startsWith("-") && !b.startsWith("-")) {
        return aTime.localeCompare(bTime);
      }
      if (a.startsWith("-") && b.startsWith("-")) {
        return aTime.localeCompare(bTime);
      }
      if (a.startsWith("-") && !b.startsWith("-")) return -1;
      if (!a.startsWith("-") && b.startsWith("-")) return 1;
      return 0;
    });
    finalSlots.push(sortedSlots[0]);
    for (let i = 1; i < sortedSlots.length; i++) {
      const currentSlot = sortedSlots[i];
      const lastAddedSlot = finalSlots[finalSlots.length - 1];
      const currentSlotTimeStr = currentSlot.startsWith("-") ? currentSlot.substring(1) : currentSlot;
      const lastAddedSlotTimeStr = lastAddedSlot.startsWith("-") ? lastAddedSlot.substring(1) : lastAddedSlot;
      const currentSlotDate = currentSlot.startsWith("-") ? addMinutes(dateIso, -24 * 60) : dateIso;
      const lastAddedSlotDate = lastAddedSlot.startsWith("-") ? addMinutes(dateIso, -24 * 60) : dateIso;
      const currentSlotTime = parse(
        currentSlotTimeStr,
        "HH:mm",
        currentSlotDate
      );
      const lastAddedSlotTime = parse(
        lastAddedSlotTimeStr,
        "HH:mm",
        lastAddedSlotDate
      );
      const diff = differenceInMinutes(currentSlotTime, lastAddedSlotTime);
      if (diff >= MIN_SLOT_DIFFERENCE_MINUTES) {
        finalSlots.push(currentSlot);
      }
    }
  }
  return finalSlots;
};
const getTimeSlotsForTable = (locationReservations, date, timeFromUtc, timeToUtc, pauses, intervalMinutes = 30) => {
  const dateIso = parseISO(date);
  const dateIsoUTC = parseISO("".concat(date, "T00:00:00Z"));
  const allSlots = [];
  const slotDuration = {};
  let startTime = parse(timeFromUtc, "HH:mm:ss", dateIso);
  const endTime = parse(timeToUtc, "HH:mm:ss", dateIso);
  if (startTime > endTime) {
    startTime = addMinutes(startTime, -24 * 60);
  }
  if (pauses == null ? void 0 : pauses.length) {
    pauses.forEach((pause) => {
      const pauseStartTime = parse(pause.timeFromUtc, "HH:mm:ss", dateIso);
      const pauseEndTime = parse(pause.timeToUtc, "HH:mm:ss", dateIso);
      let currentPauseTime = pauseStartTime;
      while (isWithinInterval(currentPauseTime, {
        start: pauseStartTime,
        end: pauseEndTime
      }) && differenceInMinutes(currentPauseTime, pauseEndTime) !== 0) {
        const isCrossMidnight = parse(timeFromUtc, "HH:mm:ss", dateIso) > parse(timeToUtc, "HH:mm:ss", dateIso);
        const isPreviousDay = isCrossMidnight && currentPauseTime.getDate() !== dateIso.getDate();
        const slotTime = format(currentPauseTime, "HH:mm");
        const prefixedSlot = isPreviousDay ? "-".concat(slotTime) : slotTime;
        if (isWithinInterval(currentPauseTime, { start: startTime, end: endTime })) {
          allSlots.push(prefixedSlot);
          const pauseDuration = differenceInMinutes(
            pauseEndTime,
            pauseStartTime
          );
          slotDuration[prefixedSlot] = pauseDuration;
        }
        currentPauseTime = addMinutes(currentPauseTime, intervalMinutes);
      }
    });
  }
  let currentTime = startTime;
  while (isWithinInterval(currentTime, { start: startTime, end: endTime })) {
    const isCrossMidnight = parse(timeFromUtc, "HH:mm:ss", dateIso) > parse(timeToUtc, "HH:mm:ss", dateIso);
    const isPreviousDay = isCrossMidnight && currentTime.getDate() !== dateIso.getDate();
    const slotTime = format(currentTime, "HH:mm");
    const prefixedSlot = isPreviousDay ? "-".concat(slotTime) : slotTime;
    if (!allSlots.includes(prefixedSlot)) {
      allSlots.push(prefixedSlot);
    }
    currentTime = addMinutes(currentTime, intervalMinutes);
  }
  if (locationReservations == null ? void 0 : locationReservations.length) {
    locationReservations.forEach((reservation) => {
      const reservationStartUtc = parseISO(reservation.dateUtc);
      const reservationStartTimeUtc = formatInTimeZone(
        reservationStartUtc,
        "UTC",
        "HH:mm:ss"
      );
      const isPreviousDay = reservationStartUtc.getUTCDate() !== dateIsoUTC.getUTCDate();
      const reservationStart = parse(
        reservationStartTimeUtc,
        "HH:mm:ss",
        isPreviousDay ? addMinutes(dateIso, -24 * 60) : dateIso
      );
      const slotTime = format(reservationStart, "HH:mm");
      const prefixedSlot = isPreviousDay ? "-".concat(slotTime) : slotTime;
      if (!allSlots.includes(prefixedSlot)) {
        allSlots.push(prefixedSlot);
      }
      slotDuration[prefixedSlot] = reservation.servicesDuration;
    });
  }
  const filteredSlots = allSlots.filter((slot) => {
    if (slotDuration[slot]) {
      return true;
    }
    const isPreviousDay = slot.startsWith("-");
    const actualSlot = isPreviousDay ? slot.substring(1) : slot;
    const slotTime = parse(
      actualSlot,
      "HH:mm",
      isPreviousDay ? addMinutes(dateIso, -24 * 60) : dateIso
    );
    for (const [existingSlot, duration] of Object.entries(slotDuration)) {
      const existingIsPreviousDay = existingSlot.startsWith("-");
      const existingActualSlot = existingIsPreviousDay ? existingSlot.substring(1) : existingSlot;
      const existingSlotTime = parse(
        existingActualSlot,
        "HH:mm",
        existingIsPreviousDay ? addMinutes(dateIso, -24 * 60) : dateIso
      );
      const existingSlotEnd = addMinutes(existingSlotTime, duration);
      if (slotTime > existingSlotTime && slotTime < existingSlotEnd) {
        return false;
      }
    }
    return true;
  });
  const sortedSlots = filteredSlots.sort((a, b) => {
    const aTime = a.startsWith("-") ? a.substring(1) : a;
    const bTime = b.startsWith("-") ? b.substring(1) : b;
    if (!a.startsWith("-") && !b.startsWith("-")) {
      return aTime.localeCompare(bTime);
    }
    if (a.startsWith("-") && b.startsWith("-")) {
      return aTime.localeCompare(bTime);
    }
    if (a.startsWith("-") && !b.startsWith("-")) return -1;
    if (!a.startsWith("-") && b.startsWith("-")) return 1;
    return 0;
  });
  return sortedSlots.map((slot) => {
    const isPreviousDay = slot.startsWith("-");
    const actualSlot = isPreviousDay ? slot.substring(1) : slot;
    const slotTime = parse(
      actualSlot,
      "HH:mm",
      isPreviousDay ? addMinutes(dateIso, -24 * 60) : dateIso
    );
    const isPauseSlot = pauses == null ? void 0 : pauses.some((pause) => {
      const pauseStartTime = parse(pause.timeFromUtc, "HH:mm:ss", dateIso);
      const pauseEndTime = parse(pause.timeToUtc, "HH:mm:ss", dateIso);
      let adjustedPauseStart = pauseStartTime;
      let adjustedPauseEnd = pauseEndTime;
      if (isPreviousDay && pauseStartTime > pauseEndTime) {
        adjustedPauseStart = addMinutes(pauseStartTime, -24 * 60);
      }
      return isWithinInterval(slotTime, {
        start: adjustedPauseStart,
        end: adjustedPauseEnd
      }) && differenceInMinutes(slotTime, adjustedPauseEnd) !== 0;
    });
    return {
      time: slot,
      isPause: !!isPauseSlot
    };
  });
};
function ReservationItem({ reservation, heightStyle }) {
  var _a2;
  const { t: t2 } = useTranslation();
  const { data: workersResult, isLoading: workersLoading } = useGetFeWorkersQuery({ locationSlug: activeLocation });
  const { push } = useIonRouter();
  const worker = reactExports.useMemo(
    () => {
      var _a3;
      return (_a3 = workersResult == null ? void 0 : workersResult.data) == null ? void 0 : _a3.find(
        (worker2) => worker2.id === reservation.locationWorkerId
      );
    },
    [workersResult, reservation.locationWorkerId]
  );
  reactExports.useMemo(() => {
    switch (reservation.status) {
      case AppointmentStatus.DRAFT:
        return "secondary";
      case AppointmentStatus.PENDING:
        return "warning";
      case AppointmentStatus.CONFIRMED:
        return "success";
      case AppointmentStatus.CANCELLED:
        return "danger";
      case AppointmentStatus.NO_SHOW:
        return "danger";
      default:
        return "primary";
    }
  }, [reservation]);
  const handleReservationClick = () => {
    push("".concat(urlPrefix, "/r/").concat(reservation.hash));
  };
  const classPromo = reservation.discount ? "border-x-8 border-r-yellow-600" : "";
  reservation.discount ? "rose-800" : "white";
  if (workersLoading || !worker) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {});
  }
  const getStatusInfo = () => {
    switch (reservation.status) {
      case AppointmentStatus.DRAFT:
        return {
          text: t2("Nacrt"),
          color: "text-amber-500",
          bg: "bg-amber-50",
          borderColor: "border-amber-500"
        };
      case AppointmentStatus.PENDING:
        return {
          text: t2("Na 훾ekanju"),
          color: "text-yellow-500",
          bg: "bg-yellow-50",
          borderColor: "border-yellow-500"
        };
      case AppointmentStatus.CONFIRMED:
        return {
          text: "",
          color: "text-green-500",
          bg: "bg-green-50",
          borderColor: "border-green-500"
        };
      case AppointmentStatus.CANCELLED:
        return {
          text: t2("Otkazan"),
          color: "text-red-500",
          bg: "bg-red-50",
          borderColor: "border-red-600"
        };
      case AppointmentStatus.NO_SHOW:
        return {
          text: t2("Nije se pojavio"),
          color: "text-red-500",
          bg: "bg-red-50",
          borderColor: "border-red-600"
        };
      default:
        return {
          text: t2("Nepoznat"),
          color: "text-gray-500",
          bg: "bg-gray-100",
          borderColor: "border-gray-500"
        };
    }
  };
  const statusInfo = getStatusInfo();
  const discountPercentage = Math.round(
    reservation.discount / (reservation.servicesCost + reservation.discount) * 100
  );
  const itemPadding = reservation.servicesDuration >= 45 ? "py-8" : "py-0";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "border-l-4 py-3 px-2 cursor-pointer transition-all duration-200 hover:shadow-md bg-gray-900 ".concat(statusInfo.borderColor, " ").concat(classPromo, " w-full"),
      onClick: handleReservationClick,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between ".concat(itemPadding), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center space-x-2 mb-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold text-white", children: ((_a2 = reservation.client) == null ? void 0 : _a2.fullName) || t2("Nepoznati klijent") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3 text-sm", children: [
          statusInfo.text && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium ".concat(statusInfo.color), children: statusInfo.text }),
          reservation.servicesDuration && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-300", children: [
            reservation.servicesDuration,
            "min"
          ] }),
          reservation.servicesCost && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "span",
            {
              className: "font-semibold ".concat(reservation.discount ? "text-white" : "text-white"),
              children: [
                reservation.servicesCost,
                " RSD"
              ]
            }
          ),
          reservation.discount && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: cashOutline, className: "text-gray-400 text-xs" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-gray-400 font-medium", children: [
              discountPercentage,
              "%"
            ] })
          ] })
        ] })
      ] }) })
    }
  );
}
const ReservationItem$1 = reactExports.memo(ReservationItem);
function TableOfReservationList({
  selectedWorker,
  reservationByDate,
  timeSlots,
  selectedDateIndex
}) {
  var _a2;
  const { t: t2 } = useTranslation();
  const { push } = useIonRouter();
  const [currentTime, setCurrentTime] = reactExports.useState(/* @__PURE__ */ new Date());
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      setCurrentTime(/* @__PURE__ */ new Date());
    }, 60 * 1e3);
    return () => clearInterval(interval);
  }, []);
  const selectedDate = (_a2 = timeSlots == null ? void 0 : timeSlots[selectedDateIndex]) == null ? void 0 : _a2.date;
  const selectedDateFormatted = selectedDate ? format(selectedDate, "yyyy-MM-dd") : void 0;
  const currentTimeUtc = formatInTimeZone(currentTime, "UTC", "HH:mm");
  const handleSlotClick = (timeSlotInfo) => {
    if (timeSlotInfo.isPause) return;
    const reservationUrl = getReservationUrlWithSlot(
      selectedWorker.id,
      timeSlotInfo.time,
      selectedDateFormatted || ""
    );
    push(reservationUrl);
  };
  const selectedWorkerReservationsBySlot = reactExports.useMemo(() => {
    if (!selectedDateFormatted || !(reservationByDate == null ? void 0 : reservationByDate[selectedDateFormatted])) {
      return void 0;
    }
    return reservationByDate[selectedDateFormatted].reduce(
      (acc, reservation) => {
        const parsedDate = parseISO(reservation.dateUtc);
        const slotStartUtc = formatInTimeZone(parsedDate, "UTC", "HH:mm");
        acc[slotStartUtc] = reservation;
        return acc;
      },
      {}
    );
  }, [reservationByDate, selectedDateFormatted, selectedWorker.id]);
  const getStyleFromReservation = (timeSlot, addHeight = 0) => {
    var _a3, _b2;
    const actualTime = timeSlot.startsWith("-") ? timeSlot.substring(1) : timeSlot;
    const height = (_b2 = (_a3 = selectedWorkerReservationsBySlot == null ? void 0 : selectedWorkerReservationsBySlot[actualTime]) == null ? void 0 : _a3.servicesDuration) != null ? _b2 : 30;
    return {
      height: "".concat((height > 30 ? height : 30) + addHeight, "px")
    };
  };
  const selectedDateSlots = reactExports.useMemo(() => {
    var _a3;
    if (!timeSlots || selectedDateIndex === void 0) {
      return void 0;
    }
    return (_a3 = timeSlots == null ? void 0 : timeSlots[selectedDateIndex]) == null ? void 0 : _a3.slots;
  }, [timeSlots, selectedDateIndex]);
  if (!selectedDateSlots || selectedDateSlots.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col items-center justify-center py-12 px-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-6xl mb-4", children: "윋" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-semibold text-gray-300 mb-2", children: t2("Nema termina za ovaj dan") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-400 text-sm", children: t2("Nema zakazanih termina za odabrani dan") })
    ] }) });
  }
  const isToday = selectedDateFormatted === formatInTimeZone(currentTime, getAppTimezone(), "yyyy-MM-dd");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-black min-h-screen", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full px-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-900 overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "divide-y divide-gray-800 relative", children: selectedDateSlots.map((timeSlotInfo, index) => {
    const isPreviousDay = timeSlotInfo.time.startsWith("-");
    const actualTime = isPreviousDay ? timeSlotInfo.time.substring(1) : timeSlotInfo.time;
    const displayTime = fromUtcHM(actualTime);
    const reservation = selectedWorkerReservationsBySlot == null ? void 0 : selectedWorkerReservationsBySlot[actualTime];
    const [hours, minutes] = actualTime.split(":").map(Number);
    const slotStartMinutes = hours * 60 + minutes;
    const [currentHours, currentMins] = currentTimeUtc.split(":").map(Number);
    const currentMinutesFromMidnight = currentHours * 60 + currentMins;
    const nextSlot = selectedDateSlots[index + 1];
    const nextSlotTime = nextSlot == null ? void 0 : nextSlot.time.replace("-", "");
    let slotDuration;
    if (reservation) {
      slotDuration = reservation.servicesDuration;
    } else if (timeSlotInfo.isPause && nextSlotTime) {
      const [nextHours, nextMinutes] = nextSlotTime.split(":").map(Number);
      const nextSlotMinutes = nextHours * 60 + nextMinutes;
      slotDuration = nextSlotMinutes - slotStartMinutes;
    } else {
      slotDuration = 0;
    }
    const slotEndMinutes = slotStartMinutes + slotDuration;
    const isWithinSlot = isToday && currentMinutesFromMidnight >= slotStartMinutes && currentMinutesFromMidnight < slotEndMinutes;
    const minutesIntoSlot = currentMinutesFromMidnight - slotStartMinutes;
    const slotProgressPercent = slotDuration > 0 ? minutesIntoSlot / slotDuration * 100 : 100;
    const isAfterSlot = isToday && currentMinutesFromMidnight >= slotEndMinutes && (!nextSlotTime || currentTimeUtc < nextSlotTime);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "py-4 transition-colors duration-200 relative ".concat(timeSlotInfo.isPause ? "bg-gray-700 border-l-4 border-gray-500" : reservation ? "hover:bg-gray-800" : "hover:bg-gray-800 cursor-pointer"),
          onClick: () => !timeSlotInfo.isPause && !reservation && handleSlotClick(timeSlotInfo),
          children: [
            isWithinSlot && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                id: "current-time-indicator",
                className: "absolute left-0 right-0 flex items-center z-10",
                style: { top: "".concat(slotProgressPercent, "%") },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 bg-red-500 rounded-full ml-2" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 h-0.5 bg-red-500" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-xs font-medium mr-2", children: fromUtcHM(currentTimeUtc) })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between px-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-4 w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "w-16 text-center ".concat(timeSlotInfo.isPause ? "text-white" : "text-white"),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold", children: displayTime })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 w-full", children: timeSlotInfo.isPause ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 bg-white rounded-full" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-white font-medium", children: t2("Pauza") })
              ] }) : reservation ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                ReservationItem$1,
                {
                  reservation,
                  heightStyle: getStyleFromReservation(actualTime)
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-300 text-sm", children: t2("Slobodan termin") }) })
            ] }) })
          ]
        }
      ),
      isAfterSlot && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-full h-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          id: "current-time-indicator",
          className: "absolute left-0 right-0 flex items-center z-10",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 bg-red-500 rounded-full ml-2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 h-0.5 bg-red-500" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-xs font-medium mr-2", children: fromUtcHM(currentTimeUtc) })
          ]
        }
      ) })
    ] }, timeSlotInfo.time);
  }) }) }) }) });
}
const TableOfReservationList$1 = reactExports.memo(TableOfReservationList);
const getTodayInAppTimezone = () => {
  return formatInTimeZone(/* @__PURE__ */ new Date(), getAppTimezone(), "yyyy-MM-dd");
};
function TableOfReservations({ selectedWorker }) {
  var _a2, _b2;
  const { t: t2 } = useTranslation();
  const [selectedDateIndex, setSelectedDateIndex] = React.useState(0);
  const [showTimezoneWarning, setShowTimezoneWarning] = React.useState(false);
  const contentRefFunctions = useContentRefFunctions();
  const isCompatible = true;
  React.useEffect(() => {
  }, [isCompatible]);
  const {
    data: workersWorkingShiftsByDaysResult,
    isFetching: isWorkersWorkingShiftsFetching
  } = useGetFeWorkerWorkingShiftsByDaysQuery({
    locationSlug: activeLocation,
    workerId: selectedWorker.id
  });
  const swiperRef = reactExports.useRef(null);
  const { data: locationReservations, isLoading: isReservationsLoading } = useGetFeLocationReservationsQuery({
    locationSlug: activeLocation,
    locationWorkerId: selectedWorker.id,
    withClient: 1
  });
  const reservationByDate = reactExports.useMemo(
    () => (
      // transform reservations to object with date as key
      locationReservations == null ? void 0 : locationReservations.data.reduce((acc, reservation) => {
        const date = getUtcDateFormattedInTz(reservation.dateUtc);
        if (!acc[date]) {
          acc[date] = [];
        }
        acc[date].push(reservation);
        return acc;
      }, {})
    ),
    [locationReservations]
  );
  const timeSlots = reactExports.useMemo(() => {
    if (!(workersWorkingShiftsByDaysResult == null ? void 0 : workersWorkingShiftsByDaysResult.data)) {
      return void 0;
    }
    const slotsByDay = [];
    workersWorkingShiftsByDaysResult.data.forEach((shift) => {
      const { date: realDate, dateFormatted: realDateFormatted } = parseUtcDate(
        shift.dateUtc,
        getAppTimezone()
      );
      const reservationsForDate = reservationByDate == null ? void 0 : reservationByDate[realDateFormatted];
      const slots = getTimeSlotsForTable(
        reservationsForDate,
        realDateFormatted,
        shift.timeFromUtc,
        shift.timeToUtc,
        shift.pausesUtc
      );
      slotsByDay.push({
        dateFormatted: realDateFormatted,
        date: realDate,
        slots,
        workerId: selectedWorker.id
      });
    });
    return slotsByDay;
  }, [
    workersWorkingShiftsByDaysResult == null ? void 0 : workersWorkingShiftsByDaysResult.data,
    selectedWorker,
    reservationByDate
  ]);
  const selectedDate = (_a2 = timeSlots == null ? void 0 : timeSlots[selectedDateIndex]) == null ? void 0 : _a2.date;
  const selectedDateFormattedAdvanced = selectedDate ? t2("weeks.".concat(format(selectedDate, "EEEE"))) + ", " + format(selectedDate, "dd.MM") : void 0;
  const handleNextDate = () => {
    var _a3;
    if (selectedDateIndex === ((_a3 = timeSlots == null ? void 0 : timeSlots.length) != null ? _a3 : 0) - 1) {
      return;
    }
    setSelectedDateIndex((prev) => prev + 1);
  };
  const handlePrevDate = () => {
    if (selectedDateIndex === 0) {
      return;
    }
    setSelectedDateIndex((prev) => prev - 1);
  };
  reactExports.useEffect(() => {
    setSelectedDateIndex(0);
  }, [selectedWorker]);
  const scrollToCurrentTime = (retryCount = 0) => {
    const redLineElement = document.getElementById("current-time-indicator");
    if (redLineElement) {
      redLineElement.scrollIntoView({
        behavior: "smooth",
        block: "center"
      });
    } else if (retryCount < 5) {
      setTimeout(() => scrollToCurrentTime(retryCount + 1), 400);
    } else {
      console.log("Element not found after 5 retries");
    }
  };
  reactExports.useEffect(() => {
    if (timeSlots && timeSlots.length > 0) {
      const today = getTodayInAppTimezone();
      const todaySlide = timeSlots.find((slot) => slot.dateFormatted === today);
      if (todaySlide && selectedDateIndex === 0) {
        setTimeout(() => {
          scrollToCurrentTime();
        }, 200);
      }
    }
  }, [timeSlots]);
  const handleSlideChange = async (swiper) => {
    setSelectedDateIndex(swiper.activeIndex);
  };
  const handleSlideChangeTransitionStart = async (swiper) => {
    var _a3, _b3, _c2;
    const currentSlideIndex = swiper.activeIndex;
    const currentSlide = timeSlots == null ? void 0 : timeSlots[currentSlideIndex];
    const today = getTodayInAppTimezone();
    const isToday = (currentSlide == null ? void 0 : currentSlide.dateFormatted) === today;
    if (isToday) {
      setTimeout(() => {
        scrollToCurrentTime();
      }, 600);
    } else {
      const scrollElement = await ((_b3 = (_a3 = contentRefFunctions == null ? void 0 : contentRefFunctions.contentRef) == null ? void 0 : _a3.current) == null ? void 0 : _b3.getScrollElement());
      const scrollTop = (_c2 = scrollElement == null ? void 0 : scrollElement.scrollTop) != null ? _c2 : 0;
      if (scrollTop > 300) {
        contentRefFunctions == null ? void 0 : contentRefFunctions.scrollToTop(500);
      }
    }
  };
  if (isWorkersWorkingShiftsFetching || isReservationsLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {});
  }
  if (!selectedDateFormattedAdvanced) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: t2("Nema aktivnih termina") });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { color: "light", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          onClick: handlePrevDate,
          disabled: selectedDateIndex === 0,
          fill: "clear",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronBackOutline })
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-lg font-bold", children: selectedDateFormattedAdvanced }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          onClick: handleNextDate,
          disabled: selectedDateIndex === ((_b2 = timeSlots == null ? void 0 : timeSlots.length) != null ? _b2 : 0) - 1,
          fill: "clear",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronForwardOutline })
        }
      ) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwiperWrapper$1,
      {
        virtual: true,
        slidesPerView: 1,
        ref: swiperRef,
        onSlideChange: handleSlideChange,
        currentStep: selectedDateIndex,
        onSlideChangeTransitionStart: handleSlideChangeTransitionStart,
        children: timeSlots == null ? void 0 : timeSlots.map((timeSlot, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { virtualIndex: index, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableOfReservationList$1,
          {
            reservationByDate,
            selectedWorker,
            timeSlots,
            selectedDateIndex: index
          }
        ) }, timeSlot.dateFormatted))
      }
    )
  ] });
}
function OwnerAppointmentFooter() {
  const { t: t2 } = useTranslation();
  const { isScrolled } = useContentData() || {};
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonButton,
    {
      routerLink: "".concat(urlPrefix, "/zakazi-novo"),
      className: "border border-gray-500 mb-1",
      color: "dark",
      size: isScrolled ? "small" : "large",
      children: t2("Zaka탑ite nov termin")
    }
  );
}
function OwnerAppointmentPage() {
  const { t: t2 } = useTranslation();
  const [selectedWorker, setSelectedWorker] = reactExports.useState(
    null
  );
  const handleSelectWorker = (worker) => {
    setSelectedWorker(worker);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Termini") }),
      headerClasses: mainHeaderClasses,
      footer: /* @__PURE__ */ jsxRuntimeExports.jsx(OwnerAppointmentFooter, {}),
      additionalHeader: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectWorker,
        {
          onSelectWorker: handleSelectWorker,
          selectedWorker
        }
      ) }),
      children: selectedWorker && /* @__PURE__ */ jsxRuntimeExports.jsx(TableOfReservations, { selectedWorker })
    }
  );
}
const MainTabs = ({ match }) => {
  const { t: t2 } = useTranslation();
  const url = fixUrlPath(match.url);
  const tabBarClasses = isWebPlatform ? "justify-end py-1 mb-[1px] z-10 bg-transparent w-[40vw] right-0 absolute" : "";
  const mainRoles = [
    UserGroupCode.Admin,
    UserGroupCode.Owner,
    UserGroupCode.Worker
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTabs, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRouterOutlet, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "".concat(url, "/"), exact: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Redirect, { to: "".concat(url, "/salon") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        GuardedRoute$1,
        {
          path: "".concat(url, "/salon"),
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(OwnerHomePage, {}),
          fallbackRender: () => /* @__PURE__ */ jsxRuntimeExports.jsx(HomePage, {}),
          hasFallbackWithoutUser: true,
          exact: true,
          roles: mainRoles
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        GuardedRoute$1,
        {
          path: "".concat(url, "/termini"),
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(OwnerAppointmentPage, {}),
          fallbackRender: () => /* @__PURE__ */ jsxRuntimeExports.jsx(AppointmentPage, {}),
          hasFallbackWithoutUser: true,
          exact: true,
          roles: mainRoles
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        GuardedRoute$1,
        {
          path: "".concat(url, "/salon/pripremi"),
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(PrepareWorkingDaysShiftsPage, {}),
          exact: true,
          roles: mainRoles
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        GuardedRoute$1,
        {
          path: "".concat(url, "/notifikacije"),
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationPage, {}),
          exact: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        GuardedRoute$1,
        {
          path: "".concat(url, "/profil"),
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(ProfilePage, {}),
          exact: true
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTabBar, { slot: tabPosition, className: tabBarClasses, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTabButton, { tab: "salon", href: "".concat(url, "/salon"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: cutOutline }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Salon") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTabButton, { tab: "termini", href: "".concat(url, "/termini"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: alarmOutline }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Termini") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTabButton, { tab: "notifikacije", href: "".concat(url, "/notifikacije"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: notificationsOutline }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Notifikacije") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTabButton, { tab: "profil", href: "".concat(url, "/profil"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: personOutline }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Profil") })
      ] })
    ] })
  ] }, activeLocation);
};
function SelectWorkerStep({
  workerId,
  setSelectedWorker,
  activeWorkersCount = 0
}) {
  const { t: t2 } = useTranslation();
  const { data: workersResult, isLoading: workersLoading } = useGetFeWorkersQuery({ locationSlug: activeLocation });
  const workers = (workersResult == null ? void 0 : workersResult.data) || [];
  const handleSelectWorker = (worker) => () => {
    setSelectedWorker(worker);
  };
  reactExports.useEffect(() => {
    if (workerId && workers.length) {
      const worker = workers.find((w) => w.id == workerId);
      setSelectedWorker(worker);
    }
  }, [workerId, workers]);
  if (workersLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "px-4 py-2", children: t2("Izaberite radnika") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { className: "w-full bg-inherit", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonItem,
        {
          button: true,
          onClick: handleSelectWorker(null),
          detail: false,
          disabled: activeWorkersCount === 1,
          className: "mb-2",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonAvatar, { slot: "start", className: "w-14 h-14 rounded-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-full bg-gray-700 flex items-center justify-center rounded-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonIcon,
              {
                icon: peopleOutline,
                className: "text-3xl text-gray-300"
              }
            ) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-semibold", children: t2("Prvi slobodan") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "end", icon: chevronForwardOutline })
          ]
        }
      ),
      workers.map((worker) => {
        var _a2;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonItem,
          {
            button: true,
            onClick: handleSelectWorker(worker),
            detail: false,
            className: "mb-2",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonAvatar, { slot: "start", className: "w-14 h-14 rounded-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                LazyLoadImgStandard$1,
                {
                  src: getPathBySize((_a2 = worker.avatar) == null ? void 0 : _a2.pathByResolution),
                  preloadImg: preloadCoverImg$1,
                  alt: worker.fullName,
                  className: "w-full h-full object-cover rounded-full"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-semibold", children: worker.fullName }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "end", icon: chevronForwardOutline })
            ]
          },
          worker.id
        );
      })
    ] })
  ] });
}
var InputType = /* @__PURE__ */ ((InputType2) => {
  InputType2[InputType2["checkbox"] = 0] = "checkbox";
  InputType2[InputType2["radio"] = 1] = "radio";
  InputType2[InputType2["select"] = 2] = "select";
  return InputType2;
})(InputType || {});
const maxQuantity = 4;
const maxServicesTime = 180;
function SelectService({
  groupsSelectedServices,
  onSelectedService,
  serviceGroup,
  hasMultiplePersons,
  allSelectedServicesDurationSum,
  selectedWorker
}) {
  const handleSelectService = (service) => () => {
    onSelectedService(serviceGroup, { ...service, quantity: 1 });
  };
  const addQuantity = (selectedService) => () => {
    var _a2;
    const quantity = (_a2 = selectedService.quantity) != null ? _a2 : 1;
    onSelectedService(serviceGroup, selectedService);
    onSelectedService(serviceGroup, {
      ...selectedService,
      quantity: quantity + 1
    });
  };
  const removeQuantity = (selectedService) => () => {
    var _a2;
    const quantity = (_a2 = selectedService.quantity) != null ? _a2 : 1;
    onSelectedService(serviceGroup, selectedService);
    if (quantity > 1) {
      onSelectedService(serviceGroup, {
        ...selectedService,
        quantity: quantity - 1
      });
    }
  };
  const selectedServices = reactExports.useMemo(() => {
    const selectedGroup = groupsSelectedServices.find(
      (group) => group.serviceGroup.id === serviceGroup.id
    );
    return (selectedGroup == null ? void 0 : selectedGroup.services) || [];
  }, [groupsSelectedServices, serviceGroup]);
  const [expandedDescriptions, setExpandedDescriptions] = reactExports.useState({});
  const toggleDescription = (serviceId) => (e) => {
    e.stopPropagation();
    setExpandedDescriptions((prev) => ({
      ...prev,
      [serviceId]: !prev[serviceId]
    }));
  };
  const renderService = (service) => {
    var _a2;
    const selectedService = selectedServices.find((s) => s.id === service.id);
    const isSelected = !!selectedService;
    const isDescriptionExpanded = expandedDescriptions[service.id];
    const hasLongDescription = service.description && service.description.length > 80;
    const displayDescription = !isDescriptionExpanded && service.description && service.description.length > 80 ? service.description.substring(0, 80) + "..." : service.description;
    let workerPrice;
    let workerDuration;
    if (selectedWorker && service.locationWorkers) {
      const workerData = service.locationWorkers.find(
        (worker) => worker.id === selectedWorker.id
      );
      if (workerData == null ? void 0 : workerData.pivot) {
        workerPrice = workerData.pivot.price !== void 0 && workerData.pivot.price !== null ? workerData.pivot.price : service.price;
        workerDuration = workerData.pivot.duration !== void 0 && workerData.pivot.duration !== null ? workerData.pivot.duration : service.duration;
      }
    }
    const effectivePrice = workerPrice != null ? workerPrice : service.price;
    const effectiveDuration = workerDuration != null ? workerDuration : service.duration;
    const hasWorkerSelected = selectedWorker !== null && selectedWorker !== void 0;
    hasWorkerSelected ? "".concat(formatPriceSimple(effectivePrice), " RSD") : service.minPrice && service.maxPrice && service.minPrice !== service.maxPrice ? "od ".concat(formatPriceSimple(service.minPrice), " do ").concat(formatPriceSimple(
      service.maxPrice
    ), " RSD") : "".concat(formatPriceSimple(effectivePrice), " RSD");
    hasWorkerSelected ? "".concat(effectiveDuration, " min") : service.minDuration && service.maxDuration && service.minDuration !== service.maxDuration ? "od ".concat(service.minDuration, " do ").concat(service.maxDuration, " min") : "".concat(effectiveDuration, " min");
    const isMaxedOut = (selectedService == null ? void 0 : selectedService.quantity) === maxQuantity || allSelectedServicesDurationSum >= maxServicesTime;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonCol,
      {
        size: "12",
        sizeMd: "6",
        sizeLg: "4",
        className: "ion-align-self-stretch",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonCard,
          {
            disabled: isMaxedOut && !isSelected,
            className: "ion-no-padding ion-no-margin cursor-pointer relative h-full flex flex-col ".concat(isSelected ? "border-2 border-green-500 shadow-lg service-selected" : "border border-gray-200 hover:shadow-md"),
            onClick: handleSelectService(service),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { className: "ion-no-padding ion-no-margin pb-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardTitle, { className: "text-md font-semibold line-clamp-2", children: service.title }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { className: "pt-0 ion-no-padding ion-no-margin pb-1 flex flex-col h-full", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ConditionalComponent,
                  {
                    condition: !!((_a2 = service.description) == null ? void 0 : _a2.length),
                    render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-1 text-xs text-gray-400 relative", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          className: "px-1 ".concat(isDescriptionExpanded ? "inline-block max-w-full" : "inline-block max-w-full overflow-hidden text-ellipsis whitespace-nowrap"),
                          children: service.description ? displayDescription : "혻"
                        }
                      ),
                      service.description && hasLongDescription && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          onClick: toggleDescription(service.id),
                          className: "absolute right-2 text-xs text-blue-400 hover:text-blue-300 underline bg-transparent ".concat(isDescriptionExpanded ? "-bottom-2.5" : "top-2.5"),
                          style: { background: "transparent" },
                          children: isDescriptionExpanded ? "manje" : "vi큄e"
                        }
                      )
                    ] })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-auto", children: [
                  service.minDuration && service.maxDuration && service.minDuration !== service.maxDuration && !hasWorkerSelected ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-gray-300", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-400", children: "od " }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: service.minDuration }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-400", children: " do " }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      service.maxDuration,
                      " min"
                    ] })
                  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-gray-300", children: [
                    effectiveDuration,
                    " min"
                  ] }),
                  hasWorkerSelected ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-bold px-2 py-1 text-green-500", children: [
                    formatPriceSimple(effectivePrice),
                    " RSD"
                  ] }) : service.minPrice && service.maxPrice && service.minPrice !== service.maxPrice ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm font-bold px-2 py-1 text-green-500", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-gray-400 font-normal", children: "od " }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: formatPriceSimple(service.minPrice) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-gray-400 font-normal", children: [
                      " ",
                      "do",
                      " "
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: formatPriceSimple(service.maxPrice) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-bold text-green-500", children: " RSD" })
                  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-bold px-2 py-1 text-green-500", children: [
                    formatPriceSimple(effectivePrice),
                    " RSD"
                  ] })
                ] }),
                selectedService && hasMultiplePersons && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: "flex items-center justify-between mt-2 pt-2 border-t",
                    onClick: (e) => e.stopPropagation(),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        IonButton,
                        {
                          size: "small",
                          fill: "clear",
                          color: "danger",
                          onClick: (e) => {
                            e.stopPropagation();
                            removeQuantity(selectedService)();
                          },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: removeOutline })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { className: "text-sm font-bold", children: selectedService.quantity }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        IonButton,
                        {
                          size: "small",
                          fill: "clear",
                          disabled: selectedService.quantity === maxQuantity || allSelectedServicesDurationSum >= maxServicesTime,
                          onClick: (e) => {
                            e.stopPropagation();
                            addQuantity(selectedService)();
                          },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline })
                        }
                      )
                    ]
                  }
                )
              ] })
            ]
          }
        )
      },
      service.id
    );
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { className: "p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonTitle,
      {
        className: "border-2 bg-green-900 rounded-md text-white py-2",
        children: serviceGroup.title
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonGrid, { className: "px-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { className: "ion-align-items-stretch", children: serviceGroup.services.map((service) => renderService(service)) }) })
  ] });
}
const createValidationSchema = (serviceGroups) => {
  const schemaFields = {};
  serviceGroups.forEach((group) => {
    if (group.inputType === InputType.checkbox) {
      schemaFields["serviceGroup_".concat(group.id)] = yup.array().of(yup.string()).min(
        group.minSelected || 0,
        "Select at least ".concat(group.minSelected, " options")
      ).max(
        group.maxSelected || Number.POSITIVE_INFINITY,
        "Select no more than ".concat(group.maxSelected, " options")
      ).when([], () => group.required ? yup.array().required() : yup.array());
    } else if (group.inputType === InputType.select) {
      schemaFields["serviceGroup_".concat(group.id)] = yup.string().when(
        [],
        () => group.required ? yup.string().nullable().required() : yup.string().nullable()
      );
    }
  });
  return yup.object().shape(schemaFields);
};
function SelectAppointmentStep({
  onBack,
  onNext,
  selectedWorker,
  serviceGroups,
  onSelectService,
  groupsSelectedServices,
  hasMultiplePersons,
  setHasMultiplePersons
}) {
  const { t: t2 } = useTranslation();
  const formSchema = createValidationSchema(serviceGroups);
  const form = useForm({
    resolver: o(formSchema)
  });
  const onSubmit = (data) => {
    handleNext();
  };
  const handleNext = () => {
    onNext();
  };
  groupsSelectedServices.length;
  const toggleMultiplePersons = () => {
    setHasMultiplePersons(!hasMultiplePersons);
  };
  const filteredServiceGroups = reactExports.useMemo(() => {
    if (!selectedWorker) {
      return serviceGroups;
    }
    return serviceGroups.map((group) => ({
      ...group,
      services: group.services.filter((service) => {
        return service.locationWorkers && service.locationWorkers.some(
          (worker) => worker.id === selectedWorker.id
        );
      })
    }));
  }, [serviceGroups, selectedWorker]);
  const allSelectedServicesDurationSum = reactExports.useMemo(() => {
    return groupsSelectedServices.reduce(
      (acc, group) => {
        var _a2, _b2;
        return acc + ((_b2 = (_a2 = group.services) == null ? void 0 : _a2.reduce(
          (acc2, service) => {
            var _a3;
            return acc2 + service.duration * ((_a3 = service.quantity) != null ? _a3 : 1);
          },
          0
        )) != null ? _b2 : 0);
      },
      0
    );
  }, [groupsSelectedServices]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-[80px]", children: [
    selectedWorker && /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: selectedWorker.fullName }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonToggle,
      {
        checked: hasMultiplePersons,
        onClick: toggleMultiplePersons,
        children: t2("Za vi큄e osoba")
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: form.handleSubmit(onSubmit), children: filteredServiceGroups.map((group, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectService,
      {
        groupsSelectedServices,
        onSelectedService: onSelectService,
        serviceGroup: group,
        hasMultiplePersons,
        allSelectedServicesDurationSum,
        selectedWorker
      },
      "".concat(group.id, " ").concat(index)
    )) })
  ] }) });
}
const serviceGroupApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getFeServiceGroups: builder.query({
      query: ({ locationSlug, workerId, withWorkers }) => ({
        url: "locations/services-groups",
        method: "GET",
        params: { locationSlug, workerId, withWorkers }
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [TagType$1.APP_LANG, TagType$1.SERVICES_GROUPS]
    })
  })
});
const { useGetFeServiceGroupsQuery } = serviceGroupApi;
const getCreateAppointmentFormFields = (t2) => [
  {
    keyName: "note",
    name: "note",
    data: {
      type: FieldType.Text,
      label: t2("Napomena")
    },
    gridSize: {
      size: "6"
    }
  },
  {
    keyName: "promoCode",
    name: "promoCode",
    data: {
      type: FieldType.Text,
      label: t2("Promo kod")
    },
    gridSize: {
      size: "6"
    }
  }
];
const schema$2 = yup.object().shape({
  note: yup.string().nullable().default(null),
  promoCode: yup.string().nullable().default(null)
});
function CreateReservationModal({
  onConfirm,
  onCancel,
  isOpen,
  worker,
  selectedServices,
  dateOnly,
  timeUtc,
  dateFormatted
}, ref) {
  var _a2, _b2;
  const { t: t2 } = useTranslation();
  const [createReservation, createReservationResponse] = useCreateFeReservationMutation();
  const { isOwnerOrWorker } = useUser();
  const initialModalBp = isOwnerOrWorker ? 0.4 : 0.5;
  const [promoCodeData, setPromoCodeData] = reactExports.useState(null);
  const [currentBreakpoint, setCurrentBreakpoint] = reactExports.useState(initialModalBp);
  const { push } = useIonRouter();
  const [presentToast] = useIonToast();
  const internalModalRef = reactExports.useRef(null);
  reactExports.useImperativeHandle(ref, () => internalModalRef.current, []);
  const modalRef = internalModalRef;
  const { data: clientResponse } = useGetFeClientDataQuery(void 0, {
    skip: !!isOwnerOrWorker
  });
  const clientData = clientResponse == null ? void 0 : clientResponse.data;
  const form = useFormWithSchema(schema$2, {
    defaultValues: {
      note: null,
      promoCode: null
    }
  });
  const formFields = getCreateAppointmentFormFields(t2);
  const promoCode = form.watch("promoCode");
  const {
    data: promoCodeResponse,
    isFetching: isPromoCodeFetching,
    refetch
  } = useGetFePromoCodeDataQuery(
    {
      locationSlug: activeLocation,
      code: promoCode != null ? promoCode : ""
    },
    {
      skip: !(promoCode == null ? void 0 : promoCode.length) || !(promoCode != null ? promoCode : "").endsWith("#")
    }
  );
  const duration = reactExports.useMemo(() => {
    return selectedServices == null ? void 0 : selectedServices.reduce(
      (acc, service) => {
        var _a3;
        return acc + service.duration * ((_a3 = service.quantity) != null ? _a3 : 1);
      },
      0
    );
  }, [selectedServices]);
  const cost = reactExports.useMemo(() => {
    return (selectedServices == null ? void 0 : selectedServices.reduce(
      (acc, service) => {
        var _a3;
        return acc + service.price * ((_a3 = service.quantity) != null ? _a3 : 1);
      },
      0
    )) || 0;
  }, [selectedServices]);
  const onSubmit = (data) => {
    handleConfirmReservation();
  };
  const handleConfirmReservation = () => {
    var _a3;
    const dateUtcString = formatInTimeZone(dateOnly, "UTC", "yyyy-MM-dd") + "".concat(timeUtc, ":00");
    createReservation({
      locationSlug: activeLocation,
      locationWorkerId: worker.id,
      dateUtc: dateUtcString,
      services: selectedServices.map((service) => {
        var _a4;
        return {
          id: service.id,
          quantity: (_a4 = service.quantity) != null ? _a4 : 1
        };
      }),
      clientId: clientData == null ? void 0 : clientData.id,
      promoCode: promoCodeData == null ? void 0 : promoCodeData.name,
      notice: (_a3 = form.getValues("note")) != null ? _a3 : void 0
    });
  };
  const handleBreakpointChange = (event) => {
    setCurrentBreakpoint(event.detail.breakpoint);
  };
  const hasDiscount = (_a2 = promoCodeData == null ? void 0 : promoCodeData.discountValue) != null ? _a2 : 0 > 0;
  const isDiscountInPercent = (_b2 = promoCodeData == null ? void 0 : promoCodeData.inPercent) != null ? _b2 : false;
  const getPriceWithDiscount = () => {
    var _a3, _b3;
    if (hasDiscount) {
      const discountPrice = isDiscountInPercent ? cost - cost * ((_a3 = promoCodeData == null ? void 0 : promoCodeData.discountValue) != null ? _a3 : 0) / 100 : cost - ((_b3 = promoCodeData == null ? void 0 : promoCodeData.discountValue) != null ? _b3 : 0);
      return Math.round(discountPrice / 50) * 50;
    } else {
      return cost;
    }
  };
  const isBigScreen = currentBreakpoint >= 0.8;
  const timeLocal = fromUtcHM(timeUtc);
  const footerBottomClass = reactExports.useMemo(() => {
    if (currentBreakpoint === 0.4) {
      return "bottom-[60vh]";
    } else if (currentBreakpoint === 0.5) {
      return "bottom-[50vh]";
    } else if (currentBreakpoint === 0.8) {
      return "bottom-[20vh]";
    }
    return "bottom-0";
  }, [currentBreakpoint]);
  const handleCloseModal = reactExports.useCallback(() => {
    var _a3;
    (_a3 = modalRef == null ? void 0 : modalRef.current) == null ? void 0 : _a3.dismiss();
  }, [modalRef]);
  const handleInputFocus = () => {
    var _a3;
    !isWebPlatform && ((_a3 = modalRef == null ? void 0 : modalRef.current) == null ? void 0 : _a3.setCurrentBreakpoint(0.8));
  };
  reactExports.useEffect(() => {
    var _a3;
    if (createReservationResponse.isSuccess && ((_a3 = createReservationResponse.data) == null ? void 0 : _a3.success)) {
      const data = createReservationResponse.data.data;
      onConfirm == null ? void 0 : onConfirm();
      onCancel();
      push("".concat(urlPrefix, "/r/").concat(data.hash, "?backToHome=1"));
    } else if (createReservationResponse.isError && createReservationResponse.error && "data" in createReservationResponse.error) {
      const errorData = createReservationResponse.error.data;
      presentToast({
        message: errorData.message,
        duration: 3e3,
        color: "danger"
      });
    }
  }, [createReservationResponse]);
  reactExports.useEffect(() => {
    if ((promoCodeResponse == null ? void 0 : promoCodeResponse.data) === null) {
      form.setValue("promoCode", "");
      presentToast({
        message: t2("Promo kod nije validan"),
        duration: 3e3,
        color: "danger"
      });
    } else if (promoCodeResponse == null ? void 0 : promoCodeResponse.data) {
      setPromoCodeData(promoCodeResponse.data);
    }
  }, [promoCodeResponse]);
  reactExports.useEffect(() => {
    if (promoCode == null ? void 0 : promoCode.endsWith("#")) {
      if ((promoCodeResponse == null ? void 0 : promoCodeResponse.data) && promoCode === promoCodeResponse.data.name) {
        setPromoCodeData(promoCodeResponse == null ? void 0 : promoCodeResponse.data);
      } else {
        refetch();
      }
    } else {
      setPromoCodeData(null);
    }
  }, [promoCode]);
  const breakpoints = isWebPlatform ? void 0 : [0, initialModalBp, 0.8, 1];
  const initialBreakpoint = isWebPlatform ? void 0 : initialModalBp;
  const backdropBreakpoint = isWebPlatform ? void 0 : initialModalBp;
  const showBackdrop = isWebPlatform ? void 0 : false;
  const modalClassName = isWebPlatform ? void 0 : "hd-extended";
  const footerClassName = isWebPlatform ? void 0 : "fixed left-0 w-full z-[100] bg-neutral-900 ".concat(footerBottomClass);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonModalExtended$1,
    {
      name: "create-reservation-modal",
      isOpen,
      onClose: onCancel,
      breakpoints,
      showBackdrop,
      onIonBreakpointDidChange: handleBreakpointChange,
      backdropBreakpoint,
      initialBreakpoint,
      className: modalClassName,
      ref: modalRef,
      children: [
        createReservationResponse.isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(IonLoading, { isOpen: true, message: t2("Kreiranje rezervacije...") }),
        isPromoCodeFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(IonLoading, { isOpen: true, message: t2("Provera promo koda...") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { className: "px-1", color: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { className: "border", color: "dark", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: worker.fullName }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
            dateFormatted,
            " ",
            timeLocal
          ] }),
          !isOwnerOrWorker && /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onFocus: handleInputFocus, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields: formFields, form }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonGrid, { className: "ion-no-padding mt-2 !px-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonCol,
              {
                size: isBigScreen ? "12" : "6",
                className: "flex items-center justify-between",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ConditionalComponent,
                    {
                      condition: isBigScreen,
                      render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                        t2("Trajanje usluge"),
                        ":"
                      ] })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(IonBadge, { className: "p-2", color: "default", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: timeOutline, className: "mr-1" }),
                    duration,
                    " min"
                  ] })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonCol,
              {
                size: isBigScreen ? "12" : "6",
                className: "flex items-center " + (isBigScreen ? "justify-between" : "justify-end"),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ConditionalComponent,
                    {
                      condition: isBigScreen,
                      render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                        t2("Cena"),
                        ":"
                      ] })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(IonBadge, { color: "success", className: "p-2 text-white", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: cashOutline, className: "mr-1" }),
                    hasDiscount ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("s", { className: "px-1 text-rose-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: cost }) }),
                      getPriceWithDiscount()
                    ] }) : cost,
                    " ",
                    "RSD"
                  ] })
                ]
              }
            )
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { className: footerClassName, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            IonButton,
            {
              slot: "start",
              color: "medium",
              onClick: handleCloseModal,
              className: "ml-2",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline }),
                t2("Zatvori")
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            IonButton,
            {
              slot: "end",
              color: "primary",
              onClick: form.handleSubmit(onSubmit),
              className: "mr-2",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarClearOutline, className: "mr-1" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { slot: "end", children: t2("Kreiraj rezervaciju") })
              ]
            }
          )
        ] }) })
      ]
    }
  );
}
const CreateReservationModal$1 = reactExports.forwardRef(
  CreateReservationModal
);
function TimeSlotButton({
  timeUtc,
  slotDate,
  slotDateFormatted,
  workerId,
  isSelected,
  onClick
}) {
  const isPreviousDay = timeUtc.startsWith("-");
  const actualTimeUtc = isPreviousDay ? timeUtc.substring(1) : timeUtc;
  const timeLocal = fromUtcHM(actualTimeUtc);
  ({
    date: isPreviousDay ? addDays(slotDate, -1) : slotDate
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonButton,
    {
      color: isSelected ? "success" : "dark",
      onClick,
      size: "large",
      mode: "ios",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: timeLocal })
    }
  );
}
const TimeSlotButton$1 = reactExports.memo(TimeSlotButton);
function TimeSlotsSwiper({
  slots,
  slotDate,
  slotDateFormatted,
  workerId,
  selectedSlot,
  onSlotSelect,
  shouldScrollToSlot = false,
  targetSlotTime,
  autoplay = false
}, ref) {
  const swiperRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    var _a2;
    if (shouldScrollToSlot && targetSlotTime && (swiperRef == null ? void 0 : swiperRef.current)) {
      const targetIndex = slots.findIndex((slot) => {
        const actualTime = slot.startsWith("-") ? slot.substring(1) : slot;
        return actualTime === targetSlotTime;
      });
      if (targetIndex !== -1) {
        (_a2 = swiperRef.current.swiper) == null ? void 0 : _a2.slideTo(targetIndex, 300);
      }
    }
  }, [shouldScrollToSlot, targetSlotTime, slots, swiperRef, slotDateFormatted]);
  const checkIsSameSlot = (slot) => {
    if (!selectedSlot) return false;
    return selectedSlot.dateFormatted === slot.dateFormatted && selectedSlot.timeUtc === slot.timeUtc && selectedSlot.workerId === slot.workerId;
  };
  reactExports.useImperativeHandle(ref, () => {
    var _a2;
    return {
      swiper: (_a2 = swiperRef.current) == null ? void 0 : _a2.swiper
    };
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SwiperWrapper$1,
    {
      ref: swiperRef,
      spaceBetween: 10,
      slidesPerView: "auto",
      freeMode: true,
      autoplay: autoplay ? {
        delay: 2e3,
        disableOnInteraction: true,
        pauseOnMouseEnter: true
      } : void 0,
      children: slots.map((timeUtc) => {
        const isPreviousDay = timeUtc.startsWith("-");
        const actualTimeUtc = isPreviousDay ? timeUtc.substring(1) : timeUtc;
        const timeLocal = fromUtcHM(actualTimeUtc);
        const selectSlot = {
          date: isPreviousDay ? addDays(slotDate, -1) : slotDate,
          dateFormatted: slotDateFormatted,
          timeUtc: actualTimeUtc,
          timeLocal,
          workerId,
          isPreviousDay
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { style: { width: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TimeSlotButton$1,
          {
            timeUtc,
            slotDate,
            slotDateFormatted,
            workerId,
            isSelected: checkIsSameSlot(selectSlot),
            onClick: () => onSlotSelect(selectSlot)
          }
        ) }, timeUtc);
      })
    }
  );
}
const TimeSlotsSwiper$1 = reactExports.memo(reactExports.forwardRef(TimeSlotsSwiper));
function DaySlotsCard({
  dateFormatted,
  date,
  slots,
  workerId,
  workers,
  selectedSlot,
  onSlotSelect,
  isFirstDay = false,
  shouldScrollToSlot = false,
  targetSlotTime,
  showWorkerName = false
}) {
  const { t: t2 } = useTranslation();
  const timeSlotsSwiperRef = reactExports.useRef(null);
  const getWorkerFullName = (workerId2, workers2) => {
    var _a2;
    return ((_a2 = workers2.find((worker) => worker.id === workerId2)) == null ? void 0 : _a2.fullName) + ": ";
  };
  const [isBeginning, setIsBeginning] = reactExports.useState(true);
  const [isEnd, setIsEnd] = reactExports.useState(false);
  const [showControls, setShowControls] = reactExports.useState(true);
  reactExports.useEffect(() => {
    var _a2;
    const swiper = (_a2 = timeSlotsSwiperRef.current) == null ? void 0 : _a2.swiper;
    if (swiper) {
      const updateControls = () => {
        var _a3, _b2;
        const isBeginningValue = (_a3 = swiper.isBeginning) != null ? _a3 : false;
        const isEndValue = (_b2 = swiper.isEnd) != null ? _b2 : false;
        setIsBeginning(isBeginningValue);
        setIsEnd(isEndValue);
      };
      swiper.on("slideChange", updateControls);
      return () => {
        swiper.off("slideChange");
      };
    }
  }, [slots.length]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { className: "ion-no-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          slot: "start",
          fill: "clear",
          color: "medium",
          size: "small",
          disabled: isBeginning,
          onClick: () => {
            var _a2, _b2;
            return (_b2 = (_a2 = timeSlotsSwiperRef.current) == null ? void 0 : _a2.swiper) == null ? void 0 : _b2.slidePrev();
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronBackOutline })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardTitle, { className: "text-xl", children: [
        showWorkerName && getWorkerFullName(workerId, workers),
        dateFormatted
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          disabled: isEnd,
          onClick: () => {
            var _a2, _b2;
            return (_b2 = (_a2 = timeSlotsSwiperRef.current) == null ? void 0 : _a2.swiper) == null ? void 0 : _b2.slideNext();
          },
          fill: "clear",
          color: "medium",
          size: "small",
          slot: "end",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronForwardOutline })
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { children: [
      slots.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { children: t2("Nema slobodnih termina") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TimeSlotsSwiper$1,
        {
          ref: timeSlotsSwiperRef,
          slots,
          slotDate: date,
          slotDateFormatted: dateFormatted,
          workerId,
          selectedSlot,
          onSlotSelect,
          shouldScrollToSlot,
          targetSlotTime,
          autoplay: false
        }
      )
    ] }),
    showControls && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full flex justify-between" })
  ] });
}
const DaySlotsCard$1 = reactExports.memo(DaySlotsCard);
function SelectDateTimeStep({
  locationWorker,
  selectedGroupServices,
  onBack,
  selectedSlot,
  selectedDate,
  onClearQueryParams
}) {
  var _a2;
  const { t: t2 } = useTranslation();
  const [selectedSlotState, setSelectedSlotState] = reactExports.useState(
    null
  );
  const createReservationModalRef = reactExports.useRef(null);
  const { wrapUserLoginModal, isOwnerOrWorker } = useUser();
  const {
    data: workersWorkingShiftsByDaysResult,
    isFetching: isWorkersWorkingShiftsFetching
  } = useGetFeWorkerWorkingShiftsByDaysQuery({
    locationSlug: activeLocation,
    workerId: locationWorker == null ? void 0 : locationWorker.id
  });
  const { data: workersResult } = useGetFeWorkersQuery({
    locationSlug: activeLocation
  });
  const { data: locationReservations, isLoading: isReservationsLoading } = useGetFeLocationReservationsQuery({ locationSlug: activeLocation });
  const reservations = (_a2 = locationReservations == null ? void 0 : locationReservations.data) != null ? _a2 : [];
  const services = reactExports.useMemo(() => {
    return selectedGroupServices.filter((groupService) => {
      var _a3;
      return (_a3 = groupService.services) == null ? void 0 : _a3.length;
    }).map((group) => group.services).flat();
  }, [selectedGroupServices]);
  const servicesDuration = reactExports.useMemo(() => {
    return services.reduce((acc, service) => {
      var _a3;
      return acc + service.duration * ((_a3 = service.quantity) != null ? _a3 : 1);
    }, 0);
  }, [services]);
  const workersReservationByDate = reactExports.useMemo(
    () => (
      // transform reservations to object with date as key
      locationReservations == null ? void 0 : locationReservations.data.reduce((acc, reservation) => {
        const parsedDate = parseISO(reservation.dateUtc);
        const date = formatInTimeZone(
          parsedDate,
          getAppTimezone(),
          "yyyy-MM-dd"
        );
        const workerId = reservation.locationWorkerId;
        if (!acc[workerId]) {
          acc[workerId] = {};
        }
        if (!acc[workerId][date]) {
          acc[workerId][date] = [];
        }
        acc[workerId][date].push(reservation);
        return acc;
      }, {})
    ),
    [locationReservations]
  );
  const timeSlots = reactExports.useMemo(() => {
    if (!(workersWorkingShiftsByDaysResult == null ? void 0 : workersWorkingShiftsByDaysResult.data) || !(workersResult == null ? void 0 : workersResult.data)) {
      return void 0;
    }
    const slotsByDay = [];
    workersWorkingShiftsByDaysResult.data.forEach((shift) => {
      var _a3, _b2;
      const { date, dateFormatted: realDateFormatted } = parseUtcDate(
        shift.dateUtc,
        getAppTimezone()
      );
      const utcDate = parseISO(shift.dateUtc);
      slotsByDay.push({
        workerId: shift.locationWorkerId,
        date: utcDate,
        dateFormatted: t2("weeks.".concat(format(date, "EEEE"))) + ", " + format(date, "dd.MM."),
        slots: generateTimeSlots(
          shift.dateUtc,
          shift.timeFromUtc,
          shift.timeToUtc,
          reservationTimeInterval,
          roundedSlotInterval,
          (_b2 = (_a3 = workersReservationByDate == null ? void 0 : workersReservationByDate[shift.locationWorkerId]) == null ? void 0 : _a3[realDateFormatted]) != null ? _b2 : [],
          servicesDuration,
          isOwnerOrWorker ? 0 : 180,
          shift.pausesUtc
        )
      });
    });
    return slotsByDay.sort((a, b) => a.date.getTime() - b.date.getTime());
  }, [
    workersWorkingShiftsByDaysResult,
    workersResult,
    servicesDuration,
    reservations
  ]);
  const autoSelectedSlot = reactExports.useMemo(() => {
    if (selectedSlot && selectedDate && timeSlots && !selectedSlotState) {
      const matchingSlot = timeSlots.find(
        (slot) => slot.dateFormatted.includes(selectedDate) || format(slot.date, "yyyy-MM-dd") === selectedDate
      );
      if (matchingSlot) {
        const matchingTimeSlot = matchingSlot.slots.find(
          (timeSlot) => timeSlot === selectedSlot || timeSlot.substring(1) === selectedSlot
        );
        if (matchingTimeSlot) {
          const isPreviousDay = matchingTimeSlot.startsWith("-");
          const actualTimeUtc = isPreviousDay ? matchingTimeSlot.substring(1) : matchingTimeSlot;
          const timeLocal = fromUtcHM(actualTimeUtc);
          return {
            date: isPreviousDay ? addDays(matchingSlot.date, -1) : matchingSlot.date,
            dateFormatted: matchingSlot.dateFormatted,
            timeUtc: actualTimeUtc,
            timeLocal,
            workerId: matchingSlot.workerId,
            isPreviousDay
          };
        }
      }
    }
    return null;
  }, [selectedSlot, selectedDate, timeSlots, selectedSlotState]);
  const shouldShowNotification = reactExports.useMemo(
    () => selectedSlot && selectedDate && !autoSelectedSlot,
    [selectedSlot, selectedDate, autoSelectedSlot]
  );
  reactExports.useEffect(() => {
    if (autoSelectedSlot) {
      onClearQueryParams();
      setSelectedSlotState(autoSelectedSlot);
    }
  }, [autoSelectedSlot, onClearQueryParams]);
  const getWorkerDataByWorkerId = (workerId) => {
    var _a3, _b2;
    return (_b2 = locationWorker != null ? locationWorker : (_a3 = workersResult == null ? void 0 : workersResult.data) == null ? void 0 : _a3.find((worker) => worker.id === workerId)) != null ? _b2 : void 0;
  };
  const timeSlotsLoading = isWorkersWorkingShiftsFetching ? true : (timeSlots == null ? void 0 : timeSlots.length) ? false : void 0;
  const allSelectedServices = reactExports.useMemo(
    () => selectedGroupServices.filter((groupService) => {
      var _a3;
      return (_a3 = groupService.services) == null ? void 0 : _a3.length;
    }).map((group) => group.services).flat(),
    [selectedGroupServices]
  );
  const checkIsSameSlot = reactExports.useCallback(
    (slot) => {
      if (!selectedSlotState) return false;
      return selectedSlotState.dateFormatted === slot.dateFormatted && selectedSlotState.timeUtc === slot.timeUtc && selectedSlotState.workerId === slot.workerId;
    },
    [selectedSlotState]
  );
  const handleCloseSlotModal = reactExports.useCallback(() => {
    setSelectedSlotState(null);
  }, []);
  const handleSelectSlot = reactExports.useCallback(
    (slot) => {
      var _a3;
      if (!slot || checkIsSameSlot(slot)) {
        (_a3 = createReservationModalRef == null ? void 0 : createReservationModalRef.current) == null ? void 0 : _a3.dismiss();
        return;
      }
      setSelectedSlotState(slot);
    },
    [createReservationModalRef, checkIsSameSlot]
  );
  const handleSelectSlotWithAuth = reactExports.useCallback(
    (slot) => {
      var _a3;
      return (_a3 = wrapUserLoginModal(() => handleSelectSlot(slot))) == null ? void 0 : _a3();
    },
    [wrapUserLoginModal, handleSelectSlot]
  );
  const wrapperClassName = selectedSlotState && !isWebPlatform ? "mb-[50vh]" : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "".concat(wrapperClassName, " min-h-[50vh]"), children: [
      timeSlotsLoading === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Nema slobodnih termina") }) }) : timeSlotsLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pb-24", children: timeSlots == null ? void 0 : timeSlots.map((slot, index) => {
        const isSelectedDate = selectedDate && (slot.dateFormatted.includes(selectedDate) || format(slot.date, "yyyy-MM-dd") === selectedDate);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          DaySlotsCard$1,
          {
            dateFormatted: slot.dateFormatted,
            date: slot.date,
            slots: slot.slots,
            workerId: slot.workerId,
            workers: (workersResult == null ? void 0 : workersResult.data) || [],
            selectedSlot: selectedSlotState,
            onSlotSelect: handleSelectSlotWithAuth,
            shouldScrollToSlot: !!selectedSlot && !!isSelectedDate,
            targetSlotTime: selectedSlot,
            showWorkerName: !locationWorker
          },
          slot.dateFormatted + index
        );
      }) }, servicesDuration)
    ] }),
    selectedSlotState && /* @__PURE__ */ jsxRuntimeExports.jsx(
      CreateReservationModal$1,
      {
        ref: createReservationModalRef,
        isOpen: !!selectedSlotState,
        onCancel: handleCloseSlotModal,
        dateOnly: selectedSlotState.date,
        timeUtc: selectedSlotState.timeUtc,
        worker: getWorkerDataByWorkerId(
          selectedSlotState.workerId
        ),
        dateFormatted: selectedSlotState.dateFormatted,
        selectedServices: allSelectedServices
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NotificationToast,
      {
        message: t2("Izabrani slot nije slobodan"),
        type: "error",
        duration: 5e3,
        position: "top",
        isOpen: !!shouldShowNotification,
        onDidDismiss: () => {
        },
        cssClass: "animate-pulse"
      }
    )
  ] });
}
const SelectDateTimeStep$1 = reactExports.memo(SelectDateTimeStep);
const maxStep = 2;
function CreateAppointmentSteps({ appointment }) {
  var _a2;
  const { t: t2 } = useTranslation();
  const location = useLocation();
  const history = useHistory();
  const { wrapUserLoginModal } = useUser();
  const { delete: deleteQueryParam, data: queryParams } = useQueryParamsHook({});
  const formRef = reactExports.useRef(null);
  const queryWorkerId = queryParams["worker"] ? parseInt(queryParams["worker"]) : void 0;
  const querySlot = queryParams["slot"];
  const queryDate = queryParams["date"];
  const [activeStep, setActiveStep] = reactExports.useState(
    parseInt((_a2 = queryParams["step"]) != null ? _a2 : "0")
  );
  const [hasMultiplePersons, setHasMultiplePersons] = reactExports.useState(false);
  const contentRefFunctions = useContentRefFunctions();
  const { data: workersResult, isLoading: workersLoading } = useGetFeWorkersQuery({
    locationSlug: activeLocation
  });
  const workers = (workersResult == null ? void 0 : workersResult.data) || [];
  const activeWorkers = workers.filter(
    (worker) => worker.active
  );
  const [selectedWorker, setSelectedWorker] = reactExports.useState();
  const [groupsSelectedServices, setGroupsSelectedServices] = reactExports.useState([]);
  const {
    data: serviceGroupsResult,
    isLoading: serviceGroupsLoading,
    isFetching: serviceGroupsFetching
  } = useGetFeServiceGroupsQuery({
    locationSlug: activeLocation,
    withWorkers: 1
    // Always load workers data
  });
  const serviceGroups = serviceGroupsResult == null ? void 0 : serviceGroupsResult.data;
  const landedDirectlyOnStep1 = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (queryParams["step"] === "1" && history.length <= 2) {
      landedDirectlyOnStep1.current = true;
    }
  }, []);
  const canGoToStep = (step) => {
    if (step === 2 && groupsSelectedServices.length === 0) return false;
    return true;
  };
  const handleSetStep = (step) => {
    var _a3;
    if (!canGoToStep(step)) return;
    const params = new URLSearchParams(location.search);
    params.set("step", step.toString());
    if (activeStep && activeStep > step) {
      history.goBack();
    } else if (activeStep === 2 && step === 1) {
      history.replace({ search: params.toString() });
    } else {
      history.push({ search: params.toString() });
    }
    setActiveStep(step);
    (_a3 = formRef.current) == null ? void 0 : _a3.handleSetStep(step);
    contentRefFunctions == null ? void 0 : contentRefFunctions.scrollToTop(50);
  };
  const handleNextStep = () => {
    if (activeStep !== void 0 && activeStep < maxStep) {
      handleSetStep(activeStep + 1);
    }
  };
  const handleBackStep = () => {
    if (activeStep === 1 && landedDirectlyOnStep1.current) {
      history.goBack();
    } else if (activeStep !== void 0 && activeStep > 0) {
      handleSetStep(activeStep - 1);
    }
  };
  const handleSelectWorker = (worker) => {
    setSelectedWorker(worker);
    if (activeStep === 0) {
      handleSetStep(1);
    }
  };
  const handleSelectService = (serviceGroup, service) => {
    setGroupsSelectedServices((prev) => {
      const index = prev.findIndex(
        (item) => item.serviceGroup.id === serviceGroup.id
      );
      if (index > -1) {
        const group = prev[index].serviceGroup;
        const services = prev[index].services;
        if (services) {
          const serviceIndex = services.findIndex(
            (item) => item.id === service.id
          );
          if (serviceIndex > -1) {
            services.splice(serviceIndex, 1);
          } else if (group.inputType !== InputType.checkbox && !hasMultiplePersons) {
            services.splice(0, services.length);
            services.push(service);
          } else {
            services.push(service);
          }
          if (services.length === 0) {
            prev.splice(index, 1);
          }
        }
      } else {
        prev.push({ serviceGroup, services: [service] });
      }
      return [...prev];
    });
  };
  const handleHasMultiplePersons = (has) => {
    setHasMultiplePersons(has);
    setGroupsSelectedServices([]);
  };
  const pickDateTimeEnabled = (activeStep != null ? activeStep : 0) >= 2 && groupsSelectedServices.length > 0 ? true : void 0;
  const allSelectedServices = reactExports.useMemo(
    () => groupsSelectedServices.filter((groupService) => {
      var _a3;
      return (_a3 = groupService.services) == null ? void 0 : _a3.length;
    }).map((group) => group.services).flat(),
    [groupsSelectedServices]
  );
  const getBadgeQuantityOfServices = (service) => service.quantity && service.quantity > 1 ? "x".concat(service.quantity) : "";
  const handleClearQueryParams = reactExports.useCallback(() => {
    if (querySlot && queryDate) {
      deleteQueryParam(["slot", "date"]);
    }
  }, [deleteQueryParam, querySlot, queryDate]);
  reactExports.useEffect(() => {
    var _a3;
    (_a3 = wrapUserLoginModal()) == null ? void 0 : _a3();
  }, []);
  reactExports.useEffect(() => {
    if (activeWorkers.length === 1 && !selectedWorker && activeStep === 0) {
      const singleWorker = activeWorkers[0];
      setSelectedWorker(singleWorker);
      handleSetStep(1);
    }
  }, [activeWorkers, selectedWorker, activeStep]);
  reactExports.useEffect(() => {
    if (activeStep === 2 && groupsSelectedServices.length === 0) {
      const params = new URLSearchParams(location.search);
      params.set("step", "1");
      history.replace({ search: params.toString() });
      setActiveStep(1);
    }
  }, [activeStep, selectedWorker, groupsSelectedServices]);
  reactExports.useEffect(() => {
    var _a3, _b2;
    const params = new URLSearchParams(location.search);
    const stepFromUrl = parseInt((_a3 = params.get("step")) != null ? _a3 : "0", 10);
    setActiveStep(stepFromUrl);
    (_b2 = formRef.current) == null ? void 0 : _b2.handleSetStep(stepFromUrl);
  }, [location.search]);
  if ((serviceGroupsLoading || serviceGroupsFetching || workersLoading) && activeStep) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { name: "crescent" });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConditionalComponent,
      {
        condition: activeStep === 2,
        render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { className: "sticky top-0 pt-1", color: "dark", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { className: "px-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SwiperWrapper$1,
          {
            spaceBetween: 10,
            slidesPerView: "auto",
            freeMode: true,
            children: allSelectedServices == null ? void 0 : allSelectedServices.map((service) => /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { style: { width: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonBadge, { className: "p-2 text-black", color: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
              service.title,
              " ",
              getBadgeQuantityOfServices(service)
            ] }) }) }, service.id))
          }
        ) }) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormStepper$1,
      {
        className: "mt-2 max-w-[1200px] overflow-y-scroll",
        ref: formRef,
        minStep: 0,
        swiperProps: {
          onSlideChangeTransitionEnd: () => {
            contentRefFunctions == null ? void 0 : contentRefFunctions.scrollToTop(50);
          }
        },
        renderSteps: () => [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectWorkerStep,
            {
              selectedWorker,
              setSelectedWorker: handleSelectWorker,
              workerId: selectedWorker ? void 0 : queryWorkerId,
              activeWorkersCount: activeWorkers.length
            }
          ),
          serviceGroups && !serviceGroupsLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectAppointmentStep,
            {
              onBack: handleBackStep,
              onNext: handleNextStep,
              selectedWorker,
              serviceGroups,
              groupsSelectedServices,
              onSelectService: handleSelectService,
              hasMultiplePersons,
              setHasMultiplePersons: handleHasMultiplePersons
            }
          ) : void 0,
          pickDateTimeEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectDateTimeStep$1,
            {
              locationWorker: selectedWorker,
              selectedGroupServices: groupsSelectedServices,
              onBack: handleBackStep,
              selectedSlot: querySlot,
              selectedDate: queryDate,
              onClearQueryParams: handleClearQueryParams
            }
          )
        ],
        initialStep: activeStep != null ? activeStep : 0,
        onCurrentStepChange: setActiveStep
      }
    ),
    !!activeStep && /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { className: "ion-no-border fixed bottom-2 left-0 right-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { className: "px-2 h-[76px]", color: "translucent", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          onClick: handleBackStep,
          slot: "start",
          color: "light",
          size: "large",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: arrowBack }),
            t2("Nazad")
          ]
        }
      ),
      activeStep === 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          onClick: handleNextStep,
          slot: "end",
          color: "dark",
          size: "large",
          disabled: !groupsSelectedServices.length,
          children: [
            t2("Dalje"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: arrowForward })
          ]
        }
      )
    ] }) })
  ] });
}
function CreateAppointmentPage() {
  const { t: t2 } = useTranslation();
  const [key, setKey] = reactExports.useState("appointment");
  const { userData } = useUser();
  const dispatch = useAppDispatch();
  const deviceData = useAppSelector(getDeviceData);
  const location = useLocation();
  const [backButtonUrl, setBackButtonUrl] = reactExports.useState(
    void 0
  );
  const initialStep = reactExports.useRef(0);
  useIonViewDidLeave(() => {
    setTimeout(() => {
      setKey((prev) => prev + "-new");
    }, 1e3);
  });
  reactExports.useEffect(() => {
    var _a2;
    const params = new URLSearchParams(location.search);
    const step = parseInt((_a2 = params.get("step")) != null ? _a2 : "0", 10);
    initialStep.current = step;
    if (step === 0 || step === 1) {
      setBackButtonUrl(void 0);
    } else {
      setBackButtonUrl("".concat(urlPrefix, "/t/termini"));
    }
  }, []);
  reactExports.useEffect(() => {
    var _a2;
    const params = new URLSearchParams(location.search);
    const step = parseInt((_a2 = params.get("step")) != null ? _a2 : "0", 10);
    if (step !== initialStep.current) {
      setBackButtonUrl("".concat(urlPrefix, "/t/termini"));
    } else if (step === 0 || step === 1) {
      setBackButtonUrl(void 0);
    }
  }, [location.search]);
  reactExports.useEffect(() => {
    if (!deviceData.notificationsEnabled && userData) {
      dispatch(setDeviceData({ notificationsEnabled: true }));
    }
  }, [deviceData, userData]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      title: t2("Nov termin"),
      hasBackButton: true,
      backButtonIcon: exitOutline,
      backButtonUrl,
      hasRefresher: false,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateAppointmentSteps, {}, key)
    }
  );
}
function ConfirmReservation({ reservationHash }) {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  const { t: t2 } = useTranslation();
  const { data: reservationResponse, isLoading: isReservationLoading } = useGetOneFeReservationQuery({
    locationSlug: activeLocation,
    reservationHash
  });
  const reservationData = reservationResponse == null ? void 0 : reservationResponse.data;
  if (isReservationLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {});
  }
  if (!reservationData || !reservationData.dateUtc) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { color: "danger", children: t2("Do큄lo je do gre큄ke!") });
  }
  const date = parseISO(reservationData.dateUtc);
  const dateFormatted = format(date, "dd.MM.yyyy");
  const timeFormatted = fromUtcDateTimeToTime(date);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonGrid, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        LazyLoadImgStandard$1,
        {
          src: getPathBySize(
            (_b2 = (_a2 = reservationData.locationWorker) == null ? void 0 : _a2.avatar) == null ? void 0 : _b2.pathByResolution
          ),
          preloadImg: preloadCoverImg$1,
          className: "h-16 w-16 rounded-full object-cover flex-shrink-0"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-lg font-semibold mb-0 flex items-center", children: (_c2 = reservationData.locationWorker) == null ? void 0 : _c2.fullName })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "border-2 rounded-2xl border-amber-300 text-md text-center py-2",
        children: reservationData.friendlyCode || reservationData.hash
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarClearOutline, className: "mr-2" }),
        t2("Status")
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "flex items-center h-full ".concat(reservationData.status === AppointmentStatus.CONFIRMED ? "text-green-500" : reservationData.status === AppointmentStatus.CANCELLED || reservationData.status === AppointmentStatus.NO_SHOW ? "text-red-500" : ""),
          children: t2(APPOINTMENT_STATUS_LABELS[reservationData.status])
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarOutline, className: "mr-2" }),
        t2("Datum")
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { className: "flex items-center", children: dateFormatted })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: timeOutline, className: "mr-2" }),
        t2("Vreme")
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { className: "flex items-center", children: timeFormatted })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: pricetagOutline, className: "mr-2" }),
        t2("Cena usluga")
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCol, { className: "flex items-center", children: [
        reservationData.originalCost && reservationData.discount && /* @__PURE__ */ jsxRuntimeExports.jsx("s", { className: "text-rose-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: reservationData.originalCost }) }),
        " ",
        reservationData.servicesCost,
        " RSD"
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTitle, { children: [
      t2("Usluge"),
      " [",
      (_e2 = (_d2 = reservationData.services) == null ? void 0 : _d2.length) != null ? _e2 : 0,
      "]"
    ] }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperWrapper$1, { slidesPerView: "auto", spaceBetween: 12, children: (_f2 = reservationData.services) == null ? void 0 : _f2.map((service) => {
      var _a3, _b3;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { style: { width: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonBadge, { className: "p-2", color: "warning", children: [
        service.title,
        ((_a3 = service.pivot) == null ? void 0 : _a3.quantity) && service.pivot.quantity > 1 ? " x".concat((_b3 = service.pivot) == null ? void 0 : _b3.quantity) : ""
      ] }) }, service.id);
    }) }) }) }),
    reservationData.notice && /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { color: "warning", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: alertCircleOutline, className: "mr-2" }),
        t2("Napomena")
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { className: "flex items-center", children: reservationData.notice })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: hourglassOutline, className: "mr-2" }),
        t2("Trajanje usluga")
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCol, { className: "flex items-center", children: [
        reservationData.servicesDuration,
        " min"
      ] })
    ] }),
    reservationData.reason && /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: helpOutline, className: "mr-2", color: "danger" }),
        t2("Razlog")
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { className: "flex items-center", children: reservationData.reason })
    ] })
  ] });
}
const ConfirmReservation$1 = reactExports.memo(ConfirmReservation);
const schema$1 = yup.object().shape({
  id: yup.mixed().required().nullable(),
  fullName: yup.string().required(),
  // yup validation (phone number) must start with 0, and have 5-10 digits
  phoneNumber: yup.string().matches(/^[0]\d{6,11}$/, {
    message: t("Broj telefona mora po훾eti sa 0 i imati od 6 do 12 cifara")
  }).required(),
  dateOfBirth: yup.string().required().nullable()
});
function ClientForm({
  clientData,
  onSave,
  disabledPhoneNumber,
  scrollToBottom,
  formDisabled,
  showSaveButton
}) {
  var _a2, _b2, _c2, _d2;
  useTranslation();
  const form = useFormWithSchema(schema$1, {
    defaultValues: {
      id: (_a2 = clientData == null ? void 0 : clientData.id) != null ? _a2 : null,
      fullName: (_b2 = clientData == null ? void 0 : clientData.fullName) != null ? _b2 : "",
      phoneNumber: (_c2 = clientData == null ? void 0 : clientData.phoneNumber) != null ? _c2 : "",
      dateOfBirth: (_d2 = clientData == null ? void 0 : clientData.dateOfBirth) != null ? _d2 : null
    }
  });
  const { handleSubmit } = form;
  const formFields = getClientFormFields(
    disabledPhoneNumber != null ? disabledPhoneNumber : false,
    formDisabled
  );
  const firstName = form.watch("fullName");
  const phoneNumber = form.watch("phoneNumber");
  const onSubmit = (data) => {
    onSave(data);
  };
  const handleForm = () => {
    setTimeout(() => {
      window.scrollTo(0, document.body.scrollHeight);
    }, 100);
  };
  reactExports.useEffect(() => {
    if (firstName && phoneNumber) {
      handleSubmit(onSubmit)();
    }
  }, [firstName, phoneNumber]);
  reactExports.useEffect(() => {
    var _a3, _b3;
    if (clientData) {
      form.setValue("id", (_a3 = clientData.id) != null ? _a3 : null);
      form.setValue("fullName", clientData.fullName);
      form.setValue("phoneNumber", clientData.phoneNumber);
      form.setValue("dateOfBirth", (_b3 = clientData.dateOfBirth) != null ? _b3 : null);
    }
  }, [clientData]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "form",
    {
      onSubmit: handleSubmit(onSubmit),
      onClick: scrollToBottom ? handleForm : void 0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields: formFields, form }),
        showSaveButton && /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { type: "submit", color: "success", children: t("Sa훾uvaj") })
      ]
    }
  );
}
const schema = yup.object().shape({
  id: yup.mixed().required().nullable(),
  fullName: yup.string().required().nullable(),
  phoneNumber: yup.string().required(),
  dateOfBirth: yup.string().required().nullable()
});
function AdministrationClientForm({
  clients,
  onSave,
  disabledPhoneNumber
}) {
  const [selectedClientData, setSelectedClientData] = reactExports.useState(void 0);
  const form = useFormWithSchema(schema, {
    defaultValues: {
      id: null,
      fullName: "",
      phoneNumber: ""
    }
  });
  const { handleSubmit, watch } = form;
  const clientId = watch("id");
  const clientOptions = reactExports.useMemo(
    () => {
      var _a2;
      return (_a2 = clients.map((client) => {
        var _a3, _b2;
        return {
          value: (_b2 = (_a3 = client.id) == null ? void 0 : _a3.toString()) != null ? _b2 : "",
          text: "".concat(client.fullName, " - ").concat(client.phoneNumber)
        };
      })) != null ? _a2 : [];
    },
    [clients]
  );
  const formFields = getAdministrationClientFormFields(
    disabledPhoneNumber != null ? disabledPhoneNumber : false,
    clientOptions,
    () => {
    }
  );
  reactExports.useEffect(() => {
    var _a2, _b2;
    if (!clientId) {
      setSelectedClientData(void 0);
      return;
    }
    const existingClient = clients.find(
      (client) => {
        var _a3;
        return ((_a3 = client.id) == null ? void 0 : _a3.toString()) === clientId;
      }
    );
    if (existingClient) {
      setSelectedClientData(existingClient);
      onSave({
        id: (_a2 = existingClient.id) != null ? _a2 : null,
        fullName: existingClient.fullName,
        phoneNumber: existingClient.phoneNumber,
        dateOfBirth: (_b2 = existingClient.dateOfBirth) != null ? _b2 : null
      });
    } else {
      setSelectedClientData({
        id: void 0,
        fullName: clientId ? clientId.toString() : "",
        phoneNumber: "",
        dateOfBirth: void 0,
        email: "",
        userId: 0
      });
    }
  }, [clientId]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    selectedClientData && /* @__PURE__ */ jsxRuntimeExports.jsx(ClientForm, { onSave, clientData: selectedClientData }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields: formFields, form })
  ] });
}
function EditClient({
  onSave,
  scrollToBottom,
  editDisabled,
  showSaveButton
}) {
  var _a2;
  const { data: clientsResponse, isLoading: isClientDataLoading } = useGetFeLocationClientsQuery({
    locationSlug: activeLocation
  });
  const clients = (_a2 = clientsResponse == null ? void 0 : clientsResponse.data) != null ? _a2 : [];
  const { isOwnerOrWorker } = useUser();
  const { data: clientResponse } = useGetFeClientDataQuery(void 0, {
    skip: !!isOwnerOrWorker
  });
  const clientData = clientResponse == null ? void 0 : clientResponse.data;
  if (isClientDataLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {});
  }
  if (isOwnerOrWorker) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AdministrationClientForm, { onSave, clients });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ClientForm,
    {
      onSave,
      clientData,
      scrollToBottom,
      formDisabled: editDisabled,
      showSaveButton
    }
  );
}
function ReservationFooter({
  client,
  existingClient,
  isOwnerOrWorker,
  isOwnerOrWorkerOrAdmin,
  validUser,
  disableCancel,
  clientExists,
  reservationStatus,
  isLoadingReservation,
  isReservationInPast,
  onClientDataChange,
  onShowClientModal,
  onCancelClick,
  onNoShowClick,
  onConfirmClick
}) {
  const { t: t2 } = useTranslation();
  if (isLoadingReservation) {
    return null;
  }
  const hasMultipleActions = !(isReservationInPast && !isOwnerOrWorkerOrAdmin) || !!reservationStatus && reservationStatus !== AppointmentStatus.CONFIRMED;
  const justifyActions = hasMultipleActions ? "justify-between" : "justify-center";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonFooter, { className: "bg-black", children: [
    client && client.id ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonItem,
      {
        button: true,
        routerLink: "".concat(urlPrefix, "/public-profile/").concat(client.id),
        className: "text-blue-400",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: personOutline }),
          client.fullName,
          " - ",
          client.phoneNumber
        ] })
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConditionalComponent,
      {
        condition: !existingClient && !isOwnerOrWorker,
        render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonItem,
          {
            button: true,
            color: "dark",
            className: "text-amber-400 animate-bounce",
            onClick: onShowClientModal,
            children: t2("Popunite podatke o vama")
          }
        ),
        renderElse: () => /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditClient, { onSave: onClientDataChange, scrollToBottom: true }) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConditionalComponent,
      {
        condition: !(isReservationInPast && !isOwnerOrWorkerOrAdmin),
        render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center ".concat(justifyActions, " w-full pb-2"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ConditionalComponent,
            {
              condition: isReservationInPast && isOwnerOrWorkerOrAdmin,
              render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  color: "danger",
                  onClick: onNoShowClick || onCancelClick,
                  disabled: !validUser || disableCancel,
                  children: t2("Nije se pojavio")
                }
              ),
              renderElse: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
                ConditionalComponent,
                {
                  condition: !isReservationInPast,
                  render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    IonButton,
                    {
                      slot: "start",
                      color: "danger",
                      size: "default",
                      onClick: onCancelClick,
                      disabled: !validUser || disableCancel,
                      children: t2("Otka탑i")
                    }
                  )
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ConditionalComponent,
            {
              condition: !!reservationStatus && reservationStatus !== AppointmentStatus.CONFIRMED,
              render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  slot: "end",
                  color: "success",
                  size: "default",
                  className: "text-white",
                  disabled: !validUser || disableCancel,
                  onClick: () => {
                    if (clientExists) {
                      onConfirmClick();
                    } else {
                      onShowClientModal();
                    }
                  },
                  children: t2("Potvrdi")
                }
              )
            }
          )
        ] })
      }
    )
  ] });
}
function ReservationActions({
  showCancelConfirmation,
  showClientModal,
  existingClient,
  saveLabel,
  isNoShow,
  onCancelConfirm,
  onNoShowConfirm,
  onCancelDismiss,
  onClientSave,
  onClientCancel
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ClientDataModal,
      {
        isOpen: showClientModal,
        onCancel: onClientCancel,
        onSave: onClientSave,
        saveLabel: saveLabel || t2("Sa훾uvaj i potvrdi"),
        initialData: existingClient
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonAlertConfirmation,
      {
        confirmAction: isNoShow ? onNoShowConfirm || onCancelConfirm : onCancelConfirm,
        isOpen: showCancelConfirmation,
        message: isNoShow ? t2("Da li ste sigurni da klijent nije do큄ao na rezervaciju?") : t2("Da li ste sigurni da 탑elite da otka탑ete rezervaciju?"),
        confirmCssClass: isNoShow ? "!text-orange-600" : "!text-rose-600",
        onDidDismiss: onCancelDismiss,
        inputs: [
          {
            name: "reason",
            type: "text",
            placeholder: isNoShow ? t2("Unesite napomenu (opciono)") : t2("Unesite razlog otkazivanja")
          }
        ]
      }
    )
  ] });
}
function ConfirmReservationPage({
  match
}) {
  var _a2, _b2;
  const { t: t2 } = useTranslation();
  const hash = match.params.reservationHash;
  const [clientData, setClientData] = reactExports.useState(
    void 0
  );
  const [showSuccessToast] = useIonToast();
  const { push, goBack } = useIonRouter();
  const { isOwnerOrWorker, isAdmin, userData } = useUser();
  const [showCancelConfirmation, setShowCancelConfirmation] = reactExports.useState(false);
  const [showClientModal, setShowClientModal] = reactExports.useState(false);
  const { data: queryParams } = useQueryParamsHook({});
  const hasBackToHome = (_a2 = queryParams["backToHome"]) != null ? _a2 : false;
  const [updateReservation, updateReservationResult] = useUpdateFeReservationMutation();
  const { data: reservationResponse, isLoading: isReservationLoading } = useGetOneFeReservationQuery({
    locationSlug: activeLocation,
    reservationHash: hash
  });
  const reservationData = reservationResponse == null ? void 0 : reservationResponse.data;
  const clientExists = !!(clientData == null ? void 0 : clientData.fullName) && !!(clientData == null ? void 0 : clientData.phoneNumber);
  const existingClient = reservationData == null ? void 0 : reservationData.client;
  const goToAppointments = () => {
    push("".concat(urlPrefix, "/t/termini"), "back");
  };
  const handleConfirm = () => {
    if (!clientData) {
      return;
    }
    updateReservation({
      locationSlug: activeLocation,
      reservationHash: hash,
      clientData,
      status: AppointmentStatus.CONFIRMED,
      saveClient: !isOwnerOrWorker
    }).then((result) => {
      var _a3;
      if ("data" in result && ((_a3 = result.data) == null ? void 0 : _a3.success)) {
        goToAppointments();
        showSuccessToast({
          message: t2("Rezervacija je uspe큄no potvr휃ena"),
          duration: 3e3,
          color: "success"
        });
      }
    });
  };
  const handleCancel = (data) => {
    updateReservation({
      locationSlug: activeLocation,
      reservationHash: hash,
      status: AppointmentStatus.CANCELLED,
      reason: data == null ? void 0 : data.reason
    }).then((result) => {
      var _a3;
      if ("data" in result && ((_a3 = result.data) == null ? void 0 : _a3.success)) {
        goToAppointments();
        showSuccessToast({
          message: t2("Rezervacija je uspe큄no otkazana"),
          duration: 3e3,
          color: "danger"
        });
      }
    });
    showCancelConfirmation && setShowCancelConfirmation(false);
  };
  const handleNoShow = (data) => {
    updateReservation({
      locationSlug: activeLocation,
      reservationHash: hash,
      status: AppointmentStatus.NO_SHOW,
      reason: data == null ? void 0 : data.reason
    }).then((result) => {
      var _a3;
      if ("data" in result && ((_a3 = result.data) == null ? void 0 : _a3.success)) {
        goToAppointments();
        showSuccessToast({
          message: t2('Rezervacija je ozna훾ena kao "Nije se pojavio"'),
          duration: 3e3,
          color: "warning"
        });
      }
    });
    showCancelConfirmation && setShowCancelConfirmation(false);
  };
  const isReservationInPast = (reservationData == null ? void 0 : reservationData.dateUtc) && (reservationData == null ? void 0 : reservationData.servicesDuration) ? isPast(
    addMinutes(
      parseISO(reservationData.dateUtc),
      reservationData.servicesDuration
    )
  ) : false;
  const validUser = isOwnerOrWorker || !(reservationData == null ? void 0 : reservationData.client) || (userData == null ? void 0 : userData.id) === reservationData.client.userId;
  const handleClientData = (data) => {
    setClientData(data);
  };
  const disableCancel = reservationData && (reservationData.status === AppointmentStatus.CANCELLED || reservationData.status === AppointmentStatus.NO_SHOW);
  const handleClientModalSave = (data) => {
    setClientData(data);
    setShowClientModal(false);
    handleConfirm();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    LayoutMainPage,
    {
      title: t2("Potvrda rezervacije"),
      titleSlot: "start",
      hasBackButton: true,
      backButtonUrl: hasBackToHome ? "".concat(urlPrefix, "/t/termini") : void 0,
      showLoadingMessage: updateReservationResult.isLoading,
      footer: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ReservationFooter,
        {
          client: (_b2 = reservationData == null ? void 0 : reservationData.client) != null ? _b2 : void 0,
          existingClient: existingClient != null ? existingClient : void 0,
          isOwnerOrWorker,
          validUser,
          disableCancel: !!disableCancel,
          clientExists,
          reservationStatus: reservationData == null ? void 0 : reservationData.status,
          isLoadingReservation: isReservationLoading,
          isReservationInPast,
          isOwnerOrWorkerOrAdmin: isOwnerOrWorker || isAdmin,
          onClientDataChange: handleClientData,
          onShowClientModal: () => setShowClientModal(true),
          onCancelClick: () => setShowCancelConfirmation(true),
          onNoShowClick: () => setShowCancelConfirmation(true),
          onConfirmClick: handleConfirm
        }
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmReservation$1, { reservationHash: hash }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ReservationActions,
          {
            showCancelConfirmation,
            showClientModal,
            existingClient: existingClient != null ? existingClient : void 0,
            saveLabel: t2("Sa훾uvaj i potvrdi"),
            isNoShow: isReservationInPast && (isOwnerOrWorker || isAdmin),
            onCancelConfirm: handleCancel,
            onNoShowConfirm: handleNoShow,
            onCancelDismiss: () => setShowCancelConfirmation(false),
            onClientSave: handleClientModalSave,
            onClientCancel: () => setShowClientModal(false)
          }
        )
      ]
    }
  );
}
const PublicProfilePage = reactExports.lazy(() => __vitePreload(() => import("./PublicProfilePage-CqaO_eRj.js"), true ? __vite__mapDeps([10,1,2,3,4,5,6,7,8,9]) : void 0));
function PublicProfilePageWrapper() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Profil klijenta") }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PublicProfilePage, {})
    }
  );
}
const ITEMS_PER_PAGE = 10;
function NewsListPage() {
  var _a2, _b2, _c2, _d2, _e2;
  const { t: t2 } = useTranslation();
  const router = useIonRouter();
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const [filters, setFilters] = reactExports.useState({
    type: void 0,
    status: void 0
  });
  const { data, isLoading } = useGetNewsListQuery({
    locationSlug: activeLocation,
    page: currentPage,
    perPage: ITEMS_PER_PAGE,
    ...filters
  });
  const handleCreateNews = () => {
    router.push("".concat(urlPrefix, "/podesavanja/vesti/novo"));
  };
  const handleEditNews = (newsId) => {
    router.push("".concat(urlPrefix, "/podesavanja/vesti/edit/").concat(newsId));
  };
  const getTypeIcon = (type) => {
    switch (type) {
      case "news":
        return megaphoneOutline;
      case "chyron":
        return timeOutline;
      case "alert":
        return alertOutline;
      default:
        return megaphoneOutline;
    }
  };
  const getStatusIcon = (status) => {
    switch (status) {
      case "approved":
        return checkmarkCircleOutline;
      case "pending":
        return timeOutline;
      case "draft":
        return closeCircleOutline;
      default:
        return closeCircleOutline;
    }
  };
  const getStatusColor = (status) => {
    switch (status) {
      case "approved":
        return "success";
      case "pending":
        return "warning";
      case "draft":
        return "medium";
      default:
        return "medium";
    }
  };
  const getLevelColor = (level) => {
    if (level >= 8) return "danger";
    if (level >= 6) return "warning";
    if (level >= 4) return "primary";
    return "medium";
  };
  if (isLoading) return /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {});
  const totalPages = ((_a2 = data == null ? void 0 : data.data) == null ? void 0 : _a2.lastPage) || 1;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      title: t2("Vesti i va탑na saop큄tenja"),
      hasBackButton: true,
      footer: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButton, { onClick: handleCreateNews, color: "dark", size: "large", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline, slot: "start" }),
        t2("Nova vest")
      ] }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardTitle, { children: t2("Lista vesti") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { children: [
          (_c2 = (_b2 = data == null ? void 0 : data.data) == null ? void 0 : _b2.data) == null ? void 0 : _c2.map((news) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            IonItem,
            {
              button: true,
              onClick: () => handleEditNews(news.id),
              className: "border-t border-gray-200",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: getTypeIcon(news.type), slot: "start" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: news.title }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: news.description }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 mt-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonBadge, { color: getLevelColor(news.level), children: [
                      t2("Nivo"),
                      ": ",
                      news.level
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonBadge, { color: getStatusColor(news.status), children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: getStatusIcon(news.status) }),
                      t2(news.status)
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(IonBadge, { color: "primary", children: t2(news.type) })
                  ] })
                ] })
              ]
            },
            news.id
          )),
          ((_e2 = (_d2 = data == null ? void 0 : data.data) == null ? void 0 : _d2.data) == null ? void 0 : _e2.length) === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-text-center ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: t2("Nema vesti") }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Pagination,
            {
              currentPage,
              totalPages,
              onPageChange: setCurrentPage,
              isLoading,
              className: "ion-padding-top"
            }
          )
        ] })
      ] })
    }
  );
}
const newsFormSchema = create$3().shape({
  title: create$6().min(2, t("Naslov mora imati najmanje 2 karaktera")).max(255, t("Naslov ne mo탑e biti du탑i od 255 karaktera")).required(t("Naslov je obavezan")),
  description: create$6().min(10, t("Opis mora imati najmanje 10 karaktera")).max(1e3, t("Opis ne mo탑e biti du탑i od 1000 karaktera")).required(t("Opis je obavezan")),
  level: create$5().min(1, t("Nivo mora biti izme휃u 1 i 10")).max(10, t("Nivo mora biti izme휃u 1 i 10")).required(t("Nivo je obavezan")),
  type: create$6().oneOf(["news", "chyron", "alert"], t("Neva탑e훶i tip vesti")).required(t("Tip vesti je obavezan")),
  status: create$6().oneOf(["draft", "pending", "approved"], t("Neva탑e훶i status")).required(t("Status je obavezan")),
  locationSlug: create$6().required(t("Lokacija je obavezna")),
  activatedAtUtc: create$6().required(),
  deactivatedAtUtc: create$6().required(),
  showActivationDates: create$7().optional()
}).test(
  "activation-dates",
  t("Datum deaktivacije mora biti nakon datuma aktivacije"),
  function(value) {
    const { activatedAtUtc, deactivatedAtUtc } = value;
    if (activatedAtUtc && deactivatedAtUtc) {
      const activatedDate = new Date(activatedAtUtc);
      const deactivatedDate = new Date(deactivatedAtUtc);
      if (deactivatedDate <= activatedDate) {
        return this.createError({
          message: t("Datum deaktivacije mora biti nakon datuma aktivacije"),
          path: "deactivatedAtUtc"
        });
      }
    }
    return true;
  }
);
const getNewsFormFields = (showActivationDates) => [
  {
    keyName: "title",
    name: "title",
    data: {
      type: FieldType.Text,
      label: t("Naslov")
    },
    gridSize: {
      size: "12"
    },
    required: true
  },
  {
    keyName: "description",
    name: "description",
    data: {
      type: FieldType.TextArea,
      label: t("Opis"),
      maxlength: 1e3,
      rows: 4
    },
    gridSize: {
      size: "12"
    },
    required: true
  },
  {
    keyName: "type",
    name: "type",
    data: {
      type: FieldType.Select,
      label: t("Tip vesti"),
      placeholder: t("Izaberite tip vesti"),
      options: [
        { value: "chyron", text: t("Kajron") },
        { value: "news", text: t("Vesti") },
        { value: "alert", text: t("Upozorenja") }
      ]
    },
    gridSize: {
      size: "12",
      sizeMd: "6"
    },
    required: true
  },
  {
    keyName: "level",
    name: "level",
    data: {
      type: FieldType.Select,
      label: t("Nivo va탑nosti"),
      placeholder: t("Izaberite nivo va탑nosti"),
      options: Array.from({ length: 10 }, (_, i) => ({
        value: String(i + 1),
        text: "".concat(i + 1, " - ").concat(t("Nivo ".concat(i + 1)))
      }))
    },
    gridSize: {
      size: "12",
      sizeMd: "6"
    },
    required: true
  },
  {
    keyName: "status",
    name: "status",
    data: {
      type: FieldType.Select,
      label: t("Status"),
      placeholder: t("Izaberite status"),
      options: [
        { value: "draft", text: t("Draft") },
        { value: "pending", text: t("Na 훾ekanju") },
        { value: "approved", text: t("Odobreno") }
      ]
    },
    gridSize: {
      size: "12",
      sizeMd: "6"
    },
    required: true
  },
  {
    keyName: "activatedAtUtc",
    name: "activatedAtUtc",
    data: {
      type: FieldType.DateTime,
      label: t("Aktiviraj od"),
      inputProps: {
        preferWheel: true,
        locale: instance.language === "rs" ? "sr-Latn-RS" : "en-GB"
      }
    },
    gridSize: {
      size: "12",
      sizeMd: "6"
    }
  },
  {
    keyName: "deactivatedAtUtc",
    name: "deactivatedAtUtc",
    data: {
      type: FieldType.DateTime,
      label: t("Deaktiviraj od"),
      inputProps: {
        preferWheel: true,
        locale: instance.language === "rs" ? "sr-Latn-RS" : "en-GB"
      }
    },
    gridSize: {
      size: "12",
      sizeMd: "6"
    }
  }
];
function NewsForm({
  news,
  onSubmit,
  isLoading = false,
  isEdit = false
}) {
  const { t: t2 } = useTranslation();
  const [showActivationDates, setShowActivationDates] = reactExports.useState(false);
  const form = useFormWithSchema(newsFormSchema, {
    defaultValues: {
      title: "",
      description: "",
      level: 5,
      type: "news",
      status: "draft",
      locationSlug: activeLocation,
      activatedAtUtc: void 0,
      deactivatedAtUtc: void 0,
      showActivationDates: false
    }
  });
  reactExports.useEffect(() => {
    if (news) {
      const hasActivationDates = !!news.activatedAtUtc || !!news.deactivatedAtUtc;
      setShowActivationDates(hasActivationDates);
      form.reset({
        title: news.title,
        description: news.description,
        level: news.level,
        type: news.type,
        status: news.status,
        locationSlug: activeLocation,
        activatedAtUtc: news.activatedAtUtc || void 0,
        deactivatedAtUtc: news.deactivatedAtUtc || void 0,
        showActivationDates: hasActivationDates
      });
    }
  }, [news, form]);
  const handleSubmit = form.handleSubmit((data) => {
    const submitData = { ...data };
    if (typeof submitData.level === "string") {
      submitData.level = parseInt(submitData.level, 10);
    }
    onSubmit(submitData);
  });
  const handleActivationDatesChange = (checked) => {
    setShowActivationDates(checked);
    form.setValue("showActivationDates", checked);
    if (!checked) {
      form.setValue("activatedAtUtc", void 0);
      form.setValue("deactivatedAtUtc", void 0);
    }
  };
  const formFields = getNewsFormFields();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DynamicForm,
      {
        fields: formFields,
        form,
        callback: (field) => {
          if (field.keyName === "showActivationDates") {
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Aktivacioni datumi") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonToggle,
                {
                  checked: showActivationDates,
                  onIonChange: (e) => handleActivationDatesChange(e.detail.checked)
                }
              )
            ] });
          }
          return null;
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-padding-top", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        type: "submit",
        expand: "block",
        disabled: isLoading,
        color: "success",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "start" }),
          isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { name: "crescent" }) : t2(isEdit ? "Sa훾uvaj izmene" : "Kreiraj vest")
        ]
      }
    ) })
  ] });
}
function NewsCreatePage() {
  const { t: t2 } = useTranslation();
  const router = useIonRouter();
  const [presentToast] = useIonToast();
  const [createNews, { isLoading }] = useCreateNewsMutation();
  const handleSubmit = async (data) => {
    try {
      await createNews(data).unwrap();
      presentToast({
        message: t2("Vest je uspe큄no kreirana"),
        duration: 2e3,
        color: "success"
      });
      router.push("".concat(urlPrefix, "/podesavanja/vesti"));
    } catch (error) {
      presentToast({
        message: t2("Gre큄ka pri kreiranju vesti"),
        duration: 3e3,
        color: "danger"
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMainPage, { title: t2("Nova vest"), hasBackButton: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(NewsForm, { onSubmit: handleSubmit, isLoading, isEdit: false }) });
}
function NewsEditPage() {
  const { t: t2 } = useTranslation();
  const router = useIonRouter();
  const [presentToast] = useIonToast();
  const { id } = useParams();
  const [updateNews, { isLoading: isUpdating }] = useUpdateNewsMutation();
  const { data: newsResponse, isLoading: isLoadingNews } = useGetNewsOneQuery(
    { id },
    { skip: !id }
  );
  const handleSubmit = async (data) => {
    if (!id) return;
    try {
      await updateNews({ id, ...data }).unwrap();
      presentToast({
        message: t2("Vest je uspe큄no a탑urirana"),
        duration: 2e3,
        color: "success"
      });
      router.push("".concat(urlPrefix, "/podesavanja/vesti"));
    } catch (error) {
      presentToast({
        message: t2("Gre큄ka pri a탑uriranju vesti"),
        duration: 3e3,
        color: "danger"
      });
    }
  };
  if (isLoadingNews) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMainPage, { title: t2("U훾itavanje..."), hasBackButton: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-text-center ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}) }) });
  }
  if (!(newsResponse == null ? void 0 : newsResponse.data)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMainPage, { title: t2("Gre큄ka"), hasBackButton: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-text-center ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("Vest nije prona휃ena") }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMainPage, { title: t2("Izmeni vest"), hasBackButton: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    NewsForm,
    {
      news: newsResponse.data,
      onSubmit: handleSubmit,
      isLoading: isUpdating,
      isEdit: true
    }
  ) });
}
const LocationWorkingTimePage = reactExports.lazy(() => __vitePreload(() => import("./LocationWorkingTimePage-CLzoQKU8.js"), true ? __vite__mapDeps([11,1,2,3,4,5,6,7,8,9]) : void 0));
function LocationWorkingTimePageWrapper() {
  const { t: t2 } = useTranslation();
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Radno vreme") }),
      hasBackButton: true,
      footer: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          expand: "block",
          onClick: () => setIsModalOpen(true),
          className: "flex items-center gap-1",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline }),
            t2("Dodaj radno vreme")
          ]
        }
      ) }) }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        LocationWorkingTimePage,
        {
          isModalOpen,
          setIsModalOpen
        }
      )
    }
  );
}
const LocationEditPage = reactExports.lazy(() => __vitePreload(() => import("./LocationEditPage-v87AmeK2.js"), true ? __vite__mapDeps([12,1,2,3,4,5,6,7,8,13,9]) : void 0));
function LocationEditDataPageWrapper() {
  const { t: t2 } = useTranslation();
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-left", children: t2("Izmeni podatke lokacije") }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        LocationEditPage,
        {
          isModalOpen,
          setIsModalOpen
        }
      )
    }
  );
}
const LocationWorkersPage = reactExports.lazy(() => __vitePreload(() => import("./LocationWorkersPage-BnHlXwhR.js"), true ? __vite__mapDeps([14,1,2,3,4,5,6,7,8,9]) : void 0));
function LocationWorkersPageWrapper() {
  const { t: t2 } = useTranslation();
  const history = useHistory();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Radnici") }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        LocationWorkersPage,
        {
          locationSlug: activeLocation,
          onCreate: () => history.push("/zakazivanje/podesavanja/radnici/novi"),
          onEdit: (worker) => history.push("/zakazivanje/podesavanja/radnici/edit/".concat(worker.id))
        }
      )
    }
  );
}
const LocationSettingsPage = reactExports.lazy(() => __vitePreload(() => import("./LocationSettingsPage-1DBKXZI1.js"), true ? __vite__mapDeps([15,1,2,3,4,5,6,13,7,8,9]) : void 0));
function LocationSettingsPageWrapper() {
  const { t: t2 } = useTranslation();
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Pode큄avanja lokacije") }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        LocationSettingsPage,
        {
          isModalOpen,
          setIsModalOpen
        }
      )
    }
  );
}
const ServicesPage = reactExports.lazy(() => __vitePreload(() => import("./ServicesPage-ZWdKQ5N4.js"), true ? __vite__mapDeps([16,1,2,3,4,5,6,7,8,9]) : void 0));
function ServicesPageWrapper() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Usluge") }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ServicesPage, {})
    }
  );
}
const ServiceGroupEditPage = reactExports.lazy(() => __vitePreload(() => import("./ServiceGroupEditPage-DI-UwQEs.js"), true ? __vite__mapDeps([17,1,2,3,4,5,6,7,8,9]) : void 0));
function ServiceGroupEditPageWrapper() {
  const { t: t2 } = useTranslation();
  const { serviceGroupId } = useParams();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Uredi grupu usluga") }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ServiceGroupEditPage, { serviceGroupId: parseInt(serviceGroupId) })
    }
  );
}
const ServiceEditPage = reactExports.lazy(() => __vitePreload(() => import("./ServiceEditPage-CUbold2D.js"), true ? __vite__mapDeps([18,1,2,3,4,5,6,7,8,9]) : void 0));
function ServiceEditPageWrapper() {
  const { t: t2 } = useTranslation();
  const { serviceId } = useParams();
  const {
    data: serviceGroupsResponse,
    isLoading,
    error
  } = useGetFeServiceGroupsQuery({
    locationSlug: activeLocation
  });
  const serviceGroups = (serviceGroupsResponse == null ? void 0 : serviceGroupsResponse.data) || [];
  const service = serviceGroups.flatMap((sg) => sg.services).find((s) => s.id === parseInt(serviceId));
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      LayoutMainPage,
      {
        headerClasses: mainHeaderClasses,
        title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("U훾itavanje...") }),
        hasBackButton: true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-text-center ion-padding", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { name: "crescent" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("U훾itavanje...") })
        ] })
      }
    );
  }
  if (error || !service) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      LayoutMainPage,
      {
        headerClasses: mainHeaderClasses,
        title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Gre큄ka") }),
        hasBackButton: true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-text-center ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", children: t2("Gre큄ka pri u훾itavanju usluge") }) })
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: service.title }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ServiceEditPage, { service })
    }
  );
}
const serviceGroupEditApi = rzrApi.injectEndpoints({
  endpoints: (build) => ({
    updateServiceGroup: build.mutation({
      query: (data) => ({
        url: "locations/service-groups/update",
        method: "PUT",
        body: humpsExports.decamelizeKeys(data)
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.SERVICES_GROUPS]
    }),
    createServiceGroup: build.mutation({
      query: ({ locationSlug, ...data }) => ({
        url: "locations/service-groups/create",
        method: "POST",
        body: { ...humpsExports.decamelizeKeys(data), locationSlug }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.SERVICES_GROUPS]
    }),
    deleteServiceGroup: build.mutation({
      query: (id) => ({
        url: "locations/service-groups/delete/".concat(id),
        method: "DELETE"
      }),
      invalidatesTags: [TagType$1.SERVICES_GROUPS]
    })
  })
});
const {
  useUpdateServiceGroupMutation,
  useCreateServiceGroupMutation,
  useDeleteServiceGroupMutation
} = serviceGroupEditApi;
const serviceGroupEditFormSchema = create$3().shape({
  title: create$6().required(t("Naslov je obavezan")),
  slug: create$6().required(t("Slug je obavezan")),
  description: create$6().nullable().defined(),
  active: create$7().defined(),
  type: create$5().required(t("Tip je obavezan")),
  required: create$7().defined(),
  minSelected: create$5().nullable().transform((value) => isNaN(value) ? void 0 : value).defined(t("Minimalno izabrano je obavezno")),
  maxSelected: create$5().nullable().transform((value) => isNaN(value) ? void 0 : value).defined(t("Maksimalno izabrano je obavezno"))
});
const getServiceGroupEditFormFields = (serviceGroupId) => {
  const { isAdmin } = useUser();
  return [
    {
      keyName: "title",
      name: "title",
      data: {
        type: FieldType.Text,
        label: t("Naslov"),
        translation: serviceGroupId ? {
          type: "service_group",
          fieldName: "title",
          dataId: serviceGroupId
        } : void 0
      }
    },
    {
      keyName: "slug",
      name: "slug",
      data: {
        type: FieldType.Text,
        label: t("Slug")
      },
      disabled: !isAdmin
    },
    {
      keyName: "description",
      name: "description",
      data: {
        type: FieldType.TextArea,
        label: t("Opis"),
        translation: serviceGroupId ? {
          type: "service_group",
          fieldName: "description",
          dataId: serviceGroupId
        } : void 0
      }
    },
    {
      keyName: "active",
      name: "active",
      data: {
        type: FieldType.Switch,
        label: t("Aktivno")
      },
      disabled: !isAdmin
    },
    {
      keyName: "type",
      name: "type",
      data: {
        type: FieldType.Select,
        label: t("Tip"),
        options: [
          { value: "0", text: t("Salon") },
          { value: "1", text: t("Restoran") }
        ]
      }
    },
    {
      keyName: "required",
      name: "required",
      data: {
        type: FieldType.Switch,
        label: t("Obavezno")
      }
    },
    {
      keyName: "minSelected",
      name: "minSelected",
      data: {
        type: FieldType.Number,
        label: t("Minimalno izabrano")
      }
    },
    {
      keyName: "maxSelected",
      name: "maxSelected",
      data: {
        type: FieldType.Number,
        label: t("Maksimalno izabrano")
      }
    }
  ];
};
function ServiceGroupEditForm({
  serviceGroup,
  onSubmit,
  isLoading: externalLoading
}) {
  var _a2, _b2, _c2, _d2;
  const { t: t2 } = useTranslation();
  const form = useFormWithSchema(serviceGroupEditFormSchema, {
    defaultValues: {
      title: serviceGroup == null ? void 0 : serviceGroup.title,
      slug: serviceGroup == null ? void 0 : serviceGroup.slug,
      description: (serviceGroup == null ? void 0 : serviceGroup.description) || null,
      active: (_a2 = serviceGroup == null ? void 0 : serviceGroup.active) != null ? _a2 : true,
      type: typeof (serviceGroup == null ? void 0 : serviceGroup.type) === "string" ? parseInt(serviceGroup.type) : (serviceGroup == null ? void 0 : serviceGroup.type) || 0,
      required: (_b2 = serviceGroup == null ? void 0 : serviceGroup.required) != null ? _b2 : false,
      minSelected: (_c2 = serviceGroup == null ? void 0 : serviceGroup.minSelected) != null ? _c2 : null,
      maxSelected: (_d2 = serviceGroup == null ? void 0 : serviceGroup.maxSelected) != null ? _d2 : null
    }
  });
  const title = form.watch("title");
  React.useEffect(() => {
    if (title) {
      const generated = generateSlug(title);
      form.setValue("slug", generated);
    }
  }, [title]);
  const [deleteServiceGroup, deleteResponse] = useDeleteServiceGroupMutation();
  const router = useIonRouter();
  useShowNotification({
    message: t2("Podaci su uspe큄no sa훾uvani"),
    color: "success"
  });
  useShowNotification({
    message: t2("Gre큄ka pri 훾uvanju podataka"),
    color: "danger"
  });
  const [showDeleteAlert, setShowDeleteAlert] = React.useState(false);
  const formFields = getServiceGroupEditFormFields(serviceGroup == null ? void 0 : serviceGroup.id);
  const handleSubmit = (data) => {
    if (onSubmit) {
      onSubmit(data);
    }
  };
  const handleDelete = async () => {
    setShowDeleteAlert(true);
  };
  const confirmDelete = async () => {
    if (serviceGroup == null ? void 0 : serviceGroup.id) {
      await deleteServiceGroup(serviceGroup.id);
      router.goBack();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: form.handleSubmit(handleSubmit), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields: formFields, form }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-padding-top flex gap-2", children: [
      (serviceGroup == null ? void 0 : serviceGroup.id) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonButton,
          {
            type: "button",
            size: "small",
            color: "danger",
            onClick: handleDelete,
            disabled: deleteResponse.isLoading,
            fill: "clear",
            style: { minWidth: 0 },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline, slot: "icon-only" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonAlertConfirmation,
          {
            isOpen: showDeleteAlert,
            header: t2("Obri큄i grupu?"),
            message: t2("Da li ste sigurni da 탑elite da obri큄ete ovu grupu?"),
            confirmAction: confirmDelete,
            cancelAction: () => setShowDeleteAlert(false),
            onDidDismiss: () => setShowDeleteAlert(false),
            confirmTextKey: "Da",
            cancelTextKey: "Ne",
            confirmCssClass: "danger"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          type: "submit",
          expand: "block",
          disabled: externalLoading,
          color: "success",
          className: "flex-1",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "start" }),
            externalLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { name: "crescent" }) : t2("Sa훾uvaj podatke")
          ]
        }
      )
    ] }),
    externalLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-padding-top", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: t2("훻uvanje podataka...") }) })
  ] });
}
function ServiceGroupCreatePage() {
  const { t: t2 } = useTranslation();
  const [createServiceGroup, createResponse] = useCreateServiceGroupMutation();
  const router = useIonRouter();
  const handleSubmit = (data) => {
    createServiceGroup({
      ...data,
      locationSlug: activeLocation
    }).then((response) => {
      if ("data" in response) {
        router.goBack();
      }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ServiceGroupEditForm,
    {
      serviceGroup: null,
      onSubmit: handleSubmit,
      isLoading: createResponse.isLoading
    }
  );
}
function ServiceGroupCreatePageWrapper() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Nova grupa usluga") }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ServiceGroupCreatePage, {})
    }
  );
}
const serviceEditApi = rzrApi.injectEndpoints({
  endpoints: (build) => ({
    updateService: build.mutation({
      query: (data) => ({
        url: "locations/services/update",
        method: "PUT",
        body: humpsExports.decamelizeKeys(data)
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.SERVICES_GROUPS, TagType$1.SERVICES]
    }),
    createService: build.mutation({
      query: (data) => ({
        url: "locations/services/create",
        method: "POST",
        body: humpsExports.decamelizeKeys(data)
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.SERVICES_GROUPS, TagType$1.SERVICES]
    }),
    deleteService: build.mutation({
      query: (id) => ({
        url: "locations/services/delete/".concat(id),
        method: "DELETE"
      }),
      invalidatesTags: [TagType$1.SERVICES_GROUPS, TagType$1.SERVICES]
    })
  })
});
const {
  useUpdateServiceMutation,
  useCreateServiceMutation,
  useDeleteServiceMutation
} = serviceEditApi;
const serviceEditFormSchema = create$3().shape({
  groupId: create$5().required("Grupa je obavezna"),
  title: create$6().required("Naslov je obavezan"),
  description: create$6().required().nullable(),
  slug: create$6().required("Slug je obavezan"),
  active: create$7().required(),
  duration: create$5().nullable().transform((value) => isNaN(value) ? void 0 : value).defined("Trajanje je obavezno"),
  price: create$5().nullable().transform((value) => isNaN(value) ? void 0 : value).defined("Cena je obavezna"),
  currency: create$5().required("Valuta je obavezna"),
  changeRequest: create$3({
    isEnabled: create$7().required(),
    scheduledDateUtc: create$6().nullable().required()
  }).nullable()
});
const getServiceEditFormFields = (serviceId) => {
  const { isAdmin } = useUser();
  return [
    {
      keyName: "title",
      name: "title",
      data: {
        type: FieldType.Text,
        label: t("Naslov"),
        translation: serviceId ? {
          type: "service",
          fieldName: "title",
          dataId: serviceId
        } : void 0
      },
      gridSize: { size: "12" }
    },
    {
      keyName: "description",
      name: "description",
      data: {
        type: FieldType.TextArea,
        label: t("Opis"),
        translation: serviceId ? {
          type: "service",
          fieldName: "description",
          dataId: serviceId
        } : void 0
      },
      gridSize: { size: "12" }
    },
    {
      keyName: "slug",
      name: "slug",
      data: {
        type: FieldType.Text,
        label: t("Slug")
      },
      disabled: !isAdmin,
      gridSize: { size: "12" }
    },
    {
      keyName: "active",
      name: "active",
      data: {
        type: FieldType.Switch,
        label: t("Aktivno")
      },
      disabled: !isAdmin,
      gridSize: { size: "12" }
    },
    {
      keyName: "duration",
      name: "duration",
      data: {
        type: FieldType.Number,
        label: t("Trajanje (minuti)")
      }
    },
    {
      keyName: "price",
      name: "price",
      data: {
        type: FieldType.Number,
        label: t("Cena")
      }
    },
    {
      keyName: "currency",
      name: "currency",
      data: {
        type: FieldType.Select,
        label: t("Valuta"),
        options: [
          { value: "0", text: "RSD" },
          { value: "1", text: "EUR" }
        ]
      }
    },
    {
      keyName: "changeRequest",
      name: "changeRequest",
      data: {
        type: FieldType.ChangeRequest,
        label: t("Planirane promene"),
        entityId: serviceId,
        entityType: "service"
      },
      visible: !!serviceId,
      // Only show for existing services
      gridSize: { size: "12" }
    }
  ];
};
function ServiceEditForm({
  service,
  onSubmit,
  isLoading: externalLoading
}) {
  var _a2, _b2, _c2;
  const { t: t2 } = useTranslation();
  const form = useFormWithSchema(serviceEditFormSchema, {
    defaultValues: {
      groupId: service == null ? void 0 : service.groupId,
      title: service == null ? void 0 : service.title,
      description: (_a2 = service == null ? void 0 : service.description) != null ? _a2 : null,
      slug: service == null ? void 0 : service.slug,
      active: (_b2 = service == null ? void 0 : service.active) != null ? _b2 : true,
      duration: service == null ? void 0 : service.duration,
      price: service == null ? void 0 : service.price,
      currency: (_c2 = service == null ? void 0 : service.currency) != null ? _c2 : 0,
      changeRequest: null
    }
  });
  const title = form.watch("title");
  React.useEffect(() => {
    if (title) {
      const generated = generateSlug(title);
      form.setValue("slug", generated);
    }
  }, [title]);
  const [deleteService, deleteResponse] = useDeleteServiceMutation();
  const router = useIonRouter();
  useShowNotification({
    message: t2("Podaci su uspe큄no sa훾uvani"),
    color: "success"
  });
  useShowNotification({
    message: t2("Gre큄ka pri 훾uvanju podataka"),
    color: "danger"
  });
  const [showDeleteAlert, setShowDeleteAlert] = React.useState(false);
  const formFields = getServiceEditFormFields(service == null ? void 0 : service.id);
  const handleSubmit = (data) => {
    console.log(data);
    if (onSubmit) {
      onSubmit(data);
    }
  };
  const handleDelete = async () => {
    setShowDeleteAlert(true);
  };
  const confirmDelete = async () => {
    if (service == null ? void 0 : service.id) {
      deleteService(service.id).then((response) => {
        if ("data" in response) {
          router.goBack();
        }
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: form.handleSubmit(handleSubmit), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields: formFields, form }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-padding-top flex gap-2", children: [
      (service == null ? void 0 : service.id) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonButton,
          {
            type: "button",
            size: "small",
            color: "danger",
            onClick: handleDelete,
            disabled: deleteResponse.isLoading,
            fill: "clear",
            style: { minWidth: 0 },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline, slot: "icon-only" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonAlertConfirmation,
          {
            isOpen: showDeleteAlert,
            header: t2("Obri큄i uslugu?"),
            message: t2("Da li ste sigurni da 탑elite da obri큄ete ovu uslugu?"),
            confirmAction: confirmDelete,
            cancelAction: () => setShowDeleteAlert(false),
            onDidDismiss: () => setShowDeleteAlert(false),
            confirmTextKey: "Da",
            cancelTextKey: "Ne",
            confirmCssClass: "danger"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          type: "submit",
          expand: "block",
          style: { flexGrow: 1 },
          disabled: externalLoading,
          color: "success",
          className: "flex-1",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "start" }),
            externalLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { name: "crescent" }) : t2("Sa훾uvaj podatke")
          ]
        }
      )
    ] })
  ] });
}
function ServiceCreatePage({ groupId }) {
  const { t: t2 } = useTranslation();
  const [createService, createResponse] = useCreateServiceMutation();
  const router = useIonRouter();
  const handleSubmit = (data) => {
    createService(data).then((response) => {
      if ("data" in response) {
        router.goBack();
      }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ServiceEditForm,
    {
      service: {
        groupId
      },
      onSubmit: handleSubmit,
      isLoading: createResponse.isLoading
    }
  );
}
function ServiceCreatePageWrapper() {
  const { t: t2 } = useTranslation();
  const { groupId } = useParams();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Nova usluga") }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ServiceCreatePage, { groupId: parseInt(groupId, 10) })
    }
  );
}
const LocationWorkerCreatePage = reactExports.lazy(
  () => __vitePreload(() => import("./LocationWorkerCreatePage-dPw7zkh5.js"), true ? __vite__mapDeps([19,1,2,3,4,5,6,7,8,9]) : void 0)
);
function LocationWorkerCreatePageWrapper() {
  const { t: t2 } = useTranslation();
  const locationSlug = activeLocation;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Novi radnik") }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(LocationWorkerCreatePage, { locationSlug })
    }
  );
}
const workerEditFormSchema = create$3().shape({
  firstName: create$6().required(t("Ime je obavezno")),
  lastName: create$6().required(t("Prezime je obavezno")),
  description: create$6().nullable().defined(),
  userId: create$5().nullable().defined(),
  active: create$7().defined(),
  avatar: create$2().nullable().defined()
});
const getWorkerEditFormFields = (users, workerId, initialValues, onAvatarUploadSuccess) => {
  var _a2;
  return [
    {
      keyName: "firstName",
      name: "firstName",
      data: {
        type: FieldType.Text,
        label: t("Ime"),
        translation: workerId ? {
          type: "location_worker",
          fieldName: "first_name",
          dataId: workerId
        } : void 0
      }
    },
    {
      keyName: "lastName",
      name: "lastName",
      data: {
        type: FieldType.Text,
        label: t("Prezime")
      }
    },
    {
      keyName: "description",
      name: "description",
      data: {
        type: FieldType.TextArea,
        label: t("Opis"),
        translation: workerId ? {
          type: "location_worker",
          fieldName: "description",
          dataId: workerId
        } : void 0
      }
    },
    {
      keyName: "userId",
      name: "userId",
      data: {
        type: FieldType.Autocomplete,
        // async search handled in DynamicForm
        label: t("Korisnik (email)"),
        options: users.map((user) => ({
          text: user.email,
          value: user.id.toString()
        }))
      }
    },
    {
      keyName: "avatar",
      name: "avatar",
      data: {
        type: FieldType.GalleryArea,
        label: t("Slika radnika"),
        oneImage: true,
        maxPhotos: 1,
        photos: ((_a2 = initialValues == null ? void 0 : initialValues.avatar) == null ? void 0 : _a2.map((photo) => ({
          id: photo.id,
          url: photo.url,
          name: photo.url.split("/").pop() || "avatar",
          index: 0
        }))) || [],
        cropAspectRatio: {
          width: 1,
          height: 1
        },
        uploadUrl: "rzr/locations/worker/".concat(workerId, "/avatar"),
        deleteUrl: "rzr/locations/worker/".concat(workerId, "/avatar"),
        uploadBehavior: "onSave",
        onUploadSuccess: (photo) => {
          onAvatarUploadSuccess == null ? void 0 : onAvatarUploadSuccess();
        },
        onUploadError: (error) => {
          console.error("Avatar upload error:", error);
        },
        onDeleteSuccess: (photoId) => {
          onAvatarUploadSuccess == null ? void 0 : onAvatarUploadSuccess();
        },
        onDeleteError: (error) => {
          console.error("Avatar delete error:", error);
        }
      }
    },
    {
      keyName: "active",
      name: "active",
      data: {
        type: FieldType.Switch,
        label: t("Aktivan")
      }
    }
  ];
};
const userApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    userSearch: builder.query({
      query: (params) => ({
        url: "users/list",
        method: "GET",
        params
      }),
      transformResponse: transformPaginationResponseToCamelCase
    })
  })
});
const { useUserSearchQuery } = userApi;
const WorkerForm = ({
  initialValues = {},
  onSubmit,
  onDelete,
  isEdit = false,
  loading = false,
  onAvatarUploadSuccess
}) => {
  var _a2;
  const { t: t2 } = useTranslation();
  const form = useFormWithSchema(workerEditFormSchema, {
    defaultValues: initialValues
  });
  const { data: userData } = useUserSearchQuery({});
  const fields = getWorkerEditFormFields(
    (_a2 = userData == null ? void 0 : userData.data) != null ? _a2 : [],
    initialValues == null ? void 0 : initialValues.id,
    initialValues,
    onAvatarUploadSuccess
    // Pass callback for avatar upload success
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: form.handleSubmit(onSubmit), className: "p-0", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields, form }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormActionButtons,
      {
        onSave: form.handleSubmit(onSubmit),
        isSaving: loading,
        onDelete,
        isDeleting: loading,
        showDelete: isEdit,
        deleteConfirmationProps: {
          header: t2("Obri큄i radnika?"),
          message: t2("Da li ste sigurni da 탑elite da obri큄ete ovog radnika?")
        }
      }
    )
  ] });
};
function WorkerServiceManagement({
  worker,
  locationSlug
}) {
  const { t: t2 } = useTranslation();
  const [workerServices, setWorkerServices] = reactExports.useState(/* @__PURE__ */ new Map());
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [isSyncedService, setIsSyncedService] = reactExports.useState(worker.isSyncedService);
  const [updateWorker, { isLoading: isUpdating }] = useUpdateWorkerMutation();
  const [storeWorkerService] = useStoreWorkerServiceMutation();
  const [updateWorkerService] = useUpdateWorkerServiceMutation();
  const [deleteWorkerService] = useDeleteWorkerServiceMutation();
  const {
    data: serviceGroupsResponse,
    isLoading: isLoadingServices,
    error
  } = useGetFeServiceGroupsQuery({
    locationSlug
  });
  const {
    data: workerServicesResponse,
    isLoading: isLoadingWorkerServices,
    error: workerServicesError
  } = useGetWorkerServicesQuery({
    locationSlug,
    workerId: worker.id
  });
  const serviceGroups = (serviceGroupsResponse == null ? void 0 : serviceGroupsResponse.data) || [];
  reactExports.useEffect(() => {
    if (workerServicesResponse == null ? void 0 : workerServicesResponse.data) {
      const servicesMap = /* @__PURE__ */ new Map();
      workerServicesResponse.data.forEach(
        (workerService) => {
          servicesMap.set(workerService.serviceId, {
            serviceId: workerService.serviceId,
            price: workerService.price,
            duration: workerService.duration,
            active: workerService.active,
            useDefaultPrice: workerService.price === null || workerService.price === void 0,
            useDefaultDuration: workerService.duration === null || workerService.duration === void 0
          });
        }
      );
      setWorkerServices(servicesMap);
    }
  }, [workerServicesResponse]);
  reactExports.useEffect(() => {
    setIsSyncedService(worker.isSyncedService);
  }, [worker.isSyncedService]);
  const handleServiceToggle = (service, checked) => {
    const newServices = new Map(workerServices);
    if (checked) {
      newServices.set(service.id, {
        serviceId: service.id,
        price: service.price,
        duration: service.duration,
        active: true,
        useDefaultPrice: true,
        useDefaultDuration: true
      });
    } else {
      newServices.delete(service.id);
    }
    setWorkerServices(newServices);
  };
  const handlePriceChange = (serviceId, price) => {
    const newServices = new Map(workerServices);
    const service = newServices.get(serviceId);
    if (service) {
      newServices.set(serviceId, { ...service, price });
    }
    setWorkerServices(newServices);
  };
  const handleDurationChange = (serviceId, duration) => {
    const newServices = new Map(workerServices);
    const service = newServices.get(serviceId);
    if (service) {
      newServices.set(serviceId, { ...service, duration });
    }
    setWorkerServices(newServices);
  };
  const handleUseDefaultPriceToggle = (serviceId, useDefault) => {
    const newServices = new Map(workerServices);
    const service = newServices.get(serviceId);
    if (service) {
      newServices.set(serviceId, {
        ...service,
        useDefaultPrice: useDefault,
        price: useDefault ? void 0 : service.price
      });
    }
    setWorkerServices(newServices);
  };
  const handleUseDefaultDurationToggle = (serviceId, useDefault) => {
    const newServices = new Map(workerServices);
    const service = newServices.get(serviceId);
    if (service) {
      newServices.set(serviceId, {
        ...service,
        useDefaultDuration: useDefault,
        duration: useDefault ? void 0 : service.duration
      });
    }
    setWorkerServices(newServices);
  };
  const handleOnFocus = (e) => {
    var _a2;
    (_a2 = e.nativeEvent.target) == null ? void 0 : _a2.select();
  };
  const handleSyncedServiceToggle = async (checked) => {
    setIsSyncedService(checked);
    try {
      await updateWorker({
        id: worker.id,
        locationSlug,
        isSyncedService: checked
      }).unwrap();
      if (checked) {
        setWorkerServices(/* @__PURE__ */ new Map());
      } else {
        const servicesMap = /* @__PURE__ */ new Map();
        serviceGroups.forEach((group) => {
          group.services.forEach((service) => {
            servicesMap.set(service.id, {
              serviceId: service.id,
              price: service.price,
              duration: service.duration,
              active: true,
              useDefaultPrice: true,
              useDefaultDuration: true
            });
          });
        });
        setWorkerServices(servicesMap);
      }
    } catch (error2) {
      console.error("Error updating worker:", error2);
      setIsSyncedService(!checked);
    }
  };
  reactExports.useEffect(() => {
    if (isSyncedService && (workerServicesResponse == null ? void 0 : workerServicesResponse.data)) {
      const servicesMap = /* @__PURE__ */ new Map();
      workerServicesResponse.data.forEach(
        (workerService) => {
          servicesMap.set(workerService.serviceId, {
            serviceId: workerService.serviceId,
            price: workerService.price,
            duration: workerService.duration,
            active: workerService.active,
            useDefaultPrice: workerService.price === null || workerService.price === void 0,
            useDefaultDuration: workerService.duration === null || workerService.duration === void 0
          });
        }
      );
      setWorkerServices(servicesMap);
    }
  }, [isSyncedService, workerServicesResponse]);
  const handleSave = async () => {
    setIsLoading(true);
    try {
      const locationId = 1;
      const servicesToSave = Array.from(workerServices.entries()).map(
        ([serviceId, serviceData]) => ({
          serviceId,
          locationId,
          price: serviceData.useDefaultPrice ? void 0 : serviceData.price,
          duration: serviceData.useDefaultDuration ? void 0 : serviceData.duration,
          sortOrder: void 0,
          // Add sortOrder field
          active: serviceData.active
        })
      );
      const bulkPayload = {
        locationSlug,
        workerId: worker.id,
        services: servicesToSave
      };
      try {
        const result = await storeWorkerService(bulkPayload).unwrap();
        console.log("Worker services saved successfully:", result);
      } catch (error2) {
        console.error("Error saving worker services:", error2);
      }
    } catch (error2) {
      console.error("Error saving worker services:", error2);
    } finally {
      setIsLoading(false);
    }
  };
  if (isLoadingServices) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center p-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}) });
  }
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center p-8 text-red-500", children: t2("Gre큄ka pri u훾itavanju usluga.") });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCard, { className: "mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonToggle,
        {
          checked: isSyncedService,
          onIonChange: (e) => handleSyncedServiceToggle(e.detail.checked),
          disabled: isUpdating
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("Podrazumevani svi servisi") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2(
          "Kada je stiklirano, radnik koristi sve servise sa default cenama i trajanjima"
        ) })
      ] })
    ] }) }) }),
    serviceGroups.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonCard, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardContent, { className: "text-center p-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: t2("Nema usluga za prikaz.") }) }) }) : isSyncedService ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonCard, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { className: "text-center p-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonIcon,
        {
          icon: checkmarkCircleOutline,
          className: "text-4xl text-green-500 mb-4"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-medium", children: t2("Radnik koristi sve servise sa default cenama") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm mt-2", children: t2(
          'Odstikliraj "Podrazumevani svi servisi" da bi prilagodio servise'
        ) })
      ] })
    ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      serviceGroups.map((group) => /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { className: "mb-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardTitle, { children: group.title }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonList, { children: group.services.map((service) => {
          var _a2, _b2;
          const isSelected = workerServices.has(service.id);
          const workerService = workerServices.get(service.id);
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonItem,
              {
                button: true,
                onClick: () => handleServiceToggle(service, !isSelected),
                className: "ion-no-padding",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    IonCheckbox,
                    {
                      slot: "start",
                      checked: isSelected,
                      onIonChange: (e) => {
                        e.stopPropagation();
                        handleServiceToggle(service, e.detail.checked);
                      }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium", children: service.title }),
                    service.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 mt-1", children: service.description }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-gray-400 mt-1", children: [
                      service.price,
                      " RSD  ",
                      service.duration,
                      " min"
                    ] })
                  ] })
                ]
              }
            ),
            isSelected && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "py-2 border-b border-gray-200", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3 mb-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonCheckbox,
                  {
                    checked: (_a2 = workerService == null ? void 0 : workerService.useDefaultPrice) != null ? _a2 : true,
                    onIonChange: (e) => {
                      handleUseDefaultPriceToggle(
                        service.id,
                        e.detail.checked
                      );
                    },
                    labelPlacement: "end",
                    slot: "end",
                    color: "warning",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { className: "text-sm", children: t2("Osnovna cena") })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonCheckbox,
                  {
                    checked: (_b2 = workerService == null ? void 0 : workerService.useDefaultDuration) != null ? _b2 : true,
                    onIonChange: (e) => {
                      handleUseDefaultDurationToggle(
                        service.id,
                        e.detail.checked
                      );
                    },
                    labelPlacement: "end",
                    slot: "start",
                    color: "warning",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { className: "text-sm", children: t2("Osnovno trajanje") })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
                !(workerService == null ? void 0 : workerService.useDefaultPrice) && /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "border rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonInput,
                  {
                    label: t2("Cena (RSD)"),
                    labelPlacement: "floating",
                    type: "number",
                    value: (workerService == null ? void 0 : workerService.price) || service.price,
                    onFocus: handleOnFocus,
                    onIonInput: (e) => {
                      handlePriceChange(
                        service.id,
                        Number(e.detail.value)
                      );
                    }
                  }
                ) }),
                !(workerService == null ? void 0 : workerService.useDefaultDuration) && /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "border rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonInput,
                  {
                    label: t2("Trajanje (min)"),
                    labelPlacement: "floating",
                    type: "number",
                    value: (workerService == null ? void 0 : workerService.duration) || service.duration,
                    onFocus: handleOnFocus,
                    onIonInput: (e) => {
                      handleDurationChange(
                        service.id,
                        Number(e.detail.value)
                      );
                    }
                  }
                ) })
              ] })
            ] })
          ] }, service.id);
        }) }) })
      ] }, group.id)),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormActionButtons,
        {
          onSave: handleSave,
          isSaving: isLoading,
          saveButtonProps: {
            children: t2("Sa훾uvaj usluge"),
            expand: "block"
          }
        }
      )
    ] })
  ] });
}
const convertProductPhotoToUploadPhoto = (productPhoto) => ({
  url: productPhoto.path,
  id: productPhoto.id
});
const convertProductPhotosToUploadPhotos = (productPhotos) => {
  if (Array.isArray(productPhotos)) {
    return productPhotos.map(convertProductPhotoToUploadPhoto);
  }
  return [convertProductPhotoToUploadPhoto(productPhotos)];
};
const LocationWorkerEditPage = ({
  locationSlug,
  worker
}) => {
  const { t: t2 } = useTranslation();
  const history = useHistory();
  const [activeTab, setActiveTab] = reactExports.useState("details");
  const [updateWorker, { isLoading, isSuccess, isError }] = useUpdateWorkerMutation();
  const [deleteWorker, { isLoading: isDeleting }] = useDeleteWorkerMutation();
  const { refetch } = useGetFeWorkerQuery({
    workerId: worker.id,
    locationSlug
  });
  const handleSubmit = async (data) => {
    await updateWorker({ ...data, id: worker.id, locationSlug }).unwrap();
  };
  const handleDelete = async () => {
    await deleteWorker({ id: worker.id, locationSlug }).unwrap();
    history.goBack();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonSegment,
      {
        value: activeTab,
        onIonChange: (e) => setActiveTab(e.detail.value),
        className: "mb-4",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonSegmentButton, { value: "details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: personOutline }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Podaci") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonSegmentButton, { value: "services", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: settingsOutline }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Usluge") })
          ] })
        ]
      }
    ),
    activeTab === "details" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      WorkerForm,
      {
        initialValues: {
          ...worker,
          avatar: convertProductPhotosToUploadPhotos(worker.avatar || [])
        },
        onSubmit: handleSubmit,
        onDelete: handleDelete,
        isEdit: true,
        loading: isLoading || isDeleting,
        onAvatarUploadSuccess: () => {
          refetch();
        }
      }
    ),
    activeTab === "services" && /* @__PURE__ */ jsxRuntimeExports.jsx(WorkerServiceManagement, { worker, locationSlug }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NotificationToast,
      {
        isOpen: isSuccess || isError,
        onDidDismiss: () => {
        },
        message: isSuccess ? "Radnik je uspe큄no sa훾uvan" : "Gre큄ka pri 훾uvanju radnika",
        type: isSuccess ? "success" : "error"
      }
    )
  ] });
};
function LocationWorkerEditPageWrapper() {
  const { t: t2 } = useTranslation();
  const locationSlug = activeLocation;
  const { workerId } = useParams();
  const {
    data: workerResponse,
    isLoading,
    isError
  } = useGetFeWorkerQuery({
    workerId: parseInt(workerId),
    locationSlug
  });
  const worker = workerResponse == null ? void 0 : workerResponse.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Izmeni radnika") }),
      hasBackButton: true,
      children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center p-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}) }) : isError || !worker ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center p-8 text-red-500", children: t2("Gre큄ka pri u훾itavanju radnika.") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(LocationWorkerEditPage, { locationSlug, worker })
    }
  );
}
const promoCodeApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getAllPromoCodes: builder.query({
      query: ({ locationSlug }) => ({
        url: "locations/promo-codes/all",
        method: "GET",
        params: { locationSlug }
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [TagType$1.LOCATION_PROMO_CODES]
    }),
    createPromoCode: builder.mutation({
      query: ({ locationSlug, ...body }) => ({
        url: "locations/promo-codes/create",
        method: "POST",
        body: {
          ...humpsExports.decamelizeKeys(body),
          locationSlug
        }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_PROMO_CODES]
    }),
    updatePromoCode: builder.mutation({
      query: ({ id, locationSlug, ...body }) => ({
        url: "locations/promo-codes/update",
        method: "POST",
        body: {
          ...humpsExports.decamelizeKeys(body),
          id,
          locationSlug
        }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_PROMO_CODES]
    }),
    deletePromoCode: builder.mutation({
      query: (body) => ({
        url: "locations/promo-codes/delete",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_PROMO_CODES]
    })
  })
});
const {
  useGetAllPromoCodesQuery,
  useCreatePromoCodeMutation,
  useUpdatePromoCodeMutation,
  useDeletePromoCodeMutation
} = promoCodeApi;
function LocationPromoCodesPage({
  locationSlug,
  onCreate,
  onEdit
}) {
  var _a2;
  const { t: t2 } = useTranslation();
  const { data, isLoading, isError } = useGetAllPromoCodesQuery({
    locationSlug
  });
  const getStatusBadge = (promoCode) => {
    const now = /* @__PURE__ */ new Date();
    const activateAt = new Date(promoCode.activateAtUtc);
    const deactivateAt = new Date(promoCode.deactivateAtUtc);
    if (!promoCode.isActive) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(IonBadge, { color: "medium", children: "Neaktivan" });
    }
    if (now < activateAt) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(IonBadge, { color: "warning", children: "훻eka" });
    }
    if (now > deactivateAt) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(IonBadge, { color: "danger", children: "Istekao" });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IonBadge, { color: "success", children: "Aktivan" });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardTitle, { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: giftOutline }),
        t2("Promo kodovi")
      ] }),
      onCreate && /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButton, { onClick: onCreate, size: "small", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline, slot: "start" }),
        t2("Novi kod")
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardContent, { className: "ion-no-padding", children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center p-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}) }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center p-8 text-red-500", children: t2("Gre큄ka pri u훾itavanju promo kodova.") }) : !((_a2 = data == null ? void 0 : data.data) == null ? void 0 : _a2.length) ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center p-8 text-gray-500", children: t2("Nema promo kodova za ovu lokaciju.") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(IonList, { children: data.data.map((promoCode) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonItem,
      {
        button: true,
        onClick: () => onEdit == null ? void 0 : onEdit(promoCode),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { className: "flex flex-col ion-no-padding", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: promoCode.name }),
            getStatusBadge(promoCode)
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-gray-600", children: [
            promoCode.discountValue,
            promoCode.inPercent ? "%" : " RSD",
            " popusta",
            " - "
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-gray-500", children: [
            t2("Aktivno od"),
            ":",
            " ",
            format(promoCode.activateAtUtc, "dd.MM.yyyy"),
            " -",
            " ",
            format(promoCode.deactivateAtUtc, "dd.MM.yyyy")
          ] })
        ] })
      },
      promoCode.id
    )) }) })
  ] }) });
}
function LocationPromoCodesPageWrapper() {
  const { t: t2 } = useTranslation();
  const history = useHistory();
  const locationSlug = activeLocation;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Promo kodovi") }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        LocationPromoCodesPage,
        {
          locationSlug,
          onCreate: () => history.push("/zakazivanje/podesavanja/promo-kodovi/novo"),
          onEdit: (promoCode) => history.push(
            "/zakazivanje/podesavanja/promo-kodovi/edit/".concat(promoCode.id)
          )
        }
      )
    }
  );
}
const promoCodeFormSchema = create$3().shape({
  name: create$6().required(t("Naziv je obavezan")).min(3, t("Naziv mora imati najmanje 3 karaktera")).transform((value) => {
    if (!value) return value;
    let cleanValue = value.replace(/#/g, "");
    return cleanValue + "#";
  }).test(
    "single-hash-at-end",
    t("Naziv mora imati ta훾no jedan # na kraju"),
    (value) => {
      if (!value) return false;
      const hashCount = (value.match(/#/g) || []).length;
      return hashCount === 1 && value.endsWith("#");
    }
  ),
  discountValue: create$5().transform((value) => isNaN(value) ? void 0 : value).required(t("Vrednost popusta je obavezna")).min(0, t("Vrednost popusta mora biti ve훶a od 0")).when("inPercent", {
    is: true,
    then: (schema2) => schema2.max(100, t("Procenat popusta ne mo탑e biti ve훶i od 100")),
    otherwise: (schema2) => schema2
  }),
  inPercent: create$7().required(),
  activateAtUtc: create$6().required(t("Datum aktivacije je obavezan")),
  deactivateAtUtc: create$6().required(t("Datum deaktivacije je obavezan")),
  isActive: create$7().required()
});
const getPromoCodeFormFields = () => [
  {
    keyName: "name",
    name: "name",
    data: {
      type: FieldType.Text,
      label: t("Naziv")
    }
  },
  {
    keyName: "discountValue",
    name: "discountValue",
    data: {
      type: FieldType.Number,
      label: t("Vrednost popusta")
    }
  },
  {
    keyName: "inPercent",
    name: "inPercent",
    data: {
      type: FieldType.Switch,
      label: t("U procentima")
    }
  },
  {
    keyName: "activateAtUtc",
    name: "activateAtUtc",
    data: {
      type: FieldType.DateTime,
      label: t("Aktivno od")
    }
  },
  {
    keyName: "deactivateAtUtc",
    name: "deactivateAtUtc",
    data: {
      type: FieldType.DateTime,
      label: t("Aktivno do")
    }
  },
  {
    keyName: "isActive",
    name: "isActive",
    data: {
      type: FieldType.Switch,
      label: t("Aktivan")
    }
  }
];
const PromoCodeForm = ({
  initialValues = {
    isActive: true,
    inPercent: true
  },
  onSubmit,
  onDelete,
  isEdit = false,
  loading = false
}) => {
  const { t: t2 } = useTranslation();
  const form = useFormWithSchema(promoCodeFormSchema, {
    defaultValues: initialValues
  });
  const fields = getPromoCodeFormFields();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: form.handleSubmit(onSubmit), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields, form }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 mt-4 justify-center", children: [
      isEdit && onDelete && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonAlertConfirmationBtn,
        {
          color: "danger",
          alertProps: {
            header: t2("Da li ste sigurni?"),
            message: t2("Obri큄i promo kod")
          },
          onConfirm: onDelete,
          disabled: loading,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline }),
            t2("Obri큄i")
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          type: "submit",
          expand: "block",
          disabled: loading,
          className: "w-full",
          children: isEdit ? t2("Sa훾uvaj") : t2("Kreiraj")
        }
      )
    ] })
  ] });
};
const LocationPromoCodeCreatePage = ({ locationSlug }) => {
  const { t: t2 } = useTranslation();
  const history = useHistory();
  const [createPromoCode, { isLoading }] = useCreatePromoCodeMutation();
  const handleSubmit = async (data) => {
    try {
      await createPromoCode({ ...data, locationSlug }).unwrap();
      history.goBack();
    } catch (e) {
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PromoCodeForm, { onSubmit: handleSubmit, loading: isLoading });
};
function LocationPromoCodeCreatePageWrapper() {
  const { t: t2 } = useTranslation();
  const locationSlug = activeLocation;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Novi promo kod") }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(LocationPromoCodeCreatePage, { locationSlug })
    }
  );
}
const LocationPromoCodeEditPage = ({
  locationSlug,
  promoCode
}) => {
  const { t: t2 } = useTranslation();
  const history = useHistory();
  const [updatePromoCode, { isLoading }] = useUpdatePromoCodeMutation();
  const [deletePromoCode, { isLoading: isDeleting }] = useDeletePromoCodeMutation();
  const handleSubmit = async (data) => {
    try {
      await updatePromoCode({
        ...data,
        id: promoCode.id,
        locationSlug
      }).unwrap();
      history.goBack();
    } catch (e) {
    }
  };
  const handleDelete = async () => {
    try {
      await deletePromoCode({ id: promoCode.id, locationSlug }).unwrap();
      history.goBack();
    } catch (e) {
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    PromoCodeForm,
    {
      initialValues: promoCode,
      onSubmit: handleSubmit,
      onDelete: handleDelete,
      isEdit: true,
      loading: isLoading || isDeleting
    }
  );
};
function LocationPromoCodeEditPageWrapper() {
  var _a2;
  const { t: t2 } = useTranslation();
  const locationSlug = activeLocation;
  const { promoCodeId } = useParams();
  const { data, isLoading, isError } = useGetAllPromoCodesQuery({
    locationSlug
  });
  const promoCode = (_a2 = data == null ? void 0 : data.data) == null ? void 0 : _a2.find(
    (p) => String(p.id) === String(promoCodeId)
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: t2("Izmeni promo kod") }),
      hasBackButton: true,
      children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center p-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}) }) : isError || !promoCode ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center p-8 text-red-500", children: t2("Gre큄ka pri u훾itavanju promo koda.") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        LocationPromoCodeEditPage,
        {
          locationSlug,
          promoCode
        }
      )
    }
  );
}
function Routes() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRouterOutlet, { id: "main", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "".concat(urlPrefix, "/t"), component: MainTabs }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/r/:reservationHash"),
        component: ConfirmReservationPage,
        exact: true
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Route,
      {
        path: "".concat(urlPrefix, "/zakazi-novo"),
        component: CreateAppointmentPage
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/public-profile/:clientId"),
        component: PublicProfilePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/vesti"),
        component: NewsListPage,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/vesti/novo"),
        component: NewsCreatePage,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/vesti/edit/:id"),
        component: NewsEditPage,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/radno-vreme"),
        component: LocationWorkingTimePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/podaci"),
        component: LocationEditDataPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/generalno"),
        component: LocationSettingsPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/radnici"),
        component: LocationWorkersPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/radnici/novi"),
        component: LocationWorkerCreatePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/radnici/edit/:workerId"),
        component: LocationWorkerEditPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/usluge"),
        component: ServicesPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/usluge/groups/:serviceGroupId"),
        component: ServiceGroupEditPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/usluge/services/:serviceId"),
        component: ServiceEditPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/usluge/novo"),
        component: ServiceGroupCreatePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/usluge/services/novo/:groupId"),
        component: ServiceCreatePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/promo-kodovi"),
        component: LocationPromoCodesPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/promo-kodovi/novo"),
        component: LocationPromoCodeCreatePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/promo-kodovi/edit/:promoCodeId"),
        component: LocationPromoCodeEditPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", exact: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Redirect, { to: "".concat(urlPrefix, "/t") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "".concat(urlPrefix), exact: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Redirect, { to: "".concat(urlPrefix, "/t") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { component: PageNotFound, path: "/404" })
  ] });
}
const useRzrPingHandler = () => {
  const dispatch = useAppDispatch();
  const handleRzrChanges = reactExports.useCallback(
    (changes) => {
      Object.entries(changes).forEach(([type, change]) => {
        if (change.hasChanges) {
          switch (type) {
            case PingType.RESERVATIONS:
              console.log("invalidating reservations");
              dispatch(rzrApi.util.invalidateTags([TagType$1.RESERVATION]));
              break;
            case PingType.WORKERS:
              dispatch(rzrApi.util.invalidateTags([TagType$1.LOCATION_WORKERS]));
              break;
            case PingType.SERVICES:
              dispatch(rzrApi.util.invalidateTags([TagType$1.SERVICES]));
              break;
            case PingType.WORKING_HOURS:
              dispatch(
                rzrApi.util.invalidateTags([TagType$1.LOCATION_WORKING_HOURS])
              );
              break;
            case PingType.NOTIFICATIONS:
              dispatch(rzrApi.util.invalidateTags([TagType$1.USER_NOTIFICATIONS]));
              break;
          }
        }
      });
    },
    [dispatch]
  );
  return { handleRzrChanges };
};
function Ping() {
  const pingOptions = reactExports.useMemo(() => ({ autoStart: true }), []);
  const { handleRzrChanges } = useRzrPingHandler();
  usePing(
    [PingType.RESERVATIONS, PingType.NOTIFICATIONS],
    // , PingType.WORKERS, PingType.SERVICES, PingType.WORKING_HOURS
    { locationSlug: activeLocation },
    handleRzrChanges,
    pingOptions
  );
  return null;
}
const Ping$1 = reactExports.memo(Ping);
function UserLoginPageWrapper() {
  const { t: t2 } = useTranslation();
  const router = useIonRouter();
  const handleSuccessfulLogin = () => {
    router.push("".concat(urlPrefix, "/t"), "forward", "push");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonPage, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-padding text-center w-full flex justify-center items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-[100%] w-[600px] ", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ErrorBoundary$1,
    {
      fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center text-red-500", children: "Error loading login form" }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CommonLoginForm$1, { onSuccessfulLogin: handleSuccessfulLogin })
    }
  ) }) }) });
}
const Menu = reactExports.lazy(() => __vitePreload(() => import("./Menu-D0TrHqe7.js"), true ? __vite__mapDeps([20,1,2,3,4,5,6,7,8,9,21]) : void 0));
setupIonicReact({
  swipeBackEnabled: isPwa && !isIos,
  animated: !isIos
});
const urlPrefix = (_c = (_b = getInitialData("appSlug")) != null ? _b : "/zakazivanje") != null ? _c : "/zakazivanje";
const envActiveLocation = "berbernica-tanja";
const envIsPrivate = parseInt("1");
const preloadedLocationData = getInitialData(
  "locationData",
  true
);
const activeLocation = (_d = preloadedLocationData == null ? void 0 : preloadedLocationData.slug) != null ? _d : envActiveLocation;
const isPrivate = (_e = preloadedLocationData == null ? void 0 : preloadedLocationData.isPrivate) != null ? _e : envIsPrivate;
const reservationTimeInterval = (_f = preloadedLocationData == null ? void 0 : preloadedLocationData.timeSlotInterval) != null ? _f : 30;
const roundedSlotInterval = (_g = preloadedLocationData == null ? void 0 : preloadedLocationData.roundedSlotInterval) != null ? _g : 10;
const locationTimezone = (_i = (_h = preloadedLocationData == null ? void 0 : preloadedLocationData.settings) == null ? void 0 : _h.timezone) != null ? _i : "Europe/Belgrade";
setAppTimezone(locationTimezone);
function App() {
  const { userData, isAdmin, isOwnerOrWorker } = useUser();
  const dispatch = useAppDispatch$1();
  useAppFocus({
    onFocus: () => {
      var _a2;
      dispatch(
        (_a2 = rzrApi.util) == null ? void 0 : _a2.invalidateTags([
          TagType$1.USER_NOTIFICATIONS,
          { type: TagType$1.RESERVATION, id: TagId$1.LIST }
        ])
      );
    }
  });
  if (isPrivate && !isAdmin && !isOwnerOrWorker) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IonApp, { className: "select-none ".concat("dark-theme"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonReactRouter, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "".concat(urlPrefix, "/login"),
          component: UserLoginPageWrapper,
          exact: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "".concat(urlPrefix), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Redirect, { to: "".concat(urlPrefix, "/login") }) })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonApp,
    {
      className: "select-none ".concat("dark-theme"),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("swiper-container", { hidden: true }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonReactRouter, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Ping$1, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CommonModalWrappers$1, {}),
          !isWebView && isPwa && /* @__PURE__ */ jsxRuntimeExports.jsx(CommonNotificationWrapper, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonSplitPane, { contentId: "main", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Routes, {})
          ] })
        ] })
      ]
    },
    userData == null ? void 0 : userData.email
  );
}
const App$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  activeLocation,
  default: App,
  isPrivate,
  preloadedLocationData,
  reservationTimeInterval,
  roundedSlotInterval,
  urlPrefix
}, Symbol.toStringTag, { value: "Module" }));
export {
  ServiceGroupEditForm as A,
  ServiceEditForm as B,
  ConditionalComponent as C,
  DynamicForm as D,
  useCreateWorkerMutation as E,
  FieldType as F,
  fetchIonIconsList as G,
  App$1 as H,
  IonModalExtended$1 as I,
  ModalActionButtons as M,
  SwiperWrapper$1 as S,
  UserAvatar as U,
  WorkerForm as W,
  useAppDispatch as a,
  useUser as b,
  useAppSelector as c,
  isIos as d,
  urlPrefix as e,
  useClipboard as f,
  useGetWorkerClientDataQuery as g,
  activeLocation as h,
  isPwa as i,
  ClientStatistics as j,
  isWebPlatform as k,
  fromUtcHM as l,
  useGetFeWorkersQuery as m,
  useDefaultProps as n,
  useShowNotification as o,
  useFormWithSchema as p,
  photosArrayWithIdYup as q,
  useGetFeLocationQuery as r,
  preloadedLocationData as s,
  transformStandardResponseToCamelCase as t,
  useAppDispatch$1 as u,
  useGetAllWorkersQuery as v,
  useGetFeServiceGroupsQuery as w,
  useUpdateServiceGroupMutation as x,
  ShowLoading$1 as y,
  useUpdateServiceMutation as z
};
