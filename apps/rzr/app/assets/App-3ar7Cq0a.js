const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/ListIonIcons-DSrG9jQH.js","assets/vendor_react-DUHraSvm.js","assets/vendor_ionic-COxsUFYm.js","assets/vendor_ionic-D7N1wSx9.css","assets/vendor_leaflet-Lu2AnQEo.js","assets/vendor_leaflet-Bvr-Ab8i.css","assets/vendor_react-Z09ODb1v.css","assets/index-CiZrsLGn.js","assets/index-htCqLngZ.css","assets/vendor_firebase-CC6UAdG5.js","assets/HomePage-VRO4bYdN.js","assets/reservation.helpers-DRLQnio_.js","assets/NewsChyron-DIM2knsZ.js","assets/news.fe-services-Dw52PloP.js","assets/AppointmentPage-BYSqsQQ9.js","assets/appointment.constants-BtYyqQzh.js","assets/Pagination-D0n9Bkg1.js","assets/ProfilePage-BCan-p42.js","assets/client-profile.fe-services-C9snqo9c.js","assets/statistics.fe-services-BAlduTxf.js","assets/ClientDataModal-CD2cZdoZ.js","assets/NotificationPage-Cb1rYKaN.js","assets/PrepareWorkingDaysShiftsPage-HLoOub6u.js","assets/workingShift.fe-services-q28PGSw5.js","assets/OwnerHomePage-C_euHsRz.js","assets/OwnerAppointmentPage-Dev4Hdnq.js","assets/SettingsPage-BhtBHh1y.js","assets/ConfirmReservationPage-laTrRjVU.js","assets/PublicProfilePage-1t-Ehthr.js","assets/NewsListPage-I67s63Im.js","assets/NewsCreatePage-CdcLFb50.js","assets/NewsForm-pmtaAc1i.js","assets/NewsEditPage-C_aT1ZAb.js","assets/LocationWorkingTimePage-Boyv2fXR.js","assets/LocationEditPage-DznzT7Dq.js","assets/SimpleFormStepperActions-B5EYzYAt.js","assets/location-settings.data-DBZ1Yixs.js","assets/usePendingImageUploads-BU5LpMUS.js","assets/LocationWorkersPage-D01gMnhk.js","assets/LocationSettingsPage-BMw4T4BL.js","assets/ServicesPage-DAIqJ7Nv.js","assets/ServiceGroupBasicInfoStep-DbvplmHU.js","assets/ServiceGroupEditPage-COBBPTcs.js","assets/ServiceEditPage-C54pAxg6.js","assets/LocationWorkerCreatePage-CPw9lj4m.js","assets/Menu-DG78Aput.js","assets/Menu-BF-_LQ0F.css"])))=>i.map(i=>d[i]);
var _a, _b, _c, _d, _e, _f, _g, _h, _i;
import { f as IonModal, h as IonHeader, i as IonToolbar, j as IonTitle, k as IonButtons, d as IonButton, l as IonIcon, m as closeOutline, b as IonContent, n as IonSpinner, o as IonFooter, s as saveOutline, p as languageOutline, q as IonItem, r as IonInput, t as eye, u as eyeOff, v as logoGoogle, c as IonText, w as IonSelect, x as IonSelectOption, y as videocam, z as videocamOff, A as IonGrid, B as IonRow, C as IonCol, D as IonSearchbar, E as IonLabel, F as IonList, G as IonCheckbox, H as arrowUndoOutline, I as IonPage, J as createAnimation, K as useIonModal, L as useIonLoading, M as useIonAlert, N as useIonActionSheet, O as trashOutline, P as IonImg, Q as cropOutline, R as optionsOutline, S as cloudUploadOutline, T as funnelOutline, U as listCircleSharp, V as IonItemSliding, W as IonItemOptions, X as IonThumbnail, Y as IonReorder, Z as menuOutline, $ as chevronForwardOutline, a0 as IonItemOption, a1 as constructOutline, a2 as checkboxOutline, a3 as squareOutline, a4 as IonReorderGroup, a5 as checkmarkOutline, a6 as addOutline, a7 as isPlatform, a8 as icons, a9 as useIonToast, aa as IonTextarea, ab as IonDatetime, ac as IonToggle, _ as __vitePreload, ad as calendarOutline, ae as timeOutline, af as IonChip, ag as IonLoading, ah as mailOutline, ai as keyOutline, aj as useIonRouter, ak as IonToast, al as IonListHeader, am as IonSkeletonText, an as exitOutline, ao as logoApple, ap as logoAndroid, aq as IonMenuButton, ar as chevronBackOutline, as as ellipsisVertical, at as ellipsisHorizontal, au as IonRefresher, av as IonRefresherContent, aw as IonPopover, ax as IonAlert, ay as lockClosedOutline, az as logInOutline, aA as IonSegment, aB as IonSegmentButton, aC as createOutline, aD as giftOutline, aE as settingsOutline, aF as peopleOutline, aG as megaphoneOutline, aH as useIonViewWillLeave, aI as IonActionSheet, aJ as IonTabs, aK as IonRouterOutlet, aL as IonTabBar, aM as IonTabButton, aN as homeOutline, aO as alarmOutline, aP as notificationsOutline, aQ as personOutline, aR as IonAvatar, aS as checkmarkCircle, aT as removeOutline, aU as IonAccordionGroup, aV as IonAccordion, aW as IonCard, aX as IonCardHeader, aY as IonCardTitle, aZ as IonCardContent, a_ as chevronUpOutline, a$ as chevronDownOutline, b0 as IonBadge, b1 as cashOutline, b2 as calendarClearOutline, b3 as arrowBack, b4 as arrowForward, b5 as useIonViewDidLeave, b6 as checkmarkCircleOutline, b7 as refreshOutline, b8 as IonApp, b9 as IonReactRouter, ba as IonSplitPane, bb as setupIonicReact } from "./vendor_ionic-COxsUFYm.js";
import { j as jsxRuntimeExports, Z as useForm, $ as o, E as humpsExports, a0 as t, e as reactExports, a1 as create$3, a2 as create$6, R as React, a3 as Controller, a4 as yup, a5 as setLocale, a6 as lodashExports, a7 as useWatch, a8 as DraftExports, a9 as reactDraftWysiwygExports, aa as draftToHtml, ab as qr, ac as Swiper, G as createSlice, ad as l, J as combineReducers, K as configureStore, ae as c, af as SwiperSlide, ag as register, ah as V, ai as arrayMove, aj as useSensors, ak as useSensor, al as DndContext, am as closestCenter, an as SortableContext, ao as verticalListSortingStrategy, ap as TouchSensor, aq as sortableKeyboardCoordinates, ar as KeyboardSensor, as as PointerSensor, at as useSortable, au as CSS, av as parseISO, aw as formatInTimeZone, ax as toZonedTime, ay as format, az as fromZonedTime, aA as isValid, aB as useDispatch, aC as useSelector, aD as useTranslation, aE as useHistory, aF as GoogleOAuthProvider, aG as useGoogleLogin, aH as ErrorBoundary, q as Route, aI as buildExports, aJ as Redirect, aK as addDays, aL as isToday$1, aM as startOfDay, aN as addMinutes, aO as startOfMonth, aP as startOfWeek, aQ as endOfMonth, aR as subMonths, aS as addMonths, aT as isSameMonth, aU as isSameWeek, aV as isSameDay, aW as useLocation, aX as useParams, aY as create$5, aZ as create$7, a_ as create$2, a$ as useGoogleLogin$1, b0 as GoogleOAuthProvider$1, Y as ErrorBoundary$1 } from "./vendor_react-DUHraSvm.js";
import { s as sharedApi, T as TagType, a as sharedApiPrefix, U as UploadType, b as TagId, c as setShowCompleteProfileModal, d as setUser, e as setUiData, g as getImageModalData, f as closeImageModal, h as getShowLoginModal, i as getShowImageModal, j as setShowLoginModal, k as getDeviceData, l as setDeviceData, m as getUser, n as logoutAction, r as rzrApi, o as TagType$1, p as TagId$1, q as getInitialData, t as getSavedTheme, u as applyTheme } from "./index-CiZrsLGn.js";
import { i as initializeApp, g as getMessagingInWindow, a as getAnalytics, o as onMessage, b as getToken } from "./vendor_firebase-CC6UAdG5.js";
const ConditionalComponent = ({
  condition,
  render,
  elseCondition = true,
  renderElse
}) => {
  if (!!condition) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: render() });
  }
  if (elseCondition && renderElse) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderElse() });
  }
  return null;
};
var FieldType = /* @__PURE__ */ ((FieldType2) => {
  FieldType2["Text"] = "TextField";
  FieldType2["TextArea"] = "TextArea";
  FieldType2["Password"] = "Password";
  FieldType2["Number"] = "NumberField";
  FieldType2["Switch"] = "Switch";
  FieldType2["Select"] = "Select";
  FieldType2["Autocomplete"] = "Autocomplete";
  FieldType2["Checkbox"] = "Checkbox";
  FieldType2["MultiCheckbox"] = "MultiCheckbox";
  FieldType2["List"] = "List";
  FieldType2["DateTime"] = "DateTime";
  FieldType2["Date"] = "Date";
  FieldType2["Time"] = "Time";
  FieldType2["WorkingHours"] = "WorkingHours";
  FieldType2["WorkingHoursSingle"] = "WorkingHoursSingle";
  FieldType2["Callback"] = "Callback";
  FieldType2["RichEditor"] = "RichEditor";
  FieldType2["PhotoUploader"] = "PhotoUploader";
  FieldType2["GalleryArea"] = "GalleryArea";
  FieldType2["Coordinates"] = "Coordinates";
  FieldType2["IonIcon"] = "IonIcon";
  FieldType2["ChangeRequest"] = "ChangeRequest";
  FieldType2["Slug"] = "Slug";
  return FieldType2;
})(FieldType || {});
function useFormWithSchema(schema2, useFormProps) {
  return useForm({ ...useFormProps, resolver: o(schema2) });
}
const transformPaginationResponseToCamelCase = (response) => humpsExports.camelizeKeys(response.data);
const transformStandardResponseToCamelCase = (response) => humpsExports.camelizeKeys(response);
const translationsApi = sharedApi.injectEndpoints({
  endpoints: (builder) => ({
    getTranslations: builder.query({
      query: (params) => ({
        url: "translations",
        method: "GET",
        params
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType.TRANSLATIONS]
    }),
    createTranslation: builder.mutation({
      query: (body) => ({
        url: "translations",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType.TRANSLATIONS]
    })
  })
});
const { useGetTranslationsQuery, useCreateTranslationMutation } = translationsApi;
const getTranslationFormFields = (fieldType, label) => {
  const fields = [
    {
      keyName: "language",
      name: t("Jezik"),
      data: {
        type: FieldType.Select,
        label: t("Jezik"),
        options: [
          { text: t("Engleski"), value: "eng" },
          { text: t("Srpski"), value: "rs" }
        ]
      },
      gridSize: { size: "12" }
    }
  ];
  switch (fieldType) {
    case FieldType.Text:
      fields.push({
        keyName: "translationValue",
        name: t("Prevod"),
        data: {
          type: FieldType.Text,
          label
        },
        gridSize: { size: "12" },
        newRow: true
      });
      break;
    case FieldType.TextArea:
      fields.push({
        keyName: "translationValue",
        name: t("Prevod"),
        data: {
          type: FieldType.TextArea,
          label
        },
        gridSize: { size: "12" },
        newRow: true
      });
      break;
    case FieldType.RichEditor:
      fields.push({
        keyName: "translationValue",
        name: t("Prevod"),
        data: {
          type: FieldType.RichEditor,
          label
        },
        gridSize: { size: "12" },
        newRow: true
      });
      break;
  }
  return fields;
};
const LANGUAGE_MAPPING = {
  eng: "eng",
  en: "eng",
  rs: "sr"
};
function frontendToBackendLang(frontendLang) {
  return LANGUAGE_MAPPING[frontendLang] || frontendLang;
}
const schema$2 = create$3().shape({
  language: create$6().required(t("Jezik je obavezan")),
  translationValue: create$6().required(t("Prevod je obavezan"))
});
function TranslationEditor({
  isOpen,
  onClose,
  translation,
  fieldType,
  label,
  currentValue
}) {
  const [formKey, setFormKey] = reactExports.useState("");
  const [selectedLanguage, setSelectedLanguage] = reactExports.useState("eng");
  const { data: translationData, isLoading: isLoadingTranslations } = useGetTranslationsQuery({
    entityType: translation.type,
    entityId: translation.dataId
  });
  const [createTranslation, { isLoading: isCreating }] = useCreateTranslationMutation();
  const form = useFormWithSchema(schema$2, {
    defaultValues: {
      language: "eng",
      translationValue: ""
    }
  });
  const { handleSubmit, watch, setValue } = form;
  const watchedLanguage = watch("language");
  const formFields = reactExports.useMemo(
    () => getTranslationFormFields(fieldType, label),
    [fieldType, label]
  );
  const isLoading = isCreating || isLoadingTranslations;
  reactExports.useEffect(() => {
    if ((translationData == null ? void 0 : translationData.success) && translationData.data) {
      const backendLanguage = frontendToBackendLang(watchedLanguage);
      const languageData = translationData.data[backendLanguage];
      console.log(
        "languageData",
        languageData,
        backendLanguage,
        watchedLanguage
      );
      if (languageData && languageData[translation.fieldName]) {
        setValue("translationValue", languageData[translation.fieldName]);
        setFormKey(watchedLanguage);
      } else {
        setValue("translationValue", "");
        setFormKey(watchedLanguage);
      }
    }
  }, [translationData, watchedLanguage, translation.fieldName, setValue]);
  reactExports.useEffect(() => {
    if (isOpen) {
      setSelectedLanguage("eng");
      setValue("language", "eng");
    }
  }, [isOpen, setValue]);
  const handleSaveTranslation = async (formData) => {
    try {
      const backendLanguage = frontendToBackendLang(formData.language);
      const translationPayload = {
        entityType: translation.type,
        entityId: translation.dataId,
        language: backendLanguage,
        fieldName: translation.fieldName,
        fieldValue: formData.translationValue
      };
      await createTranslation(translationPayload).unwrap();
      onClose();
    } catch (error) {
      console.error("Error saving translation:", error);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonModal, { isOpen, onDidDismiss: onClose, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTitle, { children: [
        t("Prevod"),
        " - ",
        label
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: onClose, fill: "clear", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { className: "ion-padding", children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-center items-center p-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2", children: t("U훾itavanje...") })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields: formFields, form }, formKey) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 p-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { fill: "outline", onClick: onClose, disabled: isLoading, children: t("Otka탑i") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          onClick: handleSubmit(handleSaveTranslation),
          disabled: isLoading,
          className: "flex-1",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "start" }),
            isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { name: "crescent" }) : t("Sa훾uvaj prevod")
          ]
        }
      )
    ] }) }) })
  ] });
}
const TranslationEditor$1 = reactExports.memo(TranslationEditor);
function TranslationButton({
  translation,
  fieldName,
  fieldType,
  label,
  currentValue,
  buttonProps = {}
}) {
  const [showTranslationEditor, setShowTranslationEditor] = reactExports.useState(false);
  const openTranslationEditor = () => {
    setShowTranslationEditor(true);
  };
  const closeTranslationEditor = () => {
    setShowTranslationEditor(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonButton,
      {
        fill: buttonProps.fill || "clear",
        size: buttonProps.size || "small",
        slot: "end",
        onClick: openTranslationEditor,
        className: buttonProps.className,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: languageOutline })
      }
    ),
    showTranslationEditor && /* @__PURE__ */ jsxRuntimeExports.jsx(
      TranslationEditor$1,
      {
        isOpen: showTranslationEditor,
        onClose: closeTranslationEditor,
        translation,
        fieldType,
        label,
        currentValue
      }
    )
  ] });
}
function CommonIonicInput(props) {
  const { label, labelPlacement = "floating", type, register: register2, error } = props;
  const { itemProps, inputProps, control } = props;
  const { showEye, googleIt, translation } = props;
  const [showPassword, setShowPassword] = React.useState(false);
  const togglePasswordVisibility = () => {
    setShowPassword(!showPassword);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { ...itemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonInput,
          {
            label,
            type: showPassword ? "text" : type,
            labelPlacement,
            onIonBlur: register2.onBlur,
            onKeyUp: register2.onBlur,
            step: "any",
            ...inputProps,
            ...register2,
            children: [
              showEye && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  fill: "clear",
                  slot: "end",
                  onClick: togglePasswordVisibility,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: showPassword ? eye : eyeOff })
                }
              ),
              translation && /* @__PURE__ */ jsxRuntimeExports.jsx(
                TranslationButton,
                {
                  translation,
                  fieldName: register2.name,
                  fieldType: FieldType.Text,
                  label,
                  currentValue: field.value || ""
                }
              ),
              !!(googleIt == null ? void 0 : googleIt.length) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  fill: "clear",
                  slot: "end",
                  onClick: () => window.open(
                    "https://www.google.com/search?q=".concat(googleIt),
                    "_blank"
                  ),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: logoGoogle })
                }
              )
            ]
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
function CommonIonicSelect(props) {
  const {
    ariaLabel,
    interfaceProp = "action-sheet",
    selectProps,
    placeholder,
    multiple,
    register: register2,
    options = [],
    control,
    error,
    labelPlacement = "floating",
    emptyOption
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => {
          var _a2;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            IonSelect,
            {
              ...selectProps,
              label: ariaLabel,
              interface: interfaceProp,
              placeholder,
              multiple: !!multiple,
              onIonBlur: register2.onBlur,
              onIonChange: register2.onChange,
              labelPlacement,
              value: (_a2 = field.value) == null ? void 0 : _a2.toString(),
              ...register2,
              children: [
                emptyOption && /* @__PURE__ */ jsxRuntimeExports.jsx(IonSelectOption, { value: null, children: emptyOption }),
                options.map((option, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(IonSelectOption, { ...option, children: option.text }, index))
              ]
            }
          );
        }
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const commonValidationMessages = {
  required: "Obavezno polje",
  min: "minimalno ${min}",
  max: "maksimalno ${max}",
  email: "Neispravan email"
};
const tV = (key) => {
  return t(commonValidationMessages[key]);
};
setLocale({
  number: {
    min: tV("min")
  },
  array: {
    min: tV("min")
  },
  string: {
    min: tV("min")
  },
  mixed: {
    required: tV("required")
  }
});
const convertEmptyStringToNull = (value) => value === "" || lodashExports.isNumber(value) && isNaN(value) ? null : value;
const generateSlugForValidation = (text) => {
  return text.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
};
const validatePhotosHaveId = (photos) => {
  if (!photos || photos.length === 0) {
    return true;
  }
  return photos.every((photo) => (photo == null ? void 0 : photo.id) !== void 0 && (photo == null ? void 0 : photo.id) !== null);
};
const photosArrayWithIdYup = (errorMsg) => yup.array().nullable().defined().test("all-photos-have-id", "", function(value) {
  return validatePhotosHaveId(value);
});
function CommonIonicSlug(props) {
  const { label, labelPlacement = "floating", register: register2, error } = props;
  const {
    itemProps,
    inputProps,
    control,
    sourceField,
    placeholder,
    isWatched,
    isWatchedDefault
  } = props;
  const [isWatchedState, setIsWatchedState] = reactExports.useState(isWatchedDefault != null ? isWatchedDefault : true);
  const fieldOnChangeRef = reactExports.useRef(null);
  const watchSourceField = useWatch({ control, name: sourceField });
  const handleToggleWatched = () => {
    setIsWatchedState(!isWatchedState);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { ...itemProps, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => {
          fieldOnChangeRef.current = field.onChange;
          const sourceValue = watchSourceField || "";
          const shouldAutoGenerate = (isWatched != null ? isWatched : isWatchedState) && sourceValue;
          if (shouldAutoGenerate) {
            const slug = generateSlugForValidation(sourceValue);
            if (slug && slug !== field.value) {
              field.onChange(slug);
            }
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: { display: "flex", alignItems: "center", width: "100%" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonInput,
                  {
                    ...field,
                    ...inputProps,
                    label,
                    labelPlacement,
                    placeholder,
                    readonly: !!shouldAutoGenerate,
                    className: error ? "ion-invalid" : "",
                    style: { flex: 1 }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonButton,
                  {
                    fill: "clear",
                    size: "small",
                    color: isWatchedState ? "success" : "danger",
                    onClick: handleToggleWatched,
                    style: { marginLeft: "8px" },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: isWatchedState ? videocam : videocamOff })
                  }
                )
              ]
            }
          );
        }
      }
    ),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-margin-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ion-text-wrap", children: error.message }) })
  ] });
}
function MultiSelectAutocomplete(props) {
  var _a2;
  const { selectedItems } = props;
  const [filteredItems, setFilteredItems] = reactExports.useState([
    ...props.items
  ]);
  const [workingSelectedValues, setWorkingSelectedValues] = reactExports.useState([
    ...selectedItems
  ]);
  const dataRowClassNames = (_a2 = props.dataRowClassNames) != null ? _a2 : "ion-no-padding";
  const isChecked = (value) => {
    return workingSelectedValues.find((item) => item === value) !== void 0;
  };
  const cancelChanges = () => {
    const { onSelectionCancel } = props;
    if (onSelectionCancel !== void 0) {
      onSelectionCancel();
    }
  };
  const confirmChanges = () => {
    const { onSelectionChange } = props;
    if (onSelectionChange !== void 0) {
      onSelectionChange(workingSelectedValues);
    }
  };
  const searchbarInput = (ev) => {
    filterList(ev.target.value);
  };
  const filterList = (searchQuery) => {
    if (searchQuery === void 0 || searchQuery === null) {
      setFilteredItems([...props.items]);
    } else {
      const normalizedQuery = searchQuery.toLowerCase();
      setFilteredItems(
        props.items.filter((item) => {
          return item.text.toLowerCase().includes(normalizedQuery);
        })
      );
    }
  };
  const checkboxChange = (ev) => {
    const { checked, value } = ev.detail;
    if (checked) {
      setWorkingSelectedValues([...workingSelectedValues, value]);
    } else {
      setWorkingSelectedValues(
        workingSelectedValues.filter((item) => item !== value)
      );
    }
  };
  const checkSelectedValuesHasDiff = reactExports.useCallback(() => {
    if (workingSelectedValues.length === 0 && selectedItems.length === 0) {
      return false;
    }
    if (workingSelectedValues.length !== selectedItems.length || workingSelectedValues.length === 0) {
      return true;
    }
    return workingSelectedValues.filter((x) => !selectedItems.includes(x)).length;
  }, [workingSelectedValues, selectedItems]);
  reactExports.useEffect(() => {
    if (props.hideSearchbar && checkSelectedValuesHasDiff()) {
      confirmChanges();
    }
  }, [workingSelectedValues, selectedItems]);
  reactExports.useEffect(() => {
    setFilteredItems([...props.items]);
  }, [props.items]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonGrid, { className: "ion-no-padding", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { className: "ion-no-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: !props.hideSearchbar ? /* @__PURE__ */ jsxRuntimeExports.jsxs(IonHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: cancelChanges, children: "Cancel" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: props.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: confirmChanges, children: "Done" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSearchbar, { onIonInput: searchbarInput }) })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "ion-no-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: props.title }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { className: dataRowClassNames, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { className: "ion-no-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonList, { className: "ion-no-margin", children: filteredItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { disabled: props.disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonCheckbox,
      {
        value: item.value,
        checked: isChecked(item.value),
        onIonChange: checkboxChange,
        disabled: item.disabled || props.disabled,
        children: item.text
      }
    ) }, item.value)) }) }) })
  ] }) });
}
function CommonIonicMultiCheckbox(props) {
  const {
    disabled,
    register: register2,
    control,
    error,
    showSearchbar = true,
    label,
    dataRowClassNames,
    interfaceProp = "action-sheet",
    labelPlacement = "floating",
    options = []
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field: { onChange, value } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          MultiSelectAutocomplete,
          {
            disabled,
            items: options.map((option) => {
              var _a2;
              return {
                value: option.value,
                text: (_a2 = option.text) != null ? _a2 : option.value,
                disabled: option.disabled
              };
            }),
            selectedItems: value != null ? value : [],
            onSelectionChange: (items) => onChange(items),
            hideSearchbar: !showSearchbar,
            title: label,
            dataRowClassNames
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const RichEditor = ({ onChange, value, label, children, ...other }, ref) => {
  var _a2;
  const initialVal = DraftExports.convertFromHTML(String(value != null ? value : ""));
  const wrapperClassName = (_a2 = other.wrapperClassName) != null ? _a2 : "rich-editor-wrapper";
  const [editorState, setEditorState] = reactExports.useState(
    value ? DraftExports.EditorState.createWithContent(
      DraftExports.ContentState.createFromBlockArray(initialVal.contentBlocks)
    ) : DraftExports.EditorState.createEmpty()
  );
  const [text, setText] = reactExports.useState();
  const onEditorStateChange = function(editorState2) {
    setEditorState(editorState2);
    const { blocks } = DraftExports.convertToRaw(editorState2.getCurrentContent());
    const rawContentState = DraftExports.convertToRaw(editorState2.getCurrentContent());
    const markup = draftToHtml(rawContentState);
    setText(markup);
    onChange(markup);
  };
  reactExports.useEffect(() => {
    if (value && !editorState.getLastChangeType()) {
      const val = DraftExports.convertFromHTML(String(value));
      setEditorState(
        DraftExports.EditorState.createWithContent(
          DraftExports.ContentState.createFromBlockArray(val.contentBlocks)
        )
      );
    }
  }, [value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-5 w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: label }),
      children
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: wrapperClassName, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      reactDraftWysiwygExports.Editor,
      {
        editorState,
        onEditorStateChange,
        toolbarClassName: "toolbarClassName",
        wrapperClassName: "wrapperClassName",
        editorClassName: "editorClassName",
        toolbar: {
          options: [
            "inline",
            "blockType",
            "list",
            "textAlign",
            "link",
            "emoji",
            "image",
            "history"
          ]
        }
      }
    ) })
  ] });
};
const RichEditor$1 = reactExports.memo(reactExports.forwardRef(RichEditor));
function FormRichEditor(props) {
  const { register: register2, error, label } = props;
  const { itemProps, control, translation } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { ...itemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsx(RichEditor$1, { ...field, label, children: translation && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TranslationButton,
          {
            translation,
            fieldName: register2.name,
            fieldType: FieldType.RichEditor,
            label,
            currentValue: field.value || ""
          }
        ) })
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
function SelectAutocomplete(props) {
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  const { items, handleAddNewOption } = props;
  const [filteredItems, setFilteredItems] = reactExports.useState([
    ...items
  ]);
  const cancelChanges = () => {
    const { onSelectionCancel } = props;
    if (onSelectionCancel !== void 0) {
      onSelectionCancel();
    }
  };
  const searchbarInput = (ev) => {
    filterList(ev.target.value);
    setSearchQuery(ev.target.value);
  };
  const filterList = (searchQuery2) => {
    if (searchQuery2 === void 0 || searchQuery2 === null) {
      setFilteredItems([...props.items]);
    } else {
      const normalizedQuery = searchQuery2.toLowerCase();
      setFilteredItems(
        props.items.filter((item) => {
          return item.filterField === false || item.text.toLowerCase().includes(normalizedQuery);
        })
      );
    }
  };
  const handleSelected = (item) => () => {
    var _a2;
    (_a2 = props.onSelectionChange) == null ? void 0 : _a2.call(props, item);
  };
  const handleSelectAddNew = () => {
    if (searchQuery) {
      handleAddNewOption == null ? void 0 : handleAddNewOption(searchQuery);
      cancelChanges();
    }
  };
  reactExports.useEffect(() => {
    setFilteredItems(items);
  }, [items]);
  const searchPlaceholder = handleAddNewOption ? t("Pretra탑i / Dodaj novo") : t("Pretraga");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonGrid, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: !props.hideSearchbar ? /* @__PURE__ */ jsxRuntimeExports.jsxs(IonHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: props.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleSelected(void 0), children: t("Resetuj") }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonSearchbar,
        {
          onIonInput: searchbarInput,
          placeholder: searchPlaceholder
        }
      ) })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "ion-no-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: props.title }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { id: "modal-list", inset: true, children: [
      handleAddNewOption && searchQuery && /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { button: true, onClick: handleSelectAddNew, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { color: "primary", children: [
        t("Dodaj novo:"),
        " ",
        searchQuery
      ] }) }) }),
      items.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        qr,
        {
          totalCount: filteredItems.length,
          style: { height: "400px" },
          itemContent: (index) => {
            var _a2;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonItem,
              {
                disabled: props.disabled,
                onClick: handleSelected(filteredItems[index].value),
                button: true,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: (_a2 = filteredItems[index].childNode) != null ? _a2 : filteredItems[index].text })
              },
              filteredItems[index].value
            );
          }
        }
      )
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { button: true, onClick: cancelChanges, detail: false, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline, className: "mr-2", slot: "end" }),
      t("Zatvori")
    ] }) }) })
  ] }) });
}
function SelectAutocompleteModal({
  onSelectionChanged,
  selectedItemValue,
  handleAddNewOption,
  options,
  title,
  startIcon,
  endIcon,
  hideInput,
  hideOnSelection = true
}) {
  var _a2;
  const [isNewSelected, setIsNewSelected] = reactExports.useState(false);
  const modal = reactExports.useRef(null);
  selectedItemValue = selectedItemValue == null ? void 0 : selectedItemValue.toString();
  const selectedItemText = isNewSelected ? selectedItemValue : (_a2 = options.find((option) => option.value === selectedItemValue)) == null ? void 0 : _a2.text;
  const [showModal, setShowModal] = reactExports.useState(false);
  const handleSelectChange = (item, isNewSelected2) => {
    var _a3;
    onSelectionChanged == null ? void 0 : onSelectionChanged(item);
    if (hideOnSelection || options.length <= 1) {
      (_a3 = modal.current) == null ? void 0 : _a3.dismiss();
    }
    setIsNewSelected(!!isNewSelected2);
  };
  const handleAddNewSelectedOption = (value) => {
    handleAddNewOption == null ? void 0 : handleAddNewOption(value);
    handleSelectChange(value, true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonItem,
      {
        onClick: () => setShowModal(true),
        button: true,
        hidden: hideInput,
        children: [
          startIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "start", icon: startIcon }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonInput,
            {
              label: title,
              readonly: true,
              value: selectedItemText,
              labelPlacement: "floating"
            }
          ),
          endIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "end", icon: endIcon })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonModal,
      {
        ref: modal,
        isOpen: showModal,
        onDidDismiss: () => setShowModal(false),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectAutocomplete,
          {
            title,
            items: options,
            selectedItem: selectedItemValue,
            onSelectionCancel: () => {
              var _a3;
              return (_a3 = modal.current) == null ? void 0 : _a3.dismiss();
            },
            onSelectionChange: handleSelectChange,
            handleAddNewOption: handleAddNewOption ? handleAddNewSelectedOption : void 0
          }
        ) })
      }
    )
  ] });
}
function CommonIonicAutocompleteSelect(props) {
  const { register: register2, options, control, error, label, handleAddNewOption } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field: { onChange, value } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectAutocompleteModal,
          {
            selectedItemValue: value,
            onSelectionChanged: (item) => {
              var _a2, _b2;
              onChange(
                item !== void 0 ? item : (_b2 = (_a2 = control._defaultValues) == null ? void 0 : _a2[register2.name]) != null ? _b2 : null
              );
            },
            options,
            title: label,
            handleAddNewOption
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
function SwiperWrapper(props, ref) {
  const { currentStep, ...swiperProps } = props;
  const swiperRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (currentStep !== void 0) {
      const timeout = setTimeout(() => {
        var _a2, _b2, _c2, _d2;
        if (((_b2 = (_a2 = swiperRef == null ? void 0 : swiperRef.current) == null ? void 0 : _a2.swiper) == null ? void 0 : _b2.activeIndex) !== currentStep) {
          (_d2 = (_c2 = swiperRef == null ? void 0 : swiperRef.current) == null ? void 0 : _c2.swiper) == null ? void 0 : _d2.slideTo(currentStep);
        }
      }, 100);
      return () => clearTimeout(timeout);
    }
  }, [currentStep]);
  reactExports.useImperativeHandle(ref, () => {
    var _a2;
    return {
      swiper: (_a2 = swiperRef.current) == null ? void 0 : _a2.swiper
    };
  });
  const onSlideChange = reactExports.useMemo(() => {
    return currentStep !== void 0 ? (swiper) => {
      var _a2, _b2;
      if (currentStep !== void 0 && swiper.activeIndex !== currentStep) {
        (_b2 = (_a2 = swiperRef.current) == null ? void 0 : _a2.swiper) == null ? void 0 : _b2.slideTo(currentStep);
      }
    } : void 0;
  }, [currentStep]);
  const swiperPropsWithInitialSlide = reactExports.useMemo(() => {
    if (currentStep !== void 0) {
      return { ...swiperProps, initialSlide: currentStep };
    }
    return swiperProps;
  }, [currentStep, swiperProps]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Swiper,
    {
      onSlideChange,
      watchSlidesProgress: true,
      ...swiperPropsWithInitialSlide,
      ref: swiperRef
    }
  ) });
}
const SwiperWrapper$1 = reactExports.memo(reactExports.forwardRef(SwiperWrapper));
const getFirstUploadedFileIdSortedBehindIndex = (manageDataItems, fileIndex) => {
  var _a2, _b2;
  return (_b2 = (_a2 = manageDataItems == null ? void 0 : manageDataItems.find(
    (item, itemIndex) => itemIndex > fileIndex && item.id !== void 0
  )) == null ? void 0 : _a2.id) != null ? _b2 : "";
};
const fixManageDataItemsIndexes = (manageDataItems, fromIndex = 0) => manageDataItems.map((item, index) => ({
  ...item,
  index: fromIndex + index,
  sortOrder: index + fromIndex + 1,
  image: item.image ? { ...item.image, index: fromIndex + index } : void 0
}));
const initialState = {
  data: {
    manageDataItems: [],
    itemsReorderFromTo: [],
    showSortItemsModal: void 0,
    showManageListModal: void 0
  }
};
const manageDataSlices = createSlice({
  name: "manageItems",
  initialState,
  reducers: {
    setManageData(state, action) {
      const manageDataItems = action.payload.manageDataItems ? fixManageDataItemsIndexes(action.payload.manageDataItems) : state.data.manageDataItems;
      state.data = {
        ...state.data,
        ...action.payload,
        manageDataItems
      };
    },
    setShowSortDataModal(state, action) {
      state.data.showSortItemsModal = action.payload;
    },
    setShowManageListModal(state, action) {
      state.data.showManageListModal = action.payload;
    },
    setManageDataItems(state, action) {
      state.data.manageDataItems = fixManageDataItemsIndexes(action.payload);
    },
    updateManageDataItemPhoto(state, action) {
      const itemIndex = action.payload.index;
      if (state.data.manageDataItems && state.data.manageDataItems[itemIndex]) {
        state.data.manageDataItems[itemIndex].image = action.payload.image;
      }
    },
    updateManageDataItemProductPhoto(state, action) {
      const itemIndex = action.payload.index;
      if (state.data.manageDataItems && state.data.manageDataItems[itemIndex]) {
        const existingImage = state.data.manageDataItems[itemIndex].image;
        if (existingImage) {
          state.data.manageDataItems[itemIndex].image = {
            ...existingImage,
            id: action.payload.productImage.id
          };
        }
      }
    },
    updateManageDataItems(state, action) {
      action.payload.forEach((item) => {
        const itemIndex = item.index;
        if (state.data.manageDataItems && state.data.manageDataItems[itemIndex]) {
          state.data.manageDataItems[itemIndex] = item.data;
        }
      });
    },
    addManageDataItems(state, action) {
      var _a2, _b2;
      (_b2 = state.data.manageDataItems) == null ? void 0 : _b2.push(
        ...fixManageDataItemsIndexes(
          action.payload,
          (_a2 = state.data.manageDataItems) == null ? void 0 : _a2.length
        )
      );
    },
    removeManageDataItems(state, action) {
      var _a2, _b2;
      state.data.manageDataItems = fixManageDataItemsIndexes(
        (_b2 = (_a2 = state.data.manageDataItems) == null ? void 0 : _a2.filter(
          (item, index) => !action.payload.includes(index)
        )) != null ? _b2 : []
      );
    },
    resetManageDataItems(state) {
      state.data.manageDataItems = [];
    },
    addReorderFromTo(state, action) {
      var _a2;
      (_a2 = state.data.itemsReorderFromTo) == null ? void 0 : _a2.push(action.payload);
    },
    resetReorderFromTo(state) {
      state.data.itemsReorderFromTo = [];
    },
    removeReorderFromToItems(state, action) {
      var _a2;
      state.data.itemsReorderFromTo = (_a2 = state.data.itemsReorderFromTo) == null ? void 0 : _a2.filter(
        (item) => !action.payload.includes(item)
      );
    }
  }
});
const isCroppedItemImage = (item, aspectRatioStr) => {
  var _a2, _b2;
  return ((_b2 = (_a2 = item.image) == null ? void 0 : _a2.croppedUrls) == null ? void 0 : _b2[aspectRatioStr]) !== void 0 || item.id !== void 0;
};
const getManageItems = (state) => state.manageData.data.manageDataItems;
const manageItemsMaxSortOrder = (state) => {
  var _a2, _b2;
  return ((_a2 = state.manageData.data.manageDataItems) == null ? void 0 : _a2.length) ? Math.max(
    ...((_b2 = state.manageData.data.manageDataItems) == null ? void 0 : _b2.map(
      (item) => {
        var _a3;
        return (_a3 = item.sortOrder) != null ? _a3 : 0;
      }
    )) || []
  ) : 0;
};
const getNonCroppedItems = (aspectRatioStr) => (state) => {
  var _a2;
  return (_a2 = state.manageData.data.manageDataItems) == null ? void 0 : _a2.filter(
    (item) => !isCroppedItemImage(item, aspectRatioStr)
  );
};
const getItemsReorderFromTo = (state) => state.manageData.data.itemsReorderFromTo;
const {
  setManageData,
  setShowSortDataModal,
  setManageDataItems,
  updateManageDataItemPhoto,
  updateManageDataItemProductPhoto,
  updateManageDataItems,
  addManageDataItems,
  removeManageDataItems,
  setShowManageListModal,
  addReorderFromTo,
  resetReorderFromTo,
  removeReorderFromToItems,
  resetManageDataItems
} = manageDataSlices.actions;
const CropView = (props, ref) => {
  var _a2;
  const aspectRatioSizes = (_a2 = props.aspectRatio) != null ? _a2 : {
    width: 4,
    height: 5
  };
  const { image, hideActions } = props;
  const { autoCrop, autoCropIndex, onAutoCrop } = props;
  const { onSave, onDiscard } = props;
  const cropperRef = reactExports.useRef(null);
  const [cropData, setCropData] = React.useState();
  let loadingPreview = false;
  const [resizedImage, setResizedImage] = React.useState(
    void 0
  );
  const handleCrop = () => {
    var _a3;
    try {
      const cropper = (_a3 = cropperRef.current) == null ? void 0 : _a3.cropper;
      const cropData2 = cropper == null ? void 0 : cropper.getCroppedCanvas().toDataURL();
      handleSave(cropData2);
    } catch (e) {
      setTimeout(() => {
        handleCrop();
      }, 200);
    }
  };
  const onZoom = () => {
    if (!loadingPreview) {
      loadingPreview = true;
      setTimeout(() => {
        var _a3;
        const cropper = (_a3 = cropperRef.current) == null ? void 0 : _a3.cropper;
        setCropData(cropper == null ? void 0 : cropper.getCroppedCanvas().toDataURL());
        loadingPreview = false;
      }, 1e3);
    }
  };
  reactExports.useImperativeHandle(ref, () => ({
    handleSave: () => {
      handleSave();
    }
  }));
  const handleDiscard = () => {
    onDiscard == null ? void 0 : onDiscard();
  };
  const handleSave = (cropData2) => {
    if (cropData2) {
      if (autoCrop) {
        onAutoCrop == null ? void 0 : onAutoCrop(cropData2, autoCropIndex);
      } else {
        onSave == null ? void 0 : onSave(cropData2);
      }
    }
  };
  const handleSetCropData = (src) => {
    if (autoCrop) {
      setTimeout(() => {
        handleCrop();
      }, 500);
    } else {
      setCropData(src);
    }
  };
  const handleCropInit = () => {
    handleSetCropData(resizedImage);
  };
  reactExports.useEffect(() => {
    const existingImage = new Image();
    existingImage.onload = function() {
      const aspectRatio = (aspectRatioSizes == null ? void 0 : aspectRatioSizes.height) / (aspectRatioSizes == null ? void 0 : aspectRatioSizes.width);
      if (existingImage.height > existingImage.width * aspectRatio) {
        setResizedImage(image.url);
        return null;
      }
      const canvas = document.createElement("canvas");
      const canvasWidth = existingImage.width;
      const canvasHeight = existingImage.width * aspectRatio;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext("2d");
      const verticalOffset = (canvasHeight - existingImage.height) / 2;
      ctx.drawImage(
        existingImage,
        0,
        verticalOffset,
        existingImage.width,
        existingImage.height
      );
      const newImage = new Image();
      newImage.src = canvas.toDataURL();
      setTimeout(() => {
        setResizedImage(newImage.src);
      }, 200);
    };
    existingImage.src = image.url;
  }, [image.url]);
  reactExports.useEffect(() => {
    if (resizedImage && autoCrop && autoCropIndex) {
      handleSetCropData(resizedImage);
    }
  }, [resizedImage, autoCropIndex]);
  if (!resizedImage) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: image.url, alt: "cropped" });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      l,
      {
        src: resizedImage,
        style: { height: 400, width: "100%" },
        viewMode: 1,
        initialAspectRatio: aspectRatioSizes.width / aspectRatioSizes.height,
        dragMode: "move",
        aspectRatio: aspectRatioSizes.width / aspectRatioSizes.height,
        autoCrop: true,
        guides: false,
        scalable: false,
        cropBoxResizable: false,
        cropBoxMovable: false,
        minCropBoxHeight: 700,
        movable: true,
        zoom: onZoom,
        onInitialized: handleCropInit,
        ref: cropperRef
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { hidden: hideActions, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButton, { onClick: handleDiscard, color: "danger", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "start", icon: arrowUndoOutline }),
        t("Odustani")
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButton, { onClick: handleCrop, color: "secondary", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "start", icon: saveOutline }),
        t("Primeni")
      ] }) })
    ] }) })
  ] });
};
const CropView$1 = reactExports.memo(reactExports.forwardRef(CropView));
function AutoCropControllerModal(props, ref) {
  const { image, aspectRatio } = props;
  const { handleClose, cropViewProps } = props;
  const cropViewRef = reactExports.useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonPage, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: aspectRatio && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      aspectRatio.width,
      " x ",
      aspectRatio.height
    ] }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { fullscreen: true, className: "ion-padding ion-text-center", children: image && /* @__PURE__ */ jsxRuntimeExports.jsx(
      CropView$1,
      {
        ref: cropViewRef,
        image,
        onDiscard: handleClose,
        hideActions: true,
        aspectRatio,
        ...cropViewProps
      }
    ) })
  ] });
}
const AutoCropControllerModal$1 = reactExports.memo(reactExports.forwardRef(AutoCropControllerModal));
const modalEnterAnimation = (baseEl) => {
  const root = baseEl.shadowRoot;
  const backdropAnimation = createAnimation().addElement(root == null ? void 0 : root.querySelector("ion-backdrop")).fromTo("opacity", "0.01", "var(--backdrop-opacity)");
  const wrapperAnimation = createAnimation().addElement(root == null ? void 0 : root.querySelector(".modal-wrapper")).keyframes([
    { offset: 0, opacity: "0", transform: "scale(0)" },
    { offset: 1, opacity: "0.99", transform: "scale(1)" }
  ]);
  return createAnimation().addElement(baseEl).duration(350).addAnimation([backdropAnimation, wrapperAnimation]);
};
const manageDataReducers = {
  manageData: manageDataSlices.reducer
};
const rootReducer = combineReducers(manageDataReducers);
configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware()
});
function withManageDataWrapper(WrappedComponent) {
  return class extends React.Component {
    render() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ManageDataWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedComponent, { ...this.props }) });
    }
  };
}
const DataContext = reactExports.createContext(void 0);
const DispatchContext = reactExports.createContext(void 0);
function useManageDataSelector(selector) {
  const manageDataState = React.useContext(DataContext);
  if (!manageDataState) {
    throw new Error(
      "useManageDataSelector must be used within a ManageDataProvider"
    );
  }
  return selector(manageDataState);
}
function useManageDataDispatch() {
  const dispatchContext = React.useContext(DispatchContext);
  if ((dispatchContext == null ? void 0 : dispatchContext.dispatch) === void 0) {
    throw new Error(
      "useManageDataDispatch must be used within a ManageDataWrapper"
    );
  }
  return (action) => {
    dispatchContext.dispatch(action);
    dispatchContext.reRender();
  };
}
function ManageDataWrapper({ children }) {
  const manageDataStore = reactExports.useMemo(
    () => configureStore({
      reducer: combineReducers(manageDataReducers)
    }),
    []
  );
  const storeState = manageDataStore.getState();
  const dispatch = manageDataStore.dispatch;
  const [render, setRender] = reactExports.useState(false);
  const reRender = reactExports.useCallback(() => {
    setRender(!render);
  }, [render]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DataContext.Provider, { value: storeState, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DispatchContext.Provider, { value: { dispatch, reRender }, children }) });
}
reactExports.memo(ManageDataWrapper);
const useAutoCropModalController = (props) => {
  const { cropAspectRatio } = props;
  const [images, setImages] = React.useState([]);
  const [image, setImage] = React.useState(void 0);
  const [activeIndex, setActiveIndex] = React.useState(
    void 0
  );
  const [croppedIndexes, setCroppedIndexes] = React.useState([]);
  const dispatch = useManageDataDispatch();
  const cropAspectRatioStr = "".concat(cropAspectRatio.width, "x").concat(cropAspectRatio.height);
  const AutoCropControllerModalWrapper = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      AutoCropControllerModal$1,
      {
        image,
        handleClose: function() {
          setActiveIndex((activeIndex != null ? activeIndex : 0) + 1);
        },
        aspectRatio: cropAspectRatio,
        cropViewProps: {
          autoCropIndex: activeIndex,
          autoCrop: true,
          onAutoCrop: (croppedSrc, autoCropIndex) => {
            if (autoCropIndex !== void 0) {
              updateSelectedImage(croppedSrc, autoCropIndex).then(() => {
                setActiveIndex(autoCropIndex + 1);
              });
            }
          }
        }
      }
    );
  };
  const updateSelectedImage = async (croppedSrc, autoCropIndex) => {
    const selectedImage = images[autoCropIndex];
    if (!croppedIndexes.includes(autoCropIndex)) {
      setCroppedIndexes([...croppedIndexes, autoCropIndex]);
      dispatch(
        updateManageDataItemPhoto({
          index: selectedImage.index,
          image: {
            ...selectedImage,
            croppedUrls: {
              [cropAspectRatioStr]: croppedSrc
            }
          }
        })
      );
    }
  };
  const [present, dismiss] = useIonModal(AutoCropControllerModalWrapper, {
    onDismiss: (data, role) => dismiss(data, role)
  });
  const [presentLoader, dismissLoader] = useIonLoading();
  reactExports.useEffect(() => {
    if (activeIndex !== void 0) {
      if (activeIndex >= images.length) {
        dismiss();
        dismissLoader();
        setActiveIndex(void 0);
        setCroppedIndexes([]);
      } else {
        setImage(images[activeIndex]);
      }
    }
  }, [activeIndex]);
  const startAutoCrop = (images2) => {
    setImages(images2);
    setActiveIndex(0);
    present({
      enterAnimation: modalEnterAnimation
    });
    presentLoader({
      message: t("Auto-cropping images...")
    });
  };
  return { startAutoCrop };
};
const useConfirmationAlert = (callbacks, options) => {
  const [presentAlert, dismiss] = useIonAlert();
  return [
    (overrideOptions) => {
      var _a2, _b2;
      const {
        cancelCallback,
        confirmCallback,
        buttonsTextsKeys,
        ...presentOptions
      } = {
        ...options,
        ...callbacks,
        ...overrideOptions
      };
      const cancelKey = (_a2 = buttonsTextsKeys == null ? void 0 : buttonsTextsKeys.cancel) != null ? _a2 : "Odustani";
      const confirmKey = (_b2 = buttonsTextsKeys == null ? void 0 : buttonsTextsKeys.confirm) != null ? _b2 : "OK";
      return presentAlert({
        header: t("Potvrda"),
        buttons: [
          {
            text: t(cancelKey),
            role: "cancel",
            handler: cancelCallback
          },
          {
            text: t(confirmKey),
            role: "confirm",
            handler: confirmCallback
          }
        ],
        ...presentOptions
      });
    },
    dismiss
  ];
};
const formatBytes = (bytes) => {
  if (bytes === 0) return "0 Bytes";
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return Math.round(bytes / Math.pow(k, i) * 100) / 100 + " " + sizes[i];
};
const getFileSizeFromUrl = async (url) => {
  try {
    if (url.startsWith("data:")) {
      const base64String = url.split(",")[1];
      if (base64String) {
        return base64String.length * 3 / 4;
      }
    } else if (url.startsWith("blob:")) {
      const response = await fetch(url);
      const blob = await response.blob();
      return blob.size;
    }
    return 0;
  } catch (e) {
    return 0;
  }
};
const ImageSizeDisplay = ({
  url,
  maxSize = 10 * 1024 * 1024
}) => {
  const [size, setSize] = reactExports.useState(null);
  reactExports.useEffect(() => {
    const fetchSize = async () => {
      const fileSize = await getFileSizeFromUrl(url);
      if (fileSize > 0) {
        setSize(fileSize);
      }
    };
    fetchSize();
  }, [url]);
  if (!size) return null;
  const isOverLimit = size > maxSize;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: isOverLimit ? "animate-pulse" : "",
      style: {
        position: "absolute",
        bottom: "8px",
        right: "8px",
        padding: "4px 8px",
        backgroundColor: "rgba(0, 0, 0, 0.85)",
        borderRadius: "4px",
        zIndex: 10
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            alignItems: "flex-end"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonText,
              {
                color: isOverLimit ? "danger" : "light",
                style: {
                  fontSize: "12px",
                  color: isOverLimit ? "#ff6b6b" : "#ffffff",
                  fontWeight: isOverLimit ? "bold" : "normal"
                },
                children: formatBytes(size)
              }
            ),
            isOverLimit && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonText,
              {
                color: "danger",
                style: {
                  fontSize: "10px",
                  color: "#ff6b6b",
                  fontWeight: "normal"
                },
                children: [
                  "Max: ",
                  formatBytes(maxSize)
                ]
              }
            )
          ]
        }
      )
    }
  );
};
register();
function PhotoGallery(props, ref) {
  const { defaultActiveSlide, photos, setSelectedImageIndex } = props;
  const { cropAspectRatio, notCroppedPhotos, editOnSelect } = props;
  const {
    handleRemoveImages,
    handleOnManageAction,
    handleOnSortAction,
    pendingUploadCount = 0,
    onUploadClick
  } = props;
  const availableActions = {
    ...{
      crop: true,
      sort: true
    },
    ...props.availableActions
  };
  const [presentRemovePhoto] = useConfirmationAlert({
    confirmCallback: () => {
      removePhoto();
    }
  });
  const cropAspectRatioStr = "".concat(cropAspectRatio.width, "x").concat(cropAspectRatio.height);
  const [presentActions] = useIonActionSheet();
  const [activeSlide, setActiveSlide] = React.useState(
    defaultActiveSlide != null ? defaultActiveSlide : 0
  );
  const swiperRef = React.useRef(null);
  const dispatch = useManageDataDispatch();
  const { startAutoCrop } = useAutoCropModalController({
    cropAspectRatio
  });
  reactExports.useImperativeHandle(ref, () => ({
    setGalleryStep: (step) => {
      setActiveSlide(step);
    },
    handleStartAutoCrop: () => {
      handleOnAutoCrop();
    }
  }));
  const handleImageClick = () => {
    canCrop && editOnSelect && setSelectedImageIndex(activeSlide != null ? activeSlide : 0);
  };
  const handleSlideChange = (swiper) => {
    setActiveSlide(swiper.activeIndex);
  };
  const handleOnSort = () => handleOnSortAction ? handleOnSortAction() : dispatch(setShowSortDataModal(true));
  const handleOnManage = () => handleOnManageAction ? handleOnManageAction() : dispatch(setShowManageListModal(true));
  const handleOnCrop = () => {
    setSelectedImageIndex(activeSlide != null ? activeSlide : 0);
  };
  const handleOnAutoCrop = () => {
    if (notCroppedPhotos == null ? void 0 : notCroppedPhotos.length) {
      startAutoCrop(notCroppedPhotos);
    }
  };
  const presentAdditionActions = () => {
    presentActions({
      header: t("Dodatne opcije"),
      buttons: [
        {
          icon: funnelOutline,
          text: t("Sortiraj"),
          data: {
            action: "sort"
          },
          cssClass: photos.length < 2 ? "cursor-not-allowed focus:outline-none opacity-25" : void 0,
          handler: () => {
            if (photos.length >= 2) {
              handleOnSort();
            }
          }
        },
        {
          icon: cropOutline,
          text: t("Auto Crop (".concat(notCroppedPhotos == null ? void 0 : notCroppedPhotos.length, ")")),
          data: {
            action: "crop"
          },
          cssClass: !(notCroppedPhotos == null ? void 0 : notCroppedPhotos.length) ? "cursor-not-allowed focus:outline-none opacity-25" : void 0,
          handler: () => {
            if (notCroppedPhotos == null ? void 0 : notCroppedPhotos.length) {
              handleOnAutoCrop();
            }
          }
        },
        {
          icon: listCircleSharp,
          text: t("Upravljanje slikama"),
          data: {
            action: "sort"
          },
          handler: () => {
            handleOnManage();
          }
        },
        {
          text: t("Obri큄i"),
          role: "destructive",
          data: {
            action: "delete"
          },
          handler: () => {
            handleRemovePhoto();
          }
        },
        {
          text: t("Cancel"),
          role: "cancel",
          data: {
            action: "cancel"
          }
        }
      ]
    });
  };
  const removePhotoLocally = (photoIndex) => {
    dispatch(removeManageDataItems([photoIndex]));
  };
  const removePhoto = () => {
    var _a2;
    if (activeSlide !== void 0) {
      if (photos[activeSlide].id !== void 0 && handleRemoveImages) {
        (_a2 = handleRemoveImages == null ? void 0 : handleRemoveImages([photos[activeSlide]])) == null ? void 0 : _a2.then((response) => {
          if ("data" in response && response.data.success) {
            removePhotoLocally(activeSlide);
          }
        });
      } else {
        removePhotoLocally(activeSlide);
      }
    }
  };
  const handleRemovePhoto = () => {
    if (photos.length === 1 && props.handleClose) {
      props.handleClose();
    } else {
      presentRemovePhoto({
        message: t("Da li ste sigurni da 탑elite da obri큄ete sliku?")
      });
    }
  };
  const canCrop = reactExports.useMemo(() => {
    if (activeSlide !== void 0 && photos.length) {
      const photo = photos[activeSlide];
      return (photo == null ? void 0 : photo.id) === void 0 && availableActions.crop;
    }
    return false;
  }, [activeSlide, photos]);
  const bindDouble = c(
    () => {
      canCrop && handleOnCrop();
    },
    void 0,
    {
      onSingleTap: () => {
        handleImageClick();
      }
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonToolbar,
      {
        style: { position: "absolute" },
        color: "translucent",
        hidden: !photos.length,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleRemovePhoto, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "end", icon: trashOutline, color: "danger" }) }) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwiperWrapper$1,
      {
        ref: swiperRef,
        spaceBetween: 50,
        slidesPerView: 1,
        navigation: true,
        pagination: { clickable: true },
        scrollbar: { draggable: true },
        speed: 400,
        initialSlide: activeSlide,
        currentStep: activeSlide != null ? activeSlide : 0,
        onSlideChange: handleSlideChange,
        autoHeight: false,
        className: "photo-gallery-swiper",
        children: photos.map((photo, index) => {
          var _a2, _b2;
          const isNewImage = (photo == null ? void 0 : photo.id) === void 0;
          const imageUrl = cropAspectRatio && ((_a2 = photo.croppedUrls) == null ? void 0 : _a2[cropAspectRatioStr]) ? (_b2 = photo.croppedUrls) == null ? void 0 : _b2[cropAspectRatioStr] : photo.url;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwiperSlide, { style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonImg,
              {
                src: imageUrl,
                alt: photo.name,
                ...bindDouble,
                className: "photo-gallery-img"
              }
            ),
            isNewImage && /* @__PURE__ */ jsxRuntimeExports.jsx(ImageSizeDisplay, { url: imageUrl, maxSize: props.maxSize })
          ] }, "slide" + index);
        })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { className: "actions", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          color: "secondary",
          onClick: handleOnCrop,
          disabled: !canCrop,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "start", icon: cropOutline }),
            "Crop"
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: presentAdditionActions, disabled: !photos.length, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "icon-only", icon: optionsOutline }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          color: pendingUploadCount > 0 ? "warning" : "medium",
          onClick: onUploadClick,
          disabled: pendingUploadCount === 0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "start", icon: cloudUploadOutline }),
            pendingUploadCount > 0 ? "".concat(t("Upload"), " (").concat(pendingUploadCount, ")") : t("Upload")
          ]
        }
      ) })
    ] })
  ] });
}
const PhotoGallery$1 = reactExports.memo(reactExports.forwardRef(PhotoGallery));
function CropViewModal(props, ref) {
  const { isActive, image, aspectRatio } = props;
  const { handleClose, cropViewProps } = props;
  const cropViewRef = reactExports.useRef(null);
  const enterAnimation = (baseEl) => {
    const root = baseEl.shadowRoot;
    const backdropAnimation = createAnimation().addElement(root == null ? void 0 : root.querySelector("ion-backdrop")).fromTo("opacity", "0.01", "var(--backdrop-opacity)");
    const wrapperAnimation = createAnimation().addElement(root == null ? void 0 : root.querySelector(".modal-wrapper")).keyframes([
      { offset: 0, opacity: "0", transform: "scale(0)" },
      { offset: 1, opacity: "0.99", transform: "scale(1)" }
    ]);
    return createAnimation().addElement(baseEl).duration(350).addAnimation([backdropAnimation, wrapperAnimation]);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonModal,
    {
      isOpen: isActive,
      onDidDismiss: handleClose,
      enterAnimation,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: aspectRatio && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            aspectRatio.width,
            " x ",
            aspectRatio.height
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleClose, children: "Close" }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { fullscreen: true, className: "ion-padding ion-text-center", children: image && /* @__PURE__ */ jsxRuntimeExports.jsx(
          CropView$1,
          {
            ref: cropViewRef,
            image,
            onDiscard: handleClose,
            aspectRatio,
            ...cropViewProps
          }
        ) })
      ]
    }
  );
}
const CropViewModal$1 = reactExports.memo(reactExports.forwardRef(CropViewModal));
const getAspectRatioStr = (aspectRatio) => "".concat(aspectRatio.width, "x").concat(aspectRatio.height);
const windowWidth = window.innerWidth;
const commonPhotoAspectRatio = {
  width: 4,
  height: 5
};
const getPathBySize = (img) => {
  if (!img) {
    return "";
  }
  switch (true) {
    case windowWidth >= 1920:
      return img[
        "fullHd"
        /* fullHd */
      ];
    case windowWidth >= 1280:
      return img[
        "hd"
        /* hd */
      ];
    case windowWidth >= 768:
      return img[
        "small"
        /* small */
      ];
    default:
      return img[
        "mobile"
        /* mobile */
      ];
  }
};
function PhotoEditor(props, ref) {
  var _a2, _b2, _c2;
  const dispatch = useManageDataDispatch();
  const [selectedImageIndex, setSelectedImageIndex] = reactExports.useState(void 0);
  const manageDataItems = useManageDataSelector(getManageItems);
  const selectedImage = selectedImageIndex !== void 0 ? manageDataItems == null ? void 0 : manageDataItems[selectedImageIndex].image : void 0;
  const cropViewModalRef = reactExports.useRef(null);
  const photoGalleryRef = reactExports.useRef(null);
  const photos = reactExports.useMemo(
    () => (manageDataItems == null ? void 0 : manageDataItems.length) ? manageDataItems.map((manageDataItem) => manageDataItem.image) : [],
    [manageDataItems]
  );
  const photoAspectRatio = (_a2 = props.photoAspectRatio) != null ? _a2 : commonPhotoAspectRatio;
  const photoAspectRatioStr = getAspectRatioStr(photoAspectRatio);
  const notCroppedPhotos = (_c2 = (_b2 = useManageDataSelector(getNonCroppedItems(photoAspectRatioStr))) == null ? void 0 : _b2.map(
    (manageDataItem) => manageDataItem.image
  )) != null ? _c2 : [];
  const [uploadedImages, setUploadedImages] = reactExports.useState(photos);
  reactExports.useImperativeHandle(ref, () => ({
    setGalleryStep: (step) => {
      var _a3;
      (_a3 = photoGalleryRef.current) == null ? void 0 : _a3.setGalleryStep(step);
    },
    handleAutoCrop: () => {
      var _a3, _b3;
      (_b3 = (_a3 = photoGalleryRef.current) == null ? void 0 : _a3.handleStartAutoCrop) == null ? void 0 : _b3.call(_a3);
    }
  }));
  const updateSelectedImage = async (croppedSrc, removeSelected = true) => {
    if (selectedImageIndex !== void 0 && selectedImage) {
      dispatch(
        updateManageDataItemPhoto({
          index: selectedImageIndex,
          image: {
            ...selectedImage,
            croppedUrls: {
              [photoAspectRatioStr]: croppedSrc
            }
          }
        })
      );
      removeSelected && setSelectedImageIndex(void 0);
    }
  };
  const handleGalleryClose = props.onSetStep ? () => {
    var _a3;
    (_a3 = props.onSetStep) == null ? void 0 : _a3.call(props, 0);
  } : void 0;
  reactExports.useEffect(() => {
    setUploadedImages(photos);
  }, [photos]);
  reactExports.useEffect(() => {
    var _a3, _b3;
    dispatch(
      setManageDataItems(
        (_b3 = (_a3 = props.photos) == null ? void 0 : _a3.map((photo) => ({
          id: photo.id,
          index: photo.index,
          image: photo,
          sortOrder: photo.index
        }))) != null ? _b3 : []
      )
    );
  }, [props.photos]);
  reactExports.useEffect(() => {
    var _a3;
    if (props.onChangedPhotos) {
      props.onChangedPhotos(
        (_a3 = manageDataItems == null ? void 0 : manageDataItems.map((manageDataItem) => {
          var _a4, _b3, _c3, _d2, _e2;
          return {
            id: manageDataItem.id,
            url: (_c3 = (_b3 = (_a4 = manageDataItem.image) == null ? void 0 : _a4.croppedUrls) == null ? void 0 : _b3[photoAspectRatioStr]) != null ? _c3 : "",
            fileAfterId: getFirstUploadedFileIdSortedBehindIndex(
              manageDataItems != null ? manageDataItems : [],
              (_e2 = (_d2 = manageDataItem.image) == null ? void 0 : _d2.index) != null ? _e2 : 0
            )
          };
        }).filter((image) => image.url.length || image.id)) != null ? _a3 : []
      );
    }
  }, [manageDataItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PhotoGallery$1,
      {
        ref: photoGalleryRef,
        photos: uploadedImages,
        notCroppedPhotos,
        setSelectedImageIndex,
        cropAspectRatio: photoAspectRatio,
        handleClose: handleGalleryClose,
        ...props.galleryProps
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CropViewModal$1,
      {
        ref: cropViewModalRef,
        isActive: selectedImageIndex !== void 0,
        handleClose: () => {
          setSelectedImageIndex(void 0);
        },
        image: selectedImage,
        aspectRatio: photoAspectRatio,
        cropViewProps: {
          onSave: updateSelectedImage
        }
      }
    )
  ] });
}
const PhotoEditor$1 = reactExports.memo(reactExports.forwardRef(PhotoEditor));
var ItemsActions = /* @__PURE__ */ ((ItemsActions2) => {
  ItemsActions2["Remove"] = "Remove";
  ItemsActions2["Edit"] = "Edit";
  ItemsActions2["Check"] = "Check";
  return ItemsActions2;
})(ItemsActions || {});
var ListActions = /* @__PURE__ */ ((ListActions2) => {
  ListActions2["Remove"] = "Remove";
  ListActions2["Add"] = "Add";
  ListActions2["SelectEnable"] = "SelectEnable";
  ListActions2["SelectAll"] = "SelectAll";
  ListActions2["AutoCrop"] = "AutoCrop";
  return ListActions2;
})(ListActions || {});
function ManageListItem(props) {
  var _a2, _b2, _c2, _d2, _e2;
  const { data, onHandleAction } = props;
  const { showCheckbox, setShowCheckbox, isSelected } = props;
  const { availableActions } = props;
  const [isChecked, setIsChecked] = React.useState(
    isSelected
  );
  const [preventToggle, setPreventToggle] = React.useState(false);
  const [isOptionsDisabled, setIsOptionsDisabled] = reactExports.useState(true);
  const slideRef = reactExports.useRef(null);
  const slideOptionRef = reactExports.useRef(null);
  const handleSlide = () => {
    var _a3, _b3;
    if ((_a3 = slideRef.current) == null ? void 0 : _a3.classList.contains("item-sliding-active-options-end")) {
      slideClose();
    } else {
      (_b3 = slideRef.current) == null ? void 0 : _b3.open("end");
      setIsOptionsDisabled(false);
    }
  };
  const slideClose = () => {
    var _a3;
    (_a3 = slideRef.current) == null ? void 0 : _a3.close();
    setIsOptionsDisabled(true);
  };
  const handleAction = (action) => (event) => {
    event.stopPropagation();
    onHandleAction == null ? void 0 : onHandleAction({ data, type: action });
  };
  const handleDragMove = (event) => {
    if (event.detail.amount < -30) {
      if (!showCheckbox) {
        setShowCheckbox(true);
      }
      if (!isChecked) {
        setIsChecked(true);
      }
      slideClose();
    } else if (event.detail.amount > 30 && showCheckbox) {
      setShowCheckbox(false);
      setIsChecked(false);
      slideClose();
    }
    if (event.detail.ratio === 1) {
      if (!showCheckbox) {
        setIsOptionsDisabled(false);
      }
    }
  };
  const toggleIsChecked = () => {
    setIsChecked(!isChecked);
  };
  const handleItemDoubleClick = () => {
    if (!showCheckbox) {
      setShowCheckbox(true);
      setIsChecked(true);
    }
  };
  reactExports.useEffect(() => {
    if (!showCheckbox && isChecked !== void 0) {
      setIsChecked(void 0);
    }
  }, [showCheckbox]);
  reactExports.useEffect(() => {
    if (isChecked !== void 0 && isChecked !== isSelected) {
      onHandleAction == null ? void 0 : onHandleAction({ data, type: ItemsActions.Check, isChecked });
    }
  }, [isChecked]);
  reactExports.useEffect(() => {
    if (isChecked !== isSelected) {
      setIsChecked(isSelected);
    }
  }, [isSelected]);
  const bindDouble = c(() => {
    handleItemDoubleClick();
  });
  const bindHold = V(
    showCheckbox ? null : () => {
      handleItemDoubleClick();
    },
    {
      threshold: 300,
      onStart: () => {
        setPreventToggle(true);
      },
      onCancel: () => {
        setTimeout(() => {
          setPreventToggle(false);
        });
      },
      onFinish: () => {
        setTimeout(() => {
          setPreventToggle(false);
        }, 200);
      }
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonItemSliding,
    {
      ref: slideRef,
      onIonDrag: handleDragMove,
      onAnimationEnd: () => console.log("animation end"),
      disabled: showCheckbox,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonItemOptions, { side: "start" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonThumbnail, { slot: "start", ...bindHold(), ...bindDouble, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { alt: "Silhouette of mountains", src: (_a2 = data.image) == null ? void 0 : _a2.url }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { ...bindDouble, children: showCheckbox ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonCheckbox,
            {
              checked: isChecked,
              onIonChange: toggleIsChecked,
              disabled: preventToggle,
              children: (_c2 = (_b2 = data.label) != null ? _b2 : data.id) != null ? _c2 : data.index
            }
          ) }) : (_e2 = (_d2 = data.label) != null ? _d2 : data.id) != null ? _e2 : data.index }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonReorder, { color: "light", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: menuOutline }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { onClick: handleSlide, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonIcon,
            {
              icon: chevronForwardOutline,
              slot: "end",
              role: "img"
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItemOptions, { side: "end", onClick: handleSlide, ref: slideOptionRef, children: [
          (availableActions == null ? void 0 : availableActions.includes(ItemsActions.Edit)) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonItemOption,
            {
              onClick: handleAction(ItemsActions.Edit),
              disabled: isOptionsDisabled,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "icon-only", icon: constructOutline })
            }
          ),
          (availableActions == null ? void 0 : availableActions.includes(ItemsActions.Remove)) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonItemOption,
            {
              onClick: handleAction(ItemsActions.Remove),
              color: "danger",
              disabled: isOptionsDisabled,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "icon-only", icon: trashOutline })
            }
          )
        ] })
      ]
    }
  );
}
const ManageListItem$1 = reactExports.memo(ManageListItem);
function ManageListActions(props) {
  const {
    showCheckbox,
    setShowCheckbox,
    selectedCount = 0,
    totalCount = 0
  } = props;
  const handleShowCheckbox = (show) => () => {
    setShowCheckbox(show);
  };
  const handleAction = (action) => () => {
    var _a2;
    (_a2 = props.handleListAction) == null ? void 0 : _a2.call(props, {
      type: action
      // todo remove any (fix ts)
    });
  };
  const allSelected = showCheckbox && selectedCount > 0 && selectedCount === totalCount;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        color: "light",
        size: "small",
        onClick: handleAction(ListActions.SelectAll),
        disabled: totalCount === 0,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: checkboxOutline, slot: "start" }),
          allSelected ? t("Poni큄ti sve") : t("Selektuj sve")
        ]
      }
    ),
    showCheckbox ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        color: "light",
        onClick: handleShowCheckbox(false),
        size: "small",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline, slot: "start" }),
          t("Zatvori selekciju")
        ]
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        color: "light",
        onClick: handleShowCheckbox(true),
        size: "small",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: squareOutline, slot: "start" }),
          t("Selektuj slike")
        ]
      }
    )
  ] });
}
const ManageListActions$1 = reactExports.memo(ManageListActions);
function List(props) {
  const { handleCallAction } = props;
  const {
    manageItems,
    callAddReorderFromTo,
    callRemoveManageDataItems,
    callSetManageDataItems
  } = props;
  const addNew = props.addNew ? {
    labelKey: "addNew",
    position: "top",
    ...props.addNew
  } : void 0;
  const [items, setItems] = reactExports.useState(manageItems != null ? manageItems : []);
  const [selectedItems, setSelectedItems] = reactExports.useState([]);
  const [showCheckboxes, setShowCheckboxes] = React.useState(false);
  const onSelectionChangeRef = reactExports.useRef(props.onSelectionChange);
  const handleDeleteItems = (selectedItems2) => {
    var _a2;
    if (selectedItems2.length) {
      const localSelected = selectedItems2.filter(
        (item) => item.id === void 0
      );
      const existingSelected = selectedItems2.filter(
        (item) => item.id !== void 0
      );
      if (existingSelected.length) {
        (_a2 = handleCallAction == null ? void 0 : handleCallAction({
          data: existingSelected,
          type: ItemsActions.Remove
        })) == null ? void 0 : _a2.then(() => {
          deleteSelectedItems(selectedItems2);
        });
      } else if (localSelected.length) {
        deleteSelectedItems(localSelected);
      }
    }
  };
  const deleteSelectedItems = (selectedItems2) => {
    callRemoveManageDataItems == null ? void 0 : callRemoveManageDataItems(selectedItems2.map((item) => item.index));
    setSelectedItems([]);
    setShowCheckboxes(false);
  };
  const [presentDeleteItems] = useConfirmationAlert({
    confirmCallback: () => {
      handleDeleteItems(selectedItems);
    }
  });
  const handleAction = (manageDataAction) => {
    switch (manageDataAction.type) {
      case ItemsActions.Remove:
        presentDeleteItems({
          confirmCallback: () => {
            const selectedItems2 = Array.isArray(manageDataAction.data) ? manageDataAction.data : [manageDataAction.data];
            handleDeleteItems(selectedItems2);
          }
        });
        break;
      case ItemsActions.Edit:
        break;
      case ItemsActions.Check:
        toggleSelectedItems(manageDataAction.data, !manageDataAction.isChecked);
        break;
    }
  };
  const handleListAction = (listAction) => {
    switch (listAction.type) {
      case ListActions.Remove:
        presentDeleteItems();
        break;
      case ListActions.SelectAll:
        if (showCheckboxes && selectedItems.length === items.length && items.length > 0) {
          setSelectedItems([]);
        } else {
          setSelectedItems(items);
          setShowCheckboxes(true);
        }
        break;
    }
  };
  const addToSelectedItems = (item, force = false) => {
    if (force || !selectedItems.includes(item)) {
      setSelectedItems((selectedItems2) => [...selectedItems2, item]);
    }
  };
  const removeFromSelectedItems = (item) => {
    setSelectedItems(
      (selectedItems2) => selectedItems2.filter((selectedItem) => selectedItem !== item)
    );
  };
  const toggleSelectedItems = (item, remove) => {
    if (remove && selectedItems.includes(item)) {
      removeFromSelectedItems(item);
    } else if (!remove) {
      addToSelectedItems(item, true);
    }
  };
  reactExports.useEffect(() => {
    setItems(manageItems != null ? manageItems : []);
  }, [manageItems]);
  reactExports.useEffect(() => {
    if (!showCheckboxes && selectedItems.length) {
      setSelectedItems([]);
    }
  }, [showCheckboxes]);
  function handleReorder(event) {
    const from = event.detail.from;
    const to = event.detail.to;
    const itemFrom = items[from];
    const itemTo = items[to];
    if (from !== to) {
      const newItems = ((sortItems) => {
        return arrayMove(sortItems, from, to);
      })(items);
      setItems(newItems);
      setTimeout(() => {
        callSetManageDataItems == null ? void 0 : callSetManageDataItems(newItems);
      });
      if (itemFrom.id && itemTo.id && itemFrom.id !== itemTo.id) {
        callAddReorderFromTo == null ? void 0 : callAddReorderFromTo({ from: itemFrom.id, to: itemTo.id });
      }
    }
    event.detail.complete();
  }
  const AddNewButton = reactExports.useMemo(
    () => addNew && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonButton,
      {
        expand: "full",
        fill: "outline",
        className: "mt-10",
        color: "dark",
        children: t(addNew.labelKey)
      }
    ),
    [addNew]
  );
  reactExports.useEffect(() => {
    onSelectionChangeRef.current = props.onSelectionChange;
  }, [props.onSelectionChange]);
  const handleDeleteClickRef = reactExports.useRef();
  const handleDeleteClick = reactExports.useCallback(() => {
    presentDeleteItems({
      confirmCallback: () => {
        handleDeleteItems(selectedItems);
      }
    });
  }, [selectedItems, presentDeleteItems, handleDeleteItems]);
  reactExports.useEffect(() => {
    handleDeleteClickRef.current = handleDeleteClick;
  }, [handleDeleteClick]);
  reactExports.useEffect(() => {
    var _a2;
    (_a2 = onSelectionChangeRef.current) == null ? void 0 : _a2.call(onSelectionChangeRef, {
      showCheckboxes,
      selectedCount: selectedItems.length,
      onDelete: () => {
        var _a3;
        (_a3 = handleDeleteClickRef.current) == null ? void 0 : _a3.call(handleDeleteClickRef);
      }
    });
  }, [showCheckboxes, selectedItems.length]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ManageListActions$1,
      {
        showCheckbox: showCheckboxes,
        setShowCheckbox: setShowCheckboxes,
        handleListAction,
        selectedCount: selectedItems.length,
        totalCount: items.length
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { children: [
      (addNew == null ? void 0 : addNew.position) === "top" && AddNewButton,
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonReorderGroup, { disabled: false, onIonItemReorder: handleReorder, children: items == null ? void 0 : items.map((sortItemData) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        ManageListItem$1,
        {
          data: sortItemData,
          showCheckbox: showCheckboxes,
          setShowCheckbox: setShowCheckboxes,
          isSelected: selectedItems.includes(sortItemData),
          availableActions: [ItemsActions.Edit, ItemsActions.Remove],
          onHandleAction: handleAction
        },
        sortItemData.sortOrder
      )) }),
      (addNew == null ? void 0 : addNew.position) === "bottom" && AddNewButton
    ] })
  ] });
}
const List$1 = reactExports.memo(List);
function ManageList(props) {
  const dispatch = useManageDataDispatch();
  const manageItems = useManageDataSelector(getManageItems);
  const handAddReorderFromTo = (data) => {
    dispatch(addReorderFromTo(data));
  };
  const handleRemoveManageDataItems = (data) => {
    dispatch(removeManageDataItems(data));
  };
  const handleSetManageDataItems = (data) => {
    dispatch(setManageDataItems(data));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    List$1,
    {
      ...props,
      manageItems,
      callAddReorderFromTo: handAddReorderFromTo,
      callRemoveManageDataItems: handleRemoveManageDataItems,
      callSetManageDataItems: handleSetManageDataItems
    }
  );
}
const ManageList$1 = reactExports.memo(ManageList);
function ManageListModal(props) {
  const { open, manageListProps, onHandleClose } = props;
  const [footerProps, setFooterProps] = reactExports.useState(null);
  const handleClose = () => {
    onHandleClose();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonModal, { isOpen: open, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: t("Upravljanje slikama") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleClose, children: t("Zatvori") }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ManageList$1,
      {
        ...manageListProps,
        onSelectionChange: (props2) => {
          setFooterProps(props2);
        }
      }
    ) }),
    (footerProps == null ? void 0 : footerProps.showCheckboxes) && /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        expand: "block",
        color: "danger",
        disabled: footerProps.selectedCount === 0,
        onClick: footerProps.onDelete,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline, slot: "start" }),
          t("Obri큄i selektovano"),
          " ",
          footerProps.selectedCount > 0 && "(".concat(footerProps.selectedCount, ")")
        ]
      }
    ) }) })
  ] });
}
function SortableImageItem({ photo, index }) {
  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: index });
  const style = {
    transform: CSS.Transform.toString(transform),
    touchAction: "none",
    transition
  };
  const imageUrl = photo.croppedUrls && Object.keys(photo.croppedUrls).length > 0 ? Object.values(photo.croppedUrls)[0] : photo.url;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { ref: setNodeRef, style, ...attributes, ...listeners, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonThumbnail, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { alt: photo.name || "Image ".concat(index + 1), src: imageUrl }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
      photo.name || "Slika ".concat(index + 1),
      photo.id && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        "ID: ",
        photo.id
      ] })
    ] })
  ] });
}
function SortImagesModal({
  open,
  photos,
  onClose,
  onSave
}) {
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates
    }),
    useSensor(TouchSensor)
  );
  const [sortedPhotos, setSortedPhotos] = reactExports.useState(photos);
  const [hasChanges, setHasChanges] = reactExports.useState(false);
  const [isSaving, setIsSaving] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setSortedPhotos(photos);
    setHasChanges(false);
  }, [photos, open]);
  const orderIds = reactExports.useMemo(
    () => sortedPhotos.map((_, index) => index),
    [sortedPhotos]
  );
  const handleDragEnd = (event) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      setSortedPhotos((items) => {
        const oldIndex = active.id;
        const newIndex = over.id;
        return arrayMove(items, oldIndex, newIndex);
      });
      setHasChanges(true);
    }
  };
  const handleSave = async () => {
    var _a2;
    if (!hasChanges) {
      onClose();
      return;
    }
    const reorderData = [];
    const photosWithIds = sortedPhotos.filter((photo) => photo.id);
    for (let i = 0; i < photosWithIds.length; i++) {
      const currentPhoto = photosWithIds[i];
      const originalIndex = photos.findIndex((p) => p.id === currentPhoto.id);
      if (originalIndex !== i && originalIndex !== -1) {
        if (i > 0) {
          const previousPhoto = photosWithIds[i - 1];
          if (previousPhoto == null ? void 0 : previousPhoto.id) {
            reorderData.push({
              from: Number(currentPhoto.id),
              to: Number(previousPhoto.id)
            });
          }
        } else {
          const originalPreviousIndex = originalIndex - 1;
          if (originalPreviousIndex >= 0 && ((_a2 = photos[originalPreviousIndex]) == null ? void 0 : _a2.id)) {
            reorderData.push({
              from: Number(currentPhoto.id),
              to: Number(photos[originalPreviousIndex].id)
            });
          }
        }
      }
    }
    if (reorderData.length > 0) {
      setIsSaving(true);
      try {
        await onSave(reorderData);
        setHasChanges(false);
        onClose();
      } catch (error) {
        console.error("Error saving sort order:", error);
      } finally {
        setIsSaving(false);
      }
    } else {
      onClose();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonModal, { isOpen: open, onDidDismiss: onClose, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: t("Sortiraj slike") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      DndContext,
      {
        sensors,
        collisionDetection: closestCenter,
        onDragEnd: handleDragEnd,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SortableContext,
          {
            items: orderIds,
            strategy: verticalListSortingStrategy,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonList, { children: sortedPhotos.map((photo, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              SortableImageItem,
              {
                photo,
                index
              },
              photo.id || index
            )) })
          }
        )
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: onClose, disabled: isSaving, children: t("Otka탑i") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          onClick: handleSave,
          disabled: isSaving || !hasChanges && sortedPhotos.length < 2,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: checkmarkOutline, slot: "start" }),
            isSaving ? t("훻uvanje...") : t("Sa훾uvaj")
          ]
        }
      ) })
    ] }) })
  ] });
}
function useOnReorder(props) {
  const { callReorderApi, callReorderApiResult } = props;
  const itemsReorderFromTo = useManageDataSelector(getItemsReorderFromTo);
  const debounce = 1500;
  const dispatch = useManageDataDispatch();
  const [toggleReorderDataCheck, setToggleReorderDataCheck] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const callReorder = () => {
      if (itemsReorderFromTo && itemsReorderFromTo.length && !(callReorderApiResult == null ? void 0 : callReorderApiResult.isLoading)) {
        return setTimeout(() => {
          var _a2;
          (_a2 = callReorderApi == null ? void 0 : callReorderApi(itemsReorderFromTo)) == null ? void 0 : _a2.then((response) => {
            if ("data" in response) {
              if (response.data.success) {
                setToggleReorderDataCheck(!toggleReorderDataCheck);
              }
            }
          });
          dispatch(resetReorderFromTo());
        }, debounce);
      }
      return void 0;
    };
    const timeout = callReorder();
    return () => timeout ? clearTimeout(timeout) : void 0;
  }, [itemsReorderFromTo, toggleReorderDataCheck]);
}
const resizeImageToFullHD = async (file) => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      reject(new Error("Could not get canvas context"));
      return;
    }
    img.onload = () => {
      const { width, height } = img;
      const maxWidth = 1920;
      const maxHeight = 1080;
      let newWidth = width;
      let newHeight = height;
      if (width > maxWidth || height > maxHeight) {
        const aspectRatio = width / height;
        if (width > height) {
          newWidth = Math.min(width, maxWidth);
          newHeight = newWidth / aspectRatio;
          if (newHeight > maxHeight) {
            newHeight = maxHeight;
            newWidth = newHeight * aspectRatio;
          }
        } else {
          newHeight = Math.min(height, maxHeight);
          newWidth = newHeight * aspectRatio;
          if (newWidth > maxWidth) {
            newWidth = maxWidth;
            newHeight = newWidth / aspectRatio;
          }
        }
      }
      canvas.width = newWidth;
      canvas.height = newHeight;
      ctx.drawImage(img, 0, 0, newWidth, newHeight);
      canvas.toBlob(
        (blob) => {
          if (blob) {
            const resizedFile = new File([blob], file.name, {
              type: file.type,
              lastModified: file.lastModified
            });
            resolve(resizedFile);
          } else {
            reject(new Error("Could not create blob from canvas"));
          }
        },
        file.type,
        0.9
        // Quality (0.9 = 90%)
      );
    };
    img.onerror = () => {
      reject(new Error("Could not load image"));
    };
    img.src = URL.createObjectURL(file);
  });
};
const resizeImagesToFullHD = async (files) => {
  const resizePromises = files.map((file) => resizeImageToFullHD(file));
  return Promise.all(resizePromises);
};
function PhotoUploader(props) {
  var _a2, _b2;
  const { error, label } = props;
  const { register: register2, control } = props;
  const [isManageListModalOpen, setIsManageListModalOpen] = React.useState(false);
  const [isSortModalOpen, setIsSortModalOpen] = React.useState(false);
  const {
    handleAddedPhotos,
    handleReorderImages,
    handleRemovedPhotos,
    handleUploadImages
  } = props.handlers;
  const handleOnSortAction = () => {
    setIsSortModalOpen(true);
  };
  const handleSortSave = async (reorderData) => {
    if (handleReorderImages) {
      await handleReorderImages(reorderData);
    }
  };
  const { reorderImagesResult, photos } = props;
  const { oneImage, cropAspectRatio } = props;
  const maxPhotos = oneImage ? 1 : (_a2 = props.maxPhotos) != null ? _a2 : 20;
  const maxSize = (_b2 = props.maxSize) != null ? _b2 : 10 * 1024 * 1024;
  const photoEditorRef = reactExports.useRef(null);
  const fileInputRef = reactExports.useRef(null);
  const dispatch = useManageDataDispatch();
  const manageDataItems = useManageDataSelector(getManageItems);
  const maxSortOrder = useManageDataSelector(manageItemsMaxSortOrder);
  const images = reactExports.useMemo(
    () => {
      var _a3;
      return (_a3 = manageDataItems == null ? void 0 : manageDataItems.map((manageDataItem) => manageDataItem.image)) != null ? _a3 : [];
    },
    [manageDataItems]
  );
  useOnReorder({
    callReorderApi: handleReorderImages,
    callReorderApiResult: reorderImagesResult
  });
  const handleSelectFile = async () => {
    var _a3, _b3, _c2, _d2;
    let files = Object.values((_b3 = (_a3 = fileInputRef == null ? void 0 : fileInputRef.current) == null ? void 0 : _a3.files) != null ? _b3 : []);
    const imagesLength = oneImage ? 0 : images.length;
    if (files.length && imagesLength + files.length <= maxPhotos) {
      files = files.slice(0, maxPhotos - imagesLength);
      try {
        const resizedFiles = await resizeImagesToFullHD(files);
        const manageDataItems2 = [
          ...Object.values(resizedFiles).map((file, index) => ({
            sortOrder: maxSortOrder + index + 1,
            index: imagesLength + index,
            image: {
              index: imagesLength + index,
              name: file.name,
              url: URL.createObjectURL(file)
            },
            label: file.name
          }))
        ];
        if (oneImage) {
          dispatch(setManageDataItems(manageDataItems2));
        } else {
          dispatch(addManageDataItems(manageDataItems2));
        }
        (_c2 = photoEditorRef == null ? void 0 : photoEditorRef.current) == null ? void 0 : _c2.setGalleryStep(imagesLength);
        setTimeout(() => {
          var _a4, _b4, _c3;
          handleAddedPhotos == null ? void 0 : handleAddedPhotos(resizedFiles, maxSortOrder);
          if ((_a4 = fileInputRef.current) == null ? void 0 : _a4.files) {
            fileInputRef.current.value = "";
          }
          (_c3 = (_b4 = photoEditorRef == null ? void 0 : photoEditorRef.current) == null ? void 0 : _b4.handleAutoCrop) == null ? void 0 : _c3.call(_b4);
        });
      } catch (error2) {
        console.error("Error resizing images:", error2);
        const manageDataItems2 = [
          ...Object.values(files).map((file, index) => ({
            sortOrder: maxSortOrder + index + 1,
            index: imagesLength + index,
            image: {
              index: imagesLength + index,
              name: file.name,
              url: URL.createObjectURL(file)
            },
            label: file.name
          }))
        ];
        if (oneImage) {
          dispatch(setManageDataItems(manageDataItems2));
        } else {
          dispatch(addManageDataItems(manageDataItems2));
        }
        (_d2 = photoEditorRef == null ? void 0 : photoEditorRef.current) == null ? void 0 : _d2.setGalleryStep(imagesLength);
        setTimeout(() => {
          var _a4, _b4, _c3;
          handleAddedPhotos == null ? void 0 : handleAddedPhotos(files, maxSortOrder);
          if ((_a4 = fileInputRef.current) == null ? void 0 : _a4.files) {
            fileInputRef.current.value = "";
          }
          (_c3 = (_b4 = photoEditorRef == null ? void 0 : photoEditorRef.current) == null ? void 0 : _b4.handleAutoCrop) == null ? void 0 : _c3.call(_b4);
        });
      }
    }
  };
  const handleAddPhotos = () => {
    setTimeout(() => {
      var _a3;
      return (_a3 = fileInputRef == null ? void 0 : fileInputRef.current) == null ? void 0 : _a3.click();
    }, 200);
  };
  const canAddPhotos = oneImage || images.length < maxPhotos;
  const oneImageAddPhotoTitle = images.length ? t("Izmeni sliku") : t("Dodaj sliku");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          ref: fileInputRef,
          hidden: true,
          type: "file",
          accept: "image/*",
          multiple: !oneImage,
          onChange: handleSelectFile
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { className: "actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "start", className: "pl-4", children: label }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonButton,
          {
            color: "medium",
            onClick: handleAddPhotos,
            disabled: !canAddPhotos,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline }),
              oneImage ? oneImageAddPhotoTitle : t("Dodaj slike")
            ]
          }
        ) })
      ] }) }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { position: "relative" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => {
          const photosWithoutId = (field.value || []).filter(
            (photo) => !(photo == null ? void 0 : photo.id) || photo.id === null || photo.id === void 0
          );
          const pendingUploadCount = photosWithoutId.length;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            PhotoEditor$1,
            {
              ref: photoEditorRef,
              galleryProps: {
                handleOnManageAction: () => {
                  setIsManageListModalOpen(true);
                },
                handleOnSortAction,
                handleRemoveImages: handleRemovedPhotos,
                maxSize,
                pendingUploadCount,
                onUploadClick: async () => {
                  if (pendingUploadCount > 0 && handleUploadImages) {
                    await handleUploadImages();
                  }
                }
              },
              photos,
              onChangedPhotos: field.onChange,
              photoAspectRatio: cropAspectRatio
            }
          );
        }
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ManageListModal,
      {
        open: isManageListModalOpen,
        onHandleClose: () => setIsManageListModalOpen(false),
        manageListProps: {
          handleCallAction: (manageDataAction) => {
            switch (manageDataAction.type) {
              case ItemsActions.Remove: {
                const images2 = Array.isArray(manageDataAction.data) ? manageDataAction.data.map((item) => item.image) : [manageDataAction.data.image];
                if (images2.length) {
                  return new Promise((resolve) => {
                    var _a3;
                    (_a3 = handleRemovedPhotos == null ? void 0 : handleRemovedPhotos(images2)) == null ? void 0 : _a3.then(() => {
                      resolve();
                    });
                  });
                }
                break;
              }
            }
          }
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SortImagesModal,
      {
        open: isSortModalOpen,
        photos: photos || [],
        onClose: () => setIsSortModalOpen(false),
        onSave: handleSortSave
      }
    )
  ] });
}
const PhotoUploader$1 = withManageDataWrapper(PhotoUploader);
let appTimezone = "Europe/Belgrade";
const utcTimezone = "UTC";
let cachedDate = null;
let cachedHour = -1;
const setAppTimezone = (timezone) => {
  appTimezone = timezone;
};
const getAppTimezone = () => {
  return appTimezone;
};
const getCurrentDateString = (tz) => {
  const timezone = tz || getAppTimezone();
  const now = /* @__PURE__ */ new Date();
  const currentHour = now.getHours();
  if (cachedDate && cachedHour === currentHour) {
    return cachedDate;
  }
  const dateInTimezone = formatInTimeZone(now, timezone, "yyyy-MM-dd");
  cachedDate = dateInTimezone;
  cachedHour = currentHour;
  return cachedDate;
};
const toUtc = (timeString, tz) => {
  const timezone = getAppTimezone();
  const today = /* @__PURE__ */ new Date();
  const timeParts = timeString.split(":");
  const hours = parseInt(timeParts[0], 10);
  const minutes = parseInt(timeParts[1], 10);
  const seconds = timeParts[2] ? parseInt(timeParts[2], 10) : 0;
  const localDateTime = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate(),
    hours,
    minutes,
    seconds
  );
  const utcDateTime = fromZonedTime(localDateTime, timezone);
  return formatInTimeZone(utcDateTime, utcTimezone, "HH:mm:ss");
};
const fromUtc = (utcTimeString, tz) => {
  const timezone = getAppTimezone();
  const currentDate = getCurrentDateString(timezone);
  const utcDate = parseISO("".concat(currentDate, "T").concat(utcTimeString, "Z"));
  return formatInTimeZone(utcDate, timezone, "HH:mm:ss");
};
const fromUtcHM = (utcTimeString, tz) => {
  const timezone = getAppTimezone();
  const timeWithSeconds = utcTimeString.split(":").length === 2 ? "".concat(utcTimeString, ":00") : utcTimeString;
  const currentDateUtc = getCurrentDateString(timezone);
  const utcDate = parseISO("".concat(currentDateUtc, "T").concat(timeWithSeconds, "Z"));
  return formatInTimeZone(utcDate, timezone, "HH:mm");
};
const toLocalISOStringForIonDatetime = (utcDateTimeString, tz) => {
  const timezone = getAppTimezone();
  const utcDate = parseISO(utcDateTimeString);
  const localDate = toZonedTime(utcDate, timezone);
  return localDate.toISOString();
};
const fromUtcDateTimeToTime = (utcDateTime, tz) => {
  const timezone = getAppTimezone();
  const localDate = toZonedTime(utcDateTime, timezone);
  return format(localDate, "HH:mm");
};
const parseUtcDate = (utcDateString, tz) => {
  const dateUtc = parseISO(utcDateString);
  if (!tz) {
    const dateFormatted2 = formatInTimeZone(dateUtc, utcTimezone, "yyyy-MM-dd");
    return { date: dateUtc, dateFormatted: dateFormatted2 };
  }
  const timezone = tz;
  const dateInTz = toZonedTime(dateUtc, timezone);
  const dateFormatted = formatInTimeZone(dateUtc, timezone, "yyyy-MM-dd");
  return { date: dateInTz, dateFormatted };
};
const getUtcDateFormattedInTz = (utcDateString, tz) => {
  const timezone = getAppTimezone();
  const parsedDate = parseISO(utcDateString);
  return formatInTimeZone(parsedDate, timezone, "yyyy-MM-dd");
};
const daysOfWeek = {
  mon: {
    label: "Pon",
    key: "mon"
  },
  tue: {
    label: "Uto",
    key: "tue",
    prevKey: "mon"
  },
  wed: {
    label: "Sre",
    key: "wed",
    prevKey: "tue"
  },
  thu: {
    label: "훻et",
    key: "thu",
    prevKey: "wed"
  },
  fri: {
    label: "Pet",
    key: "fri",
    prevKey: "thu"
  },
  sat: {
    label: "Sub",
    key: "sat",
    prevKey: "fri"
  },
  sun: {
    label: "Ned",
    key: "sun",
    prevKey: "sat",
    color: "danger"
  }
};
const defaultWorkTimeFrom = "2023-01-01T09:00:00";
const defaultWorkTimeTo = "2023-01-01T22:00:00";
const dayOfWeeksValues = Object.values(daysOfWeek);
const getSelectedWorkingHoursLabel = (selectedDays) => {
  const daysOfWeekArr = dayOfWeeksValues;
  let firstDay;
  let lastDay;
  const selectedDaysFormatted = [];
  const appendFirstAndLastDay = (firstDay2, lastDay2) => {
    const firstDayLabel = daysOfWeek[firstDay2].label;
    const lastDayLabel = daysOfWeek[lastDay2].label;
    if (firstDay2 === lastDay2) {
      selectedDaysFormatted.push(firstDayLabel);
    } else if (firstDay2 !== daysOfWeek[lastDay2].prevKey) {
      selectedDaysFormatted.push("".concat(firstDayLabel, " - ").concat(lastDayLabel));
    } else {
      selectedDaysFormatted.push(firstDayLabel, lastDayLabel);
    }
  };
  daysOfWeekArr.forEach((day) => {
    if (selectedDays.includes(day.key)) {
      if (!firstDay) {
        firstDay = day.key;
        lastDay = day.key;
      } else if (lastDay === day.prevKey) {
        lastDay = day.key;
      }
    } else if (firstDay && lastDay) {
      appendFirstAndLastDay(firstDay, lastDay);
      firstDay = lastDay = void 0;
    }
  });
  if (firstDay && lastDay) {
    appendFirstAndLastDay(firstDay, lastDay);
  }
  return selectedDaysFormatted.join(", ");
};
const formatWorkingTime = (workingTime) => workingTime ? format(parseISO(workingTime), "HH:mm") : void 0;
const timeToDateTime = (time) => {
  const date = parseISO(time);
  if (isValid(date)) {
    return time;
  }
  const currentTime = /* @__PURE__ */ new Date();
  const [hours, minutes] = time.split(":");
  currentTime.setHours(Number(hours));
  currentTime.setMinutes(Number(minutes));
  return format(currentTime, "yyyy-MM-dd'T'HH:mm:ss");
};
const dateTimeToTime = (dateTime) => {
  const date = parseISO(dateTime);
  if (isValid(date)) {
    return format(date, "HH:mm:ss");
  }
  return dateTime;
};
const isWebPlatform = isPlatform("desktop");
const isIos = isPlatform("ios");
const isPwa = isPlatform("pwa");
isPlatform("capacitor");
const getIsWebview = (userAgent) => {
  return /webview|wv|ip((?!.*Safari)|(?=.*like Safari))/i.test(userAgent);
};
const tabPosition = isWebPlatform ? "top" : "bottom";
const isWebView = (window == null ? void 0 : window.navigator) && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) ? getIsWebview(window.navigator.userAgent) : true;
const ionIconList = [];
const ionIcons = {};
const fetchIonIconsList = () => {
  if (!ionIconList.length) {
    ionIconList.push(
      ...Object.keys(icons).map((name, index) => {
        ionIcons[name] = {
          value: icons[name],
          key: name,
          index
        };
        return ionIcons[name];
      })
    );
  }
  return ionIconList;
};
const getIonIconByName = (name) => {
  if (!ionIconList.length) {
    fetchIonIconsList();
  }
  return ionIcons[name];
};
const generateSlug = (str) => {
  str = str.replace(/^\s+|\s+$/g, "");
  str = str.toLowerCase();
  const from = "횪찼채창챔챕챘챗챙챠챦챤챵처철척첫첬체청챰챌훾훶휃큄탑쨌/_,:;";
  const to = "aaaaeeeeiiiioooouuuuncccdsz------";
  for (let i = 0, l2 = from.length; i < l2; i++) {
    str = str.replace(new RegExp(from.charAt(i), "g"), to.charAt(i));
  }
  str = str.replace(/[^a-z0-9 -]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-");
  return str;
};
function DataURIToBlob(dataURI) {
  const splitDataURI = dataURI.split(",");
  const byteString = splitDataURI[0].indexOf("base64") >= 0 ? atob(splitDataURI[1]) : decodeURI(splitDataURI[1]);
  const mimeString = splitDataURI[0].split(":")[1].split(";")[0];
  const ia = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
  return new Blob([ia], { type: mimeString });
}
function createFormData(body, files) {
  const form = new FormData();
  const bodyKeys = Object.keys(body);
  bodyKeys.forEach((key) => {
    const item = body[key];
    if (files[key] && typeof item === "string") {
      const file = DataURIToBlob(item);
      form.append(key, file, files[key]);
    } else {
      form.append(key, item);
    }
  });
  return form;
}
const userHasRoles = (user, roles, all = false) => {
  var _a2;
  const userGroups = (_a2 = user.groups) == null ? void 0 : _a2.map((group) => group.code);
  return all ? roles.every((role) => userGroups == null ? void 0 : userGroups.includes(role)) : roles.some((role) => userGroups == null ? void 0 : userGroups.includes(role));
};
function useDefaultProps(props, defaultProps2) {
  return {
    ...defaultProps2,
    ...props
  };
}
const fixUrlPath = (url) => url[url.length - 1] !== "/" ? url : url.slice(0, url.length - 1);
const useAppDispatch$1 = () => useDispatch();
const useAppSelector$1 = useSelector;
const commonSharedApi = sharedApi.injectEndpoints({
  endpoints: (build) => ({
    uploadFile: build.mutation({
      query: (body) => ({
        url: body.meta.apiUrl,
        method: "POST",
        body: body.data
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    deleteFile: build.mutation({
      query: ({ apiUrl, attachmentId, ...rest }) => ({
        url: apiUrl,
        method: "DELETE",
        body: { attachmentId, ...rest }
        // Include all additional requestData
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    reorderFile: build.mutation({
      query: ({ apiUrl, reorderData, ...rest }) => ({
        url: apiUrl,
        method: "POST",
        body: { reorderData, ...rest }
        // Include all additional requestData
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    getCountries: build.query({
      query: () => ({
        url: "/countries"
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    getCities: build.query({
      query: (params) => ({
        url: "".concat(sharedApiPrefix, "/cities"),
        params: params != null ? params : {}
      }),
      transformResponse: transformStandardResponseToCamelCase
    })
  })
});
const {
  useUploadFileMutation,
  useDeleteFileMutation,
  useReorderFileMutation
} = commonSharedApi;
const useShowNotification = (options) => {
  const [presentToast, dismiss] = useIonToast();
  const memoOptions = reactExports.useMemo(() => options, []);
  const showNotification = reactExports.useCallback(
    (overrideOptions) => {
      return presentToast({
        position: "bottom",
        duration: 1500,
        ...memoOptions,
        ...overrideOptions
      });
    },
    [presentToast, memoOptions]
  );
  return [showNotification, dismiss];
};
const useFileUploader = (uploadRequestData, callbacks, alertOptions) => {
  const [presentLoader, dismiss] = useIonLoading();
  const [showNotification] = useShowNotification();
  const hasShownErrorRef = reactExports.useRef(false);
  const [filesDataToUpload, setFilesDataToUpload] = reactExports.useState([]);
  const [currentFileIndex, setCurrentFileIndex] = reactExports.useState(
    void 0
  );
  const [retryCount, setRetryCount] = reactExports.useState(0);
  const [fileKey, setFileKey] = reactExports.useState("file");
  const [isUploading, setIsUploading] = reactExports.useState(false);
  const retryCountLimit = 10;
  const { apiUrl, uploadType, bodyData, skipUpload } = uploadRequestData;
  const [uploadFile, uploadFileResult] = useUploadFileMutation();
  const { data, isSuccess, isError } = uploadFileResult;
  const setFiles = (files, fileKey2) => {
    setFilesDataToUpload(files != null ? files : []);
    if (fileKey2) {
      setFileKey(fileKey2);
    }
  };
  const handleUploadFile = async () => {
    if (apiUrl && uploadType && currentFileIndex !== void 0 && !skipUpload) {
      uploadFile({
        meta: {
          apiUrl,
          uploadType
        },
        data: createFormData(
          {
            ...bodyData,
            ...filesDataToUpload[currentFileIndex]
          },
          { [fileKey]: fileKey + currentFileIndex }
        )
      });
    }
  };
  const resetUploader = () => {
    setCurrentFileIndex(void 0);
    setFilesDataToUpload([]);
    setRetryCount(0);
    setIsUploading(false);
    hasShownErrorRef.current = false;
    dismiss();
  };
  reactExports.useEffect(() => {
    if (filesDataToUpload.length && !isUploading) {
      setIsUploading(true);
      presentLoader({
        message: "Uploading files..."
      });
      setCurrentFileIndex(0);
    }
  }, [filesDataToUpload, isUploading]);
  reactExports.useEffect(() => {
    if (currentFileIndex === void 0) {
      return;
    }
    if (currentFileIndex < filesDataToUpload.length) {
      handleUploadFile();
    }
  }, [currentFileIndex]);
  reactExports.useEffect(() => {
    var _a2, _b2, _c2;
    if (isSuccess && data) {
      if (currentFileIndex !== void 0 && currentFileIndex < filesDataToUpload.length - 1) {
        (_a2 = callbacks == null ? void 0 : callbacks.onUploadSuccessful) == null ? void 0 : _a2.call(
          callbacks,
          filesDataToUpload[currentFileIndex],
          data.data
        );
        setCurrentFileIndex(currentFileIndex + 1);
      } else {
        if (currentFileIndex !== void 0) {
          (_b2 = callbacks == null ? void 0 : callbacks.onUploadSuccessful) == null ? void 0 : _b2.call(
            callbacks,
            filesDataToUpload[currentFileIndex],
            data.data
          );
        }
        (_c2 = callbacks == null ? void 0 : callbacks.onSuccessful) == null ? void 0 : _c2.call(callbacks);
        resetUploader();
      }
    } else if (isSuccess && retryCount < retryCountLimit) {
      handleUploadFile();
      setRetryCount(retryCount + 1);
    }
  }, [isSuccess, uploadFileResult, retryCount]);
  reactExports.useEffect(() => {
    var _a2;
    if (isError && !hasShownErrorRef.current) {
      hasShownErrorRef.current = true;
      resetUploader();
      showNotification({
        message: t("Gre큄ka pri upload-u") || "Error uploading",
        color: "danger",
        duration: 3e3
      });
      (_a2 = callbacks == null ? void 0 : callbacks.onError) == null ? void 0 : _a2.call(callbacks);
    }
  }, [isError, t, showNotification]);
  return { setFiles };
};
const useFileDeleter = (deleteRequestData, callbacks, alertOptions) => {
  const [presentLoader, dismiss] = useIonLoading();
  const [showNotification] = useShowNotification();
  const hasShownErrorRef = reactExports.useRef(false);
  const [photosToDelete, setPhotosToDelete] = reactExports.useState([]);
  const [currentPhotoIndex, setCurrentPhotoIndex] = reactExports.useState(void 0);
  const [retryCount, setRetryCount] = reactExports.useState(0);
  const [isDeleting, setIsDeleting] = reactExports.useState(false);
  const retryCountLimit = 10;
  const { apiUrl, deleteRequestData: requestData } = deleteRequestData;
  const [deleteFile, deleteFileResult] = useDeleteFileMutation();
  const { data, isSuccess, isError } = deleteFileResult;
  const deletePhotos = (photoIds) => {
    setPhotosToDelete(photoIds != null ? photoIds : []);
  };
  const handleDeleteFile = async () => {
    if (apiUrl && currentPhotoIndex !== void 0) {
      deleteFile({
        apiUrl,
        attachmentId: photosToDelete[currentPhotoIndex],
        ...requestData || {}
      });
    }
  };
  const resetDeleter = () => {
    setCurrentPhotoIndex(void 0);
    setPhotosToDelete([]);
    setRetryCount(0);
    setIsDeleting(false);
    hasShownErrorRef.current = false;
    dismiss();
  };
  reactExports.useEffect(() => {
    if (photosToDelete.length && !isDeleting) {
      setIsDeleting(true);
      presentLoader({
        message: "Deleting files..."
      });
      setCurrentPhotoIndex(0);
    }
  }, [photosToDelete, isDeleting]);
  reactExports.useEffect(() => {
    if (currentPhotoIndex === void 0) {
      return;
    }
    if (currentPhotoIndex < photosToDelete.length) {
      handleDeleteFile();
    }
  }, [currentPhotoIndex]);
  reactExports.useEffect(() => {
    var _a2, _b2, _c2;
    if (isSuccess && data) {
      if (currentPhotoIndex !== void 0 && currentPhotoIndex < photosToDelete.length - 1) {
        (_a2 = callbacks == null ? void 0 : callbacks.onDeleteSuccessful) == null ? void 0 : _a2.call(callbacks, photosToDelete[currentPhotoIndex]);
        setCurrentPhotoIndex(currentPhotoIndex + 1);
      } else {
        if (currentPhotoIndex !== void 0) {
          (_b2 = callbacks == null ? void 0 : callbacks.onDeleteSuccessful) == null ? void 0 : _b2.call(callbacks, photosToDelete[currentPhotoIndex]);
        }
        (_c2 = callbacks == null ? void 0 : callbacks.onSuccessful) == null ? void 0 : _c2.call(callbacks);
        resetDeleter();
      }
    } else if (isSuccess && retryCount < retryCountLimit) {
      handleDeleteFile();
      setRetryCount(retryCount + 1);
    }
  }, [isSuccess, deleteFileResult, retryCount]);
  reactExports.useEffect(() => {
    var _a2;
    if (isError && !hasShownErrorRef.current) {
      hasShownErrorRef.current = true;
      resetDeleter();
      showNotification({
        message: t("Gre큄ka pri brisanju") || "Error deleting",
        color: "danger",
        duration: 3e3
      });
      (_a2 = callbacks == null ? void 0 : callbacks.onError) == null ? void 0 : _a2.call(callbacks);
    }
  }, [isError, t, showNotification]);
  return { deletePhotos };
};
function GalleryArea({
  field,
  register: register2,
  control,
  error,
  form
}) {
  const { t: t2 } = useTranslation();
  const [showNotification] = useShowNotification();
  const [reorderFile] = useReorderFileMutation();
  const [photos, setPhotos] = reactExports.useState(field.photos || []);
  const [pendingFiles, setPendingFiles] = reactExports.useState([]);
  const [isUploading, setIsUploading] = reactExports.useState(false);
  const uploadValidationFieldName = "_upload_" + register2.name;
  form == null ? void 0 : form.watch(register2.name);
  form ? useWatch({ control: form.control, name: uploadValidationFieldName }) : null;
  form == null ? void 0 : form.formState.errors;
  const { setFiles } = useFileUploader(
    {
      apiUrl: field.uploadUrl,
      uploadType: UploadType.PHOTO,
      bodyData: field.uploadRequestData
      // Merge requestData with upload data
    },
    {
      onUploadSuccessful: (file, uploadedPhoto) => {
        var _a2;
        const newPhoto = {
          id: uploadedPhoto.id,
          url: uploadedPhoto.path,
          name: uploadedPhoto.fileName,
          index: 0
        };
        if (field.oneImage) {
          setPhotos([newPhoto]);
        } else {
          setPhotos((prev) => [...prev, newPhoto]);
        }
        setPendingFiles((prev) => prev.filter((f) => f !== file));
        setIsUploading(false);
        (_a2 = field.onUploadSuccess) == null ? void 0 : _a2.call(field, newPhoto);
      },
      onError: (error2) => {
        var _a2, _b2;
        setIsUploading(false);
        const errorMessage = ((_a2 = error2 == null ? void 0 : error2.data) == null ? void 0 : _a2.message) || (error2 == null ? void 0 : error2.message) || "Upload failed";
        (_b2 = field.onUploadError) == null ? void 0 : _b2.call(field, errorMessage);
      }
    }
  );
  const { deletePhotos } = useFileDeleter(
    {
      apiUrl: field.deleteUrl || "",
      deleteRequestData: field.deleteRequestData
      // Merge requestData with delete data
    },
    {
      onDeleteSuccessful: (photoId) => {
        var _a2;
        setPhotos((prev) => prev.filter((p) => p.id !== photoId));
        (_a2 = field.onDeleteSuccess) == null ? void 0 : _a2.call(field, photoId);
      },
      onError: () => {
        var _a2;
        (_a2 = field.onDeleteError) == null ? void 0 : _a2.call(field, new Error("Delete failed"));
      }
    }
  );
  const handleAddedPhotos = reactExports.useCallback(
    (files) => {
      if (field.uploadBehavior === "immediate") {
        setIsUploading(true);
        setFiles(files.map((file) => ({ file })));
      } else {
        setPendingFiles((prev) => [...prev, ...files]);
      }
    },
    [field.uploadBehavior, setFiles]
  );
  const handleRemovedPhotos = reactExports.useCallback(
    async (photosToRemove) => {
      const photosWithIds = photosToRemove.filter((photo) => photo.id);
      const photosWithoutIds = photosToRemove.filter((photo) => !photo.id);
      photosWithoutIds.forEach((photo) => {
        setPendingFiles(
          (prev) => prev.filter((_, index) => index !== photosToRemove.indexOf(photo))
        );
      });
      if (photosWithIds.length > 0) {
        deletePhotos(photosWithIds.map((photo) => Number(photo.id)));
      }
    },
    [deletePhotos]
  );
  const handleReorderImages = reactExports.useCallback(
    async (reorderData) => {
      var _a2, _b2, _c2;
      try {
        if (field.reorderUrl && reorderData.length > 0) {
          const response = await reorderFile({
            apiUrl: field.reorderUrl,
            reorderData,
            ...field.reorderRequestData || {}
          }).unwrap();
          if (response == null ? void 0 : response.data) {
            const updatedPhotos = Array.isArray(response.data) ? response.data.map((photo, index) => ({
              id: photo.id,
              url: photo.path || photo.url,
              name: photo.fileName || photo.name,
              index
            })) : photos;
            setPhotos(updatedPhotos);
            (_a2 = field.onReorderSuccess) == null ? void 0 : _a2.call(field, updatedPhotos);
          } else {
            (_b2 = field.onReorderSuccess) == null ? void 0 : _b2.call(field, photos);
          }
        }
      } catch (error2) {
        showNotification({
          message: t2("Gre큄ka pri sortiranju slika") || "Error reordering images",
          color: "danger",
          duration: 3e3
        });
        (_c2 = field.onReorderError) == null ? void 0 : _c2.call(
          field,
          error2 instanceof Error ? error2 : new Error(String(error2))
        );
      }
    },
    [
      field.reorderUrl,
      field.reorderRequestData,
      field.onReorderSuccess,
      field.onReorderError,
      showNotification,
      t2,
      photos,
      reorderFile
    ]
  );
  const uploadPendingFiles = reactExports.useCallback(async () => {
    var _a2;
    if (form && pendingFiles.length > 0) {
      setIsUploading(true);
      const formPhotos = form.getValues(register2.name);
      const photosToUpload = ((_a2 = formPhotos == null ? void 0 : formPhotos.filter((photo) => !photo.id)) == null ? void 0 : _a2.map((photo) => ({
        file: photo.url,
        // This is already the cropped image URL
        fileAfterId: photo.fileAfterId
      }))) || [];
      if (photosToUpload.length > 0) {
        setFiles(photosToUpload);
      }
      return new Promise((resolve) => {
        const checkUpload = () => {
          if (pendingFiles.length === 0) {
            resolve();
          } else {
            setTimeout(checkUpload, 100);
          }
        };
        checkUpload();
      });
    }
  }, [pendingFiles, setFiles, form, register2.name]);
  const handlers = reactExports.useMemo(
    () => ({
      handleAddedPhotos: (files, startIndex) => {
        handleAddedPhotos(files);
      },
      handleRemovedPhotos: async (images) => {
        await handleRemovedPhotos(images);
        return { data: { data: null, success: true } };
      },
      handleReorderImages: async (reorderData) => {
        await handleReorderImages(reorderData);
        return { data: { data: null, success: true } };
      },
      handleUploadImages: async () => {
        await uploadPendingFiles();
      }
    }),
    [
      handleAddedPhotos,
      handleRemovedPhotos,
      handleReorderImages,
      uploadPendingFiles
    ]
  );
  reactExports.useEffect(() => {
    if (form && pendingFiles.length > 0 && (form == null ? void 0 : form.formState.isValidating)) {
      uploadPendingFiles();
    }
  }, [
    form == null ? void 0 : form.formState.isSubmitting,
    field.uploadBehavior,
    pendingFiles.length
    // Removed uploadPendingFiles from dependencies to prevent infinite loop
  ]);
  reactExports.useEffect(() => {
    if (field.onFormSave) {
      field.onFormSave();
    }
  }, [field.onFormSave]);
  reactExports.useEffect(() => {
    if (field.onFormError && error) {
      field.onFormError({ [register2.name]: error.message });
    }
  }, [field.onFormError, error, register2.name]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    PhotoUploader$1,
    {
      label: field.label,
      register: register2,
      error,
      control,
      handlers,
      photos,
      oneImage: field.oneImage,
      maxPhotos: field.maxPhotos,
      maxSize: field.maxSize,
      cropAspectRatio: field.cropAspectRatio
    }
  );
}
function CommonIonicTextarea(props) {
  const { label, labelPlacement = "floating", register: register2, error } = props;
  const { itemProps, inputProps, control } = props;
  const { maxlength, rows, translation } = props;
  const handleKeyPress = (event) => {
    if (props.preventEnter && event.key === "Enter") {
      event.preventDefault();
    }
  };
  const textAreaRef = reactExports.useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { ...itemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonTextarea,
          {
            ref: textAreaRef,
            label,
            labelPlacement,
            onIonInput: (event) => field.onChange(event),
            onIonBlur: field.onBlur,
            onKeyPress: handleKeyPress,
            onIonChange: register2.onBlur,
            value: field.value,
            autoGrow: true,
            counter: !!maxlength,
            maxlength,
            rows: rows != null ? rows : 5,
            className: "max-h-[500px] overflow-y-auto",
            ...inputProps,
            children: translation && /* @__PURE__ */ jsxRuntimeExports.jsx(
              TranslationButton,
              {
                translation,
                fieldName: register2.name,
                fieldType: FieldType.TextArea,
                label: label || "",
                currentValue: field.value || ""
              }
            )
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const IonModalExtended = reactExports.forwardRef(
  ({ name, onClose, isPresented, onDidPresent, onDidDismiss, ...props }, ref) => {
    const history = useHistory();
    const handlePresentModal = reactExports.useCallback(
      (event) => {
        if (isPresented === void 0) {
          const params = new URLSearchParams(window.location.search);
          if (!params.has(name)) {
            params.append(name, "show");
            history.push({ search: params.toString() });
          }
        }
        onDidPresent == null ? void 0 : onDidPresent(event);
      },
      [history, name, isPresented, onDidPresent]
    );
    const handleDismissModal = reactExports.useCallback(
      (event) => {
        if (isPresented === void 0) {
          const params = new URLSearchParams(window.location.search);
          if (params.has(name)) {
            history.goBack();
          }
        }
        onDidDismiss == null ? void 0 : onDidDismiss(event);
        onClose();
      },
      [history, name, isPresented, onDidDismiss, onClose]
    );
    reactExports.useEffect(() => {
      const handleBackNavigation = () => {
        const params = new URLSearchParams(window.location.search);
        if (!params.has(name)) {
          onClose();
        }
      };
      window.addEventListener("popstate", handleBackNavigation);
      return () => {
        window.removeEventListener("popstate", handleBackNavigation);
      };
    }, [history, onClose, name]);
    reactExports.useEffect(() => {
      const params = new URLSearchParams(window.location.search);
      if (params.has(name)) {
        params.delete(name);
        history.replace({ search: params.toString() });
      }
    }, [name]);
    reactExports.useEffect(() => {
      if (isPresented === void 0) return;
      const params = new URLSearchParams(window.location.search);
      if (isPresented) {
        if (!params.has(name)) {
          params.append(name, "show");
          history.push({ search: params.toString() });
        }
      } else {
        if (params.has(name)) {
          params.delete(name);
          history.replace({ search: params.toString() });
        }
      }
    }, [isPresented]);
    const propsExtended = {
      onDidPresent: handlePresentModal,
      onDidDismiss: handleDismissModal
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IonModal, { ...props, ...propsExtended, ref });
  }
);
const IonModalExtended$1 = reactExports.memo(IonModalExtended);
function ModalActionButtons({
  onSave,
  onCancel,
  onDelete,
  isSaving = false,
  isDeleting = false,
  isSaveDisabled = false,
  showDelete = false,
  saveText,
  cancelText,
  deleteText,
  saveColor = "primary",
  cancelColor = "dark",
  deleteColor = "danger",
  cancelFill = "clear",
  deleteFill = "clear",
  className = "ion-no-padding"
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { className, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        onClick: onCancel,
        color: cancelColor,
        fill: cancelFill,
        slot: "start",
        className: showDelete ? "pr-2" : "pl-2",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline, slot: "start" }),
          cancelText || t2("Otka탑i")
        ]
      }
    ),
    showDelete && onDelete && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonButton,
      {
        onClick: onDelete,
        color: deleteColor,
        fill: deleteFill,
        slot: "end",
        className: "pl-2",
        disabled: isDeleting,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline, slot: "start" })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        onClick: onSave,
        color: saveColor,
        slot: "end",
        className: "pr-2",
        disabled: isSaving || isSaveDisabled,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "start" }),
          isSaving ? t2("훻uvanje...") : saveText || t2("Sa훾uvaj")
        ]
      }
    )
  ] });
}
function WorkingTimeEditor({
  show,
  handleClose,
  handleSave,
  workingTime,
  modalTitle,
  defaultTimeFrom,
  defaultTimeTo,
  defaultDays
}) {
  var _a2;
  const getDefaultTimeFrom = () => {
    if (workingTime == null ? void 0 : workingTime.timeFromUtc) {
      return timeToDateTime(workingTime.timeFromUtc);
    }
    if (defaultTimeFrom) {
      return "2023-01-01T".concat(defaultTimeFrom, ":00");
    }
    return defaultWorkTimeFrom;
  };
  const getDefaultTimeTo = () => {
    if (workingTime == null ? void 0 : workingTime.timeToUtc) {
      return timeToDateTime(workingTime.timeToUtc);
    }
    if (defaultTimeTo) {
      return "2023-01-01T".concat(defaultTimeTo, ":00");
    }
    return defaultWorkTimeTo;
  };
  const [workingTimeFrom, setWorkingTimeFrom] = reactExports.useState(getDefaultTimeFrom());
  const [workingTimeTo, setWorkingTimeTo] = reactExports.useState(getDefaultTimeTo());
  const [selectedDays, setSelectedDays] = reactExports.useState(
    (workingTime == null ? void 0 : workingTime.daysCodes) || defaultDays || []
  );
  const [slotName, setSlotName] = reactExports.useState((_a2 = workingTime == null ? void 0 : workingTime.name) != null ? _a2 : "");
  const daysOfWeekArr = Object.values(daysOfWeek);
  const handleSelected = (key) => () => {
    if (!selectedDays.includes(key)) {
      setSelectedDays([...selectedDays, key]);
    } else {
      setSelectedDays(selectedDays.filter((day) => day !== key));
    }
  };
  const isSelected = (key) => selectedDays.includes(key);
  const canSave = workingTimeFrom && workingTimeTo && selectedDays.length;
  const selectedWorkingHoursLabel = reactExports.useMemo(
    () => getSelectedWorkingHoursLabel(selectedDays),
    [selectedDays]
  );
  const slotNameReal = slotName.length ? slotName : selectedWorkingHoursLabel;
  const resetData = () => {
    setWorkingTimeFrom(getDefaultTimeFrom());
    setWorkingTimeTo(getDefaultTimeTo());
    setSelectedDays(defaultDays || []);
    setSlotName("");
  };
  const onSave = () => {
    if (canSave) {
      const timeFromUtc = dateTimeToTime(workingTimeFrom);
      const timeToUtc = dateTimeToTime(workingTimeTo);
      handleSave == null ? void 0 : handleSave({
        name: slotNameReal,
        daysCodes: selectedDays,
        timeFromUtc,
        timeToUtc
      });
      resetData();
    }
  };
  const onClose = () => {
    handleClose();
    resetData();
  };
  const handleDateChangeFrom = (event) => {
    const newDate = event.detail.value;
    setWorkingTimeFrom(newDate);
  };
  const handleDateChangeTo = (event) => {
    const newDate = event.detail.value;
    setWorkingTimeTo(newDate);
  };
  const workingTimeFromFormatted = reactExports.useMemo(
    () => formatWorkingTime(workingTimeFrom),
    [workingTimeFrom]
  );
  const workingTimeToFormatted = reactExports.useMemo(
    () => formatWorkingTime(workingTimeTo),
    [workingTimeTo]
  );
  const handleSlotNameChange = (event) => {
    var _a3;
    const newSlotName = (_a3 = event.detail.value) != null ? _a3 : "";
    setSlotName(newSlotName);
  };
  reactExports.useEffect(() => {
    var _a3, _b2;
    if (workingTime) {
      setWorkingTimeFrom(timeToDateTime(workingTime.timeFromUtc));
      setWorkingTimeTo(timeToDateTime(workingTime.timeToUtc));
      setSelectedDays((_a3 = workingTime.daysCodes) != null ? _a3 : workingTime.days);
      const nameLabel = getSelectedWorkingHoursLabel(
        (_b2 = workingTime.daysCodes) != null ? _b2 : workingTime.days
      );
      setSlotName(nameLabel === workingTime.name ? "" : workingTime.name);
    }
  }, [workingTime]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonModalExtended$1,
    {
      name: "working-time-editor",
      isOpen: show,
      onClose,
      ...!isWebPlatform && {
        initialBreakpoint: 1,
        breakpoints: [0, 1]
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: workingTime ? modalTitle ? t("Izmena") + " " + modalTitle.toLowerCase() : t("Izmena radnog vremena") : modalTitle || t("Novo radno vreme") }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonGrid, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCol, { style: { textAlign: "-webkit-center" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("Vreme od") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonDatetime,
                {
                  itemType: "time",
                  presentation: "time",
                  preferWheel: true,
                  hourCycle: "h24",
                  minuteValues: "0,15,30,45",
                  onIonChange: handleDateChangeFrom,
                  value: workingTimeFrom
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCol, { style: { textAlign: "-webkit-center" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("Vreme do") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonDatetime,
                {
                  itemType: "time",
                  presentation: "time",
                  preferWheel: true,
                  hourCycle: "h24",
                  minuteValues: "0,15,30,45",
                  onIonChange: handleDateChangeTo,
                  value: workingTimeTo
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: daysOfWeekArr.map((day) => {
            var _a3;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonButton,
              {
                mode: "ios",
                fill: !isSelected(day.key) ? "outline" : "solid",
                color: "dark",
                onClick: handleSelected(day.key),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { color: (_a3 = day.color) != null ? _a3 : void 0, children: day.label }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ConditionalComponent,
                    {
                      condition: isSelected(day.key),
                      render: () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1 text-green-500 font-bold", children: "쐯" }),
                      renderElse: () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1 text-red-500 font-bold", children: "쐵" })
                    }
                  )
                ]
              }
            ) }, day.key);
          }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonFooter, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonGrid, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { size: "6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: selectedWorkingHoursLabel }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                workingTimeFromFormatted != null ? workingTimeFromFormatted : t("from"),
                " - ",
                workingTimeToFormatted != null ? workingTimeToFormatted : t("to")
              ] })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { size: "6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonInput,
              {
                label: "Naziv",
                labelPlacement: "floating",
                onIonChange: handleSlotNameChange,
                value: slotName.length ? slotName : selectedWorkingHoursLabel
              }
            ) }) })
          ] }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ModalActionButtons,
            {
              onSave,
              onCancel: onClose,
              isSaveDisabled: !canSave
            }
          )
        ] })
      ]
    }
  );
}
function WorkingTimeListItem({
  workingTime,
  editWorkingTime,
  handleRemoveItem
}) {
  const slideRef = reactExports.useRef(null);
  const ionItemOptionsRef = reactExports.useRef(null);
  const showItemActions = (event) => {
    var _a2;
    event.stopPropagation();
    (_a2 = slideRef.current) == null ? void 0 : _a2.open("end");
  };
  const handleSlotClick = (event) => {
    var _a2;
    if (event.target && event.target !== ionItemOptionsRef.current) {
      return;
    }
    (_a2 = slideRef.current) == null ? void 0 : _a2.close();
  };
  const onRemoveItem = () => {
    var _a2;
    handleRemoveItem == null ? void 0 : handleRemoveItem(workingTime);
    (_a2 = slideRef.current) == null ? void 0 : _a2.close();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItemSliding, { ref: slideRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonItem,
      {
        button: true,
        onClick: editWorkingTime(workingTime),
        detail: false,
        className: "ion-no-padding",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "start", children: workingTime.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { slot: "end", children: [
            formatWorkingTime(timeToDateTime(workingTime.timeFromUtc)),
            " -",
            " ",
            formatWorkingTime(timeToDateTime(workingTime.timeToUtc))
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonButton,
            {
              slot: "end",
              color: "default",
              onClick: showItemActions,
              size: "default",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronForwardOutline, className: "p-1" })
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonItemOptions,
      {
        side: "end",
        onClick: handleSlotClick,
        ref: ionItemOptionsRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonItemOption, { color: "danger", onClick: onRemoveItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "icon-only", icon: trashOutline }) })
      }
    )
  ] });
}
const transformWorkingHoursBack = (workingHours) => {
  return workingHours;
};
function WorkingTimeList({
  workingHours,
  onChange,
  label,
  addNewLabel,
  modalTitle,
  defaultTimeFrom,
  defaultTimeTo,
  defaultDays
}) {
  const [selectedWorkingTime, setSelectedWorkingTime] = reactExports.useState(void 0);
  const [showWorkingTimeEditor, setShowWorkingTimeEditor] = reactExports.useState(false);
  const handleClose = () => {
    setShowWorkingTimeEditor(false);
    selectedWorkingTime && setSelectedWorkingTime(void 0);
  };
  const handleOnChange = (workingHours2) => {
    onChange(transformWorkingHoursBack(workingHours2));
  };
  const handleSave = (workingTime) => {
    if (selectedWorkingTime) {
      const index = workingHours.findIndex(
        (wt) => wt.name === selectedWorkingTime.name
      );
      if (index > -1) {
        workingHours[index] = workingTime;
        handleOnChange([...workingHours]);
      }
    } else {
      handleOnChange([...workingHours, workingTime]);
    }
    setShowWorkingTimeEditor(false);
    selectedWorkingTime && setSelectedWorkingTime(void 0);
  };
  const handleRemove = (workingTime) => {
    const index = workingHours.findIndex((wt) => wt.name === workingTime.name);
    if (index > -1) {
      workingHours.splice(index, 1);
      handleOnChange([...workingHours]);
    }
  };
  const addWorkingTime = () => {
    selectedWorkingTime && setSelectedWorkingTime(void 0);
    setShowWorkingTimeEditor(true);
  };
  const editWorkingTime = (workingTime) => () => {
    setSelectedWorkingTime(workingTime);
    setShowWorkingTimeEditor(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { className: "w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { className: "py-2 border-b-2", children: label }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { button: true, onClick: addWorkingTime, className: "ion-no-padding", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline, className: "pr-2" }),
        addNewLabel || t("Dodaj novo radno vreme")
      ] }),
      workingHours.map((workingTime, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        WorkingTimeListItem,
        {
          workingTime,
          editWorkingTime,
          handleRemoveItem: handleRemove
        },
        index
      ))
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      WorkingTimeEditor,
      {
        show: showWorkingTimeEditor,
        workingTime: selectedWorkingTime,
        handleClose,
        handleSave,
        modalTitle,
        defaultTimeFrom,
        defaultTimeTo,
        defaultDays
      }
    )
  ] });
}
const transformWorkingHours = (workingHours) => {
  return workingHours;
};
function CommonWorkingTime(props) {
  const {
    register: register2,
    control,
    error,
    label,
    addNewLabel,
    modalTitle,
    defaultTimeFrom,
    defaultTimeTo,
    defaultDays
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field: { onChange, value } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          WorkingTimeList,
          {
            workingHours: value ? transformWorkingHours(value) : [],
            onChange,
            label,
            addNewLabel,
            modalTitle,
            defaultTimeFrom,
            defaultTimeTo,
            defaultDays
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
function WorkingTimeItem({
  workingTime,
  onChange,
  label,
  addNewLabel
}) {
  var _a2;
  const [showWorkingTimeEditor, setShowWorkingTimeEditor] = reactExports.useState(false);
  const [currentWorkingTime, setCurrentWorkingTime] = reactExports.useState(void 0);
  const handleClose = () => {
    setShowWorkingTimeEditor(false);
    setCurrentWorkingTime(void 0);
  };
  const handleSave = (newWorkingTime) => {
    onChange(newWorkingTime);
    setShowWorkingTimeEditor(false);
    setCurrentWorkingTime(void 0);
  };
  const handleAddWorkingTime = () => {
    setCurrentWorkingTime(void 0);
    setShowWorkingTimeEditor(true);
  };
  const handleEditWorkingTime = () => {
    setCurrentWorkingTime(workingTime);
    setShowWorkingTimeEditor(true);
  };
  workingTime ? getSelectedWorkingHoursLabel((_a2 = workingTime.daysCodes) != null ? _a2 : workingTime.days) : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-2 border-b-2", children: label }),
      workingTime ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonItem,
        {
          button: true,
          onClick: handleEditWorkingTime,
          detail: false,
          className: "ion-no-padding",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "start", children: workingTime.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { slot: "end", children: [
              formatWorkingTime(timeToDateTime(workingTime.timeFromUtc)),
              " -",
              " ",
              formatWorkingTime(timeToDateTime(workingTime.timeToUtc))
            ] })
          ]
        }
      ) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonItem,
        {
          button: true,
          onClick: handleAddWorkingTime,
          className: "ion-no-padding",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline, className: "pr-2" }),
            addNewLabel || t("Izaberite radno vreme")
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      WorkingTimeEditor,
      {
        show: showWorkingTimeEditor,
        workingTime: currentWorkingTime,
        handleClose,
        handleSave
      }
    )
  ] });
}
function CommonWorkingTimeSingle(props) {
  const { register: register2, control, error, label, addNewLabel } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field: { onChange, value } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          WorkingTimeItem,
          {
            workingTime: value,
            onChange,
            label,
            addNewLabel
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
function CommonListDataListItem(props) {
  var _a2, _b2;
  const { placeholder, isNewItem, inputType } = props;
  const [item, setItem] = reactExports.useState((_a2 = props.item) != null ? _a2 : "");
  const [editMode, setEditMode] = reactExports.useState(false);
  const minLength = (_b2 = props.minLength) != null ? _b2 : 3;
  const ionItemOptionsRef = reactExports.useRef(null);
  const handleChange = (event) => {
    setItem(event.currentTarget.value);
  };
  const handleEnter = (event) => {
    if (event.key === "Enter") {
      event.preventDefault();
      event.stopPropagation();
      if (item.length >= minLength) {
        handleSave();
      }
    }
  };
  const showEdit = () => {
    setEditMode(true);
    setTimeout(() => {
      var _a3;
      (_a3 = inputRef.current) == null ? void 0 : _a3.setFocus();
    }, 120);
  };
  const inputRef = reactExports.useRef(null);
  const slideRef = reactExports.useRef(null);
  const handleSave = () => {
    props.onSave(props.index, item);
    setEditMode(false);
    if (isNewItem) {
      setItem("");
    }
  };
  const handleCancel = () => {
    setTimeout(() => {
      if (editMode) {
        setEditMode(false);
        setItem(isNewItem ? "" : props.item);
      }
    }, 300);
  };
  const handleDelete = () => {
    var _a3;
    (_a3 = props.onRemove) == null ? void 0 : _a3.call(props, props.index);
    setEditMode(false);
  };
  const showItemActions = (event) => {
    var _a3;
    event.stopPropagation();
    (_a3 = slideRef.current) == null ? void 0 : _a3.open("end");
  };
  const handleSlotClick = (event) => {
    var _a3;
    if (event.target && event.target !== ionItemOptionsRef.current) {
      return;
    }
    (_a3 = slideRef.current) == null ? void 0 : _a3.close();
  };
  reactExports.useEffect(() => {
    if (props.item !== item) {
      setItem(props.item);
    }
  }, [props.item]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItemSliding, { ref: slideRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { button: true, detail: false, onClick: showEdit, children: editMode ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonInput,
        {
          value: item,
          onKeyUp: handleChange,
          onKeyPress: handleEnter,
          ref: inputRef,
          onIonBlur: handleCancel,
          type: inputType != null ? inputType : "text"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          onClick: handleSave,
          slot: "end",
          disabled: item.length < minLength,
          size: "default",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "icon-only" })
        }
      )
    ] }) : isNewItem ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { children: placeholder }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { slot: "end", color: "default", size: "default", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline, slot: "icon-only" }) })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { children: placeholder != null ? placeholder : item }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          slot: "end",
          color: "default",
          onClick: showItemActions,
          size: "default",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronForwardOutline, className: "p-1" })
        }
      )
    ] }) }),
    !isNewItem && !editMode && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonItemOptions,
      {
        side: "end",
        ref: ionItemOptionsRef,
        onClick: handleSlotClick,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonItemOption, { color: "danger", onClick: handleDelete, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "icon-only", icon: trashOutline }) })
      }
    )
  ] });
}
function CommonListDataList(props) {
  const { items, onChange, label, inputType, errors } = props;
  const handleSave = (itemIndex, item) => {
    items[itemIndex] = item;
    onChange([...items]);
  };
  const handleDelete = (itemIndex) => {
    items.splice(itemIndex, 1);
    onChange([...items]);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { className: "w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { className: "py-2 border-b-2", children: label }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CommonListDataListItem,
      {
        item: "",
        onSave: handleSave,
        index: items.length,
        placeholder: "Dodaj",
        isNewItem: true,
        inputType
      }
    ),
    items.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        CommonListDataListItem,
        {
          item,
          index,
          onSave: handleSave,
          onRemove: handleDelete,
          inputType
        }
      ),
      errors && errors[index] && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: errors[index].message }) })
    ] }, item + index))
  ] });
}
function CommonList(props) {
  const { register: register2, control, error, label, inputType } = props;
  const singleError = !Array.isArray(error) ? error : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field: { onChange, value } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonListDataList,
          {
            items: value != null ? value : [],
            onChange,
            label,
            inputType,
            errors: Array.isArray(error) ? error : void 0
          }
        )
      }
    ) }),
    singleError && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: singleError.message }) })
  ] });
}
const CommonList$1 = reactExports.memo(CommonList);
function CommonIonicSwitch(props) {
  const { label, labelPlacement, type, register: register2, error } = props;
  const { itemProps, inputProps, control } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { ...itemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonToggle,
          {
            checked: field.value,
            onIonChange: (e) => field.onChange(e.detail.checked ? 1 : 0),
            children: label
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const ListIonIcons = reactExports.lazy(() => __vitePreload(() => import("./ListIonIcons-DSrG9jQH.js"), true ? __vite__mapDeps([0,1,2,3,4,5,6,7,8,9]) : void 0));
function ListIonIconsModal({
  isOpen,
  setIsOpen,
  onSelectIcon
}) {
  const [searchIcon, setSearchIcon] = React.useState(
    void 0
  );
  const handleDismiss = () => {
    setIsOpen(false);
  };
  const handleSelectIcon = (icon) => {
    setIsOpen(false);
    onSelectIcon == null ? void 0 : onSelectIcon(icon);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonModal, { isOpen, onDidDismiss: handleDismiss, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: t("Ikonice") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleDismiss, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline }) }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonSearchbar,
        {
          debounce: 700,
          onIonInput: (ev) => {
            var _a2;
            return setSearchIcon((_a2 = ev.target) == null ? void 0 : _a2.value);
          },
          onIonClear: () => setSearchIcon(null),
          value: searchIcon
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: "U훶itavanje ikonica...", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ListIonIcons,
      {
        onSelectIcon: handleSelectIcon,
        searchIcon
      }
    ) }) })
  ] });
}
function SelectIonicIcon({
  onSelectionChanged,
  selectedItemValue,
  title
}) {
  const modal = reactExports.useRef(null);
  selectedItemValue = selectedItemValue == null ? void 0 : selectedItemValue.toString();
  const selectedIcon = selectedItemValue ? getIonIconByName(selectedItemValue) : void 0;
  const [showModal, setShowModal] = reactExports.useState(false);
  const handleSelectChange = (item) => {
    var _a2;
    onSelectionChanged == null ? void 0 : onSelectionChanged(item == null ? void 0 : item.key);
    (_a2 = modal.current) == null ? void 0 : _a2.dismiss();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { onClick: () => setShowModal(true), button: true, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonInput,
        {
          label: title,
          readonly: true,
          value: selectedIcon == null ? void 0 : selectedIcon.key,
          labelPlacement: "floating"
        }
      ),
      selectedIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "end", icon: selectedIcon.value })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ListIonIconsModal,
      {
        isOpen: showModal,
        setIsOpen: setShowModal,
        onSelectIcon: handleSelectChange
      }
    )
  ] });
}
function CommonIonicIconSelect(props) {
  const { register: register2, control, error, label } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field: { onChange, value } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectIonicIcon,
          {
            selectedItemValue: value,
            onSelectionChanged: (item) => {
              onChange(item);
            },
            title: label
          }
        )
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const formatDate = (dateString) => {
  if (!dateString) return null;
  try {
    const date = parseISO(dateString);
    return format(date, "dd.MM.yyyy");
  } catch (e) {
    return dateString;
  }
};
function CommonIonicDatePicker({
  label,
  labelPlacement = "stacked",
  itemProps,
  inputProps,
  register: register2,
  error,
  control,
  defaultValue
}) {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const containerRef = reactExports.useRef(null);
  const handleToggle = () => {
    const newIsOpen = !isOpen;
    setIsOpen(newIsOpen);
    if (newIsOpen && containerRef.current) {
      setTimeout(() => {
        var _a2;
        (_a2 = containerRef.current) == null ? void 0 : _a2.scrollIntoView({
          behavior: "smooth",
          block: "center",
          inline: "nearest"
        });
      }, 100);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => {
          var _a2;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: containerRef, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonItem,
              {
                ...itemProps,
                button: true,
                detail: false,
                onClick: handleToggle,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: label }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { slot: "end", className: "ion-text-end", children: field.value ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: formatDate(field.value) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    IonIcon,
                    {
                      icon: calendarOutline,
                      color: "medium",
                      style: { fontSize: "1.2em" }
                    }
                  ) })
                ]
              }
            ),
            isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonDatetime,
              {
                presentation: "date",
                size: "cover",
                value: (_a2 = field.value) != null ? _a2 : defaultValue,
                onIonChange: (e) => {
                  field.onChange(e.detail.value || null);
                },
                ...inputProps
              }
            )
          ] });
        }
      }
    ),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const formatDateTime = (dateString) => {
  if (!dateString) return null;
  try {
    const date = parseISO(dateString);
    return format(date, "dd.MM.yyyy HH:mm");
  } catch (e) {
    return dateString;
  }
};
function CommonIonicDateTimePicker({
  label,
  labelPlacement = "stacked",
  itemProps,
  inputProps,
  register: register2,
  error,
  control,
  defaultValue
}) {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const containerRef = reactExports.useRef(null);
  const handleToggle = () => {
    const newIsOpen = !isOpen;
    setIsOpen(newIsOpen);
    if (newIsOpen && containerRef.current) {
      setTimeout(() => {
        var _a2;
        (_a2 = containerRef.current) == null ? void 0 : _a2.scrollIntoView({
          behavior: "smooth",
          block: "center",
          inline: "nearest"
        });
      }, 100);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: register2.name,
        control,
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: containerRef, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            IonItem,
            {
              ...itemProps,
              button: true,
              detail: false,
              onClick: handleToggle,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: label }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { slot: "end", className: "ion-text-end", children: field.value ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: formatDateTime(field.value) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonIcon,
                  {
                    icon: timeOutline,
                    color: "medium",
                    style: { fontSize: "1.2em" }
                  }
                ) })
              ]
            }
          ),
          isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonDatetime,
            {
              presentation: "date-time",
              size: "cover",
              value: field.value ? toLocalISOStringForIonDatetime(field.value) : defaultValue,
              onIonChange: (e) => {
                field.onChange(e.detail.value || null);
              },
              ...inputProps
            }
          )
        ] })
      }
    ),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: error.message }) })
  ] });
}
const changeRequestApi = sharedApi.injectEndpoints({
  endpoints: (builder) => ({
    getPendingChangeRequests: builder.query({
      query: () => ({ url: "change-requests/pending", method: "GET" }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType.CHANGE_REQUESTS]
    }),
    getEntityChangeRequests: builder.query({
      query: ({ entityType, entityId }) => ({
        url: "change-requests/get-entity",
        method: "GET",
        params: { entityType, entityId }
      }),
      providesTags: [TagType.CHANGE_REQUESTS],
      transformResponse: transformStandardResponseToCamelCase
    }),
    approveChangeRequest: builder.mutation({
      query: ({ id }) => ({
        url: "change-requests/".concat(id, "/approve"),
        method: "POST"
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType.CHANGE_REQUESTS]
    }),
    rejectChangeRequest: builder.mutation({
      query: ({ id }) => ({
        url: "change-requests/".concat(id, "/reject"),
        method: "POST"
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType.CHANGE_REQUESTS]
    })
  })
});
const {
  useGetEntityChangeRequestsQuery
} = changeRequestApi;
function ChangeRequestList({
  changeRequests,
  onSelectChangeRequest,
  isLoading = false,
  entityType
}) {
  const { t: t2 } = useTranslation();
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { className: "ml-2", children: t2("U훾itavanje planiranih promena...") })
    ] });
  }
  if (!changeRequests || changeRequests.length === 0) {
    return null;
  }
  const formatDate2 = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString("sr-RS", {
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    });
  };
  const getStatusColor = (status) => {
    switch (status) {
      case "pending":
        return "warning";
      case "approved":
        return "success";
      case "rejected":
        return "danger";
      case "executed":
        return "primary";
      case "failed":
        return "danger";
      default:
        return "medium";
    }
  };
  const getStatusText = (status) => {
    switch (status) {
      case "pending":
        return t2("Na 훾ekanju");
      case "approved":
        return t2("Odobreno");
      case "rejected":
        return t2("Odbijeno");
      case "executed":
        return t2("Izvr큄eno");
      case "failed":
        return t2("Neuspe큄no");
      default:
        return status;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarOutline, className: "text-lg" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { className: "font-medium", children: [
        t2("Planirane promene"),
        " (",
        changeRequests.length,
        ")"
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: changeRequests.map((changeRequest) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-800 rounded-lg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonButton,
              {
                fill: "outline",
                size: "small",
                color: "warning",
                onClick: () => onSelectChangeRequest(changeRequest),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: timeOutline, className: "mr-2" }),
                  formatDate2(changeRequest.scheduledDateUtc)
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonChip, { color: getStatusColor(changeRequest.status), children: getStatusText(changeRequest.status) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { className: "text-sm text-gray-600 dark:text-gray-400", children: [
                t2("Tip"),
                ":",
                " ",
                changeRequest.changeType === "update" ? t2("A탑uriranje") : changeRequest.changeType === "create" ? t2("Kreiranje") : changeRequest.changeType === "delete" ? t2("Brisanje") : changeRequest.changeType
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500", children: new Date(changeRequest.createdAt).toLocaleDateString("sr-RS") })
        ]
      },
      changeRequest.id
    )) })
  ] });
}
function CommonIonicChangeRequest({
  label,
  name,
  control,
  disabled = false,
  required = false,
  placeholder = "",
  entityId,
  entityType,
  error,
  form
}) {
  const { t: t2 } = useTranslation();
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const [selectedDate, setSelectedDate] = reactExports.useState(() => {
    const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1e3);
    return tomorrow.toISOString().split("T")[0];
  });
  const { data: existingChangeRequests, isLoading: isLoadingChangeRequests } = useGetEntityChangeRequestsQuery(
    { entityType: entityType || "service", entityId: entityId || "" },
    { skip: !entityId || !entityType }
  );
  const openModal = () => setIsOpen(true);
  const closeModal = () => setIsOpen(false);
  const handleSubmit = (onChange) => {
    if (selectedDate) {
      onChange({
        isEnabled: true,
        scheduledDateUtc: selectedDate
      });
      setIsOpen(false);
    }
  };
  const handleDisable = (onChange) => {
    onChange({
      isEnabled: false,
      scheduledDateUtc: null
    });
    setIsOpen(false);
  };
  const handleSelectChangeRequest = (changeRequest) => {
    if (form && changeRequest.data) {
      Object.keys(changeRequest.data).forEach((key) => {
        if (key !== "changeRequest" && key !== "id") {
          const value = changeRequest.data[key];
          if (value !== void 0) {
            form.setValue(key, value);
          }
        }
      });
      form.setValue(name, {
        isEnabled: true,
        scheduledDateUtc: changeRequest.scheduledDateUtc
      });
      console.log("Change request data loaded into form:", changeRequest.data);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Controller,
    {
      name,
      control,
      defaultValue: { isEnabled: false, scheduledDateUtc: null },
      render: ({ field: { onChange, value } }) => {
        const isEnabled = (value == null ? void 0 : value.isEnabled) || false;
        const scheduledDate = (value == null ? void 0 : value.scheduledDateUtc) || null;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "ion-no-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { className: "mb-2 block", children: [
            label,
            required && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-500 ml-1", children: "*" })
          ] }),
          entityId && entityType && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ChangeRequestList,
            {
              changeRequests: (existingChangeRequests == null ? void 0 : existingChangeRequests.data) || [],
              onSelectChangeRequest: handleSelectChangeRequest,
              isLoading: isLoadingChangeRequests,
              entityType
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonButton,
              {
                fill: "outline",
                size: "small",
                onClick: openModal,
                disabled,
                color: error ? "danger" : isEnabled ? "warning" : "primary",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: timeOutline, className: "mr-2" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { children: isEnabled ? t2("Promeni datum") : t2("Podesi datum promena") })
                ]
              }
            ),
            isEnabled && scheduledDate && /* @__PURE__ */ jsxRuntimeExports.jsxs(IonChip, { color: "warning", outline: true, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: timeOutline }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: scheduledDate }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  fill: "clear",
                  size: "small",
                  onClick: () => handleDisable(onChange),
                  disabled,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline })
                }
              )
            ] })
          ] }),
          error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "text-sm", children: error.message }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonModal, { isOpen, onDidDismiss: closeModal, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: isEnabled ? t2("Promeni datum promena") : t2("Podesi datum promena") }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { className: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: t2("Izaberi datum") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonDatetime,
                  {
                    value: selectedDate,
                    onIonChange: (e) => setSelectedDate(e.detail.value || ""),
                    min: new Date(Date.now() + 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
                    presentation: "date"
                  }
                )
              ] }),
              isEnabled && scheduledDate && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm text-gray-600", children: [
                t2("Trenutno pode큄en datum"),
                ": ",
                scheduledDate
              ] })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 p-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { fill: "outline", onClick: closeModal, children: t2("Otka탑i") }),
              isEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  fill: "outline",
                  onClick: () => handleDisable(onChange),
                  color: "danger",
                  children: t2("Ukloni")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  onClick: () => handleSubmit(onChange),
                  disabled: !selectedDate,
                  children: isEnabled ? t2("Promeni") : t2("Podesi")
                }
              )
            ] }) }) })
          ] })
        ] }) });
      }
    }
  );
}
function DynamicForm(props) {
  const { fields, callback, itemProps } = props;
  const form = props.form;
  const errors = form.formState.errors;
  const getField = (field) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
    const keyName = field.keyNameChild ? "".concat(field.keyName, ".").concat(field.keyNameChild) : field.keyName;
    const register2 = form.register(keyName, {
      required: field.required,
      setValueAs: (value) => typeof value === "string" ? value.trim() : value
    });
    const fieldError = field.keyNameChild ? (_a2 = errors[field.keyName]) == null ? void 0 : _a2[field.keyNameChild] : errors[field.keyName];
    const label = "label" in field.data && field.data.label ? field.required ? "".concat(field.data.label, " *") : field.data.label : "";
    switch (field.data.type) {
      case FieldType.Text:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicInput,
          {
            label,
            type: "text",
            register: register2,
            error: fieldError,
            control: form.control,
            itemProps: {
              ...itemProps,
              disabled: field.disabled
            },
            inputProps: {
              readonly: field.readOnly
            },
            labelPlacement: field.data.labelPlacement,
            translation: field.data.translation,
            googleIt: field.data.googleIt
          }
        );
      case FieldType.Slug:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicSlug,
          {
            label,
            register: register2,
            error: fieldError,
            control: form.control,
            sourceField: field.data.sourceField,
            placeholder: field.data.placeholder,
            isWatched: field.data.isWatched,
            isWatchedDefault: field.data.isWatchedDefault,
            itemProps: {
              ...itemProps,
              disabled: field.disabled
            }
          }
        );
      case FieldType.Number:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicInput,
          {
            label,
            type: "number",
            itemProps: {
              ...itemProps,
              disabled: field.disabled
            },
            inputProps: {
              readonly: field.readOnly
            },
            register: register2,
            error: fieldError,
            control: form.control
          }
        );
      case FieldType.Switch:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicSwitch,
          {
            label,
            type: "number",
            register: register2,
            error: fieldError,
            control: form.control
          }
        );
      case FieldType.Password:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicInput,
          {
            label,
            type: "password",
            register: register2,
            error: fieldError,
            control: form.control,
            showEye: (_b2 = field.data.showEye) != null ? _b2 : true
          }
        );
      case FieldType.Select:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicSelect,
          {
            register: register2,
            options: (_c2 = field.data.options) != null ? _c2 : [],
            ariaLabel: (_d2 = field.data.label) != null ? _d2 : field.name,
            placeholder: field.data.placeholder,
            error: fieldError,
            control: form.control,
            selectProps: {
              ...field.data.selectProps,
              disabled: field.disabled
            }
          }
        );
      case FieldType.Callback:
        return callback == null ? void 0 : callback(field);
      case FieldType.MultiCheckbox:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicMultiCheckbox,
          {
            control: form.control,
            error: fieldError,
            register: register2,
            disabled: field.disabled,
            options: (_e2 = field.data.options) != null ? _e2 : [],
            showSearchbar: field.data.showSearchbar,
            label: field.name,
            dataRowClassNames: field.data.rowClassNames
          }
        );
      case FieldType.Autocomplete:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicAutocompleteSelect,
          {
            control: form.control,
            error: fieldError,
            options: (_f2 = field.data.options) != null ? _f2 : [],
            handleAddNewOption: field.data.handleAddNewOption,
            register: register2,
            label: (_g2 = field.data.label) != null ? _g2 : field.name,
            selectedItem: form.getValues(keyName)
          }
        );
      case FieldType.RichEditor:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormRichEditor,
          {
            label: field.data.label,
            register: register2,
            error: fieldError,
            control: form.control,
            translation: field.data.translation
          }
        );
      case FieldType.TextArea:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicTextarea,
          {
            control: form.control,
            label: field.data.label,
            error: fieldError,
            register: register2,
            maxlength: field.data.maxlength,
            itemProps: {
              ...itemProps
            },
            translation: field.data.translation
          }
        );
      case FieldType.PhotoUploader:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          PhotoUploader$1,
          {
            label: field.data.label,
            register: register2,
            error: fieldError,
            control: form.control,
            handlers: field.data.handlers,
            reorderImagesResult: field.data.reorderImagesResult,
            photos: field.data.photos,
            oneImage: field.data.oneImage,
            cropAspectRatio: field.data.cropAspectRatio,
            maxPhotos: field.data.maxPhotos
          }
        );
      case FieldType.GalleryArea:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          GalleryArea,
          {
            field: field.data,
            register: register2,
            error: fieldError,
            control: form.control,
            form
          }
        );
      case FieldType.WorkingHours:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonWorkingTime,
          {
            label: field.data.label,
            addNewLabel: field.data.addNewLabel,
            modalTitle: field.data.modalTitle,
            defaultTimeFrom: field.data.defaultTimeFrom,
            defaultTimeTo: field.data.defaultTimeTo,
            defaultDays: field.data.defaultDays,
            register: register2,
            error: fieldError,
            control: form.control
          }
        );
      case FieldType.WorkingHoursSingle:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonWorkingTimeSingle,
          {
            label: field.data.label,
            addNewLabel: field.data.addNewLabel,
            register: register2,
            error: fieldError,
            control: form.control
          }
        );
      case FieldType.List:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonList$1,
          {
            label: field.data.label,
            register: register2,
            error: fieldError,
            control: form.control,
            inputType: field.data.inputType
          }
        );
      case FieldType.IonIcon:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicIconSelect,
          {
            register: register2,
            error: fieldError,
            control: form.control,
            label: field.data.label
          }
        );
      case FieldType.Date:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicDatePicker,
          {
            label: field.data.label,
            register: register2,
            error: fieldError,
            control: form.control,
            itemProps: field.data.itemProps,
            inputProps: field.data.inputProps,
            defaultValue: field.data.defaultValue
          }
        );
      case FieldType.DateTime:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicDateTimePicker,
          {
            label: field.data.label,
            register: register2,
            error: fieldError,
            control: form.control,
            itemProps: field.data.itemProps,
            inputProps: field.data.inputProps,
            defaultValue: field.data.defaultValue
          }
        );
      case FieldType.ChangeRequest:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommonIonicChangeRequest,
          {
            label,
            name: keyName,
            control: form.control,
            disabled: field.disabled,
            required: field.required,
            entityId: field.data.entityId,
            entityType: field.data.entityType,
            error: fieldError,
            form
          }
        );
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {});
    }
  };
  const getFields = () => {
    const returnFields = [];
    let rowElements = [];
    fields.forEach((field, index) => {
      var _a2;
      const gridSize = (_a2 = field.gridSize) != null ? _a2 : {
        size: "12",
        sizeSm: "12",
        sizeMd: "6"
      };
      if (field.newRow && rowElements.length > 0) {
        returnFields.push(/* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: rowElements }, index));
        rowElements = [];
      }
      const fieldElement = getField(field);
      if (fieldElement && field.visible !== false) {
        rowElements.push(
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { ...gridSize, className: field.colClassNames, children: fieldElement }, index)
        );
      }
    });
    if (rowElements.length > 0) {
      returnFields.push(/* @__PURE__ */ jsxRuntimeExports.jsx(IonRow, { children: rowElements }, fields.length));
    }
    return returnFields;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonGrid, { children: getFields() });
}
const loginApi = sharedApi.injectEndpoints({
  endpoints: (build) => ({
    login: build.mutation({
      query: (body) => ({
        url: "/login",
        method: "POST",
        body
      })
    }),
    loginWithCode: build.mutation({
      query: (body) => ({
        url: "/user/login-with-code",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    prepareLoginRegister: build.mutation({
      query: (body) => ({
        url: "/user/prepare",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    loginGoogle: build.mutation({
      query: (body) => ({
        url: "/login/google",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    register: build.mutation({
      query: (body) => ({
        url: "/register",
        method: "POST",
        body
      })
    }),
    userCompleteRegistration: build.mutation({
      query: (body) => ({
        url: "/user/register/complete",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase
    }),
    getUserSettings: build.query({
      query: () => "/user/settings",
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [{ type: TagType.USER_SETTINGS, id: TagId.LIST }]
    }),
    updateUserSettings: build.mutation({
      query: (data) => ({
        url: "/user/settings",
        method: "PUT",
        body: { data: humpsExports.decamelizeKeys(data) }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [{ type: TagType.USER_SETTINGS, id: TagId.LIST }]
    }),
    getUserAddresses: build.query({
      query: () => "/user/addresses",
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [{ type: TagType.USER_ADDRESS, id: TagId.LIST }]
    }),
    createUserAddress: build.mutation({
      query: (data) => ({
        url: "/user/addresses",
        method: "POST",
        body: { data: humpsExports.decamelizeKeys(data) }
      }),
      invalidatesTags: [{ type: TagType.USER_ADDRESS, id: TagId.LIST }]
    }),
    deleteUserAddresses: build.mutation({
      query: (ids) => ({
        url: "/user/addresses",
        method: "DELETE",
        body: { ids }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [{ type: TagType.USER_ADDRESS, id: TagId.LIST }]
    })
  })
});
const {
  useLoginWithCodeMutation,
  usePrepareLoginRegisterMutation,
  useLoginGoogleMutation
} = loginApi;
var UserGroupCode = /* @__PURE__ */ ((UserGroupCode2) => {
  UserGroupCode2["Admin"] = "admin";
  UserGroupCode2["Registered"] = "registered";
  UserGroupCode2["Guest"] = "guest";
  UserGroupCode2["Agent"] = "agent";
  UserGroupCode2["Client"] = "client";
  UserGroupCode2["Worker"] = "worker";
  UserGroupCode2["SocialGoogle"] = "social-google";
  UserGroupCode2["Owner"] = "owner";
  return UserGroupCode2;
})(UserGroupCode || {});
function getLoginFields(t2) {
  return [
    {
      name: "email",
      keyName: "login",
      data: {
        type: FieldType.Text,
        label: t2("Email")
      },
      gridSize: {
        size: "12"
      }
    }
  ];
}
const schema$1 = yup.object({
  login: yup.string().email(t("Email nije validan")).required()
});
const defaultDuration = 20 * 1e3;
function CommonLoginForm(props) {
  var _a2, _b2, _c2;
  const { t: t2 } = useTranslation();
  const fields = getLoginFields(t2);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [showConfirmationCodeField, setShowConfirmationCodeField] = reactExports.useState(false);
  const [confirmationCode, setConfirmationCode] = reactExports.useState("");
  const [showLoadingDuration, setShowLoadingDuration] = reactExports.useState(defaultDuration);
  const [presentToast] = useIonToast();
  const form = useFormWithSchema(schema$1);
  const { handleSubmit } = form;
  const dispatch = useDispatch();
  const [prepareUser, prepareResult] = usePrepareLoginRegisterMutation();
  const [
    loginWithCode,
    {
      data: loginWithCodeResponse,
      isSuccess: isLoginWithCodeSuccess,
      isError: isLoginWithCodeError,
      error: loginWithCodeError
    }
  ] = useLoginWithCodeMutation();
  const [loginGoogle, loginGoogleResult] = useLoginGoogleMutation();
  const {
    data: googleUserData,
    isSuccess: isGoogleLoginSuccess,
    isError: isGoogleLoginError
  } = loginGoogleResult;
  const showLoading = (duration = 20) => {
    setShowLoadingDuration(duration * 1e3);
    setIsLoading(true);
  };
  const hideLoading = () => {
    setShowLoadingDuration(defaultDuration);
    setIsLoading(false);
  };
  const onSubmit = (data) => {
    prepareUser(data);
  };
  const handleSuccessfulLogin = (loginData) => {
    var _a3;
    dispatch(setUser(loginData));
    dispatch(setUiData({ showLoginModal: false }));
    hideLoading();
    (_a3 = props.onSuccessfulLogin) == null ? void 0 : _a3.call(props);
  };
  const {
    isSuccess: isPrepareSuccess,
    isLoading: isPrepareLoading,
    isError: isPrepareError,
    error
  } = prepareResult;
  reactExports.useEffect(() => {
    if (isPrepareSuccess) {
      setShowConfirmationCodeField(true);
    }
    if (isPrepareError) {
      showNotification(
        { message: errorMessage != null ? errorMessage : "Unknown error", color: "danger" },
        1
      );
      hideLoading();
    }
  }, [isPrepareSuccess, isPrepareError, error]);
  reactExports.useEffect(() => {
    var _a3, _b3, _c3;
    if (isLoginWithCodeSuccess && loginWithCodeResponse) {
      handleSuccessfulLogin(loginWithCodeResponse.data);
      if (!((_a3 = prepareResult == null ? void 0 : prepareResult.data) == null ? void 0 : _a3.data.isExistingUser)) {
        dispatch(setShowCompleteProfileModal(true));
      }
    }
    if (isLoginWithCodeError && loginWithCodeError) {
      const errorMessage2 = (_b3 = loginWithCodeError == null ? void 0 : loginWithCodeError.data) == null ? void 0 : _b3.message;
      showNotification(
        {
          message: (_c3 = errorMessage2 == "Invalid code" ? t2("Kod nije validan") : errorMessage2) != null ? _c3 : "Unknown error",
          color: "danger",
          position: "bottom"
        },
        1
      );
      hideLoading();
    }
  }, [loginWithCodeResponse]);
  reactExports.useEffect(() => {
    if (isGoogleLoginSuccess) {
      handleSuccessfulLogin(googleUserData.data);
    }
    if (isPrepareError) {
      hideLoading();
    }
  }, [googleUserData, isGoogleLoginSuccess, isGoogleLoginError]);
  const errorMessage = (_a2 = error == null ? void 0 : error.data) == null ? void 0 : _a2.message;
  const showNotification = (options, durationSec) => {
    presentToast({
      duration: durationSec * 1e3,
      position: "top",
      ...options
    });
  };
  const googleLogin = useGoogleLogin({
    onSuccess: (tokenResponse) => {
      showLoading();
      loginGoogle({ accessToken: tokenResponse.access_token });
    },
    onError: () => {
      hideLoading();
    },
    onNonOAuthError: () => {
      hideLoading();
    }
  });
  const onLogin = () => {
    showLoading(30);
    googleLogin();
  };
  const handleConfirmationCode = () => {
    showLoading();
    loginWithCode({
      code: confirmationCode,
      login: form.getValues().login
    });
  };
  const handleCodeInputChange = (e) => {
    setConfirmationCode((e.currentTarget.value || "").trim());
  };
  const codeValidationError = (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    (_c2 = (_b2 = loginWithCodeResponse == null ? void 0 : loginWithCodeResponse.error) == null ? void 0 : _b2.data) == null ? void 0 : _c2.message
  );
  const disabledCodeButton = !confirmationCode || confirmationCode.length < 4;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-padding", children: [
    isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonLoading,
      {
        isOpen: isLoading,
        onDidDismiss: hideLoading,
        message: "Login - Molim vas sa훾ekajte...",
        duration: showLoadingDuration
      }
    ),
    isPrepareLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonLoading,
      {
        isOpen: isPrepareLoading,
        onDidDismiss: hideLoading,
        message: "힋alje se mejl sa kodom za aktivaciju...",
        duration: showLoadingDuration
      }
    ),
    showConfirmationCodeField ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonIcon,
        {
          icon: mailOutline,
          style: {
            fontSize: "48px",
            color: "var(--ion-color-success)",
            marginBottom: "16px"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { color: "success", className: "ion-padding-bottom", children: t2("Proverite mejl sandu훾e") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "ion-margin-bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonInput,
        {
          label: t2("Kod za aktivaciju"),
          labelPlacement: "stacked",
          placeholder: t2("Unesite kod ovde"),
          onKeyUp: handleCodeInputChange,
          value: confirmationCode,
          className: "ion-margin-top"
        }
      ) }),
      codeValidationError && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: codeValidationError }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          onClick: handleConfirmationCode,
          disabled: disabledCodeButton,
          expand: "block",
          className: "ion-margin-top",
          children: t2("Potvrdi")
        }
      )
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "form",
        {
          onSubmit: handleSubmit(onSubmit),
          autoComplete: "off",
          className: "ion-padding",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields, form }),
            isPrepareError && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", className: "ion-padding-top", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: errorMessage }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonButton,
              {
                type: "submit",
                expand: "block",
                className: "ion-margin-top",
                children: [
                  t2("Uloguj se"),
                  " / ",
                  t2("Registruj se")
                ]
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-padding", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-text-center ion-margin-bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("ili se prijavite sa") }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonButton,
          {
            fill: "solid",
            onClick: onLogin,
            color: "dark",
            expand: "block",
            className: "ion-margin-top",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonIcon,
                {
                  slot: "start",
                  icon: logoGoogle,
                  className: "ion-margin-end"
                }
              ),
              t2("Google Log In")
            ]
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-text-center ion-margin-bottom mt-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonIcon,
        {
          icon: keyOutline,
          style: {
            fontSize: "48px",
            color: "var(--ion-color-primary)",
            marginBottom: "16px"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("Dobro do큄li nazad!") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ion-color-medium", children: t2("Prijavite se ili registrujte za pristup") })
      ] })
    ] })
  ] });
}
const withGoogleOAuth = (Component) => {
  const WrappedComponent = (props) => {
    const googleApiKey = "528191814583-ovprc30ec231gtc7t24apkep4kqo7npo.apps.googleusercontent.com";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GoogleOAuthProvider, { clientId: googleApiKey, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ...props }) });
  };
  WrappedComponent.displayName = "withGoogleOAuth(".concat(Component.displayName || Component.name || "Component", ")");
  return WrappedComponent;
};
const CommonLoginForm$1 = withGoogleOAuth(CommonLoginForm);
function CommonLoginModal(props) {
  const { t: t2 } = useTranslation();
  const { showLoginModal, onClose } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonModalExtended$1,
    {
      name: "login-modal",
      isOpen: showLoginModal,
      onClose,
      initialBreakpoint: 0.9,
      breakpoints: [0, 0.9, 1],
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: t2("Log in / Registracija") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline }) }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CommonLoginForm$1, {}) })
      ]
    }
  );
}
const ImageModal = () => {
  const imageData = useAppSelector$1(getImageModalData);
  const dispatch = useAppDispatch$1();
  const [isBackgroundColorBlack, setIsBackgroundColorBlack] = React.useState(true);
  const handleClose = () => {
    dispatch(closeImageModal());
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonModal, { isOpen: imageData == null ? void 0 : imageData.showModal, onDidDismiss: handleClose, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: handleClose, children: "Close" }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonContent, { fullscreen: true, className: "ion-padding ion-text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: imageData == null ? void 0 : imageData.src,
          alt: imageData == null ? void 0 : imageData.alt,
          className: "inline modal-image-preview",
          style: {
            backgroundColor: isBackgroundColorBlack ? "black" : "white"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonToggle,
        {
          checked: isBackgroundColorBlack,
          labelPlacement: "start",
          onIonChange: () => setIsBackgroundColorBlack(!isBackgroundColorBlack),
          children: "Crna Pozadina"
        }
      )
    ] })
  ] });
};
function CommonModalWrappers() {
  const dispatch = useAppDispatch$1();
  const showLoginModal = useAppSelector$1(getShowLoginModal);
  const showImageModal = useAppSelector$1(getShowImageModal);
  const handleCloseLoginModal = reactExports.useCallback(() => {
    dispatch(setShowLoginModal(false));
  }, [dispatch]);
  const LoginModalWrapper = reactExports.useMemo(() => {
    if (showLoginModal !== void 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        CommonLoginModal,
        {
          showLoginModal,
          onClose: handleCloseLoginModal
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  }, [showLoginModal, handleCloseLoginModal]);
  const ImageModalWrapper = reactExports.useMemo(() => {
    if (showImageModal !== void 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageModal, {});
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  }, [showImageModal]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    LoginModalWrapper,
    ImageModalWrapper
  ] });
}
const CommonModalWrappers$1 = reactExports.memo(CommonModalWrappers);
const firebaseConfig = {
  apiKey: "AIzaSyBrqIvAMt2f_G4bZMV2GkkGCHYGdWOxVLU",
  authDomain: "rezervacije-417408.firebaseapp.com",
  projectId: "rezervacije-417408",
  storageBucket: "rezervacije-417408.appspot.com",
  messagingSenderId: "528191814583",
  appId: "1:528191814583:web:00b4a81579862dea1dc632",
  measurementId: "G-887PF27E5L"
};
let messagingTemp;
const firebaseApp = initializeApp(firebaseConfig);
try {
  messagingTemp = getMessagingInWindow(firebaseApp);
} catch (e) {
  console.error(e);
  messagingTemp = void 0;
}
getAnalytics(firebaseApp);
const messaging = messagingTemp;
const __vite_import_meta_env__ = { "LEGACY": false, "VITE_RZR_VAPID_KEY": "BLgl3XyX_NID8-aSxeMXjfw3I9dt0cHPtoTQRKX0kGSDgvSJ89UFaO2rUTsis2x4oYrqn-tN4X84WmpMyvX5e9Y" };
const { VITE_RZR_VAPID_KEY } = __vite_import_meta_env__;
function useDeviceNotification({
  handleMessage,
  onConnected,
  connectDeviceInit
}) {
  const deviceData = useAppSelector$1(getDeviceData);
  const dispatch = useAppDispatch$1();
  const onConnectedRef = reactExports.useRef(onConnected);
  const handleMessageRef = reactExports.useRef(handleMessage);
  reactExports.useEffect(() => {
    onConnectedRef.current = onConnected;
  }, [onConnected]);
  reactExports.useEffect(() => {
    handleMessageRef.current = handleMessage;
  }, [handleMessage]);
  reactExports.useEffect(() => {
    if (!messaging) {
      return;
    }
    onMessage(messaging, (payload) => {
      if (handleMessageRef.current) {
        handleMessageRef.current(payload);
      }
    });
    return () => {
    };
  }, []);
  const handleConnectDevice = reactExports.useCallback(
    async (enabled) => {
      if (!messaging) {
        return;
      }
      if (!enabled && !deviceData.notificationsEnabled) {
        return;
      }
      try {
        if (!("serviceWorker" in navigator)) {
          console.warn("Service worker not supported");
          return;
        }
        console.log("Service worker supported, waiting for registration...");
        const registration = await Promise.race([
          navigator.serviceWorker.ready,
          new Promise(
            (resolve) => setTimeout(() => {
              console.warn("Service worker ready timeout after 10s");
              resolve(null);
            }, 1e4)
          )
        ]);
        if (!registration) {
          console.warn("Service worker not available after timeout");
          return;
        }
        const permission = await Notification.requestPermission();
        if (permission === "granted") {
          const token = await getToken(messaging, {
            serviceWorkerRegistration: registration,
            vapidKey: VITE_RZR_VAPID_KEY
          });
          if (deviceData.notificationsToken !== token) {
            onConnectedRef.current(token);
            dispatch(setDeviceData({ notificationsToken: token }));
          }
        }
      } catch (error) {
        console.error("Error connecting device for notifications:", error);
      }
    },
    [deviceData.notificationsEnabled, deviceData.notificationsToken, dispatch]
  );
  reactExports.useEffect(() => {
    if (connectDeviceInit && messaging) {
      handleConnectDevice(true);
    }
  }, [connectDeviceInit, handleConnectDevice]);
  return messaging ? {
    connectDevice: handleConnectDevice
  } : null;
}
function useUser(props) {
  const user = useAppSelector$1(getUser);
  const [userId, setUserId] = reactExports.useState(user == null ? void 0 : user.id);
  const dispatch = useAppDispatch$1();
  const { roles } = {};
  const [presentToast] = useIonToast();
  const wrapUserLoginModal = reactExports.useCallback(
    (callbackFunc) => {
      const showLoginResponse = () => {
        dispatch(setShowLoginModal(true));
      };
      if (user) {
        if (roles && roles.length > 0) {
          const hasRole = userHasRoles(user, roles);
          if (!hasRole) {
            return showLoginResponse;
          }
        }
        return callbackFunc != null ? callbackFunc : (() => {
        });
      }
      return showLoginResponse;
    },
    [user, roles, dispatch]
  );
  const isGroup = (group) => {
    return user && userHasRoles(user, [group]);
  };
  const isOwner = isGroup(UserGroupCode.Owner);
  const isWorker = isGroup(UserGroupCode.Worker);
  const isAdmin = isGroup(UserGroupCode.Admin);
  const isOwnerOrWorker = isOwner || isWorker;
  const logoutUser = () => {
    var _a2;
    dispatch(logoutAction());
    dispatch((_a2 = sharedApi.util) == null ? void 0 : _a2.invalidateTags([TagType.USER]));
  };
  reactExports.useEffect(() => {
    if (!(user == null ? void 0 : user.id) && userId) {
      presentToast({
        message: t("Korisnik je izlogovan"),
        duration: 4e3,
        color: "warning"
      });
      setUserId(void 0);
    } else if ((user == null ? void 0 : user.id) && userId !== user.id) {
      setUserId(user.id);
    }
  }, [user]);
  return {
    wrapUserLoginModal,
    isOwner,
    isAdmin,
    isWorker,
    isGroup,
    isOwnerOrWorker,
    userData: user,
    logoutUser,
    skipNoUser: { skip: !user }
  };
}
const notificationServices = sharedApi.injectEndpoints({
  endpoints: (builder) => ({
    addConnectedDevice: builder.mutation({
      query: (body) => ({
        url: "users/connected-devices",
        method: "POST",
        body
      })
    }),
    removeConnectedDevice: builder.mutation({
      query: (body) => ({
        url: "users/connected-devices",
        method: "DELETE",
        body
      })
    })
  })
});
const {
  useAddConnectedDeviceMutation,
  useRemoveConnectedDeviceMutation
} = notificationServices;
function CommonNotificationWrapper({
  activeLocation: activeLocation2
} = {}) {
  const [addConnectedDevice] = useAddConnectedDeviceMutation();
  const { isOwnerOrWorker, userData } = useUser();
  const [presentToast] = useIonToast();
  const { push } = useIonRouter();
  const deviceData = useAppSelector$1(getDeviceData);
  const deviceNotification = useDeviceNotification({
    handleMessage: (payload) => {
      var _a2, _b2, _c2;
      const notification = (_a2 = payload == null ? void 0 : payload.data) == null ? void 0 : _a2.notification;
      const data = (_b2 = payload == null ? void 0 : payload.data) == null ? void 0 : _b2.data;
      if (!data || !notification) return;
      presentToast({
        message: t("Obave큄tenje: ") + ((_c2 = notification.body) != null ? _c2 : t("nema poruke")),
        duration: 5e3,
        color: "warning",
        buttons: (data == null ? void 0 : data.url) ? [
          {
            text: t("Link"),
            role: "info",
            handler: () => {
              push(data.url);
            }
          }
        ] : void 0
      });
    },
    onConnected: (token) => {
      console.log("onConnected", token, activeLocation2);
      if (activeLocation2) {
        addConnectedDevice({ token, locationSlug: activeLocation2 });
      }
    },
    // Always try to connect for all users (not just owner/worker)
    connectDeviceInit: !!userData
  });
  reactExports.useEffect(() => {
    if (!!deviceNotification && !isOwnerOrWorker && deviceData.notificationsEnabled && userData) {
      deviceNotification == null ? void 0 : deviceNotification.connectDevice(true);
    }
  }, [
    deviceData.notificationsEnabled,
    deviceNotification,
    isOwnerOrWorker,
    userData
  ]);
  return null;
}
const NotificationToast = ({
  message,
  type,
  duration = 2500,
  position = "bottom",
  isOpen,
  onDidDismiss,
  cssClass
}) => {
  const { t: t2 } = useTranslation();
  const getColor = () => {
    switch (type) {
      case "success":
        return "success";
      case "error":
        return "danger";
      case "warning":
        return "warning";
      case "info":
        return "primary";
      default:
        return "primary";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonToast,
    {
      isOpen,
      onDidDismiss,
      message: t2(message),
      duration,
      color: getColor(),
      position,
      cssClass
    }
  );
};
function ShowLoading({
  message,
  otherProps
}) {
  if (!message) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonLoading,
    {
      isOpen: !!message,
      message: message === true ? "" : message.toString(),
      ...otherProps
    }
  );
}
const ShowLoading$1 = reactExports.memo(ShowLoading);
function SkeletonLoader() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonListHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonSkeletonText,
      {
        animated: true,
        style: { width: "80px" }
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonThumbnail, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSkeletonText, { animated: true }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonSkeletonText,
          {
            animated: true,
            style: { width: "80%" }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonSkeletonText,
          {
            animated: true,
            style: { width: "60%" }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonSkeletonText,
          {
            animated: true,
            style: { width: "30%" }
          }
        ) })
      ] })
    ] })
  ] });
}
const SceletonLoader = reactExports.memo(SkeletonLoader);
function InstallInstructionsIosModal({
  isOpen,
  onClose
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonModal,
    {
      isOpen,
      onDidDismiss: onClose,
      breakpoints: [0.9, 1],
      initialBreakpoint: 0.9,
      children: isWebView ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: t("Instalacija je mogu훶a samo preko pretra탑iva훾a") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "(Google Chrome, Safari, ...)" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { expand: "block", onClick: onClose, className: "mt-6", children: t("Zatvori") }) })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl border-b-2 pb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t("iOS uputstvo za instalaciju") }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonContent, { className: "ion-padding", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: " text-xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "mb-2", children: [
                t("1) Kliknite na ikonu"),
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonIcon,
                  {
                    icon: exitOutline,
                    className: "-rotate-90",
                    color: "secondary",
                    size: "large"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "mb-2", children: t("2) Izaberite 'Dodaj na po훾etni ekran'.") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "mb-2", children: t("3) Kliknite na 'Dodaj'.") })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { expand: "block", onClick: onClose, className: "mt-6", children: t("Zatvori") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mt-10", children: t("Ako vam je telefon na engleskom:") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "mb-2", children: t("2) Izaberite 'Add to Home Screen'.") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "mb-2", children: t("3) Kliknite na 'Add'.") })
            ] })
          ] })
        ] })
      ] })
    }
  );
}
function useInstallPrompt({
  onSuccess,
  onFailure
}) {
  const [installPrompt, setInstallPrompt] = reactExports.useState(
    null
  );
  reactExports.useEffect(() => {
    const handleBeforeInstallPrompt = (e) => {
      e.preventDefault();
      setInstallPrompt(e);
    };
    window.addEventListener("beforeinstallprompt", handleBeforeInstallPrompt);
    return () => {
      window.removeEventListener(
        "beforeinstallprompt",
        handleBeforeInstallPrompt
      );
    };
  }, []);
  const promptInstall = async () => {
    if (installPrompt) {
      installPrompt.prompt();
      const choiceResult = await installPrompt.userChoice;
      if (choiceResult.outcome === "accepted") {
        console.log("User accepted the A2HS prompt");
        setInstallPrompt(null);
        onSuccess == null ? void 0 : onSuccess();
      } else {
        console.log("User dismissed the A2HS prompt");
        onFailure == null ? void 0 : onFailure();
      }
    }
  };
  return { promptInstall };
}
const fallbackRenderContent = ({ error }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { role: "alert", className: "p-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-red-500", children: "Something went wrong:" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "mt-2 text-sm text-red-700", children: error.message })
  ] });
};
const formatPriceSimple = (price) => {
  const rounded = Math.round(price * 100) / 100;
  const hasDecimals = rounded % 1 !== 0;
  if (hasDecimals) {
    const parts = rounded.toFixed(2).split(".");
    const integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, " ");
    return "".concat(integerPart, ",").concat(parts[1]);
  } else {
    return Math.round(rounded).toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
  }
};
function useWindowSize() {
  const [windowSize, setWindowSize] = reactExports.useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  reactExports.useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    }
    window.addEventListener("resize", handleResize);
    handleResize();
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return windowSize;
}
const ContentDataContext = reactExports.createContext(null);
function useContentData() {
  return reactExports.useContext(ContentDataContext);
}
function ContentDataProvider({
  children,
  contentRef,
  scrollTop
}) {
  const isScrolled = scrollTop > 0;
  const scrollToTop = (duration = 300) => {
    var _a2;
    (_a2 = contentRef.current) == null ? void 0 : _a2.scrollToTop(duration);
  };
  const scrollToBottom = (duration = 300) => {
    var _a2;
    (_a2 = contentRef.current) == null ? void 0 : _a2.scrollToBottom(duration);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ContentDataContext.Provider,
    {
      value: {
        isScrolled,
        scrollTop,
        scrollToTop,
        scrollToBottom,
        contentRef
      },
      children
    }
  );
}
const ContentRefContext = reactExports.createContext(
  null
);
function useContentRefFunctions() {
  return reactExports.useContext(ContentRefContext);
}
const defaultTitleSlot = "start";
function LayoutMainPage({
  hasPage,
  children,
  contentLoading,
  popoverChildren,
  popoverItem,
  headerEndActions,
  hideHeader,
  headerClasses,
  title,
  titleSlot = defaultTitleSlot,
  headerContent,
  hasBackButton,
  hasMenuButton = true,
  backButtonIcon,
  backButtonTitle,
  backButtonCss = "",
  onBackClick,
  additionalHeader,
  footer,
  backButtonUrl,
  showLoadingMessage,
  installAppHeaderHandle,
  contentClasses,
  hasRefresher = true
}) {
  var _a2;
  useTranslation();
  const [showPopover, setShowPopover] = reactExports.useState(false);
  const [popoverEvent, setPopoverEvent] = reactExports.useState();
  const [scrollTop, setScrollTop] = reactExports.useState(0);
  const router = useIonRouter();
  title = title && typeof title === "string" ? t(title) : title;
  hasPage = hasPage != null ? hasPage : true;
  const { width } = useWindowSize();
  const { userData } = useUser();
  const appKey = ((_a2 = userData == null ? void 0 : userData.email) != null ? _a2 : "no-user") + width.toString();
  const [showIosModal, setShowIosModal] = reactExports.useState(false);
  const { promptInstall } = useInstallPrompt({});
  const contentRef = reactExports.useRef(null);
  const presentPopover = (e) => {
    setPopoverEvent(e.nativeEvent);
    setShowPopover(true);
  };
  const handleBack = () => {
    if (onBackClick) {
      onBackClick();
    } else if (backButtonUrl) {
      router.push(backButtonUrl, "back");
    } else {
      router.goBack();
    }
  };
  const PopoverChild = popoverChildren != null ? popoverChildren : void 0;
  const PopoverItem = popoverItem != null ? popoverItem : void 0;
  const scrollToTop = (duration) => {
    var _a3;
    (_a3 = contentRef.current) == null ? void 0 : _a3.scrollToTop(duration);
  };
  const scrollToBottom = (duration) => {
    var _a3;
    (_a3 = contentRef.current) == null ? void 0 : _a3.scrollToBottom(duration);
  };
  const handleInstallApp = () => {
    if (isIos || isWebView) {
      setShowIosModal(true);
    } else {
      promptInstall();
    }
  };
  const handleRefresh = (e) => {
    window.location.reload();
    e.detail.complete();
  };
  const responseNode = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ShowLoading$1, { message: showLoadingMessage }),
    installAppHeaderHandle && !isPwa && !isWebPlatform && /* @__PURE__ */ jsxRuntimeExports.jsxs(IonHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButton, { color: "dark", onClick: handleInstallApp, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonIcon,
          {
            icon: isIos ? logoApple : logoAndroid,
            className: "mr-2"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t("Instaliraj Aplikaciju") })
      ] }),
      (isIos || isWebView) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        InstallInstructionsIosModal,
        {
          isOpen: showIosModal,
          onClose: () => setShowIosModal(false)
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonHeader,
      {
        className: "ion-no-border ".concat(headerClasses != null ? headerClasses : ""),
        translucent: true,
        collapse: "fade",
        hidden: hideHeader,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ConditionalComponent,
            {
              condition: hasBackButton != null ? hasBackButton : false,
              render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                IonButton,
                {
                  onClick: handleBack,
                  className: "min-w-[41px] ".concat(backButtonCss),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      IonIcon,
                      {
                        slot: !backButtonTitle ? "icon-only" : "start",
                        icon: backButtonIcon != null ? backButtonIcon : chevronBackOutline
                      }
                    ),
                    backButtonTitle
                  ]
                }
              ),
              elseCondition: hasMenuButton,
              renderElse: () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "min-w-[41px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonMenuButton, { className: "my-2" }) })
            }
          ) }),
          headerContent,
          title && /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { ...titleSlot ? { slot: titleSlot } : {}, children: title }),
          PopoverChild && (PopoverItem ? PopoverItem : /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: presentPopover, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonIcon,
            {
              slot: "icon-only",
              ios: ellipsisHorizontal,
              md: ellipsisVertical
            }
          ) }) })),
          headerEndActions && /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: headerEndActions })
        ] })
      }
    ),
    additionalHeader && /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: additionalHeader }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(ContentDataProvider, { contentRef, scrollTop, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonContent,
        {
          ref: contentRef,
          className: contentClasses,
          scrollEvents: true,
          fullscreen: true,
          onIonScroll: (e) => {
            setScrollTop(e.detail.scrollTop);
          },
          children: [
            hasRefresher && /* @__PURE__ */ jsxRuntimeExports.jsx(IonRefresher, { slot: "fixed", onIonRefresh: handleRefresh, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonRefresherContent, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ContentRefContext.Provider,
              {
                value: {
                  scrollToTop,
                  scrollToBottom,
                  contentRef
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { fallbackRender: fallbackRenderContent, children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {}), children: contentLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {}) : children }) })
              }
            )
          ]
        }
      ),
      footer
    ] }),
    PopoverChild && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonPopover,
      {
        isOpen: showPopover,
        event: popoverEvent,
        onDidDismiss: () => setShowPopover(false),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverChild, { dismiss: () => setShowPopover(false) })
      }
    )
  ] }, appKey);
  return hasPage ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonPage, { children: responseNode }) : responseNode;
}
function PageNotFound() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonPage, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: "404 Page Not Found" }) });
}
function IonAlertConfirmation({
  confirmAction,
  cancelAction,
  cancelTextKey,
  confirmTextKey,
  confirmCssClass,
  cancelCssClass,
  ...alertProps
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonAlert,
    {
      backdropDismiss: false,
      buttons: [
        {
          text: t(cancelTextKey != null ? cancelTextKey : "Ne"),
          role: "cancel",
          cssClass: cancelCssClass,
          handler: cancelAction
        },
        {
          text: t(confirmTextKey != null ? confirmTextKey : "Da"),
          role: "confirm",
          cssClass: confirmCssClass,
          handler: confirmAction
        }
      ],
      ...alertProps
    }
  );
}
const IonAlertConfirmationBtn = ({
  alertProps,
  onConfirm,
  children,
  ...btnProps
}) => {
  const [showAlert, setShowAlert] = reactExports.useState(false);
  const handleConfirm = async () => {
    setShowAlert(false);
    await onConfirm();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { ...btnProps, onClick: () => setShowAlert(true), children }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonAlertConfirmation,
      {
        isOpen: showAlert,
        confirmAction: handleConfirm,
        cancelAction: () => setShowAlert(false),
        onDidDismiss: () => setShowAlert(false),
        ...alertProps
      }
    )
  ] });
};
function FormActionButtons({
  onSave,
  isSaving = false,
  saveButtonProps = {},
  onDelete,
  isDeleting = false,
  showDelete = false,
  deleteButtonProps = {},
  deleteConfirmationProps = {},
  className = "mt-6 flex gap-2 justify-center"
}) {
  const { t: t2 } = useTranslation();
  const [showDeleteAlert, setShowDeleteAlert] = reactExports.useState(false);
  const handleDelete = () => {
    if (onDelete) {
      setShowDeleteAlert(true);
    }
  };
  const confirmDelete = async () => {
    if (onDelete) {
      await onDelete();
    }
    setShowDeleteAlert(false);
  };
  const defaultSaveText = saveButtonProps.children || t2("Sa훾uvaj");
  deleteButtonProps.children || t2("Obri큄i");
  const defaultDeleteHeader = deleteConfirmationProps.header || t2("Obri큄i?");
  const defaultDeleteMessage = deleteConfirmationProps.message || t2("Da li ste sigurni da 탑elite da obri큄ete ovaj podatak?");
  const defaultDeleteConfirmText = deleteConfirmationProps.confirmTextKey || t2("Da");
  const defaultDeleteCancelText = deleteConfirmationProps.cancelTextKey || t2("Ne");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className, children: [
      showDelete && onDelete && /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          type: "button",
          onClick: handleDelete,
          disabled: isDeleting,
          fill: "clear",
          color: "danger",
          ...deleteButtonProps,
          children: deleteButtonProps.children || /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline, slot: "icon-only", className: "px-4" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          onClick: onSave,
          disabled: isSaving,
          expand: "block",
          style: { flexGrow: 1, maxWidth: "300px" },
          ...saveButtonProps,
          children: [
            isSaving && /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { slot: "start" }),
            saveButtonProps.children || /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "start" }),
              defaultSaveText
            ] })
          ]
        }
      )
    ] }),
    showDelete && onDelete && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonAlertConfirmation,
      {
        isOpen: showDeleteAlert,
        header: defaultDeleteHeader,
        message: defaultDeleteMessage,
        confirmAction: confirmDelete,
        cancelAction: () => setShowDeleteAlert(false),
        onDidDismiss: () => setShowDeleteAlert(false),
        confirmTextKey: defaultDeleteConfirmText,
        cancelTextKey: defaultDeleteCancelText,
        confirmCssClass: "danger",
        ...deleteConfirmationProps
      }
    )
  ] });
}
const defaultProps = {
  minStep: 0,
  initialStep: 0
};
function FormStepper(props, ref) {
  const swiperRef = reactExports.useRef(null);
  const { renderSteps, onCurrentStepChange, returnQueryParams, swiperProps } = props;
  const { firstStepReset, initialStep } = useDefaultProps(props, defaultProps);
  const [formStep, setFormStep] = reactExports.useState(initialStep);
  const [keyIndex, setKeyIndex] = reactExports.useState(0);
  const { minStep } = useDefaultProps(props, defaultProps);
  const [presentAlert, dismiss] = useConfirmationAlert({
    cancelCallback: () => {
      dismiss();
      returnQueryParams == null ? void 0 : returnQueryParams();
    },
    confirmCallback: () => {
      var _a2;
      const finishCallback = () => {
        setKeyIndex(keyIndex + 1);
        setFormStep(0);
        dismiss();
      };
      if (firstStepReset == null ? void 0 : firstStepReset.callback) {
        if (!((_a2 = firstStepReset == null ? void 0 : firstStepReset.callback) == null ? void 0 : _a2.call(firstStepReset, finishCallback))) {
          finishCallback();
        }
      } else {
        finishCallback();
      }
    }
  });
  const resetStepper = () => {
    setKeyIndex(keyIndex + 1);
    setFormStep(0);
  };
  const handleReset = () => {
    var _a2;
    if (firstStepReset) {
      if (firstStepReset.confirmationAlertOptions) {
        presentAlert(firstStepReset.confirmationAlertOptions);
      } else {
        (_a2 = firstStepReset.callback) == null ? void 0 : _a2.call(firstStepReset);
      }
    }
  };
  const setStepBack = () => {
    setStep(formStep - 1);
    handleSlideChange(formStep + 1);
  };
  const setStepNext = () => {
    setStep(formStep + 1);
    handleSlideChange(formStep + 1);
  };
  const handleSlideChange = (slide) => {
    var _a2;
    (_a2 = swiperRef.current) == null ? void 0 : _a2.swiper.slideTo(slide);
  };
  const setStep = (step) => {
    if (step === minStep && firstStepReset) {
      handleReset();
    } else if (step <= maxStep) {
      setFormStep(step);
      handleSlideChange(step);
    }
  };
  reactExports.useImperativeHandle(ref, () => ({
    handleStepBack() {
      setStepBack();
    },
    handleStepNext() {
      setStepNext();
    },
    getCurrentStep() {
      return formStep;
    },
    handleSetStep(step) {
      setStep(step);
    },
    resetStepper() {
      resetStepper();
    }
  }));
  reactExports.useEffect(() => {
    onCurrentStepChange(formStep);
  }, [formStep]);
  const steps = reactExports.useMemo(
    () => renderSteps({
      handleStepNext: setStepNext,
      handleStepBack: setStepBack,
      setStep,
      getCurrentStep: () => formStep
    }),
    [renderSteps]
  );
  const maxStep = steps.length - 1;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SwiperWrapper$1,
    {
      className: props.className,
      speed: 400,
      initialSlide: formStep,
      allowTouchMove: false,
      currentStep: formStep,
      ...swiperProps,
      ref: swiperRef,
      children: steps.map((stepWrapper, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { children: stepWrapper }, "slide" + index))
    }
  );
}
const FormStepper$1 = reactExports.memo(
  reactExports.forwardRef(FormStepper)
);
function NoAuthenticationPage() {
  const { t: t2 } = useTranslation();
  const dispatch = useAppDispatch$1();
  const handleLogin = () => {
    dispatch(setShowLoginModal(true));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonPage, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { className: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        height: "100%",
        textAlign: "center",
        padding: "20px"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonIcon,
          {
            icon: lockClosedOutline,
            style: {
              fontSize: "64px",
              color: "var(--ion-color-medium)",
              marginBottom: "20px"
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { marginBottom: "16px" }, children: t2("Potrebna je autorizacija") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                color: "var(--ion-color-medium)",
                marginBottom: "32px",
                fontSize: "16px",
                lineHeight: "1.5"
              },
              children: t2(
                "Da biste pristupili ovoj stranici, potrebno je da se prijavite ili registrujete."
              )
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonButton,
          {
            onClick: handleLogin,
            expand: "block",
            style: {
              maxWidth: "300px",
              margin: "0 auto"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: logInOutline, slot: "start" }),
              t2("Login / Registracija")
            ]
          }
        )
      ]
    }
  ) }) });
}
function UnauthorizedPage() {
  const { t: t2 } = useTranslation();
  const { goBack } = useIonRouter();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMainPage, { title: "Nemate pristup stranici", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { className: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
      "탐ao mi je, ali nemate pristup ovoj stranici.",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          style: {
            fontSize: "2em"
          },
          children: "윑"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { button: true, routerLink: "/", routerDirection: "back", children: t2("Nazad na po훾etnu") })
  ] }) }) });
}
const UnauthorizedPage$1 = reactExports.memo(UnauthorizedPage);
const GuardedRoute = ({
  roles,
  fallbackRender,
  hasFallbackWithoutUser,
  ...rest
}) => {
  const user = useAppSelector$1(getUser);
  roles = (roles == null ? void 0 : roles.length) ? roles : void 0;
  if (user && roles && roles.length > 0) {
    const hasRole = userHasRoles(user, roles);
    if (!hasRole) {
      rest.render = fallbackRender != null ? fallbackRender : void 0;
      rest.component = fallbackRender ? void 0 : UnauthorizedPage$1;
    }
  }
  if (!user) {
    rest.render = void 0;
    rest.component = NoAuthenticationPage;
    if (fallbackRender && hasFallbackWithoutUser) {
      rest.render = fallbackRender;
      rest.component = void 0;
    }
  }
  return /* @__PURE__ */ reactExports.createElement(Route, { ...rest, key: user == null ? void 0 : user.id });
};
const GuardedRoute$1 = reactExports.memo(GuardedRoute);
const preloadCoverImg$1 = "/app/assets/preload-cover-CPxF8vUC.webp";
const preloadSquareImg = "/app/assets/preload-square-DKFvohGs.webp";
const imageCache = {};
const preloadImage = (url) => {
  if (!imageCache[url]) {
    const img = new Image();
    img.src = url;
    imageCache[url] = img;
  }
};
const pl = (url) => {
  if (!url) {
    return void 0;
  }
  preloadImage(url);
  return imageCache[url].src;
};
function LazyLoadImgStandard({
  preloadRatio,
  preloadImg,
  ...props
}) {
  const [showEffect, setShowEffect] = reactExports.useState(true);
  const src = pl(props.src);
  preloadImg = preloadImg != null ? preloadImg : preloadRatio === "1-1" ? preloadSquareImg : preloadCoverImg$1;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    buildExports.LazyLoadImage,
    {
      onLoad: () => showEffect && setShowEffect(false),
      effect: showEffect ? "blur" : void 0,
      placeholderSrc: preloadImg,
      ...props,
      src
    }
  );
}
const LazyLoadImgStandard$1 = reactExports.memo(LazyLoadImgStandard);
function useQueryParamsHook({
  beforeNavigation,
  afterNavigation
}) {
  const history = useHistory();
  const params = new URLSearchParams(window.location.search);
  const paramsData = Object.fromEntries(params.entries());
  const [queryParamsData, setQueryParamsData] = reactExports.useState(paramsData);
  const updateQueryParams = reactExports.useCallback(
    (name, value) => {
      beforeNavigation == null ? void 0 : beforeNavigation();
      const params2 = new URLSearchParams(window.location.search);
      if (!value) {
        if (Array.isArray(name)) {
          name.forEach((n) => {
            params2.delete(n);
          });
        } else {
          params2.delete(name);
        }
        setQueryParamsData((prev) => {
          if (Array.isArray(name)) {
            return name.reduce((acc, n) => {
              const { [n]: _, ...rest } = acc;
              return rest;
            }, prev);
          } else {
            const { [name]: _, ...rest } = prev;
            return rest;
          }
        });
      } else {
        if (Array.isArray(name)) {
          name.forEach((n) => {
            params2.set(n, value);
          });
        } else {
          params2.set(name, value);
        }
        setQueryParamsData((prev) => {
          if (Array.isArray(name)) {
            return name.reduce((acc, n) => {
              return { ...acc, [n]: value };
            }, prev);
          } else {
            return { ...prev, [name]: value };
          }
        });
      }
      history.replace({ search: params2.toString() });
      afterNavigation == null ? void 0 : afterNavigation();
    },
    [history]
  );
  const deleteQueryParams = reactExports.useCallback(
    (name) => {
      updateQueryParams(name, null);
    },
    [updateQueryParams]
  );
  return {
    update: updateQueryParams,
    delete: deleteQueryParams,
    data: queryParamsData
  };
}
const useAppFocus = (options = {}) => {
  const { onFocus, onVisibilityChange } = options;
  reactExports.useEffect(() => {
    const handleFocus = () => {
      onFocus == null ? void 0 : onFocus();
    };
    const handleVisibility = () => {
      const state = document.visibilityState;
      const isVisible = state === "visible";
      onVisibilityChange == null ? void 0 : onVisibilityChange(isVisible);
      if (isVisible) {
        handleFocus();
      }
    };
    window.addEventListener("focus", handleFocus);
    window.addEventListener("visibilitychange", handleVisibility);
    return () => {
      window.removeEventListener("focus", handleFocus);
      window.removeEventListener("visibilitychange", handleVisibility);
    };
  }, [onFocus, onVisibilityChange]);
};
const pingApi = sharedApi.injectEndpoints({
  endpoints: (build) => ({
    ping: build.query({
      query: (data) => ({
        url: "/ping",
        method: "POST",
        body: data,
        transformResponse: transformStandardResponseToCamelCase
      })
    })
  })
});
const { usePingQuery } = pingApi;
var PingType = /* @__PURE__ */ ((PingType2) => {
  PingType2["RESERVATIONS"] = "reservations";
  PingType2["WORKERS"] = "workers";
  PingType2["SERVICES"] = "services";
  PingType2["WORKING_HOURS"] = "working_hours";
  PingType2["NOTIFICATIONS"] = "notifications";
  return PingType2;
})(PingType || {});
const usePing = (types, requestData, onChangeHandler, options) => {
  var _a2, _b2;
  const [requestDataState, setRequestDataState] = reactExports.useState({
    lastChecks: {},
    types,
    hashes: {}
  });
  const [isActive, setIsActive] = reactExports.useState((_a2 = options == null ? void 0 : options.autoStart) != null ? _a2 : true);
  const [hasChanges, setHasChanges] = reactExports.useState(false);
  const handleChanges = reactExports.useCallback(
    (changes) => {
      var _a3;
      onChangeHandler(changes);
      (_a3 = options == null ? void 0 : options.onChanges) == null ? void 0 : _a3.call(options, changes);
    },
    [options, onChangeHandler]
  );
  const {
    data: pingResponse,
    error,
    isLoading
  } = usePingQuery(
    {
      lastChecks: requestDataState.lastChecks,
      types: requestDataState.types,
      hashes: requestDataState.hashes,
      ...requestData
    },
    {
      skip: !isActive || hasChanges,
      pollingInterval: (_b2 = options == null ? void 0 : options.interval) != null ? _b2 : 1e4
    }
  );
  const data = pingResponse == null ? void 0 : pingResponse.data;
  reactExports.useEffect(() => {
    var _a3;
    const newLastChecks = { ...requestDataState.lastChecks };
    if (!data) return;
    if (data.hasChanges || !Object.values(requestDataState.lastChecks).length) {
      let hasChanges2 = false;
      Object.keys(data.changes).forEach((type) => {
        var _a4;
        if (((_a4 = data.changes[type]) == null ? void 0 : _a4.hasChanges) || !requestDataState.lastChecks[type]) {
          newLastChecks[type] = data.changes[type].lastUpdated;
          hasChanges2 = true;
        }
      });
      if (hasChanges2) {
        setHasChanges(true);
        if (data.hasChanges) {
          handleChanges(data.changes);
        }
        const timeout = setTimeout(() => {
          setRequestDataState({
            ...requestDataState,
            lastChecks: newLastChecks,
            hashes: data.hashes
          });
          setHasChanges(false);
        }, (_a3 = options == null ? void 0 : options.interval) != null ? _a3 : 1e4);
        return () => clearTimeout(timeout);
      }
    }
  }, [data, handleChanges]);
  const start = reactExports.useCallback(() => setIsActive(true), []);
  const stop = reactExports.useCallback(() => setIsActive(false), []);
  return {
    data,
    error,
    isActive,
    start,
    stop,
    lastChecks: requestDataState.lastChecks,
    hashes: requestDataState.hashes
  };
};
const mainHeaderClasses = isWebPlatform ? "max-w-[80vw]" : "";
const locationApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getFeLocation: builder.query({
      query: ({ slug }) => ({
        url: "locations/data",
        method: "GET",
        params: { slug }
      }),
      providesTags: [TagType$1.LOCATION, TagType$1.APP_LANG],
      transformResponse: transformStandardResponseToCamelCase
    })
  })
});
const { useGetFeLocationQuery } = locationApi;
const HomePage = reactExports.lazy(() => __vitePreload(() => import("./HomePage-VRO4bYdN.js"), true ? __vite__mapDeps([10,1,2,3,4,5,6,11,12,13,7,8,9]) : void 0));
const HomePageWrapper = () => {
  var _a2;
  const { data: locationResponse } = useGetFeLocationQuery(
    {
      slug: activeLocation
    },
    { skip: !!(preloadedLocationData == null ? void 0 : preloadedLocationData.id) }
  );
  const locationData = preloadedLocationData != null ? preloadedLocationData : locationResponse == null ? void 0 : locationResponse.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: (_a2 = locationData == null ? void 0 : locationData.title) != null ? _a2 : "..." }),
      headerClasses: mainHeaderClasses,
      installAppHeaderHandle: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "flex mx-auto mt-5" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(HomePage, {}) })
    }
  );
};
const AppointmentPage = reactExports.lazy(() => __vitePreload(() => import("./AppointmentPage-BYSqsQQ9.js"), true ? __vite__mapDeps([14,1,2,3,4,5,6,15,16,12,13,7,8,9]) : void 0));
const AppointmentPageWrapper = () => {
  const { t: t2 } = useTranslation();
  const [activeStep, handleSetStep] = reactExports.useState(0);
  const handleSegmentChange = (segment) => {
    if (activeStep !== segment.detail.value) {
      handleSetStep(segment.detail.value);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      title: t2("Termini"),
      titleSlot: "start",
      headerClasses: mainHeaderClasses,
      footer: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          routerLink: "".concat(urlPrefix, "/zakazi-novo"),
          color: "dark",
          size: "large",
          className: "border border-gray-500 mb-8",
          children: t2("Zaka탑ite nov termin")
        }
      ),
      additionalHeader: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { className: "border-t", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonSegment, { value: activeStep, onIonChange: handleSegmentChange, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonSegmentButton, { value: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Aktivni termini") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonSegmentButton, { value: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Arhiva") }) })
      ] }) }),
      installAppHeaderHandle: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "flex mx-auto mt-5" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppointmentPage, { activeStep }) })
    }
  );
};
const ProfilePage = reactExports.lazy(() => __vitePreload(() => import("./ProfilePage-BCan-p42.js"), true ? __vite__mapDeps([17,1,2,3,4,5,6,18,19,7,8,20,16,9]) : void 0));
const ProfilePageWrapper = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMainPage, { headerClasses: mainHeaderClasses, title: t2("Profil"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "flex mx-auto mt-5" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProfilePage, {}) }) });
};
const NotificationPage = reactExports.lazy(() => __vitePreload(() => import("./NotificationPage-Cb1rYKaN.js"), true ? __vite__mapDeps([21,1,2,3,4,5,6,15,16,7,8,9]) : void 0));
const NotificationPageWrapper = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      title: t("Notifikacije"),
      headerClasses: mainHeaderClasses,
      installAppHeaderHandle: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "flex mx-auto mt-5" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationPage, {}) })
    }
  );
};
const locationWorkerApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getFeWorkers: builder.query({
      query: ({ locationSlug }) => ({
        url: "locations/workers",
        method: "GET",
        params: { locationSlug }
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [TagType$1.LOCATION_WORKERS]
    }),
    getFeWorker: builder.query({
      query: ({ workerId, locationSlug }) => ({
        url: "locations/worker/".concat(workerId),
        method: "GET",
        params: { locationSlug }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: (result, error, { workerId }) => [
        { type: TagType$1.LOCATION_WORKERS, id: workerId }
      ]
    }),
    createWorker: builder.mutation({
      query: ({ locationSlug, ...body }) => ({
        url: "locations/workers/create",
        method: "POST",
        body: {
          ...humpsExports.decamelizeKeys(body),
          locationSlug
        }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    }),
    updateWorker: builder.mutation({
      query: ({ id, locationSlug, ...body }) => ({
        url: "locations/workers/update",
        method: "POST",
        body: {
          ...humpsExports.decamelizeKeys(body),
          id,
          locationSlug
        }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    }),
    deleteWorker: builder.mutation({
      query: (body) => ({
        url: "locations/workers/delete",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    }),
    getAllWorkers: builder.query({
      query: ({ locationSlug }) => ({
        url: "locations/workers/all",
        method: "GET",
        params: { locationSlug }
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [TagType$1.LOCATION_WORKERS]
    }),
    // Worker Services
    getWorkerServices: builder.query({
      query: ({ locationSlug, workerId }) => ({
        url: "locations/worker/".concat(workerId, "/services"),
        method: "GET",
        params: { locationSlug, workerId }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.LOCATION_WORKERS]
    }),
    storeWorkerService: builder.mutation({
      query: ({ locationSlug, workerId, services }) => ({
        url: "locations/worker/".concat(workerId, "/services"),
        method: "POST",
        body: {
          locationSlug,
          workerId,
          services: services.map((service) => ({
            serviceId: service.serviceId,
            locationId: service.locationId,
            price: service.price,
            duration: service.duration,
            sortOrder: service.sortOrder,
            active: service.active
          }))
        }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    }),
    updateWorkerService: builder.mutation({
      query: ({ locationSlug, workerId, serviceId, ...body }) => ({
        url: "locations/worker/".concat(workerId, "/services/").concat(serviceId),
        method: "PUT",
        body: {
          ...humpsExports.decamelizeKeys(body),
          locationSlug
        }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    }),
    deleteWorkerService: builder.mutation({
      query: ({ locationSlug, workerId, serviceId }) => ({
        url: "locations/worker/".concat(workerId, "/services/").concat(serviceId),
        method: "DELETE",
        params: { locationSlug }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    }),
    deleteWorkerAvatar: builder.mutation({
      query: ({ workerId, locationSlug }) => ({
        url: "locations/workers/".concat(workerId, "/avatar"),
        method: "DELETE",
        params: { locationSlug }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_WORKERS]
    })
  })
});
const {
  useGetFeWorkersQuery,
  useGetFeWorkerQuery,
  useCreateWorkerMutation,
  useUpdateWorkerMutation,
  useDeleteWorkerMutation,
  useGetAllWorkersQuery,
  useGetWorkerServicesQuery,
  useStoreWorkerServiceMutation,
  useUpdateWorkerServiceMutation,
  useDeleteWorkerServiceMutation
} = locationWorkerApi;
const useAppDispatch = () => useDispatch();
const useAppSelector = useSelector;
function SelectWorker({ onSelectWorker, selectedWorker }) {
  const { t: t2 } = useTranslation();
  const { data: workersResult, isLoading: workersLoading } = useGetFeWorkersQuery({ locationSlug: activeLocation });
  const userData = useAppSelector(getUser);
  const handleSelectWorker = (workerId) => {
    const selectedWorkerData = workersResult == null ? void 0 : workersResult.data.find(
      (worker) => worker.id.toString() === workerId.toString()
    );
    if (selectedWorkerData) {
      onSelectWorker(selectedWorkerData);
    }
  };
  reactExports.useEffect(() => {
    if (!selectedWorker && (workersResult == null ? void 0 : workersResult.data.length) && userData) {
      const worker = workersResult == null ? void 0 : workersResult.data.find(
        (worker2) => worker2.userId === userData.id
      );
      if (worker) {
        onSelectWorker(worker);
      }
    }
  }, [userData, workersResult]);
  if (workersLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "m-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonSelect,
    {
      placeholder: t2("Odaberite radnika"),
      labelPlacement: "fixed",
      interface: "action-sheet",
      onIonChange: (event) => handleSelectWorker(event.detail.value),
      value: selectedWorker == null ? void 0 : selectedWorker.id,
      children: workersResult == null ? void 0 : workersResult.data.map((worker) => /* @__PURE__ */ jsxRuntimeExports.jsx(IonSelectOption, { value: worker.id, children: worker.fullName }, worker.id))
    }
  ) });
}
const PrepareWorkingDaysShiftsPage = reactExports.lazy(
  () => __vitePreload(() => import("./PrepareWorkingDaysShiftsPage-HLoOub6u.js"), true ? __vite__mapDeps([22,1,2,3,4,5,6,23,7,8,9]) : void 0)
);
const PrepareWorkingDaysShiftsPageWrapper = () => {
  const { t: t2 } = useTranslation();
  const [selectedWorker, setSelectedWorker] = reactExports.useState(
    null
  );
  const handleSelectWorker = (worker) => {
    setSelectedWorker(worker);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    LayoutMainPage,
    {
      title: t2("Radni dani - Izmene"),
      hasBackButton: true,
      backButtonIcon: exitOutline,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectWorker,
          {
            onSelectWorker: handleSelectWorker,
            selectedWorker
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "flex mx-auto mt-5" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(PrepareWorkingDaysShiftsPage, { selectedWorker }) })
      ]
    }
  );
};
const getSettingsOptions = (urlPrefix2) => [
  {
    title: "Priprema radnih dana",
    path: "".concat(urlPrefix2, "/t/home/pripremi"),
    icon: timeOutline
  },
  {
    title: "Izmeni podatke i slike",
    path: "".concat(urlPrefix2, "/podesavanja/podaci"),
    icon: createOutline
  },
  {
    title: "Usluge",
    path: "".concat(urlPrefix2, "/podesavanja/usluge"),
    icon: constructOutline
  },
  {
    title: "Promo kodovi",
    path: "".concat(urlPrefix2, "/podesavanja/promo-kodovi"),
    icon: giftOutline
  },
  {
    title: "Op큄ta pode큄avanja",
    path: "".concat(urlPrefix2, "/podesavanja/generalno"),
    icon: settingsOutline
  },
  {
    title: "Podesi radno vreme",
    path: "".concat(urlPrefix2, "/podesavanja/radno-vreme"),
    icon: timeOutline
  },
  {
    title: "Radnici",
    path: "".concat(urlPrefix2, "/podesavanja/radnici"),
    icon: peopleOutline
  },
  {
    title: "Vesti i va탑na saop큄tenja",
    path: "".concat(urlPrefix2, "/podesavanja/vesti"),
    icon: megaphoneOutline
  },
  {
    title: "Google Calendar Settings",
    path: "".concat(urlPrefix2, "/podesavanja/google-calendar"),
    icon: calendarOutline
  }
];
const OwnerHomePage = reactExports.lazy(() => __vitePreload(() => import("./OwnerHomePage-C_euHsRz.js"), true ? __vite__mapDeps([24,1,2,3,4,5,6,19,7,8,9]) : void 0));
const OwnerHomePageWrapper = () => {
  var _a2;
  const { t: t2 } = useTranslation();
  const [showActionSheet, setShowActionSheet] = reactExports.useState(false);
  const router = useIonRouter();
  useIonViewWillLeave(() => {
    setShowActionSheet(false);
  });
  const { data: locationResponse } = useGetFeLocationQuery(
    {
      slug: activeLocation
    },
    { skip: !!(preloadedLocationData == null ? void 0 : preloadedLocationData.id) }
  );
  const locationData = preloadedLocationData != null ? preloadedLocationData : locationResponse == null ? void 0 : locationResponse.data;
  const settingsOptions = getSettingsOptions(urlPrefix);
  const handleActionSheetAction = (path) => {
    setShowActionSheet(false);
    router.push(path);
  };
  const footer = /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { color: "light", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2 p-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        onClick: () => setShowActionSheet(true),
        expand: "block",
        color: "dark",
        fill: "outline",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { slot: "start", children: t2("Pode큄avanja") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: settingsOutline, slot: "end" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          routerLink: "".concat(urlPrefix, "/zakazi-novo"),
          expand: "block",
          className: "flex-1",
          color: "dark",
          children: t2("Zaka탑ite")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          routerLink: "".concat(urlPrefix, "/t/home/pripremi"),
          expand: "block",
          className: "flex-1",
          color: "dark",
          fill: "outline",
          children: t2("Priprema radnih dana")
        }
      )
    ] })
  ] }) }) });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    LayoutMainPage,
    {
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-left", children: (_a2 = locationData == null ? void 0 : locationData.title) != null ? _a2 : "..." }),
      headerClasses: mainHeaderClasses,
      installAppHeaderHandle: true,
      footer,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "flex mx-auto mt-5" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(OwnerHomePage, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonActionSheet,
          {
            isOpen: showActionSheet,
            onDidDismiss: () => setShowActionSheet(false),
            header: t2("Pode큄avanja"),
            buttons: [
              ...settingsOptions.map((option) => ({
                text: t2(option.title),
                icon: option.icon,
                handler: () => handleActionSheetAction(option.path)
              })),
              {
                text: t2("Otka탑i"),
                role: "cancel"
              }
            ]
          }
        )
      ]
    }
  );
};
function OwnerAppointmentFooter() {
  const { t: t2 } = useTranslation();
  const { isScrolled } = useContentData() || {};
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonButton,
    {
      routerLink: "".concat(urlPrefix, "/zakazi-novo"),
      className: "border border-gray-500 mb-1",
      color: "dark",
      size: isScrolled ? "small" : "large",
      children: t2("Zaka탑ite nov termin")
    }
  );
}
const OwnerAppointmentPage = reactExports.lazy(() => __vitePreload(() => import("./OwnerAppointmentPage-Dev4Hdnq.js"), true ? __vite__mapDeps([25,1,2,3,4,5,6,23,7,8,15,11,9]) : void 0));
const OwnerAppointmentPageWrapper = () => {
  const { t: t2 } = useTranslation();
  const [selectedWorker, setSelectedWorker] = reactExports.useState(
    null
  );
  const handleSelectWorker = (worker) => {
    setSelectedWorker(worker);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      title: t2("Termini"),
      titleSlot: "start",
      headerClasses: mainHeaderClasses,
      footer: /* @__PURE__ */ jsxRuntimeExports.jsx(OwnerAppointmentFooter, {}),
      additionalHeader: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectWorker,
        {
          onSelectWorker: handleSelectWorker,
          selectedWorker
        }
      ) }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "flex mx-auto mt-5" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(OwnerAppointmentPage, { selectedWorker }) })
    }
  );
};
const SettingsPage = reactExports.lazy(() => __vitePreload(() => import("./SettingsPage-BhtBHh1y.js"), true ? __vite__mapDeps([26,1,2,3,4,5,6,7,8,9]) : void 0));
function SettingsPageWrapper() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Pode큄avanja"),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsPage, {})
    }
  );
}
const MainTabs = ({ match }) => {
  const { t: t2 } = useTranslation();
  const url = fixUrlPath(match.url);
  const tabBarClasses = isWebPlatform ? "justify-end py-1 mb-[1px] z-10 bg-transparent w-[40vw] right-0 absolute" : "";
  const mainRoles = [
    UserGroupCode.Admin,
    UserGroupCode.Owner,
    UserGroupCode.Worker
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTabs, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRouterOutlet, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "".concat(url, "/"), exact: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Redirect, { to: "".concat(url, "/home") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "".concat(url, "/salon"), exact: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Redirect, { to: "".concat(url, "/home") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        GuardedRoute$1,
        {
          path: "".concat(url, "/home"),
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(OwnerHomePageWrapper, {}),
          fallbackRender: () => /* @__PURE__ */ jsxRuntimeExports.jsx(HomePageWrapper, {}),
          hasFallbackWithoutUser: true,
          exact: true,
          roles: mainRoles
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        GuardedRoute$1,
        {
          path: "".concat(url, "/termini"),
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(OwnerAppointmentPageWrapper, {}),
          fallbackRender: () => /* @__PURE__ */ jsxRuntimeExports.jsx(AppointmentPageWrapper, {}),
          hasFallbackWithoutUser: true,
          exact: true,
          roles: mainRoles
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        GuardedRoute$1,
        {
          path: "".concat(url, "/home/pripremi"),
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(PrepareWorkingDaysShiftsPageWrapper, {}),
          exact: true,
          roles: mainRoles
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        GuardedRoute$1,
        {
          path: "".concat(url, "/notifikacije"),
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationPageWrapper, {}),
          exact: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        GuardedRoute$1,
        {
          path: "".concat(url, "/profil"),
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(ProfilePageWrapper, {}),
          exact: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        GuardedRoute$1,
        {
          path: "".concat(url, "/podesavanja"),
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsPageWrapper, {}),
          exact: true,
          roles: mainRoles
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTabBar, { slot: tabPosition, className: tabBarClasses, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTabButton, { tab: "home", href: "".concat(url, "/home"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: homeOutline }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTabButton, { tab: "termini", href: "".concat(url, "/termini"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: alarmOutline }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Termini") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTabButton, { tab: "notifikacije", href: "".concat(url, "/notifikacije"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: notificationsOutline }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Notifikacije") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTabButton, { tab: "profil", href: "".concat(url, "/profil"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: personOutline }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Profil") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTabButton, { tab: "podesavanja", href: "".concat(url, "/podesavanja"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: settingsOutline }) })
    ] })
  ] }, activeLocation);
};
const preloadCoverImg = "/app/assets/logo-square-Bsnn6NiG.webp";
function SelectWorkerStep({
  workerId,
  setSelectedWorker,
  activeWorkersCount = 0,
  selectedCategory
}) {
  const { t: t2 } = useTranslation();
  const { data: workersResult, isLoading: workersLoading } = useGetFeWorkersQuery({ locationSlug: activeLocation });
  const workers = (workersResult == null ? void 0 : workersResult.data) || [];
  const handleSelectWorker = (worker) => () => {
    setSelectedWorker(worker);
  };
  reactExports.useEffect(() => {
    if (workerId && workers.length) {
      const worker = workers.find((w) => w.id == workerId);
      setSelectedWorker(worker);
    }
  }, [workerId, workers]);
  if (workersLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SceletonLoader, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "px-4 py-2", children: t2("Izaberite radnika") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonList, { className: "w-full bg-inherit", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonItem,
        {
          button: true,
          onClick: handleSelectWorker(null),
          detail: false,
          disabled: activeWorkersCount === 1,
          className: "mb-2",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonAvatar, { slot: "start", className: "w-14 h-14 rounded-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-full bg-gray-700 flex items-center justify-center rounded-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonIcon,
              {
                icon: peopleOutline,
                className: "text-3xl text-gray-300"
              }
            ) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-semibold", children: t2("Prvi slobodan") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "end", icon: chevronForwardOutline })
          ]
        }
      ),
      workers.map((worker) => {
        var _a2;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonItem,
          {
            button: true,
            onClick: handleSelectWorker(worker),
            detail: false,
            className: "mb-2",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonAvatar, { slot: "start", className: "w-14 h-14 rounded-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                LazyLoadImgStandard$1,
                {
                  src: getPathBySize((_a2 = worker.avatar) == null ? void 0 : _a2.pathByResolution),
                  preloadImg: preloadCoverImg,
                  alt: worker.fullName,
                  className: "w-full h-full object-cover rounded-full"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-semibold", children: worker.fullName }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { slot: "end", icon: chevronForwardOutline })
            ]
          },
          worker.id
        );
      })
    ] })
  ] });
}
const maxQuantity = 4;
const maxServicesTime = 180;
function SelectServiceListItem({
  service,
  serviceGroup,
  onSelectService,
  groupsSelectedServices,
  hasMultiplePersons,
  allSelectedServicesDurationSum,
  selectedWorker
}) {
  const selectedServices = reactExports.useMemo(() => {
    const selectedGroup = groupsSelectedServices.find(
      (group) => group.serviceGroup.id === serviceGroup.id
    );
    return (selectedGroup == null ? void 0 : selectedGroup.services) || [];
  }, [groupsSelectedServices, serviceGroup]);
  const selectedService = selectedServices.find((s) => s.id === service.id);
  const isSelected = !!selectedService;
  let effectivePrice = service.price;
  let effectiveDuration = service.duration;
  if (selectedWorker && service.locationWorkers) {
    const workerData = service.locationWorkers.find(
      (worker) => worker.id === selectedWorker.id
    );
    if (workerData == null ? void 0 : workerData.pivot) {
      effectivePrice = workerData.pivot.price !== void 0 && workerData.pivot.price !== null ? workerData.pivot.price : service.price;
      effectiveDuration = workerData.pivot.duration !== void 0 && workerData.pivot.duration !== null ? workerData.pivot.duration : service.duration;
    }
  }
  const hasWorkerSelected = selectedWorker !== null && selectedWorker !== void 0;
  const currencyLabel = reactExports.useMemo(
    () => service.currency === 1 ? "EUR" : "RSD",
    [service.currency]
  );
  const priceDisplay = reactExports.useMemo(() => {
    if (hasWorkerSelected) {
      return "".concat(formatPriceSimple(effectivePrice), " ").concat(currencyLabel);
    }
    if (service.minPrice && service.maxPrice && service.minPrice !== service.maxPrice) {
      return "od ".concat(formatPriceSimple(service.minPrice), " ").concat(currencyLabel);
    }
    return "".concat(formatPriceSimple(effectivePrice), " ").concat(currencyLabel);
  }, [
    hasWorkerSelected,
    effectivePrice,
    service.minPrice,
    service.maxPrice,
    currencyLabel
  ]);
  const durationDisplay = reactExports.useMemo(() => {
    if (hasWorkerSelected) {
      return "".concat(effectiveDuration, " min");
    }
    if (service.minDuration && service.maxDuration && service.minDuration !== service.maxDuration) {
      return "od ".concat(service.minDuration, " min");
    }
    return "".concat(effectiveDuration, " min");
  }, [
    hasWorkerSelected,
    effectiveDuration,
    service.minDuration,
    service.maxDuration
  ]);
  const isMaxedOut = (selectedService == null ? void 0 : selectedService.quantity) === maxQuantity || allSelectedServicesDurationSum >= maxServicesTime;
  const handleToggleService = (e) => {
    e.stopPropagation();
    if (isSelected) {
      onSelectService(serviceGroup, selectedService);
    } else {
      onSelectService(serviceGroup, { ...service, quantity: 1 });
    }
  };
  const handleAddQuantity = (e) => {
    var _a2;
    e.stopPropagation();
    if (selectedService) {
      const quantity = (_a2 = selectedService.quantity) != null ? _a2 : 1;
      if (quantity < maxQuantity && allSelectedServicesDurationSum < maxServicesTime) {
        onSelectService(serviceGroup, {
          ...selectedService,
          quantity: quantity + 1
        });
      }
    }
  };
  const handleRemoveQuantity = (e) => {
    var _a2;
    e.stopPropagation();
    if (selectedService) {
      const quantity = (_a2 = selectedService.quantity) != null ? _a2 : 1;
      if (quantity > 1) {
        onSelectService(serviceGroup, {
          ...selectedService,
          quantity: quantity - 1
        });
      } else {
        onSelectService(serviceGroup, selectedService);
      }
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonItem,
      {
        lines: "none",
        button: true,
        detail: false,
        onClick: handleToggleService,
        disabled: !isSelected && isMaxedOut,
        className: "".concat(isSelected && hasMultiplePersons && selectedService ? "bg-green-500/10 border-green-500/10 border-l-4 border-l-green-500" : isSelected ? "bg-green-500/10 border-green-500/10 border-l-4 border-l-green-500 border-b border-green-500/10" : "border-b border-b-gray-600 dark:border-gray-700/40"),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { className: "py-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-semibold mb-1.5 dark:text-gray-100", children: service.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center text-sm gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500 dark:text-gray-300 font-medium", children: durationDisplay }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-400", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-600 dark:text-green-500 font-semibold", children: priceDisplay })
            ] }),
            service.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 dark:text-gray-400 mt-1.5 line-clamp-2", children: service.description })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              slot: "end",
              className: "flex items-center",
              onClick: (e) => e.stopPropagation(),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonButton,
                {
                  fill: "clear",
                  size: "default",
                  color: isSelected ? "success" : "medium",
                  onClick: handleToggleService,
                  disabled: !isSelected && isMaxedOut,
                  className: "m-0",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    IonIcon,
                    {
                      icon: isSelected ? checkmarkCircle : addOutline,
                      className: "text-3xl",
                      style: isSelected ? { color: "#10b981" } : void 0
                    }
                  )
                }
              )
            }
          )
        ]
      }
    ),
    isSelected && hasMultiplePersons && selectedService && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex items-center justify-between px-4 py-2 border-b border-b-green-500 border-l-4 border-l-green-500",
        style: { backgroundColor: "var(--ion-item-background)" },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleRemoveQuantity, className: "p-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonIcon,
            {
              icon: selectedService.quantity === 1 ? trashOutline : removeOutline,
              className: "text-lg",
              style: { color: "#ef4444" }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "text-base font-semibold px-3",
              style: { color: "var(--ion-text-color)" },
              children: selectedService.quantity
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleAddQuantity,
              disabled: selectedService.quantity === maxQuantity || allSelectedServicesDurationSum >= maxServicesTime,
              className: "p-1 disabled:opacity-50",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonIcon,
                {
                  icon: addOutline,
                  className: "text-lg",
                  style: { color: "#3b82f6" }
                }
              )
            }
          )
        ]
      }
    )
  ] });
}
function SelectAppointmentStepV2({
  onBack,
  onNext,
  selectedWorker,
  serviceGroups,
  onSelectService,
  groupsSelectedServices,
  hasMultiplePersons,
  setHasMultiplePersons,
  selectedCategory
}) {
  const { t: t2 } = useTranslation();
  const toggleMultiplePersons = () => {
    setHasMultiplePersons(!hasMultiplePersons);
  };
  const filteredServiceGroups = reactExports.useMemo(() => {
    let filtered = serviceGroups;
    if (selectedCategory) {
      filtered = filtered.filter((group) => {
        var _a2, _b2;
        return (_b2 = (_a2 = group.serviceCategories) == null ? void 0 : _a2.some(
          (cat) => cat.id === selectedCategory.id
        )) != null ? _b2 : false;
      });
    }
    if (!selectedWorker) {
      return filtered;
    }
    if (selectedWorker.isSyncedService) {
      return filtered;
    }
    return filtered.map((group) => ({
      ...group,
      services: group.services.filter((service) => {
        return service.locationWorkers && service.locationWorkers.some(
          (worker) => worker.id === selectedWorker.id
        );
      })
    }));
  }, [serviceGroups, selectedCategory, selectedWorker]);
  const allSelectedServicesDurationSum = reactExports.useMemo(() => {
    return groupsSelectedServices.reduce(
      (acc, group) => {
        var _a2, _b2;
        return acc + ((_b2 = (_a2 = group.services) == null ? void 0 : _a2.reduce(
          (acc2, service) => {
            var _a3;
            return acc2 + service.duration * ((_a3 = service.quantity) != null ? _a3 : 1);
          },
          0
        )) != null ? _b2 : 0);
      },
      0
    );
  }, [groupsSelectedServices]);
  const [expandedAccordions, setExpandedAccordions] = reactExports.useState([]);
  reactExports.useEffect(() => {
    const allValues = filteredServiceGroups.map((g) => "group-".concat(g.id));
    setExpandedAccordions(allValues);
  }, [filteredServiceGroups]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-[80px]", children: [
    selectedWorker && /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "px-4 pt-4 pb-2 text-lg font-semibold dark:text-gray-100", children: selectedWorker.fullName }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 pb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonToggle,
      {
        checked: hasMultiplePersons,
        onIonChange: toggleMultiplePersons,
        children: t2("Za vi큄e osoba")
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonAccordionGroup,
      {
        multiple: true,
        value: expandedAccordions,
        onIonChange: (e) => {
          const val = e.detail.value;
          const next = Array.isArray(val) ? val : val ? [val] : [];
          setExpandedAccordions(next);
        },
        children: filteredServiceGroups.map((group) => /* @__PURE__ */ jsxRuntimeExports.jsxs(IonAccordion, { value: "group-".concat(group.id), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { slot: "header", className: "bg-gray-100 dark:bg-gray-800 border-l-4 border-l-blue-500", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { className: "text-base font-semibold text-gray-800 dark:text-gray-200 py-1", children: group.title }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { slot: "content", className: "bg-white dark:bg-[var(--ion-background-color)]", children: group.services.map((service) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectServiceListItem,
            {
              service,
              serviceGroup: group,
              onSelectService,
              groupsSelectedServices,
              hasMultiplePersons,
              allSelectedServicesDurationSum,
              selectedWorker
            },
            service.id
          )) })
        ] }, group.id))
      }
    )
  ] });
}
const serviceGroupApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getFeServiceGroups: builder.query({
      query: ({ locationSlug, workerId, withWorkers }) => ({
        url: "locations/services-groups",
        method: "GET",
        params: { locationSlug, workerId, withWorkers }
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [TagType$1.APP_LANG, TagType$1.SERVICES_GROUPS]
    })
  })
});
const { useGetFeServiceGroupsQuery } = serviceGroupApi;
const serviceCategoryApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getFeServiceCategories: builder.query({
      query: ({ locationSlug, active }) => ({
        url: "locations/service-categories",
        method: "GET",
        params: { locationSlug, active }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.APP_LANG, TagType$1.SERVICES_GROUPS]
    })
  })
});
const { useGetFeServiceCategoriesQuery } = serviceCategoryApi;
function SelectCategoryStep({
  categories,
  selectedCategory,
  onCategorySelect
}) {
  const { t: t2 } = useTranslation();
  if (categories.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardTitle, { children: t2("Izaberite delatnost") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonList, { children: categories.map((category) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonItem,
      {
        button: true,
        detail: false,
        onClick: () => onCategorySelect(category),
        className: (selectedCategory == null ? void 0 : selectedCategory.id) === category.id ? "ion-activated" : "",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: category.title }),
          category.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-500", children: category.description })
        ] })
      },
      category.id
    )) }) })
  ] });
}
function generateWeek(startDate) {
  const week = [];
  for (let i = 0; i < 7; i++) {
    week.push(addDays(startDate, i));
  }
  return week;
}
function formatMonthYear(date) {
  const monthNames = [
    "Januar",
    "Februar",
    "Mart",
    "April",
    "Maj",
    "Jun",
    "Jul",
    "Avgust",
    "Septembar",
    "Oktobar",
    "Novembar",
    "Decembar"
  ];
  return "".concat(monthNames[date.getMonth()], " ").concat(date.getFullYear());
}
function isToday(date) {
  return isToday$1(date);
}
function isPastDate(date) {
  const today = startOfDay(/* @__PURE__ */ new Date());
  const checkDate = startOfDay(date);
  return checkDate < today;
}
function hasAnySlotsInWeek(weekSlots) {
  return Object.values(weekSlots).some(
    (daySlots) => daySlots.some((workerSlots) => workerSlots.hasSlots)
  );
}
function getDaysWithSlotsSet(weekSlots) {
  const daysSet = /* @__PURE__ */ new Set();
  Object.entries(weekSlots).forEach(([dateStr, slots]) => {
    if (slots.some((ws) => ws.hasSlots)) {
      daysSet.add(dateStr);
    }
  });
  return daysSet;
}
const bookingCalendarApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getWeekSlots: builder.query({
      query: (params) => {
        const body = {
          locationSlug: params.locationSlug,
          startDate: params.startDate,
          endDate: params.endDate,
          serviceIds: params.serviceIds
        };
        if (params.workerIds !== void 0 && params.workerIds !== null) {
          body.workerIds = params.workerIds;
        }
        if (params.categoryId) {
          body.categoryId = params.categoryId;
        }
        return {
          url: "locations/".concat(params.locationSlug, "/slots/week"),
          method: "POST",
          body
        };
      },
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [
        { type: TagType$1.SHIFT, id: "WEEK_SLOTS" },
        { type: TagType$1.RESERVATION, id: "LIST" }
      ],
      // Cache za 5 minuta
      keepUnusedDataFor: 300
    }),
    getTimeGaps: builder.query({
      query: (params) => {
        const body = {
          locationSlug: params.locationSlug,
          startDate: params.startDate,
          endDate: params.endDate
        };
        if (params.workerIds !== void 0 && params.workerIds !== null) {
          body.workerIds = params.workerIds;
        }
        if (params.includeReservations !== void 0) {
          body.includeReservations = params.includeReservations;
        }
        if (params.onlyLongestGap !== void 0) {
          body.onlyLongestGap = params.onlyLongestGap;
        }
        return {
          url: "locations/".concat(params.locationSlug, "/slots/gaps"),
          method: "POST",
          body
        };
      },
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: (result, error, { locationSlug }) => [
        { type: TagType$1.SHIFT, id: "TIME_GAPS" },
        { type: TagType$1.RESERVATION, id: "LIST" },
        { type: TagType$1.LOCATION, id: locationSlug }
      ],
      keepUnusedDataFor: 300
      // 5 minutes
    }),
    getReservationsList: builder.query({
      query: (params) => {
        const queryParams = new URLSearchParams();
        queryParams.append("startDate", params.startDate);
        queryParams.append("endDate", params.endDate);
        if (params.workerIds !== void 0 && params.workerIds !== null && params.workerIds.length > 0) {
          params.workerIds.forEach(
            (id) => queryParams.append("workerIds[]", id.toString())
          );
        }
        if (params.status) {
          queryParams.append("status", params.status);
        }
        if (params.page) {
          queryParams.append("page", params.page.toString());
        }
        if (params.perPage) {
          queryParams.append("perPage", params.perPage.toString());
        }
        return {
          url: "locations/".concat(params.locationSlug, "/reservations/list?").concat(queryParams.toString()),
          method: "GET"
        };
      },
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: (result, error, { locationSlug }) => [
        { type: TagType$1.RESERVATION, id: "LIST" },
        { type: TagType$1.LOCATION, id: locationSlug }
      ],
      keepUnusedDataFor: 60
      // 1 minute
    })
  })
});
const {
  useGetTimeGapsQuery
} = bookingCalendarApi;
const PAUSE_BETWEEN_SLOTS_MINUTES = 10;
const MIN_SLOT_DIFFERENCE_MINUTES = 15;
function calculateTotalServiceDuration(selectedServices) {
  return selectedServices.flatMap((group) => {
    var _a2;
    return (_a2 = group.services) != null ? _a2 : [];
  }).reduce((total, service) => {
    var _a2;
    return total + service.duration * ((_a2 = service.quantity) != null ? _a2 : 1);
  }, 0);
}
function canGapFitServices(gap, totalServiceDuration, pauseBetweenReservations = PAUSE_BETWEEN_SLOTS_MINUTES) {
  return gap.duration >= totalServiceDuration + pauseBetweenReservations;
}
function generateSlotsFromGaps(gaps, selectedServices, slotInterval = MIN_SLOT_DIFFERENCE_MINUTES, pauseBetweenReservations = PAUSE_BETWEEN_SLOTS_MINUTES, delay = 0) {
  if (gaps.length === 0) {
    return [];
  }
  const totalServiceDuration = calculateTotalServiceDuration(selectedServices);
  const timezone = getAppTimezone();
  const currentTime = /* @__PURE__ */ new Date();
  const slots = [];
  const validGaps = gaps.filter(
    (gap) => canGapFitServices(gap, totalServiceDuration, pauseBetweenReservations)
  );
  for (const gap of validGaps) {
    const gapStartUtc = parseISO(gap.time);
    const gapEndUtc = addMinutes(gapStartUtc, gap.duration);
    const gapStartLocal = toZonedTime(gapStartUtc, timezone);
    const gapEndLocal = toZonedTime(gapEndUtc, timezone);
    const minStartTime = addMinutes(currentTime, delay);
    if (gapStartLocal < minStartTime) {
      const adjustedStart = minStartTime;
      if (adjustedStart >= gapEndLocal) {
        continue;
      }
      generateSlotsInGap(
        adjustedStart,
        gapEndLocal,
        totalServiceDuration,
        pauseBetweenReservations,
        slotInterval,
        slots,
        gapStartLocal
      );
    } else {
      generateSlotsInGap(
        gapStartLocal,
        gapEndLocal,
        totalServiceDuration,
        pauseBetweenReservations,
        slotInterval,
        slots,
        gapStartLocal
      );
    }
  }
  const finalSlots = Array.from(new Set(slots)).sort();
  return finalSlots;
}
function generateSlotsInGap(gapStart, gapEnd, totalServiceDuration, pauseBetweenReservations, slotInterval, slots, originalGapStart) {
  const timezone = getAppTimezone();
  const allSlots = [];
  let currentNormalSlot = new Date(gapStart);
  const gapStartMinutes = currentNormalSlot.getMinutes();
  if (gapStartMinutes > 0 && gapStartMinutes < 30) {
    currentNormalSlot.setMinutes(30, 0, 0);
  } else if (gapStartMinutes >= 30) {
    currentNormalSlot.setHours(currentNormalSlot.getHours() + 1, 0, 0);
  } else {
    currentNormalSlot.setMinutes(0, 0, 0);
  }
  while (currentNormalSlot < gapEnd) {
    const slotEnd = addMinutes(currentNormalSlot, totalServiceDuration);
    if (slotEnd <= gapEnd) {
      allSlots.push(new Date(currentNormalSlot));
    }
    currentNormalSlot = addMinutes(currentNormalSlot, slotInterval);
  }
  const gapStartMinutesOnly = gapStart.getMinutes();
  const isOnNormalTime = gapStartMinutesOnly === 0 || gapStartMinutesOnly === 30;
  if (!isOnNormalTime) {
    const gapStartSlotEnd = addMinutes(gapStart, totalServiceDuration);
    if (gapStartSlotEnd <= gapEnd) {
      allSlots.push(new Date(gapStart));
    }
  }
  allSlots.sort((a, b) => a.getTime() - b.getTime());
  const filteredSlots = [];
  for (const slot of allSlots) {
    const isTooClose = filteredSlots.some((existingSlot) => {
      const diffMinutes = Math.abs((slot.getTime() - existingSlot.getTime()) / 1e3 / 60);
      return diffMinutes > 0 && diffMinutes < MIN_SLOT_DIFFERENCE_MINUTES;
    });
    if (!isTooClose) {
      filteredSlots.push(slot);
    }
  }
  for (const slot of filteredSlots) {
    const slotStartUtc = fromZonedTime(slot, timezone);
    const slotTime = formatInTimeZone(slotStartUtc, "UTC", "HH:mm");
    const isPreviousDay = slot.getDate() !== originalGapStart.getDate();
    const prefixedSlot = isPreviousDay ? "-".concat(slotTime) : slotTime;
    if (!slots.includes(prefixedSlot)) {
      slots.push(prefixedSlot);
    }
  }
}
function useBookingCalendar({
  locationSlug,
  worker,
  workerIds,
  selectedServices,
  selectedCategory,
  maxPreparedDate,
  isActive = true
}) {
  const today = reactExports.useMemo(() => /* @__PURE__ */ new Date(), []);
  const [currentWeek, setCurrentWeek] = reactExports.useState(
    () => generateWeek(today)
  );
  const [selectedDate, setSelectedDate] = reactExports.useState(today);
  const [isCalendarOpen, setIsCalendarOpen] = reactExports.useState(false);
  const [currentMonth, setCurrentMonth] = reactExports.useState(
    () => startOfMonth(today)
  );
  const [weekSlots, setWeekSlots] = reactExports.useState({});
  const [errorMessage, setErrorMessage] = reactExports.useState(null);
  const serviceIds = reactExports.useMemo(
    () => selectedServices.flatMap(
      (group) => {
        var _a2;
        return ((_a2 = group.services) != null ? _a2 : []).map((service) => service.id).filter((id) => typeof id === "number");
      }
    ),
    [selectedServices]
  );
  const workerIdsToSend = reactExports.useMemo(() => {
    if (worker == null ? void 0 : worker.id) {
      return [worker.id];
    }
    if (workerIds !== void 0) {
      return workerIds;
    }
    return null;
  }, [worker == null ? void 0 : worker.id, workerIds]);
  const timezone = getAppTimezone();
  const monthToUse = reactExports.useMemo(() => {
    if (isCalendarOpen && currentMonth) {
      return startOfMonth(currentMonth);
    }
    return startOfMonth(currentWeek[0]);
  }, [currentWeek, currentMonth, isCalendarOpen]);
  const startDate = reactExports.useMemo(() => {
    const monthStart = startOfMonth(monthToUse);
    const calendarStart = startOfWeek(monthStart, { weekStartsOn: 1 });
    return formatInTimeZone(calendarStart, timezone, "yyyy-MM-dd'T'00:00:00XXX");
  }, [monthToUse, timezone]);
  const endDate = reactExports.useMemo(() => {
    const monthEnd = endOfMonth(monthToUse);
    const weekContainingMonthEnd = startOfWeek(monthEnd, { weekStartsOn: 1 });
    const calendarEnd = addDays(weekContainingMonthEnd, 6);
    return formatInTimeZone(calendarEnd, timezone, "yyyy-MM-dd'T'23:59:59XXX");
  }, [monthToUse, timezone]);
  const shouldSkip = !isActive || serviceIds.length === 0;
  const { data: workersData } = useGetFeWorkersQuery({ locationSlug });
  const workersById = reactExports.useMemo(() => {
    if (!(workersData == null ? void 0 : workersData.data)) return {};
    return workersData.data.reduce(
      (acc, worker2) => {
        acc[worker2.id] = worker2;
        return acc;
      },
      {}
    );
  }, [workersData]);
  const {
    isLoading,
    isFetching,
    data: gapsData,
    error
  } = useGetTimeGapsQuery(
    {
      locationSlug,
      startDate,
      endDate,
      workerIds: workerIdsToSend,
      includeReservations: false
      // We don't need reservations for slot generation
      // onlyLongestGap: false, // Always get all gaps, not just longest (for consistency between week and month view)
    },
    {
      skip: shouldSkip
    }
  );
  reactExports.useEffect(() => {
    if (error) {
      console.error("Error loading week slots:", error);
      setErrorMessage(
        "Slot service is currently unavailable. Please try again later."
      );
      setWeekSlots({});
    } else {
      setErrorMessage(null);
    }
  }, [error]);
  const datesToProcess = reactExports.useMemo(() => {
    if (isCalendarOpen && currentMonth) {
      const monthStart = startOfMonth(currentMonth);
      const monthEnd = endOfMonth(currentMonth);
      const calendarStart = startOfWeek(monthStart, { weekStartsOn: 1 });
      const weekContainingMonthEnd = startOfWeek(monthEnd, { weekStartsOn: 1 });
      addDays(weekContainingMonthEnd, 6);
      return Array.from({ length: 35 }, (_, i) => addDays(calendarStart, i));
    }
    return currentWeek;
  }, [isCalendarOpen, currentMonth, currentWeek]);
  reactExports.useEffect(() => {
    if (gapsData == null ? void 0 : gapsData.data) {
      const { gaps: gapsByDate } = gapsData.data;
      const slotsByDate = {};
      datesToProcess.forEach((date) => {
        const dateKeyWithDashes = format(date, "yyyy-MM-dd");
        const dateKeyWithoutDashes = format(date, "yyyyMMdd");
        const dayGaps = gapsByDate[dateKeyWithoutDashes] || gapsByDate[dateKeyWithDashes] || [];
        if (dayGaps.length === 0) {
          if (workersData == null ? void 0 : workersData.data) {
            slotsByDate[dateKeyWithDashes] = workersData.data.map((worker2) => ({
              worker: worker2,
              slots: [],
              hasSlots: false
            }));
          }
          return;
        }
        const gapsByWorker = {};
        dayGaps.forEach((gap) => {
          if (!gapsByWorker[gap.workerId]) {
            gapsByWorker[gap.workerId] = [];
          }
          gapsByWorker[gap.workerId].push(gap);
        });
        const workerSlots = [];
        Object.entries(gapsByWorker).forEach(([workerIdStr, workerGaps]) => {
          const workerId = parseInt(workerIdStr, 10);
          const worker2 = workersById[workerId];
          if (!worker2) {
            return;
          }
          let gapsToUse = workerGaps;
          const slots = generateSlotsFromGaps(
            gapsToUse,
            selectedServices,
            reservationTimeInterval,
            void 0,
            // Use default pause
            30
            // delay in minutes
          );
          const timeSlots = slots.map((time) => ({
            time
          }));
          workerSlots.push({
            worker: worker2,
            slots: timeSlots,
            hasSlots: timeSlots.length > 0
          });
        });
        if (workersData == null ? void 0 : workersData.data) {
          workersData.data.forEach((worker2) => {
            const hasWorker = workerSlots.some(
              (ws) => ws.worker.id === worker2.id
            );
            if (!hasWorker) {
              workerSlots.push({
                worker: worker2,
                slots: [],
                hasSlots: false
              });
            }
          });
        }
        slotsByDate[dateKeyWithDashes] = workerSlots;
      });
      setWeekSlots(slotsByDate);
    } else if ((gapsData == null ? void 0 : gapsData.data) && Object.keys(gapsData.data.gaps).length === 0) {
      if (workersData == null ? void 0 : workersData.data) {
        const slotsByDate = {};
        datesToProcess.forEach((date) => {
          const dateKey = format(date, "yyyy-MM-dd");
          slotsByDate[dateKey] = workersData.data.map((worker2) => ({
            worker: worker2,
            slots: [],
            hasSlots: false
          }));
        });
        setWeekSlots(slotsByDate);
      } else {
        setWeekSlots({});
      }
    }
  }, [
    gapsData,
    selectedServices,
    datesToProcess,
    workersById,
    workersData,
    isCalendarOpen,
    currentMonth
  ]);
  const hasAnySlots = reactExports.useMemo(() => hasAnySlotsInWeek(weekSlots), [weekSlots]);
  const daysWithSlots = reactExports.useMemo(
    () => getDaysWithSlotsSet(weekSlots),
    [weekSlots]
  );
  const canGoPrevious = reactExports.useMemo(() => {
    if (isCalendarOpen) {
      const todayMonth = startOfMonth(today);
      return currentMonth > todayMonth;
    }
    const firstDayOfWeek = currentWeek[0];
    return firstDayOfWeek > today;
  }, [currentWeek, currentMonth, isCalendarOpen, today]);
  const canGoNext = reactExports.useMemo(() => {
    if (isCalendarOpen) {
      if (!maxPreparedDate) return true;
      const maxMonth = startOfMonth(maxPreparedDate);
      return currentMonth < maxMonth;
    }
    if (!maxPreparedDate) return true;
    const lastDayOfWeek = currentWeek[6];
    return lastDayOfWeek < maxPreparedDate;
  }, [currentWeek, currentMonth, isCalendarOpen, maxPreparedDate]);
  const goToPreviousMonth = reactExports.useCallback(() => {
    if (!canGoPrevious) return;
    setCurrentMonth((prev) => startOfMonth(subMonths(prev)));
  }, [canGoPrevious]);
  const goToNextMonth = reactExports.useCallback(() => {
    if (!canGoNext) return;
    setCurrentMonth((prev) => startOfMonth(addMonths(prev, 1)));
  }, [canGoNext]);
  const goToPreviousWeek = reactExports.useCallback(() => {
    if (isCalendarOpen) {
      goToPreviousMonth();
      return;
    }
    if (!canGoPrevious) return;
    const newStartDate = addDays(currentWeek[0], -7);
    setCurrentWeek(generateWeek(newStartDate));
  }, [currentWeek, canGoPrevious, isCalendarOpen, goToPreviousMonth]);
  const goToNextWeek = reactExports.useCallback(() => {
    if (isCalendarOpen) {
      goToNextMonth();
      return;
    }
    if (!canGoNext) return;
    const newStartDate = addDays(currentWeek[0], 7);
    setCurrentWeek(generateWeek(newStartDate));
  }, [currentWeek, canGoNext, isCalendarOpen, goToNextMonth]);
  const toggleCalendar = reactExports.useCallback(() => {
    setIsCalendarOpen((prev) => {
      const newValue = !prev;
      if (newValue) {
        const newMonth = startOfMonth(selectedDate);
        setCurrentMonth(newMonth);
      } else {
        const todayStart = new Date(
          today.getFullYear(),
          today.getMonth(),
          today.getDate()
        );
        const selectedDateStart = new Date(
          selectedDate.getFullYear(),
          selectedDate.getMonth(),
          selectedDate.getDate()
        );
        const daysDiff = Math.floor(
          (selectedDateStart.getTime() - todayStart.getTime()) / (1e3 * 60 * 60 * 24)
        );
        const weekNumber = Math.floor(daysDiff / 7);
        const weekStart = addDays(todayStart, weekNumber * 7);
        setCurrentWeek(generateWeek(weekStart));
      }
      return newValue;
    });
  }, [selectedDate, today]);
  const handleSelectDate = reactExports.useCallback((date) => {
    setSelectedDate(date);
  }, []);
  const handleWeekChange = reactExports.useCallback((week) => {
    setCurrentWeek(week);
  }, []);
  const handleMonthChange = reactExports.useCallback((month) => {
    setCurrentMonth(startOfMonth(month));
  }, []);
  reactExports.useEffect(() => {
    if (isCalendarOpen) {
      if (currentMonth && !isSameMonth(selectedDate, currentMonth)) {
        const monthStart = startOfMonth(currentMonth);
        const monthEnd = endOfMonth(currentMonth);
        const calendarStart = startOfWeek(monthStart, { weekStartsOn: 1 });
        const weekContainingMonthEnd = startOfWeek(monthEnd, {
          weekStartsOn: 1
        });
        addDays(weekContainingMonthEnd, 6);
        const monthDays = Array.from(
          { length: 35 },
          (_, i) => addDays(calendarStart, i)
        );
        const firstDayWithSlots = monthDays.find((date) => {
          const dateStr = format(date, "yyyy-MM-dd");
          return daysWithSlots.has(dateStr);
        });
        if (firstDayWithSlots) {
          setSelectedDate(firstDayWithSlots);
        }
      } else if (currentMonth && isSameMonth(selectedDate, currentMonth)) {
        const selectedDateStr = format(selectedDate, "yyyy-MM-dd");
        if (!daysWithSlots.has(selectedDateStr)) {
          const monthStart = startOfMonth(currentMonth);
          const monthEnd = endOfMonth(currentMonth);
          const calendarStart = startOfWeek(monthStart, { weekStartsOn: 1 });
          const weekContainingMonthEnd = startOfWeek(monthEnd, {
            weekStartsOn: 1
          });
          addDays(weekContainingMonthEnd, 6);
          const monthDays = Array.from(
            { length: 35 },
            (_, i) => addDays(calendarStart, i)
          );
          const firstDayWithSlots = monthDays.find((date) => {
            const dateStr = format(date, "yyyy-MM-dd");
            return daysWithSlots.has(dateStr);
          });
          if (firstDayWithSlots) {
            setSelectedDate(firstDayWithSlots);
          }
        }
      }
    } else {
      const selectedDateStr = format(selectedDate, "yyyy-MM-dd");
      const weekDateStrs = currentWeek.map((d) => format(d, "yyyy-MM-dd"));
      const isSelectedDateInWeek = weekDateStrs.includes(selectedDateStr);
      if (!isSelectedDateInWeek) {
        const firstDayWithSlots = currentWeek.find((date) => {
          const dateStr = format(date, "yyyy-MM-dd");
          return daysWithSlots.has(dateStr);
        });
        if (firstDayWithSlots) {
          setSelectedDate(firstDayWithSlots);
        }
      }
    }
  }, [currentWeek, currentMonth, isCalendarOpen, daysWithSlots]);
  return {
    // State
    currentWeek,
    currentMonth,
    selectedDate,
    isCalendarOpen,
    isLoadingSlots: isLoading || isFetching,
    weekSlots,
    daysWithSlots,
    errorMessage,
    maxPreparedDate,
    // Actions
    setSelectedDate: handleSelectDate,
    toggleCalendar,
    goToPreviousWeek,
    goToNextWeek,
    goToPreviousMonth,
    goToNextMonth,
    handleWeekChange,
    handleMonthChange,
    // Computed
    canGoPrevious,
    canGoNext,
    hasAnySlots
  };
}
function BookingCalendarHeader({
  currentWeek,
  currentMonth,
  selectedDate,
  isCalendarOpen,
  isLoadingSlots,
  onToggleCalendar,
  onPreviousWeek,
  onNextWeek,
  canGoPrevious,
  canGoNext
}) {
  const monthToDisplay = isCalendarOpen && currentMonth ? startOfMonth(currentMonth) : (() => {
    const selectedDateStr = format(selectedDate, "yyyy-MM-dd");
    const weekDateStrs = currentWeek.map((d) => format(d, "yyyy-MM-dd"));
    const isSelectedDateInWeek = weekDateStrs.includes(selectedDateStr);
    return isSelectedDateInWeek ? selectedDate : currentWeek[0];
  })();
  const monthYearText = formatMonthYear(monthToDisplay);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { className: "border-b border-gray-200 dark:border-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between px-4 py-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonButton,
      {
        fill: isCalendarOpen ? "solid" : "clear",
        color: isCalendarOpen ? "success" : void 0,
        onClick: onToggleCalendar,
        className: "text-sm font-medium rounded-lg ".concat(isCalendarOpen ? "bg-green-500/30" : ""),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarOutline, slot: "start", className: "mr-2" }),
          monthYearText,
          isLoadingSlots ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarOutline, className: "ml-2 opacity-0" }) : null,
          isLoadingSlots ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { slot: "end", className: "ml-2" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonIcon,
            {
              icon: isCalendarOpen ? chevronUpOutline : chevronDownOutline,
              slot: "end",
              className: "ml-2"
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButtons, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          onClick: onPreviousWeek,
          disabled: !canGoPrevious,
          fill: "clear",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronBackOutline })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { onClick: onNextWeek, disabled: !canGoNext, fill: "clear", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: chevronForwardOutline }) })
    ] })
  ] }) });
}
function BookingWeekDays({
  currentWeek,
  selectedDate,
  onSelectDate,
  daysWithSlots,
  maxPreparedDate,
  onWeekChange,
  isMonthView,
  currentMonth,
  onMonthChange
}) {
  const { i18n } = useTranslation();
  const selectedDateStr = format(selectedDate, "yyyy-MM-dd");
  const swiperRef = reactExports.useRef(null);
  const monthSwiperRef = reactExports.useRef(null);
  const today = /* @__PURE__ */ new Date();
  const weeks = reactExports.useMemo(() => {
    const weeksList = [];
    let currentWeekStart = new Date(
      today.getFullYear(),
      today.getMonth(),
      today.getDate()
    );
    const endDate = maxPreparedDate || addDays(today, 365);
    const maxWeeks = 52;
    let weekCount = 0;
    while (weekCount < maxWeeks && currentWeekStart <= endDate) {
      const week = generateWeek(currentWeekStart);
      const lastDayOfWeek = week[6];
      if (lastDayOfWeek > endDate) {
        break;
      }
      weeksList.push(week);
      if (lastDayOfWeek >= endDate) {
        break;
      }
      currentWeekStart = addDays(currentWeekStart, 7);
      weekCount++;
    }
    return weeksList;
  }, [maxPreparedDate]);
  const monthDays = reactExports.useMemo(() => {
    if (!isMonthView || !currentMonth) return [];
    const monthStart = startOfMonth(currentMonth);
    const monthEnd = endOfMonth(currentMonth);
    const firstDisplayDate = today >= monthStart && today <= monthEnd ? today : monthStart;
    const calendarStart = firstDisplayDate;
    const weekContainingMonthEnd = startOfWeek(monthEnd, { weekStartsOn: 1 });
    const lastDate = addDays(weekContainingMonthEnd, 6);
    const days = [];
    let currentDate = calendarStart;
    while (currentDate <= lastDate) {
      days.push(new Date(currentDate));
      currentDate = addDays(currentDate, 1);
    }
    return days;
  }, [isMonthView, currentMonth, today]);
  const dayNames = {
    sr: ["Pon", "Uto", "Sre", "훻et", "Pet", "Sub", "Ned"],
    en: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
  };
  reactExports.useMemo(() => {
    if (monthDays.length === 0) return [];
    const weeksList = [];
    for (let i = 0; i < monthDays.length; i += 7) {
      const week = monthDays.slice(i, i + 7);
      if (week.length === 7) {
        weeksList.push(week);
      } else if (week.length > 0) {
        while (week.length < 7) {
          week.push(null);
        }
        weeksList.push(week);
      }
    }
    return weeksList;
  }, [monthDays]);
  const monthDayNames = reactExports.useMemo(() => {
    var _a2, _b2;
    if (!isMonthView) return dayNames.sr;
    const lang = (_b2 = (_a2 = i18n.language) == null ? void 0 : _a2.toLowerCase()) != null ? _b2 : "sr";
    const localeKey = lang.startsWith("sr") || lang.startsWith("rs") ? "sr" : "en";
    return dayNames[localeKey];
  }, [isMonthView, i18n.language]);
  const currentWeekIndex = reactExports.useMemo(() => {
    if (isMonthView) return -1;
    return weeks.findIndex(
      (week) => isSameWeek(currentWeek[0], week[0], { weekStartsOn: 1 })
    );
  }, [weeks, currentWeek, isMonthView]);
  reactExports.useEffect(() => {
    var _a2;
    if (!isMonthView && swiperRef.current && currentWeekIndex >= 0) {
      (_a2 = swiperRef.current.swiper) == null ? void 0 : _a2.slideTo(currentWeekIndex);
    }
  }, [currentWeekIndex, isMonthView]);
  const monthsForSwiper = reactExports.useMemo(() => {
    if (!isMonthView || !currentMonth) return [];
    const months = [];
    const todayMonth = startOfMonth(today);
    const endDate = maxPreparedDate || addMonths(today, 12);
    const endMonth = startOfMonth(endDate);
    let currentMonthToAdd = todayMonth;
    while (currentMonthToAdd <= endMonth) {
      months.push(new Date(currentMonthToAdd));
      currentMonthToAdd = addMonths(currentMonthToAdd, 1);
    }
    return months;
  }, [isMonthView, today, maxPreparedDate]);
  const currentMonthIndex = reactExports.useMemo(() => {
    if (!isMonthView || !currentMonth) return -1;
    return monthsForSwiper.findIndex(
      (month) => isSameMonth(month, currentMonth)
    );
  }, [monthsForSwiper, currentMonth, isMonthView]);
  reactExports.useEffect(() => {
    if (isMonthView && monthSwiperRef.current && currentMonthIndex >= 0) {
      requestAnimationFrame(() => {
        var _a2;
        if ((_a2 = monthSwiperRef.current) == null ? void 0 : _a2.swiper) {
          const currentActiveIndex = monthSwiperRef.current.swiper.activeIndex;
          if (currentActiveIndex !== currentMonthIndex) {
            monthSwiperRef.current.swiper.slideTo(currentMonthIndex, 0);
          }
        }
      });
    }
  }, [currentMonthIndex, isMonthView]);
  const getDayLabel = (date) => {
    var _a2, _b2;
    const lang = (_b2 = (_a2 = i18n.language) == null ? void 0 : _a2.toLowerCase()) != null ? _b2 : "sr";
    const localeKey = lang.startsWith("sr") || lang.startsWith("rs") ? "sr" : "en";
    const dayIndex = date.getDay();
    const adjustedIndex = dayIndex === 0 ? 6 : dayIndex - 1;
    return dayNames[localeKey][adjustedIndex] || "";
  };
  const renderDay = (date) => {
    const dateStr = format(date, "yyyy-MM-dd");
    const isSelected = dateStr === selectedDateStr;
    const hasSlots = daysWithSlots.has(dateStr);
    const isTodayDate = isToday(date);
    const isCurrentMonth = currentMonth ? isSameMonth(date, currentMonth) : true;
    const isPast = isPastDate(date);
    const isAfterMax = maxPreparedDate ? date > maxPreparedDate : false;
    const isDisabled = !hasSlots || isPast || isAfterMax;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: () => onSelectDate(date),
        disabled: isDisabled,
        className: "\n          flex flex-col items-center justify-center\n          ".concat(isMonthView ? "min-w-0 px-1.5 py-2" : "flex-1 min-w-0 px-1.5 py-2", "\n          rounded-xl transition-all duration-200\n          ").concat(isSelected ? "bg-gray-900 text-white dark:bg-gray-100 dark:text-gray-900 shadow-lg ring-2 ring-emerald-500 dark:ring-emerald-400" : isDisabled ? "cursor-not-allowed" : isCurrentMonth || !isMonthView ? "hover:bg-gray-100 dark:hover:bg-gray-800" : "", "\n          ").concat(isTodayDate && !isSelected && !isDisabled ? "ring-2 ring-gray-600 dark:ring-gray-400" : "", "\n        "),
        children: [
          !isMonthView && (() => {
            const dayLabel = getDayLabel(date);
            const isSub = dayLabel === "Sub" || dayLabel === "Sat";
            const isNed = dayLabel === "Ned" || dayLabel === "Sun";
            let dayLabelColor = "";
            if (!isSelected) {
              if (isSub) {
                dayLabelColor = "text-yellow-600 dark:text-yellow-400";
              } else if (isNed) {
                dayLabelColor = "text-red-600 dark:text-red-400";
              }
            }
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "text-sm font-semibold tracking-wide uppercase mb-1 ".concat(dayLabelColor || (isSelected ? "" : isDisabled ? "text-gray-400" : isCurrentMonth || !isMonthView ? hasSlots ? "" : "text-gray-500" : "text-gray-400")),
                style: !isSelected && !isDisabled && (isCurrentMonth || !isMonthView) && hasSlots && !isSub && !isNed ? { color: "var(--ion-text-color, #111827)" } : void 0,
                children: dayLabel
              }
            );
          })(),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "text-lg font-bold ".concat(isSelected ? "" : isDisabled ? "text-gray-400" : isCurrentMonth || !isMonthView ? hasSlots ? "" : "text-gray-500" : "text-gray-400"),
              style: !isSelected && !isDisabled && (isCurrentMonth || !isMonthView) && hasSlots ? { color: "var(--ion-text-color, #111827)" } : void 0,
              children: date.getDate()
            }
          ),
          hasSlots && !isDisabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "w-1.5 h-1.5 rounded-full mt-1 ".concat(isSelected ? "bg-white dark:bg-gray-900" : "bg-emerald-500 dark:bg-emerald-400")
            }
          )
        ]
      },
      dateStr
    );
  };
  if (isMonthView) {
    const generateMonthDays = (month) => {
      const monthStart = startOfMonth(month);
      const monthEnd = endOfMonth(month);
      const calendarStart = startOfWeek(monthStart, { weekStartsOn: 1 });
      const weekContainingMonthEnd = startOfWeek(monthEnd, { weekStartsOn: 1 });
      addDays(weekContainingMonthEnd, 6);
      const days = [];
      let currentDate = calendarStart;
      for (let i = 0; i < 35; i++) {
        days.push(new Date(currentDate));
        currentDate = addDays(currentDate, 1);
      }
      const weeks2 = [];
      for (let i = 0; i < 35; i += 7) {
        weeks2.push(days.slice(i, i + 7));
      }
      return weeks2;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-b border-gray-200 dark:border-gray-700", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-7 gap-1 px-2 pt-3 pb-1", children: monthDayNames.map((dayName, index) => {
        const isSub = dayName === "Sub" || dayName === "Sat";
        const isNed = dayName === "Ned" || dayName === "Sun";
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "text-center text-xs font-medium py-1 ".concat(isSub ? "text-yellow-600 dark:text-yellow-400" : isNed ? "text-red-600 dark:text-red-400" : "text-gray-500 dark:text-gray-400"),
            children: dayName
          },
          "".concat(dayName, "-").concat(index)
        );
      }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SwiperWrapper$1,
        {
          ref: monthSwiperRef,
          slidesPerView: 1,
          spaceBetween: 0,
          allowTouchMove: true,
          onSlideChange: (swiper) => {
            const activeIndex = swiper.activeIndex;
            const activeMonth = monthsForSwiper[activeIndex];
            if (activeMonth && onMonthChange && currentMonth) {
              const activeMonthStr = format(activeMonth, "yyyy-MM");
              const currentMonthStr = format(currentMonth, "yyyy-MM");
              if (activeMonthStr !== currentMonthStr) {
                onMonthChange(activeMonth);
              }
            }
          },
          children: monthsForSwiper.map((month, monthIndex) => {
            const monthWeeks2 = generateMonthDays(month);
            return /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-2 pb-3", children: monthWeeks2.map((week, weekIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-7 gap-1", children: week.map(
              (date, dayIndex) => date ? renderDay(date) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-w-0 px-1.5 py-2" }, "empty-".concat(weekIndex, "-").concat(dayIndex))
            ) }, weekIndex)) }) }, format(month, "yyyy-MM"));
          })
        }
      )
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-b border-gray-200 dark:border-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SwiperWrapper$1,
    {
      ref: swiperRef,
      slidesPerView: 1,
      spaceBetween: 0,
      allowTouchMove: true,
      onSlideChange: (swiper) => {
        const activeIndex = swiper.activeIndex;
        if (weeks[activeIndex] && onWeekChange) {
          onWeekChange(weeks[activeIndex]);
        }
      },
      children: weeks.map((week, weekIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between px-2 py-3", children: week.map((date) => renderDay(date)) }) }, weekIndex))
    }
  ) });
}
function EmptyWeekState({ currentWeek }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center py-16 px-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonIcon,
      {
        icon: calendarOutline,
        className: "text-gray-400 dark:text-gray-500",
        style: { fontSize: "80px" }
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-center mb-2 text-gray-800 dark:text-gray-100", children: t2("Nema slobodnih mesta za izabranu nedelju") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-500 dark:text-gray-300 text-center", children: t2("Poku큄ajte da izaberete drugu nedelju") })
  ] });
}
function WorkerSlotsGrid({
  slots,
  worker,
  dateFormatted,
  onSelectSlot,
  selectedSlot
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-2", children: slots.map((slot) => {
    const isPreviousDay = slot.time.startsWith("-");
    const actualTimeUtc = isPreviousDay ? slot.time.substring(1) : slot.time;
    const timeLocal = fromUtcHM(actualTimeUtc);
    const isSelected = selectedSlot && selectedSlot.worker.id === worker.id && selectedSlot.date === dateFormatted && (selectedSlot.slot.time === slot.time || selectedSlot.slot.time === "-".concat(slot.time) || "-".concat(selectedSlot.slot.time) === slot.time);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonButton,
      {
        onClick: () => onSelectSlot(slot, worker, dateFormatted),
        fill: "solid",
        size: "default",
        color: isSelected ? "success" : "dark",
        className: "text-sm font-semibold shadow-sm rounded-lg",
        children: timeLocal
      },
      slot.time
    );
  }) });
}
function DaySlotsContent({
  date,
  workerSlots,
  onSelectSlot,
  selectedServices,
  selectedSlot
}) {
  const { t: t2 } = useTranslation();
  const dateFormatted = format(date, "yyyy-MM-dd");
  const dateDisplay = format(date, "dd.MM.yyyy");
  const workersWithSlots = workerSlots.filter((ws) => ws.hasSlots);
  if (workersWithSlots.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center py-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-500 dark:text-gray-400", children: t2("Nema slobodnih slotova za ovaj dan") }) });
  }
  const accordionValues = workersWithSlots.map(
    (workerSlot) => "worker-".concat(workerSlot.worker.id)
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonAccordionGroup, { multiple: true, value: accordionValues, children: workersWithSlots.map((workerSlot) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonAccordion,
    {
      value: "worker-".concat(workerSlot.worker.id),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { slot: "header", className: "font-medium", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-semibold text-base", children: [
            dateDisplay,
            " - ",
            workerSlot.worker.fullName
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-500 dark:text-gray-400", children: [
            workerSlot.slots.length,
            " ",
            t2("slobodnih termina")
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { slot: "content", className: "p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          WorkerSlotsGrid,
          {
            slots: workerSlot.slots,
            worker: workerSlot.worker,
            dateFormatted,
            onSelectSlot,
            selectedSlot
          }
        ) })
      ]
    },
    workerSlot.worker.id
  )) }) });
}
function BookingSlotsSwiper({
  weekSlots,
  selectedDate,
  currentWeek,
  onSelectSlot,
  isLoading,
  selectedServices,
  selectedCategory,
  hasAnySlots,
  errorMessage,
  onDateChange,
  onWeekChange,
  selectedSlot
}) {
  if (errorMessage) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-[320px] flex items-center justify-center px-6 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: errorMessage }) });
  }
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center py-16", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "w-12 h-12" }) });
  }
  const timezone = getAppTimezone();
  const swiperRef = reactExports.useRef(null);
  const contentRefFunctions = useContentRefFunctions();
  const isFirstWeek = reactExports.useMemo(() => {
    const todayInTz = startOfDay(toZonedTime(/* @__PURE__ */ new Date(), timezone));
    const weekStartInTz = startOfDay(toZonedTime(currentWeek[0], timezone));
    return isSameDay(weekStartInTz, todayInTz);
  }, [currentWeek, timezone]);
  const daysWithSlots = reactExports.useMemo(() => {
    return Object.entries(weekSlots).filter(([_, slots]) => slots.some((ws) => ws.hasSlots)).sort(([dateA], [dateB]) => dateA.localeCompare(dateB));
  }, [weekSlots]);
  const slides = reactExports.useMemo(() => {
    const slidesList = [];
    if (!isFirstWeek) {
      slidesList.push({ type: "prev-week" });
    }
    if (hasAnySlots && daysWithSlots.length > 0) {
      daysWithSlots.forEach(([dateStr]) => {
        slidesList.push({
          type: "day",
          date: dateStr,
          dateObj: new Date(dateStr)
        });
      });
    } else {
      slidesList.push({ type: "empty-week" });
    }
    slidesList.push({ type: "next-week" });
    return slidesList;
  }, [daysWithSlots, isFirstWeek, hasAnySlots]);
  const selectedDateStr = format(selectedDate, "yyyy-MM-dd");
  const activeSlideIndex = reactExports.useMemo(() => {
    if (!hasAnySlots) {
      return isFirstWeek ? 0 : 1;
    }
    const dayIndex = slides.findIndex(
      (slide) => slide.type === "day" && slide.date === selectedDateStr
    );
    if (dayIndex >= 0) {
      return dayIndex;
    }
    if (slides.length === 0) return 0;
    return isFirstWeek ? 0 : 1;
  }, [slides, selectedDateStr, isFirstWeek, hasAnySlots]);
  reactExports.useEffect(() => {
    var _a2;
    if (!((_a2 = swiperRef.current) == null ? void 0 : _a2.swiper)) return;
    requestAnimationFrame(() => {
      var _a3;
      if ((_a3 = swiperRef.current) == null ? void 0 : _a3.swiper) {
        swiperRef.current.swiper.slideTo(activeSlideIndex, 0);
      }
    });
  }, [activeSlideIndex, currentWeek]);
  const scrollToTopIfNeeded = async () => {
    var _a2, _b2, _c2;
    try {
      const scrollElement = await ((_b2 = (_a2 = contentRefFunctions == null ? void 0 : contentRefFunctions.contentRef) == null ? void 0 : _a2.current) == null ? void 0 : _b2.getScrollElement());
      const scrollTop = (_c2 = scrollElement == null ? void 0 : scrollElement.scrollTop) != null ? _c2 : 0;
      if (scrollTop > 300) {
        contentRefFunctions == null ? void 0 : contentRefFunctions.scrollToTop(500);
      }
    } catch (error) {
    }
  };
  const handleSlideChange = (swiper) => {
    const activeIndex = swiper.activeIndex;
    const activeSlide = slides[activeIndex];
    if (!activeSlide) return;
    if (activeSlide.type === "prev-week") {
      if (onWeekChange) {
        const newStartDate = addDays(currentWeek[0], -7);
        const newWeek = generateWeek(newStartDate);
        onWeekChange(newWeek);
        setTimeout(() => {
          scrollToTopIfNeeded();
        }, 100);
      }
      return;
    }
    if (activeSlide.type === "next-week") {
      if (onWeekChange) {
        const newStartDate = addDays(currentWeek[0], 7);
        const newWeek = generateWeek(newStartDate);
        onWeekChange(newWeek);
        setTimeout(() => {
          scrollToTopIfNeeded();
        }, 100);
      }
      return;
    }
    if (activeSlide.type === "day" && activeSlide.date && onDateChange) {
      onDateChange(new Date(activeSlide.date));
    }
  };
  const handleSlideChangeTransitionStart = async (swiper) => {
    scrollToTopIfNeeded();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SwiperWrapper$1,
    {
      ref: swiperRef,
      spaceBetween: 16,
      navigation: true,
      onSlideChange: handleSlideChange,
      onSlideChangeTransitionStart: handleSlideChangeTransitionStart,
      children: slides.map((slide, index) => {
        if (slide.type === "prev-week") {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center py-16 min-h-[320px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-400 dark:text-gray-500 text-sm", children: "Prethodna nedelja..." }) }) }, "prev-week");
        }
        if (slide.type === "next-week") {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center py-16 min-h-[320px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-400 dark:text-gray-500 text-sm", children: "Slede훶a nedelja..." }) }) }, "next-week");
        }
        if (slide.type === "empty-week") {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyWeekState, { currentWeek }) }, "empty-week");
        }
        if (slide.type === "day" && slide.date) {
          const workerSlots = weekSlots[slide.date] || [];
          return /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DaySlotsContent,
            {
              date: slide.dateObj,
              workerSlots,
              onSelectSlot,
              selectedServices,
              selectedSlot
            }
          ) }, slide.date);
        }
        return null;
      })
    }
  ) });
}
const reservationApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    createFeReservation: builder.mutation({
      query: (body) => ({
        url: "locations/reservations/create-new",
        method: "POST",
        body
      }),
      invalidatesTags: [
        { type: TagType$1.RESERVATION, id: TagId$1.LIST },
        TagType$1.USER_NOTIFICATIONS
      ]
    }),
    updateFeReservation: builder.mutation({
      query: ({ clientData, ...body }) => ({
        url: "locations/reservations/update",
        method: "PUT",
        body: {
          ...body,
          clientData: humpsExports.decamelizeKeys(clientData)
        }
      }),
      invalidatesTags: (result) => {
        var _a2;
        return [
          { type: TagType$1.RESERVATION, id: TagId$1.LIST },
          { type: TagType$1.RESERVATION, id: (_a2 = result == null ? void 0 : result.data) == null ? void 0 : _a2.hash },
          TagType$1.USER_NOTIFICATIONS
        ];
      }
    }),
    getOneFeReservation: builder.query({
      query: (params) => ({
        url: "locations/reservations/get-one",
        method: "GET",
        params
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: (result) => {
        var _a2;
        return [
          { type: TagType$1.RESERVATION, id: (_a2 = result == null ? void 0 : result.data) == null ? void 0 : _a2.hash },
          TagType$1.USER
        ];
      }
    }),
    getFeLocationReservations: builder.query({
      query: (params) => ({
        url: "locations/reservations",
        method: "GET",
        params
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [
        { type: TagType$1.RESERVATION, id: TagId$1.LIST },
        TagType$1.USER
      ]
    }),
    getFeLocationClientReservations: builder.query({
      query: (params) => ({
        url: "locations/reservations/client",
        method: "GET",
        params
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [
        { type: TagType$1.RESERVATION, id: TagId$1.LIST },
        TagType$1.USER
      ]
    }),
    getFePromoCodeData: builder.query({
      query: (params) => ({
        url: "locations/promo-codes/find",
        method: "GET",
        params
      }),
      transformResponse: transformStandardResponseToCamelCase
    })
  })
});
const {
  useCreateFeReservationMutation,
  useGetOneFeReservationQuery,
  useUpdateFeReservationMutation,
  useGetFeLocationReservationsQuery,
  useGetFeLocationClientReservationsQuery,
  useGetFePromoCodeDataQuery
} = reservationApi;
const clientApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getFeClientData: builder.query({
      query: () => ({
        url: "users/client-data",
        method: "GET"
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.CLIENT, TagType$1.USER]
    }),
    updateFeClientData: builder.mutation({
      query: (body) => ({
        url: "users/client",
        method: "POST",
        body: humpsExports.decamelizeKeys(body)
      }),
      invalidatesTags: [TagType$1.CLIENT]
    }),
    getFeLocationClients: builder.query({
      query: (params) => ({
        url: "locations/clients",
        method: "GET",
        params
      }),
      transformResponse: transformStandardResponseToCamelCase,
      providesTags: [TagType$1.USER]
    }),
    getUserNotifications: builder.query({
      query: (params) => ({
        url: "users/notifications",
        method: "GET",
        params
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [TagType$1.USER_NOTIFICATIONS]
    })
  })
});
const {
  useGetFeClientDataQuery,
  useUpdateFeClientDataMutation,
  useGetFeLocationClientsQuery,
  useGetUserNotificationsQuery
} = clientApi;
const getCreateAppointmentFormFields = (t2) => [
  {
    keyName: "note",
    name: "note",
    data: {
      type: FieldType.Text,
      label: t2("Napomena")
    },
    gridSize: {
      size: "6"
    }
  },
  {
    keyName: "promoCode",
    name: "promoCode",
    data: {
      type: FieldType.Text,
      label: t2("Promo kod")
    },
    gridSize: {
      size: "6"
    }
  }
];
const pushDuplicateAndNavigate = (router, destination, referrer) => {
  const defaultReferrer = "".concat(urlPrefix, "/t/termini");
  router.push(defaultReferrer, "forward", "push");
  router.push(defaultReferrer, "forward", "push");
  setTimeout(() => {
    router.push(destination, "root", "replace");
  }, 10);
};
const UserAvatar = ({
  fullName,
  size = 48
}) => {
  const getInitials = (name) => {
    const names = name.split(" ");
    if (names.length >= 2) {
      return "".concat(names[0][0]).concat(names[1][0]).toUpperCase();
    }
    return name.substring(0, 2).toUpperCase();
  };
  const getRandomColor = (name) => {
    const colors = [
      "#FF6B6B",
      // Red
      "#4ECDC4",
      // Teal
      "#45B7D1",
      // Blue
      "#96CEB4",
      // Green
      "#FFEEAD",
      // Yellow
      "#D4A5A5",
      // Pink
      "#9B59B6",
      // Purple
      "#3498DB"
      // Light Blue
    ];
    const index = name.split("").reduce((acc, char) => acc + char.charCodeAt(0), 0);
    return colors[index % colors.length];
  };
  const initials = getInitials(fullName);
  const backgroundColor = getRandomColor(fullName);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonAvatar,
    {
      style: {
        width: "".concat(size, "px"),
        height: "".concat(size, "px"),
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        backgroundColor,
        color: "#FFFFFF",
        fontSize: "".concat(size * 0.4, "px"),
        fontWeight: "bold"
      },
      children: initials
    }
  );
};
const schema = yup.object().shape({
  note: yup.string().nullable().default(null),
  promoCode: yup.string().nullable().default(null)
});
function CreateReservationModal({
  onConfirm,
  onCancel,
  isOpen,
  worker,
  selectedServices,
  dateOnly,
  timeUtc,
  dateFormatted
}, ref) {
  var _a2, _b2, _c2;
  const { t: t2 } = useTranslation();
  const [createReservation, createReservationResponse] = useCreateFeReservationMutation();
  const { isOwnerOrWorker } = useUser();
  const initialModalBp = isOwnerOrWorker ? 0.4 : 0.5;
  const [promoCodeData, setPromoCodeData] = reactExports.useState(null);
  const [currentBreakpoint, setCurrentBreakpoint] = reactExports.useState(initialModalBp);
  const router = useIonRouter();
  const { push } = router;
  const [presentToast] = useIonToast();
  const internalModalRef = reactExports.useRef(null);
  reactExports.useImperativeHandle(ref, () => internalModalRef.current, []);
  const modalRef = internalModalRef;
  const { data: clientResponse } = useGetFeClientDataQuery(void 0, {
    skip: !!isOwnerOrWorker
  });
  const clientData = clientResponse == null ? void 0 : clientResponse.data;
  const form = useFormWithSchema(schema, {
    defaultValues: {
      note: null,
      promoCode: null
    }
  });
  const formFields = getCreateAppointmentFormFields(t2);
  const promoCode = form.watch("promoCode");
  const {
    data: promoCodeResponse,
    isFetching: isPromoCodeFetching,
    refetch
  } = useGetFePromoCodeDataQuery(
    {
      locationSlug: activeLocation,
      code: promoCode != null ? promoCode : ""
    },
    {
      skip: !(promoCode == null ? void 0 : promoCode.length) || !(promoCode != null ? promoCode : "").endsWith("#")
    }
  );
  const duration = reactExports.useMemo(() => {
    return selectedServices == null ? void 0 : selectedServices.reduce(
      (acc, service) => {
        var _a3;
        return acc + service.duration * ((_a3 = service.quantity) != null ? _a3 : 1);
      },
      0
    );
  }, [selectedServices]);
  const cost = reactExports.useMemo(() => {
    return (selectedServices == null ? void 0 : selectedServices.reduce(
      (acc, service) => {
        var _a3;
        return acc + service.price * ((_a3 = service.quantity) != null ? _a3 : 1);
      },
      0
    )) || 0;
  }, [selectedServices]);
  const onSubmit = (data) => {
    handleConfirmReservation();
  };
  const handleConfirmReservation = () => {
    var _a3;
    const dateUtcString = formatInTimeZone(dateOnly, "UTC", "yyyy-MM-dd") + "".concat(timeUtc, ":00");
    createReservation({
      locationSlug: activeLocation,
      locationWorkerId: worker.id,
      dateUtc: dateUtcString,
      services: selectedServices.map((service) => {
        var _a4;
        return {
          id: service.id,
          quantity: (_a4 = service.quantity) != null ? _a4 : 1
        };
      }),
      clientId: clientData == null ? void 0 : clientData.id,
      promoCode: promoCodeData == null ? void 0 : promoCodeData.name,
      notice: (_a3 = form.getValues("note")) != null ? _a3 : void 0
    });
  };
  const handleBreakpointChange = (event) => {
    setCurrentBreakpoint(event.detail.breakpoint);
  };
  const hasDiscount = (_a2 = promoCodeData == null ? void 0 : promoCodeData.discountValue) != null ? _a2 : 0 > 0;
  const isDiscountInPercent = (_b2 = promoCodeData == null ? void 0 : promoCodeData.inPercent) != null ? _b2 : false;
  const getPriceWithDiscount = () => {
    var _a3, _b3;
    if (hasDiscount) {
      const discountPrice = isDiscountInPercent ? cost - cost * ((_a3 = promoCodeData == null ? void 0 : promoCodeData.discountValue) != null ? _a3 : 0) / 100 : cost - ((_b3 = promoCodeData == null ? void 0 : promoCodeData.discountValue) != null ? _b3 : 0);
      return Math.round(discountPrice / 50) * 50;
    } else {
      return cost;
    }
  };
  const isBigScreen = currentBreakpoint >= 0.8;
  const timeLocal = fromUtcHM(timeUtc);
  const formattedDate = reactExports.useMemo(() => {
    return format(dateOnly, "dd.MM.yyyy.");
  }, [dateOnly]);
  const footerBottomClass = reactExports.useMemo(() => {
    if (currentBreakpoint === 0.4) {
      return "bottom-[60vh]";
    } else if (currentBreakpoint === 0.5) {
      return "bottom-[50vh]";
    } else if (currentBreakpoint === 0.8) {
      return "bottom-[20vh]";
    }
    return "bottom-0";
  }, [currentBreakpoint]);
  const handleCloseModal = reactExports.useCallback(() => {
    var _a3;
    (_a3 = modalRef == null ? void 0 : modalRef.current) == null ? void 0 : _a3.dismiss();
  }, [modalRef]);
  const handleInputFocus = () => {
    var _a3;
    !isWebPlatform && ((_a3 = modalRef == null ? void 0 : modalRef.current) == null ? void 0 : _a3.setCurrentBreakpoint(0.8));
  };
  reactExports.useEffect(() => {
    var _a3;
    if (createReservationResponse.isSuccess && ((_a3 = createReservationResponse.data) == null ? void 0 : _a3.success)) {
      const data = createReservationResponse.data.data;
      onConfirm == null ? void 0 : onConfirm();
      onCancel();
      const destination = "".concat(urlPrefix, "/r/").concat(data.hash, "?backToHome=1");
      pushDuplicateAndNavigate(router, destination);
    } else if (createReservationResponse.isError && createReservationResponse.error && "data" in createReservationResponse.error) {
      const errorData = createReservationResponse.error.data;
      presentToast({
        message: errorData.message,
        duration: 3e3,
        color: "danger"
      });
    }
  }, [createReservationResponse, router]);
  reactExports.useEffect(() => {
    if ((promoCodeResponse == null ? void 0 : promoCodeResponse.data) === null) {
      form.setValue("promoCode", "");
      presentToast({
        message: t2("Promo kod nije validan"),
        duration: 3e3,
        color: "danger"
      });
    } else if (promoCodeResponse == null ? void 0 : promoCodeResponse.data) {
      setPromoCodeData(promoCodeResponse.data);
    }
  }, [promoCodeResponse]);
  reactExports.useEffect(() => {
    if (promoCode == null ? void 0 : promoCode.endsWith("#")) {
      if ((promoCodeResponse == null ? void 0 : promoCodeResponse.data) && promoCode === promoCodeResponse.data.name) {
        setPromoCodeData(promoCodeResponse == null ? void 0 : promoCodeResponse.data);
      } else {
        refetch();
      }
    } else {
      setPromoCodeData(null);
    }
  }, [promoCode]);
  const breakpoints = isWebPlatform ? void 0 : [0, initialModalBp, 0.8, 1];
  const initialBreakpoint = isWebPlatform ? void 0 : initialModalBp;
  const backdropBreakpoint = isWebPlatform ? void 0 : initialModalBp;
  const showBackdrop = isWebPlatform ? void 0 : false;
  const modalClassName = isWebPlatform ? void 0 : "hd-extended";
  const footerClassName = isWebPlatform ? void 0 : "fixed left-0 w-full z-[100] ".concat(footerBottomClass);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonModalExtended$1,
    {
      name: "create-reservation-modal",
      isOpen,
      onClose: onCancel,
      breakpoints,
      showBackdrop,
      onIonBreakpointDidChange: handleBreakpointChange,
      backdropBreakpoint,
      initialBreakpoint,
      className: modalClassName,
      ref: modalRef,
      children: [
        createReservationResponse.isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(IonLoading, { isOpen: true, message: t2("Kreiranje rezervacije...") }),
        isPromoCodeFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(IonLoading, { isOpen: true, message: t2("Provera promo koda...") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { className: isWebPlatform ? "px-0" : "px-1", color: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonToolbar,
          {
            className: isWebPlatform ? "max-w-2xl mx-auto" : "",
            color: "dark",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 w-full", children: [
              ((_c2 = worker.avatar) == null ? void 0 : _c2.pathByResolution) ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonAvatar, { className: "w-10 h-10 rounded-full flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                LazyLoadImgStandard$1,
                {
                  src: getPathBySize(worker.avatar.pathByResolution),
                  alt: worker.fullName,
                  className: "w-full h-full object-cover rounded-full"
                }
              ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(UserAvatar, { fullName: worker.fullName, size: 40 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonTitle,
                {
                  className: "".concat(isWebPlatform ? "text-xl font-semibold" : "", " flex-1"),
                  children: worker.fullName
                }
              )
            ] })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { className: isWebPlatform ? "ion-padding" : "", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: isWebPlatform ? "max-w-2xl mx-auto py-4" : "", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-2xl font-semibold mb-4", children: [
            formattedDate,
            " ",
            timeLocal
          ] }),
          !isOwnerOrWorker && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "form",
            {
              onFocus: handleInputFocus,
              className: isWebPlatform ? "mb-6" : "",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields: formFields, form })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonGrid,
            {
              className: isWebPlatform ? "ion-no-padding !px-0" : "ion-no-padding mt-2 !px-2",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { className: isWebPlatform ? "gap-4" : "", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  IonCol,
                  {
                    size: isBigScreen ? "12" : "6",
                    className: "flex items-center ".concat(isWebPlatform ? "justify-start gap-3" : isBigScreen ? "justify-between" : "justify-between"),
                    children: [
                      isWebPlatform && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-medium", children: [
                        t2("Trajanje usluge"),
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        ConditionalComponent,
                        {
                          condition: isBigScreen && !isWebPlatform,
                          render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-medium", children: [
                            t2("Trajanje usluge"),
                            ":"
                          ] })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonBadge, { className: "p-2", color: "primary", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: timeOutline, className: "mr-1" }),
                        duration,
                        " min"
                      ] })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  IonCol,
                  {
                    size: isBigScreen ? "12" : "6",
                    className: "flex items-center ".concat(isWebPlatform ? "justify-start gap-3" : isBigScreen ? "justify-between" : "justify-end"),
                    children: [
                      isWebPlatform && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-medium", children: [
                        t2("Cena"),
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        ConditionalComponent,
                        {
                          condition: isBigScreen && !isWebPlatform,
                          render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-medium", children: [
                            t2("Cena"),
                            ":"
                          ] })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonBadge, { color: "success", className: "p-2", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: cashOutline, className: "mr-1" }),
                        hasDiscount ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("s", { className: "px-1 opacity-75", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: cost }) }),
                          getPriceWithDiscount()
                        ] }) : cost,
                        " ",
                        "RSD"
                      ] })
                    ]
                  }
                )
              ] })
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonFooter, { className: footerClassName, color: "dark", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { className: isWebPlatform ? "max-w-2xl mx-auto" : "", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            IonButton,
            {
              slot: "start",
              color: "medium",
              onClick: handleCloseModal,
              className: isWebPlatform ? "ml-0" : "ml-2",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: closeOutline }),
                t2("Zatvori")
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            IonButton,
            {
              slot: "end",
              color: "primary",
              onClick: form.handleSubmit(onSubmit),
              className: isWebPlatform ? "mr-0" : "mr-2",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarClearOutline, className: "mr-1" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { slot: "end", children: t2("Kreiraj rezervaciju") })
              ]
            }
          )
        ] }) })
      ]
    }
  );
}
const CreateReservationModal$1 = reactExports.forwardRef(
  CreateReservationModal
);
function BookingCalendarStep({
  locationWorker,
  workerIds,
  selectedGroupServices,
  selectedCategory,
  onBack,
  isActive = true
}) {
  const { t: t2 } = useTranslation();
  const [presentToast] = useIonToast();
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  const [selectedSlot, setSelectedSlot] = reactExports.useState(null);
  const {
    currentWeek,
    currentMonth,
    selectedDate,
    isCalendarOpen,
    isLoadingSlots,
    weekSlots,
    daysWithSlots,
    setSelectedDate,
    toggleCalendar,
    goToPreviousWeek,
    goToNextWeek,
    canGoPrevious,
    canGoNext,
    hasAnySlots,
    errorMessage,
    maxPreparedDate,
    handleWeekChange,
    handleMonthChange
  } = useBookingCalendar({
    locationSlug: activeLocation,
    worker: locationWorker,
    workerIds,
    selectedServices: selectedGroupServices,
    selectedCategory,
    isActive
    // Prosle휃i isActive da bi se API pozivao samo kada je korak aktivan
    // TODO: Dodati maxPreparedDate iz shifts
  });
  const flattenedServices = reactExports.useMemo(
    () => selectedGroupServices.flatMap((group) => {
      var _a2;
      return (_a2 = group.services) != null ? _a2 : [];
    }).filter(Boolean),
    [selectedGroupServices]
  );
  const handleSelectDate = (date) => {
    const dateStr = format(date, "yyyy-MM-dd");
    if (!daysWithSlots.has(dateStr)) {
      presentToast({
        message: t2("Nema slobodnih slotova za ovaj dan"),
        duration: 2e3,
        position: "bottom",
        color: "warning"
      });
      return;
    }
    setSelectedDate(date);
  };
  const handleSelectSlot = (slot, worker, date) => {
    setSelectedSlot({ slot, worker, date });
    setIsModalOpen(true);
  };
  const handleConfirmReservation = () => {
    setIsModalOpen(false);
    setSelectedSlot(null);
  };
  const handleCancelReservation = reactExports.useCallback(() => {
    setIsModalOpen(false);
    setSelectedSlot(null);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BookingCalendarHeader,
      {
        currentWeek,
        currentMonth,
        selectedDate,
        isCalendarOpen,
        isLoadingSlots,
        onToggleCalendar: toggleCalendar,
        onPreviousWeek: goToPreviousWeek,
        onNextWeek: goToNextWeek,
        canGoPrevious,
        canGoNext
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BookingWeekDays,
      {
        currentWeek,
        selectedDate,
        onSelectDate: handleSelectDate,
        daysWithSlots,
        maxPreparedDate,
        onWeekChange: handleWeekChange,
        isMonthView: isCalendarOpen,
        currentMonth,
        onMonthChange: handleMonthChange
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-[80px] px-2 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      BookingSlotsSwiper,
      {
        weekSlots,
        selectedDate,
        currentWeek,
        onSelectSlot: handleSelectSlot,
        isLoading: isLoadingSlots,
        selectedServices: selectedGroupServices,
        selectedCategory,
        hasAnySlots,
        errorMessage: errorMessage != null ? errorMessage : void 0,
        onDateChange: setSelectedDate,
        onWeekChange: handleWeekChange,
        selectedSlot
      }
    ) }),
    selectedSlot && /* @__PURE__ */ jsxRuntimeExports.jsx(
      CreateReservationModal$1,
      {
        isOpen: isModalOpen,
        onConfirm: handleConfirmReservation,
        onCancel: handleCancelReservation,
        worker: selectedSlot.worker,
        selectedServices: flattenedServices,
        dateOnly: new Date(selectedSlot.date),
        timeUtc: selectedSlot.slot.time,
        dateFormatted: selectedSlot.date
      }
    )
  ] });
}
var InputType = /* @__PURE__ */ ((InputType2) => {
  InputType2[InputType2["checkbox"] = 0] = "checkbox";
  InputType2[InputType2["radio"] = 1] = "radio";
  InputType2[InputType2["select"] = 2] = "select";
  return InputType2;
})(InputType || {});
function CreateAppointmentSteps({ appointment }) {
  var _a2, _b2;
  const { t: t2 } = useTranslation();
  const location = useLocation();
  const history = useHistory();
  const { wrapUserLoginModal } = useUser();
  const { data: queryParams } = useQueryParamsHook({});
  const formRef = reactExports.useRef(null);
  const queryWorkerId = queryParams["worker"] ? parseInt(queryParams["worker"]) : void 0;
  const [activeStep, setActiveStep] = reactExports.useState(
    parseInt((_a2 = queryParams["step"]) != null ? _a2 : "0")
  );
  const [hasMultiplePersons, setHasMultiplePersons] = reactExports.useState(false);
  const contentRefFunctions = useContentRefFunctions();
  const { data: workersResult, isLoading: workersLoading } = useGetFeWorkersQuery({
    locationSlug: activeLocation
  });
  const workers = (workersResult == null ? void 0 : workersResult.data) || [];
  const activeWorkers = workers.filter(
    (worker) => worker.active
  );
  const [selectedWorker, setSelectedWorker] = reactExports.useState();
  const [selectedCategory, setSelectedCategory] = reactExports.useState(null);
  const [groupsSelectedServices, setGroupsSelectedServices] = reactExports.useState([]);
  const { data: locationResponse } = useGetFeLocationQuery(
    {
      slug: activeLocation
    },
    { skip: !!(preloadedLocationData == null ? void 0 : preloadedLocationData.id) }
  );
  const locationData = preloadedLocationData != null ? preloadedLocationData : locationResponse == null ? void 0 : locationResponse.data;
  const { data: categoriesResult } = useGetFeServiceCategoriesQuery(
    {
      locationSlug: activeLocation,
      active: true
    },
    { skip: !((_b2 = locationData == null ? void 0 : locationData.serviceCategories) == null ? void 0 : _b2.length) }
  );
  const categories = (categoriesResult == null ? void 0 : categoriesResult.data) || (locationData == null ? void 0 : locationData.serviceCategories) || [];
  const hasMultipleActivities = (locationData == null ? void 0 : locationData.hasMultipleActivities) === true;
  const locationHasCategories = hasMultipleActivities && categories.length > 0;
  const maxStep = 2;
  const {
    data: serviceGroupsResult,
    isLoading: serviceGroupsLoading,
    isFetching: serviceGroupsFetching
  } = useGetFeServiceGroupsQuery({
    locationSlug: activeLocation,
    withWorkers: 1
    // Always load workers data
  });
  const serviceGroups = serviceGroupsResult == null ? void 0 : serviceGroupsResult.data;
  const landedDirectlyOnStep1 = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (queryParams["step"] === "1" && history.length <= 2) {
      landedDirectlyOnStep1.current = true;
    }
  }, []);
  const canGoToStep = (step) => {
    if (step === 1 && !selectedWorker) return false;
    if (step === 2 && groupsSelectedServices.length === 0) return false;
    return true;
  };
  const handleSetStep = (step, options) => {
    var _a3, _b3;
    const { replace = false, bypassGuard = false } = options || {};
    if (!bypassGuard && !canGoToStep(step)) return;
    const params = new URLSearchParams(location.search);
    const currentStepFromUrl = parseInt((_a3 = params.get("step")) != null ? _a3 : "0", 10);
    params.set("step", step.toString());
    if (replace || currentStepFromUrl === step && activeStep === void 0) {
      history.replace({ search: params.toString() });
    } else if (activeStep && activeStep > step) {
      history.goBack();
    } else if (activeStep === 2 && step === 1) {
      history.replace({ search: params.toString() });
    } else {
      history.push({ search: params.toString() });
    }
    setActiveStep(step);
    (_b3 = formRef.current) == null ? void 0 : _b3.handleSetStep(step);
    contentRefFunctions == null ? void 0 : contentRefFunctions.scrollToTop(50);
  };
  const forceSetStep = (step) => {
    var _a3;
    const params = new URLSearchParams(location.search);
    params.set("step", step.toString());
    history.replace({ search: params.toString() });
    setActiveStep(step);
    (_a3 = formRef.current) == null ? void 0 : _a3.handleSetStep(step);
    contentRefFunctions == null ? void 0 : contentRefFunctions.scrollToTop(50);
  };
  const handleNextStep = () => {
    if (activeStep !== void 0 && activeStep < maxStep) {
      handleSetStep(activeStep + 1);
    }
  };
  const handleBackStep = () => {
    if (activeStep === 1 && landedDirectlyOnStep1.current) {
      history.goBack();
    } else if (activeStep !== void 0 && activeStep > 0) {
      handleSetStep(activeStep - 1, { bypassGuard: true });
    }
  };
  const handleSelectWorker = (worker) => {
    setSelectedWorker(worker);
    if (activeStep === 0) {
      handleSetStep(1, { bypassGuard: true });
    }
  };
  const handleSelectService = (serviceGroup, service) => {
    setGroupsSelectedServices((prev) => {
      const index = prev.findIndex(
        (item) => item.serviceGroup.id === serviceGroup.id
      );
      if (index > -1) {
        const group = prev[index].serviceGroup;
        const services = prev[index].services;
        if (services) {
          const serviceIndex = services.findIndex(
            (item) => item.id === service.id
          );
          if (serviceIndex > -1) {
            const existingService = services[serviceIndex];
            const isToggle = existingService.quantity === service.quantity;
            if (hasMultiplePersons) {
              if (isToggle) {
                services.splice(serviceIndex, 1);
              } else if (service.quantity && service.quantity > 0) {
                services[serviceIndex] = service;
              }
            } else {
              services.splice(serviceIndex, 1);
            }
          } else if (group.inputType !== InputType.checkbox && !hasMultiplePersons) {
            services.splice(0, services.length);
            services.push(service);
          } else {
            services.push(service);
          }
          if (services.length === 0) {
            prev.splice(index, 1);
          }
        }
      } else {
        prev.push({ serviceGroup, services: [service] });
      }
      return [...prev];
    });
  };
  const handleHasMultiplePersons = (has) => {
    setHasMultiplePersons(has);
    setGroupsSelectedServices([]);
  };
  const allSelectedServices = reactExports.useMemo(
    () => groupsSelectedServices.filter((groupService) => {
      var _a3;
      return (_a3 = groupService.services) == null ? void 0 : _a3.length;
    }).map((group) => group.services).flat(),
    [groupsSelectedServices]
  );
  const nextButtonDisabled = reactExports.useMemo(() => {
    if (activeStep === void 0) return true;
    if (activeStep === 0) {
      return !selectedWorker;
    }
    if (activeStep === 1) {
      return groupsSelectedServices.length === 0;
    }
    return true;
  }, [activeStep, selectedWorker, groupsSelectedServices]);
  const getBadgeQuantityOfServices = (service) => service.quantity && service.quantity > 1 ? "x".concat(service.quantity) : "";
  reactExports.useEffect(() => {
    var _a3;
    (_a3 = wrapUserLoginModal()) == null ? void 0 : _a3();
  }, []);
  reactExports.useEffect(() => {
    if (activeWorkers.length === 1 && !selectedWorker) {
      const singleWorker = activeWorkers[0];
      setSelectedWorker(singleWorker);
    }
  }, [activeWorkers, selectedWorker]);
  reactExports.useEffect(() => {
    if (activeStep === void 0) return;
    if (activeStep === 2 && groupsSelectedServices.length === 0) {
      forceSetStep(1);
    }
  }, [activeStep, selectedWorker, groupsSelectedServices]);
  reactExports.useEffect(() => {
    var _a3, _b3;
    const params = new URLSearchParams(location.search);
    const stepFromUrl = parseInt((_a3 = params.get("step")) != null ? _a3 : "0", 10);
    setActiveStep(stepFromUrl);
    (_b3 = formRef.current) == null ? void 0 : _b3.handleSetStep(stepFromUrl);
  }, [location.search]);
  if ((serviceGroupsLoading || serviceGroupsFetching || workersLoading) && activeStep) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { name: "crescent" });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormStepper$1,
      {
        className: "mt-2 max-w-[1200px] overflow-y-scroll",
        ref: formRef,
        minStep: 0,
        swiperProps: {
          onSlideChangeTransitionEnd: () => {
            contentRefFunctions == null ? void 0 : contentRefFunctions.scrollToTop(50);
          }
        },
        renderSteps: () => {
          const workerAndCategoryStep = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-4", children: [
            locationHasCategories && /* @__PURE__ */ jsxRuntimeExports.jsx(
              SelectCategoryStep,
              {
                categories,
                selectedCategory,
                onCategorySelect: setSelectedCategory
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SelectWorkerStep,
              {
                selectedWorker,
                setSelectedWorker: handleSelectWorker,
                workerId: selectedWorker ? void 0 : queryWorkerId,
                activeWorkersCount: activeWorkers.length,
                selectedCategory
              }
            )
          ] }, "worker-category");
          const serviceStep = serviceGroups && !serviceGroupsLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectAppointmentStepV2,
            {
              onBack: handleBackStep,
              onNext: handleNextStep,
              selectedWorker,
              serviceGroups,
              groupsSelectedServices,
              onSelectService: handleSelectService,
              hasMultiplePersons,
              setHasMultiplePersons: handleHasMultiplePersons,
              selectedCategory
            },
            "service"
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "flex items-center justify-center py-10",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {})
            },
            "service-loading"
          );
          const allWorkerIds = !selectedWorker ? [] : null;
          const workerForCalendar = selectedWorker || null;
          const calendarStep = /* @__PURE__ */ jsxRuntimeExports.jsx(
            BookingCalendarStep,
            {
              locationWorker: workerForCalendar,
              workerIds: allWorkerIds,
              selectedGroupServices: groupsSelectedServices,
              selectedCategory,
              isActive: activeStep === 2
            },
            "datetime"
          );
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "flex items-center justify-center py-10",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: t2("Odaberite radnika kako biste nastavili") })
            },
            "datetime-placeholder"
          );
          return [workerAndCategoryStep, serviceStep, calendarStep];
        },
        initialStep: activeStep != null ? activeStep : 0,
        onCurrentStepChange: setActiveStep
      }
    ),
    activeStep !== void 0 && activeStep > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(IonFooter, { className: "ion-no-border fixed bottom-2 left-0 right-0 space-y-2", children: [
      activeStep === 2 && allSelectedServices.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 py-2 flex gap-2 overflow-x-auto", children: allSelectedServices.map((service) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonBadge,
        {
          color: "warning",
          className: "text-black whitespace-nowrap flex-shrink-0",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { className: "text-xs font-medium", children: [
            service.title,
            " ",
            getBadgeQuantityOfServices(service)
          ] })
        },
        "selected-".concat(service.id)
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { className: "px-2 h-[76px]", color: "translucent", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonButton,
          {
            onClick: handleBackStep,
            slot: "start",
            color: "dark",
            size: "large",
            disabled: activeStep === 0,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: arrowBack }),
              t2("Nazad")
            ]
          }
        ),
        activeStep < maxStep && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          IonButton,
          {
            onClick: handleNextStep,
            slot: "end",
            color: "dark",
            size: "large",
            disabled: nextButtonDisabled,
            children: [
              t2("Dalje"),
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: arrowForward })
            ]
          }
        )
      ] })
    ] })
  ] });
}
function CreateAppointmentPage() {
  const { t: t2 } = useTranslation();
  const [key, setKey] = reactExports.useState("appointment");
  const { userData } = useUser();
  const router = useIonRouter();
  const dispatch = useAppDispatch();
  const deviceData = useAppSelector(getDeviceData);
  const location = useLocation();
  const [backButtonUrl, setBackButtonUrl] = reactExports.useState(
    void 0
  );
  const initialStep = reactExports.useRef(0);
  const [useCustomBackHandler, setUseCustomBackHandler] = reactExports.useState(false);
  useIonViewDidLeave(() => {
    setTimeout(() => {
      setKey((prev) => prev + "-new");
    }, 1e3);
  });
  reactExports.useEffect(() => {
    var _a2;
    const params = new URLSearchParams(location.search);
    const step = parseInt((_a2 = params.get("step")) != null ? _a2 : "0", 10);
    initialStep.current = step;
    if (step === 0 || step === 1) {
      setBackButtonUrl(void 0);
      setUseCustomBackHandler(false);
    } else {
      setBackButtonUrl(void 0);
      setUseCustomBackHandler(true);
    }
  }, []);
  reactExports.useEffect(() => {
    var _a2;
    const params = new URLSearchParams(location.search);
    const step = parseInt((_a2 = params.get("step")) != null ? _a2 : "0", 10);
    if (step !== initialStep.current && step >= 2) {
      setBackButtonUrl(void 0);
      setUseCustomBackHandler(true);
    } else if (step === 0 || step === 1) {
      setBackButtonUrl(void 0);
      setUseCustomBackHandler(false);
    }
  }, [location.search]);
  const handleBackClick = () => {
    const destination = "".concat(urlPrefix, "/t/termini");
    pushDuplicateAndNavigate(router, destination);
  };
  reactExports.useEffect(() => {
    if (!deviceData.notificationsEnabled && userData) {
      dispatch(setDeviceData({ notificationsEnabled: true }));
    }
  }, [deviceData, userData]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      title: t2("Nov termin"),
      hasBackButton: true,
      backButtonIcon: exitOutline,
      backButtonUrl,
      onBackClick: useCustomBackHandler ? handleBackClick : void 0,
      hasRefresher: false,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateAppointmentSteps, {}, key)
    }
  );
}
const ConfirmReservationPage = reactExports.lazy(() => __vitePreload(() => import("./ConfirmReservationPage-laTrRjVU.js"), true ? __vite__mapDeps([27,1,2,3,4,5,6,15,20,7,8,9]) : void 0));
const ConfirmReservationPageWrapper = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "flex mx-auto mt-5" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmReservationPage, { ...props }) });
};
const PublicProfilePage = reactExports.lazy(() => __vitePreload(() => import("./PublicProfilePage-1t-Ehthr.js"), true ? __vite__mapDeps([28,1,2,3,4,5,6,18,19,7,8,9]) : void 0));
function PublicProfilePageWrapper() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Profil klijenta"),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PublicProfilePage, {})
    }
  );
}
const NewsListPage = reactExports.lazy(() => __vitePreload(() => import("./NewsListPage-I67s63Im.js"), true ? __vite__mapDeps([29,1,2,3,4,5,6,13,7,8,16,9]) : void 0));
const NewsListPageWrapper = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "flex mx-auto mt-5" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(NewsListPage, {}) });
};
const NewsCreatePage = reactExports.lazy(() => __vitePreload(() => import("./NewsCreatePage-CdcLFb50.js"), true ? __vite__mapDeps([30,1,2,3,4,5,6,31,13,7,8,9]) : void 0));
const NewsCreatePageWrapper = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "flex mx-auto mt-5" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(NewsCreatePage, {}) });
};
const NewsEditPage = reactExports.lazy(() => __vitePreload(() => import("./NewsEditPage-C_aT1ZAb.js"), true ? __vite__mapDeps([32,1,2,3,4,5,6,31,13,7,8,9]) : void 0));
const NewsEditPageWrapper = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "flex mx-auto mt-5" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(NewsEditPage, {}) });
};
const LocationWorkingTimePage = reactExports.lazy(() => __vitePreload(() => import("./LocationWorkingTimePage-Boyv2fXR.js"), true ? __vite__mapDeps([33,1,2,3,4,5,6,7,8,9]) : void 0));
function LocationWorkingTimePageWrapper() {
  const { t: t2 } = useTranslation();
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Radno vreme"),
      hasBackButton: true,
      footer: /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          expand: "block",
          onClick: () => setIsModalOpen(true),
          className: "flex items-center gap-1",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline }),
            t2("Dodaj radno vreme")
          ]
        }
      ) }) }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        LocationWorkingTimePage,
        {
          isModalOpen,
          setIsModalOpen
        }
      )
    }
  );
}
const LocationEditPage = reactExports.lazy(() => __vitePreload(() => import("./LocationEditPage-DznzT7Dq.js"), true ? __vite__mapDeps([34,1,2,3,4,5,6,7,8,35,36,37,9]) : void 0));
function LocationEditDataPageWrapper() {
  const { t: t2 } = useTranslation();
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-left", children: t2("Izmeni podatke lokacije") }),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        LocationEditPage,
        {
          isModalOpen,
          setIsModalOpen
        }
      )
    }
  );
}
const LocationWorkersPage = reactExports.lazy(() => __vitePreload(() => import("./LocationWorkersPage-D01gMnhk.js"), true ? __vite__mapDeps([38,1,2,3,4,5,6,7,8,9]) : void 0));
function LocationWorkersPageWrapper() {
  const { t: t2 } = useTranslation();
  const history = useHistory();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Radnici"),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        LocationWorkersPage,
        {
          locationSlug: activeLocation,
          onCreate: () => history.push("/zakazivanje/podesavanja/radnici/novi"),
          onEdit: (worker) => history.push("/zakazivanje/podesavanja/radnici/edit/".concat(worker.id))
        }
      )
    }
  );
}
const LocationSettingsPage = reactExports.lazy(() => __vitePreload(() => import("./LocationSettingsPage-BMw4T4BL.js"), true ? __vite__mapDeps([39,1,2,3,4,5,6,36,7,8,9]) : void 0));
function LocationSettingsPageWrapper() {
  const { t: t2 } = useTranslation();
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Pode큄avanja lokacije"),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        LocationSettingsPage,
        {
          isModalOpen,
          setIsModalOpen
        }
      )
    }
  );
}
const ServicesPage = reactExports.lazy(() => __vitePreload(() => import("./ServicesPage-DAIqJ7Nv.js"), true ? __vite__mapDeps([40,1,2,3,4,5,6,41,35,7,8,9]) : void 0));
function ServicesPageWrapper() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Usluge"),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ServicesPage, {})
    }
  );
}
const ServiceGroupEditPage = reactExports.lazy(() => __vitePreload(() => import("./ServiceGroupEditPage-COBBPTcs.js"), true ? __vite__mapDeps([42,1,2,3,4,5,6,41,35,37,7,8,9]) : void 0));
function ServiceGroupEditPageWrapper() {
  const { t: t2 } = useTranslation();
  const { serviceGroupId } = useParams();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Uredi grupu usluga"),
      hasBackButton: true,
      backButtonUrl: "".concat(urlPrefix, "/podesavanja/usluge"),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ServiceGroupEditPage, { serviceGroupId: parseInt(serviceGroupId) })
    }
  );
}
const ServiceEditPage = reactExports.lazy(() => __vitePreload(() => import("./ServiceEditPage-C54pAxg6.js"), true ? __vite__mapDeps([43,1,2,3,4,5,6,7,8,9]) : void 0));
function ServiceEditPageWrapper() {
  const { t: t2 } = useTranslation();
  const { serviceId } = useParams();
  const {
    data: serviceGroupsResponse,
    isLoading,
    error
  } = useGetFeServiceGroupsQuery({
    locationSlug: activeLocation
  });
  const serviceGroups = (serviceGroupsResponse == null ? void 0 : serviceGroupsResponse.data) || [];
  const service = serviceGroups.flatMap((sg) => sg.services).find((s) => s.id === parseInt(serviceId));
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      LayoutMainPage,
      {
        headerClasses: mainHeaderClasses,
        title: t2("U훾itavanje..."),
        hasBackButton: true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-text-center ion-padding", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { name: "crescent" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("U훾itavanje...") })
        ] })
      }
    );
  }
  if (error || !service) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      LayoutMainPage,
      {
        headerClasses: mainHeaderClasses,
        title: t2("Gre큄ka"),
        hasBackButton: true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-text-center ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "danger", children: t2("Gre큄ka pri u훾itavanju usluge") }) })
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: service.title,
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ServiceEditPage, { service })
    }
  );
}
const serviceGroupEditApi = rzrApi.injectEndpoints({
  endpoints: (build) => ({
    updateServiceGroup: build.mutation({
      query: (data) => ({
        url: "locations/service-groups/update",
        method: "PUT",
        body: humpsExports.decamelizeKeys(data)
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.SERVICES_GROUPS]
    }),
    createServiceGroup: build.mutation({
      query: ({ locationSlug, ...data }) => ({
        url: "locations/service-groups/create",
        method: "POST",
        body: { ...humpsExports.decamelizeKeys(data), locationSlug }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.SERVICES_GROUPS]
    }),
    deleteServiceGroup: build.mutation({
      query: (id) => ({
        url: "locations/service-groups/delete/".concat(id),
        method: "DELETE"
      }),
      invalidatesTags: [TagType$1.SERVICES_GROUPS]
    })
  })
});
const {
  useUpdateServiceGroupMutation,
  useCreateServiceGroupMutation,
  useDeleteServiceGroupMutation
} = serviceGroupEditApi;
const serviceGroupEditFormSchema = create$3().shape({
  title: create$6().required(t("Naslov je obavezan")),
  slug: create$6().required(t("Slug je obavezan")),
  description: create$6().nullable().defined(),
  active: create$7().defined(),
  type: create$5().required(t("Tip je obavezan")),
  required: create$7().defined(),
  minSelected: create$5().nullable().transform((value) => isNaN(value) ? void 0 : value).defined(t("Minimalno izabrano je obavezno")),
  maxSelected: create$5().nullable().transform((value) => isNaN(value) ? void 0 : value).defined(t("Maksimalno izabrano je obavezno"))
});
const getServiceGroupEditFormFields = (serviceGroupId) => {
  const { isAdmin } = useUser();
  return [
    {
      keyName: "title",
      name: "title",
      data: {
        type: FieldType.Text,
        label: t("Naslov"),
        translation: serviceGroupId ? {
          type: "service_group",
          fieldName: "title",
          dataId: serviceGroupId
        } : void 0
      }
    },
    {
      keyName: "slug",
      name: "slug",
      data: {
        type: FieldType.Text,
        label: t("Slug")
      },
      disabled: !isAdmin
    },
    {
      keyName: "description",
      name: "description",
      data: {
        type: FieldType.TextArea,
        label: t("Opis"),
        translation: serviceGroupId ? {
          type: "service_group",
          fieldName: "description",
          dataId: serviceGroupId
        } : void 0
      }
    },
    {
      keyName: "active",
      name: "active",
      data: {
        type: FieldType.Switch,
        label: t("Aktivno")
      },
      disabled: !isAdmin
    },
    {
      keyName: "type",
      name: "type",
      data: {
        type: FieldType.Select,
        label: t("Tip"),
        options: [
          { value: "0", text: t("Salon") },
          { value: "1", text: t("Restoran") }
        ]
      }
    },
    {
      keyName: "required",
      name: "required",
      data: {
        type: FieldType.Switch,
        label: t("Obavezno")
      }
    },
    {
      keyName: "minSelected",
      name: "minSelected",
      data: {
        type: FieldType.Number,
        label: t("Minimalno izabrano")
      }
    },
    {
      keyName: "maxSelected",
      name: "maxSelected",
      data: {
        type: FieldType.Number,
        label: t("Maksimalno izabrano")
      }
    }
  ];
};
function ServiceGroupEditForm({
  serviceGroup,
  onSubmit,
  isLoading: externalLoading
}) {
  var _a2, _b2, _c2, _d2;
  const { t: t2 } = useTranslation();
  const form = useFormWithSchema(serviceGroupEditFormSchema, {
    defaultValues: {
      title: serviceGroup == null ? void 0 : serviceGroup.title,
      slug: serviceGroup == null ? void 0 : serviceGroup.slug,
      description: (serviceGroup == null ? void 0 : serviceGroup.description) || null,
      active: (_a2 = serviceGroup == null ? void 0 : serviceGroup.active) != null ? _a2 : true,
      type: typeof (serviceGroup == null ? void 0 : serviceGroup.type) === "string" ? parseInt(serviceGroup.type) : (serviceGroup == null ? void 0 : serviceGroup.type) || 0,
      required: (_b2 = serviceGroup == null ? void 0 : serviceGroup.required) != null ? _b2 : false,
      minSelected: (_c2 = serviceGroup == null ? void 0 : serviceGroup.minSelected) != null ? _c2 : null,
      maxSelected: (_d2 = serviceGroup == null ? void 0 : serviceGroup.maxSelected) != null ? _d2 : null
    }
  });
  const title = form.watch("title");
  React.useEffect(() => {
    if (title) {
      const generated = generateSlug(title);
      form.setValue("slug", generated);
    }
  }, [title]);
  const [deleteServiceGroup, deleteResponse] = useDeleteServiceGroupMutation();
  const router = useIonRouter();
  useShowNotification({
    message: t2("Podaci su uspe큄no sa훾uvani"),
    color: "success"
  });
  useShowNotification({
    message: t2("Gre큄ka pri 훾uvanju podataka"),
    color: "danger"
  });
  const [showDeleteAlert, setShowDeleteAlert] = React.useState(false);
  const formFields = getServiceGroupEditFormFields(serviceGroup == null ? void 0 : serviceGroup.id);
  const handleSubmit = (data) => {
    if (onSubmit) {
      onSubmit(data);
    }
  };
  const handleDelete = async () => {
    setShowDeleteAlert(true);
  };
  const confirmDelete = async () => {
    if (serviceGroup == null ? void 0 : serviceGroup.id) {
      await deleteServiceGroup(serviceGroup.id);
      router.goBack();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: form.handleSubmit(handleSubmit), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields: formFields, form }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-padding-top flex gap-2", children: [
      (serviceGroup == null ? void 0 : serviceGroup.id) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonButton,
          {
            type: "button",
            size: "small",
            color: "danger",
            onClick: handleDelete,
            disabled: deleteResponse.isLoading,
            fill: "clear",
            style: { minWidth: 0 },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline, slot: "icon-only" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonAlertConfirmation,
          {
            isOpen: showDeleteAlert,
            header: t2("Obri큄i grupu?"),
            message: t2("Da li ste sigurni da 탑elite da obri큄ete ovu grupu?"),
            confirmAction: confirmDelete,
            cancelAction: () => setShowDeleteAlert(false),
            onDidDismiss: () => setShowDeleteAlert(false),
            confirmTextKey: "Da",
            cancelTextKey: "Ne",
            confirmCssClass: "danger"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          type: "submit",
          expand: "block",
          disabled: externalLoading,
          color: "success",
          className: "flex-1",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "start" }),
            externalLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { name: "crescent" }) : t2("Sa훾uvaj podatke")
          ]
        }
      )
    ] }),
    externalLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-padding-top", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: t2("훻uvanje podataka...") }) })
  ] });
}
function ServiceGroupCreatePage() {
  const { t: t2 } = useTranslation();
  const [createServiceGroup, createResponse] = useCreateServiceGroupMutation();
  const router = useIonRouter();
  const handleSubmit = (data) => {
    createServiceGroup({
      ...data,
      locationSlug: activeLocation
    }).then((response) => {
      if ("data" in response) {
        router.goBack();
      }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ServiceGroupEditForm,
    {
      serviceGroup: null,
      onSubmit: handleSubmit,
      isLoading: createResponse.isLoading
    }
  );
}
function ServiceGroupCreatePageWrapper() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Nova grupa usluga"),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ServiceGroupCreatePage, {})
    }
  );
}
const serviceEditApi = rzrApi.injectEndpoints({
  endpoints: (build) => ({
    updateService: build.mutation({
      query: (data) => ({
        url: "locations/services/update",
        method: "PUT",
        body: humpsExports.decamelizeKeys(data)
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.SERVICES_GROUPS, TagType$1.SERVICES]
    }),
    createService: build.mutation({
      query: (data) => ({
        url: "locations/services/create",
        method: "POST",
        body: humpsExports.decamelizeKeys(data)
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.SERVICES_GROUPS, TagType$1.SERVICES]
    }),
    deleteService: build.mutation({
      query: (id) => ({
        url: "locations/services/delete/".concat(id),
        method: "DELETE"
      }),
      invalidatesTags: [TagType$1.SERVICES_GROUPS, TagType$1.SERVICES]
    })
  })
});
const {
  useUpdateServiceMutation,
  useCreateServiceMutation,
  useDeleteServiceMutation
} = serviceEditApi;
const serviceEditFormSchema = create$3().shape({
  groupId: create$5().required("Grupa je obavezna"),
  title: create$6().required("Naslov je obavezan"),
  description: create$6().required().nullable(),
  slug: create$6().required("Slug je obavezan"),
  active: create$7().required(),
  duration: create$5().nullable().transform((value) => isNaN(value) ? void 0 : value).defined("Trajanje je obavezno"),
  price: create$5().nullable().transform((value) => isNaN(value) ? void 0 : value).defined("Cena je obavezna"),
  currency: create$5().required("Valuta je obavezna"),
  changeRequest: create$3({
    isEnabled: create$7().required(),
    scheduledDateUtc: create$6().nullable().required()
  }).nullable()
});
const getServiceEditFormFields = (serviceId) => {
  const { isAdmin } = useUser();
  return [
    {
      keyName: "title",
      name: "title",
      data: {
        type: FieldType.Text,
        label: t("Naslov"),
        translation: serviceId ? {
          type: "service",
          fieldName: "title",
          dataId: serviceId
        } : void 0
      },
      gridSize: { size: "12" }
    },
    {
      keyName: "description",
      name: "description",
      data: {
        type: FieldType.TextArea,
        label: t("Opis"),
        translation: serviceId ? {
          type: "service",
          fieldName: "description",
          dataId: serviceId
        } : void 0
      },
      gridSize: { size: "12" }
    },
    {
      keyName: "slug",
      name: "slug",
      data: {
        type: FieldType.Text,
        label: t("Slug")
      },
      disabled: !isAdmin,
      gridSize: { size: "12" }
    },
    {
      keyName: "active",
      name: "active",
      data: {
        type: FieldType.Switch,
        label: t("Aktivno")
      },
      disabled: !isAdmin,
      gridSize: { size: "12" }
    },
    {
      keyName: "duration",
      name: "duration",
      data: {
        type: FieldType.Number,
        label: t("Trajanje (minuti)")
      }
    },
    {
      keyName: "price",
      name: "price",
      data: {
        type: FieldType.Number,
        label: t("Cena")
      }
    },
    {
      keyName: "currency",
      name: "currency",
      data: {
        type: FieldType.Select,
        label: t("Valuta"),
        options: [
          { value: "0", text: "RSD" },
          { value: "1", text: "EUR" }
        ]
      }
    },
    {
      keyName: "changeRequest",
      name: "changeRequest",
      data: {
        type: FieldType.ChangeRequest,
        label: t("Planirane promene"),
        entityId: serviceId,
        entityType: "service"
      },
      visible: !!serviceId,
      // Only show for existing services
      gridSize: { size: "12" }
    }
  ];
};
function ServiceEditForm({
  service,
  onSubmit,
  isLoading: externalLoading
}) {
  var _a2, _b2, _c2;
  const { t: t2 } = useTranslation();
  const form = useFormWithSchema(serviceEditFormSchema, {
    defaultValues: {
      groupId: service == null ? void 0 : service.groupId,
      title: service == null ? void 0 : service.title,
      description: (_a2 = service == null ? void 0 : service.description) != null ? _a2 : null,
      slug: service == null ? void 0 : service.slug,
      active: (_b2 = service == null ? void 0 : service.active) != null ? _b2 : true,
      duration: service == null ? void 0 : service.duration,
      price: service == null ? void 0 : service.price,
      currency: (_c2 = service == null ? void 0 : service.currency) != null ? _c2 : 0,
      changeRequest: null
    }
  });
  const title = form.watch("title");
  React.useEffect(() => {
    if (title) {
      const generated = generateSlug(title);
      form.setValue("slug", generated);
    }
  }, [title]);
  const [deleteService, deleteResponse] = useDeleteServiceMutation();
  const router = useIonRouter();
  useShowNotification({
    message: t2("Podaci su uspe큄no sa훾uvani"),
    color: "success"
  });
  useShowNotification({
    message: t2("Gre큄ka pri 훾uvanju podataka"),
    color: "danger"
  });
  const [showDeleteAlert, setShowDeleteAlert] = React.useState(false);
  const formFields = getServiceEditFormFields(service == null ? void 0 : service.id);
  const handleSubmit = (data) => {
    console.log(data);
    if (onSubmit) {
      onSubmit(data);
    }
  };
  const handleDelete = async () => {
    setShowDeleteAlert(true);
  };
  const confirmDelete = async () => {
    if (service == null ? void 0 : service.id) {
      deleteService(service.id).then((response) => {
        if ("data" in response) {
          router.goBack();
        }
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: form.handleSubmit(handleSubmit), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields: formFields, form }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-padding-top flex gap-2", children: [
      (service == null ? void 0 : service.id) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonButton,
          {
            type: "button",
            size: "small",
            color: "danger",
            onClick: handleDelete,
            disabled: deleteResponse.isLoading,
            fill: "clear",
            style: { minWidth: 0 },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline, slot: "icon-only" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonAlertConfirmation,
          {
            isOpen: showDeleteAlert,
            header: t2("Obri큄i uslugu?"),
            message: t2("Da li ste sigurni da 탑elite da obri큄ete ovu uslugu?"),
            confirmAction: confirmDelete,
            cancelAction: () => setShowDeleteAlert(false),
            onDidDismiss: () => setShowDeleteAlert(false),
            confirmTextKey: "Da",
            cancelTextKey: "Ne",
            confirmCssClass: "danger"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonButton,
        {
          type: "submit",
          expand: "block",
          style: { flexGrow: 1 },
          disabled: externalLoading,
          color: "success",
          className: "flex-1",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: saveOutline, slot: "start" }),
            externalLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { name: "crescent" }) : t2("Sa훾uvaj podatke")
          ]
        }
      )
    ] })
  ] });
}
function ServiceCreatePage({ groupId }) {
  const { t: t2 } = useTranslation();
  const [createService, createResponse] = useCreateServiceMutation();
  const router = useIonRouter();
  const handleSubmit = (data) => {
    createService(data).then((response) => {
      if ("data" in response) {
        router.goBack();
      }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ServiceEditForm,
    {
      service: {
        groupId
      },
      onSubmit: handleSubmit,
      isLoading: createResponse.isLoading
    }
  );
}
function ServiceCreatePageWrapper() {
  const { t: t2 } = useTranslation();
  const { groupId } = useParams();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Nova usluga"),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ServiceCreatePage, { groupId: parseInt(groupId, 10) })
    }
  );
}
const LocationWorkerCreatePage = reactExports.lazy(
  () => __vitePreload(() => import("./LocationWorkerCreatePage-CPw9lj4m.js"), true ? __vite__mapDeps([44,1,2,3,4,5,6,7,8,9]) : void 0)
);
function LocationWorkerCreatePageWrapper() {
  const { t: t2 } = useTranslation();
  const locationSlug = activeLocation;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Novi radnik"),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(LocationWorkerCreatePage, { locationSlug })
    }
  );
}
const workerEditFormSchema = create$3().shape({
  firstName: create$6().required(t("Ime je obavezno")),
  lastName: create$6().required(t("Prezime je obavezno")),
  description: create$6().nullable().defined(),
  userId: create$5().nullable().defined(),
  active: create$7().defined(),
  avatar: create$2().nullable().defined()
});
const getWorkerEditFormFields = (users, workerId, initialValues, onAvatarUploadSuccess) => {
  var _a2;
  return [
    {
      keyName: "firstName",
      name: "firstName",
      data: {
        type: FieldType.Text,
        label: t("Ime"),
        translation: workerId ? {
          type: "location_worker",
          fieldName: "first_name",
          dataId: workerId
        } : void 0
      }
    },
    {
      keyName: "lastName",
      name: "lastName",
      data: {
        type: FieldType.Text,
        label: t("Prezime")
      }
    },
    {
      keyName: "description",
      name: "description",
      data: {
        type: FieldType.TextArea,
        label: t("Opis"),
        translation: workerId ? {
          type: "location_worker",
          fieldName: "description",
          dataId: workerId
        } : void 0
      }
    },
    {
      keyName: "userId",
      name: "userId",
      data: {
        type: FieldType.Autocomplete,
        // async search handled in DynamicForm
        label: t("Korisnik (email)"),
        options: users.map((user) => ({
          text: user.email,
          value: user.id.toString()
        }))
      }
    },
    {
      keyName: "avatar",
      name: "avatar",
      data: {
        type: FieldType.GalleryArea,
        label: t("Slika radnika"),
        oneImage: true,
        maxPhotos: 1,
        photos: ((_a2 = initialValues == null ? void 0 : initialValues.avatar) == null ? void 0 : _a2.map((photo) => ({
          id: photo.id,
          url: photo.url,
          name: photo.url.split("/").pop() || "avatar",
          index: 0
        }))) || [],
        cropAspectRatio: {
          width: 1,
          height: 1
        },
        uploadUrl: "rzr/locations/worker/".concat(workerId, "/avatar"),
        deleteUrl: "rzr/locations/worker/".concat(workerId, "/avatar"),
        uploadBehavior: "onSave",
        onUploadSuccess: (photo) => {
          onAvatarUploadSuccess == null ? void 0 : onAvatarUploadSuccess();
        },
        onUploadError: (error) => {
          console.error("Avatar upload error:", error);
        },
        onDeleteSuccess: (photoId) => {
          onAvatarUploadSuccess == null ? void 0 : onAvatarUploadSuccess();
        },
        onDeleteError: (error) => {
          console.error("Avatar delete error:", error);
        }
      }
    },
    {
      keyName: "active",
      name: "active",
      data: {
        type: FieldType.Switch,
        label: t("Aktivan")
      }
    }
  ];
};
const userApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    userSearch: builder.query({
      query: (params) => ({
        url: "users/list",
        method: "GET",
        params
      }),
      transformResponse: transformPaginationResponseToCamelCase
    })
  })
});
const { useUserSearchQuery } = userApi;
const WorkerForm = ({
  initialValues = {},
  onSubmit,
  onDelete,
  isEdit = false,
  loading = false,
  onAvatarUploadSuccess
}) => {
  var _a2;
  const { t: t2 } = useTranslation();
  const form = useFormWithSchema(workerEditFormSchema, {
    defaultValues: initialValues
  });
  const { data: userData } = useUserSearchQuery({});
  const fields = getWorkerEditFormFields(
    (_a2 = userData == null ? void 0 : userData.data) != null ? _a2 : [],
    initialValues == null ? void 0 : initialValues.id,
    initialValues,
    onAvatarUploadSuccess
    // Pass callback for avatar upload success
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: form.handleSubmit(onSubmit), className: "p-0", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields, form }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormActionButtons,
      {
        onSave: form.handleSubmit(onSubmit),
        isSaving: loading,
        onDelete,
        isDeleting: loading,
        showDelete: isEdit,
        deleteConfirmationProps: {
          header: t2("Obri큄i radnika?"),
          message: t2("Da li ste sigurni da 탑elite da obri큄ete ovog radnika?")
        }
      }
    )
  ] });
};
function WorkerServiceManagement({
  worker,
  locationSlug
}) {
  const { t: t2 } = useTranslation();
  const [workerServices, setWorkerServices] = reactExports.useState(/* @__PURE__ */ new Map());
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [isSyncedService, setIsSyncedService] = reactExports.useState(worker.isSyncedService);
  const [updateWorker, { isLoading: isUpdating }] = useUpdateWorkerMutation();
  const [storeWorkerService] = useStoreWorkerServiceMutation();
  const [updateWorkerService] = useUpdateWorkerServiceMutation();
  const [deleteWorkerService] = useDeleteWorkerServiceMutation();
  const {
    data: serviceGroupsResponse,
    isLoading: isLoadingServices,
    error
  } = useGetFeServiceGroupsQuery({
    locationSlug
  });
  const {
    data: workerServicesResponse,
    isLoading: isLoadingWorkerServices,
    error: workerServicesError
  } = useGetWorkerServicesQuery({
    locationSlug,
    workerId: worker.id
  });
  const serviceGroups = (serviceGroupsResponse == null ? void 0 : serviceGroupsResponse.data) || [];
  reactExports.useEffect(() => {
    if (workerServicesResponse == null ? void 0 : workerServicesResponse.data) {
      const servicesMap = /* @__PURE__ */ new Map();
      workerServicesResponse.data.forEach(
        (workerService) => {
          servicesMap.set(workerService.serviceId, {
            serviceId: workerService.serviceId,
            price: workerService.price,
            duration: workerService.duration,
            active: workerService.active,
            useDefaultPrice: workerService.price === null || workerService.price === void 0,
            useDefaultDuration: workerService.duration === null || workerService.duration === void 0
          });
        }
      );
      setWorkerServices(servicesMap);
    }
  }, [workerServicesResponse]);
  reactExports.useEffect(() => {
    setIsSyncedService(worker.isSyncedService);
  }, [worker.isSyncedService]);
  const handleServiceToggle = (service, checked) => {
    const newServices = new Map(workerServices);
    if (checked) {
      newServices.set(service.id, {
        serviceId: service.id,
        price: service.price,
        duration: service.duration,
        active: true,
        useDefaultPrice: true,
        useDefaultDuration: true
      });
    } else {
      newServices.delete(service.id);
    }
    setWorkerServices(newServices);
  };
  const handlePriceChange = (serviceId, price) => {
    const newServices = new Map(workerServices);
    const service = newServices.get(serviceId);
    if (service) {
      newServices.set(serviceId, { ...service, price });
    }
    setWorkerServices(newServices);
  };
  const handleDurationChange = (serviceId, duration) => {
    const newServices = new Map(workerServices);
    const service = newServices.get(serviceId);
    if (service) {
      newServices.set(serviceId, { ...service, duration });
    }
    setWorkerServices(newServices);
  };
  const handleUseDefaultPriceToggle = (serviceId, useDefault) => {
    const newServices = new Map(workerServices);
    const service = newServices.get(serviceId);
    if (service) {
      newServices.set(serviceId, {
        ...service,
        useDefaultPrice: useDefault,
        price: useDefault ? void 0 : service.price
      });
    }
    setWorkerServices(newServices);
  };
  const handleUseDefaultDurationToggle = (serviceId, useDefault) => {
    const newServices = new Map(workerServices);
    const service = newServices.get(serviceId);
    if (service) {
      newServices.set(serviceId, {
        ...service,
        useDefaultDuration: useDefault,
        duration: useDefault ? void 0 : service.duration
      });
    }
    setWorkerServices(newServices);
  };
  const handleOnFocus = (e) => {
    var _a2;
    (_a2 = e.nativeEvent.target) == null ? void 0 : _a2.select();
  };
  const handleSyncedServiceToggle = async (checked) => {
    setIsSyncedService(checked);
    try {
      await updateWorker({
        id: worker.id,
        locationSlug,
        isSyncedService: checked
      }).unwrap();
      if (checked) {
        setWorkerServices(/* @__PURE__ */ new Map());
      } else {
        const servicesMap = /* @__PURE__ */ new Map();
        serviceGroups.forEach((group) => {
          group.services.forEach((service) => {
            servicesMap.set(service.id, {
              serviceId: service.id,
              price: service.price,
              duration: service.duration,
              active: true,
              useDefaultPrice: true,
              useDefaultDuration: true
            });
          });
        });
        setWorkerServices(servicesMap);
      }
    } catch (error2) {
      console.error("Error updating worker:", error2);
      setIsSyncedService(!checked);
    }
  };
  reactExports.useEffect(() => {
    if (isSyncedService && (workerServicesResponse == null ? void 0 : workerServicesResponse.data)) {
      const servicesMap = /* @__PURE__ */ new Map();
      workerServicesResponse.data.forEach(
        (workerService) => {
          servicesMap.set(workerService.serviceId, {
            serviceId: workerService.serviceId,
            price: workerService.price,
            duration: workerService.duration,
            active: workerService.active,
            useDefaultPrice: workerService.price === null || workerService.price === void 0,
            useDefaultDuration: workerService.duration === null || workerService.duration === void 0
          });
        }
      );
      setWorkerServices(servicesMap);
    }
  }, [isSyncedService, workerServicesResponse]);
  const handleSave = async () => {
    setIsLoading(true);
    try {
      const locationId = 1;
      const servicesToSave = Array.from(workerServices.entries()).map(
        ([serviceId, serviceData]) => ({
          serviceId,
          locationId,
          price: serviceData.useDefaultPrice ? void 0 : serviceData.price,
          duration: serviceData.useDefaultDuration ? void 0 : serviceData.duration,
          sortOrder: void 0,
          // Add sortOrder field
          active: serviceData.active
        })
      );
      const bulkPayload = {
        locationSlug,
        workerId: worker.id,
        services: servicesToSave
      };
      try {
        const result = await storeWorkerService(bulkPayload).unwrap();
        console.log("Worker services saved successfully:", result);
      } catch (error2) {
        console.error("Error saving worker services:", error2);
      }
    } catch (error2) {
      console.error("Error saving worker services:", error2);
    } finally {
      setIsLoading(false);
    }
  };
  if (isLoadingServices) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center p-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}) });
  }
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center p-8 text-red-500", children: t2("Gre큄ka pri u훾itavanju usluga.") });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCard, { className: "mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonToggle,
        {
          checked: isSyncedService,
          onIonChange: (e) => handleSyncedServiceToggle(e.detail.checked),
          disabled: isUpdating
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("Podrazumevani svi servisi") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2(
          "Kada je stiklirano, radnik koristi sve servise sa default cenama i trajanjima"
        ) })
      ] })
    ] }) }) }),
    serviceGroups.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonCard, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardContent, { className: "text-center p-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: t2("Nema usluga za prikaz.") }) }) }) : isSyncedService ? /* @__PURE__ */ jsxRuntimeExports.jsx(IonCard, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { className: "text-center p-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonIcon,
        {
          icon: checkmarkCircleOutline,
          className: "text-4xl text-green-500 mb-4"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonText, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-medium", children: t2("Radnik koristi sve servise sa default cenama") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm mt-2", children: t2(
          'Odstikliraj "Podrazumevani svi servisi" da bi prilagodio servise'
        ) })
      ] })
    ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      serviceGroups.map((group) => /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { className: "mb-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardTitle, { children: group.title }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonList, { children: group.services.map((service) => {
          var _a2, _b2;
          const isSelected = workerServices.has(service.id);
          const workerService = workerServices.get(service.id);
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              IonItem,
              {
                button: true,
                onClick: () => handleServiceToggle(service, !isSelected),
                className: "ion-no-padding",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    IonCheckbox,
                    {
                      slot: "start",
                      checked: isSelected,
                      onIonChange: (e) => {
                        e.stopPropagation();
                        handleServiceToggle(service, e.detail.checked);
                      }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium", children: service.title }),
                    service.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 mt-1", children: service.description }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-gray-400 mt-1", children: [
                      service.price,
                      " RSD  ",
                      service.duration,
                      " min"
                    ] })
                  ] })
                ]
              }
            ),
            isSelected && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "py-2 border-b border-gray-200", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3 mb-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonCheckbox,
                  {
                    checked: (_a2 = workerService == null ? void 0 : workerService.useDefaultPrice) != null ? _a2 : true,
                    onIonChange: (e) => {
                      handleUseDefaultPriceToggle(
                        service.id,
                        e.detail.checked
                      );
                    },
                    labelPlacement: "end",
                    slot: "end",
                    color: "warning",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { className: "text-sm", children: t2("Osnovna cena") })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonCheckbox,
                  {
                    checked: (_b2 = workerService == null ? void 0 : workerService.useDefaultDuration) != null ? _b2 : true,
                    onIonChange: (e) => {
                      handleUseDefaultDurationToggle(
                        service.id,
                        e.detail.checked
                      );
                    },
                    labelPlacement: "end",
                    slot: "start",
                    color: "warning",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { className: "text-sm", children: t2("Osnovno trajanje") })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
                !(workerService == null ? void 0 : workerService.useDefaultPrice) && /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "border rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonInput,
                  {
                    label: t2("Cena (RSD)"),
                    labelPlacement: "floating",
                    type: "number",
                    value: (workerService == null ? void 0 : workerService.price) || service.price,
                    onFocus: handleOnFocus,
                    onIonInput: (e) => {
                      handlePriceChange(
                        service.id,
                        Number(e.detail.value)
                      );
                    }
                  }
                ) }),
                !(workerService == null ? void 0 : workerService.useDefaultDuration) && /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { className: "border rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonInput,
                  {
                    label: t2("Trajanje (min)"),
                    labelPlacement: "floating",
                    type: "number",
                    value: (workerService == null ? void 0 : workerService.duration) || service.duration,
                    onFocus: handleOnFocus,
                    onIonInput: (e) => {
                      handleDurationChange(
                        service.id,
                        Number(e.detail.value)
                      );
                    }
                  }
                ) })
              ] })
            ] })
          ] }, service.id);
        }) }) })
      ] }, group.id)),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormActionButtons,
        {
          onSave: handleSave,
          isSaving: isLoading,
          saveButtonProps: {
            children: t2("Sa훾uvaj usluge"),
            expand: "block"
          }
        }
      )
    ] })
  ] });
}
const convertProductPhotoToUploadPhoto = (productPhoto) => ({
  url: productPhoto.path,
  id: productPhoto.id
});
const convertProductPhotosToUploadPhotos = (productPhotos) => {
  if (Array.isArray(productPhotos)) {
    return productPhotos.map(convertProductPhotoToUploadPhoto);
  }
  return [convertProductPhotoToUploadPhoto(productPhotos)];
};
const LocationWorkerEditPage = ({
  locationSlug,
  worker
}) => {
  const { t: t2 } = useTranslation();
  const history = useHistory();
  const [activeTab, setActiveTab] = reactExports.useState("details");
  const [updateWorker, { isLoading, isSuccess, isError }] = useUpdateWorkerMutation();
  const [deleteWorker, { isLoading: isDeleting }] = useDeleteWorkerMutation();
  const { refetch } = useGetFeWorkerQuery({
    workerId: worker.id,
    locationSlug
  });
  const handleSubmit = async (data) => {
    await updateWorker({ ...data, id: worker.id, locationSlug }).unwrap();
  };
  const handleDelete = async () => {
    await deleteWorker({ id: worker.id, locationSlug }).unwrap();
    history.goBack();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonSegment,
      {
        value: activeTab,
        onIonChange: (e) => setActiveTab(e.detail.value),
        className: "mb-4",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonSegmentButton, { value: "details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: personOutline }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Podaci") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonSegmentButton, { value: "services", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: settingsOutline }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Usluge") })
          ] })
        ]
      }
    ),
    activeTab === "details" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      WorkerForm,
      {
        initialValues: {
          ...worker,
          avatar: convertProductPhotosToUploadPhotos(worker.avatar || [])
        },
        onSubmit: handleSubmit,
        onDelete: handleDelete,
        isEdit: true,
        loading: isLoading || isDeleting,
        onAvatarUploadSuccess: () => {
          refetch();
        }
      }
    ),
    activeTab === "services" && /* @__PURE__ */ jsxRuntimeExports.jsx(WorkerServiceManagement, { worker, locationSlug }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NotificationToast,
      {
        isOpen: isSuccess || isError,
        onDidDismiss: () => {
        },
        message: isSuccess ? "Radnik je uspe큄no sa훾uvan" : "Gre큄ka pri 훾uvanju radnika",
        type: isSuccess ? "success" : "error"
      }
    )
  ] });
};
function LocationWorkerEditPageWrapper() {
  const { t: t2 } = useTranslation();
  const locationSlug = activeLocation;
  const { workerId } = useParams();
  const {
    data: workerResponse,
    isLoading,
    isError
  } = useGetFeWorkerQuery({
    workerId: parseInt(workerId),
    locationSlug
  });
  const worker = workerResponse == null ? void 0 : workerResponse.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Izmeni radnika"),
      hasBackButton: true,
      children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center p-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}) }) : isError || !worker ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center p-8 text-red-500", children: t2("Gre큄ka pri u훾itavanju radnika.") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(LocationWorkerEditPage, { locationSlug, worker })
    }
  );
}
const promoCodeApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getAllPromoCodes: builder.query({
      query: ({ locationSlug }) => ({
        url: "locations/promo-codes/all",
        method: "GET",
        params: { locationSlug }
      }),
      transformResponse: transformPaginationResponseToCamelCase,
      providesTags: [TagType$1.LOCATION_PROMO_CODES]
    }),
    createPromoCode: builder.mutation({
      query: ({ locationSlug, ...body }) => ({
        url: "locations/promo-codes/create",
        method: "POST",
        body: {
          ...humpsExports.decamelizeKeys(body),
          locationSlug
        }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_PROMO_CODES]
    }),
    updatePromoCode: builder.mutation({
      query: ({ id, locationSlug, ...body }) => ({
        url: "locations/promo-codes/update",
        method: "POST",
        body: {
          ...humpsExports.decamelizeKeys(body),
          id,
          locationSlug
        }
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_PROMO_CODES]
    }),
    deletePromoCode: builder.mutation({
      query: (body) => ({
        url: "locations/promo-codes/delete",
        method: "POST",
        body
      }),
      transformResponse: transformStandardResponseToCamelCase,
      invalidatesTags: [TagType$1.LOCATION_PROMO_CODES]
    })
  })
});
const {
  useGetAllPromoCodesQuery,
  useCreatePromoCodeMutation,
  useUpdatePromoCodeMutation,
  useDeletePromoCodeMutation
} = promoCodeApi;
function LocationPromoCodesPage({
  locationSlug,
  onCreate,
  onEdit
}) {
  var _a2;
  const { t: t2 } = useTranslation();
  const { data, isLoading, isError } = useGetAllPromoCodesQuery({
    locationSlug
  });
  const getStatusBadge = (promoCode) => {
    const now = /* @__PURE__ */ new Date();
    const activateAt = new Date(promoCode.activateAtUtc);
    const deactivateAt = new Date(promoCode.deactivateAtUtc);
    if (!promoCode.isActive) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(IonBadge, { color: "medium", children: "Neaktivan" });
    }
    if (now < activateAt) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(IonBadge, { color: "warning", children: "훻eka" });
    }
    if (now > deactivateAt) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(IonBadge, { color: "danger", children: "Istekao" });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IonBadge, { color: "success", children: "Aktivan" });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardTitle, { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: giftOutline }),
        t2("Promo kodovi")
      ] }),
      onCreate && /* @__PURE__ */ jsxRuntimeExports.jsxs(IonButton, { onClick: onCreate, size: "small", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: addOutline, slot: "start" }),
        t2("Novi kod")
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardContent, { className: "ion-no-padding", children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center p-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}) }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center p-8 text-red-500", children: t2("Gre큄ka pri u훾itavanju promo kodova.") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(IonList, { children: !((_a2 = data == null ? void 0 : data.data) == null ? void 0 : _a2.length) ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center p-8 text-gray-500", children: t2("Nema promo kodova za ovu lokaciju.") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: data.data.map((promoCode) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonItem,
      {
        button: true,
        onClick: () => onEdit == null ? void 0 : onEdit(promoCode),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { className: "flex flex-col ion-no-padding", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: promoCode.name }),
            getStatusBadge(promoCode)
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-gray-600", children: [
            promoCode.discountValue,
            promoCode.inPercent ? "%" : " RSD",
            " popusta",
            " - "
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-gray-500", children: [
            t2("Aktivno od"),
            ":",
            " ",
            format(promoCode.activateAtUtc, "dd.MM.yyyy"),
            " -",
            " ",
            format(promoCode.deactivateAtUtc, "dd.MM.yyyy")
          ] })
        ] })
      },
      promoCode.id
    )) }) }) })
  ] }) });
}
function LocationPromoCodesPageWrapper() {
  const { t: t2 } = useTranslation();
  const history = useHistory();
  const locationSlug = activeLocation;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Promo kodovi"),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        LocationPromoCodesPage,
        {
          locationSlug,
          onCreate: () => history.push("/zakazivanje/podesavanja/promo-kodovi/novo"),
          onEdit: (promoCode) => history.push(
            "/zakazivanje/podesavanja/promo-kodovi/edit/".concat(promoCode.id)
          )
        }
      )
    }
  );
}
const promoCodeFormSchema = create$3().shape({
  name: create$6().required(t("Naziv je obavezan")).min(3, t("Naziv mora imati najmanje 3 karaktera")).transform((value) => {
    if (!value) return value;
    let cleanValue = value.replace(/#/g, "");
    return cleanValue + "#";
  }).test(
    "single-hash-at-end",
    t("Naziv mora imati ta훾no jedan # na kraju"),
    (value) => {
      if (!value) return false;
      const hashCount = (value.match(/#/g) || []).length;
      return hashCount === 1 && value.endsWith("#");
    }
  ),
  discountValue: create$5().transform((value) => isNaN(value) ? void 0 : value).required(t("Vrednost popusta je obavezna")).min(0, t("Vrednost popusta mora biti ve훶a od 0")).when("inPercent", {
    is: true,
    then: (schema2) => schema2.max(100, t("Procenat popusta ne mo탑e biti ve훶i od 100")),
    otherwise: (schema2) => schema2
  }),
  inPercent: create$7().required(),
  activateAtUtc: create$6().required(t("Datum aktivacije je obavezan")),
  deactivateAtUtc: create$6().required(t("Datum deaktivacije je obavezan")),
  isActive: create$7().required()
});
const getPromoCodeFormFields = () => [
  {
    keyName: "name",
    name: "name",
    data: {
      type: FieldType.Text,
      label: t("Naziv")
    }
  },
  {
    keyName: "discountValue",
    name: "discountValue",
    data: {
      type: FieldType.Number,
      label: t("Vrednost popusta")
    }
  },
  {
    keyName: "inPercent",
    name: "inPercent",
    data: {
      type: FieldType.Switch,
      label: t("U procentima")
    }
  },
  {
    keyName: "activateAtUtc",
    name: "activateAtUtc",
    data: {
      type: FieldType.DateTime,
      label: t("Aktivno od")
    }
  },
  {
    keyName: "deactivateAtUtc",
    name: "deactivateAtUtc",
    data: {
      type: FieldType.DateTime,
      label: t("Aktivno do")
    }
  },
  {
    keyName: "isActive",
    name: "isActive",
    data: {
      type: FieldType.Switch,
      label: t("Aktivan")
    }
  }
];
const PromoCodeForm = ({
  initialValues = {
    isActive: true,
    inPercent: true
  },
  onSubmit,
  onDelete,
  isEdit = false,
  loading = false
}) => {
  const { t: t2 } = useTranslation();
  const form = useFormWithSchema(promoCodeFormSchema, {
    defaultValues: initialValues
  });
  const fields = getPromoCodeFormFields();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: form.handleSubmit(onSubmit), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicForm, { fields, form }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 mt-4 justify-center", children: [
      isEdit && onDelete && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        IonAlertConfirmationBtn,
        {
          color: "danger",
          alertProps: {
            header: t2("Da li ste sigurni?"),
            message: t2("Obri큄i promo kod")
          },
          onConfirm: onDelete,
          disabled: loading,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: trashOutline }),
            t2("Obri큄i")
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonButton,
        {
          type: "submit",
          expand: "block",
          disabled: loading,
          className: "w-full",
          children: isEdit ? t2("Sa훾uvaj") : t2("Kreiraj")
        }
      )
    ] })
  ] });
};
const LocationPromoCodeCreatePage = ({ locationSlug }) => {
  const { t: t2 } = useTranslation();
  const history = useHistory();
  const [createPromoCode, { isLoading }] = useCreatePromoCodeMutation();
  const handleSubmit = async (data) => {
    try {
      await createPromoCode({ ...data, locationSlug }).unwrap();
      history.goBack();
    } catch (e) {
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PromoCodeForm, { onSubmit: handleSubmit, loading: isLoading });
};
function LocationPromoCodeCreatePageWrapper() {
  const { t: t2 } = useTranslation();
  const locationSlug = activeLocation;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Novi promo kod"),
      hasBackButton: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(LocationPromoCodeCreatePage, { locationSlug })
    }
  );
}
const LocationPromoCodeEditPage = ({
  locationSlug,
  promoCode
}) => {
  const { t: t2 } = useTranslation();
  const history = useHistory();
  const [updatePromoCode, { isLoading }] = useUpdatePromoCodeMutation();
  const [deletePromoCode, { isLoading: isDeleting }] = useDeletePromoCodeMutation();
  const handleSubmit = async (data) => {
    try {
      await updatePromoCode({
        ...data,
        id: promoCode.id,
        locationSlug
      }).unwrap();
      history.goBack();
    } catch (e) {
    }
  };
  const handleDelete = async () => {
    try {
      await deletePromoCode({ id: promoCode.id, locationSlug }).unwrap();
      history.goBack();
    } catch (e) {
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    PromoCodeForm,
    {
      initialValues: promoCode,
      onSubmit: handleSubmit,
      onDelete: handleDelete,
      isEdit: true,
      loading: isLoading || isDeleting
    }
  );
};
function LocationPromoCodeEditPageWrapper() {
  var _a2;
  const { t: t2 } = useTranslation();
  const locationSlug = activeLocation;
  const { promoCodeId } = useParams();
  const { data, isLoading, isError } = useGetAllPromoCodesQuery({
    locationSlug
  });
  const promoCode = (_a2 = data == null ? void 0 : data.data) == null ? void 0 : _a2.find(
    (p) => String(p.id) === String(promoCodeId)
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LayoutMainPage,
    {
      headerClasses: mainHeaderClasses,
      title: t2("Izmeni promo kod"),
      hasBackButton: true,
      children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center p-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}) }) : isError || !promoCode ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center p-8 text-red-500", children: t2("Gre큄ka pri u훾itavanju promo koda.") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        LocationPromoCodeEditPage,
        {
          locationSlug,
          promoCode
        }
      )
    }
  );
}
const googleCalendarApi = rzrApi.injectEndpoints({
  endpoints: (builder) => ({
    getGoogleCalendarSettings: builder.query({
      query: () => ({
        url: "locations/google-calendar/settings",
        method: "GET"
      }),
      providesTags: [{ type: TagType$1.USER, id: "google-calendar-settings" }]
    }),
    connectGoogleCalendar: builder.mutation({
      query: (body) => ({
        url: "locations/google-calendar/connect",
        method: "POST",
        body
      }),
      invalidatesTags: [{ type: TagType$1.USER, id: "google-calendar-settings" }]
    }),
    updateGoogleCalendarSettings: builder.mutation({
      query: (settings) => ({
        url: "locations/google-calendar/settings",
        method: "PUT",
        body: settings
      }),
      invalidatesTags: [{ type: TagType$1.USER, id: "google-calendar-settings" }]
    }),
    syncGoogleCalendar: builder.mutation({
      query: () => ({
        url: "locations/google-calendar/sync",
        method: "POST"
      }),
      invalidatesTags: [
        { type: TagType$1.RESERVATION, id: "LIST" },
        { type: TagType$1.USER, id: "google-calendar-settings" }
      ]
    }),
    getGoogleCalendarEvents: builder.query({
      query: ({ limit = 20 } = {}) => ({
        url: "locations/google-calendar/events?limit=" + limit,
        method: "GET"
      }),
      providesTags: [{ type: TagType$1.USER, id: "google-calendar-events" }]
    })
  })
});
const {
  useGetGoogleCalendarSettingsQuery,
  useConnectGoogleCalendarMutation,
  useUpdateGoogleCalendarSettingsMutation,
  useSyncGoogleCalendarMutation,
  useGetGoogleCalendarEventsQuery
} = googleCalendarApi;
function GoogleCalendarSettingsPage() {
  var _a2;
  const { t: t2 } = useTranslation();
  const [showAlert, setShowAlert] = reactExports.useState(false);
  const [alertMessage, setAlertMessage] = reactExports.useState("");
  const { data: settingsResponse, isLoading } = useGetGoogleCalendarSettingsQuery();
  const [updateSettings] = useUpdateGoogleCalendarSettingsMutation();
  const [syncCalendar, { isLoading: isSyncing }] = useSyncGoogleCalendarMutation();
  const [connectCalendar, { isLoading: isConnecting }] = useConnectGoogleCalendarMutation();
  const { data: eventsResponse, isLoading: isEventsLoading } = useGetGoogleCalendarEventsQuery({ limit: 20 });
  const settings = (settingsResponse == null ? void 0 : settingsResponse.data) || {
    syncToCalendar: true,
    syncFromCalendar: true,
    blockOverlappingSlots: true,
    allowOverlappingWithApproval: false,
    googleEmail: null,
    isConnected: false
  };
  const updateSetting = async (key, value) => {
    const newSettings = { ...settings, [key]: value };
    await updateSettings(newSettings);
  };
  const googleLogin = useGoogleLogin$1({
    onSuccess: async (tokenResponse) => {
      const result = await connectCalendar({ accessToken: tokenResponse.access_token });
      if ("data" in result) {
        setAlertMessage(t2("Google Calendar uspe큄no povezan!"));
      } else {
        setAlertMessage(t2("Gre큄ka pri povezivanju Google Calendar-a"));
      }
      setShowAlert(true);
    },
    onError: () => {
      setAlertMessage(t2("Gre큄ka pri autentifikaciji"));
      setShowAlert(true);
    },
    scope: "https://www.googleapis.com/auth/calendar https://www.googleapis.com/auth/calendar.events"
  });
  const handleConnectOrSync = async () => {
    if (!settings.isConnected) {
      googleLogin();
      return;
    }
    const result = await syncCalendar();
    if ("data" in result) {
      setAlertMessage(t2("Sinhronizacija je uspe큄no zavr큄ena"));
    } else {
      setAlertMessage(t2("Gre큄ka pri sinhronizaciji kalendara"));
    }
    setShowAlert(true);
  };
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-padding ion-text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-padding", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCard, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonCardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardTitle, { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: calendarOutline }),
        t2("Google Calendar pode큄avanja")
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonCardContent, { className: "ion-no-padding", children: [
        settings.googleEmail && /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: t2("Status konekcije") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            t2("Povezan sa"),
            ": ",
            settings.googleEmail
          ] })
        ] }) }),
        !settings.isConnected && /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { color: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: t2("Google Calendar nije povezan") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("Molimo pove탑ite va큄 Google Calendar nalog da bi omogu훶ili sinhronizaciju.") })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            IonButton,
            {
              fill: "solid",
              color: settings.isConnected ? "primary" : "success",
              slot: "start",
              onClick: handleConnectOrSync,
              disabled: isSyncing || isConnecting,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { icon: refreshOutline, slot: "start" }),
                isSyncing ? t2("Sinhronizacija...") : isConnecting ? t2("Povezivanje...") : settings.isConnected ? t2("Sinhronizuj") : t2("Pove탑i Google Calendar")
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: settings.isConnected ? t2("Sinhronizacija sa Google Calendar") : t2("Povezivanje sa Google Calendar") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: settings.isConnected ? t2("Kliknite da sinhronizujete rezervacije sa Google Calendar") : t2("Kliknite da pove탑ete va큄 Google Calendar nalog") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Sinhronizuj u kalendar") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonToggle,
            {
              checked: settings.syncToCalendar,
              onIonChange: (e) => updateSetting("syncToCalendar", e.detail.checked),
              disabled: !settings.isConnected
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Sinhronizuj iz kalendara") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonToggle,
            {
              checked: settings.syncFromCalendar,
              onIonChange: (e) => updateSetting("syncFromCalendar", e.detail.checked),
              disabled: !settings.isConnected
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Blokiraj preklapaju훶e termine") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonToggle,
            {
              checked: settings.blockOverlappingSlots,
              onIonChange: (e) => updateSetting("blockOverlappingSlots", e.detail.checked),
              disabled: !settings.isConnected
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: t2("Dozvoli preklapanje uz odobrenje") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonToggle,
            {
              checked: settings.allowOverlappingWithApproval,
              onIonChange: (e) => updateSetting("allowOverlappingWithApproval", e.detail.checked),
              disabled: !settings.isConnected
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("Ove opcije vam omogu훶avaju da kontroli큄ete kako se va큄e rezervacije sinhronizuju sa Google Calendar.") }) }) }),
        settings.isConnected && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ion-padding", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "primary", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: t2("Nedavni doga휃aji iz Google Calendar") }) }),
          isEventsLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-text-center ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, {}) }),
          !isEventsLoading && ((_a2 = eventsResponse == null ? void 0 : eventsResponse.data) == null ? void 0 : _a2.length) === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(IonText, { color: "medium", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("Nema doga휃aja za prikaz") }) }),
          !isEventsLoading && (eventsResponse == null ? void 0 : eventsResponse.data) && eventsResponse.data.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: eventsResponse.data.map((e) => /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { lines: "full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: e.summary || t2("Bez naslova") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              new Date(e.startTimeUtc).toLocaleString(),
              " 넂 ",
              new Date(e.endTimeUtc).toLocaleString()
            ] }),
            e.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ion-color-medium", children: e.description }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ion-color-medium", children: e.isExternal ? t2("Eksterni doga휃aj") : t2("Rezervacija") })
          ] }) }, e.id)) })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonAlert,
      {
        isOpen: showAlert,
        onDidDismiss: () => setShowAlert(false),
        header: t2("Obave큄tenje"),
        message: alertMessage,
        buttons: [t2("OK")]
      }
    )
  ] });
}
const GoogleCalendarSettingsPageWrapper = () => {
  const googleApiKey = "528191814583-ovprc30ec231gtc7t24apkep4kqo7npo.apps.googleusercontent.com";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GoogleOAuthProvider$1, { clientId: googleApiKey, children: /* @__PURE__ */ jsxRuntimeExports.jsx(GoogleCalendarSettingsPage, {}) });
};
function Routes() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRouterOutlet, { id: "main", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "".concat(urlPrefix, "/t"), component: MainTabs }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/r/:reservationHash"),
        component: ConfirmReservationPageWrapper,
        exact: true
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Route,
      {
        path: "".concat(urlPrefix, "/zakazi-novo"),
        component: CreateAppointmentPage
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/public-profile/:clientId"),
        component: PublicProfilePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja"),
        component: SettingsPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/vesti"),
        component: NewsListPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/vesti/novo"),
        component: NewsCreatePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/vesti/edit/:id"),
        component: NewsEditPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/radno-vreme"),
        component: LocationWorkingTimePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/podaci"),
        component: LocationEditDataPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/generalno"),
        component: LocationSettingsPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/radnici"),
        component: LocationWorkersPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/radnici/novi"),
        component: LocationWorkerCreatePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/radnici/edit/:workerId"),
        component: LocationWorkerEditPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/usluge"),
        component: ServicesPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/usluge/groups/:serviceGroupId"),
        component: ServiceGroupEditPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/usluge/services/:serviceId"),
        component: ServiceEditPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/usluge/novo"),
        component: ServiceGroupCreatePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/usluge/services/novo/:groupId"),
        component: ServiceCreatePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/promo-kodovi"),
        component: LocationPromoCodesPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/promo-kodovi/novo"),
        component: LocationPromoCodeCreatePageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/promo-kodovi/edit/:promoCodeId"),
        component: LocationPromoCodeEditPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GuardedRoute$1,
      {
        path: "".concat(urlPrefix, "/podesavanja/google-calendar"),
        component: GoogleCalendarSettingsPageWrapper,
        exact: true,
        roles: [UserGroupCode.Admin, UserGroupCode.Owner, UserGroupCode.Worker]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", exact: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Redirect, { to: "".concat(urlPrefix, "/t") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "".concat(urlPrefix), exact: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Redirect, { to: "".concat(urlPrefix, "/t") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { component: PageNotFound, path: "/404" })
  ] });
}
const useRzrPingHandler = () => {
  const dispatch = useAppDispatch();
  const handleRzrChanges = reactExports.useCallback(
    (changes) => {
      Object.entries(changes).forEach(([type, change]) => {
        if (change.hasChanges) {
          switch (type) {
            case PingType.RESERVATIONS:
              console.log("invalidating reservations");
              dispatch(rzrApi.util.invalidateTags([TagType$1.RESERVATION]));
              break;
            case PingType.WORKERS:
              dispatch(rzrApi.util.invalidateTags([TagType$1.LOCATION_WORKERS]));
              break;
            case PingType.SERVICES:
              dispatch(rzrApi.util.invalidateTags([TagType$1.SERVICES]));
              break;
            case PingType.WORKING_HOURS:
              dispatch(
                rzrApi.util.invalidateTags([TagType$1.LOCATION_WORKING_HOURS])
              );
              break;
            case PingType.NOTIFICATIONS:
              dispatch(rzrApi.util.invalidateTags([TagType$1.USER_NOTIFICATIONS]));
              break;
          }
        }
      });
    },
    [dispatch]
  );
  return { handleRzrChanges };
};
function Ping() {
  const pingOptions = reactExports.useMemo(() => ({ autoStart: true }), []);
  const { handleRzrChanges } = useRzrPingHandler();
  usePing(
    [PingType.RESERVATIONS, PingType.NOTIFICATIONS],
    // , PingType.WORKERS, PingType.SERVICES, PingType.WORKING_HOURS
    { locationSlug: activeLocation },
    handleRzrChanges,
    pingOptions
  );
  return null;
}
const Ping$1 = reactExports.memo(Ping);
function UserLoginPageWrapper() {
  const { t: t2 } = useTranslation();
  const router = useIonRouter();
  const handleSuccessfulLogin = () => {
    router.push("".concat(urlPrefix, "/t"), "forward", "push");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonPage, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ion-padding text-center w-full flex justify-center items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-[100%] w-[600px] ", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ErrorBoundary$1,
    {
      fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center text-red-500", children: "Error loading login form" }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CommonLoginForm$1, { onSuccessfulLogin: handleSuccessfulLogin })
    }
  ) }) }) });
}
const Menu = reactExports.lazy(() => __vitePreload(() => import("./Menu-DG78Aput.js"), true ? __vite__mapDeps([45,1,2,3,4,5,6,7,8,9,46]) : void 0));
setupIonicReact({
  swipeBackEnabled: isPwa && !isIos,
  animated: !isIos
});
const urlPrefix = (_c = (_b = getInitialData("appSlug")) != null ? _b : "/zakazivanje") != null ? _c : "/zakazivanje";
const envActiveLocation = "berbernica-tanja";
const envIsPrivate = parseInt("1");
const preloadedLocationData = getInitialData(
  "locationData",
  true,
  true
);
const activeLocation = (_d = preloadedLocationData == null ? void 0 : preloadedLocationData.slug) != null ? _d : envActiveLocation;
const isPrivate = (_e = preloadedLocationData == null ? void 0 : preloadedLocationData.isPrivate) != null ? _e : envIsPrivate;
const reservationTimeInterval = (_f = preloadedLocationData == null ? void 0 : preloadedLocationData.timeSlotInterval) != null ? _f : 30;
const roundedSlotInterval = (_g = preloadedLocationData == null ? void 0 : preloadedLocationData.roundedSlotInterval) != null ? _g : 10;
const locationTimezone = (_i = (_h = preloadedLocationData == null ? void 0 : preloadedLocationData.settings) == null ? void 0 : _h.timezone) != null ? _i : "Europe/Belgrade";
setAppTimezone(locationTimezone);
function App() {
  const { isAdmin, isOwnerOrWorker } = useUser();
  const dispatch = useAppDispatch$1();
  reactExports.useEffect(() => {
    const theme = getSavedTheme();
    applyTheme(theme);
    const prefersDark = window.matchMedia("(prefers-color-scheme: dark)");
    const handleChange = () => {
      const currentTheme = getSavedTheme();
      applyTheme(currentTheme);
    };
    prefersDark.addEventListener("change", handleChange);
    return () => prefersDark.removeEventListener("change", handleChange);
  }, []);
  useAppFocus({
    onFocus: () => {
      var _a2;
      dispatch(
        (_a2 = rzrApi.util) == null ? void 0 : _a2.invalidateTags([
          TagType$1.USER_NOTIFICATIONS,
          { type: TagType$1.RESERVATION, id: TagId$1.LIST }
        ])
      );
    }
  });
  if (isPrivate && !isAdmin && !isOwnerOrWorker) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IonApp, { className: "select-none", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonReactRouter, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "".concat(urlPrefix, "/login"),
          component: UserLoginPageWrapper,
          exact: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "".concat(urlPrefix), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Redirect, { to: "".concat(urlPrefix, "/login") }) })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonApp, { className: "select-none", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("swiper-container", { hidden: true }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonReactRouter, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Suspense, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Ping$1, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CommonModalWrappers$1, {})
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CommonNotificationWrapper, { activeLocation }),
      !isWebView && isPwa && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonSplitPane, { contentId: "main", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Routes, {})
      ] })
    ] })
  ] });
}
const App$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  activeLocation,
  default: App,
  isPrivate,
  preloadedLocationData,
  reservationTimeInterval,
  roundedSlotInterval,
  urlPrefix
}, Symbol.toStringTag, { value: "Module" }));
export {
  useUpdateFeClientDataMutation as $,
  photosArrayWithIdYup as A,
  useGetFeLocationQuery as B,
  ConditionalComponent as C,
  DynamicForm as D,
  preloadedLocationData as E,
  FieldType as F,
  useGetAllWorkersQuery as G,
  useGetFeServiceCategoriesQuery as H,
  IonAlertConfirmation as I,
  useGetFeServiceGroupsQuery as J,
  useUpdateServiceMutation as K,
  LazyLoadImgStandard$1 as L,
  ModalActionButtons as M,
  ShowLoading$1 as N,
  useDefaultProps as O,
  convertEmptyStringToNull as P,
  generateSlugForValidation as Q,
  useUpdateServiceGroupMutation as R,
  SceletonLoader as S,
  useCreateServiceGroupMutation as T,
  UserAvatar as U,
  ServiceEditForm as V,
  useCreateWorkerMutation as W,
  WorkerForm as X,
  getSettingsOptions as Y,
  transformPaginationResponseToCamelCase as Z,
  useGetFeLocationClientReservationsQuery as _,
  useAppDispatch as a,
  useGetUserNotificationsQuery as a0,
  fromUtc as a1,
  toUtc as a2,
  getAppTimezone as a3,
  getUtcDateFormattedInTz as a4,
  useContentRefFunctions as a5,
  generateWeek as a6,
  useGetFeLocationReservationsQuery as a7,
  parseUtcDate as a8,
  isToday as a9,
  BookingCalendarHeader as aa,
  BookingWeekDays as ab,
  fetchIonIconsList as ac,
  App$1 as ad,
  useUser as b,
  useAppSelector as c,
  useRemoveConnectedDeviceMutation as d,
  isIos as e,
  urlPrefix as f,
  useGetOneFeReservationQuery as g,
  activeLocation as h,
  isPwa as i,
  fromUtcDateTimeToTime as j,
  getPathBySize as k,
  SwiperWrapper$1 as l,
  useFormWithSchema as m,
  useGetFeLocationClientsQuery as n,
  useGetFeClientDataQuery as o,
  preloadCoverImg as p,
  useQueryParamsHook as q,
  useUpdateFeReservationMutation as r,
  LayoutMainPage as s,
  isWebPlatform as t,
  useAppDispatch$1 as u,
  transformStandardResponseToCamelCase as v,
  fromUtcHM as w,
  useGetFeWorkersQuery as x,
  IonModalExtended$1 as y,
  useShowNotification as z
};
