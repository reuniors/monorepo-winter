var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { g as getDefaultExportFromCjs, a as getAugmentedNamespace } from "./vendor_ionic-ZVUk9kYn.js";
import { l as leafletSrcExports, t as t$1 } from "./vendor_leaflet-C9fBH8Uj.js";
function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  /**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var l2 = Symbol.for("react.element"), n2 = Symbol.for("react.portal"), p2 = Symbol.for("react.fragment"), q2 = Symbol.for("react.strict_mode"), r2 = Symbol.for("react.profiler"), t2 = Symbol.for("react.provider"), u2 = Symbol.for("react.context"), v2 = Symbol.for("react.forward_ref"), w2 = Symbol.for("react.suspense"), x2 = Symbol.for("react.memo"), y2 = Symbol.for("react.lazy"), z2 = Symbol.iterator;
  function A2(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = z2 && a2[z2] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var B = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, D2 = {};
  function E2(a2, b2, e2) {
    this.props = a2;
    this.context = b2;
    this.refs = D2;
    this.updater = e2 || B;
  }
  E2.prototype.isReactComponent = {};
  E2.prototype.setState = function(a2, b2) {
    if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a2, b2, "setState");
  };
  E2.prototype.forceUpdate = function(a2) {
    this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E2.prototype;
  function G2(a2, b2, e2) {
    this.props = a2;
    this.context = b2;
    this.refs = D2;
    this.updater = e2 || B;
  }
  var H2 = G2.prototype = new F();
  H2.constructor = G2;
  C(H2, E2.prototype);
  H2.isPureReactComponent = true;
  var I = Array.isArray, J2 = Object.prototype.hasOwnProperty, K2 = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
  function M2(a2, b2, e2) {
    var d2, c2 = {}, k2 = null, h2 = null;
    if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J2.call(b2, d2) && !L.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
    var g2 = arguments.length - 2;
    if (1 === g2) c2.children = e2;
    else if (1 < g2) {
      for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
      c2.children = f2;
    }
    if (a2 && a2.defaultProps) for (d2 in g2 = a2.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
    return { $$typeof: l2, type: a2, key: k2, ref: h2, props: c2, _owner: K2.current };
  }
  function N2(a2, b2) {
    return { $$typeof: l2, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
  }
  function O2(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === l2;
  }
  function escape2(a2) {
    var b2 = { "=": "=0", ":": "=2" };
    return "$" + a2.replace(/[=:]/g, function(a22) {
      return b2[a22];
    });
  }
  var P = /\/+/g;
  function Q(a2, b2) {
    return "object" === typeof a2 && null !== a2 && null != a2.key ? escape2("" + a2.key) : b2.toString(36);
  }
  function R(a2, b2, e2, d2, c2) {
    var k2 = typeof a2;
    if ("undefined" === k2 || "boolean" === k2) a2 = null;
    var h2 = false;
    if (null === a2) h2 = true;
    else switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l2:
          case n2:
            h2 = true;
        }
    }
    if (h2) return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q(h2, 0) : d2, I(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P, "$&/") + "/"), R(c2, b2, e2, "", function(a22) {
      return a22;
    })) : null != c2 && (O2(c2) && (c2 = N2(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P, "$&/") + "/") + a2)), b2.push(c2)), 1;
    h2 = 0;
    d2 = "" === d2 ? "." : d2 + ":";
    if (I(a2)) for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q(k2, g2);
      h2 += R(k2, b2, e2, f2, c2);
    }
    else if (f2 = A2(a2), "function" === typeof f2) for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; ) k2 = k2.value, f2 = d2 + Q(k2, g2++), h2 += R(k2, b2, e2, f2, c2);
    else if ("object" === k2) throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
    return h2;
  }
  function S2(a2, b2, e2) {
    if (null == a2) return a2;
    var d2 = [], c2 = 0;
    R(a2, d2, "", "", function(a22) {
      return b2.call(e2, a22, c2++);
    });
    return d2;
  }
  function T(a2) {
    if (-1 === a2._status) {
      var b2 = a2._result;
      b2 = b2();
      b2.then(function(b22) {
        if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b22;
      }, function(b22) {
        if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b22;
      });
      -1 === a2._status && (a2._status = 0, a2._result = b2);
    }
    if (1 === a2._status) return a2._result.default;
    throw a2._result;
  }
  var U2 = { current: null }, V2 = { transition: null }, W = { ReactCurrentDispatcher: U2, ReactCurrentBatchConfig: V2, ReactCurrentOwner: K2 };
  react_production_min.Children = { map: S2, forEach: function(a2, b2, e2) {
    S2(a2, function() {
      b2.apply(this, arguments);
    }, e2);
  }, count: function(a2) {
    var b2 = 0;
    S2(a2, function() {
      b2++;
    });
    return b2;
  }, toArray: function(a2) {
    return S2(a2, function(a22) {
      return a22;
    }) || [];
  }, only: function(a2) {
    if (!O2(a2)) throw Error("React.Children.only expected to receive a single React element child.");
    return a2;
  } };
  react_production_min.Component = E2;
  react_production_min.Fragment = p2;
  react_production_min.Profiler = r2;
  react_production_min.PureComponent = G2;
  react_production_min.StrictMode = q2;
  react_production_min.Suspense = w2;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  react_production_min.cloneElement = function(a2, b2, e2) {
    if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
    var d2 = C({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
    if (null != b2) {
      void 0 !== b2.ref && (k2 = b2.ref, h2 = K2.current);
      void 0 !== b2.key && (c2 = "" + b2.key);
      if (a2.type && a2.type.defaultProps) var g2 = a2.type.defaultProps;
      for (f2 in b2) J2.call(b2, f2) && !L.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
    }
    var f2 = arguments.length - 2;
    if (1 === f2) d2.children = e2;
    else if (1 < f2) {
      g2 = Array(f2);
      for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
      d2.children = g2;
    }
    return { $$typeof: l2, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
  };
  react_production_min.createContext = function(a2) {
    a2 = { $$typeof: u2, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a2.Provider = { $$typeof: t2, _context: a2 };
    return a2.Consumer = a2;
  };
  react_production_min.createElement = M2;
  react_production_min.createFactory = function(a2) {
    var b2 = M2.bind(null, a2);
    b2.type = a2;
    return b2;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a2) {
    return { $$typeof: v2, render: a2 };
  };
  react_production_min.isValidElement = O2;
  react_production_min.lazy = function(a2) {
    return { $$typeof: y2, _payload: { _status: -1, _result: a2 }, _init: T };
  };
  react_production_min.memo = function(a2, b2) {
    return { $$typeof: x2, type: a2, compare: void 0 === b2 ? null : b2 };
  };
  react_production_min.startTransition = function(a2) {
    var b2 = V2.transition;
    V2.transition = {};
    try {
      a2();
    } finally {
      V2.transition = b2;
    }
  };
  react_production_min.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  };
  react_production_min.useCallback = function(a2, b2) {
    return U2.current.useCallback(a2, b2);
  };
  react_production_min.useContext = function(a2) {
    return U2.current.useContext(a2);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a2) {
    return U2.current.useDeferredValue(a2);
  };
  react_production_min.useEffect = function(a2, b2) {
    return U2.current.useEffect(a2, b2);
  };
  react_production_min.useId = function() {
    return U2.current.useId();
  };
  react_production_min.useImperativeHandle = function(a2, b2, e2) {
    return U2.current.useImperativeHandle(a2, b2, e2);
  };
  react_production_min.useInsertionEffect = function(a2, b2) {
    return U2.current.useInsertionEffect(a2, b2);
  };
  react_production_min.useLayoutEffect = function(a2, b2) {
    return U2.current.useLayoutEffect(a2, b2);
  };
  react_production_min.useMemo = function(a2, b2) {
    return U2.current.useMemo(a2, b2);
  };
  react_production_min.useReducer = function(a2, b2, e2) {
    return U2.current.useReducer(a2, b2, e2);
  };
  react_production_min.useRef = function(a2) {
    return U2.current.useRef(a2);
  };
  react_production_min.useState = function(a2) {
    return U2.current.useState(a2);
  };
  react_production_min.useSyncExternalStore = function(a2, b2, e2) {
    return U2.current.useSyncExternalStore(a2, b2, e2);
  };
  react_production_min.useTransition = function() {
    return U2.current.useTransition();
  };
  react_production_min.version = "18.2.0";
  return react_production_min;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production_min();
  }
  return react.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f2 = requireReact(), k2 = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n2 = f2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
  function q2(c2, a2, g2) {
    var b2, d2 = {}, e2 = null, h2 = null;
    void 0 !== g2 && (e2 = "" + g2);
    void 0 !== a2.key && (e2 = "" + a2.key);
    void 0 !== a2.ref && (h2 = a2.ref);
    for (b2 in a2) m2.call(a2, b2) && !p2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
    if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
    return { $$typeof: k2, type: c2, key: e2, ref: h2, props: d2, _owner: n2.current };
  }
  reactJsxRuntime_production_min.Fragment = l2;
  reactJsxRuntime_production_min.jsx = q2;
  reactJsxRuntime_production_min.jsxs = q2;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports) {
    function f2(a2, b2) {
      var c2 = a2.length;
      a2.push(b2);
      a: for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2)) a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else break a;
      }
    }
    function h2(a2) {
      return 0 === a2.length ? null : a2[0];
    }
    function k2(a2) {
      if (0 === a2.length) return null;
      var b2 = a2[0], c2 = a2.pop();
      if (c2 !== b2) {
        a2[0] = c2;
        a: for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C, c2)) n2 < e2 && 0 > g2(x2, C) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2)) a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else break a;
        }
      }
      return b2;
    }
    function g2(a2, b2) {
      var c2 = a2.sortIndex - b2.sortIndex;
      return 0 !== c2 ? c2 : a2.id - b2.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l2 = performance;
      exports.unstable_now = function() {
        return l2.now();
      };
    } else {
      var p2 = Date, q2 = p2.now();
      exports.unstable_now = function() {
        return p2.now() - q2;
      };
    }
    var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G2(a2) {
      for (var b2 = h2(t2); null !== b2; ) {
        if (null === b2.callback) k2(t2);
        else if (b2.startTime <= a2) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
        else break;
        b2 = h2(t2);
      }
    }
    function H2(a2) {
      B = false;
      G2(a2);
      if (!A2) if (null !== h2(r2)) A2 = true, I(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
    }
    function J2(a2, b2) {
      A2 = false;
      B && (B = false, E2(L), L = -1);
      z2 = true;
      var c2 = y2;
      try {
        G2(b2);
        for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
          var d2 = v2.callback;
          if ("function" === typeof d2) {
            v2.callback = null;
            y2 = v2.priorityLevel;
            var e2 = d2(v2.expirationTime <= b2);
            b2 = exports.unstable_now();
            "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
            G2(b2);
          } else k2(r2);
          v2 = h2(r2);
        }
        if (null !== v2) var w2 = true;
        else {
          var m2 = h2(t2);
          null !== m2 && K2(H2, m2.startTime - b2);
          w2 = false;
        }
        return w2;
      } finally {
        v2 = null, y2 = c2, z2 = false;
      }
    }
    var N2 = false, O2 = null, L = -1, P = 5, Q = -1;
    function M2() {
      return exports.unstable_now() - Q < P ? false : true;
    }
    function R() {
      if (null !== O2) {
        var a2 = exports.unstable_now();
        Q = a2;
        var b2 = true;
        try {
          b2 = O2(true, a2);
        } finally {
          b2 ? S2() : (N2 = false, O2 = null);
        }
      } else N2 = false;
    }
    var S2;
    if ("function" === typeof F) S2 = function() {
      F(R);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T = new MessageChannel(), U2 = T.port2;
      T.port1.onmessage = R;
      S2 = function() {
        U2.postMessage(null);
      };
    } else S2 = function() {
      D2(R, 0);
    };
    function I(a2) {
      O2 = a2;
      N2 || (N2 = true, S2());
    }
    function K2(a2, b2) {
      L = D2(function() {
        a2(exports.unstable_now());
      }, b2);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a2) {
      a2.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A2 || z2 || (A2 = true, I(J2));
    };
    exports.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y2;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h2(r2);
    };
    exports.unstable_next = function(a2) {
      switch (y2) {
        case 1:
        case 2:
        case 3:
          var b2 = 3;
          break;
        default:
          b2 = y2;
      }
      var c2 = y2;
      y2 = b2;
      try {
        return a2();
      } finally {
        y2 = c2;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a2, b2) {
      switch (a2) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a2 = 3;
      }
      var c2 = y2;
      y2 = a2;
      try {
        return b2();
      } finally {
        y2 = c2;
      }
    };
    exports.unstable_scheduleCallback = function(a2, b2, c2) {
      var d2 = exports.unstable_now();
      "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
      switch (a2) {
        case 1:
          var e2 = -1;
          break;
        case 2:
          e2 = 250;
          break;
        case 5:
          e2 = 1073741823;
          break;
        case 4:
          e2 = 1e4;
          break;
        default:
          e2 = 5e3;
      }
      e2 = c2 + e2;
      a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
      c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B ? (E2(L), L = -1) : B = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I(J2)));
      return a2;
    };
    exports.unstable_shouldYield = M2;
    exports.unstable_wrapCallback = function(a2) {
      var b2 = y2;
      return function() {
        var c2 = y2;
        y2 = b2;
        try {
          return a2.apply(this, arguments);
        } finally {
          y2 = c2;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production_min();
  }
  return scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = requireReact(), ca = requireScheduler();
  function p2(a2) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a2, b2) {
    ha(a2, b2);
    ha(a2 + "Capture", b2);
  }
  function ha(a2, b2) {
    ea[a2] = b2;
    for (a2 = 0; a2 < b2.length; a2++) da.add(b2[a2]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a2) {
    if (ja.call(ma, a2)) return true;
    if (ja.call(la, a2)) return false;
    if (ka.test(a2)) return ma[a2] = true;
    la[a2] = true;
    return false;
  }
  function pa(a2, b2, c2, d2) {
    if (null !== c2 && 0 === c2.type) return false;
    switch (typeof b2) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d2) return false;
        if (null !== c2) return !c2.acceptsBooleans;
        a2 = a2.toLowerCase().slice(0, 5);
        return "data-" !== a2 && "aria-" !== a2;
      default:
        return false;
    }
  }
  function qa(a2, b2, c2, d2) {
    if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2)) return true;
    if (d2) return false;
    if (null !== c2) switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
    return false;
  }
  function v2(a2, b2, c2, d2, e2, f2, g2) {
    this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
    this.attributeName = d2;
    this.attributeNamespace = e2;
    this.mustUseProperty = c2;
    this.propertyName = a2;
    this.type = b2;
    this.sanitizeURL = f2;
    this.removeEmptyString = g2;
  }
  var z2 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
    z2[a2] = new v2(a2, 0, false, a2, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
    var b2 = a2[0];
    z2[b2] = new v2(b2, 1, false, a2[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
    z2[a2] = new v2(a2, 2, false, a2.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
    z2[a2] = new v2(a2, 2, false, a2, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
    z2[a2] = new v2(a2, 3, false, a2.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
    z2[a2] = new v2(a2, 3, true, a2, null, false, false);
  });
  ["capture", "download"].forEach(function(a2) {
    z2[a2] = new v2(a2, 4, false, a2, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a2) {
    z2[a2] = new v2(a2, 6, false, a2, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a2) {
    z2[a2] = new v2(a2, 5, false, a2.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a2) {
    return a2[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
    var b2 = a2.replace(
      ra,
      sa
    );
    z2[b2] = new v2(b2, 1, false, a2, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
    var b2 = a2.replace(ra, sa);
    z2[b2] = new v2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
    var b2 = a2.replace(ra, sa);
    z2[b2] = new v2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a2) {
    z2[a2] = new v2(a2, 1, false, a2.toLowerCase(), null, false, false);
  });
  z2.xlinkHref = new v2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a2) {
    z2[a2] = new v2(a2, 1, false, a2.toLowerCase(), null, true, true);
  });
  function ta(a2, b2, c2, d2) {
    var e2 = z2.hasOwnProperty(b2) ? z2[b2] : null;
    if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = Ja && a2[Ja] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var A2 = Object.assign, La;
  function Ma(a2) {
    if (void 0 === La) try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
    return "\n" + La + a2;
  }
  var Na = false;
  function Oa(a2, b2) {
    if (!a2 || Na) return "";
    Na = true;
    var c2 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b2) if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l2) {
          d2 = l2;
        }
        a2();
      }
    } catch (l2) {
      if (l2 && d2 && "string" === typeof l2.stack) {
        for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; ) h2--;
        for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c2;
    }
    return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
  }
  function Pa(a2) {
    switch (a2.tag) {
      case 5:
        return Ma(a2.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a2 = Oa(a2.type, false), a2;
      case 11:
        return a2 = Oa(a2.type.render, false), a2;
      case 1:
        return a2 = Oa(a2.type, true), a2;
      default:
        return "";
    }
  }
  function Qa(a2) {
    if (null == a2) return null;
    if ("function" === typeof a2) return a2.displayName || a2.name || null;
    if ("string" === typeof a2) return a2;
    switch (a2) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a2) switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
    return null;
  }
  function Ra(a2) {
    var b2 = a2.type;
    switch (a2.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b2.displayName || "Context") + ".Consumer";
      case 10:
        return (b2._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b2;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b2);
      case 8:
        return b2 === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b2) return b2.displayName || b2.name || null;
        if ("string" === typeof b2) return b2;
    }
    return null;
  }
  function Sa(a2) {
    switch (typeof a2) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a2;
      case "object":
        return a2;
      default:
        return "";
    }
  }
  function Ta(a2) {
    var b2 = a2.type;
    return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
  }
  function Ua(a2) {
    var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
    if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
      var e2 = c2.get, f2 = c2.set;
      Object.defineProperty(a2, b2, { configurable: true, get: function() {
        return e2.call(this);
      }, set: function(a3) {
        d2 = "" + a3;
        f2.call(this, a3);
      } });
      Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
      return { getValue: function() {
        return d2;
      }, setValue: function(a3) {
        d2 = "" + a3;
      }, stopTracking: function() {
        a2._valueTracker = null;
        delete a2[b2];
      } };
    }
  }
  function Va(a2) {
    a2._valueTracker || (a2._valueTracker = Ua(a2));
  }
  function Wa(a2) {
    if (!a2) return false;
    var b2 = a2._valueTracker;
    if (!b2) return true;
    var c2 = b2.getValue();
    var d2 = "";
    a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
    a2 = d2;
    return a2 !== c2 ? (b2.setValue(a2), true) : false;
  }
  function Xa(a2) {
    a2 = a2 || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a2) return null;
    try {
      return a2.activeElement || a2.body;
    } catch (b2) {
      return a2.body;
    }
  }
  function Ya(a2, b2) {
    var c2 = b2.checked;
    return A2({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
  }
  function Za(a2, b2) {
    var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
    c2 = Sa(null != b2.value ? b2.value : c2);
    a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
  }
  function ab(a2, b2) {
    b2 = b2.checked;
    null != b2 && ta(a2, "checked", b2, false);
  }
  function bb(a2, b2) {
    ab(a2, b2);
    var c2 = Sa(b2.value), d2 = b2.type;
    if (null != c2) if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
    } else a2.value !== "" + c2 && (a2.value = "" + c2);
    else if ("submit" === d2 || "reset" === d2) {
      a2.removeAttribute("value");
      return;
    }
    b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
    null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
  }
  function db(a2, b2, c2) {
    if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
      var d2 = b2.type;
      if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
      b2 = "" + a2._wrapperState.initialValue;
      c2 || b2 === a2.value || (a2.value = b2);
      a2.defaultValue = b2;
    }
    c2 = a2.name;
    "" !== c2 && (a2.name = "");
    a2.defaultChecked = !!a2._wrapperState.initialChecked;
    "" !== c2 && (a2.name = c2);
  }
  function cb(a2, b2, c2) {
    if ("number" !== b2 || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
  }
  var eb = Array.isArray;
  function fb(a2, b2, c2, d2) {
    a2 = a2.options;
    if (b2) {
      b2 = {};
      for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
      for (c2 = 0; c2 < a2.length; c2++) e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
    } else {
      c2 = "" + Sa(c2);
      b2 = null;
      for (e2 = 0; e2 < a2.length; e2++) {
        if (a2[e2].value === c2) {
          a2[e2].selected = true;
          d2 && (a2[e2].defaultSelected = true);
          return;
        }
        null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
      }
      null !== b2 && (b2.selected = true);
    }
  }
  function gb(a2, b2) {
    if (null != b2.dangerouslySetInnerHTML) throw Error(p2(91));
    return A2({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
  }
  function hb(a2, b2) {
    var c2 = b2.value;
    if (null == c2) {
      c2 = b2.children;
      b2 = b2.defaultValue;
      if (null != c2) {
        if (null != b2) throw Error(p2(92));
        if (eb(c2)) {
          if (1 < c2.length) throw Error(p2(93));
          c2 = c2[0];
        }
        b2 = c2;
      }
      null == b2 && (b2 = "");
      c2 = b2;
    }
    a2._wrapperState = { initialValue: Sa(c2) };
  }
  function ib(a2, b2) {
    var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
    null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
    null != d2 && (a2.defaultValue = "" + d2);
  }
  function jb(a2) {
    var b2 = a2.textContent;
    b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
  }
  function kb(a2) {
    switch (a2) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a2, b2) {
    return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
  }
  var mb, nb = (function(a2) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
      MSApp.execUnsafeLocalFunction(function() {
        return a2(b2, c2, d2, e2);
      });
    } : a2;
  })(function(a2, b2) {
    if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b2;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
      for (b2 = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
      for (; b2.firstChild; ) a2.appendChild(b2.firstChild);
    }
  });
  function ob(a2, b2) {
    if (b2) {
      var c2 = a2.firstChild;
      if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
        c2.nodeValue = b2;
        return;
      }
    }
    a2.textContent = b2;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a2) {
    qb.forEach(function(b2) {
      b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
      pb[b2] = pb[a2];
    });
  });
  function rb(a2, b2, c2) {
    return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
  }
  function sb(a2, b2) {
    a2 = a2.style;
    for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
  }
  var tb = A2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a2, b2) {
    if (b2) {
      if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p2(137, a2));
      if (null != b2.dangerouslySetInnerHTML) {
        if (null != b2.children) throw Error(p2(60));
        if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p2(61));
      }
      if (null != b2.style && "object" !== typeof b2.style) throw Error(p2(62));
    }
  }
  function vb(a2, b2) {
    if (-1 === a2.indexOf("-")) return "string" === typeof b2.is;
    switch (a2) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a2) {
    a2 = a2.target || a2.srcElement || window;
    a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
    return 3 === a2.nodeType ? a2.parentNode : a2;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a2) {
    if (a2 = Cb(a2)) {
      if ("function" !== typeof yb) throw Error(p2(280));
      var b2 = a2.stateNode;
      b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
    }
  }
  function Eb(a2) {
    zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
  }
  function Fb() {
    if (zb) {
      var a2 = zb, b2 = Ab;
      Ab = zb = null;
      Bb(a2);
      if (b2) for (a2 = 0; a2 < b2.length; a2++) Bb(b2[a2]);
    }
  }
  function Gb(a2, b2) {
    return a2(b2);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a2, b2, c2) {
    if (Ib) return a2(b2, c2);
    Ib = true;
    try {
      return Gb(a2, b2, c2);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a2, b2) {
    var c2 = a2.stateNode;
    if (null === c2) return null;
    var d2 = Db(c2);
    if (null === d2) return null;
    c2 = d2[b2];
    a: switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
    if (a2) return null;
    if (c2 && "function" !== typeof c2) throw Error(p2(231, b2, typeof c2));
    return c2;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
  function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    var l2 = Array.prototype.slice.call(arguments, 3);
    try {
      b2.apply(c2, l2);
    } catch (m2) {
      this.onError(m2);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
    Ob = true;
    Pb = a2;
  } };
  function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l2 = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p2(198));
      Qb || (Qb = true, Rb = l2);
    }
  }
  function Vb(a2) {
    var b2 = a2, c2 = a2;
    if (a2.alternate) for (; b2.return; ) b2 = b2.return;
    else {
      a2 = b2;
      do
        b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
      while (a2);
    }
    return 3 === b2.tag ? c2 : null;
  }
  function Wb(a2) {
    if (13 === a2.tag) {
      var b2 = a2.memoizedState;
      null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
      if (null !== b2) return b2.dehydrated;
    }
    return null;
  }
  function Xb(a2) {
    if (Vb(a2) !== a2) throw Error(p2(188));
  }
  function Yb(a2) {
    var b2 = a2.alternate;
    if (!b2) {
      b2 = Vb(a2);
      if (null === b2) throw Error(p2(188));
      return b2 !== a2 ? null : a2;
    }
    for (var c2 = a2, d2 = b2; ; ) {
      var e2 = c2.return;
      if (null === e2) break;
      var f2 = e2.alternate;
      if (null === f2) {
        d2 = e2.return;
        if (null !== d2) {
          c2 = d2;
          continue;
        }
        break;
      }
      if (e2.child === f2.child) {
        for (f2 = e2.child; f2; ) {
          if (f2 === c2) return Xb(e2), a2;
          if (f2 === d2) return Xb(e2), b2;
          f2 = f2.sibling;
        }
        throw Error(p2(188));
      }
      if (c2.return !== d2.return) c2 = e2, d2 = f2;
      else {
        for (var g2 = false, h2 = e2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = e2;
            d2 = f2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = e2;
            c2 = f2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) {
          for (h2 = f2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = f2;
              d2 = e2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = f2;
              c2 = e2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) throw Error(p2(189));
        }
      }
      if (c2.alternate !== d2) throw Error(p2(190));
    }
    if (3 !== c2.tag) throw Error(p2(188));
    return c2.stateNode.current === c2 ? a2 : b2;
  }
  function Zb(a2) {
    a2 = Yb(a2);
    return null !== a2 ? $b(a2) : null;
  }
  function $b(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2;
    for (a2 = a2.child; null !== a2; ) {
      var b2 = $b(a2);
      if (null !== b2) return b2;
      a2 = a2.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a2) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a2) {
    a2 >>>= 0;
    return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a2) {
    switch (a2 & -a2) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a2 & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a2 & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a2;
    }
  }
  function uc(a2, b2) {
    var c2 = a2.pendingLanes;
    if (0 === c2) return 0;
    var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
    if (0 !== g2) {
      var h2 = g2 & ~e2;
      0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
    } else g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
    if (0 === d2) return 0;
    if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240))) return b2;
    0 !== (d2 & 4) && (d2 |= c2 & 16);
    b2 = a2.entangledLanes;
    if (0 !== b2) for (a2 = a2.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
    return d2;
  }
  function vc(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 4:
        return b2 + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b2 + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a2, b2) {
    for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
      var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
      if (-1 === k2) {
        if (0 === (h2 & c2) || 0 !== (h2 & d2)) e2[g2] = vc(h2, b2);
      } else k2 <= b2 && (a2.expiredLanes |= h2);
      f2 &= ~h2;
    }
  }
  function xc(a2) {
    a2 = a2.pendingLanes & -1073741825;
    return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a2 = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a2;
  }
  function zc(a2) {
    for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a2);
    return b2;
  }
  function Ac(a2, b2, c2) {
    a2.pendingLanes |= b2;
    536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
    a2 = a2.eventTimes;
    b2 = 31 - oc(b2);
    a2[b2] = c2;
  }
  function Bc(a2, b2) {
    var c2 = a2.pendingLanes & ~b2;
    a2.pendingLanes = b2;
    a2.suspendedLanes = 0;
    a2.pingedLanes = 0;
    a2.expiredLanes &= b2;
    a2.mutableReadLanes &= b2;
    a2.entangledLanes &= b2;
    b2 = a2.entanglements;
    var d2 = a2.eventTimes;
    for (a2 = a2.expirationTimes; 0 < c2; ) {
      var e2 = 31 - oc(c2), f2 = 1 << e2;
      b2[e2] = 0;
      d2[e2] = -1;
      a2[e2] = -1;
      c2 &= ~f2;
    }
  }
  function Cc(a2, b2) {
    var c2 = a2.entangledLanes |= b2;
    for (a2 = a2.entanglements; c2; ) {
      var d2 = 31 - oc(c2), e2 = 1 << d2;
      e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
      c2 &= ~e2;
    }
  }
  var C = 0;
  function Dc(a2) {
    a2 &= -a2;
    return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a2, b2) {
    switch (a2) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b2.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b2.pointerId);
    }
  }
  function Tc(a2, b2, c2, d2, e2, f2) {
    if (null === a2 || a2.nativeEvent !== f2) return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
    a2.eventSystemFlags |= d2;
    b2 = a2.targetContainers;
    null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
    return a2;
  }
  function Uc(a2, b2, c2, d2, e2) {
    switch (b2) {
      case "focusin":
        return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
      case "dragenter":
        return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
      case "mouseover":
        return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
      case "pointerover":
        var f2 = e2.pointerId;
        Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
        return true;
      case "gotpointercapture":
        return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
    }
    return false;
  }
  function Vc(a2) {
    var b2 = Wc(a2.target);
    if (null !== b2) {
      var c2 = Vb(b2);
      if (null !== c2) {
        if (b2 = c2.tag, 13 === b2) {
          if (b2 = Wb(c2), null !== b2) {
            a2.blockedOn = b2;
            Ic(a2.priority, function() {
              Gc(c2);
            });
            return;
          }
        } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
          a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a2.blockedOn = null;
  }
  function Xc(a2) {
    if (null !== a2.blockedOn) return false;
    for (var b2 = a2.targetContainers; 0 < b2.length; ) {
      var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
      if (null === c2) {
        c2 = a2.nativeEvent;
        var d2 = new c2.constructor(c2.type, c2);
        wb = d2;
        c2.target.dispatchEvent(d2);
        wb = null;
      } else return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
      b2.shift();
    }
    return true;
  }
  function Zc(a2, b2, c2) {
    Xc(a2) && c2.delete(b2);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a2, b2) {
    a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a2) {
    function b2(b3) {
      return ad(b3, a2);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a2);
      for (var c2 = 1; c2 < Kc.length; c2++) {
        var d2 = Kc[c2];
        d2.blockedOn === a2 && (d2.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a2);
    null !== Mc && ad(Mc, a2);
    null !== Nc && ad(Nc, a2);
    Oc.forEach(b2);
    Pc.forEach(b2);
    for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
    for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a2, b2, c2, d2) {
    var e2 = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a2, b2, c2, d2);
    } finally {
      C = e2, cd.transition = f2;
    }
  }
  function gd(a2, b2, c2, d2) {
    var e2 = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a2, b2, c2, d2);
    } finally {
      C = e2, cd.transition = f2;
    }
  }
  function fd(a2, b2, c2, d2) {
    if (dd) {
      var e2 = Yc(a2, b2, c2, d2);
      if (null === e2) hd(a2, b2, d2, id, c2), Sc(a2, d2);
      else if (Uc(e2, a2, b2, c2, d2)) d2.stopPropagation();
      else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
        for (; null !== e2; ) {
          var f2 = Cb(e2);
          null !== f2 && Ec(f2);
          f2 = Yc(a2, b2, c2, d2);
          null === f2 && hd(a2, b2, d2, id, c2);
          if (f2 === e2) break;
          e2 = f2;
        }
        null !== e2 && d2.stopPropagation();
      } else hd(a2, b2, d2, null, c2);
    }
  }
  var id = null;
  function Yc(a2, b2, c2, d2) {
    id = null;
    a2 = xb(d2);
    a2 = Wc(a2);
    if (null !== a2) if (b2 = Vb(a2), null === b2) a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2) return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else b2 !== a2 && (a2 = null);
    id = a2;
    return null;
  }
  function jd(a2) {
    switch (a2) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
    for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++) ;
    var g2 = c2 - a2;
    for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++) ;
    return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
  }
  function od(a2) {
    var b2 = a2.keyCode;
    "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
    10 === a2 && (a2 = 13);
    return 32 <= a2 || 13 === a2 ? a2 : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a2) {
    function b2(b3, d2, e2, f2, g2) {
      this._reactName = b3;
      this._targetInst = e2;
      this.type = d2;
      this.nativeEvent = f2;
      this.target = g2;
      this.currentTarget = null;
      for (var c2 in a2) a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
      this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A2(b2.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a3 = this.nativeEvent;
      a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a3 = this.nativeEvent;
      a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b2;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
    return a2.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A2({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
    return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
  }, movementX: function(a2) {
    if ("movementX" in a2) return a2.movementX;
    a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
    return wd;
  }, movementY: function(a2) {
    return "movementY" in a2 ? a2.movementY : xd;
  } }), Bd = rd(Ad), Cd = A2({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A2({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A2({}, sd, { clipboardData: function(a2) {
    return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A2({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a2) {
    var b2 = this.nativeEvent;
    return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A2({}, ud, { key: function(a2) {
    if (a2.key) {
      var b2 = Md[a2.key] || a2.key;
      if ("Unidentified" !== b2) return b2;
    }
    return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
    return "keypress" === a2.type ? od(a2) : 0;
  }, keyCode: function(a2) {
    return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  }, which: function(a2) {
    return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A2({}, Ad, {
    deltaX: function(a2) {
      return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
    },
    deltaY: function(a2) {
      return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae2 = ia && "CompositionEvent" in window, be2 = null;
  ia && "documentMode" in document && (be2 = document.documentMode);
  var ce2 = ia && "TextEvent" in window && !be2, de = ia && (!ae2 || be2 && 8 < be2 && 11 >= be2), ee2 = String.fromCharCode(32), fe = false;
  function ge2(a2, b2) {
    switch (a2) {
      case "keyup":
        return -1 !== $d.indexOf(b2.keyCode);
      case "keydown":
        return 229 !== b2.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he2(a2) {
    a2 = a2.detail;
    return "object" === typeof a2 && "data" in a2 ? a2.data : null;
  }
  var ie2 = false;
  function je2(a2, b2) {
    switch (a2) {
      case "compositionend":
        return he2(b2);
      case "keypress":
        if (32 !== b2.which) return null;
        fe = true;
        return ee2;
      case "textInput":
        return a2 = b2.data, a2 === ee2 && fe ? null : a2;
      default:
        return null;
    }
  }
  function ke2(a2, b2) {
    if (ie2) return "compositionend" === a2 || !ae2 && ge2(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie2 = false, a2) : null;
    switch (a2) {
      case "paste":
        return null;
      case "keypress":
        if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
          if (b2.char && 1 < b2.char.length) return b2.char;
          if (b2.which) return String.fromCharCode(b2.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b2.locale ? null : b2.data;
      default:
        return null;
    }
  }
  var le2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a2) {
    var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return "input" === b2 ? !!le2[a2.type] : "textarea" === b2 ? true : false;
  }
  function ne2(a2, b2, c2, d2) {
    Eb(d2);
    b2 = oe2(b2, "onChange");
    0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
  }
  var pe2 = null, qe2 = null;
  function re2(a2) {
    se2(a2, 0);
  }
  function te2(a2) {
    var b2 = ue2(a2);
    if (Wa(b2)) return a2;
  }
  function ve2(a2, b2) {
    if ("change" === a2) return b2;
  }
  var we2 = false;
  if (ia) {
    var xe2;
    if (ia) {
      var ye2 = "oninput" in document;
      if (!ye2) {
        var ze2 = document.createElement("div");
        ze2.setAttribute("oninput", "return;");
        ye2 = "function" === typeof ze2.oninput;
      }
      xe2 = ye2;
    } else xe2 = false;
    we2 = xe2 && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae2() {
    pe2 && (pe2.detachEvent("onpropertychange", Be2), qe2 = pe2 = null);
  }
  function Be2(a2) {
    if ("value" === a2.propertyName && te2(qe2)) {
      var b2 = [];
      ne2(b2, qe2, a2, xb(a2));
      Jb(re2, b2);
    }
  }
  function Ce2(a2, b2, c2) {
    "focusin" === a2 ? (Ae2(), pe2 = b2, qe2 = c2, pe2.attachEvent("onpropertychange", Be2)) : "focusout" === a2 && Ae2();
  }
  function De2(a2) {
    if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te2(qe2);
  }
  function Ee2(a2, b2) {
    if ("click" === a2) return te2(b2);
  }
  function Fe2(a2, b2) {
    if ("input" === a2 || "change" === a2) return te2(b2);
  }
  function Ge2(a2, b2) {
    return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge2;
  function Ie2(a2, b2) {
    if (He(a2, b2)) return true;
    if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2) return false;
    var c2 = Object.keys(a2), d2 = Object.keys(b2);
    if (c2.length !== d2.length) return false;
    for (d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      if (!ja.call(b2, e2) || !He(a2[e2], b2[e2])) return false;
    }
    return true;
  }
  function Je2(a2) {
    for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
    return a2;
  }
  function Ke2(a2, b2) {
    var c2 = Je2(a2);
    a2 = 0;
    for (var d2; c2; ) {
      if (3 === c2.nodeType) {
        d2 = a2 + c2.textContent.length;
        if (a2 <= b2 && d2 >= b2) return { node: c2, offset: b2 - a2 };
        a2 = d2;
      }
      a: {
        for (; c2; ) {
          if (c2.nextSibling) {
            c2 = c2.nextSibling;
            break a;
          }
          c2 = c2.parentNode;
        }
        c2 = void 0;
      }
      c2 = Je2(c2);
    }
  }
  function Le2(a2, b2) {
    return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le2(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
  }
  function Me2() {
    for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
      try {
        var c2 = "string" === typeof b2.contentWindow.location.href;
      } catch (d2) {
        c2 = false;
      }
      if (c2) a2 = b2.contentWindow;
      else break;
      b2 = Xa(a2.document);
    }
    return b2;
  }
  function Ne2(a2) {
    var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
  }
  function Oe2(a2) {
    var b2 = Me2(), c2 = a2.focusedElem, d2 = a2.selectionRange;
    if (b2 !== c2 && c2 && c2.ownerDocument && Le2(c2.ownerDocument.documentElement, c2)) {
      if (null !== d2 && Ne2(c2)) {
        if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
        else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
          a2 = a2.getSelection();
          var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
          d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
          !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
          e2 = Ke2(c2, f2);
          var g2 = Ke2(
            c2,
            d2
          );
          e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
        }
      }
      b2 = [];
      for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
      "function" === typeof c2.focus && c2.focus();
      for (c2 = 0; c2 < b2.length; c2++) a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
    }
  }
  var Pe2 = ia && "documentMode" in document && 11 >= document.documentMode, Qe2 = null, Re2 = null, Se2 = null, Te2 = false;
  function Ue2(a2, b2, c2) {
    var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
    Te2 || null == Qe2 || Qe2 !== Xa(d2) || (d2 = Qe2, "selectionStart" in d2 && Ne2(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se2 && Ie2(Se2, d2) || (Se2 = d2, d2 = oe2(Re2, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe2)));
  }
  function Ve2(a2, b2) {
    var c2 = {};
    c2[a2.toLowerCase()] = b2.toLowerCase();
    c2["Webkit" + a2] = "webkit" + b2;
    c2["Moz" + a2] = "moz" + b2;
    return c2;
  }
  var We2 = { animationend: Ve2("Animation", "AnimationEnd"), animationiteration: Ve2("Animation", "AnimationIteration"), animationstart: Ve2("Animation", "AnimationStart"), transitionend: Ve2("Transition", "TransitionEnd") }, Xe2 = {}, Ye2 = {};
  ia && (Ye2 = document.createElement("div").style, "AnimationEvent" in window || (delete We2.animationend.animation, delete We2.animationiteration.animation, delete We2.animationstart.animation), "TransitionEvent" in window || delete We2.transitionend.transition);
  function Ze2(a2) {
    if (Xe2[a2]) return Xe2[a2];
    if (!We2[a2]) return a2;
    var b2 = We2[a2], c2;
    for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye2) return Xe2[a2] = b2[c2];
    return a2;
  }
  var $e2 = Ze2("animationend"), af = Ze2("animationiteration"), bf = Ze2("animationstart"), cf = Ze2("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a2, b2) {
    df.set(a2, b2);
    fa(b2, [a2]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e2, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a2, b2, c2) {
    var d2 = a2.type || "unknown-event";
    a2.currentTarget = c2;
    Ub(d2, b2, void 0, a2);
    a2.currentTarget = null;
  }
  function se2(a2, b2) {
    b2 = 0 !== (b2 & 4);
    for (var c2 = 0; c2 < a2.length; c2++) {
      var d2 = a2[c2], e2 = d2.event;
      d2 = d2.listeners;
      a: {
        var f2 = void 0;
        if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped()) break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
        else for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped()) break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      }
    }
    if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
  }
  function D2(a2, b2) {
    var c2 = b2[of];
    void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
    var d2 = a2 + "__bubble";
    c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
  }
  function qf(a2, b2, c2) {
    var d2 = 0;
    b2 && (d2 |= 4);
    pf(c2, a2, d2, b2);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a2) {
    if (!a2[rf]) {
      a2[rf] = true;
      da.forEach(function(b3) {
        "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
      });
      var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
      null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
    }
  }
  function pf(a2, b2, c2, d2) {
    switch (jd(b2)) {
      case 1:
        var e2 = ed;
        break;
      case 4:
        e2 = gd;
        break;
      default:
        e2 = fd;
    }
    c2 = e2.bind(null, b2, c2, a2);
    e2 = void 0;
    !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
    d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
  }
  function hd(a2, b2, c2, d2, e2) {
    var f2 = d2;
    if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
      if (null === d2) return;
      var g2 = d2.tag;
      if (3 === g2 || 4 === g2) {
        var h2 = d2.stateNode.containerInfo;
        if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
        if (4 === g2) for (g2 = d2.return; null !== g2; ) {
          var k2 = g2.tag;
          if (3 === k2 || 4 === k2) {
            if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
          }
          g2 = g2.return;
        }
        for (; null !== h2; ) {
          g2 = Wc(h2);
          if (null === g2) return;
          k2 = g2.tag;
          if (5 === k2 || 6 === k2) {
            d2 = f2 = g2;
            continue a;
          }
          h2 = h2.parentNode;
        }
      }
      d2 = d2.return;
    }
    Jb(function() {
      var d3 = f2, e3 = xb(c2), g3 = [];
      a: {
        var h3 = df.get(a2);
        if (void 0 !== h3) {
          var k3 = td, n2 = a2;
          switch (a2) {
            case "keypress":
              if (0 === od(c2)) break a;
            case "keydown":
            case "keyup":
              k3 = Rd;
              break;
            case "focusin":
              n2 = "focus";
              k3 = Fd;
              break;
            case "focusout":
              n2 = "blur";
              k3 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd;
              break;
            case "click":
              if (2 === c2.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd;
              break;
            case $e2:
            case af:
            case bf:
              k3 = Hd;
              break;
            case cf:
              k3 = Xd;
              break;
            case "scroll":
              k3 = vd;
              break;
            case "wheel":
              k3 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td;
          }
          var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
          t2 = [];
          for (var w2 = d3, u2; null !== w2; ) {
            u2 = w2;
            var F = u2.stateNode;
            5 === u2.tag && null !== F && (u2 = F, null !== x2 && (F = Kb(w2, x2), null != F && t2.push(tf(w2, F, u2))));
            if (J2) break;
            w2 = w2.return;
          }
          0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
        }
      }
      if (0 === (b2 & 7)) {
        a: {
          h3 = "mouseover" === a2 || "pointerover" === a2;
          k3 = "mouseout" === a2 || "pointerout" === a2;
          if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
          if (k3 || h3) {
            h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
            if (k3) {
              if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
            } else k3 = null, n2 = d3;
            if (k3 !== n2) {
              t2 = Bd;
              F = "onMouseLeave";
              x2 = "onMouseEnter";
              w2 = "mouse";
              if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
              J2 = null == k3 ? h3 : ue2(k3);
              u2 = null == n2 ? h3 : ue2(n2);
              h3 = new t2(F, w2 + "leave", k3, c2, e3);
              h3.target = J2;
              h3.relatedTarget = u2;
              F = null;
              Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F = t2);
              J2 = F;
              if (k3 && n2) b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2)) w2++;
                u2 = 0;
                for (F = x2; F; F = vf(F)) u2++;
                for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
              else t2 = null;
              null !== k3 && wf(g3, h3, k3, t2, false);
              null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
            }
          }
        }
        a: {
          h3 = d3 ? ue2(d3) : window;
          k3 = h3.nodeName && h3.nodeName.toLowerCase();
          if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve2;
          else if (me(h3)) if (we2) na = Fe2;
          else {
            na = De2;
            var xa = Ce2;
          }
          else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee2);
          if (na && (na = na(a2, d3))) {
            ne2(g3, na, c2, e3);
            break a;
          }
          xa && xa(a2, h3, d3);
          "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
        }
        xa = d3 ? ue2(d3) : window;
        switch (a2) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe2 = xa, Re2 = d3, Se2 = null;
            break;
          case "focusout":
            Se2 = Re2 = Qe2 = null;
            break;
          case "mousedown":
            Te2 = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te2 = false;
            Ue2(g3, c2, e3);
            break;
          case "selectionchange":
            if (Pe2) break;
          case "keydown":
          case "keyup":
            Ue2(g3, c2, e3);
        }
        var $a;
        if (ae2) b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie2 ? ge2(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c2.locale && (ie2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie2 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie2 = true)), xa = oe2(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he2(c2), null !== $a && (ba.data = $a))));
        if ($a = ce2 ? je2(a2, c2) : ke2(a2, c2)) d3 = oe2(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
      }
      se2(g3, b2);
    });
  }
  function tf(a2, b2, c2) {
    return { instance: a2, listener: b2, currentTarget: c2 };
  }
  function oe2(a2, b2) {
    for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
      var e2 = a2, f2 = e2.stateNode;
      5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
      a2 = a2.return;
    }
    return d2;
  }
  function vf(a2) {
    if (null === a2) return null;
    do
      a2 = a2.return;
    while (a2 && 5 !== a2.tag);
    return a2 ? a2 : null;
  }
  function wf(a2, b2, c2, d2, e2) {
    for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
      var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
      if (null !== k2 && k2 === d2) break;
      5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
      c2 = c2.return;
    }
    0 !== g2.length && a2.push({ event: b2, listeners: g2 });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a2) {
    return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
  }
  function Af(a2, b2, c2) {
    b2 = zf(b2);
    if (zf(a2) !== b2 && c2) throw Error(p2(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a2, b2) {
    return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
    return Hf.resolve(null).then(a2).catch(If);
  } : Ff;
  function If(a2) {
    setTimeout(function() {
      throw a2;
    });
  }
  function Kf(a2, b2) {
    var c2 = b2, d2 = 0;
    do {
      var e2 = c2.nextSibling;
      a2.removeChild(c2);
      if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
      c2 = e2;
    } while (c2);
    bd(b2);
  }
  function Lf(a2) {
    for (; null != a2; a2 = a2.nextSibling) {
      var b2 = a2.nodeType;
      if (1 === b2 || 3 === b2) break;
      if (8 === b2) {
        b2 = a2.data;
        if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
        if ("/$" === b2) return null;
      }
    }
    return a2;
  }
  function Mf(a2) {
    a2 = a2.previousSibling;
    for (var b2 = 0; a2; ) {
      if (8 === a2.nodeType) {
        var c2 = a2.data;
        if ("$" === c2 || "$!" === c2 || "$?" === c2) {
          if (0 === b2) return a2;
          b2--;
        } else "/$" === c2 && b2++;
      }
      a2 = a2.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a2) {
    var b2 = a2[Of];
    if (b2) return b2;
    for (var c2 = a2.parentNode; c2; ) {
      if (b2 = c2[uf] || c2[Of]) {
        c2 = b2.alternate;
        if (null !== b2.child || null !== c2 && null !== c2.child) for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of]) return c2;
          a2 = Mf(a2);
        }
        return b2;
      }
      a2 = c2;
      c2 = a2.parentNode;
    }
    return null;
  }
  function Cb(a2) {
    a2 = a2[Of] || a2[uf];
    return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
  }
  function ue2(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
    throw Error(p2(33));
  }
  function Db(a2) {
    return a2[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a2) {
    return { current: a2 };
  }
  function E2(a2) {
    0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G2(a2, b2) {
    Tf++;
    Sf[Tf] = a2.current;
    a2.current = b2;
  }
  var Vf = {}, H2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a2, b2) {
    var c2 = a2.type.contextTypes;
    if (!c2) return Vf;
    var d2 = a2.stateNode;
    if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
    var e2 = {}, f2;
    for (f2 in c2) e2[f2] = b2[f2];
    d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
    return e2;
  }
  function Zf(a2) {
    a2 = a2.childContextTypes;
    return null !== a2 && void 0 !== a2;
  }
  function $f() {
    E2(Wf);
    E2(H2);
  }
  function ag(a2, b2, c2) {
    if (H2.current !== Vf) throw Error(p2(168));
    G2(H2, b2);
    G2(Wf, c2);
  }
  function bg(a2, b2, c2) {
    var d2 = a2.stateNode;
    b2 = b2.childContextTypes;
    if ("function" !== typeof d2.getChildContext) return c2;
    d2 = d2.getChildContext();
    for (var e2 in d2) if (!(e2 in b2)) throw Error(p2(108, Ra(a2) || "Unknown", e2));
    return A2({}, c2, d2);
  }
  function cg(a2) {
    a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H2.current;
    G2(H2, a2);
    G2(Wf, Wf.current);
    return true;
  }
  function dg(a2, b2, c2) {
    var d2 = a2.stateNode;
    if (!d2) throw Error(p2(169));
    c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E2(Wf), E2(H2), G2(H2, a2)) : E2(Wf);
    G2(Wf, c2);
  }
  var eg = null, fg = false, gg = false;
  function hg(a2) {
    null === eg ? eg = [a2] : eg.push(a2);
  }
  function ig(a2) {
    fg = true;
    hg(a2);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a2 = 0, b2 = C;
      try {
        var c2 = eg;
        for (C = 1; a2 < c2.length; a2++) {
          var d2 = c2[a2];
          do
            d2 = d2(true);
          while (null !== d2);
        }
        eg = null;
        fg = false;
      } catch (e2) {
        throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
      } finally {
        C = b2, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a2, b2) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a2;
    ng = b2;
  }
  function ug(a2, b2, c2) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a2;
    var d2 = rg;
    a2 = sg;
    var e2 = 32 - oc(d2) - 1;
    d2 &= ~(1 << e2);
    c2 += 1;
    var f2 = 32 - oc(b2) + e2;
    if (30 < f2) {
      var g2 = e2 - e2 % 5;
      f2 = (d2 & (1 << g2) - 1).toString(32);
      d2 >>= g2;
      e2 -= g2;
      rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
      sg = f2 + a2;
    } else rg = 1 << f2 | c2 << e2 | d2, sg = a2;
  }
  function vg(a2) {
    null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
  }
  function wg(a2) {
    for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a2, b2) {
    var c2 = Bg(5, null, null, 0);
    c2.elementType = "DELETED";
    c2.stateNode = b2;
    c2.return = a2;
    b2 = a2.deletions;
    null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
  }
  function Cg(a2, b2) {
    switch (a2.tag) {
      case 5:
        var c2 = a2.type;
        b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
        return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
      case 6:
        return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
      case 13:
        return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a2) {
    return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
  }
  function Eg(a2) {
    if (I) {
      var b2 = yg;
      if (b2) {
        var c2 = b2;
        if (!Cg(a2, b2)) {
          if (Dg(a2)) throw Error(p2(418));
          b2 = Lf(c2.nextSibling);
          var d2 = xg;
          b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
        }
      } else {
        if (Dg(a2)) throw Error(p2(418));
        a2.flags = a2.flags & -4097 | 2;
        I = false;
        xg = a2;
      }
    }
  }
  function Fg(a2) {
    for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
    xg = a2;
  }
  function Gg(a2) {
    if (a2 !== xg) return false;
    if (!I) return Fg(a2), I = true, false;
    var b2;
    (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
    if (b2 && (b2 = yg)) {
      if (Dg(a2)) throw Hg(), Error(p2(418));
      for (; b2; ) Ag(a2, b2), b2 = Lf(b2.nextSibling);
    }
    Fg(a2);
    if (13 === a2.tag) {
      a2 = a2.memoizedState;
      a2 = null !== a2 ? a2.dehydrated : null;
      if (!a2) throw Error(p2(317));
      a: {
        a2 = a2.nextSibling;
        for (b2 = 0; a2; ) {
          if (8 === a2.nodeType) {
            var c2 = a2.data;
            if ("/$" === c2) {
              if (0 === b2) {
                yg = Lf(a2.nextSibling);
                break a;
              }
              b2--;
            } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
          }
          a2 = a2.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a2) {
    null === zg ? zg = [a2] : zg.push(a2);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a2, b2) {
    if (a2 && a2.defaultProps) {
      b2 = A2({}, b2);
      a2 = a2.defaultProps;
      for (var c2 in a2) void 0 === b2[c2] && (b2[c2] = a2[c2]);
      return b2;
    }
    return b2;
  }
  var Mg = Uf(null), Ng = null, Og = null, Pg = null;
  function Qg() {
    Pg = Og = Ng = null;
  }
  function Rg(a2) {
    var b2 = Mg.current;
    E2(Mg);
    a2._currentValue = b2;
  }
  function Sg(a2, b2, c2) {
    for (; null !== a2; ) {
      var d2 = a2.alternate;
      (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
      if (a2 === c2) break;
      a2 = a2.return;
    }
  }
  function Tg(a2, b2) {
    Ng = a2;
    Pg = Og = null;
    a2 = a2.dependencies;
    null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
  }
  function Vg(a2) {
    var b2 = a2._currentValue;
    if (Pg !== a2) if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng) throw Error(p2(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else Og = Og.next = a2;
    return b2;
  }
  var Wg = null;
  function Xg(a2) {
    null === Wg ? Wg = [a2] : Wg.push(a2);
  }
  function Yg(a2, b2, c2, d2) {
    var e2 = b2.interleaved;
    null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
    b2.interleaved = c2;
    return Zg(a2, d2);
  }
  function Zg(a2, b2) {
    a2.lanes |= b2;
    var c2 = a2.alternate;
    null !== c2 && (c2.lanes |= b2);
    c2 = a2;
    for (a2 = a2.return; null !== a2; ) a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
    return 3 === c2.tag ? c2.stateNode : null;
  }
  var $g = false;
  function ah(a2) {
    a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function bh(a2, b2) {
    a2 = a2.updateQueue;
    b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
  }
  function ch(a2, b2) {
    return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
  }
  function dh(a2, b2, c2) {
    var d2 = a2.updateQueue;
    if (null === d2) return null;
    d2 = d2.shared;
    if (0 !== (K2 & 2)) {
      var e2 = d2.pending;
      null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
      d2.pending = b2;
      return Zg(a2, c2);
    }
    e2 = d2.interleaved;
    null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
    d2.interleaved = b2;
    return Zg(a2, c2);
  }
  function eh(a2, b2, c2) {
    b2 = b2.updateQueue;
    if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
      var d2 = b2.lanes;
      d2 &= a2.pendingLanes;
      c2 |= d2;
      b2.lanes = c2;
      Cc(a2, c2);
    }
  }
  function fh(a2, b2) {
    var c2 = a2.updateQueue, d2 = a2.alternate;
    if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
      var e2 = null, f2 = null;
      c2 = c2.firstBaseUpdate;
      if (null !== c2) {
        do {
          var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
          null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
          c2 = c2.next;
        } while (null !== c2);
        null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
      } else e2 = f2 = b2;
      c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
      a2.updateQueue = c2;
      return;
    }
    a2 = c2.lastBaseUpdate;
    null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
    c2.lastBaseUpdate = b2;
  }
  function gh(a2, b2, c2, d2) {
    var e2 = a2.updateQueue;
    $g = false;
    var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
    if (null !== h2) {
      e2.shared.pending = null;
      var k2 = h2, l2 = k2.next;
      k2.next = null;
      null === g2 ? f2 = l2 : g2.next = l2;
      g2 = k2;
      var m2 = a2.alternate;
      null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
    }
    if (null !== f2) {
      var q2 = e2.baseState;
      g2 = 0;
      m2 = l2 = k2 = null;
      h2 = f2;
      do {
        var r2 = h2.lane, y2 = h2.eventTime;
        if ((d2 & r2) === r2) {
          null !== m2 && (m2 = m2.next = {
            eventTime: y2,
            lane: 0,
            tag: h2.tag,
            payload: h2.payload,
            callback: h2.callback,
            next: null
          });
          a: {
            var n2 = a2, t2 = h2;
            r2 = b2;
            y2 = c2;
            switch (t2.tag) {
              case 1:
                n2 = t2.payload;
                if ("function" === typeof n2) {
                  q2 = n2.call(y2, q2, r2);
                  break a;
                }
                q2 = n2;
                break a;
              case 3:
                n2.flags = n2.flags & -65537 | 128;
              case 0:
                n2 = t2.payload;
                r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                if (null === r2 || void 0 === r2) break a;
                q2 = A2({}, q2, r2);
                break a;
              case 2:
                $g = true;
            }
          }
          null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
        } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
        h2 = h2.next;
        if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
        else r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
      } while (1);
      null === m2 && (k2 = q2);
      e2.baseState = k2;
      e2.firstBaseUpdate = l2;
      e2.lastBaseUpdate = m2;
      b2 = e2.shared.interleaved;
      if (null !== b2) {
        e2 = b2;
        do
          g2 |= e2.lane, e2 = e2.next;
        while (e2 !== b2);
      } else null === f2 && (e2.shared.lanes = 0);
      hh |= g2;
      a2.lanes = g2;
      a2.memoizedState = q2;
    }
  }
  function ih(a2, b2, c2) {
    a2 = b2.effects;
    b2.effects = null;
    if (null !== a2) for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2) throw Error(p2(191, e2));
        e2.call(d2);
      }
    }
  }
  var jh = new aa.Component().refs;
  function kh(a2, b2, c2, d2) {
    b2 = a2.memoizedState;
    c2 = c2(d2, b2);
    c2 = null === c2 || void 0 === c2 ? b2 : A2({}, b2, c2);
    a2.memoizedState = c2;
    0 === a2.lanes && (a2.updateQueue.baseState = c2);
  }
  var nh = { isMounted: function(a2) {
    return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
  }, enqueueSetState: function(a2, b2, c2) {
    a2 = a2._reactInternals;
    var d2 = L(), e2 = lh(a2), f2 = ch(d2, e2);
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = dh(a2, f2, e2);
    null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
  }, enqueueReplaceState: function(a2, b2, c2) {
    a2 = a2._reactInternals;
    var d2 = L(), e2 = lh(a2), f2 = ch(d2, e2);
    f2.tag = 1;
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = dh(a2, f2, e2);
    null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
  }, enqueueForceUpdate: function(a2, b2) {
    a2 = a2._reactInternals;
    var c2 = L(), d2 = lh(a2), e2 = ch(c2, d2);
    e2.tag = 2;
    void 0 !== b2 && null !== b2 && (e2.callback = b2);
    b2 = dh(a2, e2, d2);
    null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
  } };
  function oh(a2, b2, c2, d2, e2, f2, g2) {
    a2 = a2.stateNode;
    return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie2(c2, d2) || !Ie2(e2, f2) : true;
  }
  function ph(a2, b2, c2) {
    var d2 = false, e2 = Vf;
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H2.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
    b2 = new b2(c2, f2);
    a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
    b2.updater = nh;
    a2.stateNode = b2;
    b2._reactInternals = a2;
    d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
    return b2;
  }
  function qh(a2, b2, c2, d2) {
    a2 = b2.state;
    "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
    "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
    b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
  }
  function rh(a2, b2, c2, d2) {
    var e2 = a2.stateNode;
    e2.props = c2;
    e2.state = a2.memoizedState;
    e2.refs = jh;
    ah(a2);
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H2.current, e2.context = Yf(a2, f2));
    e2.state = a2.memoizedState;
    f2 = b2.getDerivedStateFromProps;
    "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
    "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
    "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
  }
  function sh(a2, b2, c2) {
    a2 = c2.ref;
    if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
      if (c2._owner) {
        c2 = c2._owner;
        if (c2) {
          if (1 !== c2.tag) throw Error(p2(309));
          var d2 = c2.stateNode;
        }
        if (!d2) throw Error(p2(147, a2));
        var e2 = d2, f2 = "" + a2;
        if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
        b2 = function(a3) {
          var b3 = e2.refs;
          b3 === jh && (b3 = e2.refs = {});
          null === a3 ? delete b3[f2] : b3[f2] = a3;
        };
        b2._stringRef = f2;
        return b2;
      }
      if ("string" !== typeof a2) throw Error(p2(284));
      if (!c2._owner) throw Error(p2(290, a2));
    }
    return a2;
  }
  function th(a2, b2) {
    a2 = Object.prototype.toString.call(b2);
    throw Error(p2(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
  }
  function uh(a2) {
    var b2 = a2._init;
    return b2(a2._payload);
  }
  function vh(a2) {
    function b2(b3, c3) {
      if (a2) {
        var d3 = b3.deletions;
        null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
      }
    }
    function c2(c3, d3) {
      if (!a2) return null;
      for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
      return null;
    }
    function d2(a3, b3) {
      for (a3 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
      return a3;
    }
    function e2(a3, b3) {
      a3 = wh(a3, b3);
      a3.index = 0;
      a3.sibling = null;
      return a3;
    }
    function f2(b3, c3, d3) {
      b3.index = d3;
      if (!a2) return b3.flags |= 1048576, c3;
      d3 = b3.alternate;
      if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
      b3.flags |= 2;
      return c3;
    }
    function g2(b3) {
      a2 && null === b3.alternate && (b3.flags |= 2);
      return b3;
    }
    function h2(a3, b3, c3, d3) {
      if (null === b3 || 6 !== b3.tag) return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
      b3 = e2(b3, c3);
      b3.return = a3;
      return b3;
    }
    function k2(a3, b3, c3, d3) {
      var f3 = c3.type;
      if (f3 === ya) return m2(a3, b3, c3.props.children, d3, c3.key);
      if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type)) return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
      d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
      d3.ref = sh(a3, b3, c3);
      d3.return = a3;
      return d3;
    }
    function l2(a3, b3, c3, d3) {
      if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
      b3 = e2(b3, c3.children || []);
      b3.return = a3;
      return b3;
    }
    function m2(a3, b3, c3, d3, f3) {
      if (null === b3 || 7 !== b3.tag) return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
      b3 = e2(b3, c3);
      b3.return = a3;
      return b3;
    }
    function q2(a3, b3, c3) {
      if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
      if ("object" === typeof b3 && null !== b3) {
        switch (b3.$$typeof) {
          case va:
            return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
          case wa:
            return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
          case Ha:
            var d3 = b3._init;
            return q2(a3, d3(b3._payload), c3);
        }
        if (eb(b3) || Ka(b3)) return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
        th(a3, b3);
      }
      return null;
    }
    function r2(a3, b3, c3, d3) {
      var e3 = null !== b3 ? b3.key : null;
      if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
      if ("object" === typeof c3 && null !== c3) {
        switch (c3.$$typeof) {
          case va:
            return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
          case wa:
            return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
          case Ha:
            return e3 = c3._init, r2(
              a3,
              b3,
              e3(c3._payload),
              d3
            );
        }
        if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a3, b3, c3, d3, null);
        th(a3, c3);
      }
      return null;
    }
    function y2(a3, b3, c3, d3, e3) {
      if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
      if ("object" === typeof d3 && null !== d3) {
        switch (d3.$$typeof) {
          case va:
            return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
          case wa:
            return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
          case Ha:
            var f3 = d3._init;
            return y2(a3, b3, c3, f3(d3._payload), e3);
        }
        if (eb(d3) || Ka(d3)) return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
        th(b3, d3);
      }
      return null;
    }
    function n2(e3, g3, h3, k3) {
      for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
        u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
        var n3 = r2(e3, u2, h3[w2], k3);
        if (null === n3) {
          null === u2 && (u2 = x2);
          break;
        }
        a2 && u2 && null === n3.alternate && b2(e3, u2);
        g3 = f2(n3, g3, w2);
        null === m3 ? l3 = n3 : m3.sibling = n3;
        m3 = n3;
        u2 = x2;
      }
      if (w2 === h3.length) return c2(e3, u2), I && tg(e3, w2), l3;
      if (null === u2) {
        for (; w2 < h3.length; w2++) u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
        I && tg(e3, w2);
        return l3;
      }
      for (u2 = d2(e3, u2); w2 < h3.length; w2++) x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
      a2 && u2.forEach(function(a3) {
        return b2(e3, a3);
      });
      I && tg(e3, w2);
      return l3;
    }
    function t2(e3, g3, h3, k3) {
      var l3 = Ka(h3);
      if ("function" !== typeof l3) throw Error(p2(150));
      h3 = l3.call(h3);
      if (null == h3) throw Error(p2(151));
      for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
        m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
        var t3 = r2(e3, m3, n3.value, k3);
        if (null === t3) {
          null === m3 && (m3 = x2);
          break;
        }
        a2 && m3 && null === t3.alternate && b2(e3, m3);
        g3 = f2(t3, g3, w2);
        null === u2 ? l3 = t3 : u2.sibling = t3;
        u2 = t3;
        m3 = x2;
      }
      if (n3.done) return c2(
        e3,
        m3
      ), I && tg(e3, w2), l3;
      if (null === m3) {
        for (; !n3.done; w2++, n3 = h3.next()) n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        I && tg(e3, w2);
        return l3;
      }
      for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      a2 && m3.forEach(function(a3) {
        return b2(e3, a3);
      });
      I && tg(e3, w2);
      return l3;
    }
    function J2(a3, d3, f3, h3) {
      "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
      if ("object" === typeof f3 && null !== f3) {
        switch (f3.$$typeof) {
          case va:
            a: {
              for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                if (l3.key === k3) {
                  k3 = f3.type;
                  if (k3 === ya) {
                    if (7 === l3.tag) {
                      c2(a3, l3.sibling);
                      d3 = e2(l3, f3.props.children);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                  } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props);
                    d3.ref = sh(a3, l3, f3);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                  c2(a3, l3);
                  break;
                } else b2(a3, l3);
                l3 = l3.sibling;
              }
              f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
            }
            return g2(a3);
          case wa:
            a: {
              for (l3 = f3.key; null !== d3; ) {
                if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
                else b2(a3, d3);
                d3 = d3.sibling;
              }
              d3 = zh(f3, a3.mode, h3);
              d3.return = a3;
              a3 = d3;
            }
            return g2(a3);
          case Ha:
            return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
        }
        if (eb(f3)) return n2(a3, d3, f3, h3);
        if (Ka(f3)) return t2(a3, d3, f3, h3);
        th(a3, f3);
      }
      return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
    }
    return J2;
  }
  var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
  function Hh(a2) {
    if (a2 === Dh) throw Error(p2(174));
    return a2;
  }
  function Ih(a2, b2) {
    G2(Gh, b2);
    G2(Fh, a2);
    G2(Eh, Dh);
    a2 = b2.nodeType;
    switch (a2) {
      case 9:
      case 11:
        b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
        break;
      default:
        a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
    }
    E2(Eh);
    G2(Eh, b2);
  }
  function Jh() {
    E2(Eh);
    E2(Fh);
    E2(Gh);
  }
  function Kh(a2) {
    Hh(Gh.current);
    var b2 = Hh(Eh.current);
    var c2 = lb(b2, a2.type);
    b2 !== c2 && (G2(Fh, a2), G2(Eh, c2));
  }
  function Lh(a2) {
    Fh.current === a2 && (E2(Eh), E2(Fh));
  }
  var M2 = Uf(0);
  function Mh(a2) {
    for (var b2 = a2; null !== b2; ) {
      if (13 === b2.tag) {
        var c2 = b2.memoizedState;
        if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
      } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
        if (0 !== (b2.flags & 128)) return b2;
      } else if (null !== b2.child) {
        b2.child.return = b2;
        b2 = b2.child;
        continue;
      }
      if (b2 === a2) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2) return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
    return null;
  }
  var Nh = [];
  function Oh() {
    for (var a2 = 0; a2 < Nh.length; a2++) Nh[a2]._workInProgressVersionPrimary = null;
    Nh.length = 0;
  }
  var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N2 = null, O2 = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
  function Q() {
    throw Error(p2(321));
  }
  function Wh(a2, b2) {
    if (null === b2) return false;
    for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++) if (!He(a2[c2], b2[c2])) return false;
    return true;
  }
  function Xh(a2, b2, c2, d2, e2, f2) {
    Rh = f2;
    N2 = b2;
    b2.memoizedState = null;
    b2.updateQueue = null;
    b2.lanes = 0;
    Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
    a2 = c2(d2, e2);
    if (Th) {
      f2 = 0;
      do {
        Th = false;
        Uh = 0;
        if (25 <= f2) throw Error(p2(301));
        f2 += 1;
        P = O2 = null;
        b2.updateQueue = null;
        Ph.current = $h;
        a2 = c2(d2, e2);
      } while (Th);
    }
    Ph.current = ai;
    b2 = null !== O2 && null !== O2.next;
    Rh = 0;
    P = O2 = N2 = null;
    Sh = false;
    if (b2) throw Error(p2(300));
    return a2;
  }
  function bi() {
    var a2 = 0 !== Uh;
    Uh = 0;
    return a2;
  }
  function ci() {
    var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === P ? N2.memoizedState = P = a2 : P = P.next = a2;
    return P;
  }
  function di() {
    if (null === O2) {
      var a2 = N2.alternate;
      a2 = null !== a2 ? a2.memoizedState : null;
    } else a2 = O2.next;
    var b2 = null === P ? N2.memoizedState : P.next;
    if (null !== b2) P = b2, O2 = a2;
    else {
      if (null === a2) throw Error(p2(310));
      O2 = a2;
      a2 = { memoizedState: O2.memoizedState, baseState: O2.baseState, baseQueue: O2.baseQueue, queue: O2.queue, next: null };
      null === P ? N2.memoizedState = P = a2 : P = P.next = a2;
    }
    return P;
  }
  function ei(a2, b2) {
    return "function" === typeof b2 ? b2(a2) : b2;
  }
  function fi(a2) {
    var b2 = di(), c2 = b2.queue;
    if (null === c2) throw Error(p2(311));
    c2.lastRenderedReducer = a2;
    var d2 = O2, e2 = d2.baseQueue, f2 = c2.pending;
    if (null !== f2) {
      if (null !== e2) {
        var g2 = e2.next;
        e2.next = f2.next;
        f2.next = g2;
      }
      d2.baseQueue = e2 = f2;
      c2.pending = null;
    }
    if (null !== e2) {
      f2 = e2.next;
      d2 = d2.baseState;
      var h2 = g2 = null, k2 = null, l2 = f2;
      do {
        var m2 = l2.lane;
        if ((Rh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
        else {
          var q2 = {
            lane: m2,
            action: l2.action,
            hasEagerState: l2.hasEagerState,
            eagerState: l2.eagerState,
            next: null
          };
          null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
          N2.lanes |= m2;
          hh |= m2;
        }
        l2 = l2.next;
      } while (null !== l2 && l2 !== f2);
      null === k2 ? g2 = d2 : k2.next = h2;
      He(d2, b2.memoizedState) || (Ug = true);
      b2.memoizedState = d2;
      b2.baseState = g2;
      b2.baseQueue = k2;
      c2.lastRenderedState = d2;
    }
    a2 = c2.interleaved;
    if (null !== a2) {
      e2 = a2;
      do
        f2 = e2.lane, N2.lanes |= f2, hh |= f2, e2 = e2.next;
      while (e2 !== a2);
    } else null === e2 && (c2.lanes = 0);
    return [b2.memoizedState, c2.dispatch];
  }
  function gi(a2) {
    var b2 = di(), c2 = b2.queue;
    if (null === c2) throw Error(p2(311));
    c2.lastRenderedReducer = a2;
    var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
    if (null !== e2) {
      c2.pending = null;
      var g2 = e2 = e2.next;
      do
        f2 = a2(f2, g2.action), g2 = g2.next;
      while (g2 !== e2);
      He(f2, b2.memoizedState) || (Ug = true);
      b2.memoizedState = f2;
      null === b2.baseQueue && (b2.baseState = f2);
      c2.lastRenderedState = f2;
    }
    return [f2, d2];
  }
  function hi() {
  }
  function ii(a2, b2) {
    var c2 = N2, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
    f2 && (d2.memoizedState = e2, Ug = true);
    d2 = d2.queue;
    ji(ki.bind(null, c2, d2, a2), [a2]);
    if (d2.getSnapshot !== b2 || f2 || null !== P && P.memoizedState.tag & 1) {
      c2.flags |= 2048;
      li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
      if (null === R) throw Error(p2(349));
      0 !== (Rh & 30) || ni(c2, b2, e2);
    }
    return e2;
  }
  function ni(a2, b2, c2) {
    a2.flags |= 16384;
    a2 = { getSnapshot: b2, value: c2 };
    b2 = N2.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, N2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
  }
  function mi(a2, b2, c2, d2) {
    b2.value = c2;
    b2.getSnapshot = d2;
    oi(b2) && pi(a2);
  }
  function ki(a2, b2, c2) {
    return c2(function() {
      oi(b2) && pi(a2);
    });
  }
  function oi(a2) {
    var b2 = a2.getSnapshot;
    a2 = a2.value;
    try {
      var c2 = b2();
      return !He(a2, c2);
    } catch (d2) {
      return true;
    }
  }
  function pi(a2) {
    var b2 = Zg(a2, 1);
    null !== b2 && mh(b2, a2, 1, -1);
  }
  function qi(a2) {
    var b2 = ci();
    "function" === typeof a2 && (a2 = a2());
    b2.memoizedState = b2.baseState = a2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
    b2.queue = a2;
    a2 = a2.dispatch = ri.bind(null, N2, a2);
    return [b2.memoizedState, a2];
  }
  function li(a2, b2, c2, d2) {
    a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
    b2 = N2.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, N2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
    return a2;
  }
  function si() {
    return di().memoizedState;
  }
  function ti(a2, b2, c2, d2) {
    var e2 = ci();
    N2.flags |= a2;
    e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
  }
  function ui(a2, b2, c2, d2) {
    var e2 = di();
    d2 = void 0 === d2 ? null : d2;
    var f2 = void 0;
    if (null !== O2) {
      var g2 = O2.memoizedState;
      f2 = g2.destroy;
      if (null !== d2 && Wh(d2, g2.deps)) {
        e2.memoizedState = li(b2, c2, f2, d2);
        return;
      }
    }
    N2.flags |= a2;
    e2.memoizedState = li(1 | b2, c2, f2, d2);
  }
  function vi(a2, b2) {
    return ti(8390656, 8, a2, b2);
  }
  function ji(a2, b2) {
    return ui(2048, 8, a2, b2);
  }
  function wi(a2, b2) {
    return ui(4, 2, a2, b2);
  }
  function xi(a2, b2) {
    return ui(4, 4, a2, b2);
  }
  function yi(a2, b2) {
    if ("function" === typeof b2) return a2 = a2(), b2(a2), function() {
      b2(null);
    };
    if (null !== b2 && void 0 !== b2) return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
  }
  function zi(a2, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return ui(4, 4, yi.bind(null, b2, a2), c2);
  }
  function Ai() {
  }
  function Bi(a2, b2) {
    var c2 = di();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Wh(b2, d2[1])) return d2[0];
    c2.memoizedState = [a2, b2];
    return a2;
  }
  function Ci(a2, b2) {
    var c2 = di();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Wh(b2, d2[1])) return d2[0];
    a2 = a2();
    c2.memoizedState = [a2, b2];
    return a2;
  }
  function Di(a2, b2, c2) {
    if (0 === (Rh & 21)) return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
    He(c2, b2) || (c2 = yc(), N2.lanes |= c2, hh |= c2, a2.baseState = true);
    return b2;
  }
  function Ei(a2, b2) {
    var c2 = C;
    C = 0 !== c2 && 4 > c2 ? c2 : 4;
    a2(true);
    var d2 = Qh.transition;
    Qh.transition = {};
    try {
      a2(false), b2();
    } finally {
      C = c2, Qh.transition = d2;
    }
  }
  function Fi() {
    return di().memoizedState;
  }
  function Gi(a2, b2, c2) {
    var d2 = lh(a2);
    c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (Hi(a2)) Ii(b2, c2);
    else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
      var e2 = L();
      mh(c2, a2, d2, e2);
      Ji(c2, b2, d2);
    }
  }
  function ri(a2, b2, c2) {
    var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (Hi(a2)) Ii(b2, e2);
    else {
      var f2 = a2.alternate;
      if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
      c2 = Yg(a2, b2, e2, d2);
      null !== c2 && (e2 = L(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
    }
  }
  function Hi(a2) {
    var b2 = a2.alternate;
    return a2 === N2 || null !== b2 && b2 === N2;
  }
  function Ii(a2, b2) {
    Th = Sh = true;
    var c2 = a2.pending;
    null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
    a2.pending = b2;
  }
  function Ji(a2, b2, c2) {
    if (0 !== (c2 & 4194240)) {
      var d2 = b2.lanes;
      d2 &= a2.pendingLanes;
      c2 |= d2;
      b2.lanes = c2;
      Cc(a2, c2);
    }
  }
  var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
    ci().memoizedState = [a2, void 0 === b2 ? null : b2];
    return a2;
  }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return ti(
      4194308,
      4,
      yi.bind(null, b2, a2),
      c2
    );
  }, useLayoutEffect: function(a2, b2) {
    return ti(4194308, 4, a2, b2);
  }, useInsertionEffect: function(a2, b2) {
    return ti(4, 2, a2, b2);
  }, useMemo: function(a2, b2) {
    var c2 = ci();
    b2 = void 0 === b2 ? null : b2;
    a2 = a2();
    c2.memoizedState = [a2, b2];
    return a2;
  }, useReducer: function(a2, b2, c2) {
    var d2 = ci();
    b2 = void 0 !== c2 ? c2(b2) : b2;
    d2.memoizedState = d2.baseState = b2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
    d2.queue = a2;
    a2 = a2.dispatch = Gi.bind(null, N2, a2);
    return [d2.memoizedState, a2];
  }, useRef: function(a2) {
    var b2 = ci();
    a2 = { current: a2 };
    return b2.memoizedState = a2;
  }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
    return ci().memoizedState = a2;
  }, useTransition: function() {
    var a2 = qi(false), b2 = a2[0];
    a2 = Ei.bind(null, a2[1]);
    ci().memoizedState = a2;
    return [b2, a2];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a2, b2, c2) {
    var d2 = N2, e2 = ci();
    if (I) {
      if (void 0 === c2) throw Error(p2(407));
      c2 = c2();
    } else {
      c2 = b2();
      if (null === R) throw Error(p2(349));
      0 !== (Rh & 30) || ni(d2, b2, c2);
    }
    e2.memoizedState = c2;
    var f2 = { value: c2, getSnapshot: b2 };
    e2.queue = f2;
    vi(ki.bind(
      null,
      d2,
      f2,
      a2
    ), [a2]);
    d2.flags |= 2048;
    li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
    return c2;
  }, useId: function() {
    var a2 = ci(), b2 = R.identifierPrefix;
    if (I) {
      var c2 = sg;
      var d2 = rg;
      c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
      b2 = ":" + b2 + "R" + c2;
      c2 = Uh++;
      0 < c2 && (b2 += "H" + c2.toString(32));
      b2 += ":";
    } else c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
    return a2.memoizedState = b2;
  }, unstable_isNewReconciler: false }, Zh = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: fi,
    useRef: si,
    useState: function() {
      return fi(ei);
    },
    useDebugValue: Ai,
    useDeferredValue: function(a2) {
      var b2 = di();
      return Di(b2, O2.memoizedState, a2);
    },
    useTransition: function() {
      var a2 = fi(ei)[0], b2 = di().memoizedState;
      return [a2, b2];
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: false
  }, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
    return gi(ei);
  }, useDebugValue: Ai, useDeferredValue: function(a2) {
    var b2 = di();
    return null === O2 ? b2.memoizedState = a2 : Di(b2, O2.memoizedState, a2);
  }, useTransition: function() {
    var a2 = gi(ei)[0], b2 = di().memoizedState;
    return [a2, b2];
  }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
  function Ki(a2, b2) {
    try {
      var c2 = "", d2 = b2;
      do
        c2 += Pa(d2), d2 = d2.return;
      while (d2);
      var e2 = c2;
    } catch (f2) {
      e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
    }
    return { value: a2, source: b2, stack: e2, digest: null };
  }
  function Li(a2, b2, c2) {
    return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
  }
  function Mi(a2, b2) {
    try {
      console.error(b2.value);
    } catch (c2) {
      setTimeout(function() {
        throw c2;
      });
    }
  }
  var Ni = "function" === typeof WeakMap ? WeakMap : Map;
  function Oi(a2, b2, c2) {
    c2 = ch(-1, c2);
    c2.tag = 3;
    c2.payload = { element: null };
    var d2 = b2.value;
    c2.callback = function() {
      Pi || (Pi = true, Qi = d2);
      Mi(a2, b2);
    };
    return c2;
  }
  function Ri(a2, b2, c2) {
    c2 = ch(-1, c2);
    c2.tag = 3;
    var d2 = a2.type.getDerivedStateFromError;
    if ("function" === typeof d2) {
      var e2 = b2.value;
      c2.payload = function() {
        return d2(e2);
      };
      c2.callback = function() {
        Mi(a2, b2);
      };
    }
    var f2 = a2.stateNode;
    null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
      Mi(a2, b2);
      "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
      var c3 = b2.stack;
      this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
    });
    return c2;
  }
  function Ti(a2, b2, c2) {
    var d2 = a2.pingCache;
    if (null === d2) {
      d2 = a2.pingCache = new Ni();
      var e2 = /* @__PURE__ */ new Set();
      d2.set(b2, e2);
    } else e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
    e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
  }
  function Vi(a2) {
    do {
      var b2;
      if (b2 = 13 === a2.tag) b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
      if (b2) return a2;
      a2 = a2.return;
    } while (null !== a2);
    return null;
  }
  function Wi(a2, b2, c2, d2, e2) {
    if (0 === (a2.mode & 1)) return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
    a2.flags |= 65536;
    a2.lanes = e2;
    return a2;
  }
  var Xi = ua.ReactCurrentOwner, Ug = false;
  function Yi(a2, b2, c2, d2) {
    b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
  }
  function Zi(a2, b2, c2, d2, e2) {
    c2 = c2.render;
    var f2 = b2.ref;
    Tg(b2, e2);
    d2 = Xh(a2, b2, c2, d2, f2, e2);
    c2 = bi();
    if (null !== a2 && !Ug) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
    I && c2 && vg(b2);
    b2.flags |= 1;
    Yi(a2, b2, d2, e2);
    return b2.child;
  }
  function aj(a2, b2, c2, d2, e2) {
    if (null === a2) {
      var f2 = c2.type;
      if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
      a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
      a2.ref = b2.ref;
      a2.return = b2;
      return b2.child = a2;
    }
    f2 = a2.child;
    if (0 === (a2.lanes & e2)) {
      var g2 = f2.memoizedProps;
      c2 = c2.compare;
      c2 = null !== c2 ? c2 : Ie2;
      if (c2(g2, d2) && a2.ref === b2.ref) return $i(a2, b2, e2);
    }
    b2.flags |= 1;
    a2 = wh(f2, d2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  function cj(a2, b2, c2, d2, e2) {
    if (null !== a2) {
      var f2 = a2.memoizedProps;
      if (Ie2(f2, d2) && a2.ref === b2.ref) if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2)) 0 !== (a2.flags & 131072) && (Ug = true);
      else return b2.lanes = a2.lanes, $i(a2, b2, e2);
    }
    return dj(a2, b2, c2, d2, e2);
  }
  function ej(a2, b2, c2) {
    var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
    if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G2(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824)) return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G2(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G2(fj, gj);
      gj |= d2;
    }
    else null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G2(fj, gj), gj |= d2;
    Yi(a2, b2, e2, c2);
    return b2.child;
  }
  function hj(a2, b2) {
    var c2 = b2.ref;
    if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
  }
  function dj(a2, b2, c2, d2, e2) {
    var f2 = Zf(c2) ? Xf : H2.current;
    f2 = Yf(b2, f2);
    Tg(b2, e2);
    c2 = Xh(a2, b2, c2, d2, f2, e2);
    d2 = bi();
    if (null !== a2 && !Ug) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
    I && d2 && vg(b2);
    b2.flags |= 1;
    Yi(a2, b2, c2, e2);
    return b2.child;
  }
  function ij(a2, b2, c2, d2, e2) {
    if (Zf(c2)) {
      var f2 = true;
      cg(b2);
    } else f2 = false;
    Tg(b2, e2);
    if (null === b2.stateNode) jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
    else if (null === a2) {
      var g2 = b2.stateNode, h2 = b2.memoizedProps;
      g2.props = h2;
      var k2 = g2.context, l2 = c2.contextType;
      "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H2.current, l2 = Yf(b2, l2));
      var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
      q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
      $g = false;
      var r2 = b2.memoizedState;
      g2.state = r2;
      gh(b2, d2, g2, e2);
      k2 = b2.memoizedState;
      h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
    } else {
      g2 = b2.stateNode;
      bh(a2, b2);
      h2 = b2.memoizedProps;
      l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
      g2.props = l2;
      q2 = b2.pendingProps;
      r2 = g2.context;
      k2 = c2.contextType;
      "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H2.current, k2 = Yf(b2, k2));
      var y2 = c2.getDerivedStateFromProps;
      (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
      $g = false;
      r2 = b2.memoizedState;
      g2.state = r2;
      gh(b2, d2, g2, e2);
      var n2 = b2.memoizedState;
      h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
    }
    return kj(a2, b2, c2, d2, f2, e2);
  }
  function kj(a2, b2, c2, d2, e2, f2) {
    hj(a2, b2);
    var g2 = 0 !== (b2.flags & 128);
    if (!d2 && !g2) return e2 && dg(b2, c2, false), $i(a2, b2, f2);
    d2 = b2.stateNode;
    Xi.current = b2;
    var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
    b2.flags |= 1;
    null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
    b2.memoizedState = d2.state;
    e2 && dg(b2, c2, true);
    return b2.child;
  }
  function lj(a2) {
    var b2 = a2.stateNode;
    b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
    Ih(a2, b2.containerInfo);
  }
  function mj(a2, b2, c2, d2, e2) {
    Ig();
    Jg(e2);
    b2.flags |= 256;
    Yi(a2, b2, c2, d2);
    return b2.child;
  }
  var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function oj(a2) {
    return { baseLanes: a2, cachePool: null, transitions: null };
  }
  function pj(a2, b2, c2) {
    var d2 = b2.pendingProps, e2 = M2.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
    (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
    if (h2) f2 = true, b2.flags &= -129;
    else if (null === a2 || null !== a2.memoizedState) e2 |= 1;
    G2(M2, e2 & 1);
    if (null === a2) {
      Eg(b2);
      a2 = b2.memoizedState;
      if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
      g2 = d2.children;
      a2 = d2.fallback;
      return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
    }
    e2 = a2.memoizedState;
    if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return sj(a2, b2, g2, d2, h2, e2, c2);
    if (f2) {
      f2 = d2.fallback;
      g2 = b2.mode;
      e2 = a2.child;
      h2 = e2.sibling;
      var k2 = { mode: "hidden", children: d2.children };
      0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
      null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
      f2.return = b2;
      d2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      d2 = f2;
      f2 = b2.child;
      g2 = a2.child.memoizedState;
      g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
      f2.memoizedState = g2;
      f2.childLanes = a2.childLanes & ~c2;
      b2.memoizedState = nj;
      return d2;
    }
    f2 = a2.child;
    a2 = f2.sibling;
    d2 = wh(f2, { mode: "visible", children: d2.children });
    0 === (b2.mode & 1) && (d2.lanes = c2);
    d2.return = b2;
    d2.sibling = null;
    null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
    b2.child = d2;
    b2.memoizedState = null;
    return d2;
  }
  function rj(a2, b2) {
    b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
    b2.return = a2;
    return a2.child = b2;
  }
  function tj(a2, b2, c2, d2) {
    null !== d2 && Jg(d2);
    Bh(b2, a2.child, null, c2);
    a2 = rj(b2, b2.pendingProps.children);
    a2.flags |= 2;
    b2.memoizedState = null;
    return a2;
  }
  function sj(a2, b2, c2, d2, e2, f2, g2) {
    if (c2) {
      if (b2.flags & 256) return b2.flags &= -257, d2 = Li(Error(p2(422))), tj(a2, b2, g2, d2);
      if (null !== b2.memoizedState) return b2.child = a2.child, b2.flags |= 128, null;
      f2 = d2.fallback;
      e2 = b2.mode;
      d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
      f2 = Ah(f2, e2, g2, null);
      f2.flags |= 2;
      d2.return = b2;
      f2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
      b2.child.memoizedState = oj(g2);
      b2.memoizedState = nj;
      return f2;
    }
    if (0 === (b2.mode & 1)) return tj(a2, b2, g2, null);
    if ("$!" === e2.data) {
      d2 = e2.nextSibling && e2.nextSibling.dataset;
      if (d2) var h2 = d2.dgst;
      d2 = h2;
      f2 = Error(p2(419));
      d2 = Li(f2, d2, void 0);
      return tj(a2, b2, g2, d2);
    }
    h2 = 0 !== (g2 & a2.childLanes);
    if (Ug || h2) {
      d2 = R;
      if (null !== d2) {
        switch (g2 & -g2) {
          case 4:
            e2 = 2;
            break;
          case 16:
            e2 = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e2 = 32;
            break;
          case 536870912:
            e2 = 268435456;
            break;
          default:
            e2 = 0;
        }
        e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
        0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
      }
      uj();
      d2 = Li(Error(p2(421)));
      return tj(a2, b2, g2, d2);
    }
    if ("$?" === e2.data) return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
    a2 = f2.treeContext;
    yg = Lf(e2.nextSibling);
    xg = b2;
    I = true;
    zg = null;
    null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
    b2 = rj(b2, d2.children);
    b2.flags |= 4096;
    return b2;
  }
  function wj(a2, b2, c2) {
    a2.lanes |= b2;
    var d2 = a2.alternate;
    null !== d2 && (d2.lanes |= b2);
    Sg(a2.return, b2, c2);
  }
  function xj(a2, b2, c2, d2, e2) {
    var f2 = a2.memoizedState;
    null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
  }
  function yj(a2, b2, c2) {
    var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
    Yi(a2, b2, d2.children, c2);
    d2 = M2.current;
    if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
    else {
      if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b2.child; null !== a2; ) {
        if (13 === a2.tag) null !== a2.memoizedState && wj(a2, c2, b2);
        else if (19 === a2.tag) wj(a2, c2, b2);
        else if (null !== a2.child) {
          a2.child.return = a2;
          a2 = a2.child;
          continue;
        }
        if (a2 === b2) break a;
        for (; null === a2.sibling; ) {
          if (null === a2.return || a2.return === b2) break a;
          a2 = a2.return;
        }
        a2.sibling.return = a2.return;
        a2 = a2.sibling;
      }
      d2 &= 1;
    }
    G2(M2, d2);
    if (0 === (b2.mode & 1)) b2.memoizedState = null;
    else switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
    return b2.child;
  }
  function jj(a2, b2) {
    0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
  }
  function $i(a2, b2, c2) {
    null !== a2 && (b2.dependencies = a2.dependencies);
    hh |= b2.lanes;
    if (0 === (c2 & b2.childLanes)) return null;
    if (null !== a2 && b2.child !== a2.child) throw Error(p2(153));
    if (null !== b2.child) {
      a2 = b2.child;
      c2 = wh(a2, a2.pendingProps);
      b2.child = c2;
      for (c2.return = b2; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
      c2.sibling = null;
    }
    return b2.child;
  }
  function zj(a2, b2, c2) {
    switch (b2.tag) {
      case 3:
        lj(b2);
        Ig();
        break;
      case 5:
        Kh(b2);
        break;
      case 1:
        Zf(b2.type) && cg(b2);
        break;
      case 4:
        Ih(b2, b2.stateNode.containerInfo);
        break;
      case 10:
        var d2 = b2.type._context, e2 = b2.memoizedProps.value;
        G2(Mg, d2._currentValue);
        d2._currentValue = e2;
        break;
      case 13:
        d2 = b2.memoizedState;
        if (null !== d2) {
          if (null !== d2.dehydrated) return G2(M2, M2.current & 1), b2.flags |= 128, null;
          if (0 !== (c2 & b2.child.childLanes)) return pj(a2, b2, c2);
          G2(M2, M2.current & 1);
          a2 = $i(a2, b2, c2);
          return null !== a2 ? a2.sibling : null;
        }
        G2(M2, M2.current & 1);
        break;
      case 19:
        d2 = 0 !== (c2 & b2.childLanes);
        if (0 !== (a2.flags & 128)) {
          if (d2) return yj(a2, b2, c2);
          b2.flags |= 128;
        }
        e2 = b2.memoizedState;
        null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
        G2(M2, M2.current);
        if (d2) break;
        else return null;
      case 22:
      case 23:
        return b2.lanes = 0, ej(a2, b2, c2);
    }
    return $i(a2, b2, c2);
  }
  var Aj, Bj, Cj, Dj;
  Aj = function(a2, b2) {
    for (var c2 = b2.child; null !== c2; ) {
      if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
      else if (4 !== c2.tag && null !== c2.child) {
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
      if (c2 === b2) break;
      for (; null === c2.sibling; ) {
        if (null === c2.return || c2.return === b2) return;
        c2 = c2.return;
      }
      c2.sibling.return = c2.return;
      c2 = c2.sibling;
    }
  };
  Bj = function() {
  };
  Cj = function(a2, b2, c2, d2) {
    var e2 = a2.memoizedProps;
    if (e2 !== d2) {
      a2 = b2.stateNode;
      Hh(Eh.current);
      var f2 = null;
      switch (c2) {
        case "input":
          e2 = Ya(a2, e2);
          d2 = Ya(a2, d2);
          f2 = [];
          break;
        case "select":
          e2 = A2({}, e2, { value: void 0 });
          d2 = A2({}, d2, { value: void 0 });
          f2 = [];
          break;
        case "textarea":
          e2 = gb(a2, e2);
          d2 = gb(a2, d2);
          f2 = [];
          break;
        default:
          "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
      }
      ub(c2, d2);
      var g2;
      c2 = null;
      for (l2 in e2) if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
        var h2 = e2[l2];
        for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
      } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
      for (l2 in d2) {
        var k2 = d2[l2];
        h2 = null != e2 ? e2[l2] : void 0;
        if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
          for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
          for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
        } else c2 || (f2 || (f2 = []), f2.push(
          l2,
          c2
        )), c2 = k2;
        else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
      }
      c2 && (f2 = f2 || []).push("style", c2);
      var l2 = f2;
      if (b2.updateQueue = l2) b2.flags |= 4;
    }
  };
  Dj = function(a2, b2, c2, d2) {
    c2 !== d2 && (b2.flags |= 4);
  };
  function Ej(a2, b2) {
    if (!I) switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
  }
  function S2(a2) {
    var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
    if (b2) for (var e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
    else for (e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
    a2.subtreeFlags |= d2;
    a2.childLanes = c2;
    return b2;
  }
  function Fj(a2, b2, c2) {
    var d2 = b2.pendingProps;
    wg(b2);
    switch (b2.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S2(b2), null;
      case 1:
        return Zf(b2.type) && $f(), S2(b2), null;
      case 3:
        d2 = b2.stateNode;
        Jh();
        E2(Wf);
        E2(H2);
        Oh();
        d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
        if (null === a2 || null === a2.child) Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
        Bj(a2, b2);
        S2(b2);
        return null;
      case 5:
        Lh(b2);
        var e2 = Hh(Gh.current);
        c2 = b2.type;
        if (null !== a2 && null != b2.stateNode) Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        else {
          if (!d2) {
            if (null === b2.stateNode) throw Error(p2(166));
            S2(b2);
            return null;
          }
          a2 = Hh(Eh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c2 = b2.type;
            var f2 = b2.memoizedProps;
            d2[Of] = b2;
            d2[Pf] = f2;
            a2 = 0 !== (b2.mode & 1);
            switch (c2) {
              case "dialog":
                D2("cancel", d2);
                D2("close", d2);
                break;
              case "iframe":
              case "object":
              case "embed":
                D2("load", d2);
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D2(lf[e2], d2);
                break;
              case "source":
                D2("error", d2);
                break;
              case "img":
              case "image":
              case "link":
                D2(
                  "error",
                  d2
                );
                D2("load", d2);
                break;
              case "details":
                D2("toggle", d2);
                break;
              case "input":
                Za(d2, f2);
                D2("invalid", d2);
                break;
              case "select":
                d2._wrapperState = { wasMultiple: !!f2.multiple };
                D2("invalid", d2);
                break;
              case "textarea":
                hb(d2, f2), D2("invalid", d2);
            }
            ub(c2, f2);
            e2 = null;
            for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D2("scroll", d2);
            }
            switch (c2) {
              case "input":
                Va(d2);
                db(d2, f2, true);
                break;
              case "textarea":
                Va(d2);
                jb(d2);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f2.onClick && (d2.onclick = Bf);
            }
            d2 = e2;
            b2.updateQueue = d2;
            null !== d2 && (b2.flags |= 4);
          } else {
            g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
            "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
            a2[Of] = b2;
            a2[Pf] = d2;
            Aj(a2, b2, false, false);
            b2.stateNode = a2;
            a: {
              g2 = vb(c2, d2);
              switch (c2) {
                case "dialog":
                  D2("cancel", a2);
                  D2("close", a2);
                  e2 = d2;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D2("load", a2);
                  e2 = d2;
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++) D2(lf[e2], a2);
                  e2 = d2;
                  break;
                case "source":
                  D2("error", a2);
                  e2 = d2;
                  break;
                case "img":
                case "image":
                case "link":
                  D2(
                    "error",
                    a2
                  );
                  D2("load", a2);
                  e2 = d2;
                  break;
                case "details":
                  D2("toggle", a2);
                  e2 = d2;
                  break;
                case "input":
                  Za(a2, d2);
                  e2 = Ya(a2, d2);
                  D2("invalid", a2);
                  break;
                case "option":
                  e2 = d2;
                  break;
                case "select":
                  a2._wrapperState = { wasMultiple: !!d2.multiple };
                  e2 = A2({}, d2, { value: void 0 });
                  D2("invalid", a2);
                  break;
                case "textarea":
                  hb(a2, d2);
                  e2 = gb(a2, d2);
                  D2("invalid", a2);
                  break;
                default:
                  e2 = d2;
              }
              ub(c2, e2);
              h2 = e2;
              for (f2 in h2) if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D2("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
              switch (c2) {
                case "input":
                  Va(a2);
                  db(a2, d2, false);
                  break;
                case "textarea":
                  Va(a2);
                  jb(a2);
                  break;
                case "option":
                  null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                  break;
                case "select":
                  a2.multiple = !!d2.multiple;
                  f2 = d2.value;
                  null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                    a2,
                    !!d2.multiple,
                    d2.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e2.onClick && (a2.onclick = Bf);
              }
              switch (c2) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d2 = !!d2.autoFocus;
                  break a;
                case "img":
                  d2 = true;
                  break a;
                default:
                  d2 = false;
              }
            }
            d2 && (b2.flags |= 4);
          }
          null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        }
        S2(b2);
        return null;
      case 6:
        if (a2 && null != b2.stateNode) Dj(a2, b2, a2.memoizedProps, d2);
        else {
          if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p2(166));
          c2 = Hh(Gh.current);
          Hh(Eh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c2 = b2.memoizedProps;
            d2[Of] = b2;
            if (f2 = d2.nodeValue !== c2) {
              if (a2 = xg, null !== a2) switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
            }
            f2 && (b2.flags |= 4);
          } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
        }
        S2(b2);
        return null;
      case 13:
        E2(M2);
        d2 = b2.memoizedState;
        if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
          else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
            if (null === a2) {
              if (!f2) throw Error(p2(318));
              f2 = b2.memoizedState;
              f2 = null !== f2 ? f2.dehydrated : null;
              if (!f2) throw Error(p2(317));
              f2[Of] = b2;
            } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
            S2(b2);
            f2 = false;
          } else null !== zg && (Gj(zg), zg = null), f2 = true;
          if (!f2) return b2.flags & 65536 ? b2 : null;
        }
        if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
        d2 = null !== d2;
        d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M2.current & 1) ? 0 === T && (T = 3) : uj()));
        null !== b2.updateQueue && (b2.flags |= 4);
        S2(b2);
        return null;
      case 4:
        return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S2(b2), null;
      case 10:
        return Rg(b2.type._context), S2(b2), null;
      case 17:
        return Zf(b2.type) && $f(), S2(b2), null;
      case 19:
        E2(M2);
        f2 = b2.memoizedState;
        if (null === f2) return S2(b2), null;
        d2 = 0 !== (b2.flags & 128);
        g2 = f2.rendering;
        if (null === g2) if (d2) Ej(f2, false);
        else {
          if (0 !== T || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b2.child; null !== a2; ) {
            g2 = Mh(a2);
            if (null !== g2) {
              b2.flags |= 128;
              Ej(f2, false);
              d2 = g2.updateQueue;
              null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
              b2.subtreeFlags = 0;
              d2 = c2;
              for (c2 = b2.child; null !== c2; ) f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
              G2(M2, M2.current & 1 | 2);
              return b2.child;
            }
            a2 = a2.sibling;
          }
          null !== f2.tail && B() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
        else {
          if (!d2) if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I) return S2(b2), null;
          } else 2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
          f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
        }
        if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = M2.current, G2(M2, d2 ? c2 & 1 | 2 : c2 & 1), b2;
        S2(b2);
        return null;
      case 22:
      case 23:
        return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S2(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S2(b2), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p2(156, b2.tag));
  }
  function Jj(a2, b2) {
    wg(b2);
    switch (b2.tag) {
      case 1:
        return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 3:
        return Jh(), E2(Wf), E2(H2), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 5:
        return Lh(b2), null;
      case 13:
        E2(M2);
        a2 = b2.memoizedState;
        if (null !== a2 && null !== a2.dehydrated) {
          if (null === b2.alternate) throw Error(p2(340));
          Ig();
        }
        a2 = b2.flags;
        return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 19:
        return E2(M2), null;
      case 4:
        return Jh(), null;
      case 10:
        return Rg(b2.type._context), null;
      case 22:
      case 23:
        return Ij(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Kj = false, U2 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V2 = null;
  function Mj(a2, b2) {
    var c2 = a2.ref;
    if (null !== c2) if ("function" === typeof c2) try {
      c2(null);
    } catch (d2) {
      W(a2, b2, d2);
    }
    else c2.current = null;
  }
  function Nj(a2, b2, c2) {
    try {
      c2();
    } catch (d2) {
      W(a2, b2, d2);
    }
  }
  var Oj = false;
  function Pj(a2, b2) {
    Cf = dd;
    a2 = Me2();
    if (Ne2(a2)) {
      if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
      else a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b: for (; ; ) {
            for (var y2; ; ) {
              q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
              q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
              3 === q2.nodeType && (g2 += q2.nodeValue.length);
              if (null === (y2 = q2.firstChild)) break;
              r2 = q2;
              q2 = y2;
            }
            for (; ; ) {
              if (q2 === a2) break b;
              r2 === c2 && ++l2 === e2 && (h2 = g2);
              r2 === f2 && ++m2 === d2 && (k2 = g2);
              if (null !== (y2 = q2.nextSibling)) break;
              q2 = r2;
              r2 = q2.parentNode;
            }
            q2 = y2;
          }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else c2 = null;
      }
      c2 = c2 || { start: 0, end: 0 };
    } else c2 = null;
    Df = { focusedElem: a2, selectionRange: c2 };
    dd = false;
    for (V2 = b2; null !== V2; ) if (b2 = V2, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2) a2.return = b2, V2 = a2;
    else for (; null !== V2; ) {
      b2 = V2;
      try {
        var n2 = b2.alternate;
        if (0 !== (b2.flags & 1024)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n2) {
              var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
              x2.__reactInternalSnapshotBeforeUpdate = w2;
            }
            break;
          case 3:
            var u2 = b2.stateNode.containerInfo;
            1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p2(163));
        }
      } catch (F) {
        W(b2, b2.return, F);
      }
      a2 = b2.sibling;
      if (null !== a2) {
        a2.return = b2.return;
        V2 = a2;
        break;
      }
      V2 = b2.return;
    }
    n2 = Oj;
    Oj = false;
    return n2;
  }
  function Qj(a2, b2, c2) {
    var d2 = b2.updateQueue;
    d2 = null !== d2 ? d2.lastEffect : null;
    if (null !== d2) {
      var e2 = d2 = d2.next;
      do {
        if ((e2.tag & a2) === a2) {
          var f2 = e2.destroy;
          e2.destroy = void 0;
          void 0 !== f2 && Nj(b2, c2, f2);
        }
        e2 = e2.next;
      } while (e2 !== d2);
    }
  }
  function Rj(a2, b2) {
    b2 = b2.updateQueue;
    b2 = null !== b2 ? b2.lastEffect : null;
    if (null !== b2) {
      var c2 = b2 = b2.next;
      do {
        if ((c2.tag & a2) === a2) {
          var d2 = c2.create;
          c2.destroy = d2();
        }
        c2 = c2.next;
      } while (c2 !== b2);
    }
  }
  function Sj(a2) {
    var b2 = a2.ref;
    if (null !== b2) {
      var c2 = a2.stateNode;
      switch (a2.tag) {
        case 5:
          a2 = c2;
          break;
        default:
          a2 = c2;
      }
      "function" === typeof b2 ? b2(a2) : b2.current = a2;
    }
  }
  function Tj(a2) {
    var b2 = a2.alternate;
    null !== b2 && (a2.alternate = null, Tj(b2));
    a2.child = null;
    a2.deletions = null;
    a2.sibling = null;
    5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
    a2.stateNode = null;
    a2.return = null;
    a2.dependencies = null;
    a2.memoizedProps = null;
    a2.memoizedState = null;
    a2.pendingProps = null;
    a2.stateNode = null;
    a2.updateQueue = null;
  }
  function Uj(a2) {
    return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
  }
  function Vj(a2) {
    a: for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return)) return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2) continue a;
        if (null === a2.child || 4 === a2.tag) continue a;
        else a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2)) return a2.stateNode;
    }
  }
  function Wj(a2, b2, c2) {
    var d2 = a2.tag;
    if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
    else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b2, c2), a2 = a2.sibling;
  }
  function Xj(a2, b2, c2) {
    var d2 = a2.tag;
    if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
    else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Xj(a2, b2, c2), a2 = a2.sibling;
  }
  var X2 = null, Yj = false;
  function Zj(a2, b2, c2) {
    for (c2 = c2.child; null !== c2; ) ak(a2, b2, c2), c2 = c2.sibling;
  }
  function ak(a2, b2, c2) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
    switch (c2.tag) {
      case 5:
        U2 || Mj(c2, b2);
      case 6:
        var d2 = X2, e2 = Yj;
        X2 = null;
        Zj(a2, b2, c2);
        X2 = d2;
        Yj = e2;
        null !== X2 && (Yj ? (a2 = X2, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X2.removeChild(c2.stateNode));
        break;
      case 18:
        null !== X2 && (Yj ? (a2 = X2, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X2, c2.stateNode));
        break;
      case 4:
        d2 = X2;
        e2 = Yj;
        X2 = c2.stateNode.containerInfo;
        Yj = true;
        Zj(a2, b2, c2);
        X2 = d2;
        Yj = e2;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U2 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
          e2 = d2 = d2.next;
          do {
            var f2 = e2, g2 = f2.destroy;
            f2 = f2.tag;
            void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
            e2 = e2.next;
          } while (e2 !== d2);
        }
        Zj(a2, b2, c2);
        break;
      case 1:
        if (!U2 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W(c2, b2, h2);
        }
        Zj(a2, b2, c2);
        break;
      case 21:
        Zj(a2, b2, c2);
        break;
      case 22:
        c2.mode & 1 ? (U2 = (d2 = U2) || null !== c2.memoizedState, Zj(a2, b2, c2), U2 = d2) : Zj(a2, b2, c2);
        break;
      default:
        Zj(a2, b2, c2);
    }
  }
  function bk(a2) {
    var b2 = a2.updateQueue;
    if (null !== b2) {
      a2.updateQueue = null;
      var c2 = a2.stateNode;
      null === c2 && (c2 = a2.stateNode = new Lj());
      b2.forEach(function(b3) {
        var d2 = ck.bind(null, a2, b3);
        c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
      });
    }
  }
  function dk(a2, b2) {
    var c2 = b2.deletions;
    if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a: for (; null !== h2; ) {
          switch (h2.tag) {
            case 5:
              X2 = h2.stateNode;
              Yj = false;
              break a;
            case 3:
              X2 = h2.stateNode.containerInfo;
              Yj = true;
              break a;
            case 4:
              X2 = h2.stateNode.containerInfo;
              Yj = true;
              break a;
          }
          h2 = h2.return;
        }
        if (null === X2) throw Error(p2(160));
        ak(f2, g2, e2);
        X2 = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b2, l2);
      }
    }
    if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) ek(b2, a2), b2 = b2.sibling;
  }
  function ek(a2, b2) {
    var c2 = a2.alternate, d2 = a2.flags;
    switch (a2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        dk(b2, a2);
        fk(a2);
        if (d2 & 4) {
          try {
            Qj(3, a2, a2.return), Rj(3, a2);
          } catch (t2) {
            W(a2, a2.return, t2);
          }
          try {
            Qj(5, a2, a2.return);
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 1:
        dk(b2, a2);
        fk(a2);
        d2 & 512 && null !== c2 && Mj(c2, c2.return);
        break;
      case 5:
        dk(b2, a2);
        fk(a2);
        d2 & 512 && null !== c2 && Mj(c2, c2.return);
        if (a2.flags & 32) {
          var e2 = a2.stateNode;
          try {
            ob(e2, "");
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
          var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
          a2.updateQueue = null;
          if (null !== k2) try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 6:
        dk(b2, a2);
        fk(a2);
        if (d2 & 4) {
          if (null === a2.stateNode) throw Error(p2(162));
          e2 = a2.stateNode;
          f2 = a2.memoizedProps;
          try {
            e2.nodeValue = f2;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 3:
        dk(b2, a2);
        fk(a2);
        if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
          bd(b2.containerInfo);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
        break;
      case 4:
        dk(b2, a2);
        fk(a2);
        break;
      case 13:
        dk(b2, a2);
        fk(a2);
        e2 = a2.child;
        e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
        d2 & 4 && bk(a2);
        break;
      case 22:
        m2 = null !== c2 && null !== c2.memoizedState;
        a2.mode & 1 ? (U2 = (l2 = U2) || m2, dk(b2, a2), U2 = l2) : dk(b2, a2);
        fk(a2);
        if (d2 & 8192) {
          l2 = null !== a2.memoizedState;
          if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1)) for (V2 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V2 = m2; null !== V2; ) {
              r2 = V2;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V2 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
          a: for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2) try {
                q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
              } catch (t2) {
                W(a2, a2.return, t2);
              }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2) break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2) break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
        }
        break;
      case 19:
        dk(b2, a2);
        fk(a2);
        d2 & 4 && bk(a2);
        break;
      case 21:
        break;
      default:
        dk(
          b2,
          a2
        ), fk(a2);
    }
  }
  function fk(a2) {
    var b2 = a2.flags;
    if (b2 & 2) {
      try {
        a: {
          for (var c2 = a2.return; null !== c2; ) {
            if (Uj(c2)) {
              var d2 = c2;
              break a;
            }
            c2 = c2.return;
          }
          throw Error(p2(160));
        }
        switch (d2.tag) {
          case 5:
            var e2 = d2.stateNode;
            d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
            var f2 = Vj(a2);
            Xj(a2, f2, e2);
            break;
          case 3:
          case 4:
            var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
            Wj(a2, h2, g2);
            break;
          default:
            throw Error(p2(161));
        }
      } catch (k2) {
        W(a2, a2.return, k2);
      }
      a2.flags &= -3;
    }
    b2 & 4096 && (a2.flags &= -4097);
  }
  function ik(a2, b2, c2) {
    V2 = a2;
    jk(a2);
  }
  function jk(a2, b2, c2) {
    for (var d2 = 0 !== (a2.mode & 1); null !== V2; ) {
      var e2 = V2, f2 = e2.child;
      if (22 === e2.tag && d2) {
        var g2 = null !== e2.memoizedState || Kj;
        if (!g2) {
          var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U2;
          h2 = Kj;
          var l2 = U2;
          Kj = g2;
          if ((U2 = k2) && !l2) for (V2 = e2; null !== V2; ) g2 = V2, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V2 = k2) : kk(e2);
          for (; null !== f2; ) V2 = f2, jk(f2), f2 = f2.sibling;
          V2 = e2;
          Kj = h2;
          U2 = l2;
        }
        lk(a2);
      } else 0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V2 = f2) : lk(a2);
    }
  }
  function lk(a2) {
    for (; null !== V2; ) {
      var b2 = V2;
      if (0 !== (b2.flags & 8772)) {
        var c2 = b2.alternate;
        try {
          if (0 !== (b2.flags & 8772)) switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U2 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U2) if (null === c2) d2.componentDidMount();
              else {
                var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
              }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child) switch (b2.child.tag) {
                  case 5:
                    c2 = b2.child.stateNode;
                    break;
                  case 1:
                    c2 = b2.child.stateNode;
                }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p2(163));
          }
          U2 || b2.flags & 512 && Sj(b2);
        } catch (r2) {
          W(b2, b2.return, r2);
        }
      }
      if (b2 === a2) {
        V2 = null;
        break;
      }
      c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V2 = c2;
        break;
      }
      V2 = b2.return;
    }
  }
  function hk(a2) {
    for (; null !== V2; ) {
      var b2 = V2;
      if (b2 === a2) {
        V2 = null;
        break;
      }
      var c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V2 = c2;
        break;
      }
      V2 = b2.return;
    }
  }
  function kk(a2) {
    for (; null !== V2; ) {
      var b2 = V2;
      try {
        switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            var c2 = b2.return;
            try {
              Rj(4, b2);
            } catch (k2) {
              W(b2, c2, k2);
            }
            break;
          case 1:
            var d2 = b2.stateNode;
            if ("function" === typeof d2.componentDidMount) {
              var e2 = b2.return;
              try {
                d2.componentDidMount();
              } catch (k2) {
                W(b2, e2, k2);
              }
            }
            var f2 = b2.return;
            try {
              Sj(b2);
            } catch (k2) {
              W(b2, f2, k2);
            }
            break;
          case 5:
            var g2 = b2.return;
            try {
              Sj(b2);
            } catch (k2) {
              W(b2, g2, k2);
            }
        }
      } catch (k2) {
        W(b2, b2.return, k2);
      }
      if (b2 === a2) {
        V2 = null;
        break;
      }
      var h2 = b2.sibling;
      if (null !== h2) {
        h2.return = b2.return;
        V2 = h2;
        break;
      }
      V2 = b2.return;
    }
  }
  var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok2 = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K2 = 0, R = null, Y2 = null, Z2 = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
  function L() {
    return 0 !== (K2 & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
  }
  function lh(a2) {
    if (0 === (a2.mode & 1)) return 1;
    if (0 !== (K2 & 2) && 0 !== Z2) return Z2 & -Z2;
    if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
    a2 = C;
    if (0 !== a2) return a2;
    a2 = window.event;
    a2 = void 0 === a2 ? 16 : jd(a2.type);
    return a2;
  }
  function mh(a2, b2, c2, d2) {
    if (50 < zk) throw zk = 0, Ak = null, Error(p2(185));
    Ac(a2, c2, d2);
    if (0 === (K2 & 2) || a2 !== R) a2 === R && (0 === (K2 & 2) && (rk |= c2), 4 === T && Dk(a2, Z2)), Ek(a2, d2), 1 === c2 && 0 === K2 && 0 === (b2.mode & 1) && (Hj = B() + 500, fg && jg());
  }
  function Ek(a2, b2) {
    var c2 = a2.callbackNode;
    wc(a2, b2);
    var d2 = uc(a2, a2 === R ? Z2 : 0);
    if (0 === d2) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
    else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
      null != c2 && bc(c2);
      if (1 === b2) 0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K2 & 6) && jg();
      }), c2 = null;
      else {
        switch (Dc(d2)) {
          case 1:
            c2 = fc;
            break;
          case 4:
            c2 = gc;
            break;
          case 16:
            c2 = hc;
            break;
          case 536870912:
            c2 = jc;
            break;
          default:
            c2 = hc;
        }
        c2 = Gk(c2, Hk.bind(null, a2));
      }
      a2.callbackPriority = b2;
      a2.callbackNode = c2;
    }
  }
  function Hk(a2, b2) {
    Bk = -1;
    Ck = 0;
    if (0 !== (K2 & 6)) throw Error(p2(327));
    var c2 = a2.callbackNode;
    if (Ik() && a2.callbackNode !== c2) return null;
    var d2 = uc(a2, a2 === R ? Z2 : 0);
    if (0 === d2) return null;
    if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2) b2 = Jk(a2, d2);
    else {
      b2 = d2;
      var e2 = K2;
      K2 |= 2;
      var f2 = Kk();
      if (R !== a2 || Z2 !== b2) vk = null, Hj = B() + 500, Lk(a2, b2);
      do
        try {
          Mk();
          break;
        } catch (h2) {
          Nk(a2, h2);
        }
      while (1);
      Qg();
      nk.current = f2;
      K2 = e2;
      null !== Y2 ? b2 = 0 : (R = null, Z2 = 0, b2 = T);
    }
    if (0 !== b2) {
      2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
      if (1 === b2) throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B()), c2;
      if (6 === b2) Dk(a2, d2);
      else {
        e2 = a2.current.alternate;
        if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2)) throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B()), c2;
        a2.finishedWork = e2;
        a2.finishedLanes = d2;
        switch (b2) {
          case 0:
          case 1:
            throw Error(p2(345));
          case 2:
            Qk(a2, uk, vk);
            break;
          case 3:
            Dk(a2, d2);
            if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B(), 10 < b2)) {
              if (0 !== uc(a2, 0)) break;
              e2 = a2.suspendedLanes;
              if ((e2 & d2) !== d2) {
                L();
                a2.pingedLanes |= a2.suspendedLanes & e2;
                break;
              }
              a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
              break;
            }
            Qk(a2, uk, vk);
            break;
          case 4:
            Dk(a2, d2);
            if ((d2 & 4194240) === d2) break;
            b2 = a2.eventTimes;
            for (e2 = -1; 0 < d2; ) {
              var g2 = 31 - oc(d2);
              f2 = 1 << g2;
              g2 = b2[g2];
              g2 > e2 && (e2 = g2);
              d2 &= ~f2;
            }
            d2 = e2;
            d2 = B() - d2;
            d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
            if (10 < d2) {
              a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
              break;
            }
            Qk(a2, uk, vk);
            break;
          case 5:
            Qk(a2, uk, vk);
            break;
          default:
            throw Error(p2(329));
        }
      }
    }
    Ek(a2, B());
    return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
  }
  function Ok(a2, b2) {
    var c2 = tk;
    a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
    a2 = Jk(a2, b2);
    2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
    return a2;
  }
  function Gj(a2) {
    null === uk ? uk = a2 : uk.push.apply(uk, a2);
  }
  function Pk(a2) {
    for (var b2 = a2; ; ) {
      if (b2.flags & 16384) {
        var c2 = b2.updateQueue;
        if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2)) return false;
          } catch (g2) {
            return false;
          }
        }
      }
      c2 = b2.child;
      if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
      else {
        if (b2 === a2) break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a2) return true;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
    }
    return true;
  }
  function Dk(a2, b2) {
    b2 &= ~sk;
    b2 &= ~rk;
    a2.suspendedLanes |= b2;
    a2.pingedLanes &= ~b2;
    for (a2 = a2.expirationTimes; 0 < b2; ) {
      var c2 = 31 - oc(b2), d2 = 1 << c2;
      a2[c2] = -1;
      b2 &= ~d2;
    }
  }
  function Fk(a2) {
    if (0 !== (K2 & 6)) throw Error(p2(327));
    Ik();
    var b2 = uc(a2, 0);
    if (0 === (b2 & 1)) return Ek(a2, B()), null;
    var c2 = Jk(a2, b2);
    if (0 !== a2.tag && 2 === c2) {
      var d2 = xc(a2);
      0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
    }
    if (1 === c2) throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B()), c2;
    if (6 === c2) throw Error(p2(345));
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = b2;
    Qk(a2, uk, vk);
    Ek(a2, B());
    return null;
  }
  function Rk(a2, b2) {
    var c2 = K2;
    K2 |= 1;
    try {
      return a2(b2);
    } finally {
      K2 = c2, 0 === K2 && (Hj = B() + 500, fg && jg());
    }
  }
  function Sk(a2) {
    null !== xk && 0 === xk.tag && 0 === (K2 & 6) && Ik();
    var b2 = K2;
    K2 |= 1;
    var c2 = pk.transition, d2 = C;
    try {
      if (pk.transition = null, C = 1, a2) return a2();
    } finally {
      C = d2, pk.transition = c2, K2 = b2, 0 === (K2 & 6) && jg();
    }
  }
  function Ij() {
    gj = fj.current;
    E2(fj);
  }
  function Lk(a2, b2) {
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    var c2 = a2.timeoutHandle;
    -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
    if (null !== Y2) for (c2 = Y2.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E2(Wf);
          E2(H2);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E2(M2);
          break;
        case 19:
          E2(M2);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
    R = a2;
    Y2 = a2 = wh(a2.current, null);
    Z2 = gj = b2;
    T = 0;
    qk = null;
    sk = rk = hh = 0;
    uk = tk = null;
    if (null !== Wg) {
      for (b2 = 0; b2 < Wg.length; b2++) if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
      Wg = null;
    }
    return a2;
  }
  function Nk(a2, b2) {
    do {
      var c2 = Y2;
      try {
        Qg();
        Ph.current = ai;
        if (Sh) {
          for (var d2 = N2.memoizedState; null !== d2; ) {
            var e2 = d2.queue;
            null !== e2 && (e2.pending = null);
            d2 = d2.next;
          }
          Sh = false;
        }
        Rh = 0;
        P = O2 = N2 = null;
        Th = false;
        Uh = 0;
        ok2.current = null;
        if (null === c2 || null === c2.return) {
          T = 1;
          qk = b2;
          Y2 = null;
          break;
        }
        a: {
          var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
          b2 = Z2;
          h2.flags |= 32768;
          if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
            var l2 = k2, m2 = h2, q2 = m2.tag;
            if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
              var r2 = m2.alternate;
              r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
            }
            var y2 = Vi(g2);
            if (null !== y2) {
              y2.flags &= -257;
              Wi(y2, g2, h2, f2, b2);
              y2.mode & 1 && Ti(f2, l2, b2);
              b2 = y2;
              k2 = l2;
              var n2 = b2.updateQueue;
              if (null === n2) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k2);
                b2.updateQueue = t2;
              } else n2.add(k2);
              break a;
            } else {
              if (0 === (b2 & 1)) {
                Ti(f2, l2, b2);
                uj();
                break a;
              }
              k2 = Error(p2(426));
            }
          } else if (I && h2.mode & 1) {
            var J2 = Vi(g2);
            if (null !== J2) {
              0 === (J2.flags & 65536) && (J2.flags |= 256);
              Wi(J2, g2, h2, f2, b2);
              Jg(Ki(k2, h2));
              break a;
            }
          }
          f2 = k2 = Ki(k2, h2);
          4 !== T && (T = 2);
          null === tk ? tk = [f2] : tk.push(f2);
          f2 = g2;
          do {
            switch (f2.tag) {
              case 3:
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var x2 = Oi(f2, k2, b2);
                fh(f2, x2);
                break a;
              case 1:
                h2 = k2;
                var w2 = f2.type, u2 = f2.stateNode;
                if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var F = Ri(f2, h2, b2);
                  fh(f2, F);
                  break a;
                }
            }
            f2 = f2.return;
          } while (null !== f2);
        }
        Tk(c2);
      } catch (na) {
        b2 = na;
        Y2 === c2 && null !== c2 && (Y2 = c2 = c2.return);
        continue;
      }
      break;
    } while (1);
  }
  function Kk() {
    var a2 = nk.current;
    nk.current = ai;
    return null === a2 ? ai : a2;
  }
  function uj() {
    if (0 === T || 3 === T || 2 === T) T = 4;
    null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z2);
  }
  function Jk(a2, b2) {
    var c2 = K2;
    K2 |= 2;
    var d2 = Kk();
    if (R !== a2 || Z2 !== b2) vk = null, Lk(a2, b2);
    do
      try {
        Uk();
        break;
      } catch (e2) {
        Nk(a2, e2);
      }
    while (1);
    Qg();
    K2 = c2;
    nk.current = d2;
    if (null !== Y2) throw Error(p2(261));
    R = null;
    Z2 = 0;
    return T;
  }
  function Uk() {
    for (; null !== Y2; ) Vk(Y2);
  }
  function Mk() {
    for (; null !== Y2 && !cc(); ) Vk(Y2);
  }
  function Vk(a2) {
    var b2 = Wk(a2.alternate, a2, gj);
    a2.memoizedProps = a2.pendingProps;
    null === b2 ? Tk(a2) : Y2 = b2;
    ok2.current = null;
  }
  function Tk(a2) {
    var b2 = a2;
    do {
      var c2 = b2.alternate;
      a2 = b2.return;
      if (0 === (b2.flags & 32768)) {
        if (c2 = Fj(c2, b2, gj), null !== c2) {
          Y2 = c2;
          return;
        }
      } else {
        c2 = Jj(c2, b2);
        if (null !== c2) {
          c2.flags &= 32767;
          Y2 = c2;
          return;
        }
        if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
        else {
          T = 6;
          Y2 = null;
          return;
        }
      }
      b2 = b2.sibling;
      if (null !== b2) {
        Y2 = b2;
        return;
      }
      Y2 = b2 = a2;
    } while (null !== b2);
    0 === T && (T = 5);
  }
  function Qk(a2, b2, c2) {
    var d2 = C, e2 = pk.transition;
    try {
      pk.transition = null, C = 1, Xk(a2, b2, c2, d2);
    } finally {
      pk.transition = e2, C = d2;
    }
    return null;
  }
  function Xk(a2, b2, c2, d2) {
    do
      Ik();
    while (null !== xk);
    if (0 !== (K2 & 6)) throw Error(p2(327));
    c2 = a2.finishedWork;
    var e2 = a2.finishedLanes;
    if (null === c2) return null;
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    if (c2 === a2.current) throw Error(p2(177));
    a2.callbackNode = null;
    a2.callbackPriority = 0;
    var f2 = c2.lanes | c2.childLanes;
    Bc(a2, f2);
    a2 === R && (Y2 = R = null, Z2 = 0);
    0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
      Ik();
      return null;
    }));
    f2 = 0 !== (c2.flags & 15990);
    if (0 !== (c2.subtreeFlags & 15990) || f2) {
      f2 = pk.transition;
      pk.transition = null;
      var g2 = C;
      C = 1;
      var h2 = K2;
      K2 |= 4;
      ok2.current = null;
      Pj(a2, c2);
      ek(c2, a2);
      Oe2(Df);
      dd = !!Cf;
      Df = Cf = null;
      a2.current = c2;
      ik(c2);
      dc();
      K2 = h2;
      C = g2;
      pk.transition = f2;
    } else a2.current = c2;
    wk && (wk = false, xk = a2, yk = e2);
    f2 = a2.pendingLanes;
    0 === f2 && (Si = null);
    mc(c2.stateNode);
    Ek(a2, B());
    if (null !== b2) for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
    if (Pi) throw Pi = false, a2 = Qi, Qi = null, a2;
    0 !== (yk & 1) && 0 !== a2.tag && Ik();
    f2 = a2.pendingLanes;
    0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
    jg();
    return null;
  }
  function Ik() {
    if (null !== xk) {
      var a2 = Dc(yk), b2 = pk.transition, c2 = C;
      try {
        pk.transition = null;
        C = 16 > a2 ? 16 : a2;
        if (null === xk) var d2 = false;
        else {
          a2 = xk;
          xk = null;
          yk = 0;
          if (0 !== (K2 & 6)) throw Error(p2(331));
          var e2 = K2;
          K2 |= 4;
          for (V2 = a2.current; null !== V2; ) {
            var f2 = V2, g2 = f2.child;
            if (0 !== (V2.flags & 16)) {
              var h2 = f2.deletions;
              if (null !== h2) {
                for (var k2 = 0; k2 < h2.length; k2++) {
                  var l2 = h2[k2];
                  for (V2 = l2; null !== V2; ) {
                    var m2 = V2;
                    switch (m2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(8, m2, f2);
                    }
                    var q2 = m2.child;
                    if (null !== q2) q2.return = m2, V2 = q2;
                    else for (; null !== V2; ) {
                      m2 = V2;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V2 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V2 = r2;
                        break;
                      }
                      V2 = y2;
                    }
                  }
                }
                var n2 = f2.alternate;
                if (null !== n2) {
                  var t2 = n2.child;
                  if (null !== t2) {
                    n2.child = null;
                    do {
                      var J2 = t2.sibling;
                      t2.sibling = null;
                      t2 = J2;
                    } while (null !== t2);
                  }
                }
                V2 = f2;
              }
            }
            if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V2 = g2;
            else b: for (; null !== V2; ) {
              f2 = V2;
              if (0 !== (f2.flags & 2048)) switch (f2.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, f2, f2.return);
              }
              var x2 = f2.sibling;
              if (null !== x2) {
                x2.return = f2.return;
                V2 = x2;
                break b;
              }
              V2 = f2.return;
            }
          }
          var w2 = a2.current;
          for (V2 = w2; null !== V2; ) {
            g2 = V2;
            var u2 = g2.child;
            if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V2 = u2;
            else b: for (g2 = w2; null !== V2; ) {
              h2 = V2;
              if (0 !== (h2.flags & 2048)) try {
                switch (h2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Rj(9, h2);
                }
              } catch (na) {
                W(h2, h2.return, na);
              }
              if (h2 === g2) {
                V2 = null;
                break b;
              }
              var F = h2.sibling;
              if (null !== F) {
                F.return = h2.return;
                V2 = F;
                break b;
              }
              V2 = h2.return;
            }
          }
          K2 = e2;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
          d2 = true;
        }
        return d2;
      } finally {
        C = c2, pk.transition = b2;
      }
    }
    return false;
  }
  function Yk(a2, b2, c2) {
    b2 = Ki(c2, b2);
    b2 = Oi(a2, b2, 1);
    a2 = dh(a2, b2, 1);
    b2 = L();
    null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
  }
  function W(a2, b2, c2) {
    if (3 === a2.tag) Yk(a2, a2, c2);
    else for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
  }
  function Ui(a2, b2, c2) {
    var d2 = a2.pingCache;
    null !== d2 && d2.delete(b2);
    b2 = L();
    a2.pingedLanes |= a2.suspendedLanes & c2;
    R === a2 && (Z2 & c2) === c2 && (4 === T || 3 === T && (Z2 & 130023424) === Z2 && 500 > B() - gk ? Lk(a2, 0) : sk |= c2);
    Ek(a2, b2);
  }
  function Zk(a2, b2) {
    0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c2 = L();
    a2 = Zg(a2, b2);
    null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
  }
  function vj(a2) {
    var b2 = a2.memoizedState, c2 = 0;
    null !== b2 && (c2 = b2.retryLane);
    Zk(a2, c2);
  }
  function ck(a2, b2) {
    var c2 = 0;
    switch (a2.tag) {
      case 13:
        var d2 = a2.stateNode;
        var e2 = a2.memoizedState;
        null !== e2 && (c2 = e2.retryLane);
        break;
      case 19:
        d2 = a2.stateNode;
        break;
      default:
        throw Error(p2(314));
    }
    null !== d2 && d2.delete(b2);
    Zk(a2, c2);
  }
  var Wk;
  Wk = function(a2, b2, c2) {
    if (null !== a2) if (a2.memoizedProps !== b2.pendingProps || Wf.current) Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128)) return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
    else Ug = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
    b2.lanes = 0;
    switch (b2.tag) {
      case 2:
        var d2 = b2.type;
        jj(a2, b2);
        a2 = b2.pendingProps;
        var e2 = Yf(b2, H2.current);
        Tg(b2, c2);
        e2 = Xh(null, b2, d2, a2, e2, c2);
        var f2 = bi();
        b2.flags |= 1;
        "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
        return b2;
      case 16:
        d2 = b2.elementType;
        a: {
          jj(a2, b2);
          a2 = b2.pendingProps;
          e2 = d2._init;
          d2 = e2(d2._payload);
          b2.type = d2;
          e2 = b2.tag = $k(d2);
          a2 = Lg(d2, a2);
          switch (e2) {
            case 0:
              b2 = dj(null, b2, d2, a2, c2);
              break a;
            case 1:
              b2 = ij(null, b2, d2, a2, c2);
              break a;
            case 11:
              b2 = Zi(null, b2, d2, a2, c2);
              break a;
            case 14:
              b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
              break a;
          }
          throw Error(p2(
            306,
            d2,
            ""
          ));
        }
        return b2;
      case 0:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
      case 1:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
      case 3:
        a: {
          lj(b2);
          if (null === a2) throw Error(p2(387));
          d2 = b2.pendingProps;
          f2 = b2.memoizedState;
          e2 = f2.element;
          bh(a2, b2);
          gh(b2, d2, null, c2);
          var g2 = b2.memoizedState;
          d2 = g2.element;
          if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p2(423)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p2(424)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
          else {
            Ig();
            if (d2 === e2) {
              b2 = $i(a2, b2, c2);
              break a;
            }
            Yi(a2, b2, d2, c2);
          }
          b2 = b2.child;
        }
        return b2;
      case 5:
        return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
      case 6:
        return null === a2 && Eg(b2), null;
      case 13:
        return pj(a2, b2, c2);
      case 4:
        return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
      case 11:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
      case 7:
        return Yi(a2, b2, b2.pendingProps, c2), b2.child;
      case 8:
        return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
      case 12:
        return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
      case 10:
        a: {
          d2 = b2.type._context;
          e2 = b2.pendingProps;
          f2 = b2.memoizedProps;
          g2 = e2.value;
          G2(Mg, d2._currentValue);
          d2._currentValue = g2;
          if (null !== f2) if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
            var h2 = f2.dependencies;
            if (null !== h2) {
              g2 = f2.child;
              for (var k2 = h2.firstContext; null !== k2; ) {
                if (k2.context === d2) {
                  if (1 === f2.tag) {
                    k2 = ch(-1, c2 & -c2);
                    k2.tag = 2;
                    var l2 = f2.updateQueue;
                    if (null !== l2) {
                      l2 = l2.shared;
                      var m2 = l2.pending;
                      null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                      l2.pending = k2;
                    }
                  }
                  f2.lanes |= c2;
                  k2 = f2.alternate;
                  null !== k2 && (k2.lanes |= c2);
                  Sg(
                    f2.return,
                    c2,
                    b2
                  );
                  h2.lanes |= c2;
                  break;
                }
                k2 = k2.next;
              }
            } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
            else if (18 === f2.tag) {
              g2 = f2.return;
              if (null === g2) throw Error(p2(341));
              g2.lanes |= c2;
              h2 = g2.alternate;
              null !== h2 && (h2.lanes |= c2);
              Sg(g2, c2, b2);
              g2 = f2.sibling;
            } else g2 = f2.child;
            if (null !== g2) g2.return = f2;
            else for (g2 = f2; null !== g2; ) {
              if (g2 === b2) {
                g2 = null;
                break;
              }
              f2 = g2.sibling;
              if (null !== f2) {
                f2.return = g2.return;
                g2 = f2;
                break;
              }
              g2 = g2.return;
            }
            f2 = g2;
          }
          Yi(a2, b2, e2.children, c2);
          b2 = b2.child;
        }
        return b2;
      case 9:
        return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
      case 14:
        return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
      case 15:
        return cj(a2, b2, b2.type, b2.pendingProps, c2);
      case 17:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
      case 19:
        return yj(a2, b2, c2);
      case 22:
        return ej(a2, b2, c2);
    }
    throw Error(p2(156, b2.tag));
  };
  function Gk(a2, b2) {
    return ac(a2, b2);
  }
  function al(a2, b2, c2, d2) {
    this.tag = a2;
    this.key = c2;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b2;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d2;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a2, b2, c2, d2) {
    return new al(a2, b2, c2, d2);
  }
  function bj(a2) {
    a2 = a2.prototype;
    return !(!a2 || !a2.isReactComponent);
  }
  function $k(a2) {
    if ("function" === typeof a2) return bj(a2) ? 1 : 0;
    if (void 0 !== a2 && null !== a2) {
      a2 = a2.$$typeof;
      if (a2 === Da) return 11;
      if (a2 === Ga) return 14;
    }
    return 2;
  }
  function wh(a2, b2) {
    var c2 = a2.alternate;
    null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
    c2.flags = a2.flags & 14680064;
    c2.childLanes = a2.childLanes;
    c2.lanes = a2.lanes;
    c2.child = a2.child;
    c2.memoizedProps = a2.memoizedProps;
    c2.memoizedState = a2.memoizedState;
    c2.updateQueue = a2.updateQueue;
    b2 = a2.dependencies;
    c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
    c2.sibling = a2.sibling;
    c2.index = a2.index;
    c2.ref = a2.ref;
    return c2;
  }
  function yh(a2, b2, c2, d2, e2, f2) {
    var g2 = 2;
    d2 = a2;
    if ("function" === typeof a2) bj(a2) && (g2 = 1);
    else if ("string" === typeof a2) g2 = 5;
    else a: switch (a2) {
      case ya:
        return Ah(c2.children, e2, f2, b2);
      case za:
        g2 = 8;
        e2 |= 8;
        break;
      case Aa:
        return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
      case Ea:
        return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
      case Fa:
        return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
      case Ia:
        return qj(c2, e2, f2, b2);
      default:
        if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
          case Ba:
            g2 = 10;
            break a;
          case Ca:
            g2 = 9;
            break a;
          case Da:
            g2 = 11;
            break a;
          case Ga:
            g2 = 14;
            break a;
          case Ha:
            g2 = 16;
            d2 = null;
            break a;
        }
        throw Error(p2(130, null == a2 ? a2 : typeof a2, ""));
    }
    b2 = Bg(g2, c2, b2, e2);
    b2.elementType = a2;
    b2.type = d2;
    b2.lanes = f2;
    return b2;
  }
  function Ah(a2, b2, c2, d2) {
    a2 = Bg(7, a2, d2, b2);
    a2.lanes = c2;
    return a2;
  }
  function qj(a2, b2, c2, d2) {
    a2 = Bg(22, a2, d2, b2);
    a2.elementType = Ia;
    a2.lanes = c2;
    a2.stateNode = { isHidden: false };
    return a2;
  }
  function xh(a2, b2, c2) {
    a2 = Bg(6, a2, null, b2);
    a2.lanes = c2;
    return a2;
  }
  function zh(a2, b2, c2) {
    b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
    b2.lanes = c2;
    b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
    return b2;
  }
  function bl(a2, b2, c2, d2, e2) {
    this.tag = b2;
    this.containerInfo = a2;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d2;
    this.onRecoverableError = e2;
    this.mutableSourceEagerHydrationData = null;
  }
  function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    a2 = new bl(a2, b2, c2, h2, k2);
    1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
    f2 = Bg(3, null, null, b2);
    a2.current = f2;
    f2.stateNode = a2;
    f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    ah(f2);
    return a2;
  }
  function dl(a2, b2, c2) {
    var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
  }
  function el(a2) {
    if (!a2) return Vf;
    a2 = a2._reactInternals;
    a: {
      if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p2(170));
      var b2 = a2;
      do {
        switch (b2.tag) {
          case 3:
            b2 = b2.stateNode.context;
            break a;
          case 1:
            if (Zf(b2.type)) {
              b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b2 = b2.return;
      } while (null !== b2);
      throw Error(p2(171));
    }
    if (1 === a2.tag) {
      var c2 = a2.type;
      if (Zf(c2)) return bg(a2, c2, b2);
    }
    return b2;
  }
  function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    a2 = cl(c2, d2, true, a2, e2, f2, g2, h2, k2);
    a2.context = el(null);
    c2 = a2.current;
    d2 = L();
    e2 = lh(c2);
    f2 = ch(d2, e2);
    f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
    dh(c2, f2, e2);
    a2.current.lanes = e2;
    Ac(a2, e2, d2);
    Ek(a2, d2);
    return a2;
  }
  function gl(a2, b2, c2, d2) {
    var e2 = b2.current, f2 = L(), g2 = lh(e2);
    c2 = el(c2);
    null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
    b2 = ch(f2, g2);
    b2.payload = { element: a2 };
    d2 = void 0 === d2 ? null : d2;
    null !== d2 && (b2.callback = d2);
    a2 = dh(e2, b2, g2);
    null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
    return g2;
  }
  function hl(a2) {
    a2 = a2.current;
    if (!a2.child) return null;
    switch (a2.child.tag) {
      case 5:
        return a2.child.stateNode;
      default:
        return a2.child.stateNode;
    }
  }
  function il(a2, b2) {
    a2 = a2.memoizedState;
    if (null !== a2 && null !== a2.dehydrated) {
      var c2 = a2.retryLane;
      a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
    }
  }
  function jl(a2, b2) {
    il(a2, b2);
    (a2 = a2.alternate) && il(a2, b2);
  }
  function kl() {
    return null;
  }
  var ll = "function" === typeof reportError ? reportError : function(a2) {
    console.error(a2);
  };
  function ml(a2) {
    this._internalRoot = a2;
  }
  nl.prototype.render = ml.prototype.render = function(a2) {
    var b2 = this._internalRoot;
    if (null === b2) throw Error(p2(409));
    gl(a2, b2, null, null);
  };
  nl.prototype.unmount = ml.prototype.unmount = function() {
    var a2 = this._internalRoot;
    if (null !== a2) {
      this._internalRoot = null;
      var b2 = a2.containerInfo;
      Sk(function() {
        gl(null, a2, null, null);
      });
      b2[uf] = null;
    }
  };
  function nl(a2) {
    this._internalRoot = a2;
  }
  nl.prototype.unstable_scheduleHydration = function(a2) {
    if (a2) {
      var b2 = Hc();
      a2 = { blockedOn: null, target: a2, priority: b2 };
      for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
      Qc.splice(c2, 0, a2);
      0 === c2 && Vc(a2);
    }
  };
  function ol(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
  }
  function pl(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
  }
  function ql() {
  }
  function rl(a2, b2, c2, d2, e2) {
    if (e2) {
      if ("function" === typeof d2) {
        var f2 = d2;
        d2 = function() {
          var a3 = hl(g2);
          f2.call(a3);
        };
      }
      var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
      a2._reactRootContainer = g2;
      a2[uf] = g2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      Sk();
      return g2;
    }
    for (; e2 = a2.lastChild; ) a2.removeChild(e2);
    if ("function" === typeof d2) {
      var h2 = d2;
      d2 = function() {
        var a3 = hl(k2);
        h2.call(a3);
      };
    }
    var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
    a2._reactRootContainer = k2;
    a2[uf] = k2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk(function() {
      gl(b2, k2, c2, d2);
    });
    return k2;
  }
  function sl(a2, b2, c2, d2, e2) {
    var f2 = c2._reactRootContainer;
    if (f2) {
      var g2 = f2;
      if ("function" === typeof e2) {
        var h2 = e2;
        e2 = function() {
          var a3 = hl(g2);
          h2.call(a3);
        };
      }
      gl(b2, g2, a2, e2);
    } else g2 = rl(c2, b2, a2, e2, d2);
    return hl(g2);
  }
  Ec = function(a2) {
    switch (a2.tag) {
      case 3:
        var b2 = a2.stateNode;
        if (b2.current.memoizedState.isDehydrated) {
          var c2 = tc(b2.pendingLanes);
          0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B()), 0 === (K2 & 6) && (Hj = B() + 500, jg()));
        }
        break;
      case 13:
        Sk(function() {
          var b3 = Zg(a2, 1);
          if (null !== b3) {
            var c3 = L();
            mh(b3, a2, 1, c3);
          }
        }), jl(a2, 1);
    }
  };
  Fc = function(a2) {
    if (13 === a2.tag) {
      var b2 = Zg(a2, 134217728);
      if (null !== b2) {
        var c2 = L();
        mh(b2, a2, 134217728, c2);
      }
      jl(a2, 134217728);
    }
  };
  Gc = function(a2) {
    if (13 === a2.tag) {
      var b2 = lh(a2), c2 = Zg(a2, b2);
      if (null !== c2) {
        var d2 = L();
        mh(c2, a2, b2, d2);
      }
      jl(a2, b2);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a2, b2) {
    var c2 = C;
    try {
      return C = a2, b2();
    } finally {
      C = c2;
    }
  };
  yb = function(a2, b2, c2) {
    switch (b2) {
      case "input":
        bb(a2, c2);
        b2 = c2.name;
        if ("radio" === c2.type && null != b2) {
          for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
          c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
          for (b2 = 0; b2 < c2.length; b2++) {
            var d2 = c2[b2];
            if (d2 !== a2 && d2.form === a2.form) {
              var e2 = Db(d2);
              if (!e2) throw Error(p2(90));
              Wa(d2);
              bb(d2, e2);
            }
          }
        }
        break;
      case "textarea":
        ib(a2, c2);
        break;
      case "select":
        b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
    }
  };
  Gb = Rk;
  Hb = Sk;
  var tl = { usingClientEntryPoint: false, Events: [Cb, ue2, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
  var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
    a2 = Zb(a2);
    return null === a2 ? null : a2.stateNode;
  }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!wl.isDisabled && wl.supportsFiber) try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
  reactDom_production_min.createPortal = function(a2, b2) {
    var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!ol(b2)) throw Error(p2(200));
    return dl(a2, b2, null, c2);
  };
  reactDom_production_min.createRoot = function(a2, b2) {
    if (!ol(a2)) throw Error(p2(299));
    var c2 = false, d2 = "", e2 = ll;
    null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
    b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
    a2[uf] = b2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    return new ml(b2);
  };
  reactDom_production_min.findDOMNode = function(a2) {
    if (null == a2) return null;
    if (1 === a2.nodeType) return a2;
    var b2 = a2._reactInternals;
    if (void 0 === b2) {
      if ("function" === typeof a2.render) throw Error(p2(188));
      a2 = Object.keys(a2).join(",");
      throw Error(p2(268, a2));
    }
    a2 = Zb(b2);
    a2 = null === a2 ? null : a2.stateNode;
    return a2;
  };
  reactDom_production_min.flushSync = function(a2) {
    return Sk(a2);
  };
  reactDom_production_min.hydrate = function(a2, b2, c2) {
    if (!pl(b2)) throw Error(p2(200));
    return sl(null, a2, b2, true, c2);
  };
  reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
    if (!ol(a2)) throw Error(p2(405));
    var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
    null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
    b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
    a2[uf] = b2.current;
    sf(a2);
    if (d2) for (a2 = 0; a2 < d2.length; a2++) c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
      c2,
      e2
    );
    return new nl(b2);
  };
  reactDom_production_min.render = function(a2, b2, c2) {
    if (!pl(b2)) throw Error(p2(200));
    return sl(null, a2, b2, false, c2);
  };
  reactDom_production_min.unmountComponentAtNode = function(a2) {
    if (!pl(a2)) throw Error(p2(40));
    return a2._reactRootContainer ? (Sk(function() {
      sl(null, null, a2, false, function() {
        a2._reactRootContainer = null;
        a2[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Rk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
    if (!pl(c2)) throw Error(p2(200));
    if (null == a2 || void 0 === a2._reactInternals) throw Error(p2(38));
    return sl(a2, b2, c2, false, d2);
  };
  reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
  return reactDom_production_min;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err2) {
      console.error(err2);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  return reactDom.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m2 = requireReactDom();
  {
    client.createRoot = m2.createRoot;
    client.hydrateRoot = m2.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
var shim = { exports: {} };
var useSyncExternalStoreShim_production = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production;
function requireUseSyncExternalStoreShim_production() {
  if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
  hasRequiredUseSyncExternalStoreShim_production = 1;
  var React2 = requireReact();
  function is2(x2, y2) {
    return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs2 = "function" === typeof Object.is ? Object.is : is2, useState = React2.useState, useEffect = React2.useEffect, useLayoutEffect = React2.useLayoutEffect, useDebugValue = React2.useDebugValue;
  function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate2 = _useState[1];
    useLayoutEffect(
      function() {
        inst.value = value;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceUpdate2({ inst });
      },
      [subscribe, value, getSnapshot]
    );
    useEffect(
      function() {
        checkIfSnapshotChanged(inst) && forceUpdate2({ inst });
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceUpdate2({ inst });
        });
      },
      [subscribe]
    );
    useDebugValue(value);
    return value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs2(inst, nextValue);
    } catch (error2) {
      return true;
    }
  }
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
  }
  var shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
  useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React2.useSyncExternalStore ? React2.useSyncExternalStore : shim2;
  return useSyncExternalStoreShim_production;
}
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim.exports;
  hasRequiredShim = 1;
  {
    shim.exports = requireUseSyncExternalStoreShim_production();
  }
  return shim.exports;
}
requireShim();
var withSelector = { exports: {} };
var withSelector_production = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_production;
function requireWithSelector_production() {
  if (hasRequiredWithSelector_production) return withSelector_production;
  hasRequiredWithSelector_production = 1;
  var React2 = requireReact(), shim2 = requireShim();
  function is2(x2, y2) {
    return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs2 = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore = shim2.useSyncExternalStore, useRef = React2.useRef, useEffect = React2.useEffect, useMemo = React2.useMemo, useDebugValue = React2.useDebugValue;
  withSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = { hasValue: false, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = true;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs2(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
            return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          null === maybeGetServerSnapshot ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(
      function() {
        inst.hasValue = true;
        inst.value = value;
      },
      [value]
    );
    useDebugValue(value);
    return value;
  };
  return withSelector_production;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  {
    withSelector.exports = requireWithSelector_production();
  }
  return withSelector.exports;
}
var withSelectorExports = requireWithSelector();
var reactDomExports = requireReactDom();
const ao = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
function defaultNoopBatch(callback) {
  callback();
}
let batch = defaultNoopBatch;
const setBatch = (newBatch) => batch = newBatch;
const getBatch = () => batch;
const ContextKey = Symbol.for("react-redux-context");
const gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  var _gT$ContextKey;
  if (!reactExports.createContext) return {};
  const contextMap = (_gT$ContextKey = gT[ContextKey]) != null ? _gT$ContextKey : gT[ContextKey] = /* @__PURE__ */ new Map();
  let realContext = contextMap.get(reactExports.createContext);
  if (!realContext) {
    realContext = reactExports.createContext(null);
    contextMap.set(reactExports.createContext, realContext);
  }
  return realContext;
}
const ReactReduxContext = /* @__PURE__ */ getContext();
function createReduxContextHook(context2 = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = reactExports.useContext(context2);
    return contextValue;
  };
}
const useReduxContext = /* @__PURE__ */ createReduxContextHook();
const notInitialized = () => {
  throw new Error("uSES not initialized!");
};
let useSyncExternalStoreWithSelector = notInitialized;
const initializeUseSelector = (fn2) => {
  useSyncExternalStoreWithSelector = fn2;
};
const refEquality = (a2, b2) => a2 === b2;
function createSelectorHook(context2 = ReactReduxContext) {
  const useReduxContext$1 = context2 === ReactReduxContext ? useReduxContext : createReduxContextHook(context2);
  return function useSelector2(selector, equalityFnOrOptions = {}) {
    const {
      equalityFn = refEquality,
      stabilityCheck = void 0,
      noopCheck = void 0
    } = typeof equalityFnOrOptions === "function" ? {
      equalityFn: equalityFnOrOptions
    } : equalityFnOrOptions;
    const {
      store,
      subscription,
      getServerState,
      stabilityCheck: globalStabilityCheck,
      noopCheck: globalNoopCheck
    } = useReduxContext$1();
    reactExports.useRef(true);
    const wrappedSelector = reactExports.useCallback({
      [selector.name](state) {
        const selected = selector(state);
        return selected;
      }
    }[selector.name], [selector, globalStabilityCheck, stabilityCheck]);
    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);
    reactExports.useDebugValue(selectedState);
    return selectedState;
  };
}
const useSelector = /* @__PURE__ */ createSelectorHook();
function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$2.apply(null, arguments);
}
function _objectWithoutPropertiesLoose$1(r2, e2) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e2.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var reactIs$1 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min$1;
function requireReactIs_production_min$1() {
  if (hasRequiredReactIs_production_min$1) return reactIs_production_min$1;
  hasRequiredReactIs_production_min$1 = 1;
  var b2 = "function" === typeof Symbol && Symbol.for, c2 = b2 ? Symbol.for("react.element") : 60103, d2 = b2 ? Symbol.for("react.portal") : 60106, e2 = b2 ? Symbol.for("react.fragment") : 60107, f2 = b2 ? Symbol.for("react.strict_mode") : 60108, g2 = b2 ? Symbol.for("react.profiler") : 60114, h2 = b2 ? Symbol.for("react.provider") : 60109, k2 = b2 ? Symbol.for("react.context") : 60110, l2 = b2 ? Symbol.for("react.async_mode") : 60111, m2 = b2 ? Symbol.for("react.concurrent_mode") : 60111, n2 = b2 ? Symbol.for("react.forward_ref") : 60112, p2 = b2 ? Symbol.for("react.suspense") : 60113, q2 = b2 ? Symbol.for("react.suspense_list") : 60120, r2 = b2 ? Symbol.for("react.memo") : 60115, t2 = b2 ? Symbol.for("react.lazy") : 60116, v2 = b2 ? Symbol.for("react.block") : 60121, w2 = b2 ? Symbol.for("react.fundamental") : 60117, x2 = b2 ? Symbol.for("react.responder") : 60118, y2 = b2 ? Symbol.for("react.scope") : 60119;
  function z2(a2) {
    if ("object" === typeof a2 && null !== a2) {
      var u2 = a2.$$typeof;
      switch (u2) {
        case c2:
          switch (a2 = a2.type, a2) {
            case l2:
            case m2:
            case e2:
            case g2:
            case f2:
            case p2:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k2:
                case n2:
                case t2:
                case r2:
                case h2:
                  return a2;
                default:
                  return u2;
              }
          }
        case d2:
          return u2;
      }
    }
  }
  function A2(a2) {
    return z2(a2) === m2;
  }
  reactIs_production_min$1.AsyncMode = l2;
  reactIs_production_min$1.ConcurrentMode = m2;
  reactIs_production_min$1.ContextConsumer = k2;
  reactIs_production_min$1.ContextProvider = h2;
  reactIs_production_min$1.Element = c2;
  reactIs_production_min$1.ForwardRef = n2;
  reactIs_production_min$1.Fragment = e2;
  reactIs_production_min$1.Lazy = t2;
  reactIs_production_min$1.Memo = r2;
  reactIs_production_min$1.Portal = d2;
  reactIs_production_min$1.Profiler = g2;
  reactIs_production_min$1.StrictMode = f2;
  reactIs_production_min$1.Suspense = p2;
  reactIs_production_min$1.isAsyncMode = function(a2) {
    return A2(a2) || z2(a2) === l2;
  };
  reactIs_production_min$1.isConcurrentMode = A2;
  reactIs_production_min$1.isContextConsumer = function(a2) {
    return z2(a2) === k2;
  };
  reactIs_production_min$1.isContextProvider = function(a2) {
    return z2(a2) === h2;
  };
  reactIs_production_min$1.isElement = function(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === c2;
  };
  reactIs_production_min$1.isForwardRef = function(a2) {
    return z2(a2) === n2;
  };
  reactIs_production_min$1.isFragment = function(a2) {
    return z2(a2) === e2;
  };
  reactIs_production_min$1.isLazy = function(a2) {
    return z2(a2) === t2;
  };
  reactIs_production_min$1.isMemo = function(a2) {
    return z2(a2) === r2;
  };
  reactIs_production_min$1.isPortal = function(a2) {
    return z2(a2) === d2;
  };
  reactIs_production_min$1.isProfiler = function(a2) {
    return z2(a2) === g2;
  };
  reactIs_production_min$1.isStrictMode = function(a2) {
    return z2(a2) === f2;
  };
  reactIs_production_min$1.isSuspense = function(a2) {
    return z2(a2) === p2;
  };
  reactIs_production_min$1.isValidElementType = function(a2) {
    return "string" === typeof a2 || "function" === typeof a2 || a2 === e2 || a2 === m2 || a2 === g2 || a2 === f2 || a2 === p2 || a2 === q2 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t2 || a2.$$typeof === r2 || a2.$$typeof === h2 || a2.$$typeof === k2 || a2.$$typeof === n2 || a2.$$typeof === w2 || a2.$$typeof === x2 || a2.$$typeof === y2 || a2.$$typeof === v2);
  };
  reactIs_production_min$1.typeOf = z2;
  return reactIs_production_min$1;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  {
    reactIs$1.exports = requireReactIs_production_min$1();
  }
  return reactIs$1.exports;
}
var hoistNonReactStatics_cjs;
var hasRequiredHoistNonReactStatics_cjs;
function requireHoistNonReactStatics_cjs() {
  if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
  hasRequiredHoistNonReactStatics_cjs = 1;
  var reactIs2 = requireReactIs$1();
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
  function getStatics(component) {
    if (reactIs2.isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf2 = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf2(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys2 = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i2 = 0; i2 < keys2.length; ++i2) {
        var key = keys2[i2];
        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
          try {
            defineProperty(targetComponent, key, descriptor);
          } catch (e2) {
          }
        }
      }
    }
    return targetComponent;
  }
  hoistNonReactStatics_cjs = hoistNonReactStatics;
  return hoistNonReactStatics_cjs;
}
var hoistNonReactStatics_cjsExports = requireHoistNonReactStatics_cjs();
const hoistStatics = /* @__PURE__ */ getDefaultExportFromCjs(hoistNonReactStatics_cjsExports);
var reactIs = { exports: {} };
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b2 = Symbol.for("react.element"), c2 = Symbol.for("react.portal"), d2 = Symbol.for("react.fragment"), e2 = Symbol.for("react.strict_mode"), f2 = Symbol.for("react.profiler"), g2 = Symbol.for("react.provider"), h2 = Symbol.for("react.context"), k2 = Symbol.for("react.server_context"), l2 = Symbol.for("react.forward_ref"), m2 = Symbol.for("react.suspense"), n2 = Symbol.for("react.suspense_list"), p2 = Symbol.for("react.memo"), q2 = Symbol.for("react.lazy"), t2 = Symbol.for("react.offscreen"), u2;
  u2 = Symbol.for("react.module.reference");
  function v2(a2) {
    if ("object" === typeof a2 && null !== a2) {
      var r2 = a2.$$typeof;
      switch (r2) {
        case b2:
          switch (a2 = a2.type, a2) {
            case d2:
            case f2:
            case e2:
            case m2:
            case n2:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k2:
                case h2:
                case l2:
                case q2:
                case p2:
                case g2:
                  return a2;
                default:
                  return r2;
              }
          }
        case c2:
          return r2;
      }
    }
  }
  reactIs_production_min.ContextConsumer = h2;
  reactIs_production_min.ContextProvider = g2;
  reactIs_production_min.Element = b2;
  reactIs_production_min.ForwardRef = l2;
  reactIs_production_min.Fragment = d2;
  reactIs_production_min.Lazy = q2;
  reactIs_production_min.Memo = p2;
  reactIs_production_min.Portal = c2;
  reactIs_production_min.Profiler = f2;
  reactIs_production_min.StrictMode = e2;
  reactIs_production_min.Suspense = m2;
  reactIs_production_min.SuspenseList = n2;
  reactIs_production_min.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min.isContextConsumer = function(a2) {
    return v2(a2) === h2;
  };
  reactIs_production_min.isContextProvider = function(a2) {
    return v2(a2) === g2;
  };
  reactIs_production_min.isElement = function(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === b2;
  };
  reactIs_production_min.isForwardRef = function(a2) {
    return v2(a2) === l2;
  };
  reactIs_production_min.isFragment = function(a2) {
    return v2(a2) === d2;
  };
  reactIs_production_min.isLazy = function(a2) {
    return v2(a2) === q2;
  };
  reactIs_production_min.isMemo = function(a2) {
    return v2(a2) === p2;
  };
  reactIs_production_min.isPortal = function(a2) {
    return v2(a2) === c2;
  };
  reactIs_production_min.isProfiler = function(a2) {
    return v2(a2) === f2;
  };
  reactIs_production_min.isStrictMode = function(a2) {
    return v2(a2) === e2;
  };
  reactIs_production_min.isSuspense = function(a2) {
    return v2(a2) === m2;
  };
  reactIs_production_min.isSuspenseList = function(a2) {
    return v2(a2) === n2;
  };
  reactIs_production_min.isValidElementType = function(a2) {
    return "string" === typeof a2 || "function" === typeof a2 || a2 === d2 || a2 === f2 || a2 === e2 || a2 === m2 || a2 === n2 || a2 === t2 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q2 || a2.$$typeof === p2 || a2.$$typeof === g2 || a2.$$typeof === h2 || a2.$$typeof === l2 || a2.$$typeof === u2 || void 0 !== a2.getModuleId) ? true : false;
  };
  reactIs_production_min.typeOf = v2;
  return reactIs_production_min;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  {
    reactIs.exports = requireReactIs_production_min();
  }
  return reactIs.exports;
}
requireReactIs();
function createListenerCollection() {
  const batch2 = getBatch();
  let first3 = null;
  let last3 = null;
  return {
    clear() {
      first3 = null;
      last3 = null;
    },
    notify() {
      batch2(() => {
        let listener = first3;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      let listeners = [];
      let listener = first3;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      let listener = last3 = {
        callback,
        next: null,
        prev: last3
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first3 = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first3 === null) return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last3 = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first3 = listener.next;
        }
      };
    }
  };
}
const nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
const canUseDOM$3 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const useIsomorphicLayoutEffect$4 = canUseDOM$3 ? reactExports.useLayoutEffect : reactExports.useEffect;
function is$2(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || y2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function shallowEqual(objA, objB) {
  if (is$2(objA, objB)) return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;
  for (let i2 = 0; i2 < keysA.length; i2++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !is$2(objA[keysA[i2]], objB[keysA[i2]])) {
      return false;
    }
  }
  return true;
}
function Provider({
  store,
  context: context2,
  children,
  serverState,
  stabilityCheck = "once",
  noopCheck = "once"
}) {
  const contextValue = reactExports.useMemo(() => {
    const subscription = createSubscription(store);
    return {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0,
      stabilityCheck,
      noopCheck
    };
  }, [store, serverState, stabilityCheck, noopCheck]);
  const previousState = reactExports.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect$4(() => {
    const {
      subscription
    } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context2 = context2 || ReactReduxContext;
  return /* @__PURE__ */ reactExports.createElement(Context2.Provider, {
    value: contextValue
  }, children);
}
function createStoreHook(context2 = ReactReduxContext) {
  const useReduxContext$1 = (
    // @ts-ignore
    context2 === ReactReduxContext ? useReduxContext : (
      // @ts-ignore
      createReduxContextHook(context2)
    )
  );
  return function useStore2() {
    const {
      store
    } = useReduxContext$1();
    return store;
  };
}
const useStore = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context2 = ReactReduxContext) {
  const useStore$1 = (
    // @ts-ignore
    context2 === ReactReduxContext ? useStore : createStoreHook(context2)
  );
  return function useDispatch2() {
    const store = useStore$1();
    return store.dispatch;
  };
}
const useDispatch = /* @__PURE__ */ createDispatchHook();
initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
setBatch(reactDomExports.unstable_batchedUpdates);
function _typeof$6(o2) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$6(o2);
}
function _classCallCheck$3(a2, n2) {
  if (!(a2 instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function toPrimitive(t2, r2) {
  if ("object" != _typeof$6(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$6(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function toPropertyKey(t2) {
  var i2 = toPrimitive(t2, "string");
  return "symbol" == _typeof$6(i2) ? i2 : i2 + "";
}
function _defineProperties$3(e2, r2) {
  for (var t2 = 0; t2 < r2.length; t2++) {
    var o2 = r2[t2];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, toPropertyKey(o2.key), o2);
  }
}
function _createClass$3(e2, r2, t2) {
  return r2 && _defineProperties$3(e2.prototype, r2), t2 && _defineProperties$3(e2, t2), Object.defineProperty(e2, "prototype", {
    writable: false
  }), e2;
}
function _assertThisInitialized$1(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function _setPrototypeOf$1(t2, e2) {
  return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf$1(t2, e2);
}
function _inherits$1(t2, e2) {
  if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
  t2.prototype = Object.create(e2 && e2.prototype, {
    constructor: {
      value: t2,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t2, "prototype", {
    writable: false
  }), e2 && _setPrototypeOf$1(t2, e2);
}
function _possibleConstructorReturn$1(t2, e2) {
  if (e2 && ("object" == _typeof$6(e2) || "function" == typeof e2)) return e2;
  if (void 0 !== e2) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$1(t2);
}
function _getPrototypeOf$1(t2) {
  return _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  }, _getPrototypeOf$1(t2);
}
function _defineProperty$6(e2, r2, t2) {
  return (r2 = toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t2, e2;
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
function _iterableToArray$2(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayLikeToArray$1(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function _unsupportedIterableToArray$1(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$1(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$1(r2, a2) : void 0;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toArray(r2) {
  return _arrayWithHoles(r2) || _iterableToArray$2(r2) || _unsupportedIterableToArray$1(r2) || _nonIterableRest();
}
function ownKeys$6(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn(args) {
    this.output("warn", args);
  },
  error: function error(args) {
    this.output("error", args);
  },
  output: function output(type, args) {
    if (console && console[type]) console[type].apply(console, args);
  }
};
var Logger = (function() {
  function Logger2(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$3(this, Logger2);
    this.init(concreteLogger, options);
  }
  _createClass$3(Logger2, [{
    key: "init",
    value: function init2(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix2, debugOnly) {
      if (debugOnly && !this.debug) return null;
      if (typeof args[0] === "string") args[0] = "".concat(prefix2).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create3(moduleName) {
      return new Logger2(this.logger, _objectSpread$6(_objectSpread$6({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function clone2(options) {
      options = options || this.options;
      options.prefix = options.prefix || this.prefix;
      return new Logger2(this.logger, options);
    }
  }]);
  return Logger2;
})();
var baseLogger = new Logger();
var EventEmitter = (function() {
  function EventEmitter2() {
    _classCallCheck$3(this, EventEmitter2);
    this.observers = {};
  }
  _createClass$3(EventEmitter2, [{
    key: "on",
    value: function on(events2, listener) {
      var _this = this;
      events2.split(" ").forEach(function(event2) {
        _this.observers[event2] = _this.observers[event2] || [];
        _this.observers[event2].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event2, listener) {
      if (!this.observers[event2]) return;
      if (!listener) {
        delete this.observers[event2];
        return;
      }
      this.observers[event2] = this.observers[event2].filter(function(l2) {
        return l2 !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event2) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event2]) {
        var cloned = [].concat(this.observers[event2]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event2].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
})();
function defer() {
  var res;
  var rej;
  var promise = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object2) {
  if (object2 == null) return "";
  return "" + object2;
}
function copy(a2, s2, t2) {
  a2.forEach(function(m2) {
    if (s2[m2]) t2[m2] = s2[m2];
  });
}
function getLastOfPath(object2, path2, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object2 || typeof object2 === "string";
  }
  var stack = typeof path2 !== "string" ? [].concat(path2) : path2.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper()) return {};
    var key = cleanKey(stack.shift());
    if (!object2[key] && Empty) object2[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object2, key)) {
      object2 = object2[key];
    } else {
      object2 = {};
    }
  }
  if (canNotTraverseDeeper()) return {};
  return {
    obj: object2,
    k: cleanKey(stack.shift())
  };
}
function setPath(object2, path2, newValue) {
  var _getLastOfPath = getLastOfPath(object2, path2, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
  obj[k2] = newValue;
}
function pushPath(object2, path2, newValue, concat2) {
  var _getLastOfPath2 = getLastOfPath(object2, path2, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
  obj[k2] = obj[k2] || [];
  obj[k2].push(newValue);
}
function getPath(object2, path2) {
  var _getLastOfPath3 = getLastOfPath(object2, path2), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
  if (!obj) return void 0;
  return obj[k2];
}
function getPathWithDefaults(data, defaultData2, key) {
  var value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData2, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape$1(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, function(s2) {
      return _entityMap[s2];
    });
  }
  return data;
}
var isIE10 = typeof window !== "undefined" && window.navigator && typeof window.navigator.userAgentData === "undefined" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c2) {
    return nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0;
  });
  if (possibleChars.length === 0) return true;
  var r2 = new RegExp("(".concat(possibleChars.map(function(c2) {
    return c2 === "?" ? "\\?" : c2;
  }).join("|"), ")"));
  var matched = !r2.test(key);
  if (!matched) {
    var ki = key.indexOf(keySeparator);
    if (ki > 0 && !r2.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}
function deepFind(obj, path2) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path2]) return obj[path2];
  var paths = path2.split(keySeparator);
  var current2 = obj;
  for (var i2 = 0; i2 < paths.length; ++i2) {
    if (!current2) return void 0;
    if (typeof current2[paths[i2]] === "string" && i2 + 1 < paths.length) {
      return void 0;
    }
    if (current2[paths[i2]] === void 0) {
      var j2 = 2;
      var p2 = paths.slice(i2, i2 + j2).join(keySeparator);
      var mix = current2[p2];
      while (mix === void 0 && paths.length > i2 + j2) {
        j2++;
        p2 = paths.slice(i2, i2 + j2).join(keySeparator);
        mix = current2[p2];
      }
      if (mix === void 0) return void 0;
      if (mix === null) return null;
      if (path2.endsWith(p2)) {
        if (typeof mix === "string") return mix;
        if (p2 && typeof mix[p2] === "string") return mix[p2];
      }
      var joinedPath = paths.slice(i2 + j2).join(keySeparator);
      if (joinedPath) return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current2 = current2[paths[i2]];
  }
  return current2;
}
function ownKeys$5$1(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$5$1(Object(source), true).forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ResourceStore = (function(_EventEmitter) {
  _inherits$1(ResourceStore2, _EventEmitter);
  var _super = _createSuper$3(ResourceStore2);
  function ResourceStore2(data) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck$3(this, ResourceStore2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized$1(_this));
    }
    _this.data = data || {};
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    if (_this.options.ignoreJSONStructure === void 0) {
      _this.options.ignoreJSONStructure = true;
    }
    return _this;
  }
  _createClass$3(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index = this.options.ns.indexOf(ns);
      if (index > -1) {
        this.options.ns.splice(index, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path2 = [lng, ns];
      if (key && typeof key !== "string") path2 = path2.concat(key);
      if (key && typeof key === "string") path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
      }
      var result = getPath(this.data, path2);
      if (result || !ignoreJSONStructure || typeof key !== "string") return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0) keySeparator = ".";
      var path2 = [lng, ns];
      if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        value = ns;
        ns = path2[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path2, value);
      if (!options.silent) this.emit("added", lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m2 in resources) {
        if (typeof resources[m2] === "string" || Object.prototype.toString.apply(resources[m2]) === "[object Array]") this.addResource(lng, ns, m2, resources[m2], {
          silent: true
        });
      }
      if (!options.silent) this.emit("added", lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path2 = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        deep = resources;
        resources = ns;
        ns = path2[1];
      }
      this.addNamespaces(ns);
      var pack = getPath(this.data, path2) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread$5(_objectSpread$5({}, pack), resources);
      }
      setPath(this.data, path2, pack);
      if (!options.silent) this.emit("added", lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns) ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1") return _objectSpread$5(_objectSpread$5({}, {}), this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data = this.getDataByLanguage(lng);
      var n2 = data && Object.keys(data) || [];
      return !!n2.find(function(v2) {
        return data[v2] && Object.keys(data[v2]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
})(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
function ownKeys$4$1(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$4$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$4$1(Object(source), true).forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var checkedLoadedFor = {};
var Translator = (function(_EventEmitter) {
  _inherits$1(Translator2, _EventEmitter);
  var _super = _createSuper$2(Translator2);
  function Translator2(services) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$3(this, Translator2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized$1(_this));
    }
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized$1(_this));
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass$3(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng) this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0) nsSeparator = ":";
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m2 = key.match(this.interpolator.nestingRegexp);
        if (m2 && m2.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string") namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate2(keys2, options, lastKey) {
      var _this2 = this;
      if (_typeof$6(options) !== "object" && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (_typeof$6(options) === "object") options = _objectSpread$4$1({}, options);
      if (!options) options = {};
      if (keys2 === void 0 || keys2 === null) return "";
      if (!Array.isArray(keys2)) keys2 = [String(keys2)];
      var returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys2[keys2.length - 1], options), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
          if (returnDetails) {
            return {
              res: "".concat(namespace).concat(nsSeparator).concat(key),
              usedKey: key,
              exactUsedKey: key,
              usedLng: lng,
              usedNS: namespace
            };
          }
          return "".concat(namespace).concat(nsSeparator).concat(key);
        }
        if (returnDetails) {
          return {
            res: key,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace
          };
        }
        return key;
      }
      var resolved = this.resolve(keys2, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          var r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$4$1(_objectSpread$4$1({}, options), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
          if (returnDetails) {
            resolved.res = r2;
            return resolved;
          }
          return r2;
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m2 in res) {
            if (Object.prototype.hasOwnProperty.call(res, m2)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m2);
              copy2[m2] = this.translate(deepKey, _objectSpread$4$1(_objectSpread$4$1({}, options), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m2] === deepKey) copy2[m2] = res[m2];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res) res = this.extendTranslation(res, keys2, options, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
        var defaultValue2 = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue2;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        var updateMissing = hasDefaultValue && defaultValue2 !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue2 : res);
          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread$4$1(_objectSpread$4$1({}, options), {}, {
              keySeparator: false
            }));
            if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i2 = 0; i2 < fallbackLngs.length; i2++) {
              lngs.push(fallbackLngs[i2]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }
          var send = function send2(l2, k2, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
            }
            _this2.emit("missingKey", l2, namespace, k2, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language, options).forEach(function(suffix) {
                  send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue2);
                });
              });
            } else {
              send(lngs, key, defaultValue2);
            }
          }
        }
        res = this.extendTranslation(res, keys2, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key);
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      if (returnDetails) {
        resolved.res = res;
        return resolved;
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$4$1(_objectSpread$4$1({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation) this.interpolator.init(_objectSpread$4$1(_objectSpread$4$1({}, options), {
          interpolation: _objectSpread$4$1(_objectSpread$4$1({}, this.options.interpolation), options.interpolation)
        }));
        var skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;
        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }
        var data = options.replace && typeof options.replace !== "string" ? options.replace : options;
        if (this.options.interpolation.defaultVariables) data = _objectSpread$4$1(_objectSpread$4$1({}, this.options.interpolation.defaultVariables), data);
        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft) options.nest = false;
        }
        if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res) options.lng = resolved.usedLng;
        if (options.nest !== false) res = this.interpolator.nest(res, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (lastKey && lastKey[0] === args[0] && !options.context) {
            _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
            return null;
          }
          return _this3.translate.apply(_this3, args.concat([key]));
        }, options);
        if (options.interpolation) this.interpolator.reset();
      }
      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$4$1({
          i18nResolved: resolved
        }, options) : options, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys2) {
      var _this4 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys2 === "string") keys2 = [keys2];
      keys2.forEach(function(k2) {
        if (_this4.isValidLookup(found)) return;
        var extracted = _this4.extractFromKey(k2, options);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
        var needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function(ns) {
          if (_this4.isValidLookup(found)) return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), '" won\'t get resolved as namespace "').concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code) {
            if (_this4.isValidLookup(found)) return;
            usedLng = code;
            var finalKeys = [key];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);
              var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                finalKeys.push(contextKey);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
      return this.resourceStore.getResource(code, ns, key, options);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options) {
      var prefix2 = "defaultValue";
      for (var option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option) && prefix2 === option.substring(0, prefix2.length) && void 0 !== options[option]) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
})(EventEmitter);
function capitalize$1(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
var LanguageUtil = (function() {
  function LanguageUtil2(options) {
    _classCallCheck$3(this, LanguageUtil2);
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass$3(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf("-") < 0) return null;
      var p2 = code.split("-");
      if (p2.length === 2) return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x") return null;
      return this.formatLanguageCode(p2.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf("-") < 0) return code;
      var p2 = code.split("-");
      return this.formatLanguageCode(p2[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p2 = code.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1) p2[1] = capitalize$1(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2) p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2) p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1) p2[1] = capitalize$1(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1) p2[2] = capitalize$1(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes) return null;
      var found;
      codes.forEach(function(code) {
        if (found) return;
        var cleanedLng = _this.formatLanguageCode(code);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code) {
          if (found) return;
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly)) return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng === lngOnly) return supportedLng;
            if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
            if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
          });
        });
      }
      if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks) return [];
      if (typeof fallbacks === "function") fallbacks = fallbacks(code);
      if (typeof fallbacks === "string") fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]") return fallbacks;
      if (!code) return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found) found = fallbacks[this.formatLanguageCode(code)];
      if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found) found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];
      var addCode = function addCode2(c2) {
        if (!c2) return;
        if (_this2.isSupportedCode(c2)) {
          codes.push(c2);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c2));
        }
      };
      if (typeof code === "string" && code.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === "string") {
        addCode(this.formatLanguageCode(code));
      }
      fallbackCodes.forEach(function(fc) {
        if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
})();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n2) {
    return Number(n2 > 1);
  },
  2: function _2(n2) {
    return Number(n2 != 1);
  },
  3: function _3(n2) {
    return 0;
  },
  4: function _4(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function _5(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function _6(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function _7(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function _8(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function _9(n2) {
    return Number(n2 >= 2);
  },
  10: function _10(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function _11(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function _12(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function _13(n2) {
    return Number(n2 !== 0);
  },
  14: function _14(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function _15(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function _16(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function _17(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function _18(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function _19(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function _20(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function _21(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function _22(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ["v1", "v2", "v3"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  sets.forEach(function(set3) {
    set3.lngs.forEach(function(l2) {
      rules[l2] = {
        numbers: set3.nr,
        plurals: _rulesPluralsTypes[set3.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = (function() {
  function PluralResolver2(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$3(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  _createClass$3(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code, {
            type: options.ordinal ? "ordinal" : "cardinal"
          });
        } catch (_unused) {
          return;
        }
      }
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code, options).map(function(suffix) {
        return "".concat(key).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function(pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }
      return rule.numbers.map(function(number2) {
        return _this.getSuffix(code, number2, options);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var rule = this.getRule(code, options);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count2));
        }
        return this.getSuffixRetroCompatible(rule, count2);
      }
      this.logger.warn("no plural rule found for: ".concat(code));
      return "";
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count2) {
      var _this2 = this;
      var idx = rule.noAbs ? rule.plurals(count2) : rule.plurals(Math.abs(count2));
      var suffix = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = "plural";
        } else if (suffix === 1) {
          suffix = "";
        }
      }
      var returnSuffix = function returnSuffix2() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };
      if (this.options.compatibilityJSON === "v1") {
        if (suffix === 1) return "";
        if (typeof suffix === "number") return "_plural_".concat(suffix.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);
  return PluralResolver2;
})();
function ownKeys$3$1(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$3$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$3$1(Object(source), true).forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function deepFindWithDefaults(data, defaultData2, key) {
  var keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  var ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  var path2 = getPathWithDefaults(data, defaultData2, key);
  if (!path2 && ignoreJSONStructure && typeof key === "string") {
    path2 = deepFind(data, key, keySeparator);
    if (path2 === void 0) path2 = deepFind(defaultData2, key, keySeparator);
  }
  return path2;
}
var Interpolator = (function() {
  function Interpolator2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck$3(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || function(value) {
      return value;
    };
    this.init(options);
  }
  _createClass$3(Interpolator2, [{
    key: "init",
    value: function init2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options.interpolation) options.interpolation = {
        escapeValue: true
      };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape$1;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset2() {
      if (this.options) this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options) {
      var _this = this;
      var match2;
      var value;
      var replaces;
      var defaultData2 = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path2 = deepFindWithDefaults(data, defaultData2, key, _this.options.keySeparator, _this.options.ignoreJSONStructure);
          return _this.alwaysFormat ? _this.format(path2, void 0, lng, _objectSpread$3$1(_objectSpread$3$1(_objectSpread$3$1({}, options), data), {}, {
            interpolationkey: key
          })) : path2;
        }
        var p2 = key.split(_this.formatSeparator);
        var k2 = p2.shift().trim();
        var f2 = p2.join(_this.formatSeparator).trim();
        return _this.format(deepFindWithDefaults(data, defaultData2, k2, _this.options.keySeparator, _this.options.ignoreJSONStructure), f2, lng, _objectSpread$3$1(_objectSpread$3$1(_objectSpread$3$1({}, options), data), {}, {
          interpolationkey: k2
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match2 = todo.regex.exec(str)) {
          var matchedVar = match2[1].trim();
          value = handleFormat(matchedVar);
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match2, options);
              value = typeof temp === "string" ? temp : "";
            } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
              value = "";
            } else if (skipOnVariables) {
              value = match2[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          var safeValue = todo.safeValue(value);
          str = str.replace(match2[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += value.length;
            todo.regex.lastIndex -= match2[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match2;
      var value;
      var clonedOptions;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0) return key;
        var c2 = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c2[1]);
        key = c2[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        var matchedSingleQuotes = optionsString.match(/'/g);
        var matchedDoubleQuotes = optionsString.match(/"/g);
        if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
          optionsString = optionsString.replace(/'/g, '"');
        }
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions) clonedOptions = _objectSpread$3$1(_objectSpread$3$1({}, inheritedOptions), clonedOptions);
        } catch (e2) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e2);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match2 = this.nestingRegexp.exec(str)) {
        var formatters2 = [];
        clonedOptions = _objectSpread$3$1({}, options);
        clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
        clonedOptions.applyPostProcessor = false;
        delete clonedOptions.defaultValue;
        var doReduce = false;
        if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
          var r2 = match2[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match2[1] = r2.shift();
          formatters2 = r2;
          doReduce = true;
        }
        value = fc(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions);
        if (value && match2[0] === str && typeof value !== "string") return value;
        if (typeof value !== "string") value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match2[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters2.reduce(function(v2, f2) {
            return _this2.format(v2, f2, options.lng, _objectSpread$3$1(_objectSpread$3$1({}, options), {}, {
              interpolationkey: match2[1].trim()
            }));
          }, value.trim());
        }
        str = str.replace(match2[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
})();
function ownKeys$2$1(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$2$1(Object(source), true).forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    var optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (!opt) return;
        var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key = _opt$split2[0], rest2 = _opt$split2.slice(1);
        var val = rest2.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;
        if (val === "false") formatOptions[key.trim()] = false;
        if (val === "true") formatOptions[key.trim()] = true;
        if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
function createCachedFormatter(fn2) {
  var cache2 = {};
  return function invokeFormatter(val, lng, options) {
    var key = lng + JSON.stringify(options);
    var formatter = cache2[key];
    if (!formatter) {
      formatter = fn2(lng, options);
      cache2[key] = formatter;
    }
    return formatter(val);
  };
}
var Formatter = (function() {
  function Formatter2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck$3(this, Formatter2);
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.NumberFormat(lng, _objectSpread$2$1({}, opt));
        return function(val) {
          return formatter.format(val);
        };
      }),
      currency: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.NumberFormat(lng, _objectSpread$2$1(_objectSpread$2$1({}, opt), {}, {
          style: "currency"
        }));
        return function(val) {
          return formatter.format(val);
        };
      }),
      datetime: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.DateTimeFormat(lng, _objectSpread$2$1({}, opt));
        return function(val) {
          return formatter.format(val);
        };
      }),
      relativetime: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.RelativeTimeFormat(lng, _objectSpread$2$1({}, opt));
        return function(val) {
          return formatter.format(val, opt.range || "day");
        };
      }),
      list: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.ListFormat(lng, _objectSpread$2$1({}, opt));
        return function(val) {
          return formatter.format(val);
        };
      })
    };
    this.init(options);
  }
  _createClass$3(Formatter2, [{
    key: "init",
    value: function init2(services) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function add2(name, fc) {
      this.formats[name.toLowerCase().trim()] = fc;
    }
  }, {
    key: "addCached",
    value: function addCached(name, fc) {
      this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
    }
  }, {
    key: "format",
    value: function format2(value, _format, lng) {
      var _this = this;
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var formats = _format.split(this.formatSeparator);
      var result = formats.reduce(function(mem, f2) {
        var _parseFormatStr = parseFormatStr(f2), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
            var l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
            formatted = _this.formats[formatName](mem, l2, _objectSpread$2$1(_objectSpread$2$1(_objectSpread$2$1({}, formatOptions), options), valOptions));
          } catch (error2) {
            _this.logger.warn(error2);
          }
          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }
        return mem;
      }, value);
      return result;
    }
  }]);
  return Formatter2;
})();
function ownKeys$1$1(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1$1(Object(source), true).forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function removePending(q2, name) {
  if (q2.pending[name] !== void 0) {
    delete q2.pending[name];
    q2.pendingCount--;
  }
}
var Connector = (function(_EventEmitter) {
  _inherits$1(Connector2, _EventEmitter);
  var _super = _createSuper$1(Connector2);
  function Connector2(backend, store, services) {
    var _this;
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck$3(this, Connector2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized$1(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create("backendConnector");
    _this.waitingReads = [];
    _this.maxParallelReads = options.maxParallelReads || 10;
    _this.readingCalls = 0;
    _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }
    return _this;
  }
  _createClass$3(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options, callback) {
      var _this2 = this;
      var toLoad = {};
      var pending = {};
      var toLoadLanguages = {};
      var toLoadNamespaces = {};
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns) {
          var name = "".concat(lng, "|").concat(ns);
          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0) ;
          else if (_this2.state[name] === 1) {
            if (pending[name] === void 0) pending[name] = true;
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending[name] === void 0) pending[name] = true;
            if (toLoad[name] === void 0) toLoad[name] = true;
            if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces) toLoadLanguages[lng] = true;
      });
      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err2, data) {
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      if (err2) this.emit("failedLoading", lng, ns, err2);
      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      }
      this.state[name] = err2 ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q2) {
        pushPath(q2.loaded, [lng], ns);
        removePending(q2, name);
        if (err2) q2.errors.push(err2);
        if (q2.pendingCount === 0 && !q2.done) {
          Object.keys(q2.loaded).forEach(function(l2) {
            if (!loaded2[l2]) loaded2[l2] = {};
            var loadedKeys = q2.loaded[l2];
            if (loadedKeys.length) {
              loadedKeys.forEach(function(n2) {
                if (loaded2[l2][n2] === void 0) loaded2[l2][n2] = true;
              });
            }
          });
          q2.done = true;
          if (q2.errors.length) {
            q2.callback(q2.errors);
          } else {
            q2.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q2) {
        return !q2.done;
      });
    }
  }, {
    key: "read",
    value: function read2(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
      var callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length) return callback(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng,
          ns,
          fcName,
          tried,
          wait,
          callback
        });
        return;
      }
      this.readingCalls++;
      var resolver = function resolver2(err2, data) {
        _this3.readingCalls--;
        if (_this3.waitingReads.length > 0) {
          var next = _this3.waitingReads.shift();
          _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
        }
        if (err2 && data && tried < _this3.maxRetries) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err2, data);
      };
      var fc = this.backend[fcName].bind(this.backend);
      if (fc.length === 2) {
        try {
          var r2 = fc(lng, ns);
          if (r2 && typeof r2.then === "function") {
            r2.then(function(data) {
              return resolver(null, data);
            })["catch"](resolver);
          } else {
            resolver(null, r2);
          }
        } catch (err2) {
          resolver(err2);
        }
        return;
      }
      return fc(lng, ns, resolver);
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages === "string") languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string") namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length) callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      this.read(lng, ns, "read", void 0, void 0, function(err2, data) {
        if (err2) _this5.logger.warn("".concat(prefix2, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err2);
        if (!err2 && data) _this5.logger.log("".concat(prefix2, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
        _this5.loaded(name, err2, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      var clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : function() {
      };
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "") return;
      if (this.backend && this.backend.create) {
        var opts = _objectSpread$1$1(_objectSpread$1$1({}, options), {}, {
          isUpdate
        });
        var fc = this.backend.create.bind(this.backend);
        if (fc.length < 6) {
          try {
            var r2;
            if (fc.length === 5) {
              r2 = fc(languages, namespace, key, fallbackValue, opts);
            } else {
              r2 = fc(languages, namespace, key, fallbackValue);
            }
            if (r2 && typeof r2.then === "function") {
              r2.then(function(data) {
                return clb(null, data);
              })["catch"](clb);
            } else {
              clb(null, r2);
            }
          } catch (err2) {
            clb(err2);
          }
        } else {
          fc(languages, namespace, key, fallbackValue, clb, opts);
        }
      }
      if (!languages || !languages[0]) return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
})(EventEmitter);
function get$3() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof$6(args[1]) === "object") ret = args[1];
      if (typeof args[1] === "string") ret.defaultValue = args[1];
      if (typeof args[2] === "string") ret.tDescription = args[2];
      if (_typeof$6(args[2]) === "object" || _typeof$6(args[3]) === "object") {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function(key) {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format2(value, _format, lng, options) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string") options.ns = [options.ns];
  if (typeof options.fallbackLng === "string") options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string") options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function ownKeys$7(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$7(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$7(Object(source), true).forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function noop$3() {
}
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = (function(_EventEmitter) {
  _inherits$1(I18n2, _EventEmitter);
  var _super = _createSuper(I18n2);
  function I18n2() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck$3(this, I18n2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized$1(_this));
    }
    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized$1(_this));
    if (callback && !_this.isInitialized && !options.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options, callback);
        return _possibleConstructorReturn$1(_this, _assertThisInitialized$1(_this));
      }
      setTimeout(function() {
        _this.init(options, callback);
      }, 0);
    }
    return _this;
  }
  _createClass$3(I18n2, [{
    key: "init",
    value: function init2() {
      var _this2 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!options.defaultNS && options.defaultNS !== false && options.ns) {
        if (typeof options.ns === "string") {
          options.defaultNS = options.ns;
        } else if (options.ns.indexOf("translation") < 0) {
          options.defaultNS = options.ns[0];
        }
      }
      var defOpts = get$3();
      this.options = _objectSpread$7(_objectSpread$7(_objectSpread$7({}, defOpts), this.options), transformOptions(options));
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = _objectSpread$7(_objectSpread$7({}, defOpts.interpolation), this.options.interpolation);
      }
      if (options.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options.keySeparator;
      }
      if (options.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options.nsSeparator;
      }
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject) return null;
        if (typeof ClassOrObject === "function") return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s2 = this.services;
        s2.logger = baseLogger;
        s2.resourceStore = this.store;
        s2.languageUtils = lu;
        s2.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s2.formatter = createClassOnDemand(formatter);
          s2.formatter.init(s2, this.options);
          this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
        }
        s2.interpolator = new Interpolator(this.options);
        s2.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
        s2.backendConnector.on("*", function(event2) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event2].concat(args));
        });
        if (this.modules.languageDetector) {
          s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
          if (s2.languageDetector.init) s2.languageDetector.init(s2, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s2.i18nFormat.init) s2.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event2) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event2].concat(args));
        });
        this.modules.external.forEach(function(m2) {
          if (m2.init) m2.init(_this2);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback) callback = noop$3;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish = function finish2(err2, t2) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce) _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone) _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t2);
          callback(err2, t2);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$3;
      var usedCallback = callback;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function") usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode") return usedCallback();
        var toLoad = [];
        var append = function append2(lng) {
          if (!lng) return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l2) {
            if (toLoad.indexOf(l2) < 0) toLoad.push(l2);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l2) {
            return append(l2);
          });
        } else {
          append(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l2) {
            return append(l2);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, function(e2) {
          if (!e2 && !_this3.resolvedLanguage && _this3.language) _this3.setResolvedLanguage(_this3.language);
          usedCallback(e2);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs) lngs = this.languages;
      if (!ns) ns = this.options.ns;
      if (!callback) callback = noop$3;
      this.services.backendConnector.reload(lngs, ns, function(err2) {
        deferred.resolve();
        callback(err2);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module.type === "backend") {
        this.modules.backend = module;
      }
      if (module.type === "logger" || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }
      if (module.type === "languageDetector") {
        this.modules.languageDetector = module;
      }
      if (module.type === "i18nFormat") {
        this.modules.i18nFormat = module;
      }
      if (module.type === "postProcessor") {
        postProcessor.addPostProcessor(module);
      }
      if (module.type === "formatter") {
        this.modules.formatter = module;
      }
      if (module.type === "3rdParty") {
        this.modules.external.push(module);
      }
      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l2) {
      if (!l2 || !this.languages) return;
      if (["cimode", "dev"].indexOf(l2) > -1) return;
      for (var li = 0; li < this.languages.length; li++) {
        var lngInLngs = this.languages[li];
        if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = function setLngProps2(l2) {
        _this4.language = l2;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l2);
        _this4.resolvedLanguage = void 0;
        _this4.setResolvedLanguage(l2);
      };
      var done = function done2(err2, l2) {
        if (l2) {
          setLngProps(l2);
          _this4.translator.changeLanguage(l2);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l2);
          _this4.logger.log("languageChanged", l2);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback) callback(err2, function() {
          return _this4.t.apply(_this4, arguments);
        });
      };
      var setLng = function setLng2(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector) lngs = [];
        var l2 = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l2) {
          if (!_this4.language) {
            setLngProps(l2);
          }
          if (!_this4.translator.language) _this4.translator.changeLanguage(l2);
          if (_this4.services.languageDetector && _this4.services.languageDetector.cacheUserLanguage) _this4.services.languageDetector.cacheUserLanguage(l2);
        }
        _this4.loadResources(l2, function(err2) {
          done(err2, l2);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        if (this.services.languageDetector.detect.length === 0) {
          this.services.languageDetector.detect().then(setLng);
        } else {
          this.services.languageDetector.detect(setLng);
        }
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns, keyPrefix) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options;
        if (_typeof$6(opts) !== "object") {
          for (var _len3 = arguments.length, rest2 = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest2[_key3 - 2] = arguments[_key3];
          }
          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest2));
        } else {
          options = _objectSpread$7({}, opts);
        }
        options.lng = options.lng || fixedT2.lng;
        options.lngs = options.lngs || fixedT2.lngs;
        options.ns = options.ns || fixedT2.ns;
        options.keyPrefix = options.keyPrefix || keyPrefix || fixedT2.keyPrefix;
        var keySeparator = _this5.options.keySeparator || ".";
        var resultKey;
        if (options.keyPrefix && Array.isArray(key)) {
          resultKey = key.map(function(k2) {
            return "".concat(options.keyPrefix).concat(keySeparator).concat(k2);
          });
        } else {
          resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
        }
        return _this5.t(resultKey, options);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t2() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace2(ns) {
      var _this6 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = options.lng || this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode") return true;
      var loadNotPending = function loadNotPending2(l2, n2) {
        var loadState = _this6.services.backendConnector.state["".concat(l2, "|").concat(n2)];
        return loadState === -1 || loadState === 2;
      };
      if (options.precheck) {
        var preResult = options.precheck(this, loadNotPending);
        if (preResult !== void 0) return preResult;
      }
      if (this.hasResourceBundle(lng, ns)) return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces2(ns, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        if (callback) callback();
        return Promise.resolve();
      }
      if (typeof ns === "string") ns = [ns];
      ns.forEach(function(n2) {
        if (_this7.options.ns.indexOf(n2) < 0) _this7.options.ns.push(n2);
      });
      this.loadResources(function(err2) {
        deferred.resolve();
        if (callback) callback(err2);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages2(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string") lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback) callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err2) {
        deferred.resolve();
        if (callback) callback(err2);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng) return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      var languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get$3());
      return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$3;
      var mergedOptions = _objectSpread$7(_objectSpread$7(_objectSpread$7({}, this.options), options), {
        isClone: true
      });
      var clone2 = new I18n2(mergedOptions);
      if (options.debug !== void 0 || options.prefix !== void 0) {
        clone2.logger = clone2.logger.clone(options);
      }
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m2) {
        clone2[m2] = _this8[m2];
      });
      clone2.services = _objectSpread$7({}, this.services);
      clone2.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      clone2.translator = new Translator(clone2.services, clone2.options);
      clone2.translator.on("*", function(event2) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone2.emit.apply(clone2, [event2].concat(args));
      });
      clone2.init(mergedOptions, callback);
      clone2.translator.options = clone2.options;
      clone2.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      return clone2;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);
  return I18n2;
})(EventEmitter);
_defineProperty$6(I18n, "createInstance", function() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var callback = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options, callback);
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
var t = instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
function warn2() {
  if (console && console.warn) {
    var _console;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "string") args[0] = "react-i18next:: ".concat(args[0]);
    (_console = console).warn.apply(_console, args);
  }
}
var alreadyWarned = {};
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "string" && alreadyWarned[args[0]]) return;
  if (typeof args[0] === "string") alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
  warn2.apply(void 0, args);
}
var loadedClb = function loadedClb2(i18n, cb) {
  return function() {
    if (i18n.isInitialized) {
      cb();
    } else {
      var initialized = function initialized2() {
        setTimeout(function() {
          i18n.off("initialized", initialized2);
        }, 0);
        cb();
      };
      i18n.on("initialized", initialized);
    }
  };
};
function loadNamespaces(i18n, ns, cb) {
  i18n.loadNamespaces(ns, loadedClb(i18n, cb));
}
function loadLanguages(i18n, lng, ns, cb) {
  if (typeof ns === "string") ns = [ns];
  ns.forEach(function(n2) {
    if (i18n.options.ns.indexOf(n2) < 0) i18n.options.ns.push(n2);
  });
  i18n.loadLanguages(lng, loadedClb(i18n, cb));
}
function oldI18nextHasLoadedNamespace(ns, i18n) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var lng = i18n.languages[0];
  var fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
  var lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode") return true;
  var loadNotPending = function loadNotPending2(l2, n2) {
    var loadState = i18n.services.backendConnector.state["".concat(l2, "|").concat(n2)];
    return loadState === -1 || loadState === 2;
  };
  if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns)) return false;
  if (i18n.hasResourceBundle(lng, ns)) return true;
  if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages) return true;
  if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
  return false;
}
function hasLoadedNamespace(ns, i18n) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  var isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
  if (!isNewerI18next) {
    return oldI18nextHasLoadedNamespace(ns, i18n, options);
  }
  return i18n.hasLoadedNamespace(ns, {
    lng: options.lng,
    precheck: function precheck(i18nInstance2, loadNotPending) {
      if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns)) return false;
    }
  });
}
var matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
var htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "",
  "&#169;": "",
  "&reg;": "",
  "&#174;": "",
  "&hellip;": "",
  "&#8230;": "",
  "&#x2F;": "/",
  "&#47;": "/"
};
var unescapeHtmlEntity = function unescapeHtmlEntity2(m2) {
  return htmlEntities[m2];
};
var unescape = function unescape2(text) {
  return text.replace(matchHtmlEntity, unescapeHtmlEntity);
};
function ownKeys$5(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty$6(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var defaultOptions$3 = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape
};
function setDefaults() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  defaultOptions$3 = _objectSpread$4(_objectSpread$4({}, defaultOptions$3), options);
}
function getDefaults$2() {
  return defaultOptions$3;
}
var i18nInstance;
function setI18n(instance2) {
  i18nInstance = instance2;
}
function getI18n() {
  return i18nInstance;
}
var initReactI18next = {
  type: "3rdParty",
  init: function init(instance2) {
    setDefaults(instance2.options.react);
    setI18n(instance2);
  }
};
var I18nContext = reactExports.createContext();
var ReportNamespaces = (function() {
  function ReportNamespaces2() {
    _classCallCheck$3(this, ReportNamespaces2);
    this.usedNamespaces = {};
  }
  _createClass$3(ReportNamespaces2, [{
    key: "addUsedNamespaces",
    value: function addUsedNamespaces(namespaces) {
      var _this = this;
      namespaces.forEach(function(ns) {
        if (!_this.usedNamespaces[ns]) _this.usedNamespaces[ns] = true;
      });
    }
  }, {
    key: "getUsedNamespaces",
    value: function getUsedNamespaces() {
      return Object.keys(this.usedNamespaces);
    }
  }]);
  return ReportNamespaces2;
})();
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _slicedToArray(r2, e2) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray$1(r2, e2) || _nonIterableRest();
}
function ownKeys$4(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty$6(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var usePrevious$1 = function usePrevious(value, ignore) {
  var ref = reactExports.useRef();
  reactExports.useEffect(function() {
    ref.current = value;
  }, [value, ignore]);
  return ref.current;
};
function useTranslation(ns) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var i18nFromProps = props.i18n;
  var _ref = reactExports.useContext(I18nContext) || {}, i18nFromContext = _ref.i18n, defaultNSFromContext = _ref.defaultNS;
  var i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    var notReadyT = function notReadyT2(k2, optsOrDefaultValue) {
      if (typeof optsOrDefaultValue === "string") return optsOrDefaultValue;
      if (optsOrDefaultValue && _typeof$6(optsOrDefaultValue) === "object" && typeof optsOrDefaultValue.defaultValue === "string") return optsOrDefaultValue.defaultValue;
      return Array.isArray(k2) ? k2[k2.length - 1] : k2;
    };
    var retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react && i18n.options.react.wait !== void 0) warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  var i18nOptions = _objectSpread$3(_objectSpread$3(_objectSpread$3({}, getDefaults$2()), i18n.options.react), props);
  var useSuspense = i18nOptions.useSuspense, keyPrefix = i18nOptions.keyPrefix;
  var namespaces = defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  if (i18n.reportNamespaces.addUsedNamespaces) i18n.reportNamespaces.addUsedNamespaces(namespaces);
  var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function(n2) {
    return hasLoadedNamespace(n2, i18n, i18nOptions);
  });
  function getT() {
    return i18n.getFixedT(props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  var _useState = reactExports.useState(getT), _useState2 = _slicedToArray(_useState, 2), t2 = _useState2[0], setT = _useState2[1];
  var joinedNS = namespaces.join();
  if (props.lng) joinedNS = "".concat(props.lng).concat(joinedNS);
  var previousJoinedNS = usePrevious$1(joinedNS);
  var isMounted = reactExports.useRef(true);
  reactExports.useEffect(function() {
    var bindI18n = i18nOptions.bindI18n, bindI18nStore = i18nOptions.bindI18nStore;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      if (props.lng) {
        loadLanguages(i18n, props.lng, namespaces, function() {
          if (isMounted.current) setT(getT);
        });
      } else {
        loadNamespaces(i18n, namespaces, function() {
          if (isMounted.current) setT(getT);
        });
      }
    }
    if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
      setT(getT);
    }
    function boundReset() {
      if (isMounted.current) setT(getT);
    }
    if (bindI18n && i18n) i18n.on(bindI18n, boundReset);
    if (bindI18nStore && i18n) i18n.store.on(bindI18nStore, boundReset);
    return function() {
      isMounted.current = false;
      if (bindI18n && i18n) bindI18n.split(" ").forEach(function(e2) {
        return i18n.off(e2, boundReset);
      });
      if (bindI18nStore && i18n) bindI18nStore.split(" ").forEach(function(e2) {
        return i18n.store.off(e2, boundReset);
      });
    };
  }, [i18n, joinedNS]);
  var isInitial = reactExports.useRef(true);
  reactExports.useEffect(function() {
    if (isMounted.current && !isInitial.current) {
      setT(getT);
    }
    isInitial.current = false;
  }, [i18n, keyPrefix]);
  var ret = [t2, i18n, ready];
  ret.t = t2;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready) return ret;
  if (!ready && !useSuspense) return ret;
  throw new Promise(function(resolve) {
    if (props.lng) {
      loadLanguages(i18n, props.lng, namespaces, function() {
        return resolve();
      });
    } else {
      loadNamespaces(i18n, namespaces, function() {
        return resolve();
      });
    }
  });
}
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$5(obj);
}
var arr$1 = [];
var each$2 = arr$1.forEach;
var slice$2 = arr$1.slice;
function defaults$2(obj) {
  each$2.call(slice$2.call(arguments, 1), function(source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
function hasXMLHttpRequest() {
  return typeof XMLHttpRequest === "function" || (typeof XMLHttpRequest === "undefined" ? "undefined" : _typeof$5(XMLHttpRequest)) === "object";
}
function isPromise(maybePromise) {
  return !!maybePromise && typeof maybePromise.then === "function";
}
function makePromise(maybePromise) {
  if (isPromise(maybePromise)) {
    return maybePromise;
  }
  return Promise.resolve(maybePromise);
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var getFetch$1 = { exports: {} };
var browserPonyfill$1 = { exports: {} };
var browserPonyfill = browserPonyfill$1.exports;
var hasRequiredBrowserPonyfill;
function requireBrowserPonyfill() {
  if (hasRequiredBrowserPonyfill) return browserPonyfill$1.exports;
  hasRequiredBrowserPonyfill = 1;
  (function(module, exports) {
    var global = typeof self !== "undefined" ? self : browserPonyfill;
    var __self__ = (function() {
      function F() {
        this.fetch = false;
        this.DOMException = global.DOMException;
      }
      F.prototype = global;
      return new F();
    })();
    (function(self2) {
      (function(exports2) {
        var support2 = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && (function() {
            try {
              new Blob();
              return true;
            } catch (e2) {
              return false;
            }
          })(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support2.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support2.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers2.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers2.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers2.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support2.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars2 = new Array(view.length);
          for (var i2 = 0; i2 < view.length; i2++) {
            chars2[i2] = String.fromCharCode(view[i2]);
          }
          return chars2.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support2.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support2.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support2.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support2.arrayBuffer && support2.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support2.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support2.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support2.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support2.formData) {
            this.formData = function() {
              return this.text().then(decode2);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods2 = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods2.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request2(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode2(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request2.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err2) {
          exports2.DOMException = function(message2, name) {
            this.message = message2;
            this.name = name;
            var error2 = Error(message2);
            this.stack = error2.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init2) {
          return new Promise(function(resolve, reject) {
            var request3 = new Request2(input, init2);
            if (request3.signal && request3.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request3.method, request3.url, true);
            if (request3.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request3.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support2.blob) {
              xhr.responseType = "blob";
            }
            request3.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request3.signal) {
              request3.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request3.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request3._bodyInit === "undefined" ? null : request3._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers2;
          self2.Request = Request2;
          self2.Response = Response;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request2;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      })({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  })(browserPonyfill$1, browserPonyfill$1.exports);
  return browserPonyfill$1.exports;
}
var hasRequiredGetFetch;
function requireGetFetch() {
  if (hasRequiredGetFetch) return getFetch$1.exports;
  hasRequiredGetFetch = 1;
  (function(module, exports) {
    var fetchApi2;
    if (typeof fetch === "function") {
      if (typeof globalThis !== "undefined" && globalThis.fetch) {
        fetchApi2 = globalThis.fetch;
      } else if (typeof window !== "undefined" && window.fetch) {
        fetchApi2 = window.fetch;
      } else {
        fetchApi2 = fetch;
      }
    }
    if (typeof commonjsRequire !== "undefined" && (typeof window === "undefined" || typeof window.document === "undefined")) {
      var f2 = fetchApi2 || requireBrowserPonyfill();
      if (f2.default) f2 = f2.default;
      exports.default = f2;
      module.exports = exports.default;
    }
  })(getFetch$1, getFetch$1.exports);
  return getFetch$1.exports;
}
var getFetchExports = requireGetFetch();
const getFetch = /* @__PURE__ */ getDefaultExportFromCjs(getFetchExports);
const fetchNode = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getFetch
}, [getFetchExports]);
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$4(obj);
}
var fetchApi;
if (typeof fetch === "function") {
  if (typeof globalThis !== "undefined" && globalThis.fetch) {
    fetchApi = globalThis.fetch;
  } else if (typeof window !== "undefined" && window.fetch) {
    fetchApi = window.fetch;
  } else {
    fetchApi = fetch;
  }
}
var XmlHttpRequestApi;
if (hasXMLHttpRequest()) {
  if (typeof globalThis !== "undefined" && globalThis.XMLHttpRequest) {
    XmlHttpRequestApi = globalThis.XMLHttpRequest;
  } else if (typeof window !== "undefined" && window.XMLHttpRequest) {
    XmlHttpRequestApi = window.XMLHttpRequest;
  }
}
var ActiveXObjectApi;
if (typeof ActiveXObject === "function") {
  if (typeof globalThis !== "undefined" && globalThis.ActiveXObject) {
    ActiveXObjectApi = globalThis.ActiveXObject;
  } else if (typeof window !== "undefined" && window.ActiveXObject) {
    ActiveXObjectApi = window.ActiveXObject;
  }
}
if (!fetchApi && fetchNode && !XmlHttpRequestApi && !ActiveXObjectApi) fetchApi = getFetch || fetchNode;
if (typeof fetchApi !== "function") fetchApi = void 0;
var addQueryString = function addQueryString2(url, params) {
  if (params && _typeof$4(params) === "object") {
    var queryString = "";
    for (var paramName in params) {
      queryString += "&" + encodeURIComponent(paramName) + "=" + encodeURIComponent(params[paramName]);
    }
    if (!queryString) return url;
    url = url + (url.indexOf("?") !== -1 ? "&" : "?") + queryString.slice(1);
  }
  return url;
};
var fetchIt = function fetchIt2(url, fetchOptions, callback) {
  fetchApi(url, fetchOptions).then(function(response) {
    if (!response.ok) return callback(response.statusText || "Error", {
      status: response.status
    });
    response.text().then(function(data) {
      callback(null, {
        status: response.status,
        data
      });
    }).catch(callback);
  }).catch(callback);
};
var omitFetchOptions = false;
var requestWithFetch = function requestWithFetch2(options, url, payload, callback) {
  if (options.queryStringParams) {
    url = addQueryString(url, options.queryStringParams);
  }
  var headers = defaults$2({}, typeof options.customHeaders === "function" ? options.customHeaders() : options.customHeaders);
  if (payload) headers["Content-Type"] = "application/json";
  var reqOptions = typeof options.requestOptions === "function" ? options.requestOptions(payload) : options.requestOptions;
  var fetchOptions = defaults$2({
    method: payload ? "POST" : "GET",
    body: payload ? options.stringify(payload) : void 0,
    headers
  }, omitFetchOptions ? {} : reqOptions);
  try {
    fetchIt(url, fetchOptions, callback);
  } catch (e2) {
    if (!reqOptions || Object.keys(reqOptions).length === 0 || !e2.message || e2.message.indexOf("not implemented") < 0) {
      return callback(e2);
    }
    try {
      Object.keys(reqOptions).forEach(function(opt) {
        delete fetchOptions[opt];
      });
      fetchIt(url, fetchOptions, callback);
      omitFetchOptions = true;
    } catch (err2) {
      callback(err2);
    }
  }
};
var requestWithXmlHttpRequest = function requestWithXmlHttpRequest2(options, url, payload, callback) {
  if (payload && _typeof$4(payload) === "object") {
    payload = addQueryString("", payload).slice(1);
  }
  if (options.queryStringParams) {
    url = addQueryString(url, options.queryStringParams);
  }
  try {
    var x2;
    if (XmlHttpRequestApi) {
      x2 = new XmlHttpRequestApi();
    } else {
      x2 = new ActiveXObjectApi("MSXML2.XMLHTTP.3.0");
    }
    x2.open(payload ? "POST" : "GET", url, 1);
    if (!options.crossDomain) {
      x2.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    }
    x2.withCredentials = !!options.withCredentials;
    if (payload) {
      x2.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    }
    if (x2.overrideMimeType) {
      x2.overrideMimeType("application/json");
    }
    var h2 = options.customHeaders;
    h2 = typeof h2 === "function" ? h2() : h2;
    if (h2) {
      for (var i2 in h2) {
        x2.setRequestHeader(i2, h2[i2]);
      }
    }
    x2.onreadystatechange = function() {
      x2.readyState > 3 && callback(x2.status >= 400 ? x2.statusText : null, {
        status: x2.status,
        data: x2.responseText
      });
    };
    x2.send(payload);
  } catch (e2) {
    console && console.log(e2);
  }
};
var request = function request2(options, url, payload, callback) {
  if (typeof payload === "function") {
    callback = payload;
    payload = void 0;
  }
  callback = callback || function() {
  };
  if (fetchApi && url.indexOf("file:") !== 0) {
    return requestWithFetch(options, url, payload, callback);
  }
  if (hasXMLHttpRequest() || typeof ActiveXObject === "function") {
    return requestWithXmlHttpRequest(options, url, payload, callback);
  }
  callback(new Error("No fetch and no xhr implementation found!"));
};
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$3(obj);
}
function _classCallCheck$2(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty$5(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$1(arg) {
  var key = _toPrimitive$1(arg, "string");
  return _typeof$3(key) === "symbol" ? key : String(key);
}
function _toPrimitive$1(input, hint) {
  if (_typeof$3(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint);
    if (_typeof$3(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(input);
}
var getDefaults$1 = function getDefaults() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    allowMultiLoading: false,
    parse: function parse2(data) {
      return JSON.parse(data);
    },
    stringify: JSON.stringify,
    parsePayload: function parsePayload(namespace, key, fallbackValue) {
      return _defineProperty$5({}, key, fallbackValue || "");
    },
    parseLoadPayload: function parseLoadPayload(languages, namespaces) {
      return void 0;
    },
    request,
    reloadInterval: typeof window !== "undefined" ? false : 60 * 60 * 1e3,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: false,
    withCredentials: false,
    overrideMimeType: false,
    requestOptions: {
      mode: "cors",
      credentials: "same-origin",
      cache: "default"
    }
  };
};
var Backend = (function() {
  function Backend2(services) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var allOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _classCallCheck$2(this, Backend2);
    this.services = services;
    this.options = options;
    this.allOptions = allOptions;
    this.type = "backend";
    this.init(services, options, allOptions);
  }
  _createClass$2(Backend2, [{
    key: "init",
    value: function init2(services) {
      var _this = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var allOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = services;
      this.options = defaults$2(options, this.options || {}, getDefaults$1());
      this.allOptions = allOptions;
      if (this.services && this.options.reloadInterval) {
        setInterval(function() {
          return _this.reload();
        }, this.options.reloadInterval);
      }
    }
  }, {
    key: "readMulti",
    value: function readMulti(languages, namespaces, callback) {
      this._readAny(languages, languages, namespaces, namespaces, callback);
    }
  }, {
    key: "read",
    value: function read2(language, namespace, callback) {
      this._readAny([language], language, [namespace], namespace, callback);
    }
  }, {
    key: "_readAny",
    value: function _readAny(languages, loadUrlLanguages, namespaces, loadUrlNamespaces, callback) {
      var _this2 = this;
      var loadPath = this.options.loadPath;
      if (typeof this.options.loadPath === "function") {
        loadPath = this.options.loadPath(languages, namespaces);
      }
      loadPath = makePromise(loadPath);
      loadPath.then(function(resolvedLoadPath) {
        if (!resolvedLoadPath) return callback(null, {});
        var url = _this2.services.interpolator.interpolate(resolvedLoadPath, {
          lng: languages.join("+"),
          ns: namespaces.join("+")
        });
        _this2.loadUrl(url, callback, loadUrlLanguages, loadUrlNamespaces);
      });
    }
  }, {
    key: "loadUrl",
    value: function loadUrl(url, callback, languages, namespaces) {
      var _this3 = this;
      var lng = typeof languages === "string" ? [languages] : languages;
      var ns = typeof namespaces === "string" ? [namespaces] : namespaces;
      var payload = this.options.parseLoadPayload(lng, ns);
      this.options.request(this.options, url, payload, function(err2, res) {
        if (res && (res.status >= 500 && res.status < 600 || !res.status)) return callback("failed loading " + url + "; status code: " + res.status, true);
        if (res && res.status >= 400 && res.status < 500) return callback("failed loading " + url + "; status code: " + res.status, false);
        if (!res && err2 && err2.message && err2.message.indexOf("Failed to fetch") > -1) return callback("failed loading " + url + ": " + err2.message, true);
        if (err2) return callback(err2, false);
        var ret, parseErr;
        try {
          if (typeof res.data === "string") {
            ret = _this3.options.parse(res.data, languages, namespaces);
          } else {
            ret = res.data;
          }
        } catch (e2) {
          parseErr = "failed parsing " + url + " to json";
        }
        if (parseErr) return callback(parseErr, false);
        callback(null, ret);
      });
    }
  }, {
    key: "create",
    value: function create3(languages, namespace, key, fallbackValue, callback) {
      var _this4 = this;
      if (!this.options.addPath) return;
      if (typeof languages === "string") languages = [languages];
      var payload = this.options.parsePayload(namespace, key, fallbackValue);
      var finished = 0;
      var dataArray = [];
      var resArray = [];
      languages.forEach(function(lng) {
        var addPath = _this4.options.addPath;
        if (typeof _this4.options.addPath === "function") {
          addPath = _this4.options.addPath(lng, namespace);
        }
        var url = _this4.services.interpolator.interpolate(addPath, {
          lng,
          ns: namespace
        });
        _this4.options.request(_this4.options, url, payload, function(data, res) {
          finished += 1;
          dataArray.push(data);
          resArray.push(res);
          if (finished === languages.length) {
            if (typeof callback === "function") callback(dataArray, resArray);
          }
        });
      });
    }
  }, {
    key: "reload",
    value: function reload() {
      var _this5 = this;
      var _this$services = this.services, backendConnector = _this$services.backendConnector, languageUtils = _this$services.languageUtils, logger = _this$services.logger;
      var currentLanguage = backendConnector.language;
      if (currentLanguage && currentLanguage.toLowerCase() === "cimode") return;
      var toLoad = [];
      var append = function append2(lng) {
        var lngs = languageUtils.toResolveHierarchy(lng);
        lngs.forEach(function(l2) {
          if (toLoad.indexOf(l2) < 0) toLoad.push(l2);
        });
      };
      append(currentLanguage);
      if (this.allOptions.preload) this.allOptions.preload.forEach(function(l2) {
        return append(l2);
      });
      toLoad.forEach(function(lng) {
        _this5.allOptions.ns.forEach(function(ns) {
          backendConnector.read(lng, ns, "read", null, null, function(err2, data) {
            if (err2) logger.warn("loading namespace ".concat(ns, " for language ").concat(lng, " failed"), err2);
            if (!err2 && data) logger.log("loaded namespace ".concat(ns, " for language ").concat(lng), data);
            backendConnector.loaded("".concat(lng, "|").concat(ns), err2, data);
          });
        });
      });
    }
  }]);
  return Backend2;
})();
Backend.type = "backend";
var arr = [];
var each$1 = arr.forEach;
var slice$1 = arr.slice;
function defaults$1(obj) {
  each$1.call(slice$1.call(arguments, 1), function(source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var serializeCookie = function serializeCookie2(name, val, options) {
  var opt = options || {};
  opt.path = opt.path || "/";
  var value = encodeURIComponent(val);
  var str = "".concat(name, "=").concat(value);
  if (opt.maxAge > 0) {
    var maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge)) throw new Error("maxAge should be a Number");
    str += "; Max-Age=".concat(Math.floor(maxAge));
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=".concat(opt.domain);
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=".concat(opt.path);
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=".concat(opt.expires.toUTCString());
  }
  if (opt.httpOnly) str += "; HttpOnly";
  if (opt.secure) str += "; Secure";
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
var cookie = {
  create: function create(name, value, minutes, domain) {
    var cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes) {
      cookieOptions.expires = /* @__PURE__ */ new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
    }
    if (domain) cookieOptions.domain = domain;
    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);
  },
  read: function read(name) {
    var nameEQ = "".concat(name, "=");
    var ca = document.cookie.split(";");
    for (var i2 = 0; i2 < ca.length; i2++) {
      var c2 = ca[i2];
      while (c2.charAt(0) === " ") {
        c2 = c2.substring(1, c2.length);
      }
      if (c2.indexOf(nameEQ) === 0) return c2.substring(nameEQ.length, c2.length);
    }
    return null;
  },
  remove: function remove(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  lookup: function lookup(options) {
    var found;
    if (options.lookupCookie && typeof document !== "undefined") {
      var c2 = cookie.read(options.lookupCookie);
      if (c2) found = c2;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options) {
    if (options.lookupCookie && typeof document !== "undefined") {
      cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain, options.cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  lookup: function lookup2(options) {
    var found;
    if (typeof window !== "undefined") {
      var search = window.location.search;
      if (!window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1) {
        search = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      var query = search.substring(1);
      var params = query.split("&");
      for (var i2 = 0; i2 < params.length; i2++) {
        var pos = params[i2].indexOf("=");
        if (pos > 0) {
          var key = params[i2].substring(0, pos);
          if (key === options.lookupQuerystring) {
            found = params[i2].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
var hasLocalStorageSupport = null;
var localStorageAvailable = function localStorageAvailable2() {
  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
    var testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e2) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage = {
  name: "localStorage",
  lookup: function lookup3(options) {
    var found;
    if (options.lookupLocalStorage && localStorageAvailable()) {
      var lng = window.localStorage.getItem(options.lookupLocalStorage);
      if (lng) found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage2(lng, options) {
    if (options.lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(options.lookupLocalStorage, lng);
    }
  }
};
var hasSessionStorageSupport = null;
var sessionStorageAvailable = function sessionStorageAvailable2() {
  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
    var testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e2) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage = {
  name: "sessionStorage",
  lookup: function lookup4(options) {
    var found;
    if (options.lookupSessionStorage && sessionStorageAvailable()) {
      var lng = window.sessionStorage.getItem(options.lookupSessionStorage);
      if (lng) found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage3(lng, options) {
    if (options.lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(options.lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup: function lookup5(options) {
    var found = [];
    if (typeof navigator !== "undefined") {
      if (navigator.languages) {
        for (var i2 = 0; i2 < navigator.languages.length; i2++) {
          found.push(navigator.languages[i2]);
        }
      }
      if (navigator.userLanguage) {
        found.push(navigator.userLanguage);
      }
      if (navigator.language) {
        found.push(navigator.language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  lookup: function lookup6(options) {
    var found;
    var htmlTag2 = options.htmlTag || (typeof document !== "undefined" ? document.documentElement : null);
    if (htmlTag2 && typeof htmlTag2.getAttribute === "function") {
      found = htmlTag2.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  lookup: function lookup7(options) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (language instanceof Array) {
        if (typeof options.lookupFromPathIndex === "number") {
          if (typeof language[options.lookupFromPathIndex] !== "string") {
            return void 0;
          }
          found = language[options.lookupFromPathIndex].replace("/", "");
        } else {
          found = language[0].replace("/", "");
        }
      }
    }
    return found;
  }
};
var subdomain = {
  name: "subdomain",
  lookup: function lookup8(options) {
    var lookupFromSubdomainIndex = typeof options.lookupFromSubdomainIndex === "number" ? options.lookupFromSubdomainIndex + 1 : 1;
    var language = typeof window !== "undefined" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
    if (!language) return void 0;
    return language[lookupFromSubdomainIndex];
  }
};
function getDefaults2() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"]
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'
  };
}
var Browser = /* @__PURE__ */ (function() {
  function Browser2(services) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$3(this, Browser2);
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options);
  }
  _createClass$3(Browser2, [{
    key: "init",
    value: function init2(services) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = services || {
        languageUtils: {}
      };
      this.options = defaults$1(options, this.options || {}, getDefaults2());
      if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
      this.i18nOptions = i18nOptions;
      this.addDetector(cookie$1);
      this.addDetector(querystring);
      this.addDetector(localStorage);
      this.addDetector(sessionStorage);
      this.addDetector(navigator$1);
      this.addDetector(htmlTag);
      this.addDetector(path);
      this.addDetector(subdomain);
    }
  }, {
    key: "addDetector",
    value: function addDetector(detector) {
      this.detectors[detector.name] = detector;
    }
  }, {
    key: "detect",
    value: function detect(detectionOrder) {
      var _this = this;
      if (!detectionOrder) detectionOrder = this.options.order;
      var detected = [];
      detectionOrder.forEach(function(detectorName) {
        if (_this.detectors[detectorName]) {
          var lookup9 = _this.detectors[detectorName].lookup(_this.options);
          if (lookup9 && typeof lookup9 === "string") lookup9 = [lookup9];
          if (lookup9) detected = detected.concat(lookup9);
        }
      });
      if (this.services.languageUtils.getBestMatchFromCodes) return detected;
      return detected.length > 0 ? detected[0] : null;
    }
  }, {
    key: "cacheUserLanguage",
    value: function cacheUserLanguage4(lng, caches) {
      var _this2 = this;
      if (!caches) caches = this.options.caches;
      if (!caches) return;
      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
      caches.forEach(function(cacheName) {
        if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
      });
    }
  }]);
  return Browser2;
})();
Browser.type = "languageDetector";
var BUILD = {
  allRenderFn: false,
  element: true,
  event: true,
  hasRenderFn: true,
  hostListener: true,
  hostListenerTargetWindow: true,
  hostListenerTargetDocument: true,
  hostListenerTargetBody: true,
  hostListenerTargetParent: false,
  hostListenerTarget: true,
  member: true,
  method: true,
  mode: true,
  observeAttribute: true,
  prop: true,
  propMutable: true,
  reflect: true,
  scoped: true,
  shadowDom: true,
  slot: true,
  cssAnnotations: true,
  state: true,
  style: true,
  formAssociated: false,
  svg: true,
  updatable: true,
  vdomAttribute: true,
  vdomXlink: true,
  vdomClass: true,
  vdomFunctional: true,
  vdomKey: true,
  vdomListener: true,
  vdomRef: true,
  vdomPropOrAttr: true,
  vdomRender: true,
  vdomStyle: true,
  vdomText: true,
  watchCallback: true,
  taskQueue: true,
  hotModuleReplacement: false,
  isDebug: false,
  isDev: false,
  isTesting: false,
  hydrateServerSide: false,
  hydrateClientSide: false,
  lifecycleDOMEvents: false,
  lazyLoad: false,
  profile: false,
  slotRelocation: true,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: false,
  hydratedAttribute: false,
  hydratedClass: true,
  // TODO(STENCIL-1305): remove this option
  scriptDataOpts: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: false,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: false,
  invisiblePrehydration: true,
  propBoolean: true,
  propNumber: true,
  propString: true,
  constructableCSS: true,
  devTools: false,
  shadowDelegatesFocus: true,
  initializeNextTick: false,
  asyncLoading: true,
  asyncQueue: false,
  transformTagName: false,
  attachStyles: true,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: false
};
var NAMESPACE$1 = (
  /* default */
  "app"
);
var __defProp2 = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var Build = {
  isBrowser: true
};
var SVG_NS = "http://www.w3.org/2000/svg";
var HTML_NS = "http://www.w3.org/1999/xhtml";
var reWireGetterSetter = (instance2, hostRef) => {
  var _a;
  const cmpMeta = hostRef.$cmpMeta$;
  const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});
  members.map(([memberName, [memberFlags]]) => {
    if (memberFlags & 31 || memberFlags & 32) {
      const ogValue = instance2[memberName];
      const ogDescriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(instance2), memberName);
      Object.defineProperty(instance2, memberName, {
        get() {
          return ogDescriptor.get.call(this);
        },
        set(newValue) {
          ogDescriptor.set.call(this, newValue);
        },
        configurable: true,
        enumerable: true
      });
      instance2[memberName] = hostRef.$instanceValues$.has(memberName) ? hostRef.$instanceValues$.get(memberName) : ogValue;
    }
  });
};
var getHostRef = (ref) => {
  if (ref.__stencil__getHostRef) {
    return ref.__stencil__getHostRef();
  }
  return void 0;
};
var registerHost = (hostElement, cmpMeta) => {
  const hostRef = {
    $flags$: 0,
    $hostElement$: hostElement,
    $cmpMeta$: cmpMeta,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  {
    hostRef.$onReadyPromise$ = new Promise((r2) => hostRef.$onReadyResolve$ = r2);
    hostElement["s-p"] = [];
    hostElement["s-rc"] = [];
  }
  const ref = hostRef;
  hostElement.__stencil__getHostRef = () => ref;
  if (BUILD.modernPropertyDecls && BUILD.state) {
    reWireGetterSetter(hostElement, hostRef);
  }
  return ref;
};
var isMemberInElement = (elm, memberName) => memberName in elm;
var consoleError = (e2, el) => (0, console.error)(e2, el);
var styles = /* @__PURE__ */ new Map();
var modeResolutionChain = [];
var SLOT_FB_CSS = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
var XLINK_NS = "http://www.w3.org/1999/xlink";
var win = typeof window !== "undefined" ? window : {};
var H = win.HTMLElement || class {
};
var plt = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (h2) => h2(),
  raf: (h2) => requestAnimationFrame(h2),
  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
  ce: (eventName, opts) => new CustomEvent(eventName, opts)
};
var supportsListenerOptions = /* @__PURE__ */ (() => {
  var _a;
  let supportsListenerOptions2 = false;
  try {
    (_a = win.document) == null ? void 0 : _a.addEventListener(
      "e",
      null,
      Object.defineProperty({}, "passive", {
        get() {
          supportsListenerOptions2 = true;
        }
      })
    );
  } catch (e2) {
  }
  return supportsListenerOptions2;
})();
var promiseResolve = (v2) => Promise.resolve(v2);
var supportsConstructableStylesheets = /* @__PURE__ */ (() => {
  try {
    new CSSStyleSheet();
    return typeof new CSSStyleSheet().replaceSync === "function";
  } catch (e2) {
  }
  return false;
})();
var supportsMutableAdoptedStyleSheets = supportsConstructableStylesheets ? /* @__PURE__ */ (() => !!win.document && Object.getOwnPropertyDescriptor(win.document.adoptedStyleSheets, "length").writable)() : false;
var queuePending = false;
var queueDomReads = [];
var queueDomWrites = [];
var queueTask = (queue, write) => (cb) => {
  queue.push(cb);
  if (!queuePending) {
    queuePending = true;
    if (write && plt.$flags$ & 4) {
      nextTick$1(flush);
    } else {
      plt.raf(flush);
    }
  }
};
var consume = (queue) => {
  for (let i2 = 0; i2 < queue.length; i2++) {
    try {
      queue[i2](performance.now());
    } catch (e2) {
      consoleError(e2);
    }
  }
  queue.length = 0;
};
var flush = () => {
  consume(queueDomReads);
  {
    consume(queueDomWrites);
    if (queuePending = queueDomReads.length > 0) {
      plt.raf(flush);
    }
  }
};
var nextTick$1 = (cb) => promiseResolve().then(cb);
var readTask = /* @__PURE__ */ queueTask(queueDomReads, false);
var writeTask = /* @__PURE__ */ queueTask(queueDomWrites, true);
var getAssetPath = (path2) => {
  const assetUrl = new URL(path2, plt.$resourcesUrl$);
  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
};
var isDef = (v2) => v2 != null && v2 !== void 0;
var isComplexType = (o2) => {
  o2 = typeof o2;
  return o2 === "object" || o2 === "function";
};
function queryNonceMetaTagContent(doc) {
  var _a, _b, _c;
  return (_c = (_b = (_a = doc.head) == null ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) == null ? void 0 : _b.getAttribute("content")) != null ? _c : void 0;
}
var escapeRegExpSpecialCharacters = (text) => {
  return text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var result_exports = {};
__export(result_exports, {
  err: () => err,
  map: () => map,
  ok: () => ok,
  unwrap: () => unwrap$1,
  unwrapErr: () => unwrapErr
});
var ok = (value) => ({
  isOk: true,
  isErr: false,
  value
});
var err = (value) => ({
  isOk: false,
  isErr: true,
  value
});
function map(result, fn2) {
  if (result.isOk) {
    const val = fn2(result.value);
    if (val instanceof Promise) {
      return val.then((newVal) => ok(newVal));
    } else {
      return ok(val);
    }
  }
  if (result.isErr) {
    const value = result.value;
    return err(value);
  }
  throw "should never get here";
}
var unwrap$1 = (result) => {
  if (result.isOk) {
    return result.value;
  } else {
    throw result.value;
  }
};
var unwrapErr = (result) => {
  if (result.isErr) {
    return result.value;
  } else {
    throw result.value;
  }
};
function createStyleSheetIfNeededAndSupported(styles2) {
  return void 0;
}
var globalStyleSheet;
function createShadowRoot(cmpMeta) {
  var _a;
  const shadowRoot = this.attachShadow({
    mode: "open",
    delegatesFocus: !!(cmpMeta.$flags$ & 16)
  });
  if (globalStyleSheet === void 0) globalStyleSheet = (_a = createStyleSheetIfNeededAndSupported()) != null ? _a : null;
  if (globalStyleSheet) {
    if (supportsMutableAdoptedStyleSheets) {
      shadowRoot.adoptedStyleSheets.push(globalStyleSheet);
    } else {
      shadowRoot.adoptedStyleSheets = [...shadowRoot.adoptedStyleSheets, globalStyleSheet];
    }
  }
}
var updateFallbackSlotVisibility = (elm) => {
  const childNodes = internalCall(elm, "childNodes");
  if (elm.tagName && elm.tagName.includes("-") && elm["s-cr"] && elm.tagName !== "SLOT-FB") {
    getHostSlotNodes(childNodes, elm.tagName).forEach((slotNode) => {
      if (slotNode.nodeType === 1 && slotNode.tagName === "SLOT-FB") {
        if (getSlotChildSiblings(slotNode, getSlotName(slotNode), false).length) {
          slotNode.hidden = true;
        } else {
          slotNode.hidden = false;
        }
      }
    });
  }
  let i2 = 0;
  for (i2 = 0; i2 < childNodes.length; i2++) {
    const childNode = childNodes[i2];
    if (childNode.nodeType === 1 && internalCall(childNode, "childNodes").length) {
      updateFallbackSlotVisibility(childNode);
    }
  }
};
var getSlottedChildNodes = (childNodes) => {
  const result = [];
  for (let i2 = 0; i2 < childNodes.length; i2++) {
    const slottedNode = childNodes[i2]["s-nr"] || void 0;
    if (slottedNode && slottedNode.isConnected) {
      result.push(slottedNode);
    }
  }
  return result;
};
function getHostSlotNodes(childNodes, hostName, slotName) {
  let i2 = 0;
  let slottedNodes = [];
  let childNode;
  for (; i2 < childNodes.length; i2++) {
    childNode = childNodes[i2];
    if (childNode["s-sr"] && (!hostName || childNode["s-hn"] === hostName) && slotName === void 0) {
      slottedNodes.push(childNode);
    }
    slottedNodes = [...slottedNodes, ...getHostSlotNodes(childNode.childNodes, hostName, slotName)];
  }
  return slottedNodes;
}
var getSlotChildSiblings = (slot, slotName, includeSlot = true) => {
  const childNodes = [];
  if (includeSlot && slot["s-sr"] || !slot["s-sr"]) childNodes.push(slot);
  let node = slot;
  while (node = node.nextSibling) {
    if (getSlotName(node) === slotName && (includeSlot || !node["s-sr"])) childNodes.push(node);
  }
  return childNodes;
};
var isNodeLocatedInSlot = (nodeToRelocate, slotName) => {
  if (nodeToRelocate.nodeType === 1) {
    if (nodeToRelocate.getAttribute("slot") === null && slotName === "") {
      return true;
    }
    if (nodeToRelocate.getAttribute("slot") === slotName) {
      return true;
    }
    return false;
  }
  if (nodeToRelocate["s-sn"] === slotName) {
    return true;
  }
  return slotName === "";
};
var getSlotName = (node) => typeof node["s-sn"] === "string" ? node["s-sn"] : node.nodeType === 1 && node.getAttribute("slot") || void 0;
function patchSlotNode(node) {
  if (node.assignedElements || node.assignedNodes || !node["s-sr"]) return;
  const assignedFactory = (elementsOnly) => (function(opts) {
    const toReturn = [];
    const slotName = this["s-sn"];
    if (opts == null ? void 0 : opts.flatten) {
      console.error("\n          Flattening is not supported for Stencil non-shadow slots.\n          You can use `.childNodes` to nested slot fallback content.\n          If you have a particular use case, please open an issue on the Stencil repo.\n        ");
    }
    const parent = this["s-cr"].parentElement;
    const slottedNodes = parent.__childNodes ? parent.childNodes : getSlottedChildNodes(parent.childNodes);
    slottedNodes.forEach((n2) => {
      if (slotName === getSlotName(n2)) {
        toReturn.push(n2);
      }
    });
    if (elementsOnly) {
      return toReturn.filter(
        (n2) => n2.nodeType === 1
        /* ElementNode */
      );
    }
    return toReturn;
  }).bind(node);
  node.assignedElements = assignedFactory(true);
  node.assignedNodes = assignedFactory(false);
}
function internalCall(node, method) {
  if ("__" + method in node) {
    const toReturn = node["__" + method];
    if (typeof toReturn !== "function") return toReturn;
    return toReturn.bind(node);
  } else {
    if (typeof node[method] !== "function") return node[method];
    return node[method].bind(node);
  }
}
var createTime = (fnName, tagName = "") => {
  {
    return () => {
      return;
    };
  }
};
var rootAppliedStyles = /* @__PURE__ */ new WeakMap();
var registerStyle = (scopeId2, cssText, allowCS) => {
  let style = styles.get(scopeId2);
  if (supportsConstructableStylesheets && allowCS) {
    style = style || new CSSStyleSheet();
    if (typeof style === "string") {
      style = cssText;
    } else {
      style.replaceSync(cssText);
    }
  } else {
    style = cssText;
  }
  styles.set(scopeId2, style);
};
var addStyle$1 = (styleContainerNode, cmpMeta, mode) => {
  var _a;
  const scopeId2 = getScopeId(cmpMeta, mode);
  const style = styles.get(scopeId2);
  if (!win.document) {
    return scopeId2;
  }
  styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : win.document;
  if (style) {
    if (typeof style === "string") {
      styleContainerNode = styleContainerNode.head || styleContainerNode;
      let appliedStyles = rootAppliedStyles.get(styleContainerNode);
      let styleElm;
      if (!appliedStyles) {
        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
      }
      if (!appliedStyles.has(scopeId2)) {
        {
          styleElm = win.document.createElement("style");
          styleElm.innerHTML = style;
          const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(win.document);
          if (nonce != null) {
            styleElm.setAttribute("nonce", nonce);
          }
          if (!(cmpMeta.$flags$ & 1)) {
            if (styleContainerNode.nodeName === "HEAD") {
              const preconnectLinks = styleContainerNode.querySelectorAll("link[rel=preconnect]");
              const referenceNode2 = preconnectLinks.length > 0 ? preconnectLinks[preconnectLinks.length - 1].nextSibling : styleContainerNode.querySelector("style");
              styleContainerNode.insertBefore(
                styleElm,
                (referenceNode2 == null ? void 0 : referenceNode2.parentNode) === styleContainerNode ? referenceNode2 : null
              );
            } else if ("host" in styleContainerNode) {
              if (supportsConstructableStylesheets) {
                const stylesheet = new CSSStyleSheet();
                stylesheet.replaceSync(style);
                if (supportsMutableAdoptedStyleSheets) {
                  styleContainerNode.adoptedStyleSheets.unshift(stylesheet);
                } else {
                  styleContainerNode.adoptedStyleSheets = [stylesheet, ...styleContainerNode.adoptedStyleSheets];
                }
              } else {
                const existingStyleContainer = styleContainerNode.querySelector("style");
                if (existingStyleContainer) {
                  existingStyleContainer.innerHTML = style + existingStyleContainer.innerHTML;
                } else {
                  styleContainerNode.prepend(styleElm);
                }
              }
            } else {
              styleContainerNode.append(styleElm);
            }
          }
          if (cmpMeta.$flags$ & 1) {
            styleContainerNode.insertBefore(styleElm, null);
          }
        }
        if (cmpMeta.$flags$ & 4) {
          styleElm.innerHTML += SLOT_FB_CSS;
        }
        if (appliedStyles) {
          appliedStyles.add(scopeId2);
        }
      }
    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
      if (supportsMutableAdoptedStyleSheets) {
        styleContainerNode.adoptedStyleSheets.push(style);
      } else {
        styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
      }
    }
  }
  return scopeId2;
};
var attachStyles = (hostRef) => {
  const cmpMeta = hostRef.$cmpMeta$;
  const elm = hostRef.$hostElement$;
  const flags = cmpMeta.$flags$;
  const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
  const scopeId2 = addStyle$1(
    elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(),
    cmpMeta,
    hostRef.$modeName$
  );
  if (flags & 10) {
    elm["s-sc"] = scopeId2;
    elm.classList.add(scopeId2 + "-h");
  }
  endAttachStyles();
};
var getScopeId = (cmp, mode) => "sc-" + (mode && cmp.$flags$ & 32 ? cmp.$tagName$ + "-" + mode : cmp.$tagName$);
var h$1 = (nodeName, vnodeData, ...children) => {
  let child = null;
  let key = null;
  let slotName = null;
  let simple = false;
  let lastSimple = false;
  const vNodeChildren = [];
  const walk = (c2) => {
    for (let i2 = 0; i2 < c2.length; i2++) {
      child = c2[i2];
      if (Array.isArray(child)) {
        walk(child);
      } else if (child != null && typeof child !== "boolean") {
        if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
          child = String(child);
        }
        if (simple && lastSimple) {
          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
        } else {
          vNodeChildren.push(simple ? newVNode(null, child) : child);
        }
        lastSimple = simple;
      }
    }
  };
  walk(children);
  if (vnodeData) {
    if (vnodeData.key) {
      key = vnodeData.key;
    }
    if (vnodeData.name) {
      slotName = vnodeData.name;
    }
    {
      const classData = vnodeData.className || vnodeData.class;
      if (classData) {
        vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k2) => classData[k2]).join(" ");
      }
    }
  }
  if (typeof nodeName === "function") {
    return nodeName(
      vnodeData === null ? {} : vnodeData,
      vNodeChildren,
      vdomFnUtils
    );
  }
  const vnode = newVNode(nodeName, null);
  vnode.$attrs$ = vnodeData;
  if (vNodeChildren.length > 0) {
    vnode.$children$ = vNodeChildren;
  }
  {
    vnode.$key$ = key;
  }
  {
    vnode.$name$ = slotName;
  }
  return vnode;
};
var newVNode = (tag, text) => {
  const vnode = {
    $flags$: 0,
    $tag$: tag,
    $text$: text,
    $elm$: null,
    $children$: null
  };
  {
    vnode.$attrs$ = null;
  }
  {
    vnode.$key$ = null;
  }
  {
    vnode.$name$ = null;
  }
  return vnode;
};
var Host = {};
var isHost = (node) => node && node.$tag$ === Host;
var vdomFnUtils = {
  forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
  map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate)
};
var convertToPublic = (node) => ({
  vattrs: node.$attrs$,
  vchildren: node.$children$,
  vkey: node.$key$,
  vname: node.$name$,
  vtag: node.$tag$,
  vtext: node.$text$
});
var convertToPrivate = (node) => {
  if (typeof node.vtag === "function") {
    const vnodeData = { ...node.vattrs };
    if (node.vkey) {
      vnodeData.key = node.vkey;
    }
    if (node.vname) {
      vnodeData.name = node.vname;
    }
    return h$1(node.vtag, vnodeData, ...node.vchildren || []);
  }
  const vnode = newVNode(node.vtag, node.vtext);
  vnode.$attrs$ = node.vattrs;
  vnode.$children$ = node.vchildren;
  vnode.$key$ = node.vkey;
  vnode.$name$ = node.vname;
  return vnode;
};
var createSupportsRuleRe = (selector) => {
  const safeSelector2 = escapeRegExpSpecialCharacters(selector);
  return new RegExp(
    // First capture group: match any context before the selector that's not inside @supports selector()
    // Using negative lookahead to avoid matching inside @supports selector(...) condition
    "(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?".concat(safeSelector2, "))(").concat(safeSelector2, "\\b)"),
    "g"
  );
};
createSupportsRuleRe("::slotted");
createSupportsRuleRe(":host");
createSupportsRuleRe(":host-context");
var computeMode = (elm) => modeResolutionChain.map((h2) => h2(elm)).find((m2) => !!m2);
var setMode = (handler) => modeResolutionChain.push(handler);
var getMode = (ref) => {
  var _a;
  return (_a = getHostRef(ref)) == null ? void 0 : _a.$modeName$;
};
var parsePropertyValue = (propValue, propType, isFormAssociated) => {
  if (typeof propValue === "string" && (propType & 16 || propType & 8) && (propValue.startsWith("{") && propValue.endsWith("}") || propValue.startsWith("[") && propValue.endsWith("]"))) {
    try {
      return JSON.parse(propValue);
    } catch (e2) {
    }
  }
  if (propValue != null && !isComplexType(propValue)) {
    if (propType & 4) {
      {
        return propValue === "false" ? false : propValue === "" || !!propValue;
      }
    }
    if (propType & 2) {
      return typeof propValue === "string" ? parseFloat(propValue) : typeof propValue === "number" ? propValue : NaN;
    }
    if (propType & 1) {
      return String(propValue);
    }
    return propValue;
  }
  return propValue;
};
var getElement = (ref) => {
  return ref;
};
var createEvent = (ref, name, flags) => {
  const elm = getElement(ref);
  return {
    emit: (detail) => {
      return emitEvent(elm, name, {
        bubbles: !!(flags & 4),
        composed: !!(flags & 2),
        cancelable: !!(flags & 1),
        detail
      });
    }
  };
};
var emitEvent = (elm, name, opts) => {
  const ev = plt.ce(name, opts);
  elm.dispatchEvent(ev);
  return ev;
};
var setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags, initialRender) => {
  if (oldValue === newValue) {
    return;
  }
  let isProp = isMemberInElement(elm, memberName);
  let ln = memberName.toLowerCase();
  if (memberName === "class") {
    const classList = elm.classList;
    const oldClasses = parseClassList(oldValue);
    let newClasses = parseClassList(newValue);
    {
      classList.remove(...oldClasses.filter((c2) => c2 && !newClasses.includes(c2)));
      classList.add(...newClasses.filter((c2) => c2 && !oldClasses.includes(c2)));
    }
  } else if (memberName === "style") {
    {
      for (const prop in oldValue) {
        if (!newValue || newValue[prop] == null) {
          if (prop.includes("-")) {
            elm.style.removeProperty(prop);
          } else {
            elm.style[prop] = "";
          }
        }
      }
    }
    for (const prop in newValue) {
      if (!oldValue || newValue[prop] !== oldValue[prop]) {
        if (prop.includes("-")) {
          elm.style.setProperty(prop, newValue[prop]);
        } else {
          elm.style[prop] = newValue[prop];
        }
      }
    }
  } else if (memberName === "key") ;
  else if (memberName === "ref") {
    if (newValue) {
      newValue(elm);
    }
  } else if (!elm.__lookupSetter__(memberName) && memberName[0] === "o" && memberName[1] === "n") {
    if (memberName[2] === "-") {
      memberName = memberName.slice(3);
    } else if (isMemberInElement(win, ln)) {
      memberName = ln.slice(2);
    } else {
      memberName = ln[2] + memberName.slice(3);
    }
    if (oldValue || newValue) {
      const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);
      memberName = memberName.replace(CAPTURE_EVENT_REGEX, "");
      if (oldValue) {
        plt.rel(elm, memberName, oldValue, capture);
      }
      if (newValue) {
        plt.ael(elm, memberName, newValue, capture);
      }
    }
  } else {
    const isComplex = isComplexType(newValue);
    if ((isProp || isComplex && newValue !== null) && !isSvg) {
      try {
        if (!elm.tagName.includes("-")) {
          const n2 = newValue == null ? "" : newValue;
          if (memberName === "list") {
            isProp = false;
          } else if (oldValue == null || elm[memberName] != n2) {
            if (typeof elm.__lookupSetter__(memberName) === "function") {
              elm[memberName] = n2;
            } else {
              elm.setAttribute(memberName, n2);
            }
          }
        } else if (elm[memberName] !== newValue) {
          elm[memberName] = newValue;
        }
      } catch (e2) {
      }
    }
    let xlink = false;
    {
      if (ln !== (ln = ln.replace(/^xlink\:?/, ""))) {
        memberName = ln;
        xlink = true;
      }
    }
    if (newValue == null || newValue === false) {
      if (newValue !== false || elm.getAttribute(memberName) === "") {
        if (xlink) {
          elm.removeAttributeNS(XLINK_NS, memberName);
        } else {
          elm.removeAttribute(memberName);
        }
      }
    } else if ((!isProp || flags & 4 || isSvg) && !isComplex && elm.nodeType === 1) {
      newValue = newValue === true ? "" : newValue;
      if (xlink) {
        elm.setAttributeNS(XLINK_NS, memberName, newValue);
      } else {
        elm.setAttribute(memberName, newValue);
      }
    }
  }
};
var parseClassListRegex = /\s/;
var parseClassList = (value) => {
  if (typeof value === "object" && value && "baseVal" in value) {
    value = value.baseVal;
  }
  if (!value || typeof value !== "string") {
    return [];
  }
  return value.split(parseClassListRegex);
};
var CAPTURE_EVENT_SUFFIX = "Capture";
var CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + "$");
var updateElement = (oldVnode, newVnode, isSvgMode2, isInitialRender) => {
  const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || {};
  const newVnodeAttrs = newVnode.$attrs$ || {};
  {
    for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {
      if (!(memberName in newVnodeAttrs)) {
        setAccessor(
          elm,
          memberName,
          oldVnodeAttrs[memberName],
          void 0,
          isSvgMode2,
          newVnode.$flags$
        );
      }
    }
  }
  for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {
    setAccessor(
      elm,
      memberName,
      oldVnodeAttrs[memberName],
      newVnodeAttrs[memberName],
      isSvgMode2,
      newVnode.$flags$
    );
  }
};
function sortedAttrNames(attrNames) {
  return attrNames.includes("ref") ? (
    // we need to sort these to ensure that `'ref'` is the last attr
    [...attrNames.filter((attr) => attr !== "ref"), "ref"]
  ) : (
    // no need to sort, return the original array
    attrNames
  );
}
var scopeId;
var contentRef;
var hostTagName;
var useNativeShadowDom = false;
var checkSlotFallbackVisibility = false;
var checkSlotRelocate = false;
var isSvgMode = false;
var createElm = (oldParentVNode, newParentVNode, childIndex) => {
  var _a;
  const newVNode2 = newParentVNode.$children$[childIndex];
  let i2 = 0;
  let elm;
  let childNode;
  let oldVNode;
  if (!useNativeShadowDom) {
    checkSlotRelocate = true;
    if (newVNode2.$tag$ === "slot") {
      newVNode2.$flags$ |= newVNode2.$children$ ? (
        // slot element has fallback content
        // still create an element that "mocks" the slot element
        2
      ) : (
        // slot element does not have fallback content
        // create an html comment we'll use to always reference
        // where actual slot content should sit next to
        1
      );
    }
  }
  if (newVNode2.$text$ !== null) {
    elm = newVNode2.$elm$ = win.document.createTextNode(newVNode2.$text$);
  } else if (newVNode2.$flags$ & 1) {
    elm = newVNode2.$elm$ = win.document.createTextNode("");
    {
      updateElement(null, newVNode2, isSvgMode);
    }
  } else {
    if (!isSvgMode) {
      isSvgMode = newVNode2.$tag$ === "svg";
    }
    if (!win.document) {
      throw new Error(
        "You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component."
      );
    }
    elm = newVNode2.$elm$ = win.document.createElementNS(
      isSvgMode ? SVG_NS : HTML_NS,
      !useNativeShadowDom && BUILD.slotRelocation && newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$
    );
    if (isSvgMode && newVNode2.$tag$ === "foreignObject") {
      isSvgMode = false;
    }
    {
      updateElement(null, newVNode2, isSvgMode);
    }
    if (isDef(scopeId) && elm["s-si"] !== scopeId) {
      elm.classList.add(elm["s-si"] = scopeId);
    }
    if (newVNode2.$children$) {
      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {
        childNode = createElm(oldParentVNode, newVNode2, i2);
        if (childNode) {
          elm.appendChild(childNode);
        }
      }
    }
    {
      if (newVNode2.$tag$ === "svg") {
        isSvgMode = false;
      } else if (elm.tagName === "foreignObject") {
        isSvgMode = true;
      }
    }
  }
  elm["s-hn"] = hostTagName;
  {
    if (newVNode2.$flags$ & (2 | 1)) {
      elm["s-sr"] = true;
      elm["s-cr"] = contentRef;
      elm["s-sn"] = newVNode2.$name$ || "";
      elm["s-rf"] = (_a = newVNode2.$attrs$) == null ? void 0 : _a.ref;
      patchSlotNode(elm);
      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
        {
          putBackInOriginalLocation(oldParentVNode.$elm$, false);
        }
      }
      {
        addRemoveSlotScopedClass(contentRef, elm, newParentVNode.$elm$, oldParentVNode == null ? void 0 : oldParentVNode.$elm$);
      }
    }
  }
  return elm;
};
var putBackInOriginalLocation = (parentElm, recursive) => {
  plt.$flags$ |= 1;
  const oldSlotChildNodes = Array.from(parentElm.__childNodes || parentElm.childNodes);
  if (parentElm["s-sr"] && BUILD.experimentalSlotFixes) ;
  for (let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--) {
    const childNode = oldSlotChildNodes[i2];
    if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
      insertBefore(referenceNode(childNode).parentNode, childNode, referenceNode(childNode));
      childNode["s-ol"].remove();
      childNode["s-ol"] = void 0;
      childNode["s-sh"] = void 0;
      checkSlotRelocate = true;
    }
    if (recursive) {
      putBackInOriginalLocation(childNode, recursive);
    }
  }
  plt.$flags$ &= -2;
};
var addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
  let containerElm = parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
  let childNode;
  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
    containerElm = containerElm.shadowRoot;
  }
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnodes[startIdx]) {
      childNode = createElm(null, parentVNode, startIdx);
      if (childNode) {
        vnodes[startIdx].$elm$ = childNode;
        insertBefore(containerElm, childNode, referenceNode(before));
      }
    }
  }
};
var removeVnodes = (vnodes, startIdx, endIdx) => {
  for (let index = startIdx; index <= endIdx; ++index) {
    const vnode = vnodes[index];
    if (vnode) {
      const elm = vnode.$elm$;
      nullifyVNodeRefs(vnode);
      if (elm) {
        {
          checkSlotFallbackVisibility = true;
          if (elm["s-ol"]) {
            elm["s-ol"].remove();
          } else {
            putBackInOriginalLocation(elm, true);
          }
        }
        elm.remove();
      }
    }
  }
};
var updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let idxInOld = 0;
  let i2 = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let node;
  let elmToMove;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {
      patch(oldStartVnode, newStartVnode, isInitialRender);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {
      patch(oldEndVnode, newEndVnode, isInitialRender);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
      }
      patch(oldStartVnode, newEndVnode, isInitialRender);
      insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
      }
      patch(oldEndVnode, newStartVnode, isInitialRender);
      insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      idxInOld = -1;
      {
        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {
          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
            idxInOld = i2;
            break;
          }
        }
      }
      if (idxInOld >= 0) {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.$tag$ !== newStartVnode.$tag$) {
          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld);
        } else {
          patch(elmToMove, newStartVnode, isInitialRender);
          oldCh[idxInOld] = void 0;
          node = elmToMove.$elm$;
        }
        newStartVnode = newCh[++newStartIdx];
      } else {
        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx);
        newStartVnode = newCh[++newStartIdx];
      }
      if (node) {
        {
          insertBefore(
            referenceNode(oldStartVnode.$elm$).parentNode,
            node,
            referenceNode(oldStartVnode.$elm$)
          );
        }
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    addVnodes(
      parentElm,
      newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$,
      newVNode2,
      newCh,
      newStartIdx,
      newEndIdx
    );
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
  }
};
var isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {
  if (leftVNode.$tag$ === rightVNode.$tag$) {
    if (leftVNode.$tag$ === "slot") {
      return leftVNode.$name$ === rightVNode.$name$;
    }
    if (!isInitialRender) {
      return leftVNode.$key$ === rightVNode.$key$;
    }
    if (isInitialRender && !leftVNode.$key$ && rightVNode.$key$) {
      leftVNode.$key$ = rightVNode.$key$;
    }
    return true;
  }
  return false;
};
var referenceNode = (node) => node && node["s-ol"] || node;
var patch = (oldVNode, newVNode2, isInitialRender = false) => {
  const elm = newVNode2.$elm$ = oldVNode.$elm$;
  const oldChildren = oldVNode.$children$;
  const newChildren = newVNode2.$children$;
  const tag = newVNode2.$tag$;
  const text = newVNode2.$text$;
  let defaultHolder;
  if (text === null) {
    {
      isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
    }
    {
      updateElement(oldVNode, newVNode2, isSvgMode);
    }
    if (oldChildren !== null && newChildren !== null) {
      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);
    } else if (newChildren !== null) {
      if (oldVNode.$text$ !== null) {
        elm.textContent = "";
      }
      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
    } else if (
      // don't do this on initial render as it can cause non-hydrated content to be removed
      !isInitialRender && BUILD.updatable && oldChildren !== null
    ) {
      removeVnodes(oldChildren, 0, oldChildren.length - 1);
    } else ;
    if (isSvgMode && tag === "svg") {
      isSvgMode = false;
    }
  } else if (defaultHolder = elm["s-cr"]) {
    defaultHolder.parentNode.textContent = text;
  } else if (oldVNode.$text$ !== text) {
    elm.data = text;
  }
};
var relocateNodes = [];
var markSlotContentForRelocation = (elm) => {
  let node;
  let hostContentNodes;
  let j2;
  const children = elm.__childNodes || elm.childNodes;
  for (const childNode of children) {
    if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
      hostContentNodes = node.parentNode.__childNodes || node.parentNode.childNodes;
      const slotName = childNode["s-sn"];
      for (j2 = hostContentNodes.length - 1; j2 >= 0; j2--) {
        node = hostContentNodes[j2];
        if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"] && true) {
          if (isNodeLocatedInSlot(node, slotName)) {
            let relocateNodeData = relocateNodes.find((r2) => r2.$nodeToRelocate$ === node);
            checkSlotFallbackVisibility = true;
            node["s-sn"] = node["s-sn"] || slotName;
            if (relocateNodeData) {
              relocateNodeData.$nodeToRelocate$["s-sh"] = childNode["s-hn"];
              relocateNodeData.$slotRefNode$ = childNode;
            } else {
              node["s-sh"] = childNode["s-hn"];
              relocateNodes.push({
                $slotRefNode$: childNode,
                $nodeToRelocate$: node
              });
            }
            if (node["s-sr"]) {
              relocateNodes.map((relocateNode) => {
                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                  relocateNodeData = relocateNodes.find((r2) => r2.$nodeToRelocate$ === node);
                  if (relocateNodeData && !relocateNode.$slotRefNode$) {
                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                  }
                }
              });
            }
          } else if (!relocateNodes.some((r2) => r2.$nodeToRelocate$ === node)) {
            relocateNodes.push({
              $nodeToRelocate$: node
            });
          }
        }
      }
    }
    if (childNode.nodeType === 1) {
      markSlotContentForRelocation(childNode);
    }
  }
};
var nullifyVNodeRefs = (vNode) => {
  {
    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
  }
};
var insertBefore = (parent, newNode, reference) => {
  if (typeof newNode["s-sn"] === "string" && !!newNode["s-sr"] && !!newNode["s-cr"]) {
    addRemoveSlotScopedClass(newNode["s-cr"], newNode, parent, newNode.parentElement);
  }
  {
    return parent == null ? void 0 : parent.insertBefore(newNode, reference);
  }
};
function addRemoveSlotScopedClass(reference, slotNode, newParent, oldParent) {
  var _a, _b;
  let scopeId2;
  if (reference && typeof slotNode["s-sn"] === "string" && !!slotNode["s-sr"] && reference.parentNode && reference.parentNode["s-sc"] && (scopeId2 = slotNode["s-si"] || reference.parentNode["s-sc"])) {
    const scopeName = slotNode["s-sn"];
    const hostName = slotNode["s-hn"];
    (_a = newParent.classList) == null ? void 0 : _a.add(scopeId2 + "-s");
    if (oldParent && ((_b = oldParent.classList) == null ? void 0 : _b.contains(scopeId2 + "-s"))) {
      let child = (oldParent.__childNodes || oldParent.childNodes)[0];
      let found = false;
      while (child) {
        if (child["s-sn"] !== scopeName && child["s-hn"] === hostName && !!child["s-sr"]) {
          found = true;
          break;
        }
        child = child.nextSibling;
      }
      if (!found) oldParent.classList.remove(scopeId2 + "-s");
    }
  }
}
var renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
  var _a, _b, _c, _d, _e2;
  const hostElm = hostRef.$hostElement$;
  const cmpMeta = hostRef.$cmpMeta$;
  const oldVNode = hostRef.$vnode$ || newVNode(null, null);
  const isHostElement = isHost(renderFnResults);
  const rootVnode = isHostElement ? renderFnResults : h$1(null, null, renderFnResults);
  hostTagName = hostElm.tagName;
  if (cmpMeta.$attrsToReflect$) {
    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
    cmpMeta.$attrsToReflect$.map(
      ([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]
    );
  }
  if (isInitialLoad && rootVnode.$attrs$) {
    for (const key of Object.keys(rootVnode.$attrs$)) {
      if (hostElm.hasAttribute(key) && !["key", "ref", "style", "class"].includes(key)) {
        rootVnode.$attrs$[key] = hostElm[key];
      }
    }
  }
  rootVnode.$tag$ = null;
  rootVnode.$flags$ |= 4;
  hostRef.$vnode$ = rootVnode;
  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
  {
    scopeId = hostElm["s-sc"];
  }
  useNativeShadowDom = !!(cmpMeta.$flags$ & 1) && !(cmpMeta.$flags$ & 128);
  {
    contentRef = hostElm["s-cr"];
    checkSlotFallbackVisibility = false;
  }
  patch(oldVNode, rootVnode, isInitialLoad);
  {
    plt.$flags$ |= 1;
    if (checkSlotRelocate) {
      markSlotContentForRelocation(rootVnode.$elm$);
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        if (!nodeToRelocate["s-ol"] && win.document) {
          const orgLocationNode = win.document.createTextNode("");
          orgLocationNode["s-nr"] = nodeToRelocate;
          insertBefore(nodeToRelocate.parentNode, nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
        }
      }
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        const slotRefNode = relocateData.$slotRefNode$;
        if (slotRefNode) {
          const parentNodeRef = slotRefNode.parentNode;
          let insertBeforeNode = slotRefNode.nextSibling;
          {
            let orgLocationNode = (_a = nodeToRelocate["s-ol"]) == null ? void 0 : _a.previousSibling;
            while (orgLocationNode) {
              let refNode = (_b = orgLocationNode["s-nr"]) != null ? _b : null;
              if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === (refNode.__parentNode || refNode.parentNode)) {
                refNode = refNode.nextSibling;
                while (refNode === nodeToRelocate || (refNode == null ? void 0 : refNode["s-sr"])) {
                  refNode = refNode == null ? void 0 : refNode.nextSibling;
                }
                if (!refNode || !refNode["s-nr"]) {
                  insertBeforeNode = refNode;
                  break;
                }
              }
              orgLocationNode = orgLocationNode.previousSibling;
            }
          }
          const parent = nodeToRelocate.__parentNode || nodeToRelocate.parentNode;
          const nextSibling = nodeToRelocate.__nextSibling || nodeToRelocate.nextSibling;
          if (!insertBeforeNode && parentNodeRef !== parent || nextSibling !== insertBeforeNode) {
            if (nodeToRelocate !== insertBeforeNode) {
              if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
              }
              insertBefore(parentNodeRef, nodeToRelocate, insertBeforeNode);
              if (nodeToRelocate.nodeType === 1 && nodeToRelocate.tagName !== "SLOT-FB") {
                nodeToRelocate.hidden = (_c = nodeToRelocate["s-ih"]) != null ? _c : false;
              }
            }
          }
          nodeToRelocate && typeof slotRefNode["s-rf"] === "function" && slotRefNode["s-rf"](slotRefNode);
        } else {
          if (nodeToRelocate.nodeType === 1) {
            if (isInitialLoad) {
              nodeToRelocate["s-ih"] = (_d = nodeToRelocate.hidden) != null ? _d : false;
            }
            nodeToRelocate.hidden = true;
          }
        }
      }
    }
    if (checkSlotFallbackVisibility) {
      updateFallbackSlotVisibility(rootVnode.$elm$);
    }
    plt.$flags$ &= -2;
    relocateNodes.length = 0;
  }
  if (BUILD.experimentalScopedSlotChanges && cmpMeta.$flags$ & 2) {
    const children = rootVnode.$elm$.__childNodes || rootVnode.$elm$.childNodes;
    for (const childNode of children) {
      if (childNode["s-hn"] !== hostTagName && !childNode["s-sh"]) {
        if (isInitialLoad && childNode["s-ih"] == null) {
          childNode["s-ih"] = (_e2 = childNode.hidden) != null ? _e2 : false;
        }
        childNode.hidden = true;
      }
    }
  }
  contentRef = void 0;
};
var attachToAncestor = (hostRef, ancestorComponent) => {
  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
    const index = ancestorComponent["s-p"].push(
      new Promise(
        (r2) => hostRef.$onRenderResolve$ = () => {
          ancestorComponent["s-p"].splice(index - 1, 1);
          r2();
        }
      )
    );
  }
};
var scheduleUpdate = (hostRef, isInitialLoad) => {
  {
    hostRef.$flags$ |= 16;
  }
  if (hostRef.$flags$ & 4) {
    hostRef.$flags$ |= 512;
    return;
  }
  attachToAncestor(hostRef, hostRef.$ancestorComponent$);
  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
  if (isInitialLoad) {
    queueMicrotask(() => {
      dispatch();
    });
    return;
  }
  return writeTask(dispatch);
};
var dispatchHooks = (hostRef, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
  const instance2 = elm;
  if (!instance2) {
    throw new Error(
      "Can't render component <".concat(elm.tagName.toLowerCase(), " /> with invalid Stencil runtime! Make sure this imported component is compiled with a `externalRuntime: true` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime")
    );
  }
  let maybePromise;
  if (isInitialLoad) {
    maybePromise = safeCall(instance2, "componentWillLoad", void 0, elm);
  } else {
    maybePromise = safeCall(instance2, "componentWillUpdate", void 0, elm);
  }
  maybePromise = enqueue(maybePromise, () => safeCall(instance2, "componentWillRender", void 0, elm));
  endSchedule();
  return enqueue(maybePromise, () => updateComponent(hostRef, instance2, isInitialLoad));
};
var enqueue = (maybePromise, fn2) => isPromisey(maybePromise) ? maybePromise.then(fn2).catch((err2) => {
  console.error(err2);
  fn2();
}) : fn2();
var isPromisey = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === "function";
var updateComponent = async (hostRef, instance2, isInitialLoad) => {
  var _a;
  const elm = hostRef.$hostElement$;
  const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
  const rc = elm["s-rc"];
  if (isInitialLoad) {
    attachStyles(hostRef);
  }
  const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
  {
    callRender(hostRef, instance2, elm, isInitialLoad);
  }
  if (rc) {
    rc.map((cb) => cb());
    elm["s-rc"] = void 0;
  }
  endRender();
  endUpdate();
  {
    const childrenPromises = (_a = elm["s-p"]) != null ? _a : [];
    const postUpdate = () => postUpdateComponent(hostRef);
    if (childrenPromises.length === 0) {
      postUpdate();
    } else {
      Promise.all(childrenPromises).then(postUpdate);
      hostRef.$flags$ |= 4;
      childrenPromises.length = 0;
    }
  }
};
var renderingRef = null;
var callRender = (hostRef, instance2, elm, isInitialLoad) => {
  const allRenderFn = false;
  const lazyLoad = false;
  const taskQueue = true;
  const updatable = true;
  try {
    renderingRef = instance2;
    instance2 = allRenderFn ? instance2.render() : instance2.render && instance2.render();
    if (updatable && taskQueue) {
      hostRef.$flags$ &= ~16;
    }
    if (updatable || lazyLoad) {
      hostRef.$flags$ |= 2;
    }
    if (BUILD.hasRenderFn || BUILD.reflect) {
      if (BUILD.vdomRender || BUILD.reflect) {
        if (BUILD.hydrateServerSide) ;
        else {
          renderVdom(hostRef, instance2, isInitialLoad);
        }
      }
    }
  } catch (e2) {
    consoleError(e2, hostRef.$hostElement$);
  }
  renderingRef = null;
  return null;
};
var postUpdateComponent = (hostRef) => {
  const tagName = hostRef.$cmpMeta$.$tagName$;
  const elm = hostRef.$hostElement$;
  const endPostUpdate = createTime("postUpdate", tagName);
  const instance2 = elm;
  const ancestorComponent = hostRef.$ancestorComponent$;
  safeCall(instance2, "componentDidRender", void 0, elm);
  if (!(hostRef.$flags$ & 64)) {
    hostRef.$flags$ |= 64;
    {
      addHydratedFlag(elm);
    }
    safeCall(instance2, "componentDidLoad", void 0, elm);
    endPostUpdate();
    {
      hostRef.$onReadyResolve$(elm);
      if (!ancestorComponent) {
        appDidLoad();
      }
    }
  } else {
    safeCall(instance2, "componentDidUpdate", void 0, elm);
    endPostUpdate();
  }
  {
    if (hostRef.$onRenderResolve$) {
      hostRef.$onRenderResolve$();
      hostRef.$onRenderResolve$ = void 0;
    }
    if (hostRef.$flags$ & 512) {
      nextTick$1(() => scheduleUpdate(hostRef, false));
    }
    hostRef.$flags$ &= -517;
  }
};
var forceUpdate = (ref) => {
  var _a;
  {
    const hostRef = getHostRef(ref);
    const isConnected = (_a = hostRef == null ? void 0 : hostRef.$hostElement$) == null ? void 0 : _a.isConnected;
    if (isConnected && (hostRef.$flags$ & (2 | 16)) === 2) {
      scheduleUpdate(hostRef, false);
    }
    return isConnected;
  }
};
var appDidLoad = (who) => {
  nextTick$1(() => emitEvent(win, "appload", { detail: { namespace: NAMESPACE$1 } }));
};
var safeCall = (instance2, method, arg, elm) => {
  if (instance2 && instance2[method]) {
    try {
      return instance2[method](arg);
    } catch (e2) {
      consoleError(e2, elm);
    }
  }
  return void 0;
};
var addHydratedFlag = (elm) => {
  var _a;
  return elm.classList.add((_a = BUILD.hydratedSelectorName) != null ? _a : "hydrated");
};
var getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
var setValue = (ref, propName, newVal, cmpMeta) => {
  const hostRef = getHostRef(ref);
  if (!hostRef) {
    return;
  }
  const elm = ref;
  const oldVal = hostRef.$instanceValues$.get(propName);
  const flags = hostRef.$flags$;
  const instance2 = elm;
  newVal = parsePropertyValue(
    newVal,
    cmpMeta.$members$[propName][0]
  );
  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
  const didValueChange = newVal !== oldVal && !areBothNaN;
  if (didValueChange) {
    hostRef.$instanceValues$.set(propName, newVal);
    {
      if (cmpMeta.$watchers$ && flags & 128) {
        const watchMethods = cmpMeta.$watchers$[propName];
        if (watchMethods) {
          watchMethods.map((watchMethodName) => {
            try {
              instance2[watchMethodName](newVal, oldVal, propName);
            } catch (e2) {
              consoleError(e2, elm);
            }
          });
        }
      }
      if ((flags & (2 | 16)) === 2) {
        if (instance2.componentShouldUpdate) {
          if (instance2.componentShouldUpdate(newVal, oldVal, propName) === false) {
            return;
          }
        }
        scheduleUpdate(hostRef, false);
      }
    }
  }
};
var proxyComponent = (Cstr, cmpMeta, flags) => {
  var _a, _b;
  const prototype = Cstr.prototype;
  if (cmpMeta.$members$ || (cmpMeta.$watchers$ || Cstr.watchers)) {
    if (Cstr.watchers && !cmpMeta.$watchers$) {
      cmpMeta.$watchers$ = Cstr.watchers;
    }
    const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});
    members.map(([memberName, [memberFlags]]) => {
      if (memberFlags & 31 || memberFlags & 32) {
        const { get: origGetter, set: origSetter } = Object.getOwnPropertyDescriptor(prototype, memberName) || {};
        if (origGetter) cmpMeta.$members$[memberName][0] |= 2048;
        if (origSetter) cmpMeta.$members$[memberName][0] |= 4096;
        {
          Object.defineProperty(prototype, memberName, {
            get() {
              {
                return origGetter ? origGetter.apply(this) : getValue(this, memberName);
              }
            },
            configurable: true,
            enumerable: true
          });
        }
        Object.defineProperty(prototype, memberName, {
          set(newValue) {
            const ref = getHostRef(this);
            if (!ref) {
              return;
            }
            if (origSetter) {
              const currentValue = memberFlags & 32 ? this[memberName] : ref.$hostElement$[memberName];
              if (typeof currentValue === "undefined" && ref.$instanceValues$.get(memberName)) {
                newValue = ref.$instanceValues$.get(memberName);
              } else if (!ref.$instanceValues$.get(memberName) && currentValue) {
                ref.$instanceValues$.set(memberName, currentValue);
              }
              origSetter.apply(this, [
                parsePropertyValue(
                  newValue,
                  memberFlags
                )
              ]);
              newValue = memberFlags & 32 ? this[memberName] : ref.$hostElement$[memberName];
              setValue(this, memberName, newValue, cmpMeta);
              return;
            }
            {
              setValue(this, memberName, newValue, cmpMeta);
              return;
            }
          }
        });
      }
    });
    {
      const attrNameToPropName = /* @__PURE__ */ new Map();
      prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {
        plt.jmp(() => {
          var _a2;
          const propName = attrNameToPropName.get(attrName);
          if (this.hasOwnProperty(propName) && BUILD.lazyLoad) ;
          else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && // cast type to number to avoid TS compiler issues
          this[propName] == newValue) {
            return;
          } else if (propName == null) {
            const hostRef = getHostRef(this);
            const flags2 = hostRef == null ? void 0 : hostRef.$flags$;
            if (hostRef && flags2 && !(flags2 & 8) && flags2 & 128 && newValue !== oldValue) {
              const elm = this;
              const instance2 = elm;
              const entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];
              entry == null ? void 0 : entry.forEach((callbackName) => {
                if (instance2[callbackName] != null) {
                  instance2[callbackName].call(instance2, newValue, oldValue, attrName);
                }
              });
            }
            return;
          }
          const propDesc = Object.getOwnPropertyDescriptor(prototype, propName);
          newValue = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
          if (newValue !== this[propName] && (!propDesc.get || !!propDesc.set)) {
            this[propName] = newValue;
          }
        });
      };
      Cstr.observedAttributes = Array.from(
        /* @__PURE__ */ new Set([
          ...Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {}),
          ...members.filter(
            ([_23, m2]) => m2[0] & 15
            /* HasAttribute */
          ).map(([propName, m2]) => {
            var _a2;
            const attrName = m2[1] || propName;
            attrNameToPropName.set(attrName, propName);
            if (m2[0] & 512) {
              (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);
            }
            return attrName;
          })
        ])
      );
    }
  }
  return Cstr;
};
var initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {
  let Cstr;
  if ((hostRef.$flags$ & 32) === 0) {
    hostRef.$flags$ |= 32;
    cmpMeta.$lazyBundleId$;
    {
      Cstr = elm.constructor;
      const cmpTag = elm.localName;
      customElements.whenDefined(cmpTag).then(
        () => hostRef.$flags$ |= 128
        /* isWatchReady */
      );
    }
    if (Cstr && Cstr.style) {
      let style;
      if (typeof Cstr.style === "string") {
        style = Cstr.style;
      } else if (typeof Cstr.style !== "string") {
        hostRef.$modeName$ = computeMode(elm);
        if (hostRef.$modeName$) {
          style = Cstr.style[hostRef.$modeName$];
        }
      }
      const scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);
      if (!styles.has(scopeId2)) {
        const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
        endRegisterStyles();
      }
    }
  }
  const ancestorComponent = hostRef.$ancestorComponent$;
  const schedule = () => scheduleUpdate(hostRef, true);
  if (ancestorComponent && ancestorComponent["s-rc"]) {
    ancestorComponent["s-rc"].push(schedule);
  } else {
    schedule();
  }
};
var fireConnectedCallback = (instance2, elm) => {
};
var connectedCallback = (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    if (!hostRef) {
      return;
    }
    const cmpMeta = hostRef.$cmpMeta$;
    const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
    if (!(hostRef.$flags$ & 1)) {
      hostRef.$flags$ |= 1;
      {
        if (
          // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
          cmpMeta.$flags$ & (4 | 8)
        ) {
          setContentReference(elm);
        }
      }
      {
        let ancestorComponent = elm;
        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
          if (ancestorComponent["s-p"]) {
            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
            break;
          }
        }
      }
      if (cmpMeta.$members$) {
        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
            const value = elm[memberName];
            delete elm[memberName];
            elm[memberName] = value;
          }
        });
      }
      {
        initializeComponent(elm, hostRef, cmpMeta);
      }
    } else {
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {
        fireConnectedCallback(hostRef.$lazyInstance$);
      } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {
        hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$));
      }
    }
    endConnected();
  }
};
var setContentReference = (elm) => {
  if (!win.document) {
    return;
  }
  const contentRefElm = elm["s-cr"] = win.document.createComment(
    ""
  );
  contentRefElm["s-cn"] = true;
  insertBefore(elm, contentRefElm, elm.firstChild);
};
var disconnectedCallback = async (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    {
      if (hostRef == null ? void 0 : hostRef.$rmListeners$) {
        hostRef.$rmListeners$.map((rmListener) => rmListener());
        hostRef.$rmListeners$ = void 0;
      }
    }
  }
  if (rootAppliedStyles.has(elm)) {
    rootAppliedStyles.delete(elm);
  }
  if (elm.shadowRoot && rootAppliedStyles.has(elm.shadowRoot)) {
    rootAppliedStyles.delete(elm.shadowRoot);
  }
};
var proxyCustomElement = (Cstr, compactMeta) => {
  const cmpMeta = {
    $flags$: compactMeta[0],
    $tagName$: compactMeta[1]
  };
  {
    cmpMeta.$members$ = compactMeta[2];
  }
  {
    cmpMeta.$listeners$ = compactMeta[3];
  }
  {
    cmpMeta.$watchers$ = Cstr.$watchers$;
  }
  {
    cmpMeta.$attrsToReflect$ = [];
  }
  if (!(cmpMeta.$flags$ & 1) && cmpMeta.$flags$ & 256) ;
  const originalConnectedCallback = Cstr.prototype.connectedCallback;
  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
  Object.assign(Cstr.prototype, {
    __hasHostListenerAttached: false,
    __registerHost() {
      registerHost(this, cmpMeta);
    },
    connectedCallback() {
      if (!this.__hasHostListenerAttached) {
        const hostRef = getHostRef(this);
        if (!hostRef) {
          return;
        }
        addHostEventListeners(this, hostRef, cmpMeta.$listeners$);
        this.__hasHostListenerAttached = true;
      }
      connectedCallback(this);
      if (originalConnectedCallback) {
        originalConnectedCallback.call(this);
      }
    },
    disconnectedCallback() {
      disconnectedCallback(this);
      if (originalDisconnectedCallback) {
        originalDisconnectedCallback.call(this);
      }
    },
    __attachShadow() {
      {
        if (!this.shadowRoot) {
          createShadowRoot.call(this, cmpMeta);
        } else {
          if (this.shadowRoot.mode !== "open") {
            throw new Error(
              "Unable to re-use existing shadow root for ".concat(cmpMeta.$tagName$, "! Mode is set to ").concat(this.shadowRoot.mode, " but Stencil only supports open shadow roots.")
            );
          }
        }
      }
    }
  });
  Cstr.is = cmpMeta.$tagName$;
  return proxyComponent(
    Cstr,
    cmpMeta
  );
};
var addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
  if (listeners && win.document) {
    listeners.map(([flags, name, method]) => {
      const target = getHostListenerTarget(win.document, elm, flags);
      const handler = hostListenerProxy(hostRef, method);
      const opts = hostListenerOpts(flags);
      plt.ael(target, name, handler, opts);
      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
    });
  }
};
var hostListenerProxy = (hostRef, methodName) => (ev) => {
  var _a;
  try {
    if (BUILD.lazyLoad) ;
    else {
      hostRef.$hostElement$[methodName](ev);
    }
  } catch (e2) {
    consoleError(e2, hostRef.$hostElement$);
  }
};
var getHostListenerTarget = (doc, elm, flags) => {
  if (flags & 4) {
    return doc;
  }
  if (flags & 8) {
    return win;
  }
  if (flags & 16) {
    return doc.body;
  }
  return elm;
};
var hostListenerOpts = (flags) => supportsListenerOptions ? {
  passive: (flags & 1) !== 0,
  capture: (flags & 2) !== 0
} : (flags & 2) !== 0;
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
const isObjectType = (value) => typeof value === "object";
var isObject$5 = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event2) => isObject$5(event2) && event2.target ? isCheckBoxInput(event2.target) ? event2.target.checked : event2.target.value : event2;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject$4 = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject$5(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy2;
  const isArray = Array.isArray(data);
  const isFileListInstance = typeof FileList !== "undefined" ? data instanceof FileList : false;
  if (data instanceof Date) {
    copy2 = new Date(data);
  } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray || isObject$5(data))) {
    copy2 = isArray ? [] : Object.create(Object.getPrototypeOf(data));
    if (!isArray && !isPlainObject$4(data)) {
      copy2 = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy2[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy2;
}
var isKey = (value) => /^\w*$/.test(value);
var isUndefined$1 = (val) => val === void 0;
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
var get$2 = (object2, path2, defaultValue2) => {
  if (!path2 || !isObject$5(object2)) {
    return defaultValue2;
  }
  const result = (isKey(path2) ? [path2] : stringToPath(path2)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], object2);
  return isUndefined$1(result) || result === object2 ? isUndefined$1(object2[path2]) ? defaultValue2 : object2[path2] : result;
};
var isBoolean$1 = (value) => typeof value === "boolean";
var set$2 = (object2, path2, value) => {
  let index = -1;
  const tempPath = isKey(path2) ? [path2] : stringToPath(path2);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index < length) {
    const key = tempPath[index];
    let newValue = value;
    if (index !== lastIndex) {
      const objValue = object2[key];
      newValue = isObject$5(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};
    }
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return;
    }
    object2[key] = newValue;
    object2 = object2[key];
  }
};
const EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
const VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
const INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
const HookFormContext = React.createContext(null);
HookFormContext.displayName = "HookFormContext";
const useFormContext = () => React.useContext(HookFormContext);
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
const useIsomorphicLayoutEffect$3 = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
function useFormState(props) {
  const methods2 = useFormContext();
  const { control = methods2.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = React.useState(control._formState);
  const _localProxyFormState = React.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  useIsomorphicLayoutEffect$3(() => control._subscribe({
    name,
    formState: _localProxyFormState.current,
    exact,
    callback: (formState2) => {
      !disabled && updateFormState({
        ...control._formState,
        ...formState2
      });
    }
  }), [name, disabled, exact]);
  React.useEffect(() => {
    _localProxyFormState.current.isValid && control._setValid(true);
  }, [control]);
  return React.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
}
var isString = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue2) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get$2(formValues, names, defaultValue2);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get$2(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual$1(object1, object2, _internal_visited = /* @__PURE__ */ new WeakSet()) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  if (_internal_visited.has(object1) || _internal_visited.has(object2)) {
    return true;
  }
  _internal_visited.add(object1);
  _internal_visited.add(object2);
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject$5(val1) && isObject$5(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual$1(val1, val2, _internal_visited) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
function useWatch(props) {
  const methods2 = useFormContext();
  const { control = methods2.control, name, defaultValue: defaultValue2, disabled, exact, compute } = props || {};
  const _defaultValue = React.useRef(defaultValue2);
  const _compute = React.useRef(compute);
  const _computeFormValues = React.useRef(void 0);
  _compute.current = compute;
  const defaultValueMemo = React.useMemo(() => control._getWatch(name, _defaultValue.current), [control, name]);
  const [value, updateValue] = React.useState(_compute.current ? _compute.current(defaultValueMemo) : defaultValueMemo);
  useIsomorphicLayoutEffect$3(() => control._subscribe({
    name,
    formState: {
      values: true
    },
    exact,
    callback: (formState) => {
      if (!disabled) {
        const formValues = generateWatchOutput(name, control._names, formState.values || control._formValues, false, _defaultValue.current);
        if (_compute.current) {
          const computedFormValues = _compute.current(formValues);
          if (!deepEqual$1(computedFormValues, _computeFormValues.current)) {
            updateValue(computedFormValues);
            _computeFormValues.current = computedFormValues;
          }
        } else {
          updateValue(formValues);
        }
      }
    }
  }), [control, disabled, name, exact]);
  React.useEffect(() => control._removeUnmounted());
  return value;
}
function useController(props) {
  const methods2 = useFormContext();
  const { name, disabled, control = methods2.control, shouldUnregister, defaultValue: defaultValue2 } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const defaultValueMemo = React.useMemo(() => get$2(control._formValues, name, get$2(control._defaultValues, name, defaultValue2)), [control, name, defaultValue2]);
  const value = useWatch({
    control,
    name,
    defaultValue: defaultValueMemo,
    exact: true
  });
  const formState = useFormState({
    control,
    name,
    exact: true
  });
  const _props = React.useRef(props);
  const _registerProps = React.useRef(control.register(name, {
    ...props.rules,
    value,
    ...isBoolean$1(props.disabled) ? { disabled: props.disabled } : {}
  }));
  _props.current = props;
  const fieldState = React.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: true,
      get: () => !!get$2(formState.errors, name)
    },
    isDirty: {
      enumerable: true,
      get: () => !!get$2(formState.dirtyFields, name)
    },
    isTouched: {
      enumerable: true,
      get: () => !!get$2(formState.touchedFields, name)
    },
    isValidating: {
      enumerable: true,
      get: () => !!get$2(formState.validatingFields, name)
    },
    error: {
      enumerable: true,
      get: () => get$2(formState.errors, name)
    }
  }), [formState, name]);
  const onChange = React.useCallback((event2) => _registerProps.current.onChange({
    target: {
      value: getEventValue(event2),
      name
    },
    type: EVENTS.CHANGE
  }), [name]);
  const onBlur = React.useCallback(() => _registerProps.current.onBlur({
    target: {
      value: get$2(control._formValues, name),
      name
    },
    type: EVENTS.BLUR
  }), [name, control._formValues]);
  const ref = React.useCallback((elm) => {
    const field2 = get$2(control._fields, name);
    if (field2 && elm) {
      field2._f.ref = {
        focus: () => elm.focus && elm.focus(),
        select: () => elm.select && elm.select(),
        setCustomValidity: (message2) => elm.setCustomValidity(message2),
        reportValidity: () => elm.reportValidity()
      };
    }
  }, [control._fields, name]);
  const field = React.useMemo(() => ({
    name,
    value,
    ...isBoolean$1(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
    onChange,
    onBlur,
    ref
  }), [name, disabled, formState.disabled, onChange, onBlur, ref, value]);
  React.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    control.register(name, {
      ..._props.current.rules,
      ...isBoolean$1(_props.current.disabled) ? { disabled: _props.current.disabled } : {}
    });
    const updateMounted = (name2, value2) => {
      const field2 = get$2(control._fields, name2);
      if (field2 && field2._f) {
        field2._f.mount = value2;
      }
    };
    updateMounted(name, true);
    if (_shouldUnregisterField) {
      const value2 = cloneObject(get$2(control._options.defaultValues, name));
      set$2(control._defaultValues, name, value2);
      if (isUndefined$1(get$2(control._formValues, name))) {
        set$2(control._formValues, name, value2);
      }
    }
    !isArrayField && control.register(name);
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  React.useEffect(() => {
    control._setDisabledField({
      disabled,
      name
    });
  }, [disabled, name, control]);
  return React.useMemo(() => ({
    field,
    formState,
    fieldState
  }), [field, formState, fieldState]);
}
const Controller$1 = (props) => props.render(useController(props));
var appendErrors = (name, validateAllFieldCriteria, errors, type, message2) => validateAllFieldCriteria ? {
  ...errors[name],
  types: {
    ...errors[name] && errors[name].types ? errors[name].types : {},
    [type]: message2 || true
  }
} : {};
var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
var createSubject = () => {
  let _observers = [];
  const next = (value) => {
    for (const observer of _observers) {
      observer.next && observer.next(value);
    }
  };
  const subscribe = (observer) => {
    _observers.push(observer);
    return {
      unsubscribe: () => {
        _observers = _observers.filter((o2) => o2 !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers = [];
  };
  return {
    get observers() {
      return _observers;
    },
    next,
    subscribe,
    unsubscribe
  };
};
var isEmptyObject = (value) => isObject$5(value) && !Object.keys(value).length;
var isFileInput = (element) => element.type === "file";
var isFunction$2 = (value) => typeof value === "function";
var isHTMLElement$1 = (value) => {
  if (!isWeb) {
    return false;
  }
  const owner = value ? value.ownerDocument : 0;
  return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMultipleSelect = (element) => element.type === "select-multiple";
var isRadioInput = (element) => element.type === "radio";
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement$1(ref) && ref.isConnected;
function baseGet(object2, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index = 0;
  while (index < length) {
    object2 = isUndefined$1(object2) ? index++ : object2[updatePath[index++]];
  }
  return object2;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && !isUndefined$1(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset(object2, path2) {
  const paths = Array.isArray(path2) ? path2 : isKey(path2) ? [path2] : stringToPath(path2);
  const childObject = paths.length === 1 ? object2 : baseGet(object2, paths);
  const index = paths.length - 1;
  const key = paths[index];
  if (childObject) {
    delete childObject[key];
  }
  if (index !== 0 && (isObject$5(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object2, paths.slice(0, -1));
  }
  return object2;
}
var objectHasFunction = (data) => {
  for (const key in data) {
    if (isFunction$2(data[key])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data, fields = {}) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject$5(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject$5(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject$5(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject$5(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined$1(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : { ...markFieldsDirty(data[key]) };
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual$1(data[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
const defaultResult = {
  value: false,
  isValid: false
};
const validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values2 = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values2, isValid: !!values2.length };
    }
    return options[0].checked && !options[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      options[0].attributes && !isUndefined$1(options[0].attributes.value) ? isUndefined$1(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult
    ) : defaultResult;
  }
  return defaultResult;
};
var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined$1(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
const defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getFieldValue(_f) {
  const ref = _f.ref;
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined$1(ref.value) ? _f.ref.value : ref.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name of fieldsNames) {
    const field = get$2(_fields, name);
    field && set$2(fields, name, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var isRegex = (value) => value instanceof RegExp;
var getRuleValue = (rule) => isUndefined$1(rule) ? rule : isRegex(rule) ? rule.source : isObject$5(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
const ASYNC_FUNCTION = "AsyncFunction";
var hasPromiseValidation = (fieldReference) => !!fieldReference && !!fieldReference.validate && !!(isFunction$2(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject$5(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION));
var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
const iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get$2(fields, key);
    if (field) {
      const { _f, ...currentField } = field;
      if (_f) {
        if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
          return true;
        } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
          return true;
        } else {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      } else if (isObject$5(currentField)) {
        if (iterateFieldsByAction(currentField, action)) {
          break;
        }
      }
    }
  }
  return;
};
function schemaErrorLookup(errors, _fields, name) {
  const error2 = get$2(errors, name);
  if (error2 || isKey(name)) {
    return {
      error: error2,
      name
    };
  }
  const names = name.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get$2(_fields, fieldName);
    const foundError = get$2(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    if (foundError && foundError.root && foundError.root.type) {
      return {
        name: "".concat(fieldName, ".root"),
        error: foundError.root
      };
    }
    names.pop();
  }
  return {
    name
  };
}
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
  updateFormState(formStateData);
  const { name, ...formState } = formStateData;
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
};
var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name) => !compact(get$2(ref, name)).length && unset(ref, name);
var updateFieldArrayRootError = (errors, error2, name) => {
  const fieldArrayErrors = convertToArrayPayload(get$2(errors, name));
  set$2(fieldArrayErrors, "root", error2[name]);
  set$2(errors, name, fieldArrayErrors);
  return errors;
};
var isMessage = (value) => isString(value);
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean$1(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var getValueAndMessage = (validationData) => isObject$5(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref, refs, required, maxLength, minLength, min: min2, max: max2, pattern, validate, name, valueAsNumber, mount } = field._f;
  const inputValue = get$2(formValues, name);
  if (!mount || disabledFieldNames.has(name)) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = (message2) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean$1(message2) ? "" : message2 || "");
      inputRef.reportValidity();
    }
  };
  const error2 = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty2 = (valueAsNumber || isFileInput(ref)) && isUndefined$1(ref.value) && isUndefined$1(inputValue) || isHTMLElement$1(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error2);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message2 = exceedMax ? maxLengthMessage : minLengthMessage;
    error2[name] = {
      type: exceedMax ? maxType : minType,
      message: message2,
      ref,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message2)
    };
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty2 || isNullOrUndefined(inputValue)) || isBoolean$1(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value, message: message2 } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
    if (value) {
      error2[name] = {
        type: INPUT_VALIDATION_RULES.required,
        message: message2,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message2)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message2);
        return error2;
      }
    }
  }
  if (!isEmpty2 && (!isNullOrUndefined(min2) || !isNullOrUndefined(max2))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max2);
    const minOutput = getValueAndMessage(min2);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      const convertTimeToDate = (time) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time);
      const isTime = ref.type == "time";
      const isWeek = ref.type == "week";
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error2[name].message);
        return error2;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty2 && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error2[name].message);
        return error2;
      }
    }
  }
  if (pattern && !isEmpty2 && isString(inputValue)) {
    const { value: patternValue, message: message2 } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error2[name] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message: message2,
        ref,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message2)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message2);
        return error2;
      }
    }
  }
  if (validate) {
    if (isFunction$2(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error2[name] = {
          ...validateError,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error2;
        }
      }
    } else if (isObject$5(validate)) {
      let validationResult = {};
      for (const key in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key, validateError.message)
          };
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error2[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error2[name] = {
          ref: inputRef,
          ...validationResult
        };
        if (!validateAllFieldCriteria) {
          return error2;
        }
      }
    }
  }
  setCustomValidity(true);
  return error2;
};
const defaultOptions$2 = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}) {
  let _options = {
    ...defaultOptions$2,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isReady: false,
    isLoading: isFunction$2(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false
  };
  let _fields = {};
  let _defaultValues = isObject$5(_options.defaultValues) || isObject$5(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    disabled: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  let _proxySubscribeFormState = {
    ..._proxyFormState
  };
  const _subjects = {
    array: createSubject(),
    state: createSubject()
  };
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce = (callback) => (wait) => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait);
  };
  const _setValid = async (shouldUpdateValid) => {
    if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {
      const isValid2 = _options.resolver ? isEmptyObject((await _runSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid2 !== _formState.isValid) {
        _subjects.state.next({
          isValid: isValid2
        });
      }
    }
  };
  const _updateIsValidating = (names, isValidating) => {
    if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {
      (names || Array.from(_names.mount)).forEach((name) => {
        if (name) {
          isValidating ? set$2(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
        }
      });
      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields)
      });
    }
  };
  const _setFieldArray = (name, values2 = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method && !_options.disabled) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get$2(_fields, name))) {
        const fieldValues = method(get$2(_fields, name), args.argA, args.argB);
        shouldSetValues && set$2(_fields, name, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get$2(_formState.errors, name))) {
        const errors = method(get$2(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set$2(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get$2(_formState.touchedFields, name))) {
        const touchedFields = method(get$2(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set$2(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values2),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set$2(_formValues, name, values2);
    }
  };
  const updateErrors = (name, error2) => {
    set$2(_formState.errors, name, error2);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const _setErrors = (errors) => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
    const field = get$2(_fields, name);
    if (field) {
      const defaultValue2 = get$2(_formValues, name, isUndefined$1(value) ? get$2(_defaultValues, name) : value);
      isUndefined$1(defaultValue2) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set$2(_formValues, name, shouldSkipSetValueAs ? defaultValue2 : getFieldValue(field._f)) : setFieldValue(name, defaultValue2);
      _state.mount && _setValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output3 = {
      name
    };
    if (!_options.disabled) {
      if (!isBlurEvent || shouldDirty) {
        if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {
          isPreviousDirty = _formState.isDirty;
          _formState.isDirty = output3.isDirty = _getDirty();
          shouldUpdateField = isPreviousDirty !== output3.isDirty;
        }
        const isCurrentFieldPristine = deepEqual$1(get$2(_defaultValues, name), fieldValue);
        isPreviousDirty = !!get$2(_formState.dirtyFields, name);
        isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set$2(_formState.dirtyFields, name, true);
        output3.dirtyFields = _formState.dirtyFields;
        shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;
      }
      if (isBlurEvent) {
        const isPreviousFieldTouched = get$2(_formState.touchedFields, name);
        if (!isPreviousFieldTouched) {
          set$2(_formState.touchedFields, name, isBlurEvent);
          output3.touchedFields = _formState.touchedFields;
          shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;
        }
      }
      shouldUpdateField && shouldRender && _subjects.state.next(output3);
    }
    return shouldUpdateField ? output3 : {};
  };
  const shouldRenderByError = (name, isValid2, error2, fieldState) => {
    const previousFieldError = get$2(_formState.errors, name);
    const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean$1(isValid2) && _formState.isValid !== isValid2;
    if (_options.delayError && error2) {
      delayErrorCallback = debounce(() => updateErrors(name, error2));
      delayErrorCallback(_options.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error2 ? set$2(_formState.errors, name, error2) : unset(_formState.errors, name);
    }
    if ((error2 ? !deepEqual$1(previousFieldError, error2) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean$1(isValid2) ? { isValid: isValid2 } : {},
        errors: _formState.errors,
        name
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
  };
  const _runSchema = async (name) => {
    _updateIsValidating(name, true);
    const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
    _updateIsValidating(name);
    return result;
  };
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _runSchema(names);
    if (names) {
      for (const name of names) {
        const error2 = get$2(errors, name);
        error2 ? set$2(_formState.errors, name, error2) : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context2 = {
    valid: true
  }) => {
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const { _f, ...fieldValue } = field;
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const isPromiseFunction = field._f && hasPromiseValidation(field._f);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name], true);
          }
          const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name]);
          }
          if (fieldError[_f.name]) {
            context2.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get$2(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set$2(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
        }
        !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context2);
      }
    }
    return context2.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get$2(_fields, name);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name, data) => !_options.disabled && (name && data && set$2(_formValues, name, data), !deepEqual$1(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue2, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined$1(defaultValue2) ? _defaultValues : isString(names) ? { [names]: defaultValue2 } : defaultValue2
  }, isGlobal, defaultValue2);
  const _getFieldArray = (name) => compact(get$2(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get$2(_defaultValues, name, []) : []));
  const setFieldValue = (name, value, options = {}) => {
    const field = get$2(_fields, name);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set$2(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement$1(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.forEach((checkboxRef) => {
              if (!checkboxRef.defaultChecked || !checkboxRef.disabled) {
                if (Array.isArray(fieldValue)) {
                  checkboxRef.checked = !!fieldValue.find((data) => data === checkboxRef.value);
                } else {
                  checkboxRef.checked = fieldValue === checkboxRef.value || !!fieldValue;
                }
              }
            });
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.state.next({
              name,
              values: cloneObject(_formValues)
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger(name);
  };
  const setValues = (name, value, options) => {
    for (const fieldKey in value) {
      if (!value.hasOwnProperty(fieldKey)) {
        return;
      }
      const fieldValue = value[fieldKey];
      const fieldName = name + "." + fieldKey;
      const field = get$2(_fields, fieldName);
      (_names.array.has(name) || isObject$5(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue2 = (name, value, options = {}) => {
    const field = get$2(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);
    set$2(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: cloneObject(_formValues)
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options.shouldDirty) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
    }
    isWatched(name, _names) && _subjects.state.next({ ..._formState, name });
    _subjects.state.next({
      name: _state.mount ? name : void 0,
      values: cloneObject(_formValues)
    });
  };
  const onChange = async (event2) => {
    _state.mount = true;
    const target = event2.target;
    let name = target.name;
    let isFieldValueUpdated = true;
    const field = get$2(_fields, name);
    const _updateIsFieldValueUpdated = (fieldValue) => {
      isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual$1(fieldValue, get$2(_formValues, name, fieldValue));
    };
    const validationModeBeforeSubmit = getValidationModes(_options.mode);
    const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
    if (field) {
      let error2;
      let isValid2;
      const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event2);
      const isBlurEvent = event2.type === EVENTS.BLUR || event2.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get$2(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get$2(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set$2(_formValues, name, fieldValue);
      if (isBlurEvent) {
        if (!target || !target.readOnly) {
          field._f.onBlur && field._f.onBlur(event2);
          delayErrorCallback && delayErrorCallback(0);
        }
      } else if (field._f.onChange) {
        field._f.onChange(event2);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.state.next({
        name,
        type: event2.type,
        values: cloneObject(_formValues)
      });
      if (shouldSkipValidation) {
        if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
          if (_options.mode === "onBlur") {
            if (isBlurEvent) {
              _setValid();
            }
          } else if (!isBlurEvent) {
            _setValid();
          }
        }
        return shouldRender && _subjects.state.next({ name, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      if (_options.resolver) {
        const { errors } = await _runSchema([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
          const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
          error2 = errorLookupResult.error;
          name = errorLookupResult.name;
          isValid2 = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name], true);
        error2 = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        _updateIsValidating([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          if (error2) {
            isValid2 = false;
          } else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
            isValid2 = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger(field._f.deps);
        shouldRenderByError(name, isValid2, error2, fieldState);
      }
    }
  };
  const _focusInput = (ref, key) => {
    if (get$2(_formState.errors, key) && ref.focus) {
      ref.focus();
      return 1;
    }
    return;
  };
  const trigger = async (name, options = {}) => {
    let isValid2;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined$1(name) ? name : fieldNames);
      isValid2 = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some((name2) => get$2(errors, name2)) : isValid2;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get$2(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _setValid();
    } else {
      validationResult = isValid2 = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid2 !== _formState.isValid ? {} : { name },
      ..._options.resolver || !name ? { isValid: isValid2 } : {},
      errors: _formState.errors
    });
    options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values2 = {
      ..._state.mount ? _formValues : _defaultValues
    };
    return isUndefined$1(fieldNames) ? values2 : isString(fieldNames) ? get$2(values2, fieldNames) : fieldNames.map((name) => get$2(values2, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get$2((formState || _formState).errors, name),
    isDirty: !!get$2((formState || _formState).dirtyFields, name),
    error: get$2((formState || _formState).errors, name),
    isValidating: !!get$2(_formState.validatingFields, name),
    isTouched: !!get$2((formState || _formState).touchedFields, name)
  });
  const clearErrors = (name) => {
    name && convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name ? _formState.errors : {}
    });
  };
  const setError = (name, error2, options) => {
    const ref = (get$2(_fields, name, { _f: {} })._f || {}).ref;
    const currentError = get$2(_formState.errors, name) || {};
    const { ref: currentRef, message: message2, type, ...restOfErrorTree } = currentError;
    set$2(_formState.errors, name, {
      ...restOfErrorTree,
      ...error2,
      ref
    });
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue2) => isFunction$2(name) ? _subjects.state.subscribe({
    next: (payload) => "values" in payload && name(_getWatch(void 0, defaultValue2), payload)
  }) : _getWatch(name, defaultValue2, true);
  const _subscribe = (props2) => _subjects.state.subscribe({
    next: (formState) => {
      if (shouldSubscribeByName(props2.name, formState.name, props2.exact) && shouldRenderFormState(formState, props2.formState || _proxyFormState, _setFormState, props2.reRenderRoot)) {
        props2.callback({
          values: { ..._formValues },
          ..._formState,
          ...formState,
          defaultValues: _defaultValues
        });
      }
    }
  }).unsubscribe;
  const subscribe = (props2) => {
    _state.mount = true;
    _proxySubscribeFormState = {
      ..._proxySubscribeFormState,
      ...props2.formState
    };
    return _subscribe({
      ...props2,
      formState: _proxySubscribeFormState
    });
  };
  const unregister = (name, options = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }
      !options.keepError && unset(_formState.errors, fieldName);
      !options.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options.keepTouched && unset(_formState.touchedFields, fieldName);
      !options.keepIsValidating && unset(_formState.validatingFields, fieldName);
      !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
    }
    _subjects.state.next({
      values: cloneObject(_formValues)
    });
    _subjects.state.next({
      ..._formState,
      ...!options.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options.keepIsValid && _setValid();
  };
  const _setDisabledField = ({ disabled, name }) => {
    if (isBoolean$1(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {
      disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
    }
  };
  const register2 = (name, options = {}) => {
    let field = get$2(_fields, name);
    const disabledIsDefined = isBoolean$1(options.disabled) || isBoolean$1(_options.disabled);
    set$2(_fields, name, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name } },
        name,
        mount: true,
        ...options
      }
    });
    _names.mount.add(name);
    if (field) {
      _setDisabledField({
        disabled: isBoolean$1(options.disabled) ? options.disabled : _options.disabled,
        name
      });
    } else {
      updateValidAndValue(name, true, options.value);
    }
    return {
      ...disabledIsDefined ? { disabled: options.disabled || _options.disabled } : {},
      ..._options.progressive ? {
        required: !!options.required,
        min: getRuleValue(options.min),
        max: getRuleValue(options.max),
        minLength: getRuleValue(options.minLength),
        maxLength: getRuleValue(options.maxLength),
        pattern: getRuleValue(options.pattern)
      } : {},
      name,
      onChange,
      onBlur: onChange,
      ref: (ref) => {
        if (ref) {
          register2(name, options);
          field = get$2(_fields, name);
          const fieldRef = isUndefined$1(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set$2(_fields, name, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get$2(_defaultValues, name)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name, false, void 0, fieldRef);
        } else {
          field = get$2(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
  const _disableForm = (disabled) => {
    if (isBoolean$1(disabled)) {
      _subjects.state.next({ disabled });
      iterateFieldsByAction(_fields, (ref, name) => {
        const currentField = get$2(_fields, name);
        if (currentField) {
          ref.disabled = currentField._f.disabled || disabled;
          if (Array.isArray(currentField._f.refs)) {
            currentField._f.refs.forEach((inputRef) => {
              inputRef.disabled = currentField._f.disabled || disabled;
            });
          }
        }
      }, 0, false);
    }
  };
  const handleSubmit = (onValid, onInvalid) => async (e2) => {
    let onValidError = void 0;
    if (e2) {
      e2.preventDefault && e2.preventDefault();
      e2.persist && e2.persist();
    }
    let fieldValues = cloneObject(_formValues);
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values: values2 } = await _runSchema();
      _formState.errors = errors;
      fieldValues = cloneObject(values2);
    } else {
      await executeBuiltInValidation(_fields);
    }
    if (_names.disabled.size) {
      for (const name of _names.disabled) {
        unset(fieldValues, name);
      }
    }
    unset(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      try {
        await onValid(fieldValues, e2);
      } catch (error2) {
        onValidError = error2;
      }
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e2);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
    if (onValidError) {
      throw onValidError;
    }
  };
  const resetField = (name, options = {}) => {
    if (get$2(_fields, name)) {
      if (isUndefined$1(options.defaultValue)) {
        setValue2(name, cloneObject(get$2(_defaultValues, name)));
      } else {
        setValue2(name, options.defaultValue);
        set$2(_defaultValues, name, cloneObject(options.defaultValue));
      }
      if (!options.keepTouched) {
        unset(_formState.touchedFields, name);
      }
      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get$2(_defaultValues, name))) : _getDirty();
      }
      if (!options.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _setValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values2 = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        const fieldsToCheck = /* @__PURE__ */ new Set([
          ..._names.mount,
          ...Object.keys(getDirtyFields(_defaultValues, _formValues))
        ]);
        for (const fieldName of Array.from(fieldsToCheck)) {
          get$2(_formState.dirtyFields, fieldName) ? set$2(values2, fieldName, get$2(_formValues, fieldName)) : setValue2(fieldName, get$2(values2, fieldName));
        }
      } else {
        if (isWeb && isUndefined$1(formValues)) {
          for (const name of _names.mount) {
            const field = get$2(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement$1(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        if (keepStateOptions.keepFieldsRef) {
          for (const fieldName of _names.mount) {
            setValue2(fieldName, get$2(values2, fieldName));
          }
        } else {
          _fields = {};
        }
      }
      _formValues = _options.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values2);
      _subjects.array.next({
        values: { ...values2 }
      });
      _subjects.state.next({
        values: { ...values2 }
      });
    }
    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      disabled: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
    _state.watch = !!_options.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual$1(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
      isSubmitting: false,
      defaultValues: _defaultValues
    });
  };
  const reset2 = (formValues, keepStateOptions) => _reset(isFunction$2(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name, options = {}) => {
    const field = get$2(_fields, name);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect && isFunction$2(fieldRef.select) && fieldRef.select();
      }
    }
  };
  const _setFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  const _resetDefaultValues = () => isFunction$2(_options.defaultValues) && _options.defaultValues().then((values2) => {
    reset2(values2, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  const methods2 = {
    control: {
      register: register2,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _subscribe,
      _runSchema,
      _focusError,
      _getWatch,
      _getDirty,
      _setValid,
      _setFieldArray,
      _setDisabledField,
      _setErrors,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _removeUnmounted,
      _disableForm,
      _subjects,
      _proxyFormState,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value
        };
      }
    },
    subscribe,
    trigger,
    register: register2,
    handleSubmit,
    watch,
    setValue: setValue2,
    getValues,
    reset: reset2,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
  return {
    ...methods2,
    formControl: methods2
  };
}
function useForm(props = {}) {
  const _formControl = React.useRef(void 0);
  const _values = React.useRef(void 0);
  const [formState, updateFormState] = React.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction$2(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    isReady: false,
    defaultValues: isFunction$2(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    if (props.formControl) {
      _formControl.current = {
        ...props.formControl,
        formState
      };
      if (props.defaultValues && !isFunction$2(props.defaultValues)) {
        props.formControl.reset(props.defaultValues, props.resetOptions);
      }
    } else {
      const { formControl, ...rest2 } = createFormControl(props);
      _formControl.current = {
        ...rest2,
        formState
      };
    }
  }
  const control = _formControl.current.control;
  control._options = props;
  useIsomorphicLayoutEffect$3(() => {
    const sub = control._subscribe({
      formState: control._proxyFormState,
      callback: () => updateFormState({ ...control._formState }),
      reRenderRoot: true
    });
    updateFormState((data) => ({
      ...data,
      isReady: true
    }));
    control._formState.isReady = true;
    return sub;
  }, [control]);
  React.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
  React.useEffect(() => {
    if (props.mode) {
      control._options.mode = props.mode;
    }
    if (props.reValidateMode) {
      control._options.reValidateMode = props.reValidateMode;
    }
  }, [control, props.mode, props.reValidateMode]);
  React.useEffect(() => {
    if (props.errors) {
      control._setErrors(props.errors);
      control._focusError();
    }
  }, [control, props.errors]);
  React.useEffect(() => {
    props.shouldUnregister && control._subjects.state.next({
      values: control._getWatch()
    });
  }, [control, props.shouldUnregister]);
  React.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty = control._getDirty();
      if (isDirty !== formState.isDirty) {
        control._subjects.state.next({
          isDirty
        });
      }
    }
  }, [control, formState.isDirty]);
  React.useEffect(() => {
    if (props.values && !deepEqual$1(props.values, _values.current)) {
      control._reset(props.values, {
        keepFieldsRef: true,
        ...control._options.resetOptions
      });
      _values.current = props.values;
      updateFormState((state) => ({ ...state }));
    } else {
      control._resetDefaultValues();
    }
  }, [control, props.values]);
  React.useEffect(() => {
    if (!control._state.mount) {
      control._setValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}
const s$1 = (e2, s2, o2) => {
  if (e2 && "reportValidity" in e2) {
    const r2 = get$2(o2, s2);
    e2.setCustomValidity(r2 && r2.message || ""), e2.reportValidity();
  }
}, o$2 = (t2, e2) => {
  for (const o2 in e2.fields) {
    const r2 = e2.fields[o2];
    r2 && r2.ref && "reportValidity" in r2.ref ? s$1(r2.ref, o2, t2) : r2.refs && r2.refs.forEach((e3) => s$1(e3, o2, t2));
  }
}, r$1 = (s2, r2) => {
  r2.shouldUseNativeValidation && o$2(s2, r2);
  const f2 = {};
  for (const o2 in s2) {
    const n2 = get$2(r2.fields, o2), a2 = Object.assign(s2[o2] || {}, { ref: n2 && n2.ref });
    if (i$2(r2.names || Object.keys(s2), o2)) {
      const s3 = Object.assign({}, get$2(f2, o2));
      set$2(s3, "root", a2), set$2(f2, o2, s3);
    } else set$2(f2, o2, a2);
  }
  return f2;
}, i$2 = (t2, e2) => t2.some((t3) => t3.startsWith(e2 + "."));
function o$1(o2, n2, a2) {
  return void 0 === n2 && (n2 = {}), void 0 === a2 && (a2 = {}), function(s2, i2, c2) {
    try {
      return Promise.resolve((function(t2, r2) {
        try {
          var u2 = (n2.context && false, Promise.resolve(o2["sync" === a2.mode ? "validateSync" : "validate"](s2, Object.assign({ abortEarly: false }, n2, { context: i2 }))).then(function(t3) {
            return c2.shouldUseNativeValidation && o$2({}, c2), { values: a2.raw ? s2 : t3, errors: {} };
          }));
        } catch (e2) {
          return r2(e2);
        }
        return u2 && u2.then ? u2.then(void 0, r2) : u2;
      })(0, function(e2) {
        if (!e2.inner) throw e2;
        return { values: {}, errors: r$1((o3 = e2, n22 = !c2.shouldUseNativeValidation && "all" === c2.criteriaMode, (o3.inner || []).reduce(function(e3, t2) {
          if (e3[t2.path] || (e3[t2.path] = { message: t2.message, type: t2.type }), n22) {
            var o4 = e3[t2.path].types, a22 = o4 && o4[t2.type];
            e3[t2.path] = appendErrors(t2.path, n22, e3, t2.type, a22 ? [].concat(a22, t2.message) : t2.message);
          }
          return e3;
        }, {})), c2) };
        var o3, n22;
      }));
    } catch (e2) {
      return Promise.reject(e2);
    }
  };
}
var propertyExpr;
var hasRequiredPropertyExpr;
function requirePropertyExpr() {
  if (hasRequiredPropertyExpr) return propertyExpr;
  hasRequiredPropertyExpr = 1;
  function Cache(maxSize) {
    this._maxSize = maxSize;
    this.clear();
  }
  Cache.prototype.clear = function() {
    this._size = 0;
    this._values = /* @__PURE__ */ Object.create(null);
  };
  Cache.prototype.get = function(key) {
    return this._values[key];
  };
  Cache.prototype.set = function(key, value) {
    this._size >= this._maxSize && this.clear();
    if (!(key in this._values)) this._size++;
    return this._values[key] = value;
  };
  var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g, DIGIT_REGEX = /^\d+$/, LEAD_DIGIT_REGEX = /^\d/, SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/, MAX_CACHE_SIZE = 512;
  var pathCache = new Cache(MAX_CACHE_SIZE), setCache = new Cache(MAX_CACHE_SIZE), getCache = new Cache(MAX_CACHE_SIZE);
  propertyExpr = {
    Cache,
    split,
    normalizePath,
    setter: function(path2) {
      var parts = normalizePath(path2);
      return setCache.get(path2) || setCache.set(path2, function setter(obj, value) {
        var index = 0;
        var len = parts.length;
        var data = obj;
        while (index < len - 1) {
          var part = parts[index];
          if (part === "__proto__" || part === "constructor" || part === "prototype") {
            return obj;
          }
          data = data[parts[index++]];
        }
        data[parts[index]] = value;
      });
    },
    getter: function(path2, safe) {
      var parts = normalizePath(path2);
      return getCache.get(path2) || getCache.set(path2, function getter(data) {
        var index = 0, len = parts.length;
        while (index < len) {
          if (data != null || !safe) data = data[parts[index++]];
          else return;
        }
        return data;
      });
    },
    join: function(segments) {
      return segments.reduce(function(path2, part) {
        return path2 + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path2 ? "." : "") + part);
      }, "");
    },
    forEach: function(path2, cb, thisArg) {
      forEach3(Array.isArray(path2) ? path2 : split(path2), cb, thisArg);
    }
  };
  function normalizePath(path2) {
    return pathCache.get(path2) || pathCache.set(
      path2,
      split(path2).map(function(part) {
        return part.replace(CLEAN_QUOTES_REGEX, "$2");
      })
    );
  }
  function split(path2) {
    return path2.match(SPLIT_REGEX) || [""];
  }
  function forEach3(parts, iter, thisArg) {
    var len = parts.length, part, idx, isArray, isBracket;
    for (idx = 0; idx < len; idx++) {
      part = parts[idx];
      if (part) {
        if (shouldBeQuoted(part)) {
          part = '"' + part + '"';
        }
        isBracket = isQuoted(part);
        isArray = !isBracket && /^\d+$/.test(part);
        iter.call(thisArg, part, isBracket, isArray, idx, parts);
      }
    }
  }
  function isQuoted(str) {
    return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
  }
  function hasLeadingNumber(part) {
    return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
  }
  function hasSpecialChars(part) {
    return SPEC_CHAR_REGEX.test(part);
  }
  function shouldBeQuoted(part) {
    return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
  }
  return propertyExpr;
}
var propertyExprExports = requirePropertyExpr();
var tinyCase;
var hasRequiredTinyCase;
function requireTinyCase() {
  if (hasRequiredTinyCase) return tinyCase;
  hasRequiredTinyCase = 1;
  const reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
  const words = (str) => str.match(reWords) || [];
  const upperFirst = (str) => str[0].toUpperCase() + str.slice(1);
  const join2 = (str, d2) => words(str).join(d2).toLowerCase();
  const camelCase = (str) => words(str).reduce(
    (acc, next) => "".concat(acc).concat(!acc ? next.toLowerCase() : next[0].toUpperCase() + next.slice(1).toLowerCase()),
    ""
  );
  const pascalCase = (str) => upperFirst(camelCase(str));
  const snakeCase = (str) => join2(str, "_");
  const kebabCase = (str) => join2(str, "-");
  const sentenceCase = (str) => upperFirst(join2(str, " "));
  const titleCase = (str) => words(str).map(upperFirst).join(" ");
  tinyCase = {
    words,
    upperFirst,
    camelCase,
    pascalCase,
    snakeCase,
    kebabCase,
    sentenceCase,
    titleCase
  };
  return tinyCase;
}
var tinyCaseExports = requireTinyCase();
var toposort$1 = { exports: {} };
var hasRequiredToposort;
function requireToposort() {
  if (hasRequiredToposort) return toposort$1.exports;
  hasRequiredToposort = 1;
  toposort$1.exports = function(edges) {
    return toposort2(uniqueNodes(edges), edges);
  };
  toposort$1.exports.array = toposort2;
  function toposort2(nodes, edges) {
    var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i2 = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
    edges.forEach(function(edge) {
      if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
        throw new Error("Unknown node. There is an unknown node in the supplied edges.");
      }
    });
    while (i2--) {
      if (!visited[i2]) visit(nodes[i2], i2, /* @__PURE__ */ new Set());
    }
    return sorted;
    function visit(node, i3, predecessors) {
      if (predecessors.has(node)) {
        var nodeRep;
        try {
          nodeRep = ", node was:" + JSON.stringify(node);
        } catch (e2) {
          nodeRep = "";
        }
        throw new Error("Cyclic dependency" + nodeRep);
      }
      if (!nodesHash.has(node)) {
        throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
      }
      if (visited[i3]) return;
      visited[i3] = true;
      var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
      outgoing = Array.from(outgoing);
      if (i3 = outgoing.length) {
        predecessors.add(node);
        do {
          var child = outgoing[--i3];
          visit(child, nodesHash.get(child), predecessors);
        } while (i3);
        predecessors.delete(node);
      }
      sorted[--cursor] = node;
    }
  }
  function uniqueNodes(arr2) {
    var res = /* @__PURE__ */ new Set();
    for (var i2 = 0, len = arr2.length; i2 < len; i2++) {
      var edge = arr2[i2];
      res.add(edge[0]);
      res.add(edge[1]);
    }
    return Array.from(res);
  }
  function makeOutgoingEdges(arr2) {
    var edges = /* @__PURE__ */ new Map();
    for (var i2 = 0, len = arr2.length; i2 < len; i2++) {
      var edge = arr2[i2];
      if (!edges.has(edge[0])) edges.set(edge[0], /* @__PURE__ */ new Set());
      if (!edges.has(edge[1])) edges.set(edge[1], /* @__PURE__ */ new Set());
      edges.get(edge[0]).add(edge[1]);
    }
    return edges;
  }
  function makeNodesHash(arr2) {
    var res = /* @__PURE__ */ new Map();
    for (var i2 = 0, len = arr2.length; i2 < len; i2++) {
      res.set(arr2[i2], i2);
    }
    return res;
  }
  return toposort$1.exports;
}
var toposortExports = requireToposort();
const toposort = /* @__PURE__ */ getDefaultExportFromCjs(toposortExports);
const toString$1 = Object.prototype.toString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
const symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
function printNumber(val) {
  if (val != +val) return "NaN";
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? "-0" : "" + val;
}
function printSimpleValue(val, quoteStrings = false) {
  if (val == null || val === true || val === false) return "" + val;
  const typeOf = typeof val;
  if (typeOf === "number") return printNumber(val);
  if (typeOf === "string") return quoteStrings ? '"'.concat(val, '"') : val;
  if (typeOf === "function") return "[Function " + (val.name || "anonymous") + "]";
  if (typeOf === "symbol") return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  const tag = toString$1.call(val).slice(8, -1);
  if (tag === "Date") return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
  if (tag === "Error" || val instanceof Error) return "[" + errorToString.call(val) + "]";
  if (tag === "RegExp") return regExpToString.call(val);
  return null;
}
function printValue(value, quoteStrings) {
  let result = printSimpleValue(value, quoteStrings);
  if (result !== null) return result;
  return JSON.stringify(value, function(key, value2) {
    let result2 = printSimpleValue(this[key], quoteStrings);
    if (result2 !== null) return result2;
    return value2;
  }, 2);
}
function toArray$1(value) {
  return value == null ? [] : [].concat(value);
}
let _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;
let strReg = /\$\{\s*(\w+)\s*\}/g;
_Symbol$toStringTag = Symbol.toStringTag;
class ValidationErrorNoStack {
  constructor(errorOrErrors, value, field, type) {
    this.name = void 0;
    this.message = void 0;
    this.value = void 0;
    this.path = void 0;
    this.type = void 0;
    this.params = void 0;
    this.errors = void 0;
    this.inner = void 0;
    this[_Symbol$toStringTag] = "Error";
    this.name = "ValidationError";
    this.value = value;
    this.path = field;
    this.type = type;
    this.errors = [];
    this.inner = [];
    toArray$1(errorOrErrors).forEach((err2) => {
      if (ValidationError.isError(err2)) {
        this.errors.push(...err2.errors);
        const innerErrors = err2.inner.length ? err2.inner : [err2];
        this.inner.push(...innerErrors);
      } else {
        this.errors.push(err2);
      }
    });
    this.message = this.errors.length > 1 ? "".concat(this.errors.length, " errors occurred") : this.errors[0];
  }
}
_Symbol$hasInstance = Symbol.hasInstance;
_Symbol$toStringTag2 = Symbol.toStringTag;
class ValidationError extends Error {
  static formatError(message2, params) {
    const path2 = params.label || params.path || "this";
    params = Object.assign({}, params, {
      path: path2,
      originalPath: params.path
    });
    if (typeof message2 === "string") return message2.replace(strReg, (_23, key) => printValue(params[key]));
    if (typeof message2 === "function") return message2(params);
    return message2;
  }
  static isError(err2) {
    return err2 && err2.name === "ValidationError";
  }
  constructor(errorOrErrors, value, field, type, disableStack) {
    const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);
    if (disableStack) {
      return errorNoStack;
    }
    super();
    this.value = void 0;
    this.path = void 0;
    this.type = void 0;
    this.params = void 0;
    this.errors = [];
    this.inner = [];
    this[_Symbol$toStringTag2] = "Error";
    this.name = errorNoStack.name;
    this.message = errorNoStack.message;
    this.type = errorNoStack.type;
    this.value = errorNoStack.value;
    this.path = errorNoStack.path;
    this.errors = errorNoStack.errors;
    this.inner = errorNoStack.inner;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ValidationError);
    }
  }
  static [_Symbol$hasInstance](inst) {
    return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);
  }
}
let mixed = {
  default: "${path} is invalid",
  required: "${path} is a required field",
  defined: "${path} must be defined",
  notNull: "${path} cannot be null",
  oneOf: "${path} must be one of the following values: ${values}",
  notOneOf: "${path} must not be one of the following values: ${values}",
  notType: ({
    path: path2,
    type,
    value,
    originalValue
  }) => {
    const castMsg = originalValue != null && originalValue !== value ? " (cast from the value `".concat(printValue(originalValue, true), "`).") : ".";
    return type !== "mixed" ? "".concat(path2, " must be a `").concat(type, "` type, ") + "but the final value was: `".concat(printValue(value, true), "`") + castMsg : "".concat(path2, " must match the configured type. ") + "The validated value was: `".concat(printValue(value, true), "`") + castMsg;
  }
};
let string = {
  length: "${path} must be exactly ${length} characters",
  min: "${path} must be at least ${min} characters",
  max: "${path} must be at most ${max} characters",
  matches: '${path} must match the following: "${regex}"',
  email: "${path} must be a valid email",
  url: "${path} must be a valid URL",
  uuid: "${path} must be a valid UUID",
  datetime: "${path} must be a valid ISO date-time",
  datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
  datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
  trim: "${path} must be a trimmed string",
  lowercase: "${path} must be a lowercase string",
  uppercase: "${path} must be a upper case string"
};
let number = {
  min: "${path} must be greater than or equal to ${min}",
  max: "${path} must be less than or equal to ${max}",
  lessThan: "${path} must be less than ${less}",
  moreThan: "${path} must be greater than ${more}",
  positive: "${path} must be a positive number",
  negative: "${path} must be a negative number",
  integer: "${path} must be an integer"
};
let date = {
  min: "${path} field must be later than ${min}",
  max: "${path} field must be at earlier than ${max}"
};
let boolean = {
  isValue: "${path} field must be ${value}"
};
let object = {
  noUnknown: "${path} field has unspecified keys: ${unknown}",
  exact: "${path} object contains unknown properties: ${properties}"
};
let array = {
  min: "${path} field must have at least ${min} items",
  max: "${path} field must have less than or equal to ${max} items",
  length: "${path} must have ${length} items"
};
let tuple = {
  notType: (params) => {
    const {
      path: path2,
      value,
      spec
    } = params;
    const typeLen = spec.types.length;
    if (Array.isArray(value)) {
      if (value.length < typeLen) return "".concat(path2, " tuple value has too few items, expected a length of ").concat(typeLen, " but got ").concat(value.length, " for value: `").concat(printValue(value, true), "`");
      if (value.length > typeLen) return "".concat(path2, " tuple value has too many items, expected a length of ").concat(typeLen, " but got ").concat(value.length, " for value: `").concat(printValue(value, true), "`");
    }
    return ValidationError.formatError(mixed.notType, params);
  }
};
var locale = Object.assign(/* @__PURE__ */ Object.create(null), {
  mixed,
  string,
  number,
  date,
  object,
  array,
  boolean,
  tuple
});
const isSchema = (obj) => obj && obj.__isYupSchema__;
class Condition {
  static fromOptions(refs, config) {
    if (!config.then && !config.otherwise) throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
    let {
      is: is2,
      then,
      otherwise
    } = config;
    let check = typeof is2 === "function" ? is2 : (...values2) => values2.every((value) => value === is2);
    return new Condition(refs, (values2, schema) => {
      var _branch;
      let branch = check(...values2) ? then : otherwise;
      return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
    });
  }
  constructor(refs, builder) {
    this.fn = void 0;
    this.refs = refs;
    this.refs = refs;
    this.fn = builder;
  }
  resolve(base, options) {
    let values2 = this.refs.map((ref) => (
      // TODO: ? operator here?
      ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context)
    ));
    let schema = this.fn(values2, base, options);
    if (schema === void 0 || // @ts-ignore this can be base
    schema === base) {
      return base;
    }
    if (!isSchema(schema)) throw new TypeError("conditions must return a schema object");
    return schema.resolve(options);
  }
}
const prefixes = {
  context: "$",
  value: "."
};
function create$9(key, options) {
  return new Reference(key, options);
}
class Reference {
  constructor(key, options = {}) {
    this.key = void 0;
    this.isContext = void 0;
    this.isValue = void 0;
    this.isSibling = void 0;
    this.path = void 0;
    this.getter = void 0;
    this.map = void 0;
    if (typeof key !== "string") throw new TypeError("ref must be a string, got: " + key);
    this.key = key.trim();
    if (key === "") throw new TypeError("ref must be a non-empty string");
    this.isContext = this.key[0] === prefixes.context;
    this.isValue = this.key[0] === prefixes.value;
    this.isSibling = !this.isContext && !this.isValue;
    let prefix2 = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
    this.path = this.key.slice(prefix2.length);
    this.getter = this.path && propertyExprExports.getter(this.path, true);
    this.map = options.map;
  }
  getValue(value, parent, context2) {
    let result = this.isContext ? context2 : this.isValue ? value : parent;
    if (this.getter) result = this.getter(result || {});
    if (this.map) result = this.map(result);
    return result;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {Object=} options.context
   * @param {Object=} options.parent
   */
  cast(value, options) {
    return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: "ref",
      key: this.key
    };
  }
  toString() {
    return "Ref(".concat(this.key, ")");
  }
  static isRef(value) {
    return value && value.__isYupRef;
  }
}
Reference.prototype.__isYupRef = true;
const isAbsent = (value) => value == null;
function createValidation(config) {
  function validate({
    value,
    path: path2 = "",
    options,
    originalValue,
    schema
  }, panic, next) {
    const {
      name,
      test,
      params,
      message: message2,
      skipAbsent
    } = config;
    let {
      parent,
      context: context2,
      abortEarly = schema.spec.abortEarly,
      disableStackTrace = schema.spec.disableStackTrace
    } = options;
    const resolveOptions = {
      value,
      parent,
      context: context2
    };
    function createError(overrides = {}) {
      const nextParams = resolveParams(Object.assign({
        value,
        originalValue,
        label: schema.spec.label,
        path: overrides.path || path2,
        spec: schema.spec,
        disableStackTrace: overrides.disableStackTrace || disableStackTrace
      }, params, overrides.params), resolveOptions);
      const error2 = new ValidationError(ValidationError.formatError(overrides.message || message2, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);
      error2.params = nextParams;
      return error2;
    }
    const invalid = abortEarly ? panic : next;
    let ctx = {
      path: path2,
      parent,
      type: name,
      from: options.from,
      createError,
      resolve(item) {
        return resolveMaybeRef(item, resolveOptions);
      },
      options,
      originalValue,
      schema
    };
    const handleResult = (validOrError) => {
      if (ValidationError.isError(validOrError)) invalid(validOrError);
      else if (!validOrError) invalid(createError());
      else next(null);
    };
    const handleError = (err2) => {
      if (ValidationError.isError(err2)) invalid(err2);
      else panic(err2);
    };
    const shouldSkip2 = skipAbsent && isAbsent(value);
    if (shouldSkip2) {
      return handleResult(true);
    }
    let result;
    try {
      var _result;
      result = test.call(ctx, value, ctx);
      if (typeof ((_result = result) == null ? void 0 : _result.then) === "function") {
        if (options.sync) {
          throw new Error('Validation test of type: "'.concat(ctx.type, '" returned a Promise during a synchronous validate. ') + "This test will finish after the validate call has returned");
        }
        return Promise.resolve(result).then(handleResult, handleError);
      }
    } catch (err2) {
      handleError(err2);
      return;
    }
    handleResult(result);
  }
  validate.OPTIONS = config;
  return validate;
}
function resolveParams(params, options) {
  if (!params) return params;
  for (const key of Object.keys(params)) {
    params[key] = resolveMaybeRef(params[key], options);
  }
  return params;
}
function resolveMaybeRef(item, options) {
  return Reference.isRef(item) ? item.getValue(options.value, options.parent, options.context) : item;
}
function getIn$2(schema, path2, value, context2 = value) {
  let parent, lastPart, lastPartDebug;
  if (!path2) return {
    parent,
    parentPath: path2,
    schema
  };
  propertyExprExports.forEach(path2, (_part, isBracket, isArray) => {
    let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
    schema = schema.resolve({
      context: context2,
      parent,
      value
    });
    let isTuple = schema.type === "tuple";
    let idx = isArray ? parseInt(part, 10) : 0;
    if (schema.innerType || isTuple) {
      if (isTuple && !isArray) throw new Error('Yup.reach cannot implicitly index into a tuple type. the path part "'.concat(lastPartDebug, '" must contain an index to the tuple element, e.g. "').concat(lastPartDebug, '[0]"'));
      if (value && idx >= value.length) {
        throw new Error("Yup.reach cannot resolve an array item at index: ".concat(_part, ", in the path: ").concat(path2, ". ") + "because there is no value at that index. ");
      }
      parent = value;
      value = value && value[idx];
      schema = isTuple ? schema.spec.types[idx] : schema.innerType;
    }
    if (!isArray) {
      if (!schema.fields || !schema.fields[part]) throw new Error("The schema does not contain the path: ".concat(path2, ". ") + "(failed at: ".concat(lastPartDebug, ' which is a type: "').concat(schema.type, '")'));
      parent = value;
      value = value && value[part];
      schema = schema.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
  });
  return {
    schema,
    parent,
    parentPath: lastPart
  };
}
function reach(obj, path2, value, context2) {
  return getIn$2(obj, path2, value, context2).schema;
}
class ReferenceSet extends Set {
  describe() {
    const description = [];
    for (const item of this.values()) {
      description.push(Reference.isRef(item) ? item.describe() : item);
    }
    return description;
  }
  resolveAll(resolve) {
    let result = [];
    for (const item of this.values()) {
      result.push(resolve(item));
    }
    return result;
  }
  clone() {
    return new ReferenceSet(this.values());
  }
  merge(newItems, removeItems) {
    const next = this.clone();
    newItems.forEach((value) => next.add(value));
    removeItems.forEach((value) => next.delete(value));
    return next;
  }
}
function clone(src, seen = /* @__PURE__ */ new Map()) {
  if (isSchema(src) || !src || typeof src !== "object") return src;
  if (seen.has(src)) return seen.get(src);
  let copy2;
  if (src instanceof Date) {
    copy2 = new Date(src.getTime());
    seen.set(src, copy2);
  } else if (src instanceof RegExp) {
    copy2 = new RegExp(src);
    seen.set(src, copy2);
  } else if (Array.isArray(src)) {
    copy2 = new Array(src.length);
    seen.set(src, copy2);
    for (let i2 = 0; i2 < src.length; i2++) copy2[i2] = clone(src[i2], seen);
  } else if (src instanceof Map) {
    copy2 = /* @__PURE__ */ new Map();
    seen.set(src, copy2);
    for (const [k2, v2] of src.entries()) copy2.set(k2, clone(v2, seen));
  } else if (src instanceof Set) {
    copy2 = /* @__PURE__ */ new Set();
    seen.set(src, copy2);
    for (const v2 of src) copy2.add(clone(v2, seen));
  } else if (src instanceof Object) {
    copy2 = {};
    seen.set(src, copy2);
    for (const [k2, v2] of Object.entries(src)) copy2[k2] = clone(v2, seen);
  } else {
    throw Error("Unable to clone ".concat(src));
  }
  return copy2;
}
function createStandardPath(path2) {
  if (!(path2 != null && path2.length)) {
    return void 0;
  }
  const segments = [];
  let currentSegment = "";
  let inBrackets = false;
  let inQuotes = false;
  for (let i2 = 0; i2 < path2.length; i2++) {
    const char = path2[i2];
    if (char === "[" && !inQuotes) {
      if (currentSegment) {
        segments.push(...currentSegment.split(".").filter(Boolean));
        currentSegment = "";
      }
      inBrackets = true;
      continue;
    }
    if (char === "]" && !inQuotes) {
      if (currentSegment) {
        if (/^\d+$/.test(currentSegment)) {
          segments.push(currentSegment);
        } else {
          segments.push(currentSegment.replace(/^"|"$/g, ""));
        }
        currentSegment = "";
      }
      inBrackets = false;
      continue;
    }
    if (char === '"') {
      inQuotes = !inQuotes;
      continue;
    }
    if (char === "." && !inBrackets && !inQuotes) {
      if (currentSegment) {
        segments.push(currentSegment);
        currentSegment = "";
      }
      continue;
    }
    currentSegment += char;
  }
  if (currentSegment) {
    segments.push(...currentSegment.split(".").filter(Boolean));
  }
  return segments;
}
function createStandardIssues(error2, parentPath) {
  const path2 = parentPath ? "".concat(parentPath, ".").concat(error2.path) : error2.path;
  return error2.errors.map((err2) => ({
    message: err2,
    path: createStandardPath(path2)
  }));
}
function issuesFromValidationError(error2, parentPath) {
  var _error$inner;
  if (!((_error$inner = error2.inner) != null && _error$inner.length) && error2.errors.length) {
    return createStandardIssues(error2, parentPath);
  }
  const path2 = parentPath ? "".concat(parentPath, ".").concat(error2.path) : error2.path;
  return error2.inner.flatMap((err2) => issuesFromValidationError(err2, path2));
}
class Schema {
  constructor(options) {
    this.type = void 0;
    this.deps = [];
    this.tests = void 0;
    this.transforms = void 0;
    this.conditions = [];
    this._mutate = void 0;
    this.internalTests = {};
    this._whitelist = new ReferenceSet();
    this._blacklist = new ReferenceSet();
    this.exclusiveTests = /* @__PURE__ */ Object.create(null);
    this._typeCheck = void 0;
    this.spec = void 0;
    this.tests = [];
    this.transforms = [];
    this.withMutation(() => {
      this.typeError(mixed.notType);
    });
    this.type = options.type;
    this._typeCheck = options.check;
    this.spec = Object.assign({
      strip: false,
      strict: false,
      abortEarly: true,
      recursive: true,
      disableStackTrace: false,
      nullable: false,
      optional: true,
      coerce: true
    }, options == null ? void 0 : options.spec);
    this.withMutation((s2) => {
      s2.nonNullable();
    });
  }
  // TODO: remove
  get _type() {
    return this.type;
  }
  clone(spec) {
    if (this._mutate) {
      if (spec) Object.assign(this.spec, spec);
      return this;
    }
    const next = Object.create(Object.getPrototypeOf(this));
    next.type = this.type;
    next._typeCheck = this._typeCheck;
    next._whitelist = this._whitelist.clone();
    next._blacklist = this._blacklist.clone();
    next.internalTests = Object.assign({}, this.internalTests);
    next.exclusiveTests = Object.assign({}, this.exclusiveTests);
    next.deps = [...this.deps];
    next.conditions = [...this.conditions];
    next.tests = [...this.tests];
    next.transforms = [...this.transforms];
    next.spec = clone(Object.assign({}, this.spec, spec));
    return next;
  }
  label(label) {
    let next = this.clone();
    next.spec.label = label;
    return next;
  }
  meta(...args) {
    if (args.length === 0) return this.spec.meta;
    let next = this.clone();
    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
    return next;
  }
  withMutation(fn2) {
    let before = this._mutate;
    this._mutate = true;
    let result = fn2(this);
    this._mutate = before;
    return result;
  }
  concat(schema) {
    if (!schema || schema === this) return this;
    if (schema.type !== this.type && this.type !== "mixed") throw new TypeError("You cannot `concat()` schema's of different types: ".concat(this.type, " and ").concat(schema.type));
    let base = this;
    let combined = schema.clone();
    const mergedSpec = Object.assign({}, base.spec, combined.spec);
    combined.spec = mergedSpec;
    combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);
    combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
    combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
    combined.tests = base.tests;
    combined.exclusiveTests = base.exclusiveTests;
    combined.withMutation((next) => {
      schema.tests.forEach((fn2) => {
        next.test(fn2.OPTIONS);
      });
    });
    combined.transforms = [...base.transforms, ...combined.transforms];
    return combined;
  }
  isType(v2) {
    if (v2 == null) {
      if (this.spec.nullable && v2 === null) return true;
      if (this.spec.optional && v2 === void 0) return true;
      return false;
    }
    return this._typeCheck(v2);
  }
  resolve(options) {
    let schema = this;
    if (schema.conditions.length) {
      let conditions = schema.conditions;
      schema = schema.clone();
      schema.conditions = [];
      schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);
      schema = schema.resolve(options);
    }
    return schema;
  }
  resolveOptions(options) {
    var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
    return Object.assign({}, options, {
      from: options.from || [],
      strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
      abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
      recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,
      disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
    });
  }
  /**
   * Run the configured transform pipeline over an input value.
   */
  cast(value, options = {}) {
    let resolvedSchema = this.resolve(Object.assign({
      value
    }, options));
    let allowOptionality = options.assert === "ignore-optionality";
    let result = resolvedSchema._cast(value, options);
    if (options.assert !== false && !resolvedSchema.isType(result)) {
      if (allowOptionality && isAbsent(result)) {
        return result;
      }
      let formattedValue = printValue(value);
      let formattedResult = printValue(result);
      throw new TypeError("The value of ".concat(options.path || "field", " could not be cast to a value ") + 'that satisfies the schema type: "'.concat(resolvedSchema.type, '". \n\n') + "attempted value: ".concat(formattedValue, " \n") + (formattedResult !== formattedValue ? "result of cast: ".concat(formattedResult) : ""));
    }
    return result;
  }
  _cast(rawValue, options) {
    let value = rawValue === void 0 ? rawValue : this.transforms.reduce((prevValue, fn2) => fn2.call(this, prevValue, rawValue, this), rawValue);
    if (value === void 0) {
      value = this.getDefault(options);
    }
    return value;
  }
  _validate(_value, options = {}, panic, next) {
    let {
      path: path2,
      originalValue = _value,
      strict = this.spec.strict
    } = options;
    let value = _value;
    if (!strict) {
      value = this._cast(value, Object.assign({
        assert: false
      }, options));
    }
    let initialTests = [];
    for (let test of Object.values(this.internalTests)) {
      if (test) initialTests.push(test);
    }
    this.runTests({
      path: path2,
      value,
      originalValue,
      options,
      tests: initialTests
    }, panic, (initialErrors) => {
      if (initialErrors.length) {
        return next(initialErrors, value);
      }
      this.runTests({
        path: path2,
        value,
        originalValue,
        options,
        tests: this.tests
      }, panic, next);
    });
  }
  /**
   * Executes a set of validations, either schema, produced Tests or a nested
   * schema validate result.
   */
  runTests(runOptions, panic, next) {
    let fired = false;
    let {
      tests,
      value,
      originalValue,
      path: path2,
      options
    } = runOptions;
    let panicOnce = (arg) => {
      if (fired) return;
      fired = true;
      panic(arg, value);
    };
    let nextOnce = (arg) => {
      if (fired) return;
      fired = true;
      next(arg, value);
    };
    let count2 = tests.length;
    let nestedErrors = [];
    if (!count2) return nextOnce([]);
    let args = {
      value,
      originalValue,
      path: path2,
      options,
      schema: this
    };
    for (let i2 = 0; i2 < tests.length; i2++) {
      const test = tests[i2];
      test(args, panicOnce, function finishTestRun(err2) {
        if (err2) {
          Array.isArray(err2) ? nestedErrors.push(...err2) : nestedErrors.push(err2);
        }
        if (--count2 <= 0) {
          nextOnce(nestedErrors);
        }
      });
    }
  }
  asNestedTest({
    key,
    index,
    parent,
    parentPath,
    originalParent,
    options
  }) {
    const k2 = key != null ? key : index;
    if (k2 == null) {
      throw TypeError("Must include `key` or `index` for nested validations");
    }
    const isIndex = typeof k2 === "number";
    let value = parent[k2];
    const testOptions = Object.assign({}, options, {
      // Nested validations fields are always strict:
      //    1. parent isn't strict so the casting will also have cast inner values
      //    2. parent is strict in which case the nested values weren't cast either
      strict: true,
      parent,
      value,
      originalValue: originalParent[k2],
      // FIXME: tests depend on `index` being passed around deeply,
      //   we should not let the options.key/index bleed through
      key: void 0,
      // index: undefined,
      [isIndex ? "index" : "key"]: k2,
      path: isIndex || k2.includes(".") ? "".concat(parentPath || "", "[").concat(isIndex ? k2 : '"'.concat(k2, '"'), "]") : (parentPath ? "".concat(parentPath, ".") : "") + key
    });
    return (_23, panic, next) => this.resolve(testOptions)._validate(value, testOptions, panic, next);
  }
  validate(value, options) {
    var _options$disableStack2;
    let schema = this.resolve(Object.assign({}, options, {
      value
    }));
    let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
    return new Promise((resolve, reject) => schema._validate(value, options, (error2, parsed) => {
      if (ValidationError.isError(error2)) error2.value = parsed;
      reject(error2);
    }, (errors, validated) => {
      if (errors.length) reject(new ValidationError(errors, validated, void 0, void 0, disableStackTrace));
      else resolve(validated);
    }));
  }
  validateSync(value, options) {
    var _options$disableStack3;
    let schema = this.resolve(Object.assign({}, options, {
      value
    }));
    let result;
    let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
    schema._validate(value, Object.assign({}, options, {
      sync: true
    }), (error2, parsed) => {
      if (ValidationError.isError(error2)) error2.value = parsed;
      throw error2;
    }, (errors, validated) => {
      if (errors.length) throw new ValidationError(errors, value, void 0, void 0, disableStackTrace);
      result = validated;
    });
    return result;
  }
  isValid(value, options) {
    return this.validate(value, options).then(() => true, (err2) => {
      if (ValidationError.isError(err2)) return false;
      throw err2;
    });
  }
  isValidSync(value, options) {
    try {
      this.validateSync(value, options);
      return true;
    } catch (err2) {
      if (ValidationError.isError(err2)) return false;
      throw err2;
    }
  }
  _getDefault(options) {
    let defaultValue2 = this.spec.default;
    if (defaultValue2 == null) {
      return defaultValue2;
    }
    return typeof defaultValue2 === "function" ? defaultValue2.call(this, options) : clone(defaultValue2);
  }
  getDefault(options) {
    let schema = this.resolve(options || {});
    return schema._getDefault(options);
  }
  default(def) {
    if (arguments.length === 0) {
      return this._getDefault();
    }
    let next = this.clone({
      default: def
    });
    return next;
  }
  strict(isStrict = true) {
    return this.clone({
      strict: isStrict
    });
  }
  nullability(nullable, message2) {
    const next = this.clone({
      nullable
    });
    next.internalTests.nullable = createValidation({
      message: message2,
      name: "nullable",
      test(value) {
        return value === null ? this.schema.spec.nullable : true;
      }
    });
    return next;
  }
  optionality(optional, message2) {
    const next = this.clone({
      optional
    });
    next.internalTests.optionality = createValidation({
      message: message2,
      name: "optionality",
      test(value) {
        return value === void 0 ? this.schema.spec.optional : true;
      }
    });
    return next;
  }
  optional() {
    return this.optionality(true);
  }
  defined(message2 = mixed.defined) {
    return this.optionality(false, message2);
  }
  nullable() {
    return this.nullability(true);
  }
  nonNullable(message2 = mixed.notNull) {
    return this.nullability(false, message2);
  }
  required(message2 = mixed.required) {
    return this.clone().withMutation((next) => next.nonNullable(message2).defined(message2));
  }
  notRequired() {
    return this.clone().withMutation((next) => next.nullable().optional());
  }
  transform(fn2) {
    let next = this.clone();
    next.transforms.push(fn2);
    return next;
  }
  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */
  test(...args) {
    let opts;
    if (args.length === 1) {
      if (typeof args[0] === "function") {
        opts = {
          test: args[0]
        };
      } else {
        opts = args[0];
      }
    } else if (args.length === 2) {
      opts = {
        name: args[0],
        test: args[1]
      };
    } else {
      opts = {
        name: args[0],
        message: args[1],
        test: args[2]
      };
    }
    if (opts.message === void 0) opts.message = mixed.default;
    if (typeof opts.test !== "function") throw new TypeError("`test` is a required parameters");
    let next = this.clone();
    let validate = createValidation(opts);
    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
    if (opts.exclusive) {
      if (!opts.name) throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
    }
    if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;
    next.tests = next.tests.filter((fn2) => {
      if (fn2.OPTIONS.name === opts.name) {
        if (isExclusive) return false;
        if (fn2.OPTIONS.test === validate.OPTIONS.test) return false;
      }
      return true;
    });
    next.tests.push(validate);
    return next;
  }
  when(keys2, options) {
    if (!Array.isArray(keys2) && typeof keys2 !== "string") {
      options = keys2;
      keys2 = ".";
    }
    let next = this.clone();
    let deps = toArray$1(keys2).map((key) => new Reference(key));
    deps.forEach((dep) => {
      if (dep.isSibling) next.deps.push(dep.key);
    });
    next.conditions.push(typeof options === "function" ? new Condition(deps, options) : Condition.fromOptions(deps, options));
    return next;
  }
  typeError(message2) {
    let next = this.clone();
    next.internalTests.typeError = createValidation({
      message: message2,
      name: "typeError",
      skipAbsent: true,
      test(value) {
        if (!this.schema._typeCheck(value)) return this.createError({
          params: {
            type: this.schema.type
          }
        });
        return true;
      }
    });
    return next;
  }
  oneOf(enums, message2 = mixed.oneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._whitelist.add(val);
      next._blacklist.delete(val);
    });
    next.internalTests.whiteList = createValidation({
      message: message2,
      name: "oneOf",
      skipAbsent: true,
      test(value) {
        let valids = this.schema._whitelist;
        let resolved = valids.resolveAll(this.resolve);
        return resolved.includes(value) ? true : this.createError({
          params: {
            values: Array.from(valids).join(", "),
            resolved
          }
        });
      }
    });
    return next;
  }
  notOneOf(enums, message2 = mixed.notOneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._blacklist.add(val);
      next._whitelist.delete(val);
    });
    next.internalTests.blacklist = createValidation({
      message: message2,
      name: "notOneOf",
      test(value) {
        let invalids = this.schema._blacklist;
        let resolved = invalids.resolveAll(this.resolve);
        if (resolved.includes(value)) return this.createError({
          params: {
            values: Array.from(invalids).join(", "),
            resolved
          }
        });
        return true;
      }
    });
    return next;
  }
  strip(strip = true) {
    let next = this.clone();
    next.spec.strip = strip;
    return next;
  }
  /**
   * Return a serialized description of the schema including validations, flags, types etc.
   *
   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
   */
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const {
      label,
      meta,
      optional,
      nullable
    } = next.spec;
    const description = {
      meta,
      label,
      optional,
      nullable,
      default: next.getDefault(options),
      type: next.type,
      oneOf: next._whitelist.describe(),
      notOneOf: next._blacklist.describe(),
      tests: next.tests.filter((n2, idx, list) => list.findIndex((c2) => c2.OPTIONS.name === n2.OPTIONS.name) === idx).map((fn2) => {
        const params = fn2.OPTIONS.params && options ? resolveParams(Object.assign({}, fn2.OPTIONS.params), options) : fn2.OPTIONS.params;
        return {
          name: fn2.OPTIONS.name,
          params
        };
      })
    };
    return description;
  }
  get ["~standard"]() {
    const schema = this;
    const standard = {
      version: 1,
      vendor: "yup",
      async validate(value) {
        try {
          const result = await schema.validate(value, {
            abortEarly: false
          });
          return {
            value: result
          };
        } catch (err2) {
          if (err2 instanceof ValidationError) {
            return {
              issues: issuesFromValidationError(err2)
            };
          }
          throw err2;
        }
      }
    };
    return standard;
  }
}
Schema.prototype.__isYupSchema__ = true;
for (const method of ["validate", "validateSync"]) Schema.prototype["".concat(method, "At")] = function(path2, value, options = {}) {
  const {
    parent,
    parentPath,
    schema
  } = getIn$2(this, path2, value, options.context);
  return schema[method](parent && parent[parentPath], Object.assign({}, options, {
    parent,
    path: path2
  }));
};
for (const alias of ["equals", "is"]) Schema.prototype[alias] = Schema.prototype.oneOf;
for (const alias of ["not", "nope"]) Schema.prototype[alias] = Schema.prototype.notOneOf;
const returnsTrue = () => true;
function create$8(spec) {
  return new MixedSchema(spec);
}
class MixedSchema extends Schema {
  constructor(spec) {
    super(typeof spec === "function" ? {
      type: "mixed",
      check: spec
    } : Object.assign({
      type: "mixed",
      check: returnsTrue
    }, spec));
  }
}
create$8.prototype = MixedSchema.prototype;
function create$7() {
  return new BooleanSchema();
}
class BooleanSchema extends Schema {
  constructor() {
    super({
      type: "boolean",
      check(v2) {
        if (v2 instanceof Boolean) v2 = v2.valueOf();
        return typeof v2 === "boolean";
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (ctx.spec.coerce && !ctx.isType(value)) {
          if (/^(true|1)$/i.test(String(value))) return true;
          if (/^(false|0)$/i.test(String(value))) return false;
        }
        return value;
      });
    });
  }
  isTrue(message2 = boolean.isValue) {
    return this.test({
      message: message2,
      name: "is-value",
      exclusive: true,
      params: {
        value: "true"
      },
      test(value) {
        return isAbsent(value) || value === true;
      }
    });
  }
  isFalse(message2 = boolean.isValue) {
    return this.test({
      message: message2,
      name: "is-value",
      exclusive: true,
      params: {
        value: "false"
      },
      test(value) {
        return isAbsent(value) || value === false;
      }
    });
  }
  default(def) {
    return super.default(def);
  }
  defined(msg) {
    return super.defined(msg);
  }
  optional() {
    return super.optional();
  }
  required(msg) {
    return super.required(msg);
  }
  notRequired() {
    return super.notRequired();
  }
  nullable() {
    return super.nullable();
  }
  nonNullable(msg) {
    return super.nonNullable(msg);
  }
  strip(v2) {
    return super.strip(v2);
  }
}
create$7.prototype = BooleanSchema.prototype;
const isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
function parseIsoDate(date2) {
  const struct = parseDateStruct(date2);
  if (!struct) return Date.parse ? Date.parse(date2) : Number.NaN;
  if (struct.z === void 0 && struct.plusMinus === void 0) {
    return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
  }
  let totalMinutesOffset = 0;
  if (struct.z !== "Z" && struct.plusMinus !== void 0) {
    totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
    if (struct.plusMinus === "+") totalMinutesOffset = 0 - totalMinutesOffset;
  }
  return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
}
function parseDateStruct(date2) {
  var _regexResult$7$length, _regexResult$;
  const regexResult = isoReg.exec(date2);
  if (!regexResult) return null;
  return {
    year: toNumber(regexResult[1]),
    month: toNumber(regexResult[2], 1) - 1,
    day: toNumber(regexResult[3], 1),
    hour: toNumber(regexResult[4]),
    minute: toNumber(regexResult[5]),
    second: toNumber(regexResult[6]),
    millisecond: regexResult[7] ? (
      // allow arbitrary sub-second precision beyond milliseconds
      toNumber(regexResult[7].substring(0, 3))
    ) : 0,
    precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : void 0,
    z: regexResult[8] || void 0,
    plusMinus: regexResult[9] || void 0,
    hourOffset: toNumber(regexResult[10]),
    minuteOffset: toNumber(regexResult[11])
  };
}
function toNumber(str, defaultValue2 = 0) {
  return Number(str) || defaultValue2;
}
let rEmail = (
  // eslint-disable-next-line
  /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
);
let rUrl = (
  // eslint-disable-next-line
  /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
);
let rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
let yearMonthDay = "^\\d{4}-\\d{2}-\\d{2}";
let hourMinuteSecond = "\\d{2}:\\d{2}:\\d{2}";
let zOrOffset = "(([+-]\\d{2}(:?\\d{2})?)|Z)";
let rIsoDateTime = new RegExp("".concat(yearMonthDay, "T").concat(hourMinuteSecond, "(\\.\\d+)?").concat(zOrOffset, "$"));
let isTrimmed = (value) => isAbsent(value) || value === value.trim();
let objStringTag = {}.toString();
function create$6() {
  return new StringSchema();
}
class StringSchema extends Schema {
  constructor() {
    super({
      type: "string",
      check(value) {
        if (value instanceof String) value = value.valueOf();
        return typeof value === "string";
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce || ctx.isType(value)) return value;
        if (Array.isArray(value)) return value;
        const strValue = value != null && value.toString ? value.toString() : value;
        if (strValue === objStringTag) return value;
        return strValue;
      });
    });
  }
  required(message2) {
    return super.required(message2).withMutation((schema) => schema.test({
      message: message2 || mixed.required,
      name: "required",
      skipAbsent: true,
      test: (value) => !!value.length
    }));
  }
  notRequired() {
    return super.notRequired().withMutation((schema) => {
      schema.tests = schema.tests.filter((t2) => t2.OPTIONS.name !== "required");
      return schema;
    });
  }
  length(length, message2 = string.length) {
    return this.test({
      message: message2,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      skipAbsent: true,
      test(value) {
        return value.length === this.resolve(length);
      }
    });
  }
  min(min2, message2 = string.min) {
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        min: min2
      },
      skipAbsent: true,
      test(value) {
        return value.length >= this.resolve(min2);
      }
    });
  }
  max(max2, message2 = string.max) {
    return this.test({
      name: "max",
      exclusive: true,
      message: message2,
      params: {
        max: max2
      },
      skipAbsent: true,
      test(value) {
        return value.length <= this.resolve(max2);
      }
    });
  }
  matches(regex, options) {
    let excludeEmptyString = false;
    let message2;
    let name;
    if (options) {
      if (typeof options === "object") {
        ({
          excludeEmptyString = false,
          message: message2,
          name
        } = options);
      } else {
        message2 = options;
      }
    }
    return this.test({
      name: name || "matches",
      message: message2 || string.matches,
      params: {
        regex
      },
      skipAbsent: true,
      test: (value) => value === "" && excludeEmptyString || value.search(regex) !== -1
    });
  }
  email(message2 = string.email) {
    return this.matches(rEmail, {
      name: "email",
      message: message2,
      excludeEmptyString: true
    });
  }
  url(message2 = string.url) {
    return this.matches(rUrl, {
      name: "url",
      message: message2,
      excludeEmptyString: true
    });
  }
  uuid(message2 = string.uuid) {
    return this.matches(rUUID, {
      name: "uuid",
      message: message2,
      excludeEmptyString: false
    });
  }
  datetime(options) {
    let message2 = "";
    let allowOffset;
    let precision;
    if (options) {
      if (typeof options === "object") {
        ({
          message: message2 = "",
          allowOffset = false,
          precision = void 0
        } = options);
      } else {
        message2 = options;
      }
    }
    return this.matches(rIsoDateTime, {
      name: "datetime",
      message: message2 || string.datetime,
      excludeEmptyString: true
    }).test({
      name: "datetime_offset",
      message: message2 || string.datetime_offset,
      params: {
        allowOffset
      },
      skipAbsent: true,
      test: (value) => {
        if (!value || allowOffset) return true;
        const struct = parseDateStruct(value);
        if (!struct) return false;
        return !!struct.z;
      }
    }).test({
      name: "datetime_precision",
      message: message2 || string.datetime_precision,
      params: {
        precision
      },
      skipAbsent: true,
      test: (value) => {
        if (!value || precision == void 0) return true;
        const struct = parseDateStruct(value);
        if (!struct) return false;
        return struct.precision === precision;
      }
    });
  }
  //-- transforms --
  ensure() {
    return this.default("").transform((val) => val === null ? "" : val);
  }
  trim(message2 = string.trim) {
    return this.transform((val) => val != null ? val.trim() : val).test({
      message: message2,
      name: "trim",
      test: isTrimmed
    });
  }
  lowercase(message2 = string.lowercase) {
    return this.transform((value) => !isAbsent(value) ? value.toLowerCase() : value).test({
      message: message2,
      name: "string_case",
      exclusive: true,
      skipAbsent: true,
      test: (value) => isAbsent(value) || value === value.toLowerCase()
    });
  }
  uppercase(message2 = string.uppercase) {
    return this.transform((value) => !isAbsent(value) ? value.toUpperCase() : value).test({
      message: message2,
      name: "string_case",
      exclusive: true,
      skipAbsent: true,
      test: (value) => isAbsent(value) || value === value.toUpperCase()
    });
  }
}
create$6.prototype = StringSchema.prototype;
let isNaN$1$1 = (value) => value != +value;
function create$5() {
  return new NumberSchema();
}
class NumberSchema extends Schema {
  constructor() {
    super({
      type: "number",
      check(value) {
        if (value instanceof Number) value = value.valueOf();
        return typeof value === "number" && !isNaN$1$1(value);
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce) return value;
        let parsed = value;
        if (typeof parsed === "string") {
          parsed = parsed.replace(/\s/g, "");
          if (parsed === "") return NaN;
          parsed = +parsed;
        }
        if (ctx.isType(parsed) || parsed === null) return parsed;
        return parseFloat(parsed);
      });
    });
  }
  min(min2, message2 = number.min) {
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        min: min2
      },
      skipAbsent: true,
      test(value) {
        return value >= this.resolve(min2);
      }
    });
  }
  max(max2, message2 = number.max) {
    return this.test({
      message: message2,
      name: "max",
      exclusive: true,
      params: {
        max: max2
      },
      skipAbsent: true,
      test(value) {
        return value <= this.resolve(max2);
      }
    });
  }
  lessThan(less, message2 = number.lessThan) {
    return this.test({
      message: message2,
      name: "max",
      exclusive: true,
      params: {
        less
      },
      skipAbsent: true,
      test(value) {
        return value < this.resolve(less);
      }
    });
  }
  moreThan(more, message2 = number.moreThan) {
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        more
      },
      skipAbsent: true,
      test(value) {
        return value > this.resolve(more);
      }
    });
  }
  positive(msg = number.positive) {
    return this.moreThan(0, msg);
  }
  negative(msg = number.negative) {
    return this.lessThan(0, msg);
  }
  integer(message2 = number.integer) {
    return this.test({
      name: "integer",
      message: message2,
      skipAbsent: true,
      test: (val) => Number.isInteger(val)
    });
  }
  truncate() {
    return this.transform((value) => !isAbsent(value) ? value | 0 : value);
  }
  round(method) {
    var _method;
    let avail = ["ceil", "floor", "round", "trunc"];
    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
    if (method === "trunc") return this.truncate();
    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError("Only valid options for round() are: " + avail.join(", "));
    return this.transform((value) => !isAbsent(value) ? Math[method](value) : value);
  }
}
create$5.prototype = NumberSchema.prototype;
let invalidDate = /* @__PURE__ */ new Date("");
let isDate$1 = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
function create$4() {
  return new DateSchema();
}
class DateSchema extends Schema {
  constructor() {
    super({
      type: "date",
      check(v2) {
        return isDate$1(v2) && !isNaN(v2.getTime());
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;
        value = parseIsoDate(value);
        return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;
      });
    });
  }
  prepareParam(ref, name) {
    let param;
    if (!Reference.isRef(ref)) {
      let cast = this.cast(ref);
      if (!this._typeCheck(cast)) throw new TypeError("`".concat(name, "` must be a Date or a value that can be `cast()` to a Date"));
      param = cast;
    } else {
      param = ref;
    }
    return param;
  }
  min(min2, message2 = date.min) {
    let limit = this.prepareParam(min2, "min");
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        min: min2
      },
      skipAbsent: true,
      test(value) {
        return value >= this.resolve(limit);
      }
    });
  }
  max(max2, message2 = date.max) {
    let limit = this.prepareParam(max2, "max");
    return this.test({
      message: message2,
      name: "max",
      exclusive: true,
      params: {
        max: max2
      },
      skipAbsent: true,
      test(value) {
        return value <= this.resolve(limit);
      }
    });
  }
}
DateSchema.INVALID_DATE = invalidDate;
create$4.prototype = DateSchema.prototype;
create$4.INVALID_DATE = invalidDate;
function sortFields(fields, excludedEdges = []) {
  let edges = [];
  let nodes = /* @__PURE__ */ new Set();
  let excludes = new Set(excludedEdges.map(([a2, b2]) => "".concat(a2, "-").concat(b2)));
  function addNode(depPath, key) {
    let node = propertyExprExports.split(depPath)[0];
    nodes.add(node);
    if (!excludes.has("".concat(key, "-").concat(node))) edges.push([key, node]);
  }
  for (const key of Object.keys(fields)) {
    let value = fields[key];
    nodes.add(key);
    if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);
    else if (isSchema(value) && "deps" in value) value.deps.forEach((path2) => addNode(path2, key));
  }
  return toposort.array(Array.from(nodes), edges).reverse();
}
function findIndex$1(arr2, err2) {
  let idx = Infinity;
  arr2.some((key, ii) => {
    var _err$path;
    if ((_err$path = err2.path) != null && _err$path.includes(key)) {
      idx = ii;
      return true;
    }
  });
  return idx;
}
function sortByKeyOrder(keys2) {
  return (a2, b2) => {
    return findIndex$1(keys2, a2) - findIndex$1(keys2, b2);
  };
}
const parseJson = (value, _23, ctx) => {
  if (typeof value !== "string") {
    return value;
  }
  let parsed = value;
  try {
    parsed = JSON.parse(value);
  } catch (err2) {
  }
  return ctx.isType(parsed) ? parsed : value;
};
function deepPartial(schema) {
  if ("fields" in schema) {
    const partial = {};
    for (const [key, fieldSchema] of Object.entries(schema.fields)) {
      partial[key] = deepPartial(fieldSchema);
    }
    return schema.setFields(partial);
  }
  if (schema.type === "array") {
    const nextArray = schema.optional();
    if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);
    return nextArray;
  }
  if (schema.type === "tuple") {
    return schema.optional().clone({
      types: schema.spec.types.map(deepPartial)
    });
  }
  if ("optional" in schema) {
    return schema.optional();
  }
  return schema;
}
const deepHas = (obj, p2) => {
  const path2 = [...propertyExprExports.normalizePath(p2)];
  if (path2.length === 1) return path2[0] in obj;
  let last3 = path2.pop();
  let parent = propertyExprExports.getter(propertyExprExports.join(path2), true)(obj);
  return !!(parent && last3 in parent);
};
let isObject$4 = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
function unknown(ctx, value) {
  let known = Object.keys(ctx.fields);
  return Object.keys(value).filter((key) => known.indexOf(key) === -1);
}
const defaultSort = sortByKeyOrder([]);
function create$3(spec) {
  return new ObjectSchema(spec);
}
class ObjectSchema extends Schema {
  constructor(spec) {
    super({
      type: "object",
      check(value) {
        return isObject$4(value) || typeof value === "function";
      }
    });
    this.fields = /* @__PURE__ */ Object.create(null);
    this._sortErrors = defaultSort;
    this._nodes = [];
    this._excludedEdges = [];
    this.withMutation(() => {
      if (spec) {
        this.shape(spec);
      }
    });
  }
  _cast(_value, options = {}) {
    var _options$stripUnknown;
    let value = super._cast(_value, options);
    if (value === void 0) return this.getDefault(options);
    if (!this._typeCheck(value)) return value;
    let fields = this.fields;
    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
    let props = [].concat(this._nodes, Object.keys(value).filter((v2) => !this._nodes.includes(v2)));
    let intermediateValue = {};
    let innerOptions = Object.assign({}, options, {
      parent: intermediateValue,
      __validating: options.__validating || false
    });
    let isChanged = false;
    for (const prop of props) {
      let field = fields[prop];
      let exists = prop in value;
      if (field) {
        let fieldValue;
        let inputValue = value[prop];
        innerOptions.path = (options.path ? "".concat(options.path, ".") : "") + prop;
        field = field.resolve({
          value: inputValue,
          context: options.context,
          parent: intermediateValue
        });
        let fieldSpec = field instanceof Schema ? field.spec : void 0;
        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
        if (fieldSpec != null && fieldSpec.strip) {
          isChanged = isChanged || prop in value;
          continue;
        }
        fieldValue = !options.__validating || !strict ? (
          // TODO: use _cast, this is double resolving
          field.cast(value[prop], innerOptions)
        ) : value[prop];
        if (fieldValue !== void 0) {
          intermediateValue[prop] = fieldValue;
        }
      } else if (exists && !strip) {
        intermediateValue[prop] = value[prop];
      }
      if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
        isChanged = true;
      }
    }
    return isChanged ? intermediateValue : value;
  }
  _validate(_value, options = {}, panic, next) {
    let {
      from = [],
      originalValue = _value,
      recursive = this.spec.recursive
    } = options;
    options.from = [{
      schema: this,
      value: originalValue
    }, ...from];
    options.__validating = true;
    options.originalValue = originalValue;
    super._validate(_value, options, panic, (objectErrors, value) => {
      if (!recursive || !isObject$4(value)) {
        next(objectErrors, value);
        return;
      }
      originalValue = originalValue || value;
      let tests = [];
      for (let key of this._nodes) {
        let field = this.fields[key];
        if (!field || Reference.isRef(field)) {
          continue;
        }
        tests.push(field.asNestedTest({
          options,
          key,
          parent: value,
          parentPath: options.path,
          originalParent: originalValue
        }));
      }
      this.runTests({
        tests,
        value,
        originalValue,
        options
      }, panic, (fieldErrors) => {
        next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
      });
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.fields = Object.assign({}, this.fields);
    next._nodes = this._nodes;
    next._excludedEdges = this._excludedEdges;
    next._sortErrors = this._sortErrors;
    return next;
  }
  concat(schema) {
    let next = super.concat(schema);
    let nextFields = next.fields;
    for (let [field, schemaOrRef] of Object.entries(this.fields)) {
      const target = nextFields[field];
      nextFields[field] = target === void 0 ? schemaOrRef : target;
    }
    return next.withMutation((s2) => (
      // XXX: excludes here is wrong
      s2.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges])
    ));
  }
  _getDefault(options) {
    if ("default" in this.spec) {
      return super._getDefault(options);
    }
    if (!this._nodes.length) {
      return void 0;
    }
    let dft = {};
    this._nodes.forEach((key) => {
      var _innerOptions;
      const field = this.fields[key];
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      dft[key] = field && "getDefault" in field ? field.getDefault(innerOptions) : void 0;
    });
    return dft;
  }
  setFields(shape, excludedEdges) {
    let next = this.clone();
    next.fields = shape;
    next._nodes = sortFields(shape, excludedEdges);
    next._sortErrors = sortByKeyOrder(Object.keys(shape));
    if (excludedEdges) next._excludedEdges = excludedEdges;
    return next;
  }
  shape(additions, excludes = []) {
    return this.clone().withMutation((next) => {
      let edges = next._excludedEdges;
      if (excludes.length) {
        if (!Array.isArray(excludes[0])) excludes = [excludes];
        edges = [...next._excludedEdges, ...excludes];
      }
      return next.setFields(Object.assign(next.fields, additions), edges);
    });
  }
  partial() {
    const partial = {};
    for (const [key, schema] of Object.entries(this.fields)) {
      partial[key] = "optional" in schema && schema.optional instanceof Function ? schema.optional() : schema;
    }
    return this.setFields(partial);
  }
  deepPartial() {
    const next = deepPartial(this);
    return next;
  }
  pick(keys2) {
    const picked = {};
    for (const key of keys2) {
      if (this.fields[key]) picked[key] = this.fields[key];
    }
    return this.setFields(picked, this._excludedEdges.filter(([a2, b2]) => keys2.includes(a2) && keys2.includes(b2)));
  }
  omit(keys2) {
    const remaining = [];
    for (const key of Object.keys(this.fields)) {
      if (keys2.includes(key)) continue;
      remaining.push(key);
    }
    return this.pick(remaining);
  }
  from(from, to2, alias) {
    let fromGetter = propertyExprExports.getter(from, true);
    return this.transform((obj) => {
      if (!obj) return obj;
      let newObj = obj;
      if (deepHas(obj, from)) {
        newObj = Object.assign({}, obj);
        if (!alias) delete newObj[from];
        newObj[to2] = fromGetter(obj);
      }
      return newObj;
    });
  }
  /** Parse an input JSON string to an object */
  json() {
    return this.transform(parseJson);
  }
  /**
   * Similar to `noUnknown` but only validates that an object is the right shape without stripping the unknown keys
   */
  exact(message2) {
    return this.test({
      name: "exact",
      exclusive: true,
      message: message2 || object.exact,
      test(value) {
        if (value == null) return true;
        const unknownKeys = unknown(this.schema, value);
        return unknownKeys.length === 0 || this.createError({
          params: {
            properties: unknownKeys.join(", ")
          }
        });
      }
    });
  }
  stripUnknown() {
    return this.clone({
      noUnknown: true
    });
  }
  noUnknown(noAllow = true, message2 = object.noUnknown) {
    if (typeof noAllow !== "boolean") {
      message2 = noAllow;
      noAllow = true;
    }
    let next = this.test({
      name: "noUnknown",
      exclusive: true,
      message: message2,
      test(value) {
        if (value == null) return true;
        const unknownKeys = unknown(this.schema, value);
        return !noAllow || unknownKeys.length === 0 || this.createError({
          params: {
            unknown: unknownKeys.join(", ")
          }
        });
      }
    });
    next.spec.noUnknown = noAllow;
    return next;
  }
  unknown(allow = true, message2 = object.noUnknown) {
    return this.noUnknown(!allow, message2);
  }
  transformKeys(fn2) {
    return this.transform((obj) => {
      if (!obj) return obj;
      const result = {};
      for (const key of Object.keys(obj)) result[fn2(key)] = obj[key];
      return result;
    });
  }
  camelCase() {
    return this.transformKeys(tinyCaseExports.camelCase);
  }
  snakeCase() {
    return this.transformKeys(tinyCaseExports.snakeCase);
  }
  constantCase() {
    return this.transformKeys((key) => tinyCaseExports.snakeCase(key).toUpperCase());
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    base.fields = {};
    for (const [key, value] of Object.entries(next.fields)) {
      var _innerOptions2;
      let innerOptions = options;
      if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      base.fields[key] = value.describe(innerOptions);
    }
    return base;
  }
}
create$3.prototype = ObjectSchema.prototype;
function create$2(type) {
  return new ArraySchema(type);
}
class ArraySchema extends Schema {
  constructor(type) {
    super({
      type: "array",
      spec: {
        types: type
      },
      check(v2) {
        return Array.isArray(v2);
      }
    });
    this.innerType = void 0;
    this.innerType = type;
  }
  _cast(_value, _opts) {
    const value = super._cast(_value, _opts);
    if (!this._typeCheck(value) || !this.innerType) {
      return value;
    }
    let isChanged = false;
    const castArray = value.map((v2, idx) => {
      const castElement = this.innerType.cast(v2, Object.assign({}, _opts, {
        path: "".concat(_opts.path || "", "[").concat(idx, "]")
      }));
      if (castElement !== v2) {
        isChanged = true;
      }
      return castElement;
    });
    return isChanged ? castArray : value;
  }
  _validate(_value, options = {}, panic, next) {
    var _options$recursive;
    let innerType = this.innerType;
    let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
    options.originalValue != null ? options.originalValue : _value;
    super._validate(_value, options, panic, (arrayErrors, value) => {
      var _options$originalValu2;
      if (!recursive || !innerType || !this._typeCheck(value)) {
        next(arrayErrors, value);
        return;
      }
      let tests = new Array(value.length);
      for (let index = 0; index < value.length; index++) {
        var _options$originalValu;
        tests[index] = innerType.asNestedTest({
          options,
          index,
          parent: value,
          parentPath: options.path,
          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
        });
      }
      this.runTests({
        value,
        tests,
        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
        options
      }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(arrayErrors), value));
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.innerType = this.innerType;
    return next;
  }
  /** Parse an input JSON string to an object */
  json() {
    return this.transform(parseJson);
  }
  concat(schema) {
    let next = super.concat(schema);
    next.innerType = this.innerType;
    if (schema.innerType)
      next.innerType = next.innerType ? (
        // @ts-expect-error Lazy doesn't have concat and will break
        next.innerType.concat(schema.innerType)
      ) : schema.innerType;
    return next;
  }
  of(schema) {
    let next = this.clone();
    if (!isSchema(schema)) throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
    next.innerType = schema;
    next.spec = Object.assign({}, next.spec, {
      types: schema
    });
    return next;
  }
  length(length, message2 = array.length) {
    return this.test({
      message: message2,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      skipAbsent: true,
      test(value) {
        return value.length === this.resolve(length);
      }
    });
  }
  min(min2, message2) {
    message2 = message2 || array.min;
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        min: min2
      },
      skipAbsent: true,
      // FIXME(ts): Array<typeof T>
      test(value) {
        return value.length >= this.resolve(min2);
      }
    });
  }
  max(max2, message2) {
    message2 = message2 || array.max;
    return this.test({
      message: message2,
      name: "max",
      exclusive: true,
      params: {
        max: max2
      },
      skipAbsent: true,
      test(value) {
        return value.length <= this.resolve(max2);
      }
    });
  }
  ensure() {
    return this.default(() => []).transform((val, original2) => {
      if (this._typeCheck(val)) return val;
      return original2 == null ? [] : [].concat(original2);
    });
  }
  compact(rejector) {
    let reject = !rejector ? (v2) => !!v2 : (v2, i2, a2) => !rejector(v2, i2, a2);
    return this.transform((values2) => values2 != null ? values2.filter(reject) : values2);
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    if (next.innerType) {
      var _innerOptions;
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[0]
        });
      }
      base.innerType = next.innerType.describe(innerOptions);
    }
    return base;
  }
}
create$2.prototype = ArraySchema.prototype;
function create$1(schemas) {
  return new TupleSchema(schemas);
}
class TupleSchema extends Schema {
  constructor(schemas) {
    super({
      type: "tuple",
      spec: {
        types: schemas
      },
      check(v2) {
        const types = this.spec.types;
        return Array.isArray(v2) && v2.length === types.length;
      }
    });
    this.withMutation(() => {
      this.typeError(tuple.notType);
    });
  }
  _cast(inputValue, options) {
    const {
      types
    } = this.spec;
    const value = super._cast(inputValue, options);
    if (!this._typeCheck(value)) {
      return value;
    }
    let isChanged = false;
    const castArray = types.map((type, idx) => {
      const castElement = type.cast(value[idx], Object.assign({}, options, {
        path: "".concat(options.path || "", "[").concat(idx, "]")
      }));
      if (castElement !== value[idx]) isChanged = true;
      return castElement;
    });
    return isChanged ? castArray : value;
  }
  _validate(_value, options = {}, panic, next) {
    let itemTypes = this.spec.types;
    super._validate(_value, options, panic, (tupleErrors, value) => {
      var _options$originalValu2;
      if (!this._typeCheck(value)) {
        next(tupleErrors, value);
        return;
      }
      let tests = [];
      for (let [index, itemSchema] of itemTypes.entries()) {
        var _options$originalValu;
        tests[index] = itemSchema.asNestedTest({
          options,
          index,
          parent: value,
          parentPath: options.path,
          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
        });
      }
      this.runTests({
        value,
        tests,
        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
        options
      }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(tupleErrors), value));
    });
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    base.innerType = next.spec.types.map((schema, index) => {
      var _innerOptions;
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[index]
        });
      }
      return schema.describe(innerOptions);
    });
    return base;
  }
}
create$1.prototype = TupleSchema.prototype;
function create2(builder) {
  return new Lazy(builder);
}
function catchValidationError(fn2) {
  try {
    return fn2();
  } catch (err2) {
    if (ValidationError.isError(err2)) return Promise.reject(err2);
    throw err2;
  }
}
class Lazy {
  constructor(builder) {
    this.type = "lazy";
    this.__isYupSchema__ = true;
    this.spec = void 0;
    this._resolve = (value, options = {}) => {
      let schema = this.builder(value, options);
      if (!isSchema(schema)) throw new TypeError("lazy() functions must return a valid schema");
      if (this.spec.optional) schema = schema.optional();
      return schema.resolve(options);
    };
    this.builder = builder;
    this.spec = {
      meta: void 0,
      optional: false
    };
  }
  clone(spec) {
    const next = new Lazy(this.builder);
    next.spec = Object.assign({}, this.spec, spec);
    return next;
  }
  optionality(optional) {
    const next = this.clone({
      optional
    });
    return next;
  }
  optional() {
    return this.optionality(true);
  }
  resolve(options) {
    return this._resolve(options.value, options);
  }
  cast(value, options) {
    return this._resolve(value, options).cast(value, options);
  }
  asNestedTest(config) {
    let {
      key,
      index,
      parent,
      options
    } = config;
    let value = parent[index != null ? index : key];
    return this._resolve(value, Object.assign({}, options, {
      value,
      parent
    })).asNestedTest(config);
  }
  validate(value, options) {
    return catchValidationError(() => this._resolve(value, options).validate(value, options));
  }
  validateSync(value, options) {
    return this._resolve(value, options).validateSync(value, options);
  }
  validateAt(path2, value, options) {
    return catchValidationError(() => this._resolve(value, options).validateAt(path2, value, options));
  }
  validateSyncAt(path2, value, options) {
    return this._resolve(value, options).validateSyncAt(path2, value, options);
  }
  isValid(value, options) {
    try {
      return this._resolve(value, options).isValid(value, options);
    } catch (err2) {
      if (ValidationError.isError(err2)) {
        return Promise.resolve(false);
      }
      throw err2;
    }
  }
  isValidSync(value, options) {
    return this._resolve(value, options).isValidSync(value, options);
  }
  describe(options) {
    return options ? this.resolve(options).describe(options) : {
      type: "lazy",
      meta: this.spec.meta,
      label: void 0
    };
  }
  meta(...args) {
    if (args.length === 0) return this.spec.meta;
    let next = this.clone();
    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
    return next;
  }
  get ["~standard"]() {
    const schema = this;
    const standard = {
      version: 1,
      vendor: "yup",
      async validate(value) {
        try {
          const result = await schema.validate(value, {
            abortEarly: false
          });
          return {
            value: result
          };
        } catch (err2) {
          if (ValidationError.isError(err2)) {
            return {
              issues: issuesFromValidationError(err2)
            };
          }
          throw err2;
        }
      }
    };
    return standard;
  }
}
function setLocale(custom) {
  Object.keys(custom).forEach((type) => {
    Object.keys(custom[type]).forEach((method) => {
      locale[type][method] = custom[type][method];
    });
  });
}
function addMethod(schemaType, name, fn2) {
  if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError("You must provide a yup schema constructor function");
  if (typeof name !== "string") throw new TypeError("A Method name must be provided");
  if (typeof fn2 !== "function") throw new TypeError("Method function must be provided");
  schemaType.prototype[name] = fn2;
}
const yup = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArraySchema,
  BooleanSchema,
  DateSchema,
  LazySchema: Lazy,
  MixedSchema,
  NumberSchema,
  ObjectSchema,
  Schema,
  StringSchema,
  TupleSchema,
  ValidationError,
  addMethod,
  array: create$2,
  bool: create$7,
  boolean: create$7,
  date: create$4,
  defaultLocale: locale,
  getIn: getIn$2,
  isSchema,
  lazy: create2,
  mixed: create$8,
  number: create$5,
  object: create$3,
  printValue,
  reach,
  ref: create$9,
  setLocale,
  string: create$6,
  tuple: create$1
}, Symbol.toStringTag, { value: "Module" }));
var humps$1 = { exports: {} };
var humps = humps$1.exports;
var hasRequiredHumps;
function requireHumps() {
  if (hasRequiredHumps) return humps$1.exports;
  hasRequiredHumps = 1;
  (function(module) {
    (function(global) {
      var _processKeys = function(convert, obj, options) {
        if (!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) {
          return obj;
        }
        var output3, i2 = 0, l2 = 0;
        if (_isArray(obj)) {
          output3 = [];
          for (l2 = obj.length; i2 < l2; i2++) {
            output3.push(_processKeys(convert, obj[i2], options));
          }
        } else {
          output3 = {};
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              output3[convert(key, options)] = _processKeys(convert, obj[key], options);
            }
          }
        }
        return output3;
      };
      var separateWords = function(string2, options) {
        options = options || {};
        var separator = options.separator || "_";
        var split = options.split || /(?=[A-Z])/;
        return string2.split(split).join(separator);
      };
      var camelize = function(string2) {
        if (_isNumerical(string2)) {
          return string2;
        }
        string2 = string2.replace(/[\-_\s]+(.)?/g, function(match2, chr) {
          return chr ? chr.toUpperCase() : "";
        });
        return string2.substr(0, 1).toLowerCase() + string2.substr(1);
      };
      var pascalize = function(string2) {
        var camelized = camelize(string2);
        return camelized.substr(0, 1).toUpperCase() + camelized.substr(1);
      };
      var decamelize = function(string2, options) {
        return separateWords(string2, options).toLowerCase();
      };
      var toString5 = Object.prototype.toString;
      var _isFunction = function(obj) {
        return typeof obj === "function";
      };
      var _isObject = function(obj) {
        return obj === Object(obj);
      };
      var _isArray = function(obj) {
        return toString5.call(obj) == "[object Array]";
      };
      var _isDate = function(obj) {
        return toString5.call(obj) == "[object Date]";
      };
      var _isRegExp = function(obj) {
        return toString5.call(obj) == "[object RegExp]";
      };
      var _isBoolean = function(obj) {
        return toString5.call(obj) == "[object Boolean]";
      };
      var _isNumerical = function(obj) {
        obj = obj - 0;
        return obj === obj;
      };
      var _processor = function(convert, options) {
        var callback = options && "process" in options ? options.process : options;
        if (typeof callback !== "function") {
          return convert;
        }
        return function(string2, options2) {
          return callback(string2, convert, options2);
        };
      };
      var humps2 = {
        camelize,
        decamelize,
        pascalize,
        depascalize: decamelize,
        camelizeKeys: function(object2, options) {
          return _processKeys(_processor(camelize, options), object2);
        },
        decamelizeKeys: function(object2, options) {
          return _processKeys(_processor(decamelize, options), object2, options);
        },
        pascalizeKeys: function(object2, options) {
          return _processKeys(_processor(pascalize, options), object2);
        },
        depascalizeKeys: function() {
          return this.decamelizeKeys.apply(this, arguments);
        }
      };
      if (module.exports) {
        module.exports = humps2;
      } else {
        global.humps = humps2;
      }
    })(humps);
  })(humps$1);
  return humps$1.exports;
}
var humpsExports = requireHumps();
function formatProdErrorMessage$1(code) {
  return "Minified Redux error #".concat(code, "; visit https://redux.js.org/Errors?code=").concat(code, " for the full message or use the non-minified dev environment for full errors. ");
}
var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: "@@redux/INIT".concat(/* @__PURE__ */ randomString()),
  REPLACE: "@@redux/REPLACE".concat(/* @__PURE__ */ randomString()),
  PROBE_UNKNOWN_ACTION: () => "@@redux/PROBE_UNKNOWN_ACTION".concat(randomString())
};
var actionTypes_default = ActionTypes;
function isPlainObject$3(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
function createStore(reducer2, preloadedState, enhancer) {
  if (typeof reducer2 !== "function") {
    throw new Error(formatProdErrorMessage$1(2));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage$1(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage$1(1));
    }
    return enhancer(createStore)(reducer2, preloadedState);
  }
  let currentReducer = reducer2;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener, key) => {
        nextListeners.set(key, listener);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage$1(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage$1(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage$1(5));
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage$1(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$3(action)) {
      throw new Error(formatProdErrorMessage$1(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage$1(8));
    }
    if (typeof action.type !== "string") {
      throw new Error(formatProdErrorMessage$1(17));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage$1(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach((listener) => {
      listener();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage$1(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage$1(11));
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach((key) => {
    const reducer2 = reducers[key];
    const initialState2 = reducer2(void 0, {
      type: actionTypes_default.INIT
    });
    if (typeof initialState2 === "undefined") {
      throw new Error(formatProdErrorMessage$1(12));
    }
    if (typeof reducer2(void 0, {
      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(formatProdErrorMessage$1(13));
    }
  });
}
function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);
  const finalReducers = {};
  for (let i2 = 0; i2 < reducerKeys.length; i2++) {
    const key = reducerKeys[i2];
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  let shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e2) {
    shapeAssertionError = e2;
  }
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    let hasChanged = false;
    const nextState = {};
    for (let i2 = 0; i2 < finalReducerKeys.length; i2++) {
      const key = finalReducerKeys[i2];
      const reducer2 = finalReducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer2(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        action && action.type;
        throw new Error(formatProdErrorMessage$1(14));
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore2) => (reducer2, preloadedState) => {
    const store = createStore2(reducer2, preloadedState);
    let dispatch = () => {
      throw new Error(formatProdErrorMessage$1(15));
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);
    return {
      ...store,
      dispatch
    };
  };
}
function isAction(action) {
  return isPlainObject$3(action) && "type" in action && typeof action.type === "string";
}
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
function die(error2, ...args) {
  throw new Error(
    "[Immer] minified error nr: ".concat(error2, ". Full error at: https://bit.ly/3cXEKWf")
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  var _a;
  if (!value)
    return false;
  return isPlainObject$2(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap$1(value) || isSet$1(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject$2(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function original(value) {
  if (!isDraft(value))
    die(15, value);
  return value[DRAFT_STATE].base_;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap$1(thing) ? 2 : isSet$1(thing) ? 3 : 0;
}
function has$1(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get$1(thing, prop) {
  return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
}
function set$1(thing, propOrOldValue, value) {
  const t2 = getArchtype(thing);
  if (t2 === 2)
    thing.set(propOrOldValue, value);
  else if (t2 === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is$1(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function isMap$1(target) {
  return target instanceof Map;
}
function isSet$1(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy$1(base, strict) {
  if (isMap$1(base)) {
    return new Map(base);
  }
  if (isSet$1(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject$2(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys2 = Reflect.ownKeys(descriptors);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    Object.defineProperties(obj, {
      set: { value: dontMutateFrozenCollections },
      add: { value: dontMutateFrozenCollections },
      clear: { value: dontMutateFrozenCollections },
      delete: { value: dontMutateFrozenCollections }
    });
  }
  Object.freeze(obj);
  if (deep)
    Object.values(obj).forEach((value) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
function loadPlugin(pluginKey, implementation) {
  if (!plugins[pluginKey])
    plugins[pluginKey] = implementation;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path2) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path2)
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path2, isSet2)
    );
    maybeFreeze(rootScope, result, false);
    if (path2 && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path2,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (isDraft(childValue)) {
    const path2 = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has$1(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path2);
    set$1(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap$1(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop)))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray = Array.isArray(base);
  const state = {
    type_: isArray ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has$1(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc == null ? void 0 : desc.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is$1(value, current2) && (value !== void 0 || has$1(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn2) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn2.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  var _a;
  const desc = getDescriptorFromProto(source, prop);
  return desc ? "value" in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy$1(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p2 = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p2, ip);
          patchListener(p2, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p2, ip) => {
        patches = p2;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof (config == null ? void 0 : config.autoFreeze) === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof (config == null ? void 0 : config.useStrictShallowCopy) === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i2;
    for (i2 = patches.length - 1; i2 >= 0; i2--) {
      const patch2 = patches[i2];
      if (patch2.path.length === 0 && patch2.op === "replace") {
        base = patch2.value;
        break;
      }
    }
    if (i2 > -1) {
      patches = patches.slice(i2 + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap$1(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet$1(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy2;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy2 = shallowCopy$1(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy2 = shallowCopy$1(value, true);
  }
  each(copy2, (key, childValue) => {
    set$1(copy2, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy2;
}
function enablePatches() {
  const errorOffset = 16;
  const REPLACE = "replace";
  const ADD = "add";
  const REMOVE = "remove";
  function generatePatches_(state, basePath, patches, inversePatches) {
    switch (state.type_) {
      case 0:
      case 2:
        return generatePatchesFromAssigned(
          state,
          basePath,
          patches,
          inversePatches
        );
      case 1:
        return generateArrayPatches(state, basePath, patches, inversePatches);
      case 3:
        return generateSetPatches(
          state,
          basePath,
          patches,
          inversePatches
        );
    }
  }
  function generateArrayPatches(state, basePath, patches, inversePatches) {
    let { base_, assigned_ } = state;
    let copy_ = state.copy_;
    if (copy_.length < base_.length) {
      [base_, copy_] = [copy_, base_];
      [patches, inversePatches] = [inversePatches, patches];
    }
    for (let i2 = 0; i2 < base_.length; i2++) {
      if (assigned_[i2] && copy_[i2] !== base_[i2]) {
        const path2 = basePath.concat([i2]);
        patches.push({
          op: REPLACE,
          path: path2,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: clonePatchValueIfNeeded(copy_[i2])
        });
        inversePatches.push({
          op: REPLACE,
          path: path2,
          value: clonePatchValueIfNeeded(base_[i2])
        });
      }
    }
    for (let i2 = base_.length; i2 < copy_.length; i2++) {
      const path2 = basePath.concat([i2]);
      patches.push({
        op: ADD,
        path: path2,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: clonePatchValueIfNeeded(copy_[i2])
      });
    }
    for (let i2 = copy_.length - 1; base_.length <= i2; --i2) {
      const path2 = basePath.concat([i2]);
      inversePatches.push({
        op: REMOVE,
        path: path2
      });
    }
  }
  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
    const { base_, copy_ } = state;
    each(state.assigned_, (key, assignedValue) => {
      const origValue = get$1(base_, key);
      const value = get$1(copy_, key);
      const op = !assignedValue ? REMOVE : has$1(base_, key) ? REPLACE : ADD;
      if (origValue === value && op === REPLACE)
        return;
      const path2 = basePath.concat(key);
      patches.push(op === REMOVE ? { op, path: path2 } : { op, path: path2, value });
      inversePatches.push(
        op === ADD ? { op: REMOVE, path: path2 } : op === REMOVE ? { op: ADD, path: path2, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path: path2, value: clonePatchValueIfNeeded(origValue) }
      );
    });
  }
  function generateSetPatches(state, basePath, patches, inversePatches) {
    let { base_, copy_ } = state;
    let i2 = 0;
    base_.forEach((value) => {
      if (!copy_.has(value)) {
        const path2 = basePath.concat([i2]);
        patches.push({
          op: REMOVE,
          path: path2,
          value
        });
        inversePatches.unshift({
          op: ADD,
          path: path2,
          value
        });
      }
      i2++;
    });
    i2 = 0;
    copy_.forEach((value) => {
      if (!base_.has(value)) {
        const path2 = basePath.concat([i2]);
        patches.push({
          op: ADD,
          path: path2,
          value
        });
        inversePatches.unshift({
          op: REMOVE,
          path: path2,
          value
        });
      }
      i2++;
    });
  }
  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
    patches.push({
      op: REPLACE,
      path: [],
      value: replacement === NOTHING ? void 0 : replacement
    });
    inversePatches.push({
      op: REPLACE,
      path: [],
      value: baseValue
    });
  }
  function applyPatches_(draft, patches) {
    patches.forEach((patch2) => {
      const { path: path2, op } = patch2;
      let base = draft;
      for (let i2 = 0; i2 < path2.length - 1; i2++) {
        const parentType = getArchtype(base);
        let p2 = path2[i2];
        if (typeof p2 !== "string" && typeof p2 !== "number") {
          p2 = "" + p2;
        }
        if ((parentType === 0 || parentType === 1) && (p2 === "__proto__" || p2 === "constructor"))
          die(errorOffset + 3);
        if (typeof base === "function" && p2 === "prototype")
          die(errorOffset + 3);
        base = get$1(base, p2);
        if (typeof base !== "object")
          die(errorOffset + 2, path2.join("/"));
      }
      const type = getArchtype(base);
      const value = deepClonePatchValue(patch2.value);
      const key = path2[path2.length - 1];
      switch (op) {
        case REPLACE:
          switch (type) {
            case 2:
              return base.set(key, value);
            case 3:
              die(errorOffset);
            default:
              return base[key] = value;
          }
        case ADD:
          switch (type) {
            case 1:
              return key === "-" ? base.push(value) : base.splice(key, 0, value);
            case 2:
              return base.set(key, value);
            case 3:
              return base.add(value);
            default:
              return base[key] = value;
          }
        case REMOVE:
          switch (type) {
            case 1:
              return base.splice(key, 1);
            case 2:
              return base.delete(key);
            case 3:
              return base.delete(patch2.value);
            default:
              return delete base[key];
          }
        default:
          die(errorOffset + 1, op);
      }
    });
    return draft;
  }
  function deepClonePatchValue(obj) {
    if (!isDraftable(obj))
      return obj;
    if (Array.isArray(obj))
      return obj.map(deepClonePatchValue);
    if (isMap$1(obj))
      return new Map(
        Array.from(obj.entries()).map(([k2, v2]) => [k2, deepClonePatchValue(v2)])
      );
    if (isSet$1(obj))
      return new Set(Array.from(obj).map(deepClonePatchValue));
    const cloned = Object.create(getPrototypeOf(obj));
    for (const key in obj)
      cloned[key] = deepClonePatchValue(obj[key]);
    if (has$1(obj, DRAFTABLE))
      cloned[DRAFTABLE] = obj[DRAFTABLE];
    return cloned;
  }
  function clonePatchValueIfNeeded(obj) {
    if (isDraft(obj)) {
      return deepClonePatchValue(obj);
    } else
      return obj;
  }
  loadPlugin("Patches", {
    applyPatches_,
    generatePatches_,
    generateReplacementPatches_
  });
}
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(
  immer
);
var applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer);
function assertIsFunction(func, errorMessage = "expected a function, instead received ".concat(typeof func)) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object2, errorMessage = "expected an object, instead received ".concat(typeof object2)) {
  if (typeof object2 !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array2, errorMessage = "expected all items to be functions, instead received the following types: ") {
  if (!array2.every((item) => typeof item === "function")) {
    const itemTypes = array2.map(
      (item) => typeof item === "function" ? "function ".concat(item.name || "unnamed", "()") : typeof item
    ).join(", ");
    throw new TypeError("".concat(errorMessage, "[").concat(itemTypes, "]"));
  }
}
var ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    "createSelector expects all input-selectors to be functions, but received the following types: "
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length } = dependencies;
  for (let i2 = 0; i2 < length; i2++) {
    inputSelectorResults.push(dependencies[i2].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    var _a, _b;
    let cacheNode = fnNode;
    const { length } = arguments;
    for (let i2 = 0, l2 = length; i2 < l2; i2++) {
      const arg = arguments[i2];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = (_b = (_a = lastResult == null ? void 0 : lastResult.deref) == null ? void 0 : _a.call(lastResult)) != null ? _b : lastResult;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
        lastResult = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector2 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      "createSelector expects an output function after the inputs, but received: [".concat(typeof resultFunc, "]")
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = []
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
      return lastResult;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize,
      argsMemoize
    });
  };
  Object.assign(createSelector2, {
    withTypes: () => createSelector2
  });
  return createSelector2;
}
var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector) => {
    assertIsObject(
      inputSelectorsObject,
      "createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ".concat(typeof inputSelectorsObject)
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key) => inputSelectorsObject[key]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index) => {
          composition[inputSelectorKeys[index]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);
function createThunkMiddleware(extraArgument) {
  const middleware = ({ dispatch, getState }) => (next) => (action) => {
    if (typeof action === "function") {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
  return middleware;
}
var thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0) return void 0;
  if (typeof arguments[0] === "object") return compose;
  return compose.apply(null, arguments);
};
var hasMatchFunction = (v2) => {
  return v2 && typeof v2.match === "function";
};
function createAction(type, prepareAction) {
  function actionCreator(...args) {
    if (prepareAction) {
      let prepared = prepareAction(...args);
      if (!prepared) {
        throw new Error(formatProdErrorMessage(0));
      }
      return {
        type,
        payload: prepared.payload,
        ..."meta" in prepared && {
          meta: prepared.meta
        },
        ..."error" in prepared && {
          error: prepared.error
        }
      };
    }
    return {
      type,
      payload: args[0]
    };
  }
  actionCreator.toString = () => "".concat(type);
  actionCreator.type = type;
  actionCreator.match = (action) => isAction(action) && action.type === type;
  return actionCreator;
}
var Tuple = class _Tuple extends Array {
  constructor(...items) {
    super(...items);
    Object.setPrototypeOf(this, _Tuple.prototype);
  }
  static get [Symbol.species]() {
    return _Tuple;
  }
  concat(...arr2) {
    return super.concat.apply(this, arr2);
  }
  prepend(...arr2) {
    if (arr2.length === 1 && Array.isArray(arr2[0])) {
      return new _Tuple(...arr2[0].concat(this));
    }
    return new _Tuple(...arr2.concat(this));
  }
};
function freezeDraftable(val) {
  return isDraftable(val) ? produce(val, () => {
  }) : val;
}
function getOrInsertComputed$1(map3, key, compute) {
  if (map3.has(key)) return map3.get(key);
  return map3.set(key, compute(key)).get(key);
}
function isBoolean(x2) {
  return typeof x2 === "boolean";
}
var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {
  const {
    thunk: thunk$1 = true,
    immutableCheck = true,
    serializableCheck = true,
    actionCreatorCheck = true
  } = options != null ? options : {};
  let middlewareArray = new Tuple();
  if (thunk$1) {
    if (isBoolean(thunk$1)) {
      middlewareArray.push(thunk);
    } else {
      middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
    }
  }
  return middlewareArray;
};
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var prepareAutoBatched = () => (payload) => ({
  payload,
  meta: {
    [SHOULD_AUTOBATCH]: true
  }
});
var createQueueWithTimer = (timeout) => {
  return (notify) => {
    setTimeout(notify, timeout);
  };
};
var autoBatchEnhancer = (options = {
  type: "raf"
}) => (next) => (...args) => {
  const store = next(...args);
  let notifying = true;
  let shouldNotifyAtEndOfTick = false;
  let notificationQueued = false;
  const listeners = /* @__PURE__ */ new Set();
  const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
  ) : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
  const notifyListeners = () => {
    notificationQueued = false;
    if (shouldNotifyAtEndOfTick) {
      shouldNotifyAtEndOfTick = false;
      listeners.forEach((l2) => l2());
    }
  };
  return Object.assign({}, store, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(listener2) {
      const wrappedListener = () => notifying && listener2();
      const unsubscribe = store.subscribe(wrappedListener);
      listeners.add(listener2);
      return () => {
        unsubscribe();
        listeners.delete(listener2);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(action) {
      var _a;
      try {
        notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);
        shouldNotifyAtEndOfTick = !notifying;
        if (shouldNotifyAtEndOfTick) {
          if (!notificationQueued) {
            notificationQueued = true;
            queueCallback(notifyListeners);
          }
        }
        return store.dispatch(action);
      } finally {
        notifying = true;
      }
    }
  });
};
var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {
  const {
    autoBatch = true
  } = options != null ? options : {};
  let enhancerArray = new Tuple(middlewareEnhancer);
  if (autoBatch) {
    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
  }
  return enhancerArray;
};
function configureStore(options) {
  const getDefaultMiddleware = buildGetDefaultMiddleware();
  const {
    reducer: reducer2 = void 0,
    middleware,
    devTools = true,
    duplicateMiddlewareCheck = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options || {};
  let rootReducer;
  if (typeof reducer2 === "function") {
    rootReducer = reducer2;
  } else if (isPlainObject$3(reducer2)) {
    rootReducer = combineReducers(reducer2);
  } else {
    throw new Error(formatProdErrorMessage(1));
  }
  let finalMiddleware;
  if (typeof middleware === "function") {
    finalMiddleware = middleware(getDefaultMiddleware);
  } else {
    finalMiddleware = getDefaultMiddleware();
  }
  let finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools({
      // Enable capture of stack traces for dispatched Redux actions
      trace: false,
      ...typeof devTools === "object" && devTools
    });
  }
  const middlewareEnhancer = applyMiddleware(...finalMiddleware);
  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
  let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
  const composedEnhancer = finalCompose(...storeEnhancers);
  return createStore(rootReducer, preloadedState, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  const actionsMap = {};
  const actionMatchers = [];
  let defaultCaseReducer;
  const builder = {
    addCase(typeOrActionCreator, reducer2) {
      const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type) {
        throw new Error(formatProdErrorMessage(28));
      }
      if (type in actionsMap) {
        throw new Error(formatProdErrorMessage(29));
      }
      actionsMap[type] = reducer2;
      return builder;
    },
    addAsyncThunk(asyncThunk, reducers) {
      if (reducers.pending) actionsMap[asyncThunk.pending.type] = reducers.pending;
      if (reducers.rejected) actionsMap[asyncThunk.rejected.type] = reducers.rejected;
      if (reducers.fulfilled) actionsMap[asyncThunk.fulfilled.type] = reducers.fulfilled;
      if (reducers.settled) actionMatchers.push({
        matcher: asyncThunk.settled,
        reducer: reducers.settled
      });
      return builder;
    },
    addMatcher(matcher, reducer2) {
      actionMatchers.push({
        matcher,
        reducer: reducer2
      });
      return builder;
    },
    addDefaultCase(reducer2) {
      defaultCaseReducer = reducer2;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x2) {
  return typeof x2 === "function";
}
function createReducer(initialState2, mapOrBuilderCallback) {
  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
  let getInitialState2;
  if (isStateFunction(initialState2)) {
    getInitialState2 = () => freezeDraftable(initialState2());
  } else {
    const frozenInitialState = freezeDraftable(initialState2);
    getInitialState2 = () => frozenInitialState;
  }
  function reducer2(state = getInitialState2(), action) {
    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
      matcher
    }) => matcher(action)).map(({
      reducer: reducer22
    }) => reducer22)];
    if (caseReducers.filter((cr2) => !!cr2).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce((previousState, caseReducer) => {
      if (caseReducer) {
        if (isDraft(previousState)) {
          const draft = previousState;
          const result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!isDraftable(previousState)) {
          const result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return produce(previousState, (draft) => {
            return caseReducer(draft, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer2.getInitialState = getInitialState2;
  return reducer2;
}
var matches = (matcher, action) => {
  if (hasMatchFunction(matcher)) {
    return matcher.match(action);
  } else {
    return matcher(action);
  }
};
function isAnyOf(...matchers) {
  return (action) => {
    return matchers.some((matcher) => matches(matcher, action));
  };
}
function isAllOf(...matchers) {
  return (action) => {
    return matchers.every((matcher) => matches(matcher, action));
  };
}
function hasExpectedRequestMetadata(action, validStatus) {
  if (!action || !action.meta) return false;
  const hasValidRequestId = typeof action.meta.requestId === "string";
  const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
  return hasValidRequestId && hasValidRequestStatus;
}
function isAsyncThunkArray(a2) {
  return typeof a2[0] === "function" && "pending" in a2[0] && "fulfilled" in a2[0] && "rejected" in a2[0];
}
function isPending(...asyncThunks) {
  if (asyncThunks.length === 0) {
    return (action) => hasExpectedRequestMetadata(action, ["pending"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isPending()(asyncThunks[0]);
  }
  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.pending));
}
function isRejected(...asyncThunks) {
  if (asyncThunks.length === 0) {
    return (action) => hasExpectedRequestMetadata(action, ["rejected"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isRejected()(asyncThunks[0]);
  }
  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.rejected));
}
function isRejectedWithValue(...asyncThunks) {
  const hasFlag = (action) => {
    return action && action.meta && action.meta.rejectedWithValue;
  };
  if (asyncThunks.length === 0) {
    return isAllOf(isRejected(...asyncThunks), hasFlag);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isRejectedWithValue()(asyncThunks[0]);
  }
  return isAllOf(isRejected(...asyncThunks), hasFlag);
}
function isFulfilled(...asyncThunks) {
  if (asyncThunks.length === 0) {
    return (action) => hasExpectedRequestMetadata(action, ["fulfilled"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isFulfilled()(asyncThunks[0]);
  }
  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.fulfilled));
}
function isAsyncThunkAction(...asyncThunks) {
  if (asyncThunks.length === 0) {
    return (action) => hasExpectedRequestMetadata(action, ["pending", "fulfilled", "rejected"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isAsyncThunkAction()(asyncThunks[0]);
  }
  return isAnyOf(...asyncThunks.flatMap((asyncThunk) => [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled]));
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = (size = 21) => {
  let id = "";
  let i2 = size;
  while (i2--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var commonProperties = ["name", "message", "stack", "code"];
var RejectWithValue = class {
  constructor(payload, meta) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    __publicField(this, "_type");
    this.payload = payload;
    this.meta = meta;
  }
};
var FulfillWithMeta = class {
  constructor(payload, meta) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    __publicField(this, "_type");
    this.payload = payload;
    this.meta = meta;
  }
};
var miniSerializeError = (value) => {
  if (typeof value === "object" && value !== null) {
    const simpleError = {};
    for (const property of commonProperties) {
      if (typeof value[property] === "string") {
        simpleError[property] = value[property];
      }
    }
    return simpleError;
  }
  return {
    message: String(value)
  };
};
var externalAbortMessage = "External signal was aborted";
var createAsyncThunk = /* @__PURE__ */ (() => {
  function createAsyncThunk2(typePrefix, payloadCreator, options) {
    const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta) => ({
      payload,
      meta: {
        ...meta || {},
        arg,
        requestId,
        requestStatus: "fulfilled"
      }
    }));
    const pending = createAction(typePrefix + "/pending", (requestId, arg, meta) => ({
      payload: void 0,
      meta: {
        ...meta || {},
        arg,
        requestId,
        requestStatus: "pending"
      }
    }));
    const rejected = createAction(typePrefix + "/rejected", (error2, requestId, arg, payload, meta) => ({
      payload,
      error: (options && options.serializeError || miniSerializeError)(error2 || "Rejected"),
      meta: {
        ...meta || {},
        arg,
        requestId,
        rejectedWithValue: !!payload,
        requestStatus: "rejected",
        aborted: (error2 == null ? void 0 : error2.name) === "AbortError",
        condition: (error2 == null ? void 0 : error2.name) === "ConditionError"
      }
    }));
    function actionCreator(arg, {
      signal
    } = {}) {
      return (dispatch, getState, extra) => {
        const requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
        const abortController = new AbortController();
        let abortHandler;
        let abortReason;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        if (signal) {
          if (signal.aborted) {
            abort(externalAbortMessage);
          } else {
            signal.addEventListener("abort", () => abort(externalAbortMessage), {
              once: true
            });
          }
        }
        const promise = (async function() {
          var _a, _b;
          let finalAction;
          try {
            let conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {
              getState,
              extra
            });
            if (isThenable(conditionResult)) {
              conditionResult = await conditionResult;
            }
            if (conditionResult === false || abortController.signal.aborted) {
              throw {
                name: "ConditionError",
                message: "Aborted due to condition callback returning false."
              };
            }
            const abortedPromise = new Promise((_23, reject) => {
              abortHandler = () => {
                reject({
                  name: "AbortError",
                  message: abortReason || "Aborted"
                });
              };
              abortController.signal.addEventListener("abort", abortHandler);
            });
            dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {
              requestId,
              arg
            }, {
              getState,
              extra
            })));
            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
              dispatch,
              getState,
              extra,
              requestId,
              signal: abortController.signal,
              abort,
              rejectWithValue: (value, meta) => {
                return new RejectWithValue(value, meta);
              },
              fulfillWithValue: (value, meta) => {
                return new FulfillWithMeta(value, meta);
              }
            })).then((result) => {
              if (result instanceof RejectWithValue) {
                throw result;
              }
              if (result instanceof FulfillWithMeta) {
                return fulfilled(result.payload, requestId, arg, result.meta);
              }
              return fulfilled(result, requestId, arg);
            })]);
          } catch (err2) {
            finalAction = err2 instanceof RejectWithValue ? rejected(null, requestId, arg, err2.payload, err2.meta) : rejected(err2, requestId, arg);
          } finally {
            if (abortHandler) {
              abortController.signal.removeEventListener("abort", abortHandler);
            }
          }
          const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
          if (!skipDispatch) {
            dispatch(finalAction);
          }
          return finalAction;
        })();
        return Object.assign(promise, {
          abort,
          requestId,
          arg,
          unwrap() {
            return promise.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      settled: isAnyOf(rejected, fulfilled),
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = () => createAsyncThunk2;
  return createAsyncThunk2;
})();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}
var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
function getType(slice4, actionKey) {
  return "".concat(slice4, "/").concat(actionKey);
}
function buildCreateSlice({
  creators
} = {}) {
  var _a;
  const cAT = (_a = creators == null ? void 0 : creators.asyncThunk) == null ? void 0 : _a[asyncThunkSymbol];
  return function createSlice2(options) {
    const {
      name,
      reducerPath = name
    } = options;
    if (!name) {
      throw new Error(formatProdErrorMessage(11));
    }
    const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
    const reducerNames = Object.keys(reducers);
    const context2 = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    };
    const contextMethods = {
      addCase(typeOrActionCreator, reducer22) {
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error(formatProdErrorMessage(12));
        }
        if (type in context2.sliceCaseReducersByType) {
          throw new Error(formatProdErrorMessage(13));
        }
        context2.sliceCaseReducersByType[type] = reducer22;
        return contextMethods;
      },
      addMatcher(matcher, reducer22) {
        context2.sliceMatchers.push({
          matcher,
          reducer: reducer22
        });
        return contextMethods;
      },
      exposeAction(name2, actionCreator) {
        context2.actionCreators[name2] = actionCreator;
        return contextMethods;
      },
      exposeCaseReducer(name2, reducer22) {
        context2.sliceCaseReducersByName[name2] = reducer22;
        return contextMethods;
      }
    };
    reducerNames.forEach((reducerName) => {
      const reducerDefinition = reducers[reducerName];
      const reducerDetails = {
        reducerName,
        type: getType(name, reducerName),
        createNotation: typeof options.reducers === "function"
      };
      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
      } else {
        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
      }
    });
    function buildReducer() {
      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
      const finalCaseReducers = {
        ...extraReducers,
        ...context2.sliceCaseReducersByType
      };
      return createReducer(options.initialState, (builder) => {
        for (let key in finalCaseReducers) {
          builder.addCase(key, finalCaseReducers[key]);
        }
        for (let sM of context2.sliceMatchers) {
          builder.addMatcher(sM.matcher, sM.reducer);
        }
        for (let m2 of actionMatchers) {
          builder.addMatcher(m2.matcher, m2.reducer);
        }
        if (defaultCaseReducer) {
          builder.addDefaultCase(defaultCaseReducer);
        }
      });
    }
    const selectSelf = (state) => state;
    const injectedSelectorCache = /* @__PURE__ */ new Map();
    const injectedStateCache = /* @__PURE__ */ new WeakMap();
    let _reducer;
    function reducer2(state, action) {
      if (!_reducer) _reducer = buildReducer();
      return _reducer(state, action);
    }
    function getInitialState2() {
      if (!_reducer) _reducer = buildReducer();
      return _reducer.getInitialState();
    }
    function makeSelectorProps(reducerPath2, injected = false) {
      function selectSlice(state) {
        let sliceState = state[reducerPath2];
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getOrInsertComputed$1(injectedStateCache, selectSlice, getInitialState2);
          }
        }
        return sliceState;
      }
      function getSelectors(selectState = selectSelf) {
        const selectorCache = getOrInsertComputed$1(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
        return getOrInsertComputed$1(selectorCache, selectState, () => {
          var _a2;
          const map3 = {};
          for (const [name2, selector] of Object.entries((_a2 = options.selectors) != null ? _a2 : {})) {
            map3[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed$1(injectedStateCache, selectState, getInitialState2), injected);
          }
          return map3;
        });
      }
      return {
        reducerPath: reducerPath2,
        getSelectors,
        get selectors() {
          return getSelectors(selectSlice);
        },
        selectSlice
      };
    }
    const slice4 = {
      name,
      reducer: reducer2,
      actions: context2.actionCreators,
      caseReducers: context2.sliceCaseReducersByName,
      getInitialState: getInitialState2,
      ...makeSelectorProps(reducerPath),
      injectInto(injectable, {
        reducerPath: pathOpt,
        ...config
      } = {}) {
        const newReducerPath = pathOpt != null ? pathOpt : reducerPath;
        injectable.inject({
          reducerPath: newReducerPath,
          reducer: reducer2
        }, config);
        return {
          ...slice4,
          ...makeSelectorProps(newReducerPath, true)
        };
      }
    };
    return slice4;
  };
}
function wrapSelector(selector, selectState, getInitialState2, injected) {
  function wrapper(rootState, ...args) {
    let sliceState = selectState(rootState);
    if (typeof sliceState === "undefined") {
      if (injected) {
        sliceState = getInitialState2();
      }
    }
    return selector(sliceState, ...args);
  }
  wrapper.unwrapped = selector;
  return wrapper;
}
var createSlice = /* @__PURE__ */ buildCreateSlice();
function buildReducerCreators() {
  function asyncThunk(payloadCreator, config) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator,
      ...config
    };
  }
  asyncThunk.withTypes = () => asyncThunk;
  return {
    reducer(caseReducer) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [caseReducer.name](...args) {
          return caseReducer(...args);
        }
      }[caseReducer.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(prepare, reducer2) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare,
        reducer: reducer2
      };
    },
    asyncThunk
  };
}
function handleNormalReducerDefinition({
  type,
  reducerName,
  createNotation
}, maybeReducerWithPrepare, context2) {
  let caseReducer;
  let prepareCallback;
  if ("reducer" in maybeReducerWithPrepare) {
    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
      throw new Error(formatProdErrorMessage(17));
    }
    caseReducer = maybeReducerWithPrepare.reducer;
    prepareCallback = maybeReducerWithPrepare.prepare;
  } else {
    caseReducer = maybeReducerWithPrepare;
  }
  context2.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "asyncThunk";
}
function isCaseReducerWithPrepareDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
}
function handleThunkCaseReducerDefinition({
  type,
  reducerName
}, reducerDefinition, context2, cAT) {
  if (!cAT) {
    throw new Error(formatProdErrorMessage(18));
  }
  const {
    payloadCreator,
    fulfilled,
    pending,
    rejected,
    settled,
    options
  } = reducerDefinition;
  const thunk2 = cAT(type, payloadCreator, options);
  context2.exposeAction(reducerName, thunk2);
  if (fulfilled) {
    context2.addCase(thunk2.fulfilled, fulfilled);
  }
  if (pending) {
    context2.addCase(thunk2.pending, pending);
  }
  if (rejected) {
    context2.addCase(thunk2.rejected, rejected);
  }
  if (settled) {
    context2.addMatcher(thunk2.settled, settled);
  }
  context2.exposeCaseReducer(reducerName, {
    fulfilled: fulfilled || noop$2,
    pending: pending || noop$2,
    rejected: rejected || noop$2,
    settled: settled || noop$2
  });
}
function noop$2() {
}
function formatProdErrorMessage(code) {
  return "Minified Redux Toolkit error #".concat(code, "; visit https://redux-toolkit.js.org/Errors?code=").concat(code, " for the full message or use the non-minified dev environment for full errors. ");
}
var SchemaError = class extends Error {
  /**
   * Creates a schema error with useful information.
   *
   * @param issues The schema issues.
   */
  constructor(issues) {
    super(issues[0].message);
    /**
     * The schema issues.
     */
    __publicField(this, "issues");
    this.name = "SchemaError";
    this.issues = issues;
  }
};
var QueryStatus = /* @__PURE__ */ ((QueryStatus2) => {
  QueryStatus2["uninitialized"] = "uninitialized";
  QueryStatus2["pending"] = "pending";
  QueryStatus2["fulfilled"] = "fulfilled";
  QueryStatus2["rejected"] = "rejected";
  return QueryStatus2;
})(QueryStatus || {});
function getRequestStatusFlags(status) {
  return {
    status,
    isUninitialized: status === "uninitialized",
    isLoading: status === "pending",
    isSuccess: status === "fulfilled",
    isError: status === "rejected"
    /* rejected */
  };
}
var isPlainObject2 = isPlainObject$3;
function copyWithStructuralSharing(oldObj, newObj) {
  if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {
    return newObj;
  }
  const newKeys = Object.keys(newObj);
  const oldKeys = Object.keys(oldObj);
  let isSameObject = newKeys.length === oldKeys.length;
  const mergeObj = Array.isArray(newObj) ? [] : {};
  for (const key of newKeys) {
    mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);
    if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];
  }
  return isSameObject ? oldObj : mergeObj;
}
function countObjectKeys(obj) {
  let count2 = 0;
  for (const _key in obj) {
    count2++;
  }
  return count2;
}
var flatten = (arr2) => [].concat(...arr2);
function isAbsoluteUrl(url) {
  return new RegExp("(^|:)//").test(url);
}
function isDocumentVisible() {
  if (typeof document === "undefined") {
    return true;
  }
  return document.visibilityState !== "hidden";
}
function isNotNullish(v2) {
  return v2 != null;
}
function isOnline() {
  return typeof navigator === "undefined" ? true : navigator.onLine === void 0 ? true : navigator.onLine;
}
var withoutTrailingSlash = (url) => url.replace(/\/$/, "");
var withoutLeadingSlash = (url) => url.replace(/^\//, "");
function joinUrls(base, url) {
  if (!base) {
    return url;
  }
  if (!url) {
    return base;
  }
  if (isAbsoluteUrl(url)) {
    return url;
  }
  const delimiter = base.endsWith("/") || !url.startsWith("?") ? "/" : "";
  base = withoutTrailingSlash(base);
  url = withoutLeadingSlash(url);
  return "".concat(base).concat(delimiter).concat(url);
}
function getOrInsert(map3, key, value) {
  if (map3.has(key)) return map3.get(key);
  return map3.set(key, value).get(key);
}
function getOrInsertComputed(map3, key, compute) {
  if (map3.has(key)) return map3.get(key);
  return map3.set(key, compute(key)).get(key);
}
var createNewMap = () => /* @__PURE__ */ new Map();
var defaultFetchFn = (...args) => fetch(...args);
var defaultValidateStatus = (response) => response.status >= 200 && response.status <= 299;
var defaultIsJsonContentType = (headers) => (
  /*applicat*/
  /ion\/(vnd\.api\+)?json/.test(headers.get("content-type") || "")
);
function stripUndefined(obj) {
  if (!isPlainObject$3(obj)) {
    return obj;
  }
  const copy2 = {
    ...obj
  };
  for (const [k2, v2] of Object.entries(copy2)) {
    if (v2 === void 0) delete copy2[k2];
  }
  return copy2;
}
function fetchBaseQuery({
  baseUrl,
  prepareHeaders = (x2) => x2,
  fetchFn = defaultFetchFn,
  paramsSerializer,
  isJsonContentType = defaultIsJsonContentType,
  jsonContentType = "application/json",
  jsonReplacer,
  timeout: defaultTimeout,
  responseHandler: globalResponseHandler,
  validateStatus: globalValidateStatus,
  ...baseFetchOptions
} = {}) {
  if (typeof fetch === "undefined" && fetchFn === defaultFetchFn) {
    console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.");
  }
  return async (arg, api, extraOptions) => {
    const {
      getState,
      extra,
      endpoint,
      forced,
      type
    } = api;
    let meta;
    let {
      url,
      headers = new Headers(baseFetchOptions.headers),
      params = void 0,
      responseHandler = globalResponseHandler != null ? globalResponseHandler : "json",
      validateStatus = globalValidateStatus != null ? globalValidateStatus : defaultValidateStatus,
      timeout = defaultTimeout,
      ...rest2
    } = typeof arg == "string" ? {
      url: arg
    } : arg;
    let abortController, signal = api.signal;
    if (timeout) {
      abortController = new AbortController();
      api.signal.addEventListener("abort", abortController.abort);
      signal = abortController.signal;
    }
    let config = {
      ...baseFetchOptions,
      signal,
      ...rest2
    };
    headers = new Headers(stripUndefined(headers));
    config.headers = await prepareHeaders(headers, {
      getState,
      arg,
      extra,
      endpoint,
      forced,
      type,
      extraOptions
    }) || headers;
    const isJsonifiable = (body) => typeof body === "object" && (isPlainObject$3(body) || Array.isArray(body) || typeof body.toJSON === "function");
    if (!config.headers.has("content-type") && isJsonifiable(config.body)) {
      config.headers.set("content-type", jsonContentType);
    }
    if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {
      config.body = JSON.stringify(config.body, jsonReplacer);
    }
    if (params) {
      const divider = ~url.indexOf("?") ? "&" : "?";
      const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));
      url += divider + query;
    }
    url = joinUrls(baseUrl, url);
    const request3 = new Request(url, config);
    const requestClone = new Request(url, config);
    meta = {
      request: requestClone
    };
    let response, timedOut = false, timeoutId = abortController && setTimeout(() => {
      timedOut = true;
      abortController.abort();
    }, timeout);
    try {
      response = await fetchFn(request3);
    } catch (e2) {
      return {
        error: {
          status: timedOut ? "TIMEOUT_ERROR" : "FETCH_ERROR",
          error: String(e2)
        },
        meta
      };
    } finally {
      if (timeoutId) clearTimeout(timeoutId);
      abortController == null ? void 0 : abortController.signal.removeEventListener("abort", abortController.abort);
    }
    const responseClone = response.clone();
    meta.response = responseClone;
    let resultData;
    let responseText = "";
    try {
      let handleResponseError;
      await Promise.all([
        handleResponse(response, responseHandler).then((r2) => resultData = r2, (e2) => handleResponseError = e2),
        // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182
        // we *have* to "use up" both streams at the same time or they will stop running in node-fetch scenarios
        responseClone.text().then((r2) => responseText = r2, () => {
        })
      ]);
      if (handleResponseError) throw handleResponseError;
    } catch (e2) {
      return {
        error: {
          status: "PARSING_ERROR",
          originalStatus: response.status,
          data: responseText,
          error: String(e2)
        },
        meta
      };
    }
    return validateStatus(response, resultData) ? {
      data: resultData,
      meta
    } : {
      error: {
        status: response.status,
        data: resultData
      },
      meta
    };
  };
  async function handleResponse(response, responseHandler) {
    if (typeof responseHandler === "function") {
      return responseHandler(response);
    }
    if (responseHandler === "content-type") {
      responseHandler = isJsonContentType(response.headers) ? "json" : "text";
    }
    if (responseHandler === "json") {
      const text = await response.text();
      return text.length ? JSON.parse(text) : null;
    }
    return response.text();
  }
}
var HandledError = class {
  constructor(value, meta = void 0) {
    this.value = value;
    this.meta = meta;
  }
};
var onFocus = /* @__PURE__ */ createAction("__rtkq/focused");
var onFocusLost = /* @__PURE__ */ createAction("__rtkq/unfocused");
var onOnline = /* @__PURE__ */ createAction("__rtkq/online");
var onOffline = /* @__PURE__ */ createAction("__rtkq/offline");
function isQueryDefinition$1(e2) {
  return e2.type === "query";
}
function isMutationDefinition$1(e2) {
  return e2.type === "mutation";
}
function isInfiniteQueryDefinition$1(e2) {
  return e2.type === "infinitequery";
}
function isAnyQueryDefinition(e2) {
  return isQueryDefinition$1(e2) || isInfiniteQueryDefinition$1(e2);
}
function calculateProvidedBy(description, result, error2, queryArg, meta, assertTagTypes) {
  if (isFunction$1(description)) {
    return description(result, error2, queryArg, meta).filter(isNotNullish).map(expandTagDescription).map(assertTagTypes);
  }
  if (Array.isArray(description)) {
    return description.map(expandTagDescription).map(assertTagTypes);
  }
  return [];
}
function isFunction$1(t2) {
  return typeof t2 === "function";
}
function expandTagDescription(description) {
  return typeof description === "string" ? {
    type: description
  } : description;
}
function asSafePromise(promise, fallback) {
  return promise.catch(fallback);
}
var forceQueryFnSymbol = Symbol("forceQueryFn");
var isUpsertQuery = (arg) => typeof arg[forceQueryFnSymbol] === "function";
function buildInitiate({
  serializeQueryArgs,
  queryThunk,
  infiniteQueryThunk,
  mutationThunk,
  api,
  context: context2,
  internalState
}) {
  const {
    runningQueries,
    runningMutations
  } = internalState;
  const {
    unsubscribeQueryResult,
    removeMutationResult,
    updateSubscriptionOptions
  } = api.internalActions;
  return {
    buildInitiateQuery,
    buildInitiateInfiniteQuery,
    buildInitiateMutation,
    getRunningQueryThunk,
    getRunningMutationThunk,
    getRunningQueriesThunk,
    getRunningMutationsThunk
  };
  function getRunningQueryThunk(endpointName, queryArgs) {
    return (dispatch) => {
      var _a;
      const endpointDefinition = context2.endpointDefinitions[endpointName];
      const queryCacheKey = serializeQueryArgs({
        queryArgs,
        endpointDefinition,
        endpointName
      });
      return (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];
    };
  }
  function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {
    return (dispatch) => {
      var _a;
      return (_a = runningMutations.get(dispatch)) == null ? void 0 : _a[fixedCacheKeyOrRequestId];
    };
  }
  function getRunningQueriesThunk() {
    return (dispatch) => Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);
  }
  function getRunningMutationsThunk() {
    return (dispatch) => Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);
  }
  function buildInitiateAnyQuery(endpointName, endpointDefinition) {
    const queryAction = (arg, {
      subscribe = true,
      forceRefetch,
      subscriptionOptions,
      [forceQueryFnSymbol]: forceQueryFn,
      ...rest2
    } = {}) => (dispatch, getState) => {
      var _a;
      const queryCacheKey = serializeQueryArgs({
        queryArgs: arg,
        endpointDefinition,
        endpointName
      });
      let thunk2;
      const commonThunkArgs = {
        ...rest2,
        type: "query",
        subscribe,
        forceRefetch,
        subscriptionOptions,
        endpointName,
        originalArgs: arg,
        queryCacheKey,
        [forceQueryFnSymbol]: forceQueryFn
      };
      if (isQueryDefinition$1(endpointDefinition)) {
        thunk2 = queryThunk(commonThunkArgs);
      } else {
        const {
          direction,
          initialPageParam
        } = rest2;
        thunk2 = infiniteQueryThunk({
          ...commonThunkArgs,
          // Supply these even if undefined. This helps with a field existence
          // check over in `buildSlice.ts`
          direction,
          initialPageParam
        });
      }
      const selector = api.endpoints[endpointName].select(arg);
      const thunkResult = dispatch(thunk2);
      const stateAfter = selector(getState());
      const {
        requestId,
        abort
      } = thunkResult;
      const skippedSynchronously = stateAfter.requestId !== requestId;
      const runningQuery = (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];
      const selectFromState = () => selector(getState());
      const statePromise = Object.assign(forceQueryFn ? (
        // a query has been forced (upsertQueryData)
        // -> we want to resolve it once data has been written with the data that will be written
        thunkResult.then(selectFromState)
      ) : skippedSynchronously && !runningQuery ? (
        // a query has been skipped due to a condition and we do not have any currently running query
        // -> we want to resolve it immediately with the current data
        Promise.resolve(stateAfter)
      ) : (
        // query just started or one is already in flight
        // -> wait for the running query, then resolve with data from after that
        Promise.all([runningQuery, thunkResult]).then(selectFromState)
      ), {
        arg,
        requestId,
        subscriptionOptions,
        queryCacheKey,
        abort,
        async unwrap() {
          const result = await statePromise;
          if (result.isError) {
            throw result.error;
          }
          return result.data;
        },
        refetch: () => dispatch(queryAction(arg, {
          subscribe: false,
          forceRefetch: true
        })),
        unsubscribe() {
          if (subscribe) dispatch(unsubscribeQueryResult({
            queryCacheKey,
            requestId
          }));
        },
        updateSubscriptionOptions(options) {
          statePromise.subscriptionOptions = options;
          dispatch(updateSubscriptionOptions({
            endpointName,
            requestId,
            queryCacheKey,
            options
          }));
        }
      });
      if (!runningQuery && !skippedSynchronously && !forceQueryFn) {
        const running = getOrInsert(runningQueries, dispatch, {});
        running[queryCacheKey] = statePromise;
        statePromise.then(() => {
          delete running[queryCacheKey];
          if (!countObjectKeys(running)) {
            runningQueries.delete(dispatch);
          }
        });
      }
      return statePromise;
    };
    return queryAction;
  }
  function buildInitiateQuery(endpointName, endpointDefinition) {
    const queryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
    return queryAction;
  }
  function buildInitiateInfiniteQuery(endpointName, endpointDefinition) {
    const infiniteQueryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
    return infiniteQueryAction;
  }
  function buildInitiateMutation(endpointName) {
    return (arg, {
      track = true,
      fixedCacheKey
    } = {}) => (dispatch, getState) => {
      const thunk2 = mutationThunk({
        type: "mutation",
        endpointName,
        originalArgs: arg,
        track,
        fixedCacheKey
      });
      const thunkResult = dispatch(thunk2);
      const {
        requestId,
        abort,
        unwrap: unwrap2
      } = thunkResult;
      const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data) => ({
        data
      })), (error2) => ({
        error: error2
      }));
      const reset2 = () => {
        dispatch(removeMutationResult({
          requestId,
          fixedCacheKey
        }));
      };
      const ret = Object.assign(returnValuePromise, {
        arg: thunkResult.arg,
        requestId,
        abort,
        unwrap: unwrap2,
        reset: reset2
      });
      const running = runningMutations.get(dispatch) || {};
      runningMutations.set(dispatch, running);
      running[requestId] = ret;
      ret.then(() => {
        delete running[requestId];
        if (!countObjectKeys(running)) {
          runningMutations.delete(dispatch);
        }
      });
      if (fixedCacheKey) {
        running[fixedCacheKey] = ret;
        ret.then(() => {
          if (running[fixedCacheKey] === ret) {
            delete running[fixedCacheKey];
            if (!countObjectKeys(running)) {
              runningMutations.delete(dispatch);
            }
          }
        });
      }
      return ret;
    };
  }
}
var NamedSchemaError = class extends SchemaError {
  constructor(issues, value, schemaName, _bqMeta) {
    super(issues);
    this.value = value;
    this.schemaName = schemaName;
    this._bqMeta = _bqMeta;
  }
};
var shouldSkip = (skipSchemaValidation, schemaName) => Array.isArray(skipSchemaValidation) ? skipSchemaValidation.includes(schemaName) : !!skipSchemaValidation;
async function parseWithSchema(schema, data, schemaName, bqMeta) {
  const result = await schema["~standard"].validate(data);
  if (result.issues) {
    throw new NamedSchemaError(result.issues, data, schemaName, bqMeta);
  }
  return result.value;
}
function defaultTransformResponse(baseQueryReturnValue) {
  return baseQueryReturnValue;
}
var addShouldAutoBatch = (arg = {}) => {
  return {
    ...arg,
    [SHOULD_AUTOBATCH]: true
  };
};
function buildThunks({
  reducerPath,
  baseQuery,
  context: {
    endpointDefinitions
  },
  serializeQueryArgs,
  api,
  assertTagType,
  selectors,
  onSchemaFailure,
  catchSchemaFailure: globalCatchSchemaFailure,
  skipSchemaValidation: globalSkipSchemaValidation
}) {
  const patchQueryData = (endpointName, arg, patches, updateProvided) => (dispatch, getState) => {
    const endpointDefinition = endpointDefinitions[endpointName];
    const queryCacheKey = serializeQueryArgs({
      queryArgs: arg,
      endpointDefinition,
      endpointName
    });
    dispatch(api.internalActions.queryResultPatched({
      queryCacheKey,
      patches
    }));
    if (!updateProvided) {
      return;
    }
    const newValue = api.endpoints[endpointName].select(arg)(
      // Work around TS 4.1 mismatch
      getState()
    );
    const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, arg, {}, assertTagType);
    dispatch(api.internalActions.updateProvidedBy([{
      queryCacheKey,
      providedTags
    }]));
  };
  function addToStart(items, item, max2 = 0) {
    const newItems = [item, ...items];
    return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
  }
  function addToEnd(items, item, max2 = 0) {
    const newItems = [...items, item];
    return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
  }
  const updateQueryData = (endpointName, arg, updateRecipe, updateProvided = true) => (dispatch, getState) => {
    const endpointDefinition = api.endpoints[endpointName];
    const currentState = endpointDefinition.select(arg)(
      // Work around TS 4.1 mismatch
      getState()
    );
    const ret = {
      patches: [],
      inversePatches: [],
      undo: () => dispatch(api.util.patchQueryData(endpointName, arg, ret.inversePatches, updateProvided))
    };
    if (currentState.status === "uninitialized") {
      return ret;
    }
    let newValue;
    if ("data" in currentState) {
      if (isDraftable(currentState.data)) {
        const [value, patches, inversePatches] = produceWithPatches(currentState.data, updateRecipe);
        ret.patches.push(...patches);
        ret.inversePatches.push(...inversePatches);
        newValue = value;
      } else {
        newValue = updateRecipe(currentState.data);
        ret.patches.push({
          op: "replace",
          path: [],
          value: newValue
        });
        ret.inversePatches.push({
          op: "replace",
          path: [],
          value: currentState.data
        });
      }
    }
    if (ret.patches.length === 0) {
      return ret;
    }
    dispatch(api.util.patchQueryData(endpointName, arg, ret.patches, updateProvided));
    return ret;
  };
  const upsertQueryData = (endpointName, arg, value) => (dispatch) => {
    const res = dispatch(api.endpoints[endpointName].initiate(arg, {
      subscribe: false,
      forceRefetch: true,
      [forceQueryFnSymbol]: () => ({
        data: value
      })
    }));
    return res;
  };
  const getTransformCallbackForEndpoint = (endpointDefinition, transformFieldName) => {
    return endpointDefinition.query && endpointDefinition[transformFieldName] ? endpointDefinition[transformFieldName] : defaultTransformResponse;
  };
  const executeEndpoint = async (arg, {
    signal,
    abort,
    rejectWithValue,
    fulfillWithValue,
    dispatch,
    getState,
    extra
  }) => {
    var _a, _b, _c, _d;
    const endpointDefinition = endpointDefinitions[arg.endpointName];
    const {
      metaSchema,
      skipSchemaValidation = globalSkipSchemaValidation
    } = endpointDefinition;
    try {
      let transformResponse = defaultTransformResponse;
      const baseQueryApi = {
        signal,
        abort,
        dispatch,
        getState,
        extra,
        endpoint: arg.endpointName,
        type: arg.type,
        forced: arg.type === "query" ? isForcedQuery(arg, getState()) : void 0,
        queryCacheKey: arg.type === "query" ? arg.queryCacheKey : void 0
      };
      const forceQueryFn = arg.type === "query" ? arg[forceQueryFnSymbol] : void 0;
      let finalQueryReturnValue;
      const fetchPage = async (data, param, maxPages, previous) => {
        if (param == null && data.pages.length) {
          return Promise.resolve({
            data
          });
        }
        const finalQueryArg = {
          queryArg: arg.originalArgs,
          pageParam: param
        };
        const pageResponse = await executeRequest(finalQueryArg);
        const addTo = previous ? addToStart : addToEnd;
        return {
          data: {
            pages: addTo(data.pages, pageResponse.data, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          },
          meta: pageResponse.meta
        };
      };
      async function executeRequest(finalQueryArg) {
        let result;
        const {
          extraOptions,
          argSchema,
          rawResponseSchema,
          responseSchema
        } = endpointDefinition;
        if (argSchema && !shouldSkip(skipSchemaValidation, "arg")) {
          finalQueryArg = await parseWithSchema(
            argSchema,
            finalQueryArg,
            "argSchema",
            {}
            // we don't have a meta yet, so we can't pass it
          );
        }
        if (forceQueryFn) {
          result = forceQueryFn();
        } else if (endpointDefinition.query) {
          transformResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformResponse");
          result = await baseQuery(endpointDefinition.query(finalQueryArg), baseQueryApi, extraOptions);
        } else {
          result = await endpointDefinition.queryFn(finalQueryArg, baseQueryApi, extraOptions, (arg2) => baseQuery(arg2, baseQueryApi, extraOptions));
        }
        if (typeof process !== "undefined" && false) ;
        if (result.error) throw new HandledError(result.error, result.meta);
        let {
          data
        } = result;
        if (rawResponseSchema && !shouldSkip(skipSchemaValidation, "rawResponse")) {
          data = await parseWithSchema(rawResponseSchema, result.data, "rawResponseSchema", result.meta);
        }
        let transformedResponse = await transformResponse(data, result.meta, finalQueryArg);
        if (responseSchema && !shouldSkip(skipSchemaValidation, "response")) {
          transformedResponse = await parseWithSchema(responseSchema, transformedResponse, "responseSchema", result.meta);
        }
        return {
          ...result,
          data: transformedResponse
        };
      }
      if (arg.type === "query" && "infiniteQueryOptions" in endpointDefinition) {
        const {
          infiniteQueryOptions
        } = endpointDefinition;
        const {
          maxPages = Infinity
        } = infiniteQueryOptions;
        let result;
        const blankData = {
          pages: [],
          pageParams: []
        };
        const cachedData = (_a = selectors.selectQueryEntry(getState(), arg.queryCacheKey)) == null ? void 0 : _a.data;
        const isForcedQueryNeedingRefetch = (
          // arg.forceRefetch
          isForcedQuery(arg, getState()) && !arg.direction
        );
        const existingData = isForcedQueryNeedingRefetch || !cachedData ? blankData : cachedData;
        if ("direction" in arg && arg.direction && existingData.pages.length) {
          const previous = arg.direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const param = pageParamFn(infiniteQueryOptions, existingData, arg.originalArgs);
          result = await fetchPage(existingData, param, maxPages, previous);
        } else {
          const {
            initialPageParam = infiniteQueryOptions.initialPageParam
          } = arg;
          const cachedPageParams = (_b = cachedData == null ? void 0 : cachedData.pageParams) != null ? _b : [];
          const firstPageParam = (_c = cachedPageParams[0]) != null ? _c : initialPageParam;
          const totalPages = cachedPageParams.length;
          result = await fetchPage(existingData, firstPageParam, maxPages);
          if (forceQueryFn) {
            result = {
              data: result.data.pages[0]
            };
          }
          for (let i2 = 1; i2 < totalPages; i2++) {
            const param = getNextPageParam(infiniteQueryOptions, result.data, arg.originalArgs);
            result = await fetchPage(result.data, param, maxPages);
          }
        }
        finalQueryReturnValue = result;
      } else {
        finalQueryReturnValue = await executeRequest(arg.originalArgs);
      }
      if (metaSchema && !shouldSkip(skipSchemaValidation, "meta") && finalQueryReturnValue.meta) {
        finalQueryReturnValue.meta = await parseWithSchema(metaSchema, finalQueryReturnValue.meta, "metaSchema", finalQueryReturnValue.meta);
      }
      return fulfillWithValue(finalQueryReturnValue.data, addShouldAutoBatch({
        fulfilledTimeStamp: Date.now(),
        baseQueryMeta: finalQueryReturnValue.meta
      }));
    } catch (error2) {
      let caughtError = error2;
      if (caughtError instanceof HandledError) {
        let transformErrorResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformErrorResponse");
        const {
          rawErrorResponseSchema,
          errorResponseSchema
        } = endpointDefinition;
        let {
          value,
          meta
        } = caughtError;
        try {
          if (rawErrorResponseSchema && !shouldSkip(skipSchemaValidation, "rawErrorResponse")) {
            value = await parseWithSchema(rawErrorResponseSchema, value, "rawErrorResponseSchema", meta);
          }
          if (metaSchema && !shouldSkip(skipSchemaValidation, "meta")) {
            meta = await parseWithSchema(metaSchema, meta, "metaSchema", meta);
          }
          let transformedErrorResponse = await transformErrorResponse(value, meta, arg.originalArgs);
          if (errorResponseSchema && !shouldSkip(skipSchemaValidation, "errorResponse")) {
            transformedErrorResponse = await parseWithSchema(errorResponseSchema, transformedErrorResponse, "errorResponseSchema", meta);
          }
          return rejectWithValue(transformedErrorResponse, addShouldAutoBatch({
            baseQueryMeta: meta
          }));
        } catch (e2) {
          caughtError = e2;
        }
      }
      try {
        if (caughtError instanceof NamedSchemaError) {
          const info = {
            endpoint: arg.endpointName,
            arg: arg.originalArgs,
            type: arg.type,
            queryCacheKey: arg.type === "query" ? arg.queryCacheKey : void 0
          };
          (_d = endpointDefinition.onSchemaFailure) == null ? void 0 : _d.call(endpointDefinition, caughtError, info);
          onSchemaFailure == null ? void 0 : onSchemaFailure(caughtError, info);
          const {
            catchSchemaFailure = globalCatchSchemaFailure
          } = endpointDefinition;
          if (catchSchemaFailure) {
            return rejectWithValue(catchSchemaFailure(caughtError, info), addShouldAutoBatch({
              baseQueryMeta: caughtError._bqMeta
            }));
          }
        }
      } catch (e2) {
        caughtError = e2;
      }
      {
        console.error(caughtError);
      }
      throw caughtError;
    }
  };
  function isForcedQuery(arg, state) {
    var _a;
    const requestState = selectors.selectQueryEntry(state, arg.queryCacheKey);
    const baseFetchOnMountOrArgChange = selectors.selectConfig(state).refetchOnMountOrArgChange;
    const fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
    const refetchVal = (_a = arg.forceRefetch) != null ? _a : arg.subscribe && baseFetchOnMountOrArgChange;
    if (refetchVal) {
      return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;
    }
    return false;
  }
  const createQueryThunk = () => {
    const generatedQueryThunk = createAsyncThunk("".concat(reducerPath, "/executeQuery"), executeEndpoint, {
      getPendingMeta({
        arg
      }) {
        const endpointDefinition = endpointDefinitions[arg.endpointName];
        return addShouldAutoBatch({
          startedTimeStamp: Date.now(),
          ...isInfiniteQueryDefinition$1(endpointDefinition) ? {
            direction: arg.direction
          } : {}
        });
      },
      condition(queryThunkArg, {
        getState
      }) {
        var _a;
        const state = getState();
        const requestState = selectors.selectQueryEntry(state, queryThunkArg.queryCacheKey);
        const fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
        const currentArg = queryThunkArg.originalArgs;
        const previousArg = requestState == null ? void 0 : requestState.originalArgs;
        const endpointDefinition = endpointDefinitions[queryThunkArg.endpointName];
        const direction = queryThunkArg.direction;
        if (isUpsertQuery(queryThunkArg)) {
          return true;
        }
        if ((requestState == null ? void 0 : requestState.status) === "pending") {
          return false;
        }
        if (isForcedQuery(queryThunkArg, state)) {
          return true;
        }
        if (isQueryDefinition$1(endpointDefinition) && ((_a = endpointDefinition == null ? void 0 : endpointDefinition.forceRefetch) == null ? void 0 : _a.call(endpointDefinition, {
          currentArg,
          previousArg,
          endpointState: requestState,
          state
        }))) {
          return true;
        }
        if (fulfilledVal && !direction) {
          return false;
        }
        return true;
      },
      dispatchConditionRejection: true
    });
    return generatedQueryThunk;
  };
  const queryThunk = createQueryThunk();
  const infiniteQueryThunk = createQueryThunk();
  const mutationThunk = createAsyncThunk("".concat(reducerPath, "/executeMutation"), executeEndpoint, {
    getPendingMeta() {
      return addShouldAutoBatch({
        startedTimeStamp: Date.now()
      });
    }
  });
  const hasTheForce = (options) => "force" in options;
  const hasMaxAge = (options) => "ifOlderThan" in options;
  const prefetch = (endpointName, arg, options) => (dispatch, getState) => {
    const force = hasTheForce(options) && options.force;
    const maxAge = hasMaxAge(options) && options.ifOlderThan;
    const queryAction = (force2 = true) => {
      const options2 = {
        forceRefetch: force2,
        isPrefetch: true
      };
      return api.endpoints[endpointName].initiate(arg, options2);
    };
    const latestStateValue = api.endpoints[endpointName].select(arg)(getState());
    if (force) {
      dispatch(queryAction());
    } else if (maxAge) {
      const lastFulfilledTs = latestStateValue == null ? void 0 : latestStateValue.fulfilledTimeStamp;
      if (!lastFulfilledTs) {
        dispatch(queryAction());
        return;
      }
      const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;
      if (shouldRetrigger) {
        dispatch(queryAction());
      }
    } else {
      dispatch(queryAction(false));
    }
  };
  function matchesEndpoint(endpointName) {
    return (action) => {
      var _a, _b;
      return ((_b = (_a = action == null ? void 0 : action.meta) == null ? void 0 : _a.arg) == null ? void 0 : _b.endpointName) === endpointName;
    };
  }
  function buildMatchThunkActions(thunk2, endpointName) {
    return {
      matchPending: isAllOf(isPending(thunk2), matchesEndpoint(endpointName)),
      matchFulfilled: isAllOf(isFulfilled(thunk2), matchesEndpoint(endpointName)),
      matchRejected: isAllOf(isRejected(thunk2), matchesEndpoint(endpointName))
    };
  }
  return {
    queryThunk,
    mutationThunk,
    infiniteQueryThunk,
    prefetch,
    updateQueryData,
    upsertQueryData,
    patchQueryData,
    buildMatchThunkActions
  };
}
function getNextPageParam(options, {
  pages,
  pageParams
}, queryArg) {
  const lastIndex = pages.length - 1;
  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams, queryArg);
}
function getPreviousPageParam(options, {
  pages,
  pageParams
}, queryArg) {
  var _a;
  return (_a = options.getPreviousPageParam) == null ? void 0 : _a.call(options, pages[0], pages, pageParams[0], pageParams, queryArg);
}
function calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {
  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload : void 0, isRejectedWithValue(action) ? action.payload : void 0, action.meta.arg.originalArgs, "baseQueryMeta" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);
}
function updateQuerySubstateIfExists(state, queryCacheKey, update8) {
  const substate = state[queryCacheKey];
  if (substate) {
    update8(substate);
  }
}
function getMutationCacheKey(id) {
  var _a;
  return (_a = "arg" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) != null ? _a : id.requestId;
}
function updateMutationSubstateIfExists(state, id, update8) {
  const substate = state[getMutationCacheKey(id)];
  if (substate) {
    update8(substate);
  }
}
var initialState$3 = {};
function buildSlice({
  reducerPath,
  queryThunk,
  mutationThunk,
  serializeQueryArgs,
  context: {
    endpointDefinitions: definitions,
    apiUid,
    extractRehydrationInfo,
    hasRehydrationInfo
  },
  assertTagType,
  config
}) {
  const resetApiState = createAction("".concat(reducerPath, "/resetApiState"));
  function writePendingCacheEntry(draft, arg, upserting, meta) {
    var _a, _b;
    (_b = draft[_a = arg.queryCacheKey]) != null ? _b : draft[_a] = {
      status: "uninitialized",
      endpointName: arg.endpointName
    };
    updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {
      substate.status = "pending";
      substate.requestId = upserting && substate.requestId ? (
        // for `upsertQuery` **updates**, keep the current `requestId`
        substate.requestId
      ) : (
        // for normal queries or `upsertQuery` **inserts** always update the `requestId`
        meta.requestId
      );
      if (arg.originalArgs !== void 0) {
        substate.originalArgs = arg.originalArgs;
      }
      substate.startedTimeStamp = meta.startedTimeStamp;
      const endpointDefinition = definitions[meta.arg.endpointName];
      if (isInfiniteQueryDefinition$1(endpointDefinition) && "direction" in arg) {
        substate.direction = arg.direction;
      }
    });
  }
  function writeFulfilledCacheEntry(draft, meta, payload, upserting) {
    updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate) => {
      var _a;
      if (substate.requestId !== meta.requestId && !upserting) return;
      const {
        merge: merge2
      } = definitions[meta.arg.endpointName];
      substate.status = "fulfilled";
      if (merge2) {
        if (substate.data !== void 0) {
          const {
            fulfilledTimeStamp,
            arg,
            baseQueryMeta,
            requestId
          } = meta;
          let newData = produce(substate.data, (draftSubstateData) => {
            return merge2(draftSubstateData, payload, {
              arg: arg.originalArgs,
              baseQueryMeta,
              fulfilledTimeStamp,
              requestId
            });
          });
          substate.data = newData;
        } else {
          substate.data = payload;
        }
      } else {
        substate.data = ((_a = definitions[meta.arg.endpointName].structuralSharing) != null ? _a : true) ? copyWithStructuralSharing(isDraft(substate.data) ? original(substate.data) : substate.data, payload) : payload;
      }
      delete substate.error;
      substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
    });
  }
  const querySlice = createSlice({
    name: "".concat(reducerPath, "/queries"),
    initialState: initialState$3,
    reducers: {
      removeQueryResult: {
        reducer(draft, {
          payload: {
            queryCacheKey
          }
        }) {
          delete draft[queryCacheKey];
        },
        prepare: prepareAutoBatched()
      },
      cacheEntriesUpserted: {
        reducer(draft, action) {
          for (const entry of action.payload) {
            const {
              queryDescription: arg,
              value
            } = entry;
            writePendingCacheEntry(draft, arg, true, {
              arg,
              requestId: action.meta.requestId,
              startedTimeStamp: action.meta.timestamp
            });
            writeFulfilledCacheEntry(
              draft,
              {
                arg,
                requestId: action.meta.requestId,
                fulfilledTimeStamp: action.meta.timestamp,
                baseQueryMeta: {}
              },
              value,
              // We know we're upserting here
              true
            );
          }
        },
        prepare: (payload) => {
          const queryDescriptions = payload.map((entry) => {
            const {
              endpointName,
              arg,
              value
            } = entry;
            const endpointDefinition = definitions[endpointName];
            const queryDescription = {
              type: "query",
              endpointName,
              originalArgs: entry.arg,
              queryCacheKey: serializeQueryArgs({
                queryArgs: arg,
                endpointDefinition,
                endpointName
              })
            };
            return {
              queryDescription,
              value
            };
          });
          const result = {
            payload: queryDescriptions,
            meta: {
              [SHOULD_AUTOBATCH]: true,
              requestId: nanoid(),
              timestamp: Date.now()
            }
          };
          return result;
        }
      },
      queryResultPatched: {
        reducer(draft, {
          payload: {
            queryCacheKey,
            patches
          }
        }) {
          updateQuerySubstateIfExists(draft, queryCacheKey, (substate) => {
            substate.data = applyPatches(substate.data, patches.concat());
          });
        },
        prepare: prepareAutoBatched()
      }
    },
    extraReducers(builder) {
      builder.addCase(queryThunk.pending, (draft, {
        meta,
        meta: {
          arg
        }
      }) => {
        const upserting = isUpsertQuery(arg);
        writePendingCacheEntry(draft, arg, upserting, meta);
      }).addCase(queryThunk.fulfilled, (draft, {
        meta,
        payload
      }) => {
        const upserting = isUpsertQuery(meta.arg);
        writeFulfilledCacheEntry(draft, meta, payload, upserting);
      }).addCase(queryThunk.rejected, (draft, {
        meta: {
          condition,
          arg,
          requestId
        },
        error: error2,
        payload
      }) => {
        updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {
          if (condition) ;
          else {
            if (substate.requestId !== requestId) return;
            substate.status = "rejected";
            substate.error = payload != null ? payload : error2;
          }
        });
      }).addMatcher(hasRehydrationInfo, (draft, action) => {
        const {
          queries
        } = extractRehydrationInfo(action);
        for (const [key, entry] of Object.entries(queries)) {
          if (
            // do not rehydrate entries that were currently in flight.
            (entry == null ? void 0 : entry.status) === "fulfilled" || (entry == null ? void 0 : entry.status) === "rejected"
          ) {
            draft[key] = entry;
          }
        }
      });
    }
  });
  const mutationSlice = createSlice({
    name: "".concat(reducerPath, "/mutations"),
    initialState: initialState$3,
    reducers: {
      removeMutationResult: {
        reducer(draft, {
          payload
        }) {
          const cacheKey = getMutationCacheKey(payload);
          if (cacheKey in draft) {
            delete draft[cacheKey];
          }
        },
        prepare: prepareAutoBatched()
      }
    },
    extraReducers(builder) {
      builder.addCase(mutationThunk.pending, (draft, {
        meta,
        meta: {
          requestId,
          arg,
          startedTimeStamp
        }
      }) => {
        if (!arg.track) return;
        draft[getMutationCacheKey(meta)] = {
          requestId,
          status: "pending",
          endpointName: arg.endpointName,
          startedTimeStamp
        };
      }).addCase(mutationThunk.fulfilled, (draft, {
        payload,
        meta
      }) => {
        if (!meta.arg.track) return;
        updateMutationSubstateIfExists(draft, meta, (substate) => {
          if (substate.requestId !== meta.requestId) return;
          substate.status = "fulfilled";
          substate.data = payload;
          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
        });
      }).addCase(mutationThunk.rejected, (draft, {
        payload,
        error: error2,
        meta
      }) => {
        if (!meta.arg.track) return;
        updateMutationSubstateIfExists(draft, meta, (substate) => {
          if (substate.requestId !== meta.requestId) return;
          substate.status = "rejected";
          substate.error = payload != null ? payload : error2;
        });
      }).addMatcher(hasRehydrationInfo, (draft, action) => {
        const {
          mutations
        } = extractRehydrationInfo(action);
        for (const [key, entry] of Object.entries(mutations)) {
          if (
            // do not rehydrate entries that were currently in flight.
            ((entry == null ? void 0 : entry.status) === "fulfilled" || (entry == null ? void 0 : entry.status) === "rejected") && // only rehydrate endpoints that were persisted using a `fixedCacheKey`
            key !== (entry == null ? void 0 : entry.requestId)
          ) {
            draft[key] = entry;
          }
        }
      });
    }
  });
  const initialInvalidationState = {
    tags: {},
    keys: {}
  };
  const invalidationSlice = createSlice({
    name: "".concat(reducerPath, "/invalidation"),
    initialState: initialInvalidationState,
    reducers: {
      updateProvidedBy: {
        reducer(draft, action) {
          var _a, _b, _c, _d, _e2;
          for (const {
            queryCacheKey,
            providedTags
          } of action.payload) {
            removeCacheKeyFromTags(draft, queryCacheKey);
            for (const {
              type,
              id
            } of providedTags) {
              const subscribedQueries = (_e2 = (_c = (_b = (_a = draft.tags)[type]) != null ? _b : _a[type] = {})[_d = id || "__internal_without_id"]) != null ? _e2 : _c[_d] = [];
              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
              if (!alreadySubscribed) {
                subscribedQueries.push(queryCacheKey);
              }
            }
            draft.keys[queryCacheKey] = providedTags;
          }
        },
        prepare: prepareAutoBatched()
      }
    },
    extraReducers(builder) {
      builder.addCase(querySlice.actions.removeQueryResult, (draft, {
        payload: {
          queryCacheKey
        }
      }) => {
        removeCacheKeyFromTags(draft, queryCacheKey);
      }).addMatcher(hasRehydrationInfo, (draft, action) => {
        var _a, _b, _c, _d, _e2, _f;
        const {
          provided
        } = extractRehydrationInfo(action);
        for (const [type, incomingTags] of Object.entries((_a = provided.tags) != null ? _a : {})) {
          for (const [id, cacheKeys] of Object.entries(incomingTags)) {
            const subscribedQueries = (_f = (_d = (_c = (_b = draft.tags)[type]) != null ? _c : _b[type] = {})[_e2 = id || "__internal_without_id"]) != null ? _f : _d[_e2] = [];
            for (const queryCacheKey of cacheKeys) {
              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
              if (!alreadySubscribed) {
                subscribedQueries.push(queryCacheKey);
              }
              draft.keys[queryCacheKey] = provided.keys[queryCacheKey];
            }
          }
        }
      }).addMatcher(isAnyOf(isFulfilled(queryThunk), isRejectedWithValue(queryThunk)), (draft, action) => {
        writeProvidedTagsForQueries(draft, [action]);
      }).addMatcher(querySlice.actions.cacheEntriesUpserted.match, (draft, action) => {
        const mockActions = action.payload.map(({
          queryDescription,
          value
        }) => {
          return {
            type: "UNKNOWN",
            payload: value,
            meta: {
              requestStatus: "fulfilled",
              requestId: "UNKNOWN",
              arg: queryDescription
            }
          };
        });
        writeProvidedTagsForQueries(draft, mockActions);
      });
    }
  });
  function removeCacheKeyFromTags(draft, queryCacheKey) {
    var _a, _b, _c;
    const existingTags = (_a = draft.keys[queryCacheKey]) != null ? _a : [];
    for (const tag of existingTags) {
      const tagType = tag.type;
      const tagId = (_b = tag.id) != null ? _b : "__internal_without_id";
      const tagSubscriptions = (_c = draft.tags[tagType]) == null ? void 0 : _c[tagId];
      if (tagSubscriptions) {
        draft.tags[tagType][tagId] = tagSubscriptions.filter((qc) => qc !== queryCacheKey);
      }
    }
    delete draft.keys[queryCacheKey];
  }
  function writeProvidedTagsForQueries(draft, actions2) {
    const providedByEntries = actions2.map((action) => {
      const providedTags = calculateProvidedByThunk(action, "providesTags", definitions, assertTagType);
      const {
        queryCacheKey
      } = action.meta.arg;
      return {
        queryCacheKey,
        providedTags
      };
    });
    invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy(providedByEntries));
  }
  const subscriptionSlice = createSlice({
    name: "".concat(reducerPath, "/subscriptions"),
    initialState: initialState$3,
    reducers: {
      updateSubscriptionOptions(d2, a2) {
      },
      unsubscribeQueryResult(d2, a2) {
      },
      internal_getRTKQSubscriptions() {
      }
    }
  });
  const internalSubscriptionsSlice = createSlice({
    name: "".concat(reducerPath, "/internalSubscriptions"),
    initialState: initialState$3,
    reducers: {
      subscriptionsUpdated: {
        reducer(state, action) {
          return applyPatches(state, action.payload);
        },
        prepare: prepareAutoBatched()
      }
    }
  });
  const configSlice = createSlice({
    name: "".concat(reducerPath, "/config"),
    initialState: {
      online: isOnline(),
      focused: isDocumentVisible(),
      middlewareRegistered: false,
      ...config
    },
    reducers: {
      middlewareRegistered(state, {
        payload
      }) {
        state.middlewareRegistered = state.middlewareRegistered === "conflict" || apiUid !== payload ? "conflict" : true;
      }
    },
    extraReducers: (builder) => {
      builder.addCase(onOnline, (state) => {
        state.online = true;
      }).addCase(onOffline, (state) => {
        state.online = false;
      }).addCase(onFocus, (state) => {
        state.focused = true;
      }).addCase(onFocusLost, (state) => {
        state.focused = false;
      }).addMatcher(hasRehydrationInfo, (draft) => ({
        ...draft
      }));
    }
  });
  const combinedReducer = combineReducers({
    queries: querySlice.reducer,
    mutations: mutationSlice.reducer,
    provided: invalidationSlice.reducer,
    subscriptions: internalSubscriptionsSlice.reducer,
    config: configSlice.reducer
  });
  const reducer2 = (state, action) => combinedReducer(resetApiState.match(action) ? void 0 : state, action);
  const actions = {
    ...configSlice.actions,
    ...querySlice.actions,
    ...subscriptionSlice.actions,
    ...internalSubscriptionsSlice.actions,
    ...mutationSlice.actions,
    ...invalidationSlice.actions,
    resetApiState
  };
  return {
    reducer: reducer2,
    actions
  };
}
var skipToken = /* @__PURE__ */ Symbol.for("RTKQ/skipToken");
var initialSubState = {
  status: "uninitialized"
  /* uninitialized */
};
var defaultQuerySubState = /* @__PURE__ */ produce(initialSubState, () => {
});
var defaultMutationSubState = /* @__PURE__ */ produce(initialSubState, () => {
});
function buildSelectors({
  serializeQueryArgs,
  reducerPath,
  createSelector: createSelector2
}) {
  const selectSkippedQuery = (state) => defaultQuerySubState;
  const selectSkippedMutation = (state) => defaultMutationSubState;
  return {
    buildQuerySelector,
    buildInfiniteQuerySelector,
    buildMutationSelector,
    selectInvalidatedBy,
    selectCachedArgsForQuery,
    selectApiState,
    selectQueries,
    selectMutations,
    selectQueryEntry,
    selectConfig
  };
  function withRequestFlags(substate) {
    return {
      ...substate,
      ...getRequestStatusFlags(substate.status)
    };
  }
  function selectApiState(rootState) {
    const state = rootState[reducerPath];
    return state;
  }
  function selectQueries(rootState) {
    var _a;
    return (_a = selectApiState(rootState)) == null ? void 0 : _a.queries;
  }
  function selectQueryEntry(rootState, cacheKey) {
    var _a;
    return (_a = selectQueries(rootState)) == null ? void 0 : _a[cacheKey];
  }
  function selectMutations(rootState) {
    var _a;
    return (_a = selectApiState(rootState)) == null ? void 0 : _a.mutations;
  }
  function selectConfig(rootState) {
    var _a;
    return (_a = selectApiState(rootState)) == null ? void 0 : _a.config;
  }
  function buildAnyQuerySelector(endpointName, endpointDefinition, combiner) {
    return (queryArgs) => {
      if (queryArgs === skipToken) {
        return createSelector2(selectSkippedQuery, combiner);
      }
      const serializedArgs = serializeQueryArgs({
        queryArgs,
        endpointDefinition,
        endpointName
      });
      const selectQuerySubstate = (state) => {
        var _a;
        return (_a = selectQueryEntry(state, serializedArgs)) != null ? _a : defaultQuerySubState;
      };
      return createSelector2(selectQuerySubstate, combiner);
    };
  }
  function buildQuerySelector(endpointName, endpointDefinition) {
    return buildAnyQuerySelector(endpointName, endpointDefinition, withRequestFlags);
  }
  function buildInfiniteQuerySelector(endpointName, endpointDefinition) {
    const {
      infiniteQueryOptions
    } = endpointDefinition;
    function withInfiniteQueryResultFlags(substate) {
      const stateWithRequestFlags = {
        ...substate,
        ...getRequestStatusFlags(substate.status)
      };
      const {
        isLoading,
        isError,
        direction
      } = stateWithRequestFlags;
      const isForward = direction === "forward";
      const isBackward = direction === "backward";
      return {
        ...stateWithRequestFlags,
        hasNextPage: getHasNextPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),
        hasPreviousPage: getHasPreviousPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),
        isFetchingNextPage: isLoading && isForward,
        isFetchingPreviousPage: isLoading && isBackward,
        isFetchNextPageError: isError && isForward,
        isFetchPreviousPageError: isError && isBackward
      };
    }
    return buildAnyQuerySelector(endpointName, endpointDefinition, withInfiniteQueryResultFlags);
  }
  function buildMutationSelector() {
    return (id) => {
      var _a;
      let mutationId;
      if (typeof id === "object") {
        mutationId = (_a = getMutationCacheKey(id)) != null ? _a : skipToken;
      } else {
        mutationId = id;
      }
      const selectMutationSubstate = (state) => {
        var _a2, _b, _c;
        return (_c = (_b = (_a2 = selectApiState(state)) == null ? void 0 : _a2.mutations) == null ? void 0 : _b[mutationId]) != null ? _c : defaultMutationSubState;
      };
      const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;
      return createSelector2(finalSelectMutationSubstate, withRequestFlags);
    };
  }
  function selectInvalidatedBy(state, tags) {
    var _a;
    const apiState = state[reducerPath];
    const toInvalidate = /* @__PURE__ */ new Set();
    for (const tag of tags.filter(isNotNullish).map(expandTagDescription)) {
      const provided = apiState.provided.tags[tag.type];
      if (!provided) {
        continue;
      }
      let invalidateSubscriptions = (_a = tag.id !== void 0 ? (
        // id given: invalidate all queries that provide this type & id
        provided[tag.id]
      ) : (
        // no id: invalidate all queries that provide this type
        flatten(Object.values(provided))
      )) != null ? _a : [];
      for (const invalidate of invalidateSubscriptions) {
        toInvalidate.add(invalidate);
      }
    }
    return flatten(Array.from(toInvalidate.values()).map((queryCacheKey) => {
      const querySubState = apiState.queries[queryCacheKey];
      return querySubState ? [{
        queryCacheKey,
        endpointName: querySubState.endpointName,
        originalArgs: querySubState.originalArgs
      }] : [];
    }));
  }
  function selectCachedArgsForQuery(state, queryName) {
    return Object.values(selectQueries(state)).filter(
      (entry) => (entry == null ? void 0 : entry.endpointName) === queryName && entry.status !== "uninitialized"
      /* uninitialized */
    ).map((entry) => entry.originalArgs);
  }
  function getHasNextPage(options, data, queryArg) {
    if (!data) return false;
    return getNextPageParam(options, data, queryArg) != null;
  }
  function getHasPreviousPage(options, data, queryArg) {
    if (!data || !options.getPreviousPageParam) return false;
    return getPreviousPageParam(options, data, queryArg) != null;
  }
}
var cache$2 = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;
var defaultSerializeQueryArgs = ({
  endpointName,
  queryArgs
}) => {
  let serialized = "";
  const cached = cache$2 == null ? void 0 : cache$2.get(queryArgs);
  if (typeof cached === "string") {
    serialized = cached;
  } else {
    const stringified = JSON.stringify(queryArgs, (key, value) => {
      value = typeof value === "bigint" ? {
        $bigint: value.toString()
      } : value;
      value = isPlainObject$3(value) ? Object.keys(value).sort().reduce((acc, key2) => {
        acc[key2] = value[key2];
        return acc;
      }, {}) : value;
      return value;
    });
    if (isPlainObject$3(queryArgs)) {
      cache$2 == null ? void 0 : cache$2.set(queryArgs, stringified);
    }
    serialized = stringified;
  }
  return "".concat(endpointName, "(").concat(serialized, ")");
};
function buildCreateApi(...modules2) {
  return function baseCreateApi(options) {
    const extractRehydrationInfo = weakMapMemoize((action) => {
      var _a, _b;
      return (_b = options.extractRehydrationInfo) == null ? void 0 : _b.call(options, action, {
        reducerPath: (_a = options.reducerPath) != null ? _a : "api"
      });
    });
    const optionsWithDefaults = {
      reducerPath: "api",
      keepUnusedDataFor: 60,
      refetchOnMountOrArgChange: false,
      refetchOnFocus: false,
      refetchOnReconnect: false,
      invalidationBehavior: "delayed",
      ...options,
      extractRehydrationInfo,
      serializeQueryArgs(queryArgsApi) {
        let finalSerializeQueryArgs = defaultSerializeQueryArgs;
        if ("serializeQueryArgs" in queryArgsApi.endpointDefinition) {
          const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;
          finalSerializeQueryArgs = (queryArgsApi2) => {
            const initialResult = endpointSQA(queryArgsApi2);
            if (typeof initialResult === "string") {
              return initialResult;
            } else {
              return defaultSerializeQueryArgs({
                ...queryArgsApi2,
                queryArgs: initialResult
              });
            }
          };
        } else if (options.serializeQueryArgs) {
          finalSerializeQueryArgs = options.serializeQueryArgs;
        }
        return finalSerializeQueryArgs(queryArgsApi);
      },
      tagTypes: [...options.tagTypes || []]
    };
    const context2 = {
      endpointDefinitions: {},
      batch(fn2) {
        fn2();
      },
      apiUid: nanoid(),
      extractRehydrationInfo,
      hasRehydrationInfo: weakMapMemoize((action) => extractRehydrationInfo(action) != null)
    };
    const api = {
      injectEndpoints,
      enhanceEndpoints({
        addTagTypes,
        endpoints
      }) {
        if (addTagTypes) {
          for (const eT of addTagTypes) {
            if (!optionsWithDefaults.tagTypes.includes(eT)) {
              optionsWithDefaults.tagTypes.push(eT);
            }
          }
        }
        if (endpoints) {
          for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {
            if (typeof partialDefinition === "function") {
              partialDefinition(context2.endpointDefinitions[endpointName]);
            } else {
              Object.assign(context2.endpointDefinitions[endpointName] || {}, partialDefinition);
            }
          }
        }
        return api;
      }
    };
    const initializedModules = modules2.map((m2) => m2.init(api, optionsWithDefaults, context2));
    function injectEndpoints(inject) {
      const evaluatedEndpoints = inject.endpoints({
        query: (x2) => ({
          ...x2,
          type: "query"
          /* query */
        }),
        mutation: (x2) => ({
          ...x2,
          type: "mutation"
          /* mutation */
        }),
        infiniteQuery: (x2) => ({
          ...x2,
          type: "infinitequery"
          /* infinitequery */
        })
      });
      for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)) {
        if (inject.overrideExisting !== true && endpointName in context2.endpointDefinitions) {
          if (inject.overrideExisting === "throw") {
            throw new Error(formatProdErrorMessage(39));
          }
          continue;
        }
        context2.endpointDefinitions[endpointName] = definition;
        for (const m2 of initializedModules) {
          m2.injectEndpoint(endpointName, definition);
        }
      }
      return api;
    }
    return api.injectEndpoints({
      endpoints: options.endpoints
    });
  };
}
function safeAssign$1(target, ...args) {
  return Object.assign(target, ...args);
}
var buildBatchedActionsHandler = ({
  api,
  queryThunk,
  internalState,
  mwApi
}) => {
  const subscriptionsPrefix = "".concat(api.reducerPath, "/subscriptions");
  let previousSubscriptions = null;
  let updateSyncTimer = null;
  const {
    updateSubscriptionOptions,
    unsubscribeQueryResult
  } = api.internalActions;
  const actuallyMutateSubscriptions = (currentSubscriptions, action) => {
    var _a, _b, _c, _d;
    if (updateSubscriptionOptions.match(action)) {
      const {
        queryCacheKey,
        requestId,
        options
      } = action.payload;
      const sub = currentSubscriptions.get(queryCacheKey);
      if (sub == null ? void 0 : sub.has(requestId)) {
        sub.set(requestId, options);
      }
      return true;
    }
    if (unsubscribeQueryResult.match(action)) {
      const {
        queryCacheKey,
        requestId
      } = action.payload;
      const sub = currentSubscriptions.get(queryCacheKey);
      if (sub) {
        sub.delete(requestId);
      }
      return true;
    }
    if (api.internalActions.removeQueryResult.match(action)) {
      currentSubscriptions.delete(action.payload.queryCacheKey);
      return true;
    }
    if (queryThunk.pending.match(action)) {
      const {
        meta: {
          arg,
          requestId
        }
      } = action;
      const substate = getOrInsertComputed(currentSubscriptions, arg.queryCacheKey, createNewMap);
      if (arg.subscribe) {
        substate.set(requestId, (_b = (_a = arg.subscriptionOptions) != null ? _a : substate.get(requestId)) != null ? _b : {});
      }
      return true;
    }
    let mutated = false;
    if (queryThunk.rejected.match(action)) {
      const {
        meta: {
          condition,
          arg,
          requestId
        }
      } = action;
      if (condition && arg.subscribe) {
        const substate = getOrInsertComputed(currentSubscriptions, arg.queryCacheKey, createNewMap);
        substate.set(requestId, (_d = (_c = arg.subscriptionOptions) != null ? _c : substate.get(requestId)) != null ? _d : {});
        mutated = true;
      }
    }
    return mutated;
  };
  const getSubscriptions = () => internalState.currentSubscriptions;
  const getSubscriptionCount = (queryCacheKey) => {
    var _a;
    const subscriptions = getSubscriptions();
    const subscriptionsForQueryArg = subscriptions.get(queryCacheKey);
    return (_a = subscriptionsForQueryArg == null ? void 0 : subscriptionsForQueryArg.size) != null ? _a : 0;
  };
  const isRequestSubscribed = (queryCacheKey, requestId) => {
    var _a;
    const subscriptions = getSubscriptions();
    return !!((_a = subscriptions == null ? void 0 : subscriptions.get(queryCacheKey)) == null ? void 0 : _a.get(requestId));
  };
  const subscriptionSelectors = {
    getSubscriptions,
    getSubscriptionCount,
    isRequestSubscribed
  };
  function serializeSubscriptions(currentSubscriptions) {
    return JSON.parse(JSON.stringify(Object.fromEntries([...currentSubscriptions].map(([k2, v2]) => [k2, Object.fromEntries(v2)]))));
  }
  return (action, mwApi2) => {
    if (!previousSubscriptions) {
      previousSubscriptions = serializeSubscriptions(internalState.currentSubscriptions);
    }
    if (api.util.resetApiState.match(action)) {
      previousSubscriptions = {};
      internalState.currentSubscriptions.clear();
      updateSyncTimer = null;
      return [true, false];
    }
    if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {
      return [false, subscriptionSelectors];
    }
    const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);
    let actionShouldContinue = true;
    if (didMutate) {
      if (!updateSyncTimer) {
        updateSyncTimer = setTimeout(() => {
          const newSubscriptions = serializeSubscriptions(internalState.currentSubscriptions);
          const [, patches] = produceWithPatches(previousSubscriptions, () => newSubscriptions);
          mwApi2.next(api.internalActions.subscriptionsUpdated(patches));
          previousSubscriptions = newSubscriptions;
          updateSyncTimer = null;
        }, 500);
      }
      const isSubscriptionSliceAction = typeof action.type == "string" && !!action.type.startsWith(subscriptionsPrefix);
      const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;
      actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;
    }
    return [actionShouldContinue, false];
  };
};
var THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;
var buildCacheCollectionHandler = ({
  reducerPath,
  api,
  queryThunk,
  context: context2,
  internalState,
  selectors: {
    selectQueryEntry,
    selectConfig
  },
  getRunningQueryThunk,
  mwApi
}) => {
  const {
    removeQueryResult,
    unsubscribeQueryResult,
    cacheEntriesUpserted
  } = api.internalActions;
  const runningQueries = internalState.runningQueries.get(mwApi.dispatch);
  const canTriggerUnsubscribe = isAnyOf(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected, cacheEntriesUpserted.match);
  function anySubscriptionsRemainingForKey(queryCacheKey) {
    const subscriptions = internalState.currentSubscriptions.get(queryCacheKey);
    if (!subscriptions) {
      return false;
    }
    const hasSubscriptions = subscriptions.size > 0;
    const isRunning = (runningQueries == null ? void 0 : runningQueries[queryCacheKey]) !== void 0;
    return hasSubscriptions || isRunning;
  }
  const currentRemovalTimeouts = {};
  const handler = (action, mwApi2, internalState2) => {
    const state = mwApi2.getState();
    const config = selectConfig(state);
    if (canTriggerUnsubscribe(action)) {
      let queryCacheKeys;
      if (cacheEntriesUpserted.match(action)) {
        queryCacheKeys = action.payload.map((entry) => entry.queryDescription.queryCacheKey);
      } else {
        const {
          queryCacheKey
        } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;
        queryCacheKeys = [queryCacheKey];
      }
      handleUnsubscribeMany(queryCacheKeys, mwApi2, config);
    }
    if (api.util.resetApiState.match(action)) {
      for (const [key, timeout] of Object.entries(currentRemovalTimeouts)) {
        if (timeout) clearTimeout(timeout);
        delete currentRemovalTimeouts[key];
      }
    }
    if (context2.hasRehydrationInfo(action)) {
      const {
        queries
      } = context2.extractRehydrationInfo(action);
      handleUnsubscribeMany(Object.keys(queries), mwApi2, config);
    }
  };
  function handleUnsubscribeMany(cacheKeys, api2, config) {
    const state = api2.getState();
    for (const queryCacheKey of cacheKeys) {
      const entry = selectQueryEntry(state, queryCacheKey);
      if (entry == null ? void 0 : entry.endpointName) {
        handleUnsubscribe(queryCacheKey, entry.endpointName, api2, config);
      }
    }
  }
  function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {
    var _a;
    const endpointDefinition = context2.endpointDefinitions[endpointName];
    const keepUnusedDataFor = (_a = endpointDefinition == null ? void 0 : endpointDefinition.keepUnusedDataFor) != null ? _a : config.keepUnusedDataFor;
    if (keepUnusedDataFor === Infinity) {
      return;
    }
    const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));
    if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
      const currentTimeout = currentRemovalTimeouts[queryCacheKey];
      if (currentTimeout) {
        clearTimeout(currentTimeout);
      }
      currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {
        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
          const entry = selectQueryEntry(api2.getState(), queryCacheKey);
          if (entry == null ? void 0 : entry.endpointName) {
            const runningQuery = api2.dispatch(getRunningQueryThunk(entry.endpointName, entry.originalArgs));
            runningQuery == null ? void 0 : runningQuery.abort();
          }
          api2.dispatch(removeQueryResult({
            queryCacheKey
          }));
        }
        delete currentRemovalTimeouts[queryCacheKey];
      }, finalKeepUnusedDataFor * 1e3);
    }
  }
  return handler;
};
var neverResolvedError = new Error("Promise never resolved before cacheEntryRemoved.");
var buildCacheLifecycleHandler = ({
  api,
  reducerPath,
  context: context2,
  queryThunk,
  mutationThunk,
  internalState,
  selectors: {
    selectQueryEntry,
    selectApiState
  }
}) => {
  const isQueryThunk = isAsyncThunkAction(queryThunk);
  const isMutationThunk = isAsyncThunkAction(mutationThunk);
  const isFulfilledThunk = isFulfilled(queryThunk, mutationThunk);
  const lifecycleMap = {};
  function resolveLifecycleEntry(cacheKey, data, meta) {
    const lifecycle = lifecycleMap[cacheKey];
    if (lifecycle == null ? void 0 : lifecycle.valueResolved) {
      lifecycle.valueResolved({
        data,
        meta
      });
      delete lifecycle.valueResolved;
    }
  }
  function removeLifecycleEntry(cacheKey) {
    const lifecycle = lifecycleMap[cacheKey];
    if (lifecycle) {
      delete lifecycleMap[cacheKey];
      lifecycle.cacheEntryRemoved();
    }
  }
  const handler = (action, mwApi, stateBefore) => {
    const cacheKey = getCacheKey(action);
    function checkForNewCacheKey(endpointName, cacheKey2, requestId, originalArgs) {
      const oldEntry = selectQueryEntry(stateBefore, cacheKey2);
      const newEntry = selectQueryEntry(mwApi.getState(), cacheKey2);
      if (!oldEntry && newEntry) {
        handleNewKey(endpointName, originalArgs, cacheKey2, mwApi, requestId);
      }
    }
    if (queryThunk.pending.match(action)) {
      checkForNewCacheKey(action.meta.arg.endpointName, cacheKey, action.meta.requestId, action.meta.arg.originalArgs);
    } else if (api.internalActions.cacheEntriesUpserted.match(action)) {
      for (const {
        queryDescription,
        value
      } of action.payload) {
        const {
          endpointName,
          originalArgs,
          queryCacheKey
        } = queryDescription;
        checkForNewCacheKey(endpointName, queryCacheKey, action.meta.requestId, originalArgs);
        resolveLifecycleEntry(queryCacheKey, value, {});
      }
    } else if (mutationThunk.pending.match(action)) {
      const state = mwApi.getState()[reducerPath].mutations[cacheKey];
      if (state) {
        handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
      }
    } else if (isFulfilledThunk(action)) {
      resolveLifecycleEntry(cacheKey, action.payload, action.meta.baseQueryMeta);
    } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {
      removeLifecycleEntry(cacheKey);
    } else if (api.util.resetApiState.match(action)) {
      for (const cacheKey2 of Object.keys(lifecycleMap)) {
        removeLifecycleEntry(cacheKey2);
      }
    }
  };
  function getCacheKey(action) {
    var _a;
    if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;
    if (isMutationThunk(action)) {
      return (_a = action.meta.arg.fixedCacheKey) != null ? _a : action.meta.requestId;
    }
    if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;
    if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);
    return "";
  }
  function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {
    const endpointDefinition = context2.endpointDefinitions[endpointName];
    const onCacheEntryAdded = endpointDefinition == null ? void 0 : endpointDefinition.onCacheEntryAdded;
    if (!onCacheEntryAdded) return;
    const lifecycle = {};
    const cacheEntryRemoved = new Promise((resolve) => {
      lifecycle.cacheEntryRemoved = resolve;
    });
    const cacheDataLoaded = Promise.race([new Promise((resolve) => {
      lifecycle.valueResolved = resolve;
    }), cacheEntryRemoved.then(() => {
      throw neverResolvedError;
    })]);
    cacheDataLoaded.catch(() => {
    });
    lifecycleMap[queryCacheKey] = lifecycle;
    const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : queryCacheKey);
    const extra = mwApi.dispatch((_23, __, extra2) => extra2);
    const lifecycleApi = {
      ...mwApi,
      getCacheEntry: () => selector(mwApi.getState()),
      requestId,
      extra,
      updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
      cacheDataLoaded,
      cacheEntryRemoved
    };
    const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);
    Promise.resolve(runningHandler).catch((e2) => {
      if (e2 === neverResolvedError) return;
      throw e2;
    });
  }
  return handler;
};
var buildDevCheckHandler = ({
  api,
  context: {
    apiUid
  },
  reducerPath
}) => {
  return (action, mwApi) => {
    if (api.util.resetApiState.match(action)) {
      mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
    }
  };
};
var buildInvalidationByTagsHandler = ({
  reducerPath,
  context: context2,
  context: {
    endpointDefinitions
  },
  mutationThunk,
  queryThunk,
  api,
  assertTagType,
  refetchQuery,
  internalState
}) => {
  const {
    removeQueryResult
  } = api.internalActions;
  const isThunkActionWithTags = isAnyOf(isFulfilled(mutationThunk), isRejectedWithValue(mutationThunk));
  const isQueryEnd = isAnyOf(isFulfilled(mutationThunk, queryThunk), isRejected(mutationThunk, queryThunk));
  let pendingTagInvalidations = [];
  const handler = (action, mwApi) => {
    if (isThunkActionWithTags(action)) {
      invalidateTags(calculateProvidedByThunk(action, "invalidatesTags", endpointDefinitions, assertTagType), mwApi);
    } else if (isQueryEnd(action)) {
      invalidateTags([], mwApi);
    } else if (api.util.invalidateTags.match(action)) {
      invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);
    }
  };
  function hasPendingRequests(state) {
    var _a;
    const {
      queries,
      mutations
    } = state;
    for (const cacheRecord of [queries, mutations]) {
      for (const key in cacheRecord) {
        if (((_a = cacheRecord[key]) == null ? void 0 : _a.status) === "pending") return true;
      }
    }
    return false;
  }
  function invalidateTags(newTags, mwApi) {
    const rootState = mwApi.getState();
    const state = rootState[reducerPath];
    pendingTagInvalidations.push(...newTags);
    if (state.config.invalidationBehavior === "delayed" && hasPendingRequests(state)) {
      return;
    }
    const tags = pendingTagInvalidations;
    pendingTagInvalidations = [];
    if (tags.length === 0) return;
    const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);
    context2.batch(() => {
      const valuesArray = Array.from(toInvalidate.values());
      for (const {
        queryCacheKey
      } of valuesArray) {
        const querySubState = state.queries[queryCacheKey];
        const subscriptionSubState = getOrInsertComputed(internalState.currentSubscriptions, queryCacheKey, createNewMap);
        if (querySubState) {
          if (subscriptionSubState.size === 0) {
            mwApi.dispatch(removeQueryResult({
              queryCacheKey
            }));
          } else if (querySubState.status !== "uninitialized") {
            mwApi.dispatch(refetchQuery(querySubState));
          }
        }
      }
    });
  }
  return handler;
};
var buildPollingHandler = ({
  reducerPath,
  queryThunk,
  api,
  refetchQuery,
  internalState
}) => {
  const {
    currentPolls,
    currentSubscriptions
  } = internalState;
  const pendingPollingUpdates = /* @__PURE__ */ new Set();
  let pollingUpdateTimer = null;
  const handler = (action, mwApi) => {
    if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {
      schedulePollingUpdate(action.payload.queryCacheKey, mwApi);
    }
    if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {
      schedulePollingUpdate(action.meta.arg.queryCacheKey, mwApi);
    }
    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {
      startNextPoll(action.meta.arg, mwApi);
    }
    if (api.util.resetApiState.match(action)) {
      clearPolls();
      if (pollingUpdateTimer) {
        clearTimeout(pollingUpdateTimer);
        pollingUpdateTimer = null;
      }
      pendingPollingUpdates.clear();
    }
  };
  function schedulePollingUpdate(queryCacheKey, api2) {
    pendingPollingUpdates.add(queryCacheKey);
    if (!pollingUpdateTimer) {
      pollingUpdateTimer = setTimeout(() => {
        for (const key of pendingPollingUpdates) {
          updatePollingInterval({
            queryCacheKey: key
          }, api2);
        }
        pendingPollingUpdates.clear();
        pollingUpdateTimer = null;
      }, 0);
    }
  }
  function startNextPoll({
    queryCacheKey
  }, api2) {
    const state = api2.getState()[reducerPath];
    const querySubState = state.queries[queryCacheKey];
    const subscriptions = currentSubscriptions.get(queryCacheKey);
    if (!querySubState || querySubState.status === "uninitialized") return;
    const {
      lowestPollingInterval,
      skipPollingIfUnfocused
    } = findLowestPollingInterval(subscriptions);
    if (!Number.isFinite(lowestPollingInterval)) return;
    const currentPoll = currentPolls.get(queryCacheKey);
    if (currentPoll == null ? void 0 : currentPoll.timeout) {
      clearTimeout(currentPoll.timeout);
      currentPoll.timeout = void 0;
    }
    const nextPollTimestamp = Date.now() + lowestPollingInterval;
    currentPolls.set(queryCacheKey, {
      nextPollTimestamp,
      pollingInterval: lowestPollingInterval,
      timeout: setTimeout(() => {
        if (state.config.focused || !skipPollingIfUnfocused) {
          api2.dispatch(refetchQuery(querySubState));
        }
        startNextPoll({
          queryCacheKey
        }, api2);
      }, lowestPollingInterval)
    });
  }
  function updatePollingInterval({
    queryCacheKey
  }, api2) {
    const state = api2.getState()[reducerPath];
    const querySubState = state.queries[queryCacheKey];
    const subscriptions = currentSubscriptions.get(queryCacheKey);
    if (!querySubState || querySubState.status === "uninitialized") {
      return;
    }
    const {
      lowestPollingInterval
    } = findLowestPollingInterval(subscriptions);
    if (!Number.isFinite(lowestPollingInterval)) {
      cleanupPollForKey(queryCacheKey);
      return;
    }
    const currentPoll = currentPolls.get(queryCacheKey);
    const nextPollTimestamp = Date.now() + lowestPollingInterval;
    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
      startNextPoll({
        queryCacheKey
      }, api2);
    }
  }
  function cleanupPollForKey(key) {
    const existingPoll = currentPolls.get(key);
    if (existingPoll == null ? void 0 : existingPoll.timeout) {
      clearTimeout(existingPoll.timeout);
    }
    currentPolls.delete(key);
  }
  function clearPolls() {
    for (const key of currentPolls.keys()) {
      cleanupPollForKey(key);
    }
  }
  function findLowestPollingInterval(subscribers = /* @__PURE__ */ new Map()) {
    let skipPollingIfUnfocused = false;
    let lowestPollingInterval = Number.POSITIVE_INFINITY;
    for (const entry of subscribers.values()) {
      if (!!entry.pollingInterval) {
        lowestPollingInterval = Math.min(entry.pollingInterval, lowestPollingInterval);
        skipPollingIfUnfocused = entry.skipPollingIfUnfocused || skipPollingIfUnfocused;
      }
    }
    return {
      lowestPollingInterval,
      skipPollingIfUnfocused
    };
  }
  return handler;
};
var buildQueryLifecycleHandler = ({
  api,
  context: context2,
  queryThunk,
  mutationThunk
}) => {
  const isPendingThunk = isPending(queryThunk, mutationThunk);
  const isRejectedThunk = isRejected(queryThunk, mutationThunk);
  const isFullfilledThunk = isFulfilled(queryThunk, mutationThunk);
  const lifecycleMap = {};
  const handler = (action, mwApi) => {
    var _a, _b, _c;
    if (isPendingThunk(action)) {
      const {
        requestId,
        arg: {
          endpointName,
          originalArgs
        }
      } = action.meta;
      const endpointDefinition = context2.endpointDefinitions[endpointName];
      const onQueryStarted = endpointDefinition == null ? void 0 : endpointDefinition.onQueryStarted;
      if (onQueryStarted) {
        const lifecycle = {};
        const queryFulfilled = new Promise((resolve, reject) => {
          lifecycle.resolve = resolve;
          lifecycle.reject = reject;
        });
        queryFulfilled.catch(() => {
        });
        lifecycleMap[requestId] = lifecycle;
        const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : requestId);
        const extra = mwApi.dispatch((_23, __, extra2) => extra2);
        const lifecycleApi = {
          ...mwApi,
          getCacheEntry: () => selector(mwApi.getState()),
          requestId,
          extra,
          updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
          queryFulfilled
        };
        onQueryStarted(originalArgs, lifecycleApi);
      }
    } else if (isFullfilledThunk(action)) {
      const {
        requestId,
        baseQueryMeta
      } = action.meta;
      (_a = lifecycleMap[requestId]) == null ? void 0 : _a.resolve({
        data: action.payload,
        meta: baseQueryMeta
      });
      delete lifecycleMap[requestId];
    } else if (isRejectedThunk(action)) {
      const {
        requestId,
        rejectedWithValue,
        baseQueryMeta
      } = action.meta;
      (_c = lifecycleMap[requestId]) == null ? void 0 : _c.reject({
        error: (_b = action.payload) != null ? _b : action.error,
        isUnhandledError: !rejectedWithValue,
        meta: baseQueryMeta
      });
      delete lifecycleMap[requestId];
    }
  };
  return handler;
};
var buildWindowEventHandler = ({
  reducerPath,
  context: context2,
  api,
  refetchQuery,
  internalState
}) => {
  const {
    removeQueryResult
  } = api.internalActions;
  const handler = (action, mwApi) => {
    if (onFocus.match(action)) {
      refetchValidQueries(mwApi, "refetchOnFocus");
    }
    if (onOnline.match(action)) {
      refetchValidQueries(mwApi, "refetchOnReconnect");
    }
  };
  function refetchValidQueries(api2, type) {
    const state = api2.getState()[reducerPath];
    const queries = state.queries;
    const subscriptions = internalState.currentSubscriptions;
    context2.batch(() => {
      for (const queryCacheKey of subscriptions.keys()) {
        const querySubState = queries[queryCacheKey];
        const subscriptionSubState = subscriptions.get(queryCacheKey);
        if (!subscriptionSubState || !querySubState) continue;
        const values2 = [...subscriptionSubState.values()];
        const shouldRefetch = values2.some((sub) => sub[type] === true) || values2.every((sub) => sub[type] === void 0) && state.config[type];
        if (shouldRefetch) {
          if (subscriptionSubState.size === 0) {
            api2.dispatch(removeQueryResult({
              queryCacheKey
            }));
          } else if (querySubState.status !== "uninitialized") {
            api2.dispatch(refetchQuery(querySubState));
          }
        }
      }
    });
  }
  return handler;
};
function buildMiddleware(input) {
  const {
    reducerPath,
    queryThunk,
    api,
    context: context2,
    internalState
  } = input;
  const {
    apiUid
  } = context2;
  const actions = {
    invalidateTags: createAction("".concat(reducerPath, "/invalidateTags"))
  };
  const isThisApiSliceAction = (action) => action.type.startsWith("".concat(reducerPath, "/"));
  const handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];
  const middleware = (mwApi) => {
    let initialized2 = false;
    const builderArgs = {
      ...input,
      internalState,
      refetchQuery,
      isThisApiSliceAction,
      mwApi
    };
    const handlers2 = handlerBuilders.map((build2) => build2(builderArgs));
    const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);
    const windowEventsHandler = buildWindowEventHandler(builderArgs);
    return (next) => {
      return (action) => {
        if (!isAction(action)) {
          return next(action);
        }
        if (!initialized2) {
          initialized2 = true;
          mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
        }
        const mwApiWithNext = {
          ...mwApi,
          next
        };
        const stateBefore = mwApi.getState();
        const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);
        let res;
        if (actionShouldContinue) {
          res = next(action);
        } else {
          res = internalProbeResult;
        }
        if (!!mwApi.getState()[reducerPath]) {
          windowEventsHandler(action, mwApiWithNext, stateBefore);
          if (isThisApiSliceAction(action) || context2.hasRehydrationInfo(action)) {
            for (const handler of handlers2) {
              handler(action, mwApiWithNext, stateBefore);
            }
          }
        }
        return res;
      };
    };
  };
  return {
    middleware,
    actions
  };
  function refetchQuery(querySubState) {
    return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs, {
      subscribe: false,
      forceRefetch: true
    });
  }
}
var coreModuleName = /* @__PURE__ */ Symbol();
var coreModule = ({
  createSelector: createSelector2 = createSelector
} = {}) => ({
  name: coreModuleName,
  init(api, {
    baseQuery,
    tagTypes,
    reducerPath,
    serializeQueryArgs,
    keepUnusedDataFor,
    refetchOnMountOrArgChange,
    refetchOnFocus,
    refetchOnReconnect,
    invalidationBehavior,
    onSchemaFailure,
    catchSchemaFailure,
    skipSchemaValidation
  }, context2) {
    enablePatches();
    const assertTagType = (tag) => {
      return tag;
    };
    Object.assign(api, {
      reducerPath,
      endpoints: {},
      internalActions: {
        onOnline,
        onOffline,
        onFocus,
        onFocusLost
      },
      util: {}
    });
    const selectors = buildSelectors({
      serializeQueryArgs,
      reducerPath,
      createSelector: createSelector2
    });
    const {
      selectInvalidatedBy,
      selectCachedArgsForQuery,
      buildQuerySelector,
      buildInfiniteQuerySelector,
      buildMutationSelector
    } = selectors;
    safeAssign$1(api.util, {
      selectInvalidatedBy,
      selectCachedArgsForQuery
    });
    const {
      queryThunk,
      infiniteQueryThunk,
      mutationThunk,
      patchQueryData,
      updateQueryData,
      upsertQueryData,
      prefetch,
      buildMatchThunkActions
    } = buildThunks({
      baseQuery,
      reducerPath,
      context: context2,
      api,
      serializeQueryArgs,
      assertTagType,
      selectors,
      onSchemaFailure,
      catchSchemaFailure,
      skipSchemaValidation
    });
    const {
      reducer: reducer2,
      actions: sliceActions
    } = buildSlice({
      context: context2,
      queryThunk,
      mutationThunk,
      serializeQueryArgs,
      reducerPath,
      assertTagType,
      config: {
        refetchOnFocus,
        refetchOnReconnect,
        refetchOnMountOrArgChange,
        keepUnusedDataFor,
        reducerPath,
        invalidationBehavior
      }
    });
    safeAssign$1(api.util, {
      patchQueryData,
      updateQueryData,
      upsertQueryData,
      prefetch,
      resetApiState: sliceActions.resetApiState,
      upsertQueryEntries: sliceActions.cacheEntriesUpserted
    });
    safeAssign$1(api.internalActions, sliceActions);
    const internalState = {
      currentSubscriptions: /* @__PURE__ */ new Map(),
      currentPolls: /* @__PURE__ */ new Map(),
      runningQueries: /* @__PURE__ */ new Map(),
      runningMutations: /* @__PURE__ */ new Map()
    };
    const {
      buildInitiateQuery,
      buildInitiateInfiniteQuery,
      buildInitiateMutation,
      getRunningMutationThunk,
      getRunningMutationsThunk,
      getRunningQueriesThunk,
      getRunningQueryThunk
    } = buildInitiate({
      queryThunk,
      mutationThunk,
      infiniteQueryThunk,
      api,
      serializeQueryArgs,
      context: context2,
      internalState
    });
    safeAssign$1(api.util, {
      getRunningMutationThunk,
      getRunningMutationsThunk,
      getRunningQueryThunk,
      getRunningQueriesThunk
    });
    const {
      middleware,
      actions: middlewareActions
    } = buildMiddleware({
      reducerPath,
      context: context2,
      queryThunk,
      mutationThunk,
      infiniteQueryThunk,
      api,
      assertTagType,
      selectors,
      getRunningQueryThunk,
      internalState
    });
    safeAssign$1(api.util, middlewareActions);
    safeAssign$1(api, {
      reducer: reducer2,
      middleware
    });
    return {
      name: coreModuleName,
      injectEndpoint(endpointName, definition) {
        var _a, _b;
        const anyApi = api;
        const endpoint = (_b = (_a = anyApi.endpoints)[endpointName]) != null ? _b : _a[endpointName] = {};
        if (isQueryDefinition$1(definition)) {
          safeAssign$1(endpoint, {
            name: endpointName,
            select: buildQuerySelector(endpointName, definition),
            initiate: buildInitiateQuery(endpointName, definition)
          }, buildMatchThunkActions(queryThunk, endpointName));
        }
        if (isMutationDefinition$1(definition)) {
          safeAssign$1(endpoint, {
            name: endpointName,
            select: buildMutationSelector(),
            initiate: buildInitiateMutation(endpointName)
          }, buildMatchThunkActions(mutationThunk, endpointName));
        }
        if (isInfiniteQueryDefinition$1(definition)) {
          safeAssign$1(endpoint, {
            name: endpointName,
            select: buildInfiniteQuerySelector(endpointName, definition),
            initiate: buildInitiateInfiniteQuery(endpointName, definition)
          }, buildMatchThunkActions(queryThunk, endpointName));
        }
      }
    };
  }
});
/* @__PURE__ */ buildCreateApi(coreModule());
function capitalize(str) {
  return str.replace(str[0], str[0].toUpperCase());
}
function isQueryDefinition(e2) {
  return e2.type === "query";
}
function isMutationDefinition(e2) {
  return e2.type === "mutation";
}
function isInfiniteQueryDefinition(e2) {
  return e2.type === "infinitequery";
}
function safeAssign(target, ...args) {
  return Object.assign(target, ...args);
}
var UNINITIALIZED_VALUE = Symbol();
function useStableQueryArgs(queryArgs) {
  const cache2 = reactExports.useRef(queryArgs);
  const copy2 = reactExports.useMemo(() => copyWithStructuralSharing(cache2.current, queryArgs), [queryArgs]);
  reactExports.useEffect(() => {
    if (cache2.current !== copy2) {
      cache2.current = copy2;
    }
  }, [copy2]);
  return copy2;
}
function useShallowStableValue(value) {
  const cache2 = reactExports.useRef(value);
  reactExports.useEffect(() => {
    if (!shallowEqual(cache2.current, value)) {
      cache2.current = value;
    }
  }, [value]);
  return shallowEqual(cache2.current, value) ? cache2.current : value;
}
var canUseDOM$2 = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM$2();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? reactExports.useLayoutEffect : reactExports.useEffect;
var useIsomorphicLayoutEffect$2 = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
var noPendingQueryStateSelector = (selected) => {
  if (selected.isUninitialized) {
    return {
      ...selected,
      isUninitialized: false,
      isFetching: true,
      isLoading: selected.data !== void 0 ? false : true,
      status: QueryStatus.pending
    };
  }
  return selected;
};
function pick(obj, ...keys2) {
  const ret = {};
  keys2.forEach((key) => {
    ret[key] = obj[key];
  });
  return ret;
}
var COMMON_HOOK_DEBUG_FIELDS = ["data", "status", "isLoading", "isSuccess", "isError", "error"];
function buildHooks({
  api,
  moduleOptions: {
    batch: batch2,
    hooks: {
      useDispatch: useDispatch2,
      useSelector: useSelector2,
      useStore: useStore2
    },
    unstable__sideEffectsInRender,
    createSelector: createSelector2
  },
  serializeQueryArgs,
  context: context2
}) {
  const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? (cb) => cb() : reactExports.useEffect;
  return {
    buildQueryHooks,
    buildInfiniteQueryHooks,
    buildMutationHook,
    usePrefetch
  };
  function queryStatePreSelector(currentState, lastResult, queryArgs) {
    if ((lastResult == null ? void 0 : lastResult.endpointName) && currentState.isUninitialized) {
      const {
        endpointName
      } = lastResult;
      const endpointDefinition = context2.endpointDefinitions[endpointName];
      if (queryArgs !== skipToken && serializeQueryArgs({
        queryArgs: lastResult.originalArgs,
        endpointDefinition,
        endpointName
      }) === serializeQueryArgs({
        queryArgs,
        endpointDefinition,
        endpointName
      })) lastResult = void 0;
    }
    let data = currentState.isSuccess ? currentState.data : lastResult == null ? void 0 : lastResult.data;
    if (data === void 0) data = currentState.data;
    const hasData = data !== void 0;
    const isFetching = currentState.isLoading;
    const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;
    const isSuccess = currentState.isSuccess || hasData && (isFetching && !(lastResult == null ? void 0 : lastResult.isError) || currentState.isUninitialized);
    return {
      ...currentState,
      data,
      currentData: currentState.data,
      isFetching,
      isLoading,
      isSuccess
    };
  }
  function infiniteQueryStatePreSelector(currentState, lastResult, queryArgs) {
    if ((lastResult == null ? void 0 : lastResult.endpointName) && currentState.isUninitialized) {
      const {
        endpointName
      } = lastResult;
      const endpointDefinition = context2.endpointDefinitions[endpointName];
      if (queryArgs !== skipToken && serializeQueryArgs({
        queryArgs: lastResult.originalArgs,
        endpointDefinition,
        endpointName
      }) === serializeQueryArgs({
        queryArgs,
        endpointDefinition,
        endpointName
      })) lastResult = void 0;
    }
    let data = currentState.isSuccess ? currentState.data : lastResult == null ? void 0 : lastResult.data;
    if (data === void 0) data = currentState.data;
    const hasData = data !== void 0;
    const isFetching = currentState.isLoading;
    const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;
    const isSuccess = currentState.isSuccess || isFetching && hasData;
    return {
      ...currentState,
      data,
      currentData: currentState.data,
      isFetching,
      isLoading,
      isSuccess
    };
  }
  function usePrefetch(endpointName, defaultOptions2) {
    const dispatch = useDispatch2();
    const stableDefaultOptions = useShallowStableValue(defaultOptions2);
    return reactExports.useCallback((arg, options) => dispatch(api.util.prefetch(endpointName, arg, {
      ...stableDefaultOptions,
      ...options
    })), [endpointName, dispatch, stableDefaultOptions]);
  }
  function useQuerySubscriptionCommonImpl(endpointName, arg, {
    refetchOnReconnect,
    refetchOnFocus,
    refetchOnMountOrArgChange,
    skip: skip2 = false,
    pollingInterval = 0,
    skipPollingIfUnfocused = false,
    ...rest2
  } = {}) {
    const {
      initiate
    } = api.endpoints[endpointName];
    const dispatch = useDispatch2();
    const subscriptionSelectorsRef = reactExports.useRef(void 0);
    if (!subscriptionSelectorsRef.current) {
      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());
      subscriptionSelectorsRef.current = returnedValue;
    }
    const stableArg = useStableQueryArgs(skip2 ? skipToken : arg);
    const stableSubscriptionOptions = useShallowStableValue({
      refetchOnReconnect,
      refetchOnFocus,
      pollingInterval,
      skipPollingIfUnfocused
    });
    const initialPageParam = rest2.initialPageParam;
    const stableInitialPageParam = useShallowStableValue(initialPageParam);
    const promiseRef = reactExports.useRef(void 0);
    let {
      queryCacheKey,
      requestId
    } = promiseRef.current || {};
    let currentRenderHasSubscription = false;
    if (queryCacheKey && requestId) {
      currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);
    }
    const subscriptionRemoved = !currentRenderHasSubscription && promiseRef.current !== void 0;
    usePossiblyImmediateEffect(() => {
      if (subscriptionRemoved) {
        promiseRef.current = void 0;
      }
    }, [subscriptionRemoved]);
    usePossiblyImmediateEffect(() => {
      var _a;
      const lastPromise = promiseRef.current;
      if (stableArg === skipToken) {
        lastPromise == null ? void 0 : lastPromise.unsubscribe();
        promiseRef.current = void 0;
        return;
      }
      const lastSubscriptionOptions = (_a = promiseRef.current) == null ? void 0 : _a.subscriptionOptions;
      if (!lastPromise || lastPromise.arg !== stableArg) {
        lastPromise == null ? void 0 : lastPromise.unsubscribe();
        const promise = dispatch(initiate(stableArg, {
          subscriptionOptions: stableSubscriptionOptions,
          forceRefetch: refetchOnMountOrArgChange,
          ...isInfiniteQueryDefinition(context2.endpointDefinitions[endpointName]) ? {
            initialPageParam: stableInitialPageParam
          } : {}
        }));
        promiseRef.current = promise;
      } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {
        lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);
      }
    }, [dispatch, initiate, refetchOnMountOrArgChange, stableArg, stableSubscriptionOptions, subscriptionRemoved, stableInitialPageParam, endpointName]);
    return [promiseRef, dispatch, initiate, stableSubscriptionOptions];
  }
  function buildUseQueryState(endpointName, preSelector) {
    const useQueryState = (arg, {
      skip: skip2 = false,
      selectFromResult
    } = {}) => {
      const {
        select
      } = api.endpoints[endpointName];
      const stableArg = useStableQueryArgs(skip2 ? skipToken : arg);
      const lastValue = reactExports.useRef(void 0);
      const selectDefaultResult = reactExports.useMemo(() => (
        // Normally ts-ignores are bad and should be avoided, but we're
        // already casting this selector to be `Selector<any>` anyway,
        // so the inconsistencies don't matter here
        // @ts-ignore
        createSelector2([
          // @ts-ignore
          select(stableArg),
          (_23, lastResult) => lastResult,
          (_23) => stableArg
        ], preSelector, {
          memoizeOptions: {
            resultEqualityCheck: shallowEqual
          }
        })
      ), [select, stableArg]);
      const querySelector = reactExports.useMemo(() => selectFromResult ? createSelector2([selectDefaultResult], selectFromResult, {
        devModeChecks: {
          identityFunctionCheck: "never"
        }
      }) : selectDefaultResult, [selectDefaultResult, selectFromResult]);
      const currentState = useSelector2((state) => querySelector(state, lastValue.current), shallowEqual);
      const store = useStore2();
      const newLastValue = selectDefaultResult(store.getState(), lastValue.current);
      useIsomorphicLayoutEffect$2(() => {
        lastValue.current = newLastValue;
      }, [newLastValue]);
      return currentState;
    };
    return useQueryState;
  }
  function usePromiseRefUnsubscribeOnUnmount(promiseRef) {
    reactExports.useEffect(() => {
      return () => {
        var _a, _b;
        (_b = (_a = promiseRef.current) == null ? void 0 : _a.unsubscribe) == null ? void 0 : _b.call(_a);
        promiseRef.current = void 0;
      };
    }, [promiseRef]);
  }
  function refetchOrErrorIfUnmounted(promiseRef) {
    if (!promiseRef.current) throw new Error(formatProdErrorMessage(38));
    return promiseRef.current.refetch();
  }
  function buildQueryHooks(endpointName) {
    const useQuerySubscription = (arg, options = {}) => {
      const [promiseRef] = useQuerySubscriptionCommonImpl(endpointName, arg, options);
      usePromiseRefUnsubscribeOnUnmount(promiseRef);
      return reactExports.useMemo(() => ({
        /**
         * A method to manually refetch data for the query
         */
        refetch: () => refetchOrErrorIfUnmounted(promiseRef)
      }), [promiseRef]);
    };
    const useLazyQuerySubscription = ({
      refetchOnReconnect,
      refetchOnFocus,
      pollingInterval = 0,
      skipPollingIfUnfocused = false
    } = {}) => {
      const {
        initiate
      } = api.endpoints[endpointName];
      const dispatch = useDispatch2();
      const [arg, setArg] = reactExports.useState(UNINITIALIZED_VALUE);
      const promiseRef = reactExports.useRef(void 0);
      const stableSubscriptionOptions = useShallowStableValue({
        refetchOnReconnect,
        refetchOnFocus,
        pollingInterval,
        skipPollingIfUnfocused
      });
      usePossiblyImmediateEffect(() => {
        var _a, _b;
        const lastSubscriptionOptions = (_a = promiseRef.current) == null ? void 0 : _a.subscriptionOptions;
        if (stableSubscriptionOptions !== lastSubscriptionOptions) {
          (_b = promiseRef.current) == null ? void 0 : _b.updateSubscriptionOptions(stableSubscriptionOptions);
        }
      }, [stableSubscriptionOptions]);
      const subscriptionOptionsRef = reactExports.useRef(stableSubscriptionOptions);
      usePossiblyImmediateEffect(() => {
        subscriptionOptionsRef.current = stableSubscriptionOptions;
      }, [stableSubscriptionOptions]);
      const trigger = reactExports.useCallback(function(arg2, preferCacheValue = false) {
        let promise;
        batch2(() => {
          var _a;
          (_a = promiseRef.current) == null ? void 0 : _a.unsubscribe();
          promiseRef.current = promise = dispatch(initiate(arg2, {
            subscriptionOptions: subscriptionOptionsRef.current,
            forceRefetch: !preferCacheValue
          }));
          setArg(arg2);
        });
        return promise;
      }, [dispatch, initiate]);
      const reset2 = reactExports.useCallback(() => {
        var _a, _b;
        if ((_a = promiseRef.current) == null ? void 0 : _a.queryCacheKey) {
          dispatch(api.internalActions.removeQueryResult({
            queryCacheKey: (_b = promiseRef.current) == null ? void 0 : _b.queryCacheKey
          }));
        }
      }, [dispatch]);
      reactExports.useEffect(() => {
        return () => {
          var _a;
          (_a = promiseRef == null ? void 0 : promiseRef.current) == null ? void 0 : _a.unsubscribe();
        };
      }, []);
      reactExports.useEffect(() => {
        if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {
          trigger(arg, true);
        }
      }, [arg, trigger]);
      return reactExports.useMemo(() => [trigger, arg, {
        reset: reset2
      }], [trigger, arg, reset2]);
    };
    const useQueryState = buildUseQueryState(endpointName, queryStatePreSelector);
    return {
      useQueryState,
      useQuerySubscription,
      useLazyQuerySubscription,
      useLazyQuery(options) {
        const [trigger, arg, {
          reset: reset2
        }] = useLazyQuerySubscription(options);
        const queryStateResults = useQueryState(arg, {
          ...options,
          skip: arg === UNINITIALIZED_VALUE
        });
        const info = reactExports.useMemo(() => ({
          lastArg: arg
        }), [arg]);
        return reactExports.useMemo(() => [trigger, {
          ...queryStateResults,
          reset: reset2
        }, info], [trigger, queryStateResults, reset2, info]);
      },
      useQuery(arg, options) {
        const querySubscriptionResults = useQuerySubscription(arg, options);
        const queryStateResults = useQueryState(arg, {
          selectFromResult: arg === skipToken || (options == null ? void 0 : options.skip) ? void 0 : noPendingQueryStateSelector,
          ...options
        });
        const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS);
        reactExports.useDebugValue(debugValue);
        return reactExports.useMemo(() => ({
          ...queryStateResults,
          ...querySubscriptionResults
        }), [queryStateResults, querySubscriptionResults]);
      }
    };
  }
  function buildInfiniteQueryHooks(endpointName) {
    const useInfiniteQuerySubscription = (arg, options = {}) => {
      const [promiseRef, dispatch, initiate, stableSubscriptionOptions] = useQuerySubscriptionCommonImpl(endpointName, arg, options);
      const subscriptionOptionsRef = reactExports.useRef(stableSubscriptionOptions);
      usePossiblyImmediateEffect(() => {
        subscriptionOptionsRef.current = stableSubscriptionOptions;
      }, [stableSubscriptionOptions]);
      const trigger = reactExports.useCallback(function(arg2, direction) {
        let promise;
        batch2(() => {
          var _a;
          (_a = promiseRef.current) == null ? void 0 : _a.unsubscribe();
          promiseRef.current = promise = dispatch(initiate(arg2, {
            subscriptionOptions: subscriptionOptionsRef.current,
            direction
          }));
        });
        return promise;
      }, [promiseRef, dispatch, initiate]);
      usePromiseRefUnsubscribeOnUnmount(promiseRef);
      const stableArg = useStableQueryArgs(options.skip ? skipToken : arg);
      const refetch = reactExports.useCallback(() => refetchOrErrorIfUnmounted(promiseRef), [promiseRef]);
      return reactExports.useMemo(() => {
        const fetchNextPage = () => {
          return trigger(stableArg, "forward");
        };
        const fetchPreviousPage = () => {
          return trigger(stableArg, "backward");
        };
        return {
          trigger,
          /**
           * A method to manually refetch data for the query
           */
          refetch,
          fetchNextPage,
          fetchPreviousPage
        };
      }, [refetch, trigger, stableArg]);
    };
    const useInfiniteQueryState = buildUseQueryState(endpointName, infiniteQueryStatePreSelector);
    return {
      useInfiniteQueryState,
      useInfiniteQuerySubscription,
      useInfiniteQuery(arg, options) {
        const {
          refetch,
          fetchNextPage,
          fetchPreviousPage
        } = useInfiniteQuerySubscription(arg, options);
        const queryStateResults = useInfiniteQueryState(arg, {
          selectFromResult: arg === skipToken || (options == null ? void 0 : options.skip) ? void 0 : noPendingQueryStateSelector,
          ...options
        });
        const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS, "hasNextPage", "hasPreviousPage");
        reactExports.useDebugValue(debugValue);
        return reactExports.useMemo(() => ({
          ...queryStateResults,
          fetchNextPage,
          fetchPreviousPage,
          refetch
        }), [queryStateResults, fetchNextPage, fetchPreviousPage, refetch]);
      }
    };
  }
  function buildMutationHook(name) {
    return ({
      selectFromResult,
      fixedCacheKey
    } = {}) => {
      const {
        select,
        initiate
      } = api.endpoints[name];
      const dispatch = useDispatch2();
      const [promise, setPromise] = reactExports.useState();
      reactExports.useEffect(() => () => {
        if (!(promise == null ? void 0 : promise.arg.fixedCacheKey)) {
          promise == null ? void 0 : promise.reset();
        }
      }, [promise]);
      const triggerMutation = reactExports.useCallback(function(arg) {
        const promise2 = dispatch(initiate(arg, {
          fixedCacheKey
        }));
        setPromise(promise2);
        return promise2;
      }, [dispatch, initiate, fixedCacheKey]);
      const {
        requestId
      } = promise || {};
      const selectDefaultResult = reactExports.useMemo(() => select({
        fixedCacheKey,
        requestId: promise == null ? void 0 : promise.requestId
      }), [fixedCacheKey, promise, select]);
      const mutationSelector = reactExports.useMemo(() => selectFromResult ? createSelector2([selectDefaultResult], selectFromResult) : selectDefaultResult, [selectFromResult, selectDefaultResult]);
      const currentState = useSelector2(mutationSelector, shallowEqual);
      const originalArgs = fixedCacheKey == null ? promise == null ? void 0 : promise.arg.originalArgs : void 0;
      const reset2 = reactExports.useCallback(() => {
        batch2(() => {
          if (promise) {
            setPromise(void 0);
          }
          if (fixedCacheKey) {
            dispatch(api.internalActions.removeMutationResult({
              requestId,
              fixedCacheKey
            }));
          }
        });
      }, [dispatch, fixedCacheKey, promise, requestId]);
      const debugValue = pick(currentState, ...COMMON_HOOK_DEBUG_FIELDS, "endpointName");
      reactExports.useDebugValue(debugValue);
      const finalState = reactExports.useMemo(() => ({
        ...currentState,
        originalArgs,
        reset: reset2
      }), [currentState, originalArgs, reset2]);
      return reactExports.useMemo(() => [triggerMutation, finalState], [triggerMutation, finalState]);
    };
  }
}
var reactHooksModuleName = /* @__PURE__ */ Symbol();
var reactHooksModule = ({
  batch: batch2 = reactDomExports.unstable_batchedUpdates,
  hooks = {
    useDispatch,
    useSelector,
    useStore
  },
  createSelector: createSelector$1 = createSelector,
  unstable__sideEffectsInRender = false,
  ...rest2
} = {}) => {
  return {
    name: reactHooksModuleName,
    init(api, {
      serializeQueryArgs
    }, context2) {
      const anyApi = api;
      const {
        buildQueryHooks,
        buildInfiniteQueryHooks,
        buildMutationHook,
        usePrefetch
      } = buildHooks({
        api,
        moduleOptions: {
          batch: batch2,
          hooks,
          unstable__sideEffectsInRender,
          createSelector: createSelector$1
        },
        serializeQueryArgs,
        context: context2
      });
      safeAssign(anyApi, {
        usePrefetch
      });
      safeAssign(context2, {
        batch: batch2
      });
      return {
        injectEndpoint(endpointName, definition) {
          if (isQueryDefinition(definition)) {
            const {
              useQuery,
              useLazyQuery,
              useLazyQuerySubscription,
              useQueryState,
              useQuerySubscription
            } = buildQueryHooks(endpointName);
            safeAssign(anyApi.endpoints[endpointName], {
              useQuery,
              useLazyQuery,
              useLazyQuerySubscription,
              useQueryState,
              useQuerySubscription
            });
            api["use".concat(capitalize(endpointName), "Query")] = useQuery;
            api["useLazy".concat(capitalize(endpointName), "Query")] = useLazyQuery;
          }
          if (isMutationDefinition(definition)) {
            const useMutation = buildMutationHook(endpointName);
            safeAssign(anyApi.endpoints[endpointName], {
              useMutation
            });
            api["use".concat(capitalize(endpointName), "Mutation")] = useMutation;
          } else if (isInfiniteQueryDefinition(definition)) {
            const {
              useInfiniteQuery,
              useInfiniteQuerySubscription,
              useInfiniteQueryState
            } = buildInfiniteQueryHooks(endpointName);
            safeAssign(anyApi.endpoints[endpointName], {
              useInfiniteQuery,
              useInfiniteQuerySubscription,
              useInfiniteQueryState
            });
            api["use".concat(capitalize(endpointName), "InfiniteQuery")] = useInfiniteQuery;
          }
        }
      };
    }
  };
};
var createApi = /* @__PURE__ */ buildCreateApi(coreModule(), reactHooksModule());
const version$1 = "3.7.8";
const VERSION = version$1;
const _hasBuffer = typeof Buffer === "function";
const _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
const _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
const b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64chs = Array.prototype.slice.call(b64ch);
const b64tab = ((a2) => {
  let tab = {};
  a2.forEach((c2, i2) => tab[c2] = i2);
  return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
const _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
const _tidyB64 = (s2) => s2.replace(/[^A-Za-z0-9\+\/]/g, "");
const btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i2 = 0; i2 < bin.length; ) {
    if ((c0 = bin.charCodeAt(i2++)) > 255 || (c1 = bin.charCodeAt(i2++)) > 255 || (c2 = bin.charCodeAt(i2++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
const _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
const _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i2 = 0, l2 = u8a.length; i2 < l2; i2 += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i2, i2 + maxargs)));
  }
  return _btoa(strs.join(""));
};
const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
const cb_utob = (c2) => {
  if (c2.length < 2) {
    var cc = c2.charCodeAt(0);
    return cc < 128 ? c2 : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c2.charCodeAt(0) - 55296) * 1024 + (c2.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
const utob = (u2) => u2.replace(re_utob, cb_utob);
const _encode = _hasBuffer ? (s2) => Buffer.from(s2, "utf8").toString("base64") : _TE ? (s2) => _fromUint8Array(_TE.encode(s2)) : (s2) => _btoa(utob(s2));
const encode$1 = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
const encodeURI$1 = (src) => encode$1(src, true);
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
const btou = (b2) => b2.replace(re_btou, cb_btou);
const atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, r1, r2;
  let binArray = [];
  for (let i2 = 0; i2 < asc.length; ) {
    u24 = b64tab[asc.charAt(i2++)] << 18 | b64tab[asc.charAt(i2++)] << 12 | (r1 = b64tab[asc.charAt(i2++)]) << 6 | (r2 = b64tab[asc.charAt(i2++)]);
    if (r1 === 64) {
      binArray.push(_fromCC(u24 >> 16 & 255));
    } else if (r2 === 64) {
      binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255));
    } else {
      binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255));
    }
  }
  return binArray.join("");
};
const _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
const _toUint8Array = _hasBuffer ? (a2) => _U8Afrom(Buffer.from(a2, "base64")) : (a2) => _U8Afrom(_atob(a2).split("").map((c2) => c2.charCodeAt(0)));
const toUint8Array = (a2) => _toUint8Array(_unURI(a2));
const _decode = _hasBuffer ? (a2) => Buffer.from(a2, "base64").toString("utf8") : _TD ? (a2) => _TD.decode(_toUint8Array(a2)) : (a2) => btou(_atob(a2));
const _unURI = (a2) => _tidyB64(a2.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
const decode$1 = (src) => _decode(_unURI(src));
const isValid$1 = (src) => {
  if (typeof src !== "string")
    return false;
  const s2 = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s2) || !/[^\s0-9a-zA-Z\-_]/.test(s2);
};
const _noEnum = (v2) => {
  return {
    value: v2,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
const extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode$1(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode$1(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode$1(this, true);
  });
  _add("toBase64URL", function() {
    return encode$1(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
const extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
const extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
const gBase64 = {
  version: version$1,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode$1,
  toBase64: encode$1,
  encode: encode$1,
  encodeURI: encodeURI$1,
  encodeURL: encodeURI$1,
  utob,
  btou,
  decode: decode$1,
  isValid: isValid$1,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};
var lodash$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports;
var hasRequiredLodash;
function requireLodash() {
  if (hasRequiredLodash) return lodash$1.exports;
  hasRequiredLodash = 1;
  (function(module, exports) {
    (function() {
      var undefined$1;
      var VERSION2 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "c",
        "": "D",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "N",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "Y",
        "": "y",
        "": "y",
        "": "Ae",
        "": "ae",
        "": "Th",
        "": "th",
        "": "ss",
        // Latin Extended-A block.
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "D",
        "": "D",
        "": "d",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "H",
        "": "H",
        "": "h",
        "": "h",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "J",
        "": "j",
        "": "K",
        "": "k",
        "": "k",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "R",
        "": "R",
        "": "R",
        "": "r",
        "": "r",
        "": "r",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "T",
        "": "T",
        "": "T",
        "": "t",
        "": "t",
        "": "t",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "W",
        "": "w",
        "": "Y",
        "": "y",
        "": "Y",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "z",
        "": "z",
        "": "z",
        "": "IJ",
        "": "ij",
        "": "Oe",
        "": "oe",
        "": "'n",
        "": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = exports && !exports.nodeType && exports;
      var freeModule = freeExports && true && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = (function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      })();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array2, setter, iteratee, accumulator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          var value = array2[index];
          setter(accumulator, value, iteratee(value), array2);
        }
        return accumulator;
      }
      function arrayEach(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (iteratee(array2[index], index, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEachRight(array2, iteratee) {
        var length = array2 == null ? 0 : array2.length;
        while (length--) {
          if (iteratee(array2[length], length, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEvery(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (!predicate(array2[index], index, array2)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array2, value) {
        var length = array2 == null ? 0 : array2.length;
        return !!length && baseIndexOf(array2, value, 0) > -1;
      }
      function arrayIncludesWith(array2, value, comparator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (comparator(value, array2[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      function arrayPush(array2, values2) {
        var index = -1, length = values2.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values2[index];
        }
        return array2;
      }
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
        var length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array2[length], length, array2);
        }
        return accumulator;
      }
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string2) {
        return string2.split("");
      }
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array2, predicate, fromIndex, fromRight) {
        var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array2[index], index, array2)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array2, value, fromIndex) {
        return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array2, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (comparator(array2[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array2, iteratee) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseSum(array2, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? undefined$1 : object2[key];
        };
      }
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? undefined$1 : object2[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array2, comparer) {
        var length = array2.length;
        array2.sort(comparer);
        while (length--) {
          array2[length] = array2[length].value;
        }
        return array2;
      }
      function baseSum(array2, iteratee) {
        var result, index = -1, length = array2.length;
        while (++index < length) {
          var current2 = iteratee(array2[index]);
          if (current2 !== undefined$1) {
            result = result === undefined$1 ? current2 : result + current2;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index = -1, result = Array(n2);
        while (++index < n2) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object2, props) {
        return arrayMap(props, function(key) {
          return [key, object2[key]];
        });
      }
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object2, props) {
        return arrayMap(props, function(key) {
          return object2[key];
        });
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array2, placeholder) {
        var length = array2.length, result = 0;
        while (length--) {
          if (array2[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue2(object2, key) {
        return object2 == null ? undefined$1 : object2[key];
      }
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map3) {
        var index = -1, result = Array(map3.size);
        map3.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array2, placeholder) {
        var index = -1, length = array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array2[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set3) {
        var index = -1, result = Array(set3.size);
        set3.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set3) {
        var index = -1, result = Array(set3.size);
        set3.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array2, value, fromIndex) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (array2[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array2, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array2[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string2) {
        return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string2) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string2)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      var runInContext = (function runInContext2(context2) {
        context2 = context2 == null ? root : _23.defaults(root.Object(), context2, _23.pick(root, contextProps));
        var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context2["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = (function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        })();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString2 = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context2.Buffer : undefined$1, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice2 = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
        var defineProperty = (function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e2) {
          }
        })();
        var ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString2 = symbolProto ? symbolProto.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ (function() {
          function object2() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object2.prototype = proto;
            var result2 = new object2();
            object2.prototype = undefined$1;
            return result2;
          };
        })();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array2, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array2[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries3) {
          var index = -1, length = entries3 == null ? 0 : entries3.length;
          this.clear();
          while (++index < length) {
            var entry = entries3[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries3) {
          var index = -1, length = entries3 == null ? 0 : entries3.length;
          this.clear();
          while (++index < length) {
            var entry = entries3[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice2.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined$1 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries3) {
          var index = -1, length = entries3 == null ? 0 : entries3.length;
          this.clear();
          while (++index < length) {
            var entry = entries3[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values22) {
          var index = -1, length = values22 == null ? 0 : values22.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values22[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack2(entries3) {
          var data = this.__data__ = new ListCache(entries3);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack2.prototype.clear = stackClear;
        Stack2.prototype["delete"] = stackDelete;
        Stack2.prototype.get = stackGet;
        Stack2.prototype.has = stackHas;
        Stack2.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array2) {
          var length = array2.length;
          return length ? array2[baseRandom(0, length - 1)] : undefined$1;
        }
        function arraySampleSize(array2, n2) {
          return shuffleSelf(copyArray(array2), baseClamp(n2, 0, array2.length));
        }
        function arrayShuffle(array2) {
          return shuffleSelf(copyArray(array2));
        }
        function assignMergeValue(object2, key, value) {
          if (value !== undefined$1 && !eq(object2[key], value) || value === undefined$1 && !(key in object2)) {
            baseAssignValue(object2, key, value);
          }
        }
        function assignValue(object2, key, value) {
          var objValue = object2[key];
          if (!(hasOwnProperty2.call(object2, key) && eq(objValue, value)) || value === undefined$1 && !(key in object2)) {
            baseAssignValue(object2, key, value);
          }
        }
        function assocIndexOf(array2, key) {
          var length = array2.length;
          while (length--) {
            if (eq(array2[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object2, source) {
          return object2 && copyObject(source, keys2(source), object2);
        }
        function baseAssignIn(object2, source) {
          return object2 && copyObject(source, keysIn(source), object2);
        }
        function baseAssignValue(object2, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object2, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object2[key] = value;
          }
        }
        function baseAt(object2, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip2 = object2 == null;
          while (++index < length) {
            result2[index] = skip2 ? undefined$1 : get11(object2, paths[index]);
          }
          return result2;
        }
        function baseClamp(number2, lower, upper) {
          if (number2 === number2) {
            if (upper !== undefined$1) {
              number2 = number2 <= upper ? number2 : upper;
            }
            if (lower !== undefined$1) {
              number2 = number2 >= lower ? number2 : lower;
            }
          }
          return number2;
        }
        function baseClone(value, bitmask, customizer, key, object2, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object2 ? customizer(value, key, object2, stack) : customizer(value);
          }
          if (result2 !== undefined$1) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object2) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object2 ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack2());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet2(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap2(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys2(source);
          return function(object2) {
            return baseConformsTo(object2, source, props);
          };
        }
        function baseConformsTo(object2, source, props) {
          var length = props.length;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (length--) {
            var key = props[length], predicate = source[key], value = object2[key];
            if (value === undefined$1 && !(key in object2) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined$1, args);
          }, wait);
        }
        function baseDifference(array2, values22, iteratee2, comparator) {
          var index = -1, includes22 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values22.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values22 = arrayMap(values22, baseUnary(iteratee2));
          }
          if (comparator) {
            includes22 = arrayIncludesWith;
            isCommon = false;
          } else if (values22.length >= LARGE_ARRAY_SIZE) {
            includes22 = cacheHas;
            isCommon = false;
            values22 = new SetCache(values22);
          }
          outer:
            while (++index < length) {
              var value = array2[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values22[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes22(values22, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array2, iteratee2, comparator) {
          var index = -1, length = array2.length;
          while (++index < length) {
            var value = array2[index], current2 = iteratee2(value);
            if (current2 != null && (computed === undefined$1 ? current2 === current2 && !isSymbol(current2) : comparator(current2, computed))) {
              var computed = current2, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array2, value, start, end) {
          var length = array2.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined$1 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array2[start++] = value;
          }
          return array2;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array2, depth, predicate, isStrict, result2) {
          var index = -1, length = array2.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array2[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object2, iteratee2) {
          return object2 && baseFor(object2, iteratee2, keys2);
        }
        function baseForOwnRight(object2, iteratee2) {
          return object2 && baseForRight(object2, iteratee2, keys2);
        }
        function baseFunctions(object2, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object2[key]);
          });
        }
        function baseGet2(object2, path2) {
          path2 = castPath(path2, object2);
          var index = 0, length = path2.length;
          while (object2 != null && index < length) {
            object2 = object2[toKey(path2[index++])];
          }
          return index && index == length ? object2 : undefined$1;
        }
        function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object2);
          return isArray(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object2, key) {
          return object2 != null && hasOwnProperty2.call(object2, key);
        }
        function baseHasIn(object2, key) {
          return object2 != null && key in Object2(object2);
        }
        function baseInRange(number2, start, end) {
          return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes22 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array2 = arrays[othIndex];
            if (othIndex && iteratee2) {
              array2 = arrayMap(array2, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array2.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined$1;
          }
          array2 = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes22(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache2 = caches[othIndex];
                  if (!(cache2 ? cacheHas(cache2, computed) : includes22(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object2, setter, iteratee2, accumulator) {
          baseForOwn(object2, function(value, key, object22) {
            setter(accumulator, iteratee2(value), key, object22);
          });
          return accumulator;
        }
        function baseInvoke(object2, path2, args) {
          path2 = castPath(path2, object2);
          object2 = parent(object2, path2);
          var func = object2 == null ? object2 : object2[toKey(last3(path2))];
          return func == null ? undefined$1 : apply(func, object2, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object2)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack2());
            return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack2());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack2());
          return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object2, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object2[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object2)) {
                return false;
              }
            } else {
              var stack = new Stack2();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object2, source, stack);
              }
              if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object2) {
          if (!isPrototype(object2)) {
            return nativeKeys(object2);
          }
          var result2 = [];
          for (var key in Object2(object2)) {
            if (hasOwnProperty2.call(object2, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object2) {
          if (!isObject2(object2)) {
            return nativeKeysIn(object2);
          }
          var isProto = isPrototype(object2), result2 = [];
          for (var key in object2) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object2, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object2) {
            return object2 === source || baseIsMatch(object2, source, matchData);
          };
        }
        function baseMatchesProperty(path2, srcValue) {
          if (isKey2(path2) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path2), srcValue);
          }
          return function(object2) {
            var objValue = get11(object2, path2);
            return objValue === undefined$1 && objValue === srcValue ? hasIn2(object2, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object2, source, srcIndex, customizer, stack) {
          if (object2 === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack2());
            if (isObject2(srcValue)) {
              baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : undefined$1;
              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object2, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object2, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : undefined$1;
          var isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject3(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object2, key, newValue);
        }
        function baseNth(array2, n2) {
          var length = array2.length;
          if (!length) {
            return;
          }
          n2 += n2 < 0 ? length : 0;
          return isIndex(n2, length) ? array2[n2] : undefined$1;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet2(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object2, other) {
            return compareMultiple(object2, other, orders);
          });
        }
        function basePick(object2, paths) {
          return basePickBy(object2, paths, function(value, path2) {
            return hasIn2(object2, path2);
          });
        }
        function basePickBy(object2, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path2 = paths[index], value = baseGet2(object2, path2);
            if (predicate(value, path2)) {
              baseSet(result2, castPath(path2, object2), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path2) {
          return function(object2) {
            return baseGet2(object2, path2);
          };
        }
        function basePullAll(array2, values22, iteratee2, comparator) {
          var indexOf22 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values22.length, seen = array2;
          if (array2 === values22) {
            values22 = copyArray(values22);
          }
          if (iteratee2) {
            seen = arrayMap(array2, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values22[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf22(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array2) {
                splice2.call(seen, fromIndex, 1);
              }
              splice2.call(array2, fromIndex, 1);
            }
          }
          return array2;
        }
        function basePullAt(array2, indexes) {
          var length = array2 ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice2.call(array2, index, 1);
              } else {
                baseUnset(array2, index);
              }
            }
          }
          return array2;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string2, n2) {
          var result2 = "";
          if (!string2 || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string2;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string2 += string2;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values2(collection));
        }
        function baseSampleSize(collection, n2) {
          var array2 = values2(collection);
          return shuffleSelf(array2, baseClamp(n2, 0, array2.length));
        }
        function baseSet(object2, path2, value, customizer) {
          if (!isObject2(object2)) {
            return object2;
          }
          path2 = castPath(path2, object2);
          var index = -1, length = path2.length, lastIndex = length - 1, nested = object2;
          while (nested != null && ++index < length) {
            var key = toKey(path2[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object2;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject2(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object2;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string2) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string2),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values2(collection));
        }
        function baseSlice(array2, start, end) {
          var index = -1, length = array2.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array2[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array2, value, retHighest) {
          var low = 0, high = array2 == null ? low : array2.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array2[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array2, value, identity, retHighest);
        }
        function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
          var low = 0, high = array2 == null ? 0 : array2.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array2, iteratee2) {
          var index = -1, length = array2.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString2 ? symbolToString2.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array2, iteratee2, comparator) {
          var index = -1, includes22 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes22 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set22 = iteratee2 ? null : createSet(array2);
            if (set22) {
              return setToArray(set22);
            }
            isCommon = false;
            includes22 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes22(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object2, path2) {
          path2 = castPath(path2, object2);
          object2 = parent(object2, path2);
          return object2 == null || delete object2[toKey(last3(path2))];
        }
        function baseUpdate(object2, path2, updater, customizer) {
          return baseSet(object2, path2, updater(baseGet2(object2, path2)), customizer);
        }
        function baseWhile(array2, predicate, isDrop, fromRight) {
          var length = array2.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array2[index], index, array2)) {
          }
          return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array2 = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values22, assignFunc) {
          var index = -1, length = props.length, valsLength = values22.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values22[index] : undefined$1;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object2) {
          if (isArray(value)) {
            return value;
          }
          return isKey2(value, object2) ? [value] : stringToPath2(toString5(value));
        }
        var castRest = baseRest;
        function castSlice(array2, start, end) {
          var length = array2.length;
          end = end === undefined$1 ? length : end;
          return !start && end >= length ? array2 : baseSlice(array2, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object2, other, orders) {
          var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object2.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array2) {
          var index = -1, length = source.length;
          array2 || (array2 = Array2(length));
          while (++index < length) {
            array2[index] = source[index];
          }
          return array2;
        }
        function copyObject(source, props, object2, customizer) {
          var isNew = !object2;
          object2 || (object2 = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : undefined$1;
            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object2, key, newValue);
            } else {
              assignValue(object2, key, newValue);
            }
          }
          return object2;
        }
        function copySymbols(source, object2) {
          return copyObject(source, getSymbols(source), object2);
        }
        function copySymbolsIn(source, object2) {
          return copyObject(source, getSymbolsIn(source), object2);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object2, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer;
              length = 1;
            }
            object2 = Object2(object2);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object2, source, index, customizer);
              }
            }
            return object2;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike2(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object2, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object2), props = keysFunc(object2), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object2;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn2.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string2) {
            string2 = toString5(string2);
            var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined$1;
            var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string2) {
            return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length
              );
            }
            var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn2, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike2(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys2(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData3(func) : undefined$1;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn2 = Ctor || createCtor(fn2);
            }
            return fn2.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object2, iteratee2) {
            return baseInverter(object2, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue2) {
          return function(value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue2;
            }
            if (value !== undefined$1) {
              result2 = value;
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars2) {
          chars2 = chars2 === undefined$1 ? " " : baseToString(chars2);
          var charsLength = chars2.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars2, length) : chars2;
          }
          var result2 = baseRepeat(chars2, nativeCeil(length / stringSize(chars2)));
          return hasUnicode(chars2) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn2, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber2(value);
              other = toNumber2(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= -4;
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData3(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number2, precision) {
            number2 = toNumber2(number2);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number2)) {
              var pair = (toString5(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString5(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number2);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values22) {
          return new Set2(values22);
        };
        function createToPairs(keysFunc) {
          return function(object2) {
            var tag = getTag(object2);
            if (tag == mapTag) {
              return mapToArray(object2);
            }
            if (tag == setTag) {
              return setToPairs(object2);
            }
            return baseToPairs(object2, keysFunc(object2));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= -97;
            partials = holders = undefined$1;
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData3(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= -25;
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData3;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object2) {
          if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object2, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject3(value) ? undefined$1 : value;
        }
        function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array2);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array2;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          stack.set(array2, other);
          stack.set(other, array2);
          while (++index < arrLength) {
            var arrValue = array2[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array2);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                return false;
              }
              object2 = object2.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object2, +other);
            case errorTag:
              return object2.name == other.name && object2.message == other.message;
            case regexpTag:
            case stringTag:
              return object2 == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object2.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object2);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object2, other);
              var result2 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object2);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object2) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object2);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object2;
          }
          var result2 = true;
          stack.set(object2, other);
          stack.set(other, object2);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object2[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
            }
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object2.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object2);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten4), func + "");
        }
        function getAllKeys(object2) {
          return baseGetAllKeys(object2, keys2, getSymbols);
        }
        function getAllKeysIn(object2) {
          return baseGetAllKeys(object2, keysIn, getSymbolsIn);
        }
        var getData3 = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array2.length : 0;
          while (length--) {
            var data = array2[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object2 = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
          return object2.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map22, key) {
          var data = map22.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object2) {
          var result2 = keys2(object2), length = result2.length;
          while (length--) {
            var key = result2[length], value = object2[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object2, key) {
          var value = getValue2(object2, key);
          return baseIsNative(value) ? value : undefined$1;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e2) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
          if (object2 == null) {
            return [];
          }
          object2 = Object2(object2);
          return arrayFilter(nativeGetSymbols(object2), function(symbol) {
            return propertyIsEnumerable.call(object2, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
          var result2 = [];
          while (object2) {
            arrayPush(result2, getSymbols(object2));
            object2 = getPrototype(object2);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match2 = source.match(reWrapDetails);
          return match2 ? match2[1].split(reSplitDetails) : [];
        }
        function hasPath(object2, path2, hasFunc) {
          path2 = castPath(path2, object2);
          var index = -1, length = path2.length, result2 = false;
          while (++index < length) {
            var key = toKey(path2[index]);
            if (!(result2 = object2 != null && hasFunc(object2, key))) {
              break;
            }
            object2 = object2[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object2 == null ? 0 : object2.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));
        }
        function initCloneArray(array2) {
          var length = array2.length, result2 = new array2.constructor(length);
          if (length && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
            result2.index = array2.index;
            result2.input = array2.input;
          }
          return result2;
        }
        function initCloneObject(object2) {
          return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
        }
        function initCloneByTag(object2, tag, isDeep) {
          var Ctor = object2.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object2);
            case boolTag:
            case dateTag:
              return new Ctor(+object2);
            case dataViewTag:
              return cloneDataView(object2, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object2, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object2);
            case regexpTag:
              return cloneRegExp(object2);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object2);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object2) {
          if (!isObject2(object2)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike2(object2) && isIndex(index, object2.length) : type == "string" && index in object2) {
            return eq(object2[index], value);
          }
          return false;
        }
        function isKey2(value, object2) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData3(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object2) {
            if (object2 == null) {
              return false;
            }
            return object2[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object2));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache2.size === MAX_MEMOIZE_SIZE) {
              cache2.clear();
            }
            return key;
          });
          var cache2 = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object2) {
          var result2 = [];
          if (object2 != null) {
            for (var key in Object2(object2)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array2(length);
            while (++index < length) {
              array2[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array2);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object2, path2) {
          return path2.length < 2 ? object2 : baseGet2(object2, baseSlice(path2, 0, -1));
        }
        function reorder(array2, indexes) {
          var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
          while (length--) {
            var index = indexes[length];
            array2[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array2;
        }
        function safeGet(object2, key) {
          if (key === "constructor" && typeof object2[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object2[key];
        }
        var setData3 = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count2 = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count2 >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count2 = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array2, size2) {
          var index = -1, length = array2.length, lastIndex = length - 1;
          size2 = size2 === undefined$1 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array2[rand];
            array2[rand] = array2[index];
            array2[index] = value;
          }
          array2.length = size2;
          return array2;
        }
        var stringToPath2 = memoizeCapped(function(string2) {
          var result2 = [];
          if (string2.charCodeAt(0) === 46) {
            result2.push("");
          }
          string2.replace(rePropName, function(match2, number2, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e2) {
            }
            try {
              return func + "";
            } catch (e2) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array2, size2, guard) {
          if (guard ? isIterateeCall(array2, size2, guard) : size2 === undefined$1) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array2 == null ? 0 : array2.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array2, index, index += size2);
          }
          return result2;
        }
        function compact2(array2) {
          var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array2[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat2() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array2 = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array2, values22) {
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values22, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array2, values22) {
          var iteratee2 = last3(values22);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values22, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array2, values22) {
          var comparator = last3(values22);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values22, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
        });
        function drop(array2, n2, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          return baseSlice(array2, n2 < 0 ? 0 : n2, length);
        }
        function dropRight(array2, n2, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array2, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
        }
        function fill(array2, value, start, end) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array2, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array2, value, start, end);
        }
        function findIndex3(array2, predicate, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index);
        }
        function findLastIndex2(array2, predicate, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index, true);
        }
        function flatten4(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseFlatten(array2, 1) : [];
        }
        function flattenDeep(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseFlatten(array2, INFINITY) : [];
        }
        function flattenDepth(array2, depth) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array2, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array2) {
          return array2 && array2.length ? array2[0] : undefined$1;
        }
        function indexOf2(array2, value, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array2, value, index);
        }
        function initial(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSlice(array2, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last3(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last3(mapped)) {
            iteratee2 = undefined$1;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last3(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join2(array2, separator) {
          return array2 == null ? "" : nativeJoin.call(array2, separator);
        }
        function last3(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? array2[length - 1] : undefined$1;
        }
        function lastIndexOf2(array2, value, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, true);
        }
        function nth(array2, n2) {
          return array2 && array2.length ? baseNth(array2, toInteger(n2)) : undefined$1;
        }
        var pull = baseRest(pullAll);
        function pullAll(array2, values22) {
          return array2 && array2.length && values22 && values22.length ? basePullAll(array2, values22) : array2;
        }
        function pullAllBy(array2, values22, iteratee2) {
          return array2 && array2.length && values22 && values22.length ? basePullAll(array2, values22, getIteratee(iteratee2, 2)) : array2;
        }
        function pullAllWith(array2, values22, comparator) {
          return array2 && array2.length && values22 && values22.length ? basePullAll(array2, values22, undefined$1, comparator) : array2;
        }
        var pullAt = flatRest(function(array2, indexes) {
          var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
          basePullAt(array2, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove4(array2, predicate) {
          var result2 = [];
          if (!(array2 && array2.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array2.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array2[index];
            if (predicate(value, index, array2)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array2, indexes);
          return result2;
        }
        function reverse3(array2) {
          return array2 == null ? array2 : nativeReverse.call(array2);
        }
        function slice4(array2, start, end) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array2, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length : toInteger(end);
          }
          return baseSlice(array2, start, end);
        }
        function sortedIndex(array2, value) {
          return baseSortedIndex(array2, value);
        }
        function sortedIndexBy(array2, value, iteratee2) {
          return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          if (length) {
            var index = baseSortedIndex(array2, value);
            if (index < length && eq(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array2, value) {
          return baseSortedIndex(array2, value, true);
        }
        function sortedLastIndexBy(array2, value, iteratee2) {
          return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          if (length) {
            var index = baseSortedIndex(array2, value, true) - 1;
            if (eq(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array2) {
          return array2 && array2.length ? baseSortedUniq(array2) : [];
        }
        function sortedUniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSlice(array2, 1, length) : [];
        }
        function take2(array2, n2, guard) {
          if (!(array2 && array2.length)) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          return baseSlice(array2, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array2, n2, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array2, n2 < 0 ? 0 : n2, length);
        }
        function takeRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile2(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last3(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last3(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });
        function uniq(array2) {
          return array2 && array2.length ? baseUniq(array2) : [];
        }
        function uniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array2, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return array2 && array2.length ? baseUniq(array2, undefined$1, comparator) : [];
        }
        function unzip(array2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var length = 0;
          array2 = arrayFilter(array2, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array2, baseProperty(index));
          });
        }
        function unzipWith(array2, iteratee2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var result2 = unzip(array2);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest(function(array2, values22) {
          return isArrayLikeObject(array2) ? baseDifference(array2, values22) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last3(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last3(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });
        var zip2 = baseRest(unzip);
        function zipObject(props, values22) {
          return baseZipObject(props || [], values22 || [], assignValue);
        }
        function zipObjectDeep(props, values22) {
          return baseZipObject(props || [], values22 || [], baseSet);
        }
        var zipWith2 = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
            return baseAt(object2, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array2) {
            if (length && !array2.length) {
              array2.push(undefined$1);
            }
            return array2;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray3(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone22 = wrapperClone(parent2);
            clone22.__index__ = 0;
            clone22.__values__ = undefined$1;
            if (result2) {
              previous.__wrapped__ = clone22;
            } else {
              result2 = clone22;
            }
            var previous = clone22;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse3],
              "thisArg": undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse3);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy2 = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every2(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter3(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find2 = createFind(findIndex3);
        var findLast2 = createFind(findLastIndex2);
        function flatMap2(collection, iteratee2) {
          return baseFlatten(map3(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map3(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map3(collection, iteratee2), depth);
        }
        function forEach3(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy2 = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes3(collection, value, fromIndex, guard) {
          collection = isArrayLike2(collection) ? collection : values2(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path2, args) {
          var index = -1, isFunc = typeof path2 == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map3(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition2 = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce2(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight2(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n2);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike2(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some2(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy2 = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root.Date.now();
        };
        function after(n2, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n2, guard) {
          n2 = guard ? undefined$1 : n2;
          n2 = func && n2 == null ? func.length : n2;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
        }
        function before(n2, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n2 <= 1) {
              func = undefined$1;
            }
            return result2;
          };
        }
        var bind2 = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object2, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object2, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber2(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined$1;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush2() {
            return timerId === undefined$1 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush2;
          return debounced;
        }
        var defer2 = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber2(wait) || 0, args);
        });
        function flip2(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
            if (cache2.has(key)) {
              return cache2.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache2.set(key, result2) || cache2;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest2(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array2 = args[start], otherArgs = castSlice(args, 0, start);
            if (array2) {
              arrayPush(otherArgs, array2);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap2(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone2(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object2, source) {
          return source == null || baseConformsTo(object2, source, keys2(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt2 = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
          return arguments;
        })()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike2(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike2(value);
        }
        function isBoolean2(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject3(value);
        }
        function isEmpty2(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike2(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject3(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object2, source) {
          return object2 === source || baseIsMatch(object2, source, getMatchData(source));
        }
        function isMatchWith(object2, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseIsMatch(object2, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject3(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString2;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray3(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike2(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber2(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber2(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString5(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign3 = createAssigner(function(object2, source) {
          if (isPrototype(source) || isArrayLike2(source)) {
            copyObject(source, keys2(source), object2);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object2, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object2, source) {
          copyObject(source, keysIn(source), object2);
        });
        var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object2, customizer);
        });
        var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keys2(source), object2, customizer);
        });
        var at2 = flatRest(baseAt);
        function create3(prototype, properties2) {
          var result2 = baseCreate(prototype);
          return properties2 == null ? result2 : baseAssign(result2, properties2);
        }
        var defaults2 = baseRest(function(object2, sources) {
          object2 = Object2(object2);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object2[key];
              if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object2, key)) {
                object2[key] = source[key];
              }
            }
          }
          return object2;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith2, undefined$1, args);
        });
        function findKey3(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey2(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object2, iteratee2) {
          return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object2, iteratee2) {
          return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object2, iteratee2) {
          return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object2, iteratee2) {
          return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
        }
        function functions(object2) {
          return object2 == null ? [] : baseFunctions(object2, keys2(object2));
        }
        function functionsIn(object2) {
          return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
        }
        function get11(object2, path2, defaultValue2) {
          var result2 = object2 == null ? undefined$1 : baseGet2(object2, path2);
          return result2 === undefined$1 ? defaultValue2 : result2;
        }
        function has5(object2, path2) {
          return object2 != null && hasPath(object2, path2, baseHas);
        }
        function hasIn2(object2, path2) {
          return object2 != null && hasPath(object2, path2, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys2(object2) {
          return isArrayLike2(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
        }
        function keysIn(object2) {
          return isArrayLike2(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
        }
        function mapKeys2(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value, key, object22) {
            baseAssignValue(result2, iteratee2(value, key, object22), value);
          });
          return result2;
        }
        function mapValues(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value, key, object22) {
            baseAssignValue(result2, key, iteratee2(value, key, object22));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object2, source, srcIndex) {
          baseMerge(object2, source, srcIndex);
        });
        var mergeWith2 = createAssigner(function(object2, source, srcIndex, customizer) {
          baseMerge(object2, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object2, paths) {
          var result2 = {};
          if (object2 == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path2) {
            path2 = castPath(path2, object2);
            isDeep || (isDeep = path2.length > 1);
            return path2;
          });
          copyObject(object2, getAllKeysIn(object2), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object2, predicate) {
          return pickBy(object2, negate(getIteratee(predicate)));
        }
        var pick2 = flatRest(function(object2, paths) {
          return object2 == null ? {} : basePick(object2, paths);
        });
        function pickBy(object2, predicate) {
          if (object2 == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object2), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object2, props, function(value, path2) {
            return predicate(value, path2[0]);
          });
        }
        function result(object2, path2, defaultValue2) {
          path2 = castPath(path2, object2);
          var index = -1, length = path2.length;
          if (!length) {
            length = 1;
            object2 = undefined$1;
          }
          while (++index < length) {
            var value = object2 == null ? undefined$1 : object2[toKey(path2[index])];
            if (value === undefined$1) {
              index = length;
              value = defaultValue2;
            }
            object2 = isFunction2(value) ? value.call(object2) : value;
          }
          return object2;
        }
        function set3(object2, path2, value) {
          return object2 == null ? object2 : baseSet(object2, path2, value);
        }
        function setWith(object2, path2, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object2 == null ? object2 : baseSet(object2, path2, value, customizer);
        }
        var toPairs = createToPairs(keys2);
        var toPairsIn = createToPairs(keysIn);
        function transform(object2, iteratee2, accumulator) {
          var isArr = isArray(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray(object2);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object2 && object2.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object2)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object2)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index, object22) {
            return iteratee2(accumulator, value, index, object22);
          });
          return accumulator;
        }
        function unset2(object2, path2) {
          return object2 == null ? true : baseUnset(object2, path2);
        }
        function update8(object2, path2, updater) {
          return object2 == null ? object2 : baseUpdate(object2, path2, castFunction(updater));
        }
        function updateWith(object2, path2, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object2 == null ? object2 : baseUpdate(object2, path2, castFunction(updater), customizer);
        }
        function values2(object2) {
          return object2 == null ? [] : baseValues(object2, keys2(object2));
        }
        function valuesIn(object2) {
          return object2 == null ? [] : baseValues(object2, keysIn(object2));
        }
        function clamp2(number2, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber2(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber2(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber2(number2), lower, upper);
        }
        function inRange(number2, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number2 = toNumber2(number2);
          return baseInRange(number2, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$1;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize2(word) : word);
        });
        function capitalize2(string2) {
          return upperFirst(toString5(string2).toLowerCase());
        }
        function deburr(string2) {
          string2 = toString5(string2);
          return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string2, target, position) {
          string2 = toString5(string2);
          target = baseToString(target);
          var length = string2.length;
          position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string2.slice(position, end) == target;
        }
        function escape2(string2) {
          string2 = toString5(string2);
          return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
        }
        function escapeRegExp(string2) {
          string2 = toString5(string2);
          return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string2, length, chars2) {
          string2 = toString5(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          if (!length || strLength >= length) {
            return string2;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars2) + string2 + createPadding(nativeCeil(mid), chars2);
        }
        function padEnd(string2, length, chars2) {
          string2 = toString5(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          return length && strLength < length ? string2 + createPadding(length - strLength, chars2) : string2;
        }
        function padStart(string2, length, chars2) {
          string2 = toString5(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars2) + string2 : string2;
        }
        function parseInt2(string2, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString5(string2).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string2, n2, guard) {
          if (guard ? isIterateeCall(string2, n2, guard) : n2 === undefined$1) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString5(string2), n2);
        }
        function replace2() {
          var args = arguments, string2 = toString5(args[0]);
          return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string2, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string2 = toString5(string2);
          if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string2)) {
              return castSlice(stringToArray(string2), 0, limit);
            }
          }
          return string2.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string2, target, position) {
          string2 = toString5(string2);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
          target = baseToString(target);
          return string2.slice(position, position + target.length) == target;
        }
        function template(string2, options, guard) {
          var settings = lodash2.templateSettings;
          if (guard && isIterateeCall(string2, options, guard)) {
            options = undefined$1;
          }
          string2 = toString5(string2);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string2.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string2.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match2.length;
            return match2;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString5(value).toLowerCase();
        }
        function toUpper(value) {
          return toString5(value).toUpperCase();
        }
        function trim(string2, chars2, guard) {
          string2 = toString5(string2);
          if (string2 && (guard || chars2 === undefined$1)) {
            return baseTrim(string2);
          }
          if (!string2 || !(chars2 = baseToString(chars2))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars2), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string2, chars2, guard) {
          string2 = toString5(string2);
          if (string2 && (guard || chars2 === undefined$1)) {
            return string2.slice(0, trimmedEndIndex(string2) + 1);
          }
          if (!string2 || !(chars2 = baseToString(chars2))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars2)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string2, chars2, guard) {
          string2 = toString5(string2);
          if (string2 && (guard || chars2 === undefined$1)) {
            return string2.replace(reTrimStart, "");
          }
          if (!string2 || !(chars2 = baseToString(chars2))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars2));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string2, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string2 = toString5(string2);
          var strLength = string2.length;
          if (hasUnicode(string2)) {
            var strSymbols = stringToArray(string2);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string2;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
          if (separator === undefined$1) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string2.slice(end).search(separator)) {
              var match2, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString5(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match2 = separator.exec(substring)) {
                var newEnd = match2.index;
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string2.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape3(string2) {
          string2 = toString5(string2);
          return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string2, pattern, guard) {
          string2 = toString5(string2);
          pattern = guard ? undefined$1 : pattern;
          if (pattern === undefined$1) {
            return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
          }
          return string2.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e2) {
            return isError(e2) ? e2 : new Error2(e2);
          }
        });
        var bindAll = flatRest(function(object2, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object2, key, bind2(object2[key], object2));
          });
          return object2;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue2) {
          return value == null || value !== value ? defaultValue2 : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches2(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path2, srcValue) {
          return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path2, args) {
          return function(object2) {
            return baseInvoke(object2, path2, args);
          };
        });
        var methodOf = baseRest(function(object2, args) {
          return function(path2) {
            return baseInvoke(object2, path2, args);
          };
        });
        function mixin2(object2, source, options) {
          var props = keys2(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object2;
            object2 = this;
            methodNames = baseFunctions(source, keys2(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object2);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object2[methodName] = func;
            if (isFunc) {
              object2.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object2 });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object2, arrayPush([this.value()], arguments));
              };
            }
          });
          return object2;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path2) {
          return isKey2(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
        }
        function propertyOf(object2) {
          return function(path2) {
            return object2 == null ? undefined$1 : baseGet2(object2, path2);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n2) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath2(toString5(value)));
        }
        function uniqueId(prefix2) {
          var id = ++idCounter;
          return toString5(prefix2) + id;
        }
        var add2 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max2(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity, baseGt) : undefined$1;
        }
        function maxBy2(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        function mean(array2) {
          return baseMean(array2, identity);
        }
        function meanBy(array2, iteratee2) {
          return baseMean(array2, getIteratee(iteratee2, 2));
        }
        function min2(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity, baseLt) : undefined$1;
        }
        function minBy2(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract2 = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array2) {
          return array2 && array2.length ? baseSum(array2, identity) : 0;
        }
        function sumBy(array2, iteratee2) {
          return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign3;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at2;
        lodash2.before = before;
        lodash2.bind = bind2;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact2;
        lodash2.concat = concat2;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant;
        lodash2.countBy = countBy2;
        lodash2.create = create3;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce;
        lodash2.defaults = defaults2;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer2;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter3;
        lodash2.flatMap = flatMap2;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten4;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip2;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy2;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys2;
        lodash2.keysIn = keysIn;
        lodash2.map = map3;
        lodash2.mapKeys = mapKeys2;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches2;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize;
        lodash2.merge = merge2;
        lodash2.mergeWith = mergeWith2;
        lodash2.method = method;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin2;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit;
        lodash2.omitBy = omitBy;
        lodash2.once = once;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition2;
        lodash2.pick = pick2;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove4;
        lodash2.rest = rest2;
        lodash2.reverse = reverse3;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set3;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice4;
        lodash2.sortBy = sortBy2;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split;
        lodash2.spread = spread;
        lodash2.tail = tail;
        lodash2.take = take2;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile2;
        lodash2.tap = tap;
        lodash2.throttle = throttle;
        lodash2.thru = thru;
        lodash2.toArray = toArray3;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset2;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update8;
        lodash2.updateWith = updateWith;
        lodash2.values = values2;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap2;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip2;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith2;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin2(lodash2, lodash2);
        lodash2.add = add2;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase;
        lodash2.capitalize = capitalize2;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp2;
        lodash2.clone = clone2;
        lodash2.cloneDeep = cloneDeep;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith;
        lodash2.eq = eq;
        lodash2.escape = escape2;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every2;
        lodash2.find = find2;
        lodash2.findIndex = findIndex3;
        lodash2.findKey = findKey3;
        lodash2.findLast = findLast2;
        lodash2.findLastIndex = findLastIndex2;
        lodash2.findLastKey = findLastKey2;
        lodash2.floor = floor;
        lodash2.forEach = forEach3;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get11;
        lodash2.gt = gt2;
        lodash2.gte = gte;
        lodash2.has = has5;
        lodash2.hasIn = hasIn2;
        lodash2.head = head;
        lodash2.identity = identity;
        lodash2.includes = includes3;
        lodash2.indexOf = indexOf2;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments;
        lodash2.isArray = isArray;
        lodash2.isArrayBuffer = isArrayBuffer;
        lodash2.isArrayLike = isArrayLike2;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean2;
        lodash2.isBuffer = isBuffer;
        lodash2.isDate = isDate2;
        lodash2.isElement = isElement;
        lodash2.isEmpty = isEmpty2;
        lodash2.isEqual = isEqual;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite2;
        lodash2.isFunction = isFunction2;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap2;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber2;
        lodash2.isObject = isObject2;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject3;
        lodash2.isRegExp = isRegExp;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet2;
        lodash2.isString = isString2;
        lodash2.isSymbol = isSymbol;
        lodash2.isTypedArray = isTypedArray;
        lodash2.isUndefined = isUndefined2;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join2;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last3;
        lodash2.lastIndexOf = lastIndexOf2;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max2;
        lodash2.maxBy = maxBy2;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min2;
        lodash2.minBy = minBy2;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop2;
        lodash2.now = now2;
        lodash2.pad = pad;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random;
        lodash2.reduce = reduce2;
        lodash2.reduceRight = reduceRight2;
        lodash2.repeat = repeat;
        lodash2.replace = replace2;
        lodash2.result = result;
        lodash2.round = round;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some2;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract2;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber2;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString5;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape3;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach3;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin2(lodash2, (function() {
          var source = {};
          baseForOwn(lodash2, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        })(), { "chain": false });
        lodash2.VERSION = VERSION2;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined$1 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
          if (typeof path2 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path2, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$1
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      });
      var _23 = runInContext();
      if (freeModule) {
        (freeModule.exports = _23)._ = _23;
        freeExports._ = _23;
      } else {
        root._ = _23;
      }
    }).call(lodash);
  })(lodash$1, lodash$1.exports);
  return lodash$1.exports;
}
var lodashExports = requireLodash();
var immutable$1 = { exports: {} };
var immutable = immutable$1.exports;
var hasRequiredImmutable;
function requireImmutable() {
  if (hasRequiredImmutable) return immutable$1.exports;
  hasRequiredImmutable = 1;
  (function(module, exports) {
    (function(global, factory) {
      module.exports = factory();
    })(immutable, function() {
      var SLICE$0 = Array.prototype.slice;
      function createClass(ctor, superClass) {
        if (superClass) {
          ctor.prototype = Object.create(superClass.prototype);
        }
        ctor.prototype.constructor = ctor;
      }
      function Iterable2(value) {
        return isIterable(value) ? value : Seq2(value);
      }
      createClass(KeyedIterable, Iterable2);
      function KeyedIterable(value) {
        return isKeyed2(value) ? value : KeyedSeq2(value);
      }
      createClass(IndexedIterable, Iterable2);
      function IndexedIterable(value) {
        return isIndexed2(value) ? value : IndexedSeq2(value);
      }
      createClass(SetIterable, Iterable2);
      function SetIterable(value) {
        return isIterable(value) && !isAssociative2(value) ? value : SetSeq2(value);
      }
      function isIterable(maybeIterable) {
        return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
      }
      function isKeyed2(maybeKeyed) {
        return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
      }
      function isIndexed2(maybeIndexed) {
        return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
      }
      function isAssociative2(maybeAssociative) {
        return isKeyed2(maybeAssociative) || isIndexed2(maybeAssociative);
      }
      function isOrdered2(maybeOrdered) {
        return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
      }
      Iterable2.isIterable = isIterable;
      Iterable2.isKeyed = isKeyed2;
      Iterable2.isIndexed = isIndexed2;
      Iterable2.isAssociative = isAssociative2;
      Iterable2.isOrdered = isOrdered2;
      Iterable2.Keyed = KeyedIterable;
      Iterable2.Indexed = IndexedIterable;
      Iterable2.Set = SetIterable;
      var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
      var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
      var IS_INDEXED_SENTINEL = "@@__IMMUTABLE_INDEXED__@@";
      var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
      var DELETE2 = "delete";
      var SHIFT2 = 5;
      var SIZE2 = 1 << SHIFT2;
      var MASK2 = SIZE2 - 1;
      var NOT_SET2 = {};
      var CHANGE_LENGTH = { value: false };
      var DID_ALTER = { value: false };
      function MakeRef2(ref) {
        ref.value = false;
        return ref;
      }
      function SetRef2(ref) {
        ref && (ref.value = true);
      }
      function OwnerID2() {
      }
      function arrCopy2(arr2, offset) {
        offset = offset || 0;
        var len = Math.max(0, arr2.length - offset);
        var newArr = new Array(len);
        for (var ii = 0; ii < len; ii++) {
          newArr[ii] = arr2[ii + offset];
        }
        return newArr;
      }
      function ensureSize2(iter) {
        if (iter.size === void 0) {
          iter.size = iter.__iterate(returnTrue2);
        }
        return iter.size;
      }
      function wrapIndex2(iter, index) {
        if (typeof index !== "number") {
          var uint32Index = index >>> 0;
          if ("" + uint32Index !== index || uint32Index === 4294967295) {
            return NaN;
          }
          index = uint32Index;
        }
        return index < 0 ? ensureSize2(iter) + index : index;
      }
      function returnTrue2() {
        return true;
      }
      function wholeSlice2(begin, end, size) {
        return (begin === 0 || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
      }
      function resolveBegin2(begin, size) {
        return resolveIndex2(begin, size, 0);
      }
      function resolveEnd2(end, size) {
        return resolveIndex2(end, size, size);
      }
      function resolveIndex2(index, size, defaultIndex) {
        return index === void 0 ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === void 0 ? index : Math.min(size, index);
      }
      var ITERATE_KEYS2 = 0;
      var ITERATE_VALUES2 = 1;
      var ITERATE_ENTRIES2 = 2;
      var REAL_ITERATOR_SYMBOL2 = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL2 = "@@iterator";
      var ITERATOR_SYMBOL2 = REAL_ITERATOR_SYMBOL2 || FAUX_ITERATOR_SYMBOL2;
      function Iterator3(next) {
        this.next = next;
      }
      Iterator3.prototype.toString = function() {
        return "[Iterator]";
      };
      Iterator3.KEYS = ITERATE_KEYS2;
      Iterator3.VALUES = ITERATE_VALUES2;
      Iterator3.ENTRIES = ITERATE_ENTRIES2;
      Iterator3.prototype.inspect = Iterator3.prototype.toSource = function() {
        return this.toString();
      };
      Iterator3.prototype[ITERATOR_SYMBOL2] = function() {
        return this;
      };
      function iteratorValue2(type, k2, v2, iteratorResult) {
        var value = type === 0 ? k2 : type === 1 ? v2 : [k2, v2];
        iteratorResult ? iteratorResult.value = value : iteratorResult = {
          value,
          done: false
        };
        return iteratorResult;
      }
      function iteratorDone2() {
        return { value: void 0, done: true };
      }
      function hasIterator2(maybeIterable) {
        return !!getIteratorFn2(maybeIterable);
      }
      function isIterator2(maybeIterator) {
        return maybeIterator && typeof maybeIterator.next === "function";
      }
      function getIterator2(iterable) {
        var iteratorFn = getIteratorFn2(iterable);
        return iteratorFn && iteratorFn.call(iterable);
      }
      function getIteratorFn2(iterable) {
        var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL2 && iterable[REAL_ITERATOR_SYMBOL2] || iterable[FAUX_ITERATOR_SYMBOL2]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      function isArrayLike2(value) {
        return value && typeof value.length === "number";
      }
      createClass(Seq2, Iterable2);
      function Seq2(value) {
        return value === null || value === void 0 ? emptySequence2() : isIterable(value) ? value.toSeq() : seqFromValue2(value);
      }
      Seq2.of = function() {
        return Seq2(arguments);
      };
      Seq2.prototype.toSeq = function() {
        return this;
      };
      Seq2.prototype.toString = function() {
        return this.__toString("Seq {", "}");
      };
      Seq2.prototype.cacheResult = function() {
        if (!this._cache && this.__iterateUncached) {
          this._cache = this.entrySeq().toArray();
          this.size = this._cache.length;
        }
        return this;
      };
      Seq2.prototype.__iterate = function(fn2, reverse3) {
        return seqIterate(this, fn2, reverse3, true);
      };
      Seq2.prototype.__iterator = function(type, reverse3) {
        return seqIterator(this, type, reverse3, true);
      };
      createClass(KeyedSeq2, Seq2);
      function KeyedSeq2(value) {
        return value === null || value === void 0 ? emptySequence2().toKeyedSeq() : isIterable(value) ? isKeyed2(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue2(value);
      }
      KeyedSeq2.prototype.toKeyedSeq = function() {
        return this;
      };
      createClass(IndexedSeq2, Seq2);
      function IndexedSeq2(value) {
        return value === null || value === void 0 ? emptySequence2() : !isIterable(value) ? indexedSeqFromValue2(value) : isKeyed2(value) ? value.entrySeq() : value.toIndexedSeq();
      }
      IndexedSeq2.of = function() {
        return IndexedSeq2(arguments);
      };
      IndexedSeq2.prototype.toIndexedSeq = function() {
        return this;
      };
      IndexedSeq2.prototype.toString = function() {
        return this.__toString("Seq [", "]");
      };
      IndexedSeq2.prototype.__iterate = function(fn2, reverse3) {
        return seqIterate(this, fn2, reverse3, false);
      };
      IndexedSeq2.prototype.__iterator = function(type, reverse3) {
        return seqIterator(this, type, reverse3, false);
      };
      createClass(SetSeq2, Seq2);
      function SetSeq2(value) {
        return (value === null || value === void 0 ? emptySequence2() : !isIterable(value) ? indexedSeqFromValue2(value) : isKeyed2(value) ? value.entrySeq() : value).toSetSeq();
      }
      SetSeq2.of = function() {
        return SetSeq2(arguments);
      };
      SetSeq2.prototype.toSetSeq = function() {
        return this;
      };
      Seq2.isSeq = isSeq2;
      Seq2.Keyed = KeyedSeq2;
      Seq2.Set = SetSeq2;
      Seq2.Indexed = IndexedSeq2;
      var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
      Seq2.prototype[IS_SEQ_SENTINEL] = true;
      createClass(ArraySeq2, IndexedSeq2);
      function ArraySeq2(array2) {
        this._array = array2;
        this.size = array2.length;
      }
      ArraySeq2.prototype.get = function(index, notSetValue) {
        return this.has(index) ? this._array[wrapIndex2(this, index)] : notSetValue;
      };
      ArraySeq2.prototype.__iterate = function(fn2, reverse3) {
        var array2 = this._array;
        var maxIndex = array2.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          if (fn2(array2[reverse3 ? maxIndex - ii : ii], ii, this) === false) {
            return ii + 1;
          }
        }
        return ii;
      };
      ArraySeq2.prototype.__iterator = function(type, reverse3) {
        var array2 = this._array;
        var maxIndex = array2.length - 1;
        var ii = 0;
        return new Iterator3(
          function() {
            return ii > maxIndex ? iteratorDone2() : iteratorValue2(type, ii, array2[reverse3 ? maxIndex - ii++ : ii++]);
          }
        );
      };
      createClass(ObjectSeq2, KeyedSeq2);
      function ObjectSeq2(object2) {
        var keys2 = Object.keys(object2);
        this._object = object2;
        this._keys = keys2;
        this.size = keys2.length;
      }
      ObjectSeq2.prototype.get = function(key, notSetValue) {
        if (notSetValue !== void 0 && !this.has(key)) {
          return notSetValue;
        }
        return this._object[key];
      };
      ObjectSeq2.prototype.has = function(key) {
        return this._object.hasOwnProperty(key);
      };
      ObjectSeq2.prototype.__iterate = function(fn2, reverse3) {
        var object2 = this._object;
        var keys2 = this._keys;
        var maxIndex = keys2.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          var key = keys2[reverse3 ? maxIndex - ii : ii];
          if (fn2(object2[key], key, this) === false) {
            return ii + 1;
          }
        }
        return ii;
      };
      ObjectSeq2.prototype.__iterator = function(type, reverse3) {
        var object2 = this._object;
        var keys2 = this._keys;
        var maxIndex = keys2.length - 1;
        var ii = 0;
        return new Iterator3(function() {
          var key = keys2[reverse3 ? maxIndex - ii : ii];
          return ii++ > maxIndex ? iteratorDone2() : iteratorValue2(type, key, object2[key]);
        });
      };
      ObjectSeq2.prototype[IS_ORDERED_SENTINEL] = true;
      createClass(IterableSeq, IndexedSeq2);
      function IterableSeq(iterable) {
        this._iterable = iterable;
        this.size = iterable.length || iterable.size;
      }
      IterableSeq.prototype.__iterateUncached = function(fn2, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterate(fn2, reverse3);
        }
        var iterable = this._iterable;
        var iterator = getIterator2(iterable);
        var iterations = 0;
        if (isIterator2(iterator)) {
          var step;
          while (!(step = iterator.next()).done) {
            if (fn2(step.value, iterations++, this) === false) {
              break;
            }
          }
        }
        return iterations;
      };
      IterableSeq.prototype.__iteratorUncached = function(type, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterator(type, reverse3);
        }
        var iterable = this._iterable;
        var iterator = getIterator2(iterable);
        if (!isIterator2(iterator)) {
          return new Iterator3(iteratorDone2);
        }
        var iterations = 0;
        return new Iterator3(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue2(type, iterations++, step.value);
        });
      };
      createClass(IteratorSeq, IndexedSeq2);
      function IteratorSeq(iterator) {
        this._iterator = iterator;
        this._iteratorCache = [];
      }
      IteratorSeq.prototype.__iterateUncached = function(fn2, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterate(fn2, reverse3);
        }
        var iterator = this._iterator;
        var cache2 = this._iteratorCache;
        var iterations = 0;
        while (iterations < cache2.length) {
          if (fn2(cache2[iterations], iterations++, this) === false) {
            return iterations;
          }
        }
        var step;
        while (!(step = iterator.next()).done) {
          var val = step.value;
          cache2[iterations] = val;
          if (fn2(val, iterations++, this) === false) {
            break;
          }
        }
        return iterations;
      };
      IteratorSeq.prototype.__iteratorUncached = function(type, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterator(type, reverse3);
        }
        var iterator = this._iterator;
        var cache2 = this._iteratorCache;
        var iterations = 0;
        return new Iterator3(function() {
          if (iterations >= cache2.length) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            cache2[iterations] = step.value;
          }
          return iteratorValue2(type, iterations, cache2[iterations++]);
        });
      };
      function isSeq2(maybeSeq) {
        return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
      }
      var EMPTY_SEQ2;
      function emptySequence2() {
        return EMPTY_SEQ2 || (EMPTY_SEQ2 = new ArraySeq2([]));
      }
      function keyedSeqFromValue2(value) {
        var seq = Array.isArray(value) ? new ArraySeq2(value).fromEntrySeq() : isIterator2(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator2(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === "object" ? new ObjectSeq2(value) : void 0;
        if (!seq) {
          throw new TypeError(
            "Expected Array or iterable object of [k, v] entries, or keyed object: " + value
          );
        }
        return seq;
      }
      function indexedSeqFromValue2(value) {
        var seq = maybeIndexedSeqFromValue2(value);
        if (!seq) {
          throw new TypeError(
            "Expected Array or iterable object of values: " + value
          );
        }
        return seq;
      }
      function seqFromValue2(value) {
        var seq = maybeIndexedSeqFromValue2(value) || typeof value === "object" && new ObjectSeq2(value);
        if (!seq) {
          throw new TypeError(
            "Expected Array or iterable object of values, or keyed object: " + value
          );
        }
        return seq;
      }
      function maybeIndexedSeqFromValue2(value) {
        return isArrayLike2(value) ? new ArraySeq2(value) : isIterator2(value) ? new IteratorSeq(value) : hasIterator2(value) ? new IterableSeq(value) : void 0;
      }
      function seqIterate(seq, fn2, reverse3, useKeys) {
        var cache2 = seq._cache;
        if (cache2) {
          var maxIndex = cache2.length - 1;
          for (var ii = 0; ii <= maxIndex; ii++) {
            var entry = cache2[reverse3 ? maxIndex - ii : ii];
            if (fn2(entry[1], useKeys ? entry[0] : ii, seq) === false) {
              return ii + 1;
            }
          }
          return ii;
        }
        return seq.__iterateUncached(fn2, reverse3);
      }
      function seqIterator(seq, type, reverse3, useKeys) {
        var cache2 = seq._cache;
        if (cache2) {
          var maxIndex = cache2.length - 1;
          var ii = 0;
          return new Iterator3(function() {
            var entry = cache2[reverse3 ? maxIndex - ii : ii];
            return ii++ > maxIndex ? iteratorDone2() : iteratorValue2(type, useKeys ? entry[0] : ii - 1, entry[1]);
          });
        }
        return seq.__iteratorUncached(type, reverse3);
      }
      function fromJS2(json, converter) {
        return converter ? fromJSWith2(converter, json, "", { "": json }) : fromJSDefault(json);
      }
      function fromJSWith2(converter, json, key, parentJSON) {
        if (Array.isArray(json)) {
          return converter.call(parentJSON, key, IndexedSeq2(json).map(function(v2, k2) {
            return fromJSWith2(converter, v2, k2, json);
          }));
        }
        if (isPlainObj(json)) {
          return converter.call(parentJSON, key, KeyedSeq2(json).map(function(v2, k2) {
            return fromJSWith2(converter, v2, k2, json);
          }));
        }
        return json;
      }
      function fromJSDefault(json) {
        if (Array.isArray(json)) {
          return IndexedSeq2(json).map(fromJSDefault).toList();
        }
        if (isPlainObj(json)) {
          return KeyedSeq2(json).map(fromJSDefault).toMap();
        }
        return json;
      }
      function isPlainObj(value) {
        return value && (value.constructor === Object || value.constructor === void 0);
      }
      function is2(valueA, valueB) {
        if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
          return true;
        }
        if (!valueA || !valueB) {
          return false;
        }
        if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
          valueA = valueA.valueOf();
          valueB = valueB.valueOf();
          if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
            return true;
          }
          if (!valueA || !valueB) {
            return false;
          }
        }
        if (typeof valueA.equals === "function" && typeof valueB.equals === "function" && valueA.equals(valueB)) {
          return true;
        }
        return false;
      }
      function deepEqual2(a2, b2) {
        if (a2 === b2) {
          return true;
        }
        if (!isIterable(b2) || a2.size !== void 0 && b2.size !== void 0 && a2.size !== b2.size || a2.__hash !== void 0 && b2.__hash !== void 0 && a2.__hash !== b2.__hash || isKeyed2(a2) !== isKeyed2(b2) || isIndexed2(a2) !== isIndexed2(b2) || isOrdered2(a2) !== isOrdered2(b2)) {
          return false;
        }
        if (a2.size === 0 && b2.size === 0) {
          return true;
        }
        var notAssociative = !isAssociative2(a2);
        if (isOrdered2(a2)) {
          var entries3 = a2.entries();
          return b2.every(function(v2, k2) {
            var entry = entries3.next().value;
            return entry && is2(entry[1], v2) && (notAssociative || is2(entry[0], k2));
          }) && entries3.next().done;
        }
        var flipped = false;
        if (a2.size === void 0) {
          if (b2.size === void 0) {
            if (typeof a2.cacheResult === "function") {
              a2.cacheResult();
            }
          } else {
            flipped = true;
            var _23 = a2;
            a2 = b2;
            b2 = _23;
          }
        }
        var allEqual = true;
        var bSize = b2.__iterate(function(v2, k2) {
          if (notAssociative ? !a2.has(v2) : flipped ? !is2(v2, a2.get(k2, NOT_SET2)) : !is2(a2.get(k2, NOT_SET2), v2)) {
            allEqual = false;
            return false;
          }
        });
        return allEqual && a2.size === bSize;
      }
      createClass(Repeat2, IndexedSeq2);
      function Repeat2(value, times) {
        if (!(this instanceof Repeat2)) {
          return new Repeat2(value, times);
        }
        this._value = value;
        this.size = times === void 0 ? Infinity : Math.max(0, times);
        if (this.size === 0) {
          if (EMPTY_REPEAT2) {
            return EMPTY_REPEAT2;
          }
          EMPTY_REPEAT2 = this;
        }
      }
      Repeat2.prototype.toString = function() {
        if (this.size === 0) {
          return "Repeat []";
        }
        return "Repeat [ " + this._value + " " + this.size + " times ]";
      };
      Repeat2.prototype.get = function(index, notSetValue) {
        return this.has(index) ? this._value : notSetValue;
      };
      Repeat2.prototype.includes = function(searchValue) {
        return is2(this._value, searchValue);
      };
      Repeat2.prototype.slice = function(begin, end) {
        var size = this.size;
        return wholeSlice2(begin, end, size) ? this : new Repeat2(this._value, resolveEnd2(end, size) - resolveBegin2(begin, size));
      };
      Repeat2.prototype.reverse = function() {
        return this;
      };
      Repeat2.prototype.indexOf = function(searchValue) {
        if (is2(this._value, searchValue)) {
          return 0;
        }
        return -1;
      };
      Repeat2.prototype.lastIndexOf = function(searchValue) {
        if (is2(this._value, searchValue)) {
          return this.size;
        }
        return -1;
      };
      Repeat2.prototype.__iterate = function(fn2, reverse3) {
        for (var ii = 0; ii < this.size; ii++) {
          if (fn2(this._value, ii, this) === false) {
            return ii + 1;
          }
        }
        return ii;
      };
      Repeat2.prototype.__iterator = function(type, reverse3) {
        var this$0 = this;
        var ii = 0;
        return new Iterator3(
          function() {
            return ii < this$0.size ? iteratorValue2(type, ii++, this$0._value) : iteratorDone2();
          }
        );
      };
      Repeat2.prototype.equals = function(other) {
        return other instanceof Repeat2 ? is2(this._value, other._value) : deepEqual2(other);
      };
      var EMPTY_REPEAT2;
      function invariant2(condition, error2) {
        if (!condition) throw new Error(error2);
      }
      createClass(Range2, IndexedSeq2);
      function Range2(start, end, step) {
        if (!(this instanceof Range2)) {
          return new Range2(start, end, step);
        }
        invariant2(step !== 0, "Cannot step a Range by 0");
        start = start || 0;
        if (end === void 0) {
          end = Infinity;
        }
        step = step === void 0 ? 1 : Math.abs(step);
        if (end < start) {
          step = -step;
        }
        this._start = start;
        this._end = end;
        this._step = step;
        this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
        if (this.size === 0) {
          if (EMPTY_RANGE2) {
            return EMPTY_RANGE2;
          }
          EMPTY_RANGE2 = this;
        }
      }
      Range2.prototype.toString = function() {
        if (this.size === 0) {
          return "Range []";
        }
        return "Range [ " + this._start + "..." + this._end + (this._step > 1 ? " by " + this._step : "") + " ]";
      };
      Range2.prototype.get = function(index, notSetValue) {
        return this.has(index) ? this._start + wrapIndex2(this, index) * this._step : notSetValue;
      };
      Range2.prototype.includes = function(searchValue) {
        var possibleIndex = (searchValue - this._start) / this._step;
        return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
      };
      Range2.prototype.slice = function(begin, end) {
        if (wholeSlice2(begin, end, this.size)) {
          return this;
        }
        begin = resolveBegin2(begin, this.size);
        end = resolveEnd2(end, this.size);
        if (end <= begin) {
          return new Range2(0, 0);
        }
        return new Range2(this.get(begin, this._end), this.get(end, this._end), this._step);
      };
      Range2.prototype.indexOf = function(searchValue) {
        var offsetValue = searchValue - this._start;
        if (offsetValue % this._step === 0) {
          var index = offsetValue / this._step;
          if (index >= 0 && index < this.size) {
            return index;
          }
        }
        return -1;
      };
      Range2.prototype.lastIndexOf = function(searchValue) {
        return this.indexOf(searchValue);
      };
      Range2.prototype.__iterate = function(fn2, reverse3) {
        var maxIndex = this.size - 1;
        var step = this._step;
        var value = reverse3 ? this._start + maxIndex * step : this._start;
        for (var ii = 0; ii <= maxIndex; ii++) {
          if (fn2(value, ii, this) === false) {
            return ii + 1;
          }
          value += reverse3 ? -step : step;
        }
        return ii;
      };
      Range2.prototype.__iterator = function(type, reverse3) {
        var maxIndex = this.size - 1;
        var step = this._step;
        var value = reverse3 ? this._start + maxIndex * step : this._start;
        var ii = 0;
        return new Iterator3(function() {
          var v2 = value;
          value += reverse3 ? -step : step;
          return ii > maxIndex ? iteratorDone2() : iteratorValue2(type, ii++, v2);
        });
      };
      Range2.prototype.equals = function(other) {
        return other instanceof Range2 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual2(this, other);
      };
      var EMPTY_RANGE2;
      createClass(Collection3, Iterable2);
      function Collection3() {
        throw TypeError("Abstract");
      }
      createClass(KeyedCollection2, Collection3);
      function KeyedCollection2() {
      }
      createClass(IndexedCollection2, Collection3);
      function IndexedCollection2() {
      }
      createClass(SetCollection2, Collection3);
      function SetCollection2() {
      }
      Collection3.Keyed = KeyedCollection2;
      Collection3.Indexed = IndexedCollection2;
      Collection3.Set = SetCollection2;
      var imul3 = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul22(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = a2 & 65535;
        var d2 = b2 & 65535;
        return c2 * d2 + ((a2 >>> 16) * d2 + c2 * (b2 >>> 16) << 16 >>> 0) | 0;
      };
      function smi2(i32) {
        return i32 >>> 1 & 1073741824 | i32 & 3221225471;
      }
      function hash2(o2) {
        if (o2 === false || o2 === null || o2 === void 0) {
          return 0;
        }
        if (typeof o2.valueOf === "function") {
          o2 = o2.valueOf();
          if (o2 === false || o2 === null || o2 === void 0) {
            return 0;
          }
        }
        if (o2 === true) {
          return 1;
        }
        var type = typeof o2;
        if (type === "number") {
          var h2 = o2 | 0;
          if (h2 !== o2) {
            h2 ^= o2 * 4294967295;
          }
          while (o2 > 4294967295) {
            o2 /= 4294967295;
            h2 ^= o2;
          }
          return smi2(h2);
        }
        if (type === "string") {
          return o2.length > STRING_HASH_CACHE_MIN_STRLEN2 ? cachedHashString2(o2) : hashString2(o2);
        }
        if (typeof o2.hashCode === "function") {
          return o2.hashCode();
        }
        if (type === "object") {
          return hashJSObj2(o2);
        }
        if (typeof o2.toString === "function") {
          return hashString2(o2.toString());
        }
        throw new Error("Value type " + type + " cannot be hashed.");
      }
      function cachedHashString2(string2) {
        var hash22 = stringHashCache2[string2];
        if (hash22 === void 0) {
          hash22 = hashString2(string2);
          if (STRING_HASH_CACHE_SIZE2 === STRING_HASH_CACHE_MAX_SIZE2) {
            STRING_HASH_CACHE_SIZE2 = 0;
            stringHashCache2 = {};
          }
          STRING_HASH_CACHE_SIZE2++;
          stringHashCache2[string2] = hash22;
        }
        return hash22;
      }
      function hashString2(string2) {
        var hash22 = 0;
        for (var ii = 0; ii < string2.length; ii++) {
          hash22 = 31 * hash22 + string2.charCodeAt(ii) | 0;
        }
        return smi2(hash22);
      }
      function hashJSObj2(obj) {
        var hash22;
        if (usingWeakMap2) {
          hash22 = weakMap2.get(obj);
          if (hash22 !== void 0) {
            return hash22;
          }
        }
        hash22 = obj[UID_HASH_KEY2];
        if (hash22 !== void 0) {
          return hash22;
        }
        if (!canDefineProperty2) {
          hash22 = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY2];
          if (hash22 !== void 0) {
            return hash22;
          }
          hash22 = getIENodeHash2(obj);
          if (hash22 !== void 0) {
            return hash22;
          }
        }
        hash22 = ++objHashUID;
        if (objHashUID & 1073741824) {
          objHashUID = 0;
        }
        if (usingWeakMap2) {
          weakMap2.set(obj, hash22);
        } else if (isExtensible2 !== void 0 && isExtensible2(obj) === false) {
          throw new Error("Non-extensible objects are not allowed as keys.");
        } else if (canDefineProperty2) {
          Object.defineProperty(obj, UID_HASH_KEY2, {
            "enumerable": false,
            "configurable": false,
            "writable": false,
            "value": hash22
          });
        } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
          obj.propertyIsEnumerable = function() {
            return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
          };
          obj.propertyIsEnumerable[UID_HASH_KEY2] = hash22;
        } else if (obj.nodeType !== void 0) {
          obj[UID_HASH_KEY2] = hash22;
        } else {
          throw new Error("Unable to set a non-enumerable property on object.");
        }
        return hash22;
      }
      var isExtensible2 = Object.isExtensible;
      var canDefineProperty2 = (function() {
        try {
          Object.defineProperty({}, "@", {});
          return true;
        } catch (e2) {
          return false;
        }
      })();
      function getIENodeHash2(node) {
        if (node && node.nodeType > 0) {
          switch (node.nodeType) {
            case 1:
              return node.uniqueID;
            case 9:
              return node.documentElement && node.documentElement.uniqueID;
          }
        }
      }
      var usingWeakMap2 = typeof WeakMap === "function";
      var weakMap2;
      if (usingWeakMap2) {
        weakMap2 = /* @__PURE__ */ new WeakMap();
      }
      var objHashUID = 0;
      var UID_HASH_KEY2 = "__immutablehash__";
      if (typeof Symbol === "function") {
        UID_HASH_KEY2 = Symbol(UID_HASH_KEY2);
      }
      var STRING_HASH_CACHE_MIN_STRLEN2 = 16;
      var STRING_HASH_CACHE_MAX_SIZE2 = 255;
      var STRING_HASH_CACHE_SIZE2 = 0;
      var stringHashCache2 = {};
      function assertNotInfinite2(size) {
        invariant2(
          size !== Infinity,
          "Cannot perform this action with an infinite size."
        );
      }
      createClass(Map2, KeyedCollection2);
      function Map2(value) {
        return value === null || value === void 0 ? emptyMap2() : isMap2(value) && !isOrdered2(value) ? value : emptyMap2().withMutations(function(map3) {
          var iter = KeyedIterable(value);
          assertNotInfinite2(iter.size);
          iter.forEach(function(v2, k2) {
            return map3.set(k2, v2);
          });
        });
      }
      Map2.prototype.toString = function() {
        return this.__toString("Map {", "}");
      };
      Map2.prototype.get = function(k2, notSetValue) {
        return this._root ? this._root.get(0, void 0, k2, notSetValue) : notSetValue;
      };
      Map2.prototype.set = function(k2, v2) {
        return updateMap2(this, k2, v2);
      };
      Map2.prototype.setIn = function(keyPath, v2) {
        return this.updateIn(keyPath, NOT_SET2, function() {
          return v2;
        });
      };
      Map2.prototype.remove = function(k2) {
        return updateMap2(this, k2, NOT_SET2);
      };
      Map2.prototype.deleteIn = function(keyPath) {
        return this.updateIn(keyPath, function() {
          return NOT_SET2;
        });
      };
      Map2.prototype.update = function(k2, notSetValue, updater) {
        return arguments.length === 1 ? k2(this) : this.updateIn([k2], notSetValue, updater);
      };
      Map2.prototype.updateIn = function(keyPath, notSetValue, updater) {
        if (!updater) {
          updater = notSetValue;
          notSetValue = void 0;
        }
        var updatedValue = updateInDeepMap(
          this,
          forceIterator(keyPath),
          notSetValue,
          updater
        );
        return updatedValue === NOT_SET2 ? void 0 : updatedValue;
      };
      Map2.prototype.clear = function() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._root = null;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyMap2();
      };
      Map2.prototype.merge = function() {
        return mergeIntoMapWith(this, void 0, arguments);
      };
      Map2.prototype.mergeWith = function(merger) {
        var iters = SLICE$0.call(arguments, 1);
        return mergeIntoMapWith(this, merger, iters);
      };
      Map2.prototype.mergeIn = function(keyPath) {
        var iters = SLICE$0.call(arguments, 1);
        return this.updateIn(
          keyPath,
          emptyMap2(),
          function(m2) {
            return typeof m2.merge === "function" ? m2.merge.apply(m2, iters) : iters[iters.length - 1];
          }
        );
      };
      Map2.prototype.mergeDeep = function() {
        return mergeIntoMapWith(this, deepMerger, arguments);
      };
      Map2.prototype.mergeDeepWith = function(merger) {
        var iters = SLICE$0.call(arguments, 1);
        return mergeIntoMapWith(this, deepMergerWith2(merger), iters);
      };
      Map2.prototype.mergeDeepIn = function(keyPath) {
        var iters = SLICE$0.call(arguments, 1);
        return this.updateIn(
          keyPath,
          emptyMap2(),
          function(m2) {
            return typeof m2.mergeDeep === "function" ? m2.mergeDeep.apply(m2, iters) : iters[iters.length - 1];
          }
        );
      };
      Map2.prototype.sort = function(comparator) {
        return OrderedMap2(sortFactory2(this, comparator));
      };
      Map2.prototype.sortBy = function(mapper, comparator) {
        return OrderedMap2(sortFactory2(this, comparator, mapper));
      };
      Map2.prototype.withMutations = function(fn2) {
        var mutable = this.asMutable();
        fn2(mutable);
        return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
      };
      Map2.prototype.asMutable = function() {
        return this.__ownerID ? this : this.__ensureOwner(new OwnerID2());
      };
      Map2.prototype.asImmutable = function() {
        return this.__ensureOwner();
      };
      Map2.prototype.wasAltered = function() {
        return this.__altered;
      };
      Map2.prototype.__iterator = function(type, reverse3) {
        return new MapIterator2(this, type, reverse3);
      };
      Map2.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        var iterations = 0;
        this._root && this._root.iterate(function(entry) {
          iterations++;
          return fn2(entry[1], entry[0], this$0);
        }, reverse3);
        return iterations;
      };
      Map2.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeMap2(this.size, this._root, ownerID, this.__hash);
      };
      function isMap2(maybeMap) {
        return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
      }
      Map2.isMap = isMap2;
      var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
      var MapPrototype2 = Map2.prototype;
      MapPrototype2[IS_MAP_SENTINEL] = true;
      MapPrototype2[DELETE2] = MapPrototype2.remove;
      MapPrototype2.removeIn = MapPrototype2.deleteIn;
      function ArrayMapNode3(ownerID, entries3) {
        this.ownerID = ownerID;
        this.entries = entries3;
      }
      ArrayMapNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
        var entries3 = this.entries;
        for (var ii = 0, len = entries3.length; ii < len; ii++) {
          if (is2(key, entries3[ii][0])) {
            return entries3[ii][1];
          }
        }
        return notSetValue;
      };
      ArrayMapNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        var removed = value === NOT_SET2;
        var entries3 = this.entries;
        var idx = 0;
        for (var len = entries3.length; idx < len; idx++) {
          if (is2(key, entries3[idx][0])) {
            break;
          }
        }
        var exists = idx < len;
        if (exists ? entries3[idx][1] === value : removed) {
          return this;
        }
        SetRef2(didAlter);
        (removed || !exists) && SetRef2(didChangeSize);
        if (removed && entries3.length === 1) {
          return;
        }
        if (!exists && !removed && entries3.length >= MAX_ARRAY_MAP_SIZE2) {
          return createNodes2(ownerID, entries3, key, value);
        }
        var isEditable = ownerID && ownerID === this.ownerID;
        var newEntries = isEditable ? entries3 : arrCopy2(entries3);
        if (exists) {
          if (removed) {
            idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
          } else {
            newEntries[idx] = [key, value];
          }
        } else {
          newEntries.push([key, value]);
        }
        if (isEditable) {
          this.entries = newEntries;
          return this;
        }
        return new ArrayMapNode3(ownerID, newEntries);
      };
      function BitmapIndexedNode3(ownerID, bitmap, nodes) {
        this.ownerID = ownerID;
        this.bitmap = bitmap;
        this.nodes = nodes;
      }
      BitmapIndexedNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
        if (keyHash === void 0) {
          keyHash = hash2(key);
        }
        var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK2);
        var bitmap = this.bitmap;
        return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount2(bitmap & bit - 1)].get(shift + SHIFT2, keyHash, key, notSetValue);
      };
      BitmapIndexedNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (keyHash === void 0) {
          keyHash = hash2(key);
        }
        var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK2;
        var bit = 1 << keyHashFrag;
        var bitmap = this.bitmap;
        var exists = (bitmap & bit) !== 0;
        if (!exists && value === NOT_SET2) {
          return this;
        }
        var idx = popCount2(bitmap & bit - 1);
        var nodes = this.nodes;
        var node = exists ? nodes[idx] : void 0;
        var newNode = updateNode2(node, ownerID, shift + SHIFT2, keyHash, key, value, didChangeSize, didAlter);
        if (newNode === node) {
          return this;
        }
        if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE2) {
          return expandNodes2(ownerID, nodes, bitmap, keyHashFrag, newNode);
        }
        if (exists && !newNode && nodes.length === 2 && isLeafNode2(nodes[idx ^ 1])) {
          return nodes[idx ^ 1];
        }
        if (exists && newNode && nodes.length === 1 && isLeafNode2(newNode)) {
          return newNode;
        }
        var isEditable = ownerID && ownerID === this.ownerID;
        var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
        var newNodes = exists ? newNode ? setIn2(nodes, idx, newNode, isEditable) : spliceOut2(nodes, idx, isEditable) : spliceIn2(nodes, idx, newNode, isEditable);
        if (isEditable) {
          this.bitmap = newBitmap;
          this.nodes = newNodes;
          return this;
        }
        return new BitmapIndexedNode3(ownerID, newBitmap, newNodes);
      };
      function HashArrayMapNode3(ownerID, count2, nodes) {
        this.ownerID = ownerID;
        this.count = count2;
        this.nodes = nodes;
      }
      HashArrayMapNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
        if (keyHash === void 0) {
          keyHash = hash2(key);
        }
        var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK2;
        var node = this.nodes[idx];
        return node ? node.get(shift + SHIFT2, keyHash, key, notSetValue) : notSetValue;
      };
      HashArrayMapNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (keyHash === void 0) {
          keyHash = hash2(key);
        }
        var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK2;
        var removed = value === NOT_SET2;
        var nodes = this.nodes;
        var node = nodes[idx];
        if (removed && !node) {
          return this;
        }
        var newNode = updateNode2(node, ownerID, shift + SHIFT2, keyHash, key, value, didChangeSize, didAlter);
        if (newNode === node) {
          return this;
        }
        var newCount = this.count;
        if (!node) {
          newCount++;
        } else if (!newNode) {
          newCount--;
          if (newCount < MIN_HASH_ARRAY_MAP_SIZE2) {
            return packNodes2(ownerID, nodes, newCount, idx);
          }
        }
        var isEditable = ownerID && ownerID === this.ownerID;
        var newNodes = setIn2(nodes, idx, newNode, isEditable);
        if (isEditable) {
          this.count = newCount;
          this.nodes = newNodes;
          return this;
        }
        return new HashArrayMapNode3(ownerID, newCount, newNodes);
      };
      function HashCollisionNode3(ownerID, keyHash, entries3) {
        this.ownerID = ownerID;
        this.keyHash = keyHash;
        this.entries = entries3;
      }
      HashCollisionNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
        var entries3 = this.entries;
        for (var ii = 0, len = entries3.length; ii < len; ii++) {
          if (is2(key, entries3[ii][0])) {
            return entries3[ii][1];
          }
        }
        return notSetValue;
      };
      HashCollisionNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (keyHash === void 0) {
          keyHash = hash2(key);
        }
        var removed = value === NOT_SET2;
        if (keyHash !== this.keyHash) {
          if (removed) {
            return this;
          }
          SetRef2(didAlter);
          SetRef2(didChangeSize);
          return mergeIntoNode2(this, ownerID, shift, keyHash, [key, value]);
        }
        var entries3 = this.entries;
        var idx = 0;
        for (var len = entries3.length; idx < len; idx++) {
          if (is2(key, entries3[idx][0])) {
            break;
          }
        }
        var exists = idx < len;
        if (exists ? entries3[idx][1] === value : removed) {
          return this;
        }
        SetRef2(didAlter);
        (removed || !exists) && SetRef2(didChangeSize);
        if (removed && len === 2) {
          return new ValueNode3(ownerID, this.keyHash, entries3[idx ^ 1]);
        }
        var isEditable = ownerID && ownerID === this.ownerID;
        var newEntries = isEditable ? entries3 : arrCopy2(entries3);
        if (exists) {
          if (removed) {
            idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
          } else {
            newEntries[idx] = [key, value];
          }
        } else {
          newEntries.push([key, value]);
        }
        if (isEditable) {
          this.entries = newEntries;
          return this;
        }
        return new HashCollisionNode3(ownerID, this.keyHash, newEntries);
      };
      function ValueNode3(ownerID, keyHash, entry) {
        this.ownerID = ownerID;
        this.keyHash = keyHash;
        this.entry = entry;
      }
      ValueNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
        return is2(key, this.entry[0]) ? this.entry[1] : notSetValue;
      };
      ValueNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        var removed = value === NOT_SET2;
        var keyMatch = is2(key, this.entry[0]);
        if (keyMatch ? value === this.entry[1] : removed) {
          return this;
        }
        SetRef2(didAlter);
        if (removed) {
          SetRef2(didChangeSize);
          return;
        }
        if (keyMatch) {
          if (ownerID && ownerID === this.ownerID) {
            this.entry[1] = value;
            return this;
          }
          return new ValueNode3(ownerID, this.keyHash, [key, value]);
        }
        SetRef2(didChangeSize);
        return mergeIntoNode2(this, ownerID, shift, hash2(key), [key, value]);
      };
      ArrayMapNode3.prototype.iterate = HashCollisionNode3.prototype.iterate = function(fn2, reverse3) {
        var entries3 = this.entries;
        for (var ii = 0, maxIndex = entries3.length - 1; ii <= maxIndex; ii++) {
          if (fn2(entries3[reverse3 ? maxIndex - ii : ii]) === false) {
            return false;
          }
        }
      };
      BitmapIndexedNode3.prototype.iterate = HashArrayMapNode3.prototype.iterate = function(fn2, reverse3) {
        var nodes = this.nodes;
        for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
          var node = nodes[reverse3 ? maxIndex - ii : ii];
          if (node && node.iterate(fn2, reverse3) === false) {
            return false;
          }
        }
      };
      ValueNode3.prototype.iterate = function(fn2, reverse3) {
        return fn2(this.entry);
      };
      createClass(MapIterator2, Iterator3);
      function MapIterator2(map3, type, reverse3) {
        this._type = type;
        this._reverse = reverse3;
        this._stack = map3._root && mapIteratorFrame2(map3._root);
      }
      MapIterator2.prototype.next = function() {
        var type = this._type;
        var stack = this._stack;
        while (stack) {
          var node = stack.node;
          var index = stack.index++;
          var maxIndex;
          if (node.entry) {
            if (index === 0) {
              return mapIteratorValue2(type, node.entry);
            }
          } else if (node.entries) {
            maxIndex = node.entries.length - 1;
            if (index <= maxIndex) {
              return mapIteratorValue2(type, node.entries[this._reverse ? maxIndex - index : index]);
            }
          } else {
            maxIndex = node.nodes.length - 1;
            if (index <= maxIndex) {
              var subNode = node.nodes[this._reverse ? maxIndex - index : index];
              if (subNode) {
                if (subNode.entry) {
                  return mapIteratorValue2(type, subNode.entry);
                }
                stack = this._stack = mapIteratorFrame2(subNode, stack);
              }
              continue;
            }
          }
          stack = this._stack = this._stack.__prev;
        }
        return iteratorDone2();
      };
      function mapIteratorValue2(type, entry) {
        return iteratorValue2(type, entry[0], entry[1]);
      }
      function mapIteratorFrame2(node, prev) {
        return {
          node,
          index: 0,
          __prev: prev
        };
      }
      function makeMap2(size, root, ownerID, hash22) {
        var map3 = Object.create(MapPrototype2);
        map3.size = size;
        map3._root = root;
        map3.__ownerID = ownerID;
        map3.__hash = hash22;
        map3.__altered = false;
        return map3;
      }
      var EMPTY_MAP2;
      function emptyMap2() {
        return EMPTY_MAP2 || (EMPTY_MAP2 = makeMap2(0));
      }
      function updateMap2(map3, k2, v2) {
        var newRoot;
        var newSize;
        if (!map3._root) {
          if (v2 === NOT_SET2) {
            return map3;
          }
          newSize = 1;
          newRoot = new ArrayMapNode3(map3.__ownerID, [[k2, v2]]);
        } else {
          var didChangeSize = MakeRef2(CHANGE_LENGTH);
          var didAlter = MakeRef2(DID_ALTER);
          newRoot = updateNode2(map3._root, map3.__ownerID, 0, void 0, k2, v2, didChangeSize, didAlter);
          if (!didAlter.value) {
            return map3;
          }
          newSize = map3.size + (didChangeSize.value ? v2 === NOT_SET2 ? -1 : 1 : 0);
        }
        if (map3.__ownerID) {
          map3.size = newSize;
          map3._root = newRoot;
          map3.__hash = void 0;
          map3.__altered = true;
          return map3;
        }
        return newRoot ? makeMap2(newSize, newRoot) : emptyMap2();
      }
      function updateNode2(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (!node) {
          if (value === NOT_SET2) {
            return node;
          }
          SetRef2(didAlter);
          SetRef2(didChangeSize);
          return new ValueNode3(ownerID, keyHash, [key, value]);
        }
        return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
      }
      function isLeafNode2(node) {
        return node.constructor === ValueNode3 || node.constructor === HashCollisionNode3;
      }
      function mergeIntoNode2(node, ownerID, shift, keyHash, entry) {
        if (node.keyHash === keyHash) {
          return new HashCollisionNode3(ownerID, keyHash, [node.entry, entry]);
        }
        var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK2;
        var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK2;
        var newNode;
        var nodes = idx1 === idx2 ? [mergeIntoNode2(node, ownerID, shift + SHIFT2, keyHash, entry)] : (newNode = new ValueNode3(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
        return new BitmapIndexedNode3(ownerID, 1 << idx1 | 1 << idx2, nodes);
      }
      function createNodes2(ownerID, entries3, key, value) {
        if (!ownerID) {
          ownerID = new OwnerID2();
        }
        var node = new ValueNode3(ownerID, hash2(key), [key, value]);
        for (var ii = 0; ii < entries3.length; ii++) {
          var entry = entries3[ii];
          node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
        }
        return node;
      }
      function packNodes2(ownerID, nodes, count2, excluding) {
        var bitmap = 0;
        var packedII = 0;
        var packedNodes = new Array(count2);
        for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
          var node = nodes[ii];
          if (node !== void 0 && ii !== excluding) {
            bitmap |= bit;
            packedNodes[packedII++] = node;
          }
        }
        return new BitmapIndexedNode3(ownerID, bitmap, packedNodes);
      }
      function expandNodes2(ownerID, nodes, bitmap, including, node) {
        var count2 = 0;
        var expandedNodes = new Array(SIZE2);
        for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
          expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
        }
        expandedNodes[including] = node;
        return new HashArrayMapNode3(ownerID, count2 + 1, expandedNodes);
      }
      function mergeIntoMapWith(map3, merger, iterables) {
        var iters = [];
        for (var ii = 0; ii < iterables.length; ii++) {
          var value = iterables[ii];
          var iter = KeyedIterable(value);
          if (!isIterable(value)) {
            iter = iter.map(function(v2) {
              return fromJS2(v2);
            });
          }
          iters.push(iter);
        }
        return mergeIntoCollectionWith(map3, merger, iters);
      }
      function deepMerger(existing, value, key) {
        return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is2(existing, value) ? existing : value;
      }
      function deepMergerWith2(merger) {
        return function(existing, value, key) {
          if (existing && existing.mergeDeepWith && isIterable(value)) {
            return existing.mergeDeepWith(merger, value);
          }
          var nextValue = merger(existing, value, key);
          return is2(existing, nextValue) ? existing : nextValue;
        };
      }
      function mergeIntoCollectionWith(collection, merger, iters) {
        iters = iters.filter(function(x2) {
          return x2.size !== 0;
        });
        if (iters.length === 0) {
          return collection;
        }
        if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
          return collection.constructor(iters[0]);
        }
        return collection.withMutations(function(collection2) {
          var mergeIntoMap = merger ? function(value, key) {
            collection2.update(
              key,
              NOT_SET2,
              function(existing) {
                return existing === NOT_SET2 ? value : merger(existing, value, key);
              }
            );
          } : function(value, key) {
            collection2.set(key, value);
          };
          for (var ii = 0; ii < iters.length; ii++) {
            iters[ii].forEach(mergeIntoMap);
          }
        });
      }
      function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
        var isNotSet = existing === NOT_SET2;
        var step = keyPathIter.next();
        if (step.done) {
          var existingValue = isNotSet ? notSetValue : existing;
          var newValue = updater(existingValue);
          return newValue === existingValue ? existing : newValue;
        }
        invariant2(
          isNotSet || existing && existing.set,
          "invalid keyPath"
        );
        var key = step.value;
        var nextExisting = isNotSet ? NOT_SET2 : existing.get(key, NOT_SET2);
        var nextUpdated = updateInDeepMap(
          nextExisting,
          keyPathIter,
          notSetValue,
          updater
        );
        return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET2 ? existing.remove(key) : (isNotSet ? emptyMap2() : existing).set(key, nextUpdated);
      }
      function popCount2(x2) {
        x2 = x2 - (x2 >> 1 & 1431655765);
        x2 = (x2 & 858993459) + (x2 >> 2 & 858993459);
        x2 = x2 + (x2 >> 4) & 252645135;
        x2 = x2 + (x2 >> 8);
        x2 = x2 + (x2 >> 16);
        return x2 & 127;
      }
      function setIn2(array2, idx, val, canEdit) {
        var newArray = canEdit ? array2 : arrCopy2(array2);
        newArray[idx] = val;
        return newArray;
      }
      function spliceIn2(array2, idx, val, canEdit) {
        var newLen = array2.length + 1;
        if (canEdit && idx + 1 === newLen) {
          array2[idx] = val;
          return array2;
        }
        var newArray = new Array(newLen);
        var after = 0;
        for (var ii = 0; ii < newLen; ii++) {
          if (ii === idx) {
            newArray[ii] = val;
            after = -1;
          } else {
            newArray[ii] = array2[ii + after];
          }
        }
        return newArray;
      }
      function spliceOut2(array2, idx, canEdit) {
        var newLen = array2.length - 1;
        if (canEdit && idx === newLen) {
          array2.pop();
          return array2;
        }
        var newArray = new Array(newLen);
        var after = 0;
        for (var ii = 0; ii < newLen; ii++) {
          if (ii === idx) {
            after = 1;
          }
          newArray[ii] = array2[ii + after];
        }
        return newArray;
      }
      var MAX_ARRAY_MAP_SIZE2 = SIZE2 / 4;
      var MAX_BITMAP_INDEXED_SIZE2 = SIZE2 / 2;
      var MIN_HASH_ARRAY_MAP_SIZE2 = SIZE2 / 4;
      createClass(List2, IndexedCollection2);
      function List2(value) {
        var empty = emptyList2();
        if (value === null || value === void 0) {
          return empty;
        }
        if (isList2(value)) {
          return value;
        }
        var iter = IndexedIterable(value);
        var size = iter.size;
        if (size === 0) {
          return empty;
        }
        assertNotInfinite2(size);
        if (size > 0 && size < SIZE2) {
          return makeList2(0, size, SHIFT2, null, new VNode3(iter.toArray()));
        }
        return empty.withMutations(function(list) {
          list.setSize(size);
          iter.forEach(function(v2, i2) {
            return list.set(i2, v2);
          });
        });
      }
      List2.of = function() {
        return this(arguments);
      };
      List2.prototype.toString = function() {
        return this.__toString("List [", "]");
      };
      List2.prototype.get = function(index, notSetValue) {
        index = wrapIndex2(this, index);
        if (index >= 0 && index < this.size) {
          index += this._origin;
          var node = listNodeFor2(this, index);
          return node && node.array[index & MASK2];
        }
        return notSetValue;
      };
      List2.prototype.set = function(index, value) {
        return updateList2(this, index, value);
      };
      List2.prototype.remove = function(index) {
        return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
      };
      List2.prototype.insert = function(index, value) {
        return this.splice(index, 0, value);
      };
      List2.prototype.clear = function() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = this._origin = this._capacity = 0;
          this._level = SHIFT2;
          this._root = this._tail = null;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyList2();
      };
      List2.prototype.push = function() {
        var values2 = arguments;
        var oldSize = this.size;
        return this.withMutations(function(list) {
          setListBounds2(list, 0, oldSize + values2.length);
          for (var ii = 0; ii < values2.length; ii++) {
            list.set(oldSize + ii, values2[ii]);
          }
        });
      };
      List2.prototype.pop = function() {
        return setListBounds2(this, 0, -1);
      };
      List2.prototype.unshift = function() {
        var values2 = arguments;
        return this.withMutations(function(list) {
          setListBounds2(list, -values2.length);
          for (var ii = 0; ii < values2.length; ii++) {
            list.set(ii, values2[ii]);
          }
        });
      };
      List2.prototype.shift = function() {
        return setListBounds2(this, 1);
      };
      List2.prototype.merge = function() {
        return mergeIntoListWith(this, void 0, arguments);
      };
      List2.prototype.mergeWith = function(merger) {
        var iters = SLICE$0.call(arguments, 1);
        return mergeIntoListWith(this, merger, iters);
      };
      List2.prototype.mergeDeep = function() {
        return mergeIntoListWith(this, deepMerger, arguments);
      };
      List2.prototype.mergeDeepWith = function(merger) {
        var iters = SLICE$0.call(arguments, 1);
        return mergeIntoListWith(this, deepMergerWith2(merger), iters);
      };
      List2.prototype.setSize = function(size) {
        return setListBounds2(this, 0, size);
      };
      List2.prototype.slice = function(begin, end) {
        var size = this.size;
        if (wholeSlice2(begin, end, size)) {
          return this;
        }
        return setListBounds2(
          this,
          resolveBegin2(begin, size),
          resolveEnd2(end, size)
        );
      };
      List2.prototype.__iterator = function(type, reverse3) {
        var index = 0;
        var values2 = iterateList2(this, reverse3);
        return new Iterator3(function() {
          var value = values2();
          return value === DONE2 ? iteratorDone2() : iteratorValue2(type, index++, value);
        });
      };
      List2.prototype.__iterate = function(fn2, reverse3) {
        var index = 0;
        var values2 = iterateList2(this, reverse3);
        var value;
        while ((value = values2()) !== DONE2) {
          if (fn2(value, index++, this) === false) {
            break;
          }
        }
        return index;
      };
      List2.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          this.__ownerID = ownerID;
          return this;
        }
        return makeList2(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
      };
      function isList2(maybeList) {
        return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
      }
      List2.isList = isList2;
      var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
      var ListPrototype2 = List2.prototype;
      ListPrototype2[IS_LIST_SENTINEL] = true;
      ListPrototype2[DELETE2] = ListPrototype2.remove;
      ListPrototype2.setIn = MapPrototype2.setIn;
      ListPrototype2.deleteIn = ListPrototype2.removeIn = MapPrototype2.removeIn;
      ListPrototype2.update = MapPrototype2.update;
      ListPrototype2.updateIn = MapPrototype2.updateIn;
      ListPrototype2.mergeIn = MapPrototype2.mergeIn;
      ListPrototype2.mergeDeepIn = MapPrototype2.mergeDeepIn;
      ListPrototype2.withMutations = MapPrototype2.withMutations;
      ListPrototype2.asMutable = MapPrototype2.asMutable;
      ListPrototype2.asImmutable = MapPrototype2.asImmutable;
      ListPrototype2.wasAltered = MapPrototype2.wasAltered;
      function VNode3(array2, ownerID) {
        this.array = array2;
        this.ownerID = ownerID;
      }
      VNode3.prototype.removeBefore = function(ownerID, level, index) {
        if (index === level ? 1 << level : this.array.length === 0) {
          return this;
        }
        var originIndex = index >>> level & MASK2;
        if (originIndex >= this.array.length) {
          return new VNode3([], ownerID);
        }
        var removingFirst = originIndex === 0;
        var newChild;
        if (level > 0) {
          var oldChild = this.array[originIndex];
          newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT2, index);
          if (newChild === oldChild && removingFirst) {
            return this;
          }
        }
        if (removingFirst && !newChild) {
          return this;
        }
        var editable = editableVNode2(this, ownerID);
        if (!removingFirst) {
          for (var ii = 0; ii < originIndex; ii++) {
            editable.array[ii] = void 0;
          }
        }
        if (newChild) {
          editable.array[originIndex] = newChild;
        }
        return editable;
      };
      VNode3.prototype.removeAfter = function(ownerID, level, index) {
        if (index === (level ? 1 << level : 0) || this.array.length === 0) {
          return this;
        }
        var sizeIndex = index - 1 >>> level & MASK2;
        if (sizeIndex >= this.array.length) {
          return this;
        }
        var newChild;
        if (level > 0) {
          var oldChild = this.array[sizeIndex];
          newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT2, index);
          if (newChild === oldChild && sizeIndex === this.array.length - 1) {
            return this;
          }
        }
        var editable = editableVNode2(this, ownerID);
        editable.array.splice(sizeIndex + 1);
        if (newChild) {
          editable.array[sizeIndex] = newChild;
        }
        return editable;
      };
      var DONE2 = {};
      function iterateList2(list, reverse3) {
        var left = list._origin;
        var right = list._capacity;
        var tailPos = getTailOffset2(right);
        var tail = list._tail;
        return iterateNodeOrLeaf(list._root, list._level, 0);
        function iterateNodeOrLeaf(node, level, offset) {
          return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
        }
        function iterateLeaf(node, offset) {
          var array2 = offset === tailPos ? tail && tail.array : node && node.array;
          var from = offset > left ? 0 : left - offset;
          var to2 = right - offset;
          if (to2 > SIZE2) {
            to2 = SIZE2;
          }
          return function() {
            if (from === to2) {
              return DONE2;
            }
            var idx = reverse3 ? --to2 : from++;
            return array2 && array2[idx];
          };
        }
        function iterateNode(node, level, offset) {
          var values2;
          var array2 = node && node.array;
          var from = offset > left ? 0 : left - offset >> level;
          var to2 = (right - offset >> level) + 1;
          if (to2 > SIZE2) {
            to2 = SIZE2;
          }
          return function() {
            do {
              if (values2) {
                var value = values2();
                if (value !== DONE2) {
                  return value;
                }
                values2 = null;
              }
              if (from === to2) {
                return DONE2;
              }
              var idx = reverse3 ? --to2 : from++;
              values2 = iterateNodeOrLeaf(
                array2 && array2[idx],
                level - SHIFT2,
                offset + (idx << level)
              );
            } while (true);
          };
        }
      }
      function makeList2(origin, capacity, level, root, tail, ownerID, hash22) {
        var list = Object.create(ListPrototype2);
        list.size = capacity - origin;
        list._origin = origin;
        list._capacity = capacity;
        list._level = level;
        list._root = root;
        list._tail = tail;
        list.__ownerID = ownerID;
        list.__hash = hash22;
        list.__altered = false;
        return list;
      }
      var EMPTY_LIST2;
      function emptyList2() {
        return EMPTY_LIST2 || (EMPTY_LIST2 = makeList2(0, 0, SHIFT2));
      }
      function updateList2(list, index, value) {
        index = wrapIndex2(list, index);
        if (index !== index) {
          return list;
        }
        if (index >= list.size || index < 0) {
          return list.withMutations(function(list2) {
            index < 0 ? setListBounds2(list2, index).set(0, value) : setListBounds2(list2, 0, index + 1).set(index, value);
          });
        }
        index += list._origin;
        var newTail = list._tail;
        var newRoot = list._root;
        var didAlter = MakeRef2(DID_ALTER);
        if (index >= getTailOffset2(list._capacity)) {
          newTail = updateVNode2(newTail, list.__ownerID, 0, index, value, didAlter);
        } else {
          newRoot = updateVNode2(newRoot, list.__ownerID, list._level, index, value, didAlter);
        }
        if (!didAlter.value) {
          return list;
        }
        if (list.__ownerID) {
          list._root = newRoot;
          list._tail = newTail;
          list.__hash = void 0;
          list.__altered = true;
          return list;
        }
        return makeList2(list._origin, list._capacity, list._level, newRoot, newTail);
      }
      function updateVNode2(node, ownerID, level, index, value, didAlter) {
        var idx = index >>> level & MASK2;
        var nodeHas = node && idx < node.array.length;
        if (!nodeHas && value === void 0) {
          return node;
        }
        var newNode;
        if (level > 0) {
          var lowerNode = node && node.array[idx];
          var newLowerNode = updateVNode2(lowerNode, ownerID, level - SHIFT2, index, value, didAlter);
          if (newLowerNode === lowerNode) {
            return node;
          }
          newNode = editableVNode2(node, ownerID);
          newNode.array[idx] = newLowerNode;
          return newNode;
        }
        if (nodeHas && node.array[idx] === value) {
          return node;
        }
        SetRef2(didAlter);
        newNode = editableVNode2(node, ownerID);
        if (value === void 0 && idx === newNode.array.length - 1) {
          newNode.array.pop();
        } else {
          newNode.array[idx] = value;
        }
        return newNode;
      }
      function editableVNode2(node, ownerID) {
        if (ownerID && node && ownerID === node.ownerID) {
          return node;
        }
        return new VNode3(node ? node.array.slice() : [], ownerID);
      }
      function listNodeFor2(list, rawIndex) {
        if (rawIndex >= getTailOffset2(list._capacity)) {
          return list._tail;
        }
        if (rawIndex < 1 << list._level + SHIFT2) {
          var node = list._root;
          var level = list._level;
          while (node && level > 0) {
            node = node.array[rawIndex >>> level & MASK2];
            level -= SHIFT2;
          }
          return node;
        }
      }
      function setListBounds2(list, begin, end) {
        if (begin !== void 0) {
          begin = begin | 0;
        }
        if (end !== void 0) {
          end = end | 0;
        }
        var owner = list.__ownerID || new OwnerID2();
        var oldOrigin = list._origin;
        var oldCapacity = list._capacity;
        var newOrigin = oldOrigin + begin;
        var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
        if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
          return list;
        }
        if (newOrigin >= newCapacity) {
          return list.clear();
        }
        var newLevel = list._level;
        var newRoot = list._root;
        var offsetShift = 0;
        while (newOrigin + offsetShift < 0) {
          newRoot = new VNode3(newRoot && newRoot.array.length ? [void 0, newRoot] : [], owner);
          newLevel += SHIFT2;
          offsetShift += 1 << newLevel;
        }
        if (offsetShift) {
          newOrigin += offsetShift;
          oldOrigin += offsetShift;
          newCapacity += offsetShift;
          oldCapacity += offsetShift;
        }
        var oldTailOffset = getTailOffset2(oldCapacity);
        var newTailOffset = getTailOffset2(newCapacity);
        while (newTailOffset >= 1 << newLevel + SHIFT2) {
          newRoot = new VNode3(newRoot && newRoot.array.length ? [newRoot] : [], owner);
          newLevel += SHIFT2;
        }
        var oldTail = list._tail;
        var newTail = newTailOffset < oldTailOffset ? listNodeFor2(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode3([], owner) : oldTail;
        if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
          newRoot = editableVNode2(newRoot, owner);
          var node = newRoot;
          for (var level = newLevel; level > SHIFT2; level -= SHIFT2) {
            var idx = oldTailOffset >>> level & MASK2;
            node = node.array[idx] = editableVNode2(node.array[idx], owner);
          }
          node.array[oldTailOffset >>> SHIFT2 & MASK2] = oldTail;
        }
        if (newCapacity < oldCapacity) {
          newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
        }
        if (newOrigin >= newTailOffset) {
          newOrigin -= newTailOffset;
          newCapacity -= newTailOffset;
          newLevel = SHIFT2;
          newRoot = null;
          newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
        } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
          offsetShift = 0;
          while (newRoot) {
            var beginIndex = newOrigin >>> newLevel & MASK2;
            if (beginIndex !== newTailOffset >>> newLevel & MASK2) {
              break;
            }
            if (beginIndex) {
              offsetShift += (1 << newLevel) * beginIndex;
            }
            newLevel -= SHIFT2;
            newRoot = newRoot.array[beginIndex];
          }
          if (newRoot && newOrigin > oldOrigin) {
            newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
          }
          if (newRoot && newTailOffset < oldTailOffset) {
            newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
          }
          if (offsetShift) {
            newOrigin -= offsetShift;
            newCapacity -= offsetShift;
          }
        }
        if (list.__ownerID) {
          list.size = newCapacity - newOrigin;
          list._origin = newOrigin;
          list._capacity = newCapacity;
          list._level = newLevel;
          list._root = newRoot;
          list._tail = newTail;
          list.__hash = void 0;
          list.__altered = true;
          return list;
        }
        return makeList2(newOrigin, newCapacity, newLevel, newRoot, newTail);
      }
      function mergeIntoListWith(list, merger, iterables) {
        var iters = [];
        var maxSize = 0;
        for (var ii = 0; ii < iterables.length; ii++) {
          var value = iterables[ii];
          var iter = IndexedIterable(value);
          if (iter.size > maxSize) {
            maxSize = iter.size;
          }
          if (!isIterable(value)) {
            iter = iter.map(function(v2) {
              return fromJS2(v2);
            });
          }
          iters.push(iter);
        }
        if (maxSize > list.size) {
          list = list.setSize(maxSize);
        }
        return mergeIntoCollectionWith(list, merger, iters);
      }
      function getTailOffset2(size) {
        return size < SIZE2 ? 0 : size - 1 >>> SHIFT2 << SHIFT2;
      }
      createClass(OrderedMap2, Map2);
      function OrderedMap2(value) {
        return value === null || value === void 0 ? emptyOrderedMap2() : isOrderedMap2(value) ? value : emptyOrderedMap2().withMutations(function(map3) {
          var iter = KeyedIterable(value);
          assertNotInfinite2(iter.size);
          iter.forEach(function(v2, k2) {
            return map3.set(k2, v2);
          });
        });
      }
      OrderedMap2.of = function() {
        return this(arguments);
      };
      OrderedMap2.prototype.toString = function() {
        return this.__toString("OrderedMap {", "}");
      };
      OrderedMap2.prototype.get = function(k2, notSetValue) {
        var index = this._map.get(k2);
        return index !== void 0 ? this._list.get(index)[1] : notSetValue;
      };
      OrderedMap2.prototype.clear = function() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._map.clear();
          this._list.clear();
          return this;
        }
        return emptyOrderedMap2();
      };
      OrderedMap2.prototype.set = function(k2, v2) {
        return updateOrderedMap2(this, k2, v2);
      };
      OrderedMap2.prototype.remove = function(k2) {
        return updateOrderedMap2(this, k2, NOT_SET2);
      };
      OrderedMap2.prototype.wasAltered = function() {
        return this._map.wasAltered() || this._list.wasAltered();
      };
      OrderedMap2.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        return this._list.__iterate(
          function(entry) {
            return entry && fn2(entry[1], entry[0], this$0);
          },
          reverse3
        );
      };
      OrderedMap2.prototype.__iterator = function(type, reverse3) {
        return this._list.fromEntrySeq().__iterator(type, reverse3);
      };
      OrderedMap2.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        var newList = this._list.__ensureOwner(ownerID);
        if (!ownerID) {
          this.__ownerID = ownerID;
          this._map = newMap;
          this._list = newList;
          return this;
        }
        return makeOrderedMap2(newMap, newList, ownerID, this.__hash);
      };
      function isOrderedMap2(maybeOrderedMap) {
        return isMap2(maybeOrderedMap) && isOrdered2(maybeOrderedMap);
      }
      OrderedMap2.isOrderedMap = isOrderedMap2;
      OrderedMap2.prototype[IS_ORDERED_SENTINEL] = true;
      OrderedMap2.prototype[DELETE2] = OrderedMap2.prototype.remove;
      function makeOrderedMap2(map3, list, ownerID, hash22) {
        var omap = Object.create(OrderedMap2.prototype);
        omap.size = map3 ? map3.size : 0;
        omap._map = map3;
        omap._list = list;
        omap.__ownerID = ownerID;
        omap.__hash = hash22;
        return omap;
      }
      var EMPTY_ORDERED_MAP2;
      function emptyOrderedMap2() {
        return EMPTY_ORDERED_MAP2 || (EMPTY_ORDERED_MAP2 = makeOrderedMap2(emptyMap2(), emptyList2()));
      }
      function updateOrderedMap2(omap, k2, v2) {
        var map3 = omap._map;
        var list = omap._list;
        var i2 = map3.get(k2);
        var has5 = i2 !== void 0;
        var newMap;
        var newList;
        if (v2 === NOT_SET2) {
          if (!has5) {
            return omap;
          }
          if (list.size >= SIZE2 && list.size >= map3.size * 2) {
            newList = list.filter(function(entry, idx) {
              return entry !== void 0 && i2 !== idx;
            });
            newMap = newList.toKeyedSeq().map(function(entry) {
              return entry[0];
            }).flip().toMap();
            if (omap.__ownerID) {
              newMap.__ownerID = newList.__ownerID = omap.__ownerID;
            }
          } else {
            newMap = map3.remove(k2);
            newList = i2 === list.size - 1 ? list.pop() : list.set(i2, void 0);
          }
        } else {
          if (has5) {
            if (v2 === list.get(i2)[1]) {
              return omap;
            }
            newMap = map3;
            newList = list.set(i2, [k2, v2]);
          } else {
            newMap = map3.set(k2, list.size);
            newList = list.set(list.size, [k2, v2]);
          }
        }
        if (omap.__ownerID) {
          omap.size = newMap.size;
          omap._map = newMap;
          omap._list = newList;
          omap.__hash = void 0;
          return omap;
        }
        return makeOrderedMap2(newMap, newList);
      }
      createClass(ToKeyedSequence2, KeyedSeq2);
      function ToKeyedSequence2(indexed, useKeys) {
        this._iter = indexed;
        this._useKeys = useKeys;
        this.size = indexed.size;
      }
      ToKeyedSequence2.prototype.get = function(key, notSetValue) {
        return this._iter.get(key, notSetValue);
      };
      ToKeyedSequence2.prototype.has = function(key) {
        return this._iter.has(key);
      };
      ToKeyedSequence2.prototype.valueSeq = function() {
        return this._iter.valueSeq();
      };
      ToKeyedSequence2.prototype.reverse = function() {
        var this$0 = this;
        var reversedSequence = reverseFactory2(this, true);
        if (!this._useKeys) {
          reversedSequence.valueSeq = function() {
            return this$0._iter.toSeq().reverse();
          };
        }
        return reversedSequence;
      };
      ToKeyedSequence2.prototype.map = function(mapper, context2) {
        var this$0 = this;
        var mappedSequence = mapFactory2(this, mapper, context2);
        if (!this._useKeys) {
          mappedSequence.valueSeq = function() {
            return this$0._iter.toSeq().map(mapper, context2);
          };
        }
        return mappedSequence;
      };
      ToKeyedSequence2.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        var ii;
        return this._iter.__iterate(
          this._useKeys ? function(v2, k2) {
            return fn2(v2, k2, this$0);
          } : (ii = reverse3 ? resolveSize(this) : 0, function(v2) {
            return fn2(v2, reverse3 ? --ii : ii++, this$0);
          }),
          reverse3
        );
      };
      ToKeyedSequence2.prototype.__iterator = function(type, reverse3) {
        if (this._useKeys) {
          return this._iter.__iterator(type, reverse3);
        }
        var iterator = this._iter.__iterator(ITERATE_VALUES2, reverse3);
        var ii = reverse3 ? resolveSize(this) : 0;
        return new Iterator3(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue2(type, reverse3 ? --ii : ii++, step.value, step);
        });
      };
      ToKeyedSequence2.prototype[IS_ORDERED_SENTINEL] = true;
      createClass(ToIndexedSequence2, IndexedSeq2);
      function ToIndexedSequence2(iter) {
        this._iter = iter;
        this.size = iter.size;
      }
      ToIndexedSequence2.prototype.includes = function(value) {
        return this._iter.includes(value);
      };
      ToIndexedSequence2.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        var iterations = 0;
        return this._iter.__iterate(function(v2) {
          return fn2(v2, iterations++, this$0);
        }, reverse3);
      };
      ToIndexedSequence2.prototype.__iterator = function(type, reverse3) {
        var iterator = this._iter.__iterator(ITERATE_VALUES2, reverse3);
        var iterations = 0;
        return new Iterator3(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue2(type, iterations++, step.value, step);
        });
      };
      createClass(ToSetSequence2, SetSeq2);
      function ToSetSequence2(iter) {
        this._iter = iter;
        this.size = iter.size;
      }
      ToSetSequence2.prototype.has = function(key) {
        return this._iter.includes(key);
      };
      ToSetSequence2.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        return this._iter.__iterate(function(v2) {
          return fn2(v2, v2, this$0);
        }, reverse3);
      };
      ToSetSequence2.prototype.__iterator = function(type, reverse3) {
        var iterator = this._iter.__iterator(ITERATE_VALUES2, reverse3);
        return new Iterator3(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue2(type, step.value, step.value, step);
        });
      };
      createClass(FromEntriesSequence2, KeyedSeq2);
      function FromEntriesSequence2(entries3) {
        this._iter = entries3;
        this.size = entries3.size;
      }
      FromEntriesSequence2.prototype.entrySeq = function() {
        return this._iter.toSeq();
      };
      FromEntriesSequence2.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        return this._iter.__iterate(function(entry) {
          if (entry) {
            validateEntry2(entry);
            var indexedIterable = isIterable(entry);
            return fn2(
              indexedIterable ? entry.get(1) : entry[1],
              indexedIterable ? entry.get(0) : entry[0],
              this$0
            );
          }
        }, reverse3);
      };
      FromEntriesSequence2.prototype.__iterator = function(type, reverse3) {
        var iterator = this._iter.__iterator(ITERATE_VALUES2, reverse3);
        return new Iterator3(function() {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            if (entry) {
              validateEntry2(entry);
              var indexedIterable = isIterable(entry);
              return iteratorValue2(
                type,
                indexedIterable ? entry.get(0) : entry[0],
                indexedIterable ? entry.get(1) : entry[1],
                step
              );
            }
          }
        });
      };
      ToIndexedSequence2.prototype.cacheResult = ToKeyedSequence2.prototype.cacheResult = ToSetSequence2.prototype.cacheResult = FromEntriesSequence2.prototype.cacheResult = cacheResultThrough2;
      function flipFactory2(iterable) {
        var flipSequence = makeSequence2(iterable);
        flipSequence._iter = iterable;
        flipSequence.size = iterable.size;
        flipSequence.flip = function() {
          return iterable;
        };
        flipSequence.reverse = function() {
          var reversedSequence = iterable.reverse.apply(this);
          reversedSequence.flip = function() {
            return iterable.reverse();
          };
          return reversedSequence;
        };
        flipSequence.has = function(key) {
          return iterable.includes(key);
        };
        flipSequence.includes = function(key) {
          return iterable.has(key);
        };
        flipSequence.cacheResult = cacheResultThrough2;
        flipSequence.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          return iterable.__iterate(function(v2, k2) {
            return fn2(k2, v2, this$0) !== false;
          }, reverse3);
        };
        flipSequence.__iteratorUncached = function(type, reverse3) {
          if (type === ITERATE_ENTRIES2) {
            var iterator = iterable.__iterator(type, reverse3);
            return new Iterator3(function() {
              var step = iterator.next();
              if (!step.done) {
                var k2 = step.value[0];
                step.value[0] = step.value[1];
                step.value[1] = k2;
              }
              return step;
            });
          }
          return iterable.__iterator(
            type === ITERATE_VALUES2 ? ITERATE_KEYS2 : ITERATE_VALUES2,
            reverse3
          );
        };
        return flipSequence;
      }
      function mapFactory2(iterable, mapper, context2) {
        var mappedSequence = makeSequence2(iterable);
        mappedSequence.size = iterable.size;
        mappedSequence.has = function(key) {
          return iterable.has(key);
        };
        mappedSequence.get = function(key, notSetValue) {
          var v2 = iterable.get(key, NOT_SET2);
          return v2 === NOT_SET2 ? notSetValue : mapper.call(context2, v2, key, iterable);
        };
        mappedSequence.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          return iterable.__iterate(
            function(v2, k2, c2) {
              return fn2(mapper.call(context2, v2, k2, c2), k2, this$0) !== false;
            },
            reverse3
          );
        };
        mappedSequence.__iteratorUncached = function(type, reverse3) {
          var iterator = iterable.__iterator(ITERATE_ENTRIES2, reverse3);
          return new Iterator3(function() {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            var key = entry[0];
            return iteratorValue2(
              type,
              key,
              mapper.call(context2, entry[1], key, iterable),
              step
            );
          });
        };
        return mappedSequence;
      }
      function reverseFactory2(iterable, useKeys) {
        var reversedSequence = makeSequence2(iterable);
        reversedSequence._iter = iterable;
        reversedSequence.size = iterable.size;
        reversedSequence.reverse = function() {
          return iterable;
        };
        if (iterable.flip) {
          reversedSequence.flip = function() {
            var flipSequence = flipFactory2(iterable);
            flipSequence.reverse = function() {
              return iterable.flip();
            };
            return flipSequence;
          };
        }
        reversedSequence.get = function(key, notSetValue) {
          return iterable.get(useKeys ? key : -1 - key, notSetValue);
        };
        reversedSequence.has = function(key) {
          return iterable.has(useKeys ? key : -1 - key);
        };
        reversedSequence.includes = function(value) {
          return iterable.includes(value);
        };
        reversedSequence.cacheResult = cacheResultThrough2;
        reversedSequence.__iterate = function(fn2, reverse3) {
          var this$0 = this;
          return iterable.__iterate(function(v2, k2) {
            return fn2(v2, k2, this$0);
          }, !reverse3);
        };
        reversedSequence.__iterator = function(type, reverse3) {
          return iterable.__iterator(type, !reverse3);
        };
        return reversedSequence;
      }
      function filterFactory2(iterable, predicate, context2, useKeys) {
        var filterSequence = makeSequence2(iterable);
        if (useKeys) {
          filterSequence.has = function(key) {
            var v2 = iterable.get(key, NOT_SET2);
            return v2 !== NOT_SET2 && !!predicate.call(context2, v2, key, iterable);
          };
          filterSequence.get = function(key, notSetValue) {
            var v2 = iterable.get(key, NOT_SET2);
            return v2 !== NOT_SET2 && predicate.call(context2, v2, key, iterable) ? v2 : notSetValue;
          };
        }
        filterSequence.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          var iterations = 0;
          iterable.__iterate(function(v2, k2, c2) {
            if (predicate.call(context2, v2, k2, c2)) {
              iterations++;
              return fn2(v2, useKeys ? k2 : iterations - 1, this$0);
            }
          }, reverse3);
          return iterations;
        };
        filterSequence.__iteratorUncached = function(type, reverse3) {
          var iterator = iterable.__iterator(ITERATE_ENTRIES2, reverse3);
          var iterations = 0;
          return new Iterator3(function() {
            while (true) {
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              var key = entry[0];
              var value = entry[1];
              if (predicate.call(context2, value, key, iterable)) {
                return iteratorValue2(type, useKeys ? key : iterations++, value, step);
              }
            }
          });
        };
        return filterSequence;
      }
      function countByFactory2(iterable, grouper, context2) {
        var groups = Map2().asMutable();
        iterable.__iterate(function(v2, k2) {
          groups.update(
            grouper.call(context2, v2, k2, iterable),
            0,
            function(a2) {
              return a2 + 1;
            }
          );
        });
        return groups.asImmutable();
      }
      function groupByFactory2(iterable, grouper, context2) {
        var isKeyedIter = isKeyed2(iterable);
        var groups = (isOrdered2(iterable) ? OrderedMap2() : Map2()).asMutable();
        iterable.__iterate(function(v2, k2) {
          groups.update(
            grouper.call(context2, v2, k2, iterable),
            function(a2) {
              return a2 = a2 || [], a2.push(isKeyedIter ? [k2, v2] : v2), a2;
            }
          );
        });
        var coerce = iterableClass(iterable);
        return groups.map(function(arr2) {
          return reify2(iterable, coerce(arr2));
        });
      }
      function sliceFactory2(iterable, begin, end, useKeys) {
        var originalSize = iterable.size;
        if (begin !== void 0) {
          begin = begin | 0;
        }
        if (end !== void 0) {
          end = end | 0;
        }
        if (wholeSlice2(begin, end, originalSize)) {
          return iterable;
        }
        var resolvedBegin = resolveBegin2(begin, originalSize);
        var resolvedEnd = resolveEnd2(end, originalSize);
        if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
          return sliceFactory2(iterable.toSeq().cacheResult(), begin, end, useKeys);
        }
        var resolvedSize = resolvedEnd - resolvedBegin;
        var sliceSize;
        if (resolvedSize === resolvedSize) {
          sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
        }
        var sliceSeq = makeSequence2(iterable);
        sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || void 0;
        if (!useKeys && isSeq2(iterable) && sliceSize >= 0) {
          sliceSeq.get = function(index, notSetValue) {
            index = wrapIndex2(this, index);
            return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
          };
        }
        sliceSeq.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          if (sliceSize === 0) {
            return 0;
          }
          if (reverse3) {
            return this.cacheResult().__iterate(fn2, reverse3);
          }
          var skipped = 0;
          var isSkipping = true;
          var iterations = 0;
          iterable.__iterate(function(v2, k2) {
            if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
              iterations++;
              return fn2(v2, useKeys ? k2 : iterations - 1, this$0) !== false && iterations !== sliceSize;
            }
          });
          return iterations;
        };
        sliceSeq.__iteratorUncached = function(type, reverse3) {
          if (sliceSize !== 0 && reverse3) {
            return this.cacheResult().__iterator(type, reverse3);
          }
          var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse3);
          var skipped = 0;
          var iterations = 0;
          return new Iterator3(function() {
            while (skipped++ < resolvedBegin) {
              iterator.next();
            }
            if (++iterations > sliceSize) {
              return iteratorDone2();
            }
            var step = iterator.next();
            if (useKeys || type === ITERATE_VALUES2) {
              return step;
            } else if (type === ITERATE_KEYS2) {
              return iteratorValue2(type, iterations - 1, void 0, step);
            } else {
              return iteratorValue2(type, iterations - 1, step.value[1], step);
            }
          });
        };
        return sliceSeq;
      }
      function takeWhileFactory2(iterable, predicate, context2) {
        var takeSequence = makeSequence2(iterable);
        takeSequence.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          if (reverse3) {
            return this.cacheResult().__iterate(fn2, reverse3);
          }
          var iterations = 0;
          iterable.__iterate(
            function(v2, k2, c2) {
              return predicate.call(context2, v2, k2, c2) && ++iterations && fn2(v2, k2, this$0);
            }
          );
          return iterations;
        };
        takeSequence.__iteratorUncached = function(type, reverse3) {
          var this$0 = this;
          if (reverse3) {
            return this.cacheResult().__iterator(type, reverse3);
          }
          var iterator = iterable.__iterator(ITERATE_ENTRIES2, reverse3);
          var iterating = true;
          return new Iterator3(function() {
            if (!iterating) {
              return iteratorDone2();
            }
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            var k2 = entry[0];
            var v2 = entry[1];
            if (!predicate.call(context2, v2, k2, this$0)) {
              iterating = false;
              return iteratorDone2();
            }
            return type === ITERATE_ENTRIES2 ? step : iteratorValue2(type, k2, v2, step);
          });
        };
        return takeSequence;
      }
      function skipWhileFactory2(iterable, predicate, context2, useKeys) {
        var skipSequence = makeSequence2(iterable);
        skipSequence.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          if (reverse3) {
            return this.cacheResult().__iterate(fn2, reverse3);
          }
          var isSkipping = true;
          var iterations = 0;
          iterable.__iterate(function(v2, k2, c2) {
            if (!(isSkipping && (isSkipping = predicate.call(context2, v2, k2, c2)))) {
              iterations++;
              return fn2(v2, useKeys ? k2 : iterations - 1, this$0);
            }
          });
          return iterations;
        };
        skipSequence.__iteratorUncached = function(type, reverse3) {
          var this$0 = this;
          if (reverse3) {
            return this.cacheResult().__iterator(type, reverse3);
          }
          var iterator = iterable.__iterator(ITERATE_ENTRIES2, reverse3);
          var skipping = true;
          var iterations = 0;
          return new Iterator3(function() {
            var step, k2, v2;
            do {
              step = iterator.next();
              if (step.done) {
                if (useKeys || type === ITERATE_VALUES2) {
                  return step;
                } else if (type === ITERATE_KEYS2) {
                  return iteratorValue2(type, iterations++, void 0, step);
                } else {
                  return iteratorValue2(type, iterations++, step.value[1], step);
                }
              }
              var entry = step.value;
              k2 = entry[0];
              v2 = entry[1];
              skipping && (skipping = predicate.call(context2, v2, k2, this$0));
            } while (skipping);
            return type === ITERATE_ENTRIES2 ? step : iteratorValue2(type, k2, v2, step);
          });
        };
        return skipSequence;
      }
      function concatFactory2(iterable, values2) {
        var isKeyedIterable = isKeyed2(iterable);
        var iters = [iterable].concat(values2).map(function(v2) {
          if (!isIterable(v2)) {
            v2 = isKeyedIterable ? keyedSeqFromValue2(v2) : indexedSeqFromValue2(Array.isArray(v2) ? v2 : [v2]);
          } else if (isKeyedIterable) {
            v2 = KeyedIterable(v2);
          }
          return v2;
        }).filter(function(v2) {
          return v2.size !== 0;
        });
        if (iters.length === 0) {
          return iterable;
        }
        if (iters.length === 1) {
          var singleton = iters[0];
          if (singleton === iterable || isKeyedIterable && isKeyed2(singleton) || isIndexed2(iterable) && isIndexed2(singleton)) {
            return singleton;
          }
        }
        var concatSeq = new ArraySeq2(iters);
        if (isKeyedIterable) {
          concatSeq = concatSeq.toKeyedSeq();
        } else if (!isIndexed2(iterable)) {
          concatSeq = concatSeq.toSetSeq();
        }
        concatSeq = concatSeq.flatten(true);
        concatSeq.size = iters.reduce(
          function(sum, seq) {
            if (sum !== void 0) {
              var size = seq.size;
              if (size !== void 0) {
                return sum + size;
              }
            }
          },
          0
        );
        return concatSeq;
      }
      function flattenFactory2(iterable, depth, useKeys) {
        var flatSequence = makeSequence2(iterable);
        flatSequence.__iterateUncached = function(fn2, reverse3) {
          var iterations = 0;
          var stopped = false;
          function flatDeep(iter, currentDepth) {
            var this$0 = this;
            iter.__iterate(function(v2, k2) {
              if ((!depth || currentDepth < depth) && isIterable(v2)) {
                flatDeep(v2, currentDepth + 1);
              } else if (fn2(v2, useKeys ? k2 : iterations++, this$0) === false) {
                stopped = true;
              }
              return !stopped;
            }, reverse3);
          }
          flatDeep(iterable, 0);
          return iterations;
        };
        flatSequence.__iteratorUncached = function(type, reverse3) {
          var iterator = iterable.__iterator(type, reverse3);
          var stack = [];
          var iterations = 0;
          return new Iterator3(function() {
            while (iterator) {
              var step = iterator.next();
              if (step.done !== false) {
                iterator = stack.pop();
                continue;
              }
              var v2 = step.value;
              if (type === ITERATE_ENTRIES2) {
                v2 = v2[1];
              }
              if ((!depth || stack.length < depth) && isIterable(v2)) {
                stack.push(iterator);
                iterator = v2.__iterator(type, reverse3);
              } else {
                return useKeys ? step : iteratorValue2(type, iterations++, v2, step);
              }
            }
            return iteratorDone2();
          });
        };
        return flatSequence;
      }
      function flatMapFactory2(iterable, mapper, context2) {
        var coerce = iterableClass(iterable);
        return iterable.toSeq().map(
          function(v2, k2) {
            return coerce(mapper.call(context2, v2, k2, iterable));
          }
        ).flatten(true);
      }
      function interposeFactory2(iterable, separator) {
        var interposedSequence = makeSequence2(iterable);
        interposedSequence.size = iterable.size && iterable.size * 2 - 1;
        interposedSequence.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          var iterations = 0;
          iterable.__iterate(
            function(v2, k2) {
              return (!iterations || fn2(separator, iterations++, this$0) !== false) && fn2(v2, iterations++, this$0) !== false;
            },
            reverse3
          );
          return iterations;
        };
        interposedSequence.__iteratorUncached = function(type, reverse3) {
          var iterator = iterable.__iterator(ITERATE_VALUES2, reverse3);
          var iterations = 0;
          var step;
          return new Iterator3(function() {
            if (!step || iterations % 2) {
              step = iterator.next();
              if (step.done) {
                return step;
              }
            }
            return iterations % 2 ? iteratorValue2(type, iterations++, separator) : iteratorValue2(type, iterations++, step.value, step);
          });
        };
        return interposedSequence;
      }
      function sortFactory2(iterable, comparator, mapper) {
        if (!comparator) {
          comparator = defaultComparator2;
        }
        var isKeyedIterable = isKeyed2(iterable);
        var index = 0;
        var entries3 = iterable.toSeq().map(
          function(v2, k2) {
            return [k2, v2, index++, mapper ? mapper(v2, k2, iterable) : v2];
          }
        ).toArray();
        entries3.sort(function(a2, b2) {
          return comparator(a2[3], b2[3]) || a2[2] - b2[2];
        }).forEach(
          isKeyedIterable ? function(v2, i2) {
            entries3[i2].length = 2;
          } : function(v2, i2) {
            entries3[i2] = v2[1];
          }
        );
        return isKeyedIterable ? KeyedSeq2(entries3) : isIndexed2(iterable) ? IndexedSeq2(entries3) : SetSeq2(entries3);
      }
      function maxFactory2(iterable, comparator, mapper) {
        if (!comparator) {
          comparator = defaultComparator2;
        }
        if (mapper) {
          var entry = iterable.toSeq().map(function(v2, k2) {
            return [v2, mapper(v2, k2, iterable)];
          }).reduce(function(a2, b2) {
            return maxCompare2(comparator, a2[1], b2[1]) ? b2 : a2;
          });
          return entry && entry[0];
        } else {
          return iterable.reduce(function(a2, b2) {
            return maxCompare2(comparator, a2, b2) ? b2 : a2;
          });
        }
      }
      function maxCompare2(comparator, a2, b2) {
        var comp = comparator(b2, a2);
        return comp === 0 && b2 !== a2 && (b2 === void 0 || b2 === null || b2 !== b2) || comp > 0;
      }
      function zipWithFactory2(keyIter, zipper, iters) {
        var zipSequence = makeSequence2(keyIter);
        zipSequence.size = new ArraySeq2(iters).map(function(i2) {
          return i2.size;
        }).min();
        zipSequence.__iterate = function(fn2, reverse3) {
          var iterator = this.__iterator(ITERATE_VALUES2, reverse3);
          var step;
          var iterations = 0;
          while (!(step = iterator.next()).done) {
            if (fn2(step.value, iterations++, this) === false) {
              break;
            }
          }
          return iterations;
        };
        zipSequence.__iteratorUncached = function(type, reverse3) {
          var iterators = iters.map(
            function(i2) {
              return i2 = Iterable2(i2), getIterator2(reverse3 ? i2.reverse() : i2);
            }
          );
          var iterations = 0;
          var isDone = false;
          return new Iterator3(function() {
            var steps;
            if (!isDone) {
              steps = iterators.map(function(i2) {
                return i2.next();
              });
              isDone = steps.some(function(s2) {
                return s2.done;
              });
            }
            if (isDone) {
              return iteratorDone2();
            }
            return iteratorValue2(
              type,
              iterations++,
              zipper.apply(null, steps.map(function(s2) {
                return s2.value;
              }))
            );
          });
        };
        return zipSequence;
      }
      function reify2(iter, seq) {
        return isSeq2(iter) ? seq : iter.constructor(seq);
      }
      function validateEntry2(entry) {
        if (entry !== Object(entry)) {
          throw new TypeError("Expected [K, V] tuple: " + entry);
        }
      }
      function resolveSize(iter) {
        assertNotInfinite2(iter.size);
        return ensureSize2(iter);
      }
      function iterableClass(iterable) {
        return isKeyed2(iterable) ? KeyedIterable : isIndexed2(iterable) ? IndexedIterable : SetIterable;
      }
      function makeSequence2(iterable) {
        return Object.create(
          (isKeyed2(iterable) ? KeyedSeq2 : isIndexed2(iterable) ? IndexedSeq2 : SetSeq2).prototype
        );
      }
      function cacheResultThrough2() {
        if (this._iter.cacheResult) {
          this._iter.cacheResult();
          this.size = this._iter.size;
          return this;
        } else {
          return Seq2.prototype.cacheResult.call(this);
        }
      }
      function defaultComparator2(a2, b2) {
        return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
      }
      function forceIterator(keyPath) {
        var iter = getIterator2(keyPath);
        if (!iter) {
          if (!isArrayLike2(keyPath)) {
            throw new TypeError("Expected iterable or array-like: " + keyPath);
          }
          iter = getIterator2(Iterable2(keyPath));
        }
        return iter;
      }
      createClass(Record3, KeyedCollection2);
      function Record3(defaultValues, name) {
        var hasInitialized;
        var RecordType = function Record22(values2) {
          if (values2 instanceof RecordType) {
            return values2;
          }
          if (!(this instanceof RecordType)) {
            return new RecordType(values2);
          }
          if (!hasInitialized) {
            hasInitialized = true;
            var keys2 = Object.keys(defaultValues);
            setProps(RecordTypePrototype, keys2);
            RecordTypePrototype.size = keys2.length;
            RecordTypePrototype._name = name;
            RecordTypePrototype._keys = keys2;
            RecordTypePrototype._defaultValues = defaultValues;
          }
          this._map = Map2(values2);
        };
        var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype2);
        RecordTypePrototype.constructor = RecordType;
        return RecordType;
      }
      Record3.prototype.toString = function() {
        return this.__toString(recordName2(this) + " {", "}");
      };
      Record3.prototype.has = function(k2) {
        return this._defaultValues.hasOwnProperty(k2);
      };
      Record3.prototype.get = function(k2, notSetValue) {
        if (!this.has(k2)) {
          return notSetValue;
        }
        var defaultVal = this._defaultValues[k2];
        return this._map ? this._map.get(k2, defaultVal) : defaultVal;
      };
      Record3.prototype.clear = function() {
        if (this.__ownerID) {
          this._map && this._map.clear();
          return this;
        }
        var RecordType = this.constructor;
        return RecordType._empty || (RecordType._empty = makeRecord2(this, emptyMap2()));
      };
      Record3.prototype.set = function(k2, v2) {
        if (!this.has(k2)) {
          throw new Error('Cannot set unknown key "' + k2 + '" on ' + recordName2(this));
        }
        var newMap = this._map && this._map.set(k2, v2);
        if (this.__ownerID || newMap === this._map) {
          return this;
        }
        return makeRecord2(this, newMap);
      };
      Record3.prototype.remove = function(k2) {
        if (!this.has(k2)) {
          return this;
        }
        var newMap = this._map && this._map.remove(k2);
        if (this.__ownerID || newMap === this._map) {
          return this;
        }
        return makeRecord2(this, newMap);
      };
      Record3.prototype.wasAltered = function() {
        return this._map.wasAltered();
      };
      Record3.prototype.__iterator = function(type, reverse3) {
        var this$0 = this;
        return KeyedIterable(this._defaultValues).map(function(_23, k2) {
          return this$0.get(k2);
        }).__iterator(type, reverse3);
      };
      Record3.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        return KeyedIterable(this._defaultValues).map(function(_23, k2) {
          return this$0.get(k2);
        }).__iterate(fn2, reverse3);
      };
      Record3.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map && this._map.__ensureOwner(ownerID);
        if (!ownerID) {
          this.__ownerID = ownerID;
          this._map = newMap;
          return this;
        }
        return makeRecord2(this, newMap, ownerID);
      };
      var RecordPrototype2 = Record3.prototype;
      RecordPrototype2[DELETE2] = RecordPrototype2.remove;
      RecordPrototype2.deleteIn = RecordPrototype2.removeIn = MapPrototype2.removeIn;
      RecordPrototype2.merge = MapPrototype2.merge;
      RecordPrototype2.mergeWith = MapPrototype2.mergeWith;
      RecordPrototype2.mergeIn = MapPrototype2.mergeIn;
      RecordPrototype2.mergeDeep = MapPrototype2.mergeDeep;
      RecordPrototype2.mergeDeepWith = MapPrototype2.mergeDeepWith;
      RecordPrototype2.mergeDeepIn = MapPrototype2.mergeDeepIn;
      RecordPrototype2.setIn = MapPrototype2.setIn;
      RecordPrototype2.update = MapPrototype2.update;
      RecordPrototype2.updateIn = MapPrototype2.updateIn;
      RecordPrototype2.withMutations = MapPrototype2.withMutations;
      RecordPrototype2.asMutable = MapPrototype2.asMutable;
      RecordPrototype2.asImmutable = MapPrototype2.asImmutable;
      function makeRecord2(likeRecord, map3, ownerID) {
        var record = Object.create(Object.getPrototypeOf(likeRecord));
        record._map = map3;
        record.__ownerID = ownerID;
        return record;
      }
      function recordName2(record) {
        return record._name || record.constructor.name || "Record";
      }
      function setProps(prototype, names) {
        try {
          names.forEach(setProp2.bind(void 0, prototype));
        } catch (error2) {
        }
      }
      function setProp2(prototype, name) {
        Object.defineProperty(prototype, name, {
          get: function() {
            return this.get(name);
          },
          set: function(value) {
            invariant2(this.__ownerID, "Cannot set on an immutable record.");
            this.set(name, value);
          }
        });
      }
      createClass(Set2, SetCollection2);
      function Set2(value) {
        return value === null || value === void 0 ? emptySet2() : isSet2(value) && !isOrdered2(value) ? value : emptySet2().withMutations(function(set3) {
          var iter = SetIterable(value);
          assertNotInfinite2(iter.size);
          iter.forEach(function(v2) {
            return set3.add(v2);
          });
        });
      }
      Set2.of = function() {
        return this(arguments);
      };
      Set2.fromKeys = function(value) {
        return this(KeyedIterable(value).keySeq());
      };
      Set2.prototype.toString = function() {
        return this.__toString("Set {", "}");
      };
      Set2.prototype.has = function(value) {
        return this._map.has(value);
      };
      Set2.prototype.add = function(value) {
        return updateSet2(this, this._map.set(value, true));
      };
      Set2.prototype.remove = function(value) {
        return updateSet2(this, this._map.remove(value));
      };
      Set2.prototype.clear = function() {
        return updateSet2(this, this._map.clear());
      };
      Set2.prototype.union = function() {
        var iters = SLICE$0.call(arguments, 0);
        iters = iters.filter(function(x2) {
          return x2.size !== 0;
        });
        if (iters.length === 0) {
          return this;
        }
        if (this.size === 0 && !this.__ownerID && iters.length === 1) {
          return this.constructor(iters[0]);
        }
        return this.withMutations(function(set3) {
          for (var ii = 0; ii < iters.length; ii++) {
            SetIterable(iters[ii]).forEach(function(value) {
              return set3.add(value);
            });
          }
        });
      };
      Set2.prototype.intersect = function() {
        var iters = SLICE$0.call(arguments, 0);
        if (iters.length === 0) {
          return this;
        }
        iters = iters.map(function(iter) {
          return SetIterable(iter);
        });
        var originalSet = this;
        return this.withMutations(function(set3) {
          originalSet.forEach(function(value) {
            if (!iters.every(function(iter) {
              return iter.includes(value);
            })) {
              set3.remove(value);
            }
          });
        });
      };
      Set2.prototype.subtract = function() {
        var iters = SLICE$0.call(arguments, 0);
        if (iters.length === 0) {
          return this;
        }
        iters = iters.map(function(iter) {
          return SetIterable(iter);
        });
        var originalSet = this;
        return this.withMutations(function(set3) {
          originalSet.forEach(function(value) {
            if (iters.some(function(iter) {
              return iter.includes(value);
            })) {
              set3.remove(value);
            }
          });
        });
      };
      Set2.prototype.merge = function() {
        return this.union.apply(this, arguments);
      };
      Set2.prototype.mergeWith = function(merger) {
        var iters = SLICE$0.call(arguments, 1);
        return this.union.apply(this, iters);
      };
      Set2.prototype.sort = function(comparator) {
        return OrderedSet2(sortFactory2(this, comparator));
      };
      Set2.prototype.sortBy = function(mapper, comparator) {
        return OrderedSet2(sortFactory2(this, comparator, mapper));
      };
      Set2.prototype.wasAltered = function() {
        return this._map.wasAltered();
      };
      Set2.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        return this._map.__iterate(function(_23, k2) {
          return fn2(k2, k2, this$0);
        }, reverse3);
      };
      Set2.prototype.__iterator = function(type, reverse3) {
        return this._map.map(function(_23, k2) {
          return k2;
        }).__iterator(type, reverse3);
      };
      Set2.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        if (!ownerID) {
          this.__ownerID = ownerID;
          this._map = newMap;
          return this;
        }
        return this.__make(newMap, ownerID);
      };
      function isSet2(maybeSet) {
        return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
      }
      Set2.isSet = isSet2;
      var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
      var SetPrototype2 = Set2.prototype;
      SetPrototype2[IS_SET_SENTINEL] = true;
      SetPrototype2[DELETE2] = SetPrototype2.remove;
      SetPrototype2.mergeDeep = SetPrototype2.merge;
      SetPrototype2.mergeDeepWith = SetPrototype2.mergeWith;
      SetPrototype2.withMutations = MapPrototype2.withMutations;
      SetPrototype2.asMutable = MapPrototype2.asMutable;
      SetPrototype2.asImmutable = MapPrototype2.asImmutable;
      SetPrototype2.__empty = emptySet2;
      SetPrototype2.__make = makeSet2;
      function updateSet2(set3, newMap) {
        if (set3.__ownerID) {
          set3.size = newMap.size;
          set3._map = newMap;
          return set3;
        }
        return newMap === set3._map ? set3 : newMap.size === 0 ? set3.__empty() : set3.__make(newMap);
      }
      function makeSet2(map3, ownerID) {
        var set3 = Object.create(SetPrototype2);
        set3.size = map3 ? map3.size : 0;
        set3._map = map3;
        set3.__ownerID = ownerID;
        return set3;
      }
      var EMPTY_SET2;
      function emptySet2() {
        return EMPTY_SET2 || (EMPTY_SET2 = makeSet2(emptyMap2()));
      }
      createClass(OrderedSet2, Set2);
      function OrderedSet2(value) {
        return value === null || value === void 0 ? emptyOrderedSet2() : isOrderedSet2(value) ? value : emptyOrderedSet2().withMutations(function(set3) {
          var iter = SetIterable(value);
          assertNotInfinite2(iter.size);
          iter.forEach(function(v2) {
            return set3.add(v2);
          });
        });
      }
      OrderedSet2.of = function() {
        return this(arguments);
      };
      OrderedSet2.fromKeys = function(value) {
        return this(KeyedIterable(value).keySeq());
      };
      OrderedSet2.prototype.toString = function() {
        return this.__toString("OrderedSet {", "}");
      };
      function isOrderedSet2(maybeOrderedSet) {
        return isSet2(maybeOrderedSet) && isOrdered2(maybeOrderedSet);
      }
      OrderedSet2.isOrderedSet = isOrderedSet2;
      var OrderedSetPrototype2 = OrderedSet2.prototype;
      OrderedSetPrototype2[IS_ORDERED_SENTINEL] = true;
      OrderedSetPrototype2.__empty = emptyOrderedSet2;
      OrderedSetPrototype2.__make = makeOrderedSet2;
      function makeOrderedSet2(map3, ownerID) {
        var set3 = Object.create(OrderedSetPrototype2);
        set3.size = map3 ? map3.size : 0;
        set3._map = map3;
        set3.__ownerID = ownerID;
        return set3;
      }
      var EMPTY_ORDERED_SET2;
      function emptyOrderedSet2() {
        return EMPTY_ORDERED_SET2 || (EMPTY_ORDERED_SET2 = makeOrderedSet2(emptyOrderedMap2()));
      }
      createClass(Stack2, IndexedCollection2);
      function Stack2(value) {
        return value === null || value === void 0 ? emptyStack2() : isStack2(value) ? value : emptyStack2().unshiftAll(value);
      }
      Stack2.of = function() {
        return this(arguments);
      };
      Stack2.prototype.toString = function() {
        return this.__toString("Stack [", "]");
      };
      Stack2.prototype.get = function(index, notSetValue) {
        var head = this._head;
        index = wrapIndex2(this, index);
        while (head && index--) {
          head = head.next;
        }
        return head ? head.value : notSetValue;
      };
      Stack2.prototype.peek = function() {
        return this._head && this._head.value;
      };
      Stack2.prototype.push = function() {
        if (arguments.length === 0) {
          return this;
        }
        var newSize = this.size + arguments.length;
        var head = this._head;
        for (var ii = arguments.length - 1; ii >= 0; ii--) {
          head = {
            value: arguments[ii],
            next: head
          };
        }
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack2(newSize, head);
      };
      Stack2.prototype.pushAll = function(iter) {
        iter = IndexedIterable(iter);
        if (iter.size === 0) {
          return this;
        }
        assertNotInfinite2(iter.size);
        var newSize = this.size;
        var head = this._head;
        iter.reverse().forEach(function(value) {
          newSize++;
          head = {
            value,
            next: head
          };
        });
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack2(newSize, head);
      };
      Stack2.prototype.pop = function() {
        return this.slice(1);
      };
      Stack2.prototype.unshift = function() {
        return this.push.apply(this, arguments);
      };
      Stack2.prototype.unshiftAll = function(iter) {
        return this.pushAll(iter);
      };
      Stack2.prototype.shift = function() {
        return this.pop.apply(this, arguments);
      };
      Stack2.prototype.clear = function() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._head = void 0;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyStack2();
      };
      Stack2.prototype.slice = function(begin, end) {
        if (wholeSlice2(begin, end, this.size)) {
          return this;
        }
        var resolvedBegin = resolveBegin2(begin, this.size);
        var resolvedEnd = resolveEnd2(end, this.size);
        if (resolvedEnd !== this.size) {
          return IndexedCollection2.prototype.slice.call(this, begin, end);
        }
        var newSize = this.size - resolvedBegin;
        var head = this._head;
        while (resolvedBegin--) {
          head = head.next;
        }
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack2(newSize, head);
      };
      Stack2.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeStack2(this.size, this._head, ownerID, this.__hash);
      };
      Stack2.prototype.__iterate = function(fn2, reverse3) {
        if (reverse3) {
          return this.reverse().__iterate(fn2);
        }
        var iterations = 0;
        var node = this._head;
        while (node) {
          if (fn2(node.value, iterations++, this) === false) {
            break;
          }
          node = node.next;
        }
        return iterations;
      };
      Stack2.prototype.__iterator = function(type, reverse3) {
        if (reverse3) {
          return this.reverse().__iterator(type);
        }
        var iterations = 0;
        var node = this._head;
        return new Iterator3(function() {
          if (node) {
            var value = node.value;
            node = node.next;
            return iteratorValue2(type, iterations++, value);
          }
          return iteratorDone2();
        });
      };
      function isStack2(maybeStack) {
        return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
      }
      Stack2.isStack = isStack2;
      var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
      var StackPrototype2 = Stack2.prototype;
      StackPrototype2[IS_STACK_SENTINEL] = true;
      StackPrototype2.withMutations = MapPrototype2.withMutations;
      StackPrototype2.asMutable = MapPrototype2.asMutable;
      StackPrototype2.asImmutable = MapPrototype2.asImmutable;
      StackPrototype2.wasAltered = MapPrototype2.wasAltered;
      function makeStack2(size, head, ownerID, hash22) {
        var map3 = Object.create(StackPrototype2);
        map3.size = size;
        map3._head = head;
        map3.__ownerID = ownerID;
        map3.__hash = hash22;
        map3.__altered = false;
        return map3;
      }
      var EMPTY_STACK2;
      function emptyStack2() {
        return EMPTY_STACK2 || (EMPTY_STACK2 = makeStack2(0));
      }
      function mixin2(ctor, methods2) {
        var keyCopier = function(key) {
          ctor.prototype[key] = methods2[key];
        };
        Object.keys(methods2).forEach(keyCopier);
        Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods2).forEach(keyCopier);
        return ctor;
      }
      Iterable2.Iterator = Iterator3;
      mixin2(Iterable2, {
        // ### Conversion to other types
        toArray: function() {
          assertNotInfinite2(this.size);
          var array2 = new Array(this.size || 0);
          this.valueSeq().__iterate(function(v2, i2) {
            array2[i2] = v2;
          });
          return array2;
        },
        toIndexedSeq: function() {
          return new ToIndexedSequence2(this);
        },
        toJS: function() {
          return this.toSeq().map(
            function(value) {
              return value && typeof value.toJS === "function" ? value.toJS() : value;
            }
          ).__toJS();
        },
        toJSON: function() {
          return this.toSeq().map(
            function(value) {
              return value && typeof value.toJSON === "function" ? value.toJSON() : value;
            }
          ).__toJS();
        },
        toKeyedSeq: function() {
          return new ToKeyedSequence2(this, true);
        },
        toMap: function() {
          return Map2(this.toKeyedSeq());
        },
        toObject: function() {
          assertNotInfinite2(this.size);
          var object2 = {};
          this.__iterate(function(v2, k2) {
            object2[k2] = v2;
          });
          return object2;
        },
        toOrderedMap: function() {
          return OrderedMap2(this.toKeyedSeq());
        },
        toOrderedSet: function() {
          return OrderedSet2(isKeyed2(this) ? this.valueSeq() : this);
        },
        toSet: function() {
          return Set2(isKeyed2(this) ? this.valueSeq() : this);
        },
        toSetSeq: function() {
          return new ToSetSequence2(this);
        },
        toSeq: function() {
          return isIndexed2(this) ? this.toIndexedSeq() : isKeyed2(this) ? this.toKeyedSeq() : this.toSetSeq();
        },
        toStack: function() {
          return Stack2(isKeyed2(this) ? this.valueSeq() : this);
        },
        toList: function() {
          return List2(isKeyed2(this) ? this.valueSeq() : this);
        },
        // ### Common JavaScript methods and properties
        toString: function() {
          return "[Iterable]";
        },
        __toString: function(head, tail) {
          if (this.size === 0) {
            return head + tail;
          }
          return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
        },
        // ### ES6 Collection methods (ES6 Array and Map)
        concat: function() {
          var values2 = SLICE$0.call(arguments, 0);
          return reify2(this, concatFactory2(this, values2));
        },
        includes: function(searchValue) {
          return this.some(function(value) {
            return is2(value, searchValue);
          });
        },
        entries: function() {
          return this.__iterator(ITERATE_ENTRIES2);
        },
        every: function(predicate, context2) {
          assertNotInfinite2(this.size);
          var returnValue = true;
          this.__iterate(function(v2, k2, c2) {
            if (!predicate.call(context2, v2, k2, c2)) {
              returnValue = false;
              return false;
            }
          });
          return returnValue;
        },
        filter: function(predicate, context2) {
          return reify2(this, filterFactory2(this, predicate, context2, true));
        },
        find: function(predicate, context2, notSetValue) {
          var entry = this.findEntry(predicate, context2);
          return entry ? entry[1] : notSetValue;
        },
        findEntry: function(predicate, context2) {
          var found;
          this.__iterate(function(v2, k2, c2) {
            if (predicate.call(context2, v2, k2, c2)) {
              found = [k2, v2];
              return false;
            }
          });
          return found;
        },
        findLastEntry: function(predicate, context2) {
          return this.toSeq().reverse().findEntry(predicate, context2);
        },
        forEach: function(sideEffect, context2) {
          assertNotInfinite2(this.size);
          return this.__iterate(context2 ? sideEffect.bind(context2) : sideEffect);
        },
        join: function(separator) {
          assertNotInfinite2(this.size);
          separator = separator !== void 0 ? "" + separator : ",";
          var joined = "";
          var isFirst = true;
          this.__iterate(function(v2) {
            isFirst ? isFirst = false : joined += separator;
            joined += v2 !== null && v2 !== void 0 ? v2.toString() : "";
          });
          return joined;
        },
        keys: function() {
          return this.__iterator(ITERATE_KEYS2);
        },
        map: function(mapper, context2) {
          return reify2(this, mapFactory2(this, mapper, context2));
        },
        reduce: function(reducer2, initialReduction, context2) {
          assertNotInfinite2(this.size);
          var reduction;
          var useFirst;
          if (arguments.length < 2) {
            useFirst = true;
          } else {
            reduction = initialReduction;
          }
          this.__iterate(function(v2, k2, c2) {
            if (useFirst) {
              useFirst = false;
              reduction = v2;
            } else {
              reduction = reducer2.call(context2, reduction, v2, k2, c2);
            }
          });
          return reduction;
        },
        reduceRight: function(reducer2, initialReduction, context2) {
          var reversed = this.toKeyedSeq().reverse();
          return reversed.reduce.apply(reversed, arguments);
        },
        reverse: function() {
          return reify2(this, reverseFactory2(this, true));
        },
        slice: function(begin, end) {
          return reify2(this, sliceFactory2(this, begin, end, true));
        },
        some: function(predicate, context2) {
          return !this.every(not2(predicate), context2);
        },
        sort: function(comparator) {
          return reify2(this, sortFactory2(this, comparator));
        },
        values: function() {
          return this.__iterator(ITERATE_VALUES2);
        },
        // ### More sequential methods
        butLast: function() {
          return this.slice(0, -1);
        },
        isEmpty: function() {
          return this.size !== void 0 ? this.size === 0 : !this.some(function() {
            return true;
          });
        },
        count: function(predicate, context2) {
          return ensureSize2(
            predicate ? this.toSeq().filter(predicate, context2) : this
          );
        },
        countBy: function(grouper, context2) {
          return countByFactory2(this, grouper, context2);
        },
        equals: function(other) {
          return deepEqual2(this, other);
        },
        entrySeq: function() {
          var iterable = this;
          if (iterable._cache) {
            return new ArraySeq2(iterable._cache);
          }
          var entriesSequence = iterable.toSeq().map(entryMapper2).toIndexedSeq();
          entriesSequence.fromEntrySeq = function() {
            return iterable.toSeq();
          };
          return entriesSequence;
        },
        filterNot: function(predicate, context2) {
          return this.filter(not2(predicate), context2);
        },
        findLast: function(predicate, context2, notSetValue) {
          return this.toKeyedSeq().reverse().find(predicate, context2, notSetValue);
        },
        first: function() {
          return this.find(returnTrue2);
        },
        flatMap: function(mapper, context2) {
          return reify2(this, flatMapFactory2(this, mapper, context2));
        },
        flatten: function(depth) {
          return reify2(this, flattenFactory2(this, depth, true));
        },
        fromEntrySeq: function() {
          return new FromEntriesSequence2(this);
        },
        get: function(searchKey, notSetValue) {
          return this.find(function(_23, key) {
            return is2(key, searchKey);
          }, void 0, notSetValue);
        },
        getIn: function(searchKeyPath, notSetValue) {
          var nested = this;
          var iter = forceIterator(searchKeyPath);
          var step;
          while (!(step = iter.next()).done) {
            var key = step.value;
            nested = nested && nested.get ? nested.get(key, NOT_SET2) : NOT_SET2;
            if (nested === NOT_SET2) {
              return notSetValue;
            }
          }
          return nested;
        },
        groupBy: function(grouper, context2) {
          return groupByFactory2(this, grouper, context2);
        },
        has: function(searchKey) {
          return this.get(searchKey, NOT_SET2) !== NOT_SET2;
        },
        hasIn: function(searchKeyPath) {
          return this.getIn(searchKeyPath, NOT_SET2) !== NOT_SET2;
        },
        isSubset: function(iter) {
          iter = typeof iter.includes === "function" ? iter : Iterable2(iter);
          return this.every(function(value) {
            return iter.includes(value);
          });
        },
        isSuperset: function(iter) {
          iter = typeof iter.isSubset === "function" ? iter : Iterable2(iter);
          return iter.isSubset(this);
        },
        keySeq: function() {
          return this.toSeq().map(keyMapper2).toIndexedSeq();
        },
        last: function() {
          return this.toSeq().reverse().first();
        },
        max: function(comparator) {
          return maxFactory2(this, comparator);
        },
        maxBy: function(mapper, comparator) {
          return maxFactory2(this, comparator, mapper);
        },
        min: function(comparator) {
          return maxFactory2(this, comparator ? neg2(comparator) : defaultNegComparator2);
        },
        minBy: function(mapper, comparator) {
          return maxFactory2(this, comparator ? neg2(comparator) : defaultNegComparator2, mapper);
        },
        rest: function() {
          return this.slice(1);
        },
        skip: function(amount) {
          return this.slice(Math.max(0, amount));
        },
        skipLast: function(amount) {
          return reify2(this, this.toSeq().reverse().skip(amount).reverse());
        },
        skipWhile: function(predicate, context2) {
          return reify2(this, skipWhileFactory2(this, predicate, context2, true));
        },
        skipUntil: function(predicate, context2) {
          return this.skipWhile(not2(predicate), context2);
        },
        sortBy: function(mapper, comparator) {
          return reify2(this, sortFactory2(this, comparator, mapper));
        },
        take: function(amount) {
          return this.slice(0, Math.max(0, amount));
        },
        takeLast: function(amount) {
          return reify2(this, this.toSeq().reverse().take(amount).reverse());
        },
        takeWhile: function(predicate, context2) {
          return reify2(this, takeWhileFactory2(this, predicate, context2));
        },
        takeUntil: function(predicate, context2) {
          return this.takeWhile(not2(predicate), context2);
        },
        valueSeq: function() {
          return this.toIndexedSeq();
        },
        // ### Hashable Object
        hashCode: function() {
          return this.__hash || (this.__hash = hashIterable(this));
        }
        // ### Internal
        // abstract __iterate(fn, reverse)
        // abstract __iterator(type, reverse)
      });
      var IterablePrototype = Iterable2.prototype;
      IterablePrototype[IS_ITERABLE_SENTINEL] = true;
      IterablePrototype[ITERATOR_SYMBOL2] = IterablePrototype.values;
      IterablePrototype.__toJS = IterablePrototype.toArray;
      IterablePrototype.__toStringMapper = quoteString2;
      IterablePrototype.inspect = IterablePrototype.toSource = function() {
        return this.toString();
      };
      IterablePrototype.chain = IterablePrototype.flatMap;
      IterablePrototype.contains = IterablePrototype.includes;
      (function() {
        try {
          Object.defineProperty(IterablePrototype, "length", {
            get: function() {
              if (!Iterable2.noLengthWarning) {
                var stack;
                try {
                  throw new Error();
                } catch (error2) {
                  stack = error2.stack;
                }
                if (stack.indexOf("_wrapObject") === -1) {
                  console && console.warn && console.warn(
                    "iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. " + stack
                  );
                  return this.size;
                }
              }
            }
          });
        } catch (e2) {
        }
      })();
      mixin2(KeyedIterable, {
        // ### More sequential methods
        flip: function() {
          return reify2(this, flipFactory2(this));
        },
        findKey: function(predicate, context2) {
          var entry = this.findEntry(predicate, context2);
          return entry && entry[0];
        },
        findLastKey: function(predicate, context2) {
          return this.toSeq().reverse().findKey(predicate, context2);
        },
        keyOf: function(searchValue) {
          return this.findKey(function(value) {
            return is2(value, searchValue);
          });
        },
        lastKeyOf: function(searchValue) {
          return this.findLastKey(function(value) {
            return is2(value, searchValue);
          });
        },
        mapEntries: function(mapper, context2) {
          var this$0 = this;
          var iterations = 0;
          return reify2(
            this,
            this.toSeq().map(
              function(v2, k2) {
                return mapper.call(context2, [k2, v2], iterations++, this$0);
              }
            ).fromEntrySeq()
          );
        },
        mapKeys: function(mapper, context2) {
          var this$0 = this;
          return reify2(
            this,
            this.toSeq().flip().map(
              function(k2, v2) {
                return mapper.call(context2, k2, v2, this$0);
              }
            ).flip()
          );
        }
      });
      var KeyedIterablePrototype = KeyedIterable.prototype;
      KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
      KeyedIterablePrototype[ITERATOR_SYMBOL2] = IterablePrototype.entries;
      KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
      KeyedIterablePrototype.__toStringMapper = function(v2, k2) {
        return JSON.stringify(k2) + ": " + quoteString2(v2);
      };
      mixin2(IndexedIterable, {
        // ### Conversion to other types
        toKeyedSeq: function() {
          return new ToKeyedSequence2(this, false);
        },
        // ### ES6 Collection methods (ES6 Array and Map)
        filter: function(predicate, context2) {
          return reify2(this, filterFactory2(this, predicate, context2, false));
        },
        findIndex: function(predicate, context2) {
          var entry = this.findEntry(predicate, context2);
          return entry ? entry[0] : -1;
        },
        indexOf: function(searchValue) {
          var key = this.toKeyedSeq().keyOf(searchValue);
          return key === void 0 ? -1 : key;
        },
        lastIndexOf: function(searchValue) {
          var key = this.toKeyedSeq().reverse().keyOf(searchValue);
          return key === void 0 ? -1 : key;
        },
        reverse: function() {
          return reify2(this, reverseFactory2(this, false));
        },
        slice: function(begin, end) {
          return reify2(this, sliceFactory2(this, begin, end, false));
        },
        splice: function(index, removeNum) {
          var numArgs = arguments.length;
          removeNum = Math.max(removeNum | 0, 0);
          if (numArgs === 0 || numArgs === 2 && !removeNum) {
            return this;
          }
          index = resolveBegin2(index, index < 0 ? this.count() : this.size);
          var spliced = this.slice(0, index);
          return reify2(
            this,
            numArgs === 1 ? spliced : spliced.concat(arrCopy2(arguments, 2), this.slice(index + removeNum))
          );
        },
        // ### More collection methods
        findLastIndex: function(predicate, context2) {
          var key = this.toKeyedSeq().findLastKey(predicate, context2);
          return key === void 0 ? -1 : key;
        },
        first: function() {
          return this.get(0);
        },
        flatten: function(depth) {
          return reify2(this, flattenFactory2(this, depth, false));
        },
        get: function(index, notSetValue) {
          index = wrapIndex2(this, index);
          return index < 0 || (this.size === Infinity || this.size !== void 0 && index > this.size) ? notSetValue : this.find(function(_23, key) {
            return key === index;
          }, void 0, notSetValue);
        },
        has: function(index) {
          index = wrapIndex2(this, index);
          return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
        },
        interpose: function(separator) {
          return reify2(this, interposeFactory2(this, separator));
        },
        interleave: function() {
          var iterables = [this].concat(arrCopy2(arguments));
          var zipped = zipWithFactory2(this.toSeq(), IndexedSeq2.of, iterables);
          var interleaved = zipped.flatten(true);
          if (zipped.size) {
            interleaved.size = zipped.size * iterables.length;
          }
          return reify2(this, interleaved);
        },
        last: function() {
          return this.get(-1);
        },
        skipWhile: function(predicate, context2) {
          return reify2(this, skipWhileFactory2(this, predicate, context2, false));
        },
        zip: function() {
          var iterables = [this].concat(arrCopy2(arguments));
          return reify2(this, zipWithFactory2(this, defaultZipper2, iterables));
        },
        zipWith: function(zipper) {
          var iterables = arrCopy2(arguments);
          iterables[0] = this;
          return reify2(this, zipWithFactory2(this, zipper, iterables));
        }
      });
      IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
      IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
      mixin2(SetIterable, {
        // ### ES6 Collection methods (ES6 Array and Map)
        get: function(value, notSetValue) {
          return this.has(value) ? value : notSetValue;
        },
        includes: function(value) {
          return this.has(value);
        },
        // ### More sequential methods
        keySeq: function() {
          return this.valueSeq();
        }
      });
      SetIterable.prototype.has = IterablePrototype.includes;
      mixin2(KeyedSeq2, KeyedIterable.prototype);
      mixin2(IndexedSeq2, IndexedIterable.prototype);
      mixin2(SetSeq2, SetIterable.prototype);
      mixin2(KeyedCollection2, KeyedIterable.prototype);
      mixin2(IndexedCollection2, IndexedIterable.prototype);
      mixin2(SetCollection2, SetIterable.prototype);
      function keyMapper2(v2, k2) {
        return k2;
      }
      function entryMapper2(v2, k2) {
        return [k2, v2];
      }
      function not2(predicate) {
        return function() {
          return !predicate.apply(this, arguments);
        };
      }
      function neg2(predicate) {
        return function() {
          return -predicate.apply(this, arguments);
        };
      }
      function quoteString2(value) {
        return typeof value === "string" ? JSON.stringify(value) : value;
      }
      function defaultZipper2() {
        return arrCopy2(arguments);
      }
      function defaultNegComparator2(a2, b2) {
        return a2 < b2 ? 1 : a2 > b2 ? -1 : 0;
      }
      function hashIterable(iterable) {
        if (iterable.size === Infinity) {
          return 0;
        }
        var ordered = isOrdered2(iterable);
        var keyed = isKeyed2(iterable);
        var h2 = ordered ? 1 : 0;
        var size = iterable.__iterate(
          keyed ? ordered ? function(v2, k2) {
            h2 = 31 * h2 + hashMerge2(hash2(v2), hash2(k2)) | 0;
          } : function(v2, k2) {
            h2 = h2 + hashMerge2(hash2(v2), hash2(k2)) | 0;
          } : ordered ? function(v2) {
            h2 = 31 * h2 + hash2(v2) | 0;
          } : function(v2) {
            h2 = h2 + hash2(v2) | 0;
          }
        );
        return murmurHashOfSize2(size, h2);
      }
      function murmurHashOfSize2(size, h2) {
        h2 = imul3(h2, 3432918353);
        h2 = imul3(h2 << 15 | h2 >>> -15, 461845907);
        h2 = imul3(h2 << 13 | h2 >>> -13, 5);
        h2 = (h2 + 3864292196 | 0) ^ size;
        h2 = imul3(h2 ^ h2 >>> 16, 2246822507);
        h2 = imul3(h2 ^ h2 >>> 13, 3266489909);
        h2 = smi2(h2 ^ h2 >>> 16);
        return h2;
      }
      function hashMerge2(a2, b2) {
        return a2 ^ b2 + 2654435769 + (a2 << 6) + (a2 >> 2) | 0;
      }
      var Immutable2 = {
        Iterable: Iterable2,
        Seq: Seq2,
        Collection: Collection3,
        Map: Map2,
        OrderedMap: OrderedMap2,
        List: List2,
        Stack: Stack2,
        Set: Set2,
        OrderedSet: OrderedSet2,
        Record: Record3,
        Range: Range2,
        Repeat: Repeat2,
        is: is2,
        fromJS: fromJS2
      };
      return Immutable2;
    });
  })(immutable$1);
  return immutable$1.exports;
}
var BlockMapBuilder_1;
var hasRequiredBlockMapBuilder;
function requireBlockMapBuilder() {
  if (hasRequiredBlockMapBuilder) return BlockMapBuilder_1;
  hasRequiredBlockMapBuilder = 1;
  var Immutable2 = requireImmutable();
  var OrderedMap2 = Immutable2.OrderedMap;
  var BlockMapBuilder = {
    createFromArray: function createFromArray(blocks) {
      return OrderedMap2(blocks.map(function(block) {
        return [block.getKey(), block];
      }));
    }
  };
  BlockMapBuilder_1 = BlockMapBuilder;
  return BlockMapBuilder_1;
}
var CharacterMetadata_1;
var hasRequiredCharacterMetadata;
function requireCharacterMetadata() {
  if (hasRequiredCharacterMetadata) return CharacterMetadata_1;
  hasRequiredCharacterMetadata = 1;
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var _require = requireImmutable(), Map2 = _require.Map, OrderedSet2 = _require.OrderedSet, Record3 = _require.Record;
  var EMPTY_SET2 = OrderedSet2();
  var defaultRecord = {
    style: EMPTY_SET2,
    entity: null
  };
  var CharacterMetadataRecord = Record3(defaultRecord);
  var CharacterMetadata = /* @__PURE__ */ (function(_CharacterMetadataRec) {
    _inheritsLoose2(CharacterMetadata2, _CharacterMetadataRec);
    function CharacterMetadata2() {
      return _CharacterMetadataRec.apply(this, arguments) || this;
    }
    var _proto = CharacterMetadata2.prototype;
    _proto.getStyle = function getStyle() {
      return this.get("style");
    };
    _proto.getEntity = function getEntity() {
      return this.get("entity");
    };
    _proto.hasStyle = function hasStyle(style) {
      return this.getStyle().includes(style);
    };
    CharacterMetadata2.applyStyle = function applyStyle(record, style) {
      var withStyle = record.set("style", record.getStyle().add(style));
      return CharacterMetadata2.create(withStyle);
    };
    CharacterMetadata2.removeStyle = function removeStyle(record, style) {
      var withoutStyle = record.set("style", record.getStyle().remove(style));
      return CharacterMetadata2.create(withoutStyle);
    };
    CharacterMetadata2.applyEntity = function applyEntity(record, entityKey) {
      var withEntity = record.getEntity() === entityKey ? record : record.set("entity", entityKey);
      return CharacterMetadata2.create(withEntity);
    };
    CharacterMetadata2.create = function create3(config) {
      if (!config) {
        return EMPTY;
      }
      var defaultConfig = {
        style: EMPTY_SET2,
        entity: null
      };
      var configMap = Map2(defaultConfig).merge(config);
      var existing = pool.get(configMap);
      if (existing) {
        return existing;
      }
      var newCharacter = new CharacterMetadata2(configMap);
      pool = pool.set(configMap, newCharacter);
      return newCharacter;
    };
    CharacterMetadata2.fromJS = function fromJS2(_ref) {
      var style = _ref.style, entity = _ref.entity;
      return new CharacterMetadata2({
        style: Array.isArray(style) ? OrderedSet2(style) : style,
        entity: Array.isArray(entity) ? OrderedSet2(entity) : entity
      });
    };
    return CharacterMetadata2;
  })(CharacterMetadataRecord);
  var EMPTY = new CharacterMetadata();
  var pool = Map2([[Map2(defaultRecord), EMPTY]]);
  CharacterMetadata.EMPTY = EMPTY;
  CharacterMetadata_1 = CharacterMetadata;
  return CharacterMetadata_1;
}
var findRangesImmutable_1;
var hasRequiredFindRangesImmutable;
function requireFindRangesImmutable() {
  if (hasRequiredFindRangesImmutable) return findRangesImmutable_1;
  hasRequiredFindRangesImmutable = 1;
  function findRangesImmutable(haystack, areEqualFn, filterFn, foundFn) {
    if (!haystack.size) {
      return;
    }
    var cursor = 0;
    haystack.reduce(function(value, nextValue, nextIndex) {
      if (!areEqualFn(value, nextValue)) {
        if (filterFn(value)) {
          foundFn(cursor, nextIndex);
        }
        cursor = nextIndex;
      }
      return nextValue;
    });
    filterFn(haystack.last()) && foundFn(cursor, haystack.count());
  }
  findRangesImmutable_1 = findRangesImmutable;
  return findRangesImmutable_1;
}
var ContentBlock_1;
var hasRequiredContentBlock;
function requireContentBlock() {
  if (hasRequiredContentBlock) return ContentBlock_1;
  hasRequiredContentBlock = 1;
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var CharacterMetadata = requireCharacterMetadata();
  var findRangesImmutable = requireFindRangesImmutable();
  var Immutable2 = requireImmutable();
  var List2 = Immutable2.List, Map2 = Immutable2.Map, OrderedSet2 = Immutable2.OrderedSet, Record3 = Immutable2.Record, Repeat2 = Immutable2.Repeat;
  var EMPTY_SET2 = OrderedSet2();
  var defaultRecord = {
    key: "",
    type: "unstyled",
    text: "",
    characterList: List2(),
    depth: 0,
    data: Map2()
  };
  var ContentBlockRecord = Record3(defaultRecord);
  var decorateCharacterList = function decorateCharacterList2(config) {
    if (!config) {
      return config;
    }
    var characterList = config.characterList, text = config.text;
    if (text && !characterList) {
      config.characterList = List2(Repeat2(CharacterMetadata.EMPTY, text.length));
    }
    return config;
  };
  var ContentBlock = /* @__PURE__ */ (function(_ContentBlockRecord) {
    _inheritsLoose2(ContentBlock2, _ContentBlockRecord);
    function ContentBlock2(config) {
      return _ContentBlockRecord.call(this, decorateCharacterList(config)) || this;
    }
    var _proto = ContentBlock2.prototype;
    _proto.getKey = function getKey() {
      return this.get("key");
    };
    _proto.getType = function getType2() {
      return this.get("type");
    };
    _proto.getText = function getText() {
      return this.get("text");
    };
    _proto.getCharacterList = function getCharacterList() {
      return this.get("characterList");
    };
    _proto.getLength = function getLength() {
      return this.getText().length;
    };
    _proto.getDepth = function getDepth() {
      return this.get("depth");
    };
    _proto.getData = function getData3() {
      return this.get("data");
    };
    _proto.getInlineStyleAt = function getInlineStyleAt(offset) {
      var character = this.getCharacterList().get(offset);
      return character ? character.getStyle() : EMPTY_SET2;
    };
    _proto.getEntityAt = function getEntityAt(offset) {
      var character = this.getCharacterList().get(offset);
      return character ? character.getEntity() : null;
    };
    _proto.findStyleRanges = function findStyleRanges(filterFn, callback) {
      findRangesImmutable(this.getCharacterList(), haveEqualStyle, filterFn, callback);
    };
    _proto.findEntityRanges = function findEntityRanges(filterFn, callback) {
      findRangesImmutable(this.getCharacterList(), haveEqualEntity, filterFn, callback);
    };
    return ContentBlock2;
  })(ContentBlockRecord);
  function haveEqualStyle(charA, charB) {
    return charA.getStyle() === charB.getStyle();
  }
  function haveEqualEntity(charA, charB) {
    return charA.getEntity() === charB.getEntity();
  }
  ContentBlock_1 = ContentBlock;
  return ContentBlock_1;
}
var ContentBlockNode_1;
var hasRequiredContentBlockNode;
function requireContentBlockNode() {
  if (hasRequiredContentBlockNode) return ContentBlockNode_1;
  hasRequiredContentBlockNode = 1;
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var CharacterMetadata = requireCharacterMetadata();
  var findRangesImmutable = requireFindRangesImmutable();
  var Immutable2 = requireImmutable();
  var List2 = Immutable2.List, Map2 = Immutable2.Map, OrderedSet2 = Immutable2.OrderedSet, Record3 = Immutable2.Record, Repeat2 = Immutable2.Repeat;
  var EMPTY_SET2 = OrderedSet2();
  var defaultRecord = {
    parent: null,
    characterList: List2(),
    data: Map2(),
    depth: 0,
    key: "",
    text: "",
    type: "unstyled",
    children: List2(),
    prevSibling: null,
    nextSibling: null
  };
  var haveEqualStyle = function haveEqualStyle2(charA, charB) {
    return charA.getStyle() === charB.getStyle();
  };
  var haveEqualEntity = function haveEqualEntity2(charA, charB) {
    return charA.getEntity() === charB.getEntity();
  };
  var decorateCharacterList = function decorateCharacterList2(config) {
    if (!config) {
      return config;
    }
    var characterList = config.characterList, text = config.text;
    if (text && !characterList) {
      config.characterList = List2(Repeat2(CharacterMetadata.EMPTY, text.length));
    }
    return config;
  };
  var ContentBlockNode = /* @__PURE__ */ (function(_ref) {
    _inheritsLoose2(ContentBlockNode2, _ref);
    function ContentBlockNode2() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultRecord;
      return _ref.call(this, decorateCharacterList(props)) || this;
    }
    var _proto = ContentBlockNode2.prototype;
    _proto.getKey = function getKey() {
      return this.get("key");
    };
    _proto.getType = function getType2() {
      return this.get("type");
    };
    _proto.getText = function getText() {
      return this.get("text");
    };
    _proto.getCharacterList = function getCharacterList() {
      return this.get("characterList");
    };
    _proto.getLength = function getLength() {
      return this.getText().length;
    };
    _proto.getDepth = function getDepth() {
      return this.get("depth");
    };
    _proto.getData = function getData3() {
      return this.get("data");
    };
    _proto.getInlineStyleAt = function getInlineStyleAt(offset) {
      var character = this.getCharacterList().get(offset);
      return character ? character.getStyle() : EMPTY_SET2;
    };
    _proto.getEntityAt = function getEntityAt(offset) {
      var character = this.getCharacterList().get(offset);
      return character ? character.getEntity() : null;
    };
    _proto.getChildKeys = function getChildKeys() {
      return this.get("children");
    };
    _proto.getParentKey = function getParentKey() {
      return this.get("parent");
    };
    _proto.getPrevSiblingKey = function getPrevSiblingKey() {
      return this.get("prevSibling");
    };
    _proto.getNextSiblingKey = function getNextSiblingKey() {
      return this.get("nextSibling");
    };
    _proto.findStyleRanges = function findStyleRanges(filterFn, callback) {
      findRangesImmutable(this.getCharacterList(), haveEqualStyle, filterFn, callback);
    };
    _proto.findEntityRanges = function findEntityRanges(filterFn, callback) {
      findRangesImmutable(this.getCharacterList(), haveEqualEntity, filterFn, callback);
    };
    return ContentBlockNode2;
  })(Record3(defaultRecord));
  ContentBlockNode_1 = ContentBlockNode;
  return ContentBlockNode_1;
}
var ContentStateInlineStyle_1;
var hasRequiredContentStateInlineStyle;
function requireContentStateInlineStyle() {
  if (hasRequiredContentStateInlineStyle) return ContentStateInlineStyle_1;
  hasRequiredContentStateInlineStyle = 1;
  var CharacterMetadata = requireCharacterMetadata();
  var _require = requireImmutable(), Map2 = _require.Map;
  var ContentStateInlineStyle = {
    add: function add2(contentState, selectionState, inlineStyle) {
      return modifyInlineStyle(contentState, selectionState, inlineStyle, true);
    },
    remove: function remove4(contentState, selectionState, inlineStyle) {
      return modifyInlineStyle(contentState, selectionState, inlineStyle, false);
    }
  };
  function modifyInlineStyle(contentState, selectionState, inlineStyle, addOrRemove) {
    var blockMap = contentState.getBlockMap();
    var startKey = selectionState.getStartKey();
    var startOffset = selectionState.getStartOffset();
    var endKey = selectionState.getEndKey();
    var endOffset = selectionState.getEndOffset();
    var newBlocks = blockMap.skipUntil(function(_23, k2) {
      return k2 === startKey;
    }).takeUntil(function(_23, k2) {
      return k2 === endKey;
    }).concat(Map2([[endKey, blockMap.get(endKey)]])).map(function(block, blockKey) {
      var sliceStart;
      var sliceEnd;
      if (startKey === endKey) {
        sliceStart = startOffset;
        sliceEnd = endOffset;
      } else {
        sliceStart = blockKey === startKey ? startOffset : 0;
        sliceEnd = blockKey === endKey ? endOffset : block.getLength();
      }
      var chars2 = block.getCharacterList();
      var current2;
      while (sliceStart < sliceEnd) {
        current2 = chars2.get(sliceStart);
        chars2 = chars2.set(sliceStart, addOrRemove ? CharacterMetadata.applyStyle(current2, inlineStyle) : CharacterMetadata.removeStyle(current2, inlineStyle));
        sliceStart++;
      }
      return block.set("characterList", chars2);
    });
    return contentState.merge({
      blockMap: blockMap.merge(newBlocks),
      selectionBefore: selectionState,
      selectionAfter: selectionState
    });
  }
  ContentStateInlineStyle_1 = ContentStateInlineStyle;
  return ContentStateInlineStyle_1;
}
var applyEntityToContentBlock_1;
var hasRequiredApplyEntityToContentBlock;
function requireApplyEntityToContentBlock() {
  if (hasRequiredApplyEntityToContentBlock) return applyEntityToContentBlock_1;
  hasRequiredApplyEntityToContentBlock = 1;
  var CharacterMetadata = requireCharacterMetadata();
  function applyEntityToContentBlock(contentBlock, startArg, end, entityKey) {
    var start = startArg;
    var characterList = contentBlock.getCharacterList();
    while (start < end) {
      characterList = characterList.set(start, CharacterMetadata.applyEntity(characterList.get(start), entityKey));
      start++;
    }
    return contentBlock.set("characterList", characterList);
  }
  applyEntityToContentBlock_1 = applyEntityToContentBlock;
  return applyEntityToContentBlock_1;
}
var applyEntityToContentState_1;
var hasRequiredApplyEntityToContentState;
function requireApplyEntityToContentState() {
  if (hasRequiredApplyEntityToContentState) return applyEntityToContentState_1;
  hasRequiredApplyEntityToContentState = 1;
  var applyEntityToContentBlock = requireApplyEntityToContentBlock();
  var Immutable2 = requireImmutable();
  function applyEntityToContentState(contentState, selectionState, entityKey) {
    var blockMap = contentState.getBlockMap();
    var startKey = selectionState.getStartKey();
    var startOffset = selectionState.getStartOffset();
    var endKey = selectionState.getEndKey();
    var endOffset = selectionState.getEndOffset();
    var newBlocks = blockMap.skipUntil(function(_23, k2) {
      return k2 === startKey;
    }).takeUntil(function(_23, k2) {
      return k2 === endKey;
    }).toOrderedMap().merge(Immutable2.OrderedMap([[endKey, blockMap.get(endKey)]])).map(function(block, blockKey) {
      var sliceStart = blockKey === startKey ? startOffset : 0;
      var sliceEnd = blockKey === endKey ? endOffset : block.getLength();
      return applyEntityToContentBlock(block, sliceStart, sliceEnd, entityKey);
    });
    return contentState.merge({
      blockMap: blockMap.merge(newBlocks),
      selectionBefore: selectionState,
      selectionAfter: selectionState
    });
  }
  applyEntityToContentState_1 = applyEntityToContentState;
  return applyEntityToContentState_1;
}
var DraftEntitySegments_1;
var hasRequiredDraftEntitySegments;
function requireDraftEntitySegments() {
  if (hasRequiredDraftEntitySegments) return DraftEntitySegments_1;
  hasRequiredDraftEntitySegments = 1;
  var DraftEntitySegments = {
    getRemovalRange: function getRemovalRange(selectionStart, selectionEnd, text, entityStart, direction) {
      var segments = text.split(" ");
      segments = segments.map(function(segment2, ii) {
        if (direction === "forward") {
          if (ii > 0) {
            return " " + segment2;
          }
        } else if (ii < segments.length - 1) {
          return segment2 + " ";
        }
        return segment2;
      });
      var segmentStart = entityStart;
      var segmentEnd;
      var segment;
      var removalStart = null;
      var removalEnd = null;
      for (var jj = 0; jj < segments.length; jj++) {
        segment = segments[jj];
        segmentEnd = segmentStart + segment.length;
        if (selectionStart < segmentEnd && segmentStart < selectionEnd) {
          if (removalStart !== null) {
            removalEnd = segmentEnd;
          } else {
            removalStart = segmentStart;
            removalEnd = segmentEnd;
          }
        } else if (removalStart !== null) {
          break;
        }
        segmentStart = segmentEnd;
      }
      var entityEnd = entityStart + text.length;
      var atStart = removalStart === entityStart;
      var atEnd = removalEnd === entityEnd;
      if (!atStart && atEnd || atStart && !atEnd) {
        if (direction === "forward") {
          if (removalEnd !== entityEnd) {
            removalEnd++;
          }
        } else if (removalStart !== entityStart) {
          removalStart--;
        }
      }
      return {
        start: removalStart,
        end: removalEnd
      };
    }
  };
  DraftEntitySegments_1 = DraftEntitySegments;
  return DraftEntitySegments_1;
}
var invariant_1;
var hasRequiredInvariant;
function requireInvariant() {
  if (hasRequiredInvariant) return invariant_1;
  hasRequiredInvariant = 1;
  function invariant2(condition, format2) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    if (!condition) {
      var error2;
      if (format2 === void 0) {
        error2 = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      } else {
        var argIndex = 0;
        error2 = new Error(format2.replace(/%s/g, function() {
          return String(args[argIndex++]);
        }));
        error2.name = "Invariant Violation";
      }
      error2.framesToPop = 1;
      throw error2;
    }
  }
  invariant_1 = invariant2;
  return invariant_1;
}
var getRangesForDraftEntity_1;
var hasRequiredGetRangesForDraftEntity;
function requireGetRangesForDraftEntity() {
  if (hasRequiredGetRangesForDraftEntity) return getRangesForDraftEntity_1;
  hasRequiredGetRangesForDraftEntity = 1;
  var invariant2 = requireInvariant();
  function getRangesForDraftEntity(block, key) {
    var ranges = [];
    block.findEntityRanges(function(c2) {
      return c2.getEntity() === key;
    }, function(start, end) {
      ranges.push({
        start,
        end
      });
    });
    !!!ranges.length ? invariant2(false) : void 0;
    return ranges;
  }
  getRangesForDraftEntity_1 = getRangesForDraftEntity;
  return getRangesForDraftEntity_1;
}
var getCharacterRemovalRange_1;
var hasRequiredGetCharacterRemovalRange;
function requireGetCharacterRemovalRange() {
  if (hasRequiredGetCharacterRemovalRange) return getCharacterRemovalRange_1;
  hasRequiredGetCharacterRemovalRange = 1;
  var DraftEntitySegments = requireDraftEntitySegments();
  var getRangesForDraftEntity = requireGetRangesForDraftEntity();
  var invariant2 = requireInvariant();
  function getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {
    var start = selectionState.getStartOffset();
    var end = selectionState.getEndOffset();
    var startEntityKey = startBlock.getEntityAt(start);
    var endEntityKey = endBlock.getEntityAt(end - 1);
    if (!startEntityKey && !endEntityKey) {
      return selectionState;
    }
    var newSelectionState = selectionState;
    if (startEntityKey && startEntityKey === endEntityKey) {
      newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);
    } else if (startEntityKey && endEntityKey) {
      var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);
      var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);
      newSelectionState = newSelectionState.merge({
        anchorOffset: startSelectionState.getAnchorOffset(),
        focusOffset: endSelectionState.getFocusOffset(),
        isBackward: false
      });
    } else if (startEntityKey) {
      var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);
      newSelectionState = newSelectionState.merge({
        anchorOffset: _startSelectionState.getStartOffset(),
        isBackward: false
      });
    } else if (endEntityKey) {
      var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);
      newSelectionState = newSelectionState.merge({
        focusOffset: _endSelectionState.getEndOffset(),
        isBackward: false
      });
    }
    return newSelectionState;
  }
  function getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {
    var start = selectionState.getStartOffset();
    var end = selectionState.getEndOffset();
    var entity = entityMap.__get(entityKey);
    var mutability = entity.getMutability();
    var sideToConsider = isEntityAtStart ? start : end;
    if (mutability === "MUTABLE") {
      return selectionState;
    }
    var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function(range) {
      return sideToConsider <= range.end && sideToConsider >= range.start;
    });
    !(entityRanges.length == 1) ? invariant2(false) : void 0;
    var entityRange = entityRanges[0];
    if (mutability === "IMMUTABLE") {
      return selectionState.merge({
        anchorOffset: entityRange.start,
        focusOffset: entityRange.end,
        isBackward: false
      });
    }
    if (!isEntireSelectionWithinEntity) {
      if (isEntityAtStart) {
        end = entityRange.end;
      } else {
        start = entityRange.start;
      }
    }
    var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);
    return selectionState.merge({
      anchorOffset: removalRange.start,
      focusOffset: removalRange.end,
      isBackward: false
    });
  }
  getCharacterRemovalRange_1 = getCharacterRemovalRange;
  return getCharacterRemovalRange_1;
}
var generateRandomKey_1;
var hasRequiredGenerateRandomKey;
function requireGenerateRandomKey() {
  if (hasRequiredGenerateRandomKey) return generateRandomKey_1;
  hasRequiredGenerateRandomKey = 1;
  var seenKeys = {};
  var MULTIPLIER = Math.pow(2, 24);
  function generateRandomKey() {
    var key;
    while (key === void 0 || seenKeys.hasOwnProperty(key) || !isNaN(+key)) {
      key = Math.floor(Math.random() * MULTIPLIER).toString(32);
    }
    seenKeys[key] = true;
    return key;
  }
  generateRandomKey_1 = generateRandomKey;
  return generateRandomKey_1;
}
var randomizeBlockMapKeys_1;
var hasRequiredRandomizeBlockMapKeys;
function requireRandomizeBlockMapKeys() {
  if (hasRequiredRandomizeBlockMapKeys) return randomizeBlockMapKeys_1;
  hasRequiredRandomizeBlockMapKeys = 1;
  var ContentBlockNode = requireContentBlockNode();
  var generateRandomKey = requireGenerateRandomKey();
  var Immutable2 = requireImmutable();
  var OrderedMap2 = Immutable2.OrderedMap;
  var randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys2(blockMap) {
    var newKeysRef = {};
    var lastRootBlock;
    return OrderedMap2(blockMap.withMutations(function(blockMapState) {
      blockMapState.forEach(function(block, index) {
        var oldKey = block.getKey();
        var nextKey = block.getNextSiblingKey();
        var prevKey = block.getPrevSiblingKey();
        var childrenKeys = block.getChildKeys();
        var parentKey = block.getParentKey();
        var key = generateRandomKey();
        newKeysRef[oldKey] = key;
        if (nextKey) {
          var nextBlock = blockMapState.get(nextKey);
          if (nextBlock) {
            blockMapState.setIn([nextKey, "prevSibling"], key);
          } else {
            blockMapState.setIn([oldKey, "nextSibling"], null);
          }
        }
        if (prevKey) {
          var prevBlock = blockMapState.get(prevKey);
          if (prevBlock) {
            blockMapState.setIn([prevKey, "nextSibling"], key);
          } else {
            blockMapState.setIn([oldKey, "prevSibling"], null);
          }
        }
        if (parentKey && blockMapState.get(parentKey)) {
          var parentBlock = blockMapState.get(parentKey);
          var parentChildrenList = parentBlock.getChildKeys();
          blockMapState.setIn([parentKey, "children"], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));
        } else {
          blockMapState.setIn([oldKey, "parent"], null);
          if (lastRootBlock) {
            blockMapState.setIn([lastRootBlock.getKey(), "nextSibling"], key);
            blockMapState.setIn([oldKey, "prevSibling"], newKeysRef[lastRootBlock.getKey()]);
          }
          lastRootBlock = blockMapState.get(oldKey);
        }
        childrenKeys.forEach(function(childKey) {
          var childBlock = blockMapState.get(childKey);
          if (childBlock) {
            blockMapState.setIn([childKey, "parent"], key);
          } else {
            blockMapState.setIn([oldKey, "children"], block.getChildKeys().filter(function(child) {
              return child !== childKey;
            }));
          }
        });
      });
    }).toArray().map(function(block) {
      return [newKeysRef[block.getKey()], block.set("key", newKeysRef[block.getKey()])];
    }));
  };
  var randomizeContentBlockKeys = function randomizeContentBlockKeys2(blockMap) {
    return OrderedMap2(blockMap.toArray().map(function(block) {
      var key = generateRandomKey();
      return [key, block.set("key", key)];
    }));
  };
  var randomizeBlockMapKeys = function randomizeBlockMapKeys2(blockMap) {
    var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;
    if (!isTreeBasedBlockMap) {
      return randomizeContentBlockKeys(blockMap);
    }
    return randomizeContentBlockNodeKeys(blockMap);
  };
  randomizeBlockMapKeys_1 = randomizeBlockMapKeys;
  return randomizeBlockMapKeys_1;
}
var removeEntitiesAtEdges_1;
var hasRequiredRemoveEntitiesAtEdges;
function requireRemoveEntitiesAtEdges() {
  if (hasRequiredRemoveEntitiesAtEdges) return removeEntitiesAtEdges_1;
  hasRequiredRemoveEntitiesAtEdges = 1;
  var CharacterMetadata = requireCharacterMetadata();
  var findRangesImmutable = requireFindRangesImmutable();
  var invariant2 = requireInvariant();
  function removeEntitiesAtEdges(contentState, selectionState) {
    var blockMap = contentState.getBlockMap();
    var entityMap = contentState.getEntityMap();
    var updatedBlocks = {};
    var startKey = selectionState.getStartKey();
    var startOffset = selectionState.getStartOffset();
    var startBlock = blockMap.get(startKey);
    var updatedStart = removeForBlock(entityMap, startBlock, startOffset);
    if (updatedStart !== startBlock) {
      updatedBlocks[startKey] = updatedStart;
    }
    var endKey = selectionState.getEndKey();
    var endOffset = selectionState.getEndOffset();
    var endBlock = blockMap.get(endKey);
    if (startKey === endKey) {
      endBlock = updatedStart;
    }
    var updatedEnd = removeForBlock(entityMap, endBlock, endOffset);
    if (updatedEnd !== endBlock) {
      updatedBlocks[endKey] = updatedEnd;
    }
    if (!Object.keys(updatedBlocks).length) {
      return contentState.set("selectionAfter", selectionState);
    }
    return contentState.merge({
      blockMap: blockMap.merge(updatedBlocks),
      selectionAfter: selectionState
    });
  }
  function getRemovalRange(characters, entityKey, offset) {
    var removalRange;
    findRangesImmutable(
      characters,
      // the list to iterate through
      function(a2, b2) {
        return a2.getEntity() === b2.getEntity();
      },
      // 'isEqual' callback
      function(element) {
        return element.getEntity() === entityKey;
      },
      // 'filter' callback
      function(start, end) {
        if (start <= offset && end >= offset) {
          removalRange = {
            start,
            end
          };
        }
      }
    );
    !(typeof removalRange === "object") ? invariant2(false) : void 0;
    return removalRange;
  }
  function removeForBlock(entityMap, block, offset) {
    var chars2 = block.getCharacterList();
    var charBefore = offset > 0 ? chars2.get(offset - 1) : void 0;
    var charAfter = offset < chars2.count() ? chars2.get(offset) : void 0;
    var entityBeforeCursor = charBefore ? charBefore.getEntity() : void 0;
    var entityAfterCursor = charAfter ? charAfter.getEntity() : void 0;
    if (entityAfterCursor && entityAfterCursor === entityBeforeCursor) {
      var entity = entityMap.__get(entityAfterCursor);
      if (entity.getMutability() !== "MUTABLE") {
        var _getRemovalRange = getRemovalRange(chars2, entityAfterCursor, offset), start = _getRemovalRange.start, end = _getRemovalRange.end;
        var current2;
        while (start < end) {
          current2 = chars2.get(start);
          chars2 = chars2.set(start, CharacterMetadata.applyEntity(current2, null));
          start++;
        }
        return block.set("characterList", chars2);
      }
    }
    return block;
  }
  removeEntitiesAtEdges_1 = removeEntitiesAtEdges;
  return removeEntitiesAtEdges_1;
}
var getContentStateFragment_1;
var hasRequiredGetContentStateFragment;
function requireGetContentStateFragment() {
  if (hasRequiredGetContentStateFragment) return getContentStateFragment_1;
  hasRequiredGetContentStateFragment = 1;
  var randomizeBlockMapKeys = requireRandomizeBlockMapKeys();
  var removeEntitiesAtEdges = requireRemoveEntitiesAtEdges();
  var getContentStateFragment = function getContentStateFragment2(contentState, selectionState) {
    var startKey = selectionState.getStartKey();
    var startOffset = selectionState.getStartOffset();
    var endKey = selectionState.getEndKey();
    var endOffset = selectionState.getEndOffset();
    var contentWithoutEdgeEntities = removeEntitiesAtEdges(contentState, selectionState);
    var blockMap = contentWithoutEdgeEntities.getBlockMap();
    var blockKeys = blockMap.keySeq();
    var startIndex = blockKeys.indexOf(startKey);
    var endIndex = blockKeys.indexOf(endKey) + 1;
    return randomizeBlockMapKeys(blockMap.slice(startIndex, endIndex).map(function(block, blockKey) {
      var text = block.getText();
      var chars2 = block.getCharacterList();
      if (startKey === endKey) {
        return block.merge({
          text: text.slice(startOffset, endOffset),
          characterList: chars2.slice(startOffset, endOffset)
        });
      }
      if (blockKey === startKey) {
        return block.merge({
          text: text.slice(startOffset),
          characterList: chars2.slice(startOffset)
        });
      }
      if (blockKey === endKey) {
        return block.merge({
          text: text.slice(0, endOffset),
          characterList: chars2.slice(0, endOffset)
        });
      }
      return block;
    }));
  };
  getContentStateFragment_1 = getContentStateFragment;
  return getContentStateFragment_1;
}
var insertIntoList_1;
var hasRequiredInsertIntoList;
function requireInsertIntoList() {
  if (hasRequiredInsertIntoList) return insertIntoList_1;
  hasRequiredInsertIntoList = 1;
  function insertIntoList(targetListArg, toInsert, offset) {
    var targetList = targetListArg;
    if (offset === targetList.count()) {
      toInsert.forEach(function(c2) {
        targetList = targetList.push(c2);
      });
    } else if (offset === 0) {
      toInsert.reverse().forEach(function(c2) {
        targetList = targetList.unshift(c2);
      });
    } else {
      var head = targetList.slice(0, offset);
      var tail = targetList.slice(offset);
      targetList = head.concat(toInsert, tail).toList();
    }
    return targetList;
  }
  insertIntoList_1 = insertIntoList;
  return insertIntoList_1;
}
var insertFragmentIntoContentState_1;
var hasRequiredInsertFragmentIntoContentState;
function requireInsertFragmentIntoContentState() {
  if (hasRequiredInsertFragmentIntoContentState) return insertFragmentIntoContentState_1;
  hasRequiredInsertFragmentIntoContentState = 1;
  var BlockMapBuilder = requireBlockMapBuilder();
  var ContentBlockNode = requireContentBlockNode();
  var Immutable2 = requireImmutable();
  var insertIntoList = requireInsertIntoList();
  var invariant2 = requireInvariant();
  var randomizeBlockMapKeys = requireRandomizeBlockMapKeys();
  var List2 = Immutable2.List;
  var updateExistingBlock = function updateExistingBlock2(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {
    var mergeBlockData = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : "REPLACE_WITH_NEW_DATA";
    var targetBlock = blockMap.get(targetKey);
    var text = targetBlock.getText();
    var chars2 = targetBlock.getCharacterList();
    var finalKey = targetKey;
    var finalOffset = targetOffset + fragmentBlock.getText().length;
    var data = null;
    switch (mergeBlockData) {
      case "MERGE_OLD_DATA_TO_NEW_DATA":
        data = fragmentBlock.getData().merge(targetBlock.getData());
        break;
      case "REPLACE_WITH_NEW_DATA":
        data = fragmentBlock.getData();
        break;
    }
    var type = targetBlock.getType();
    if (text && type === "unstyled") {
      type = fragmentBlock.getType();
    }
    var newBlock = targetBlock.merge({
      text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),
      characterList: insertIntoList(chars2, fragmentBlock.getCharacterList(), targetOffset),
      type,
      data
    });
    return contentState.merge({
      blockMap: blockMap.set(targetKey, newBlock),
      selectionBefore: selectionState,
      selectionAfter: selectionState.merge({
        anchorKey: finalKey,
        anchorOffset: finalOffset,
        focusKey: finalKey,
        focusOffset: finalOffset,
        isBackward: false
      })
    });
  };
  var updateHead = function updateHead2(block, targetOffset, fragment) {
    var text = block.getText();
    var chars2 = block.getCharacterList();
    var headText = text.slice(0, targetOffset);
    var headCharacters = chars2.slice(0, targetOffset);
    var appendToHead = fragment.first();
    return block.merge({
      text: headText + appendToHead.getText(),
      characterList: headCharacters.concat(appendToHead.getCharacterList()),
      type: headText ? block.getType() : appendToHead.getType(),
      data: appendToHead.getData()
    });
  };
  var updateTail = function updateTail2(block, targetOffset, fragment) {
    var text = block.getText();
    var chars2 = block.getCharacterList();
    var blockSize = text.length;
    var tailText = text.slice(targetOffset, blockSize);
    var tailCharacters = chars2.slice(targetOffset, blockSize);
    var prependToTail = fragment.last();
    return prependToTail.merge({
      text: prependToTail.getText() + tailText,
      characterList: prependToTail.getCharacterList().concat(tailCharacters),
      data: prependToTail.getData()
    });
  };
  var getRootBlocks = function getRootBlocks2(block, blockMap) {
    var headKey = block.getKey();
    var rootBlock = block;
    var rootBlocks = [];
    if (blockMap.get(headKey)) {
      rootBlocks.push(headKey);
    }
    while (rootBlock && rootBlock.getNextSiblingKey()) {
      var lastSiblingKey = rootBlock.getNextSiblingKey();
      if (!lastSiblingKey) {
        break;
      }
      rootBlocks.push(lastSiblingKey);
      rootBlock = blockMap.get(lastSiblingKey);
    }
    return rootBlocks;
  };
  var updateBlockMapLinks = function updateBlockMapLinks2(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {
    return blockMap.withMutations(function(blockMapState) {
      var targetKey = targetBlock.getKey();
      var headKey = fragmentHeadBlock.getKey();
      var targetNextKey = targetBlock.getNextSiblingKey();
      var targetParentKey = targetBlock.getParentKey();
      var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);
      var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];
      if (blockMapState.get(headKey)) {
        blockMapState.setIn([targetKey, "nextSibling"], headKey);
        blockMapState.setIn([headKey, "prevSibling"], targetKey);
      } else {
        blockMapState.setIn([targetKey, "nextSibling"], fragmentHeadBlock.getNextSiblingKey());
        blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), "prevSibling"], targetKey);
      }
      blockMapState.setIn([lastRootFragmentBlockKey, "nextSibling"], targetNextKey);
      if (targetNextKey) {
        blockMapState.setIn([targetNextKey, "prevSibling"], lastRootFragmentBlockKey);
      }
      fragmentRootBlocks.forEach(function(blockKey) {
        return blockMapState.setIn([blockKey, "parent"], targetParentKey);
      });
      if (targetParentKey) {
        var targetParent = blockMap.get(targetParentKey);
        var originalTargetParentChildKeys = targetParent.getChildKeys();
        var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);
        var insertionIndex = targetBlockIndex + 1;
        var newChildrenKeysArray = originalTargetParentChildKeys.toArray();
        newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));
        blockMapState.setIn([targetParentKey, "children"], List2(newChildrenKeysArray));
      }
    });
  };
  var insertFragment = function insertFragment2(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {
    var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;
    var newBlockArr = [];
    var fragmentSize = fragment.size;
    var target = blockMap.get(targetKey);
    var head = fragment.first();
    var tail = fragment.last();
    var finalOffset = tail.getLength();
    var finalKey = tail.getKey();
    var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());
    blockMap.forEach(function(block, blockKey) {
      if (blockKey !== targetKey) {
        newBlockArr.push(block);
        return;
      }
      if (shouldNotUpdateFromFragmentBlock) {
        newBlockArr.push(block);
      } else {
        newBlockArr.push(updateHead(block, targetOffset, fragment));
      }
      fragment.slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function(fragmentBlock) {
        return newBlockArr.push(fragmentBlock);
      });
      newBlockArr.push(updateTail(block, targetOffset, fragment));
    });
    var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);
    if (isTreeBasedBlockMap) {
      updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);
    }
    return contentState.merge({
      blockMap: updatedBlockMap,
      selectionBefore: selectionState,
      selectionAfter: selectionState.merge({
        anchorKey: finalKey,
        anchorOffset: finalOffset,
        focusKey: finalKey,
        focusOffset: finalOffset,
        isBackward: false
      })
    });
  };
  var insertFragmentIntoContentState = function insertFragmentIntoContentState2(contentState, selectionState, fragmentBlockMap) {
    var mergeBlockData = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "REPLACE_WITH_NEW_DATA";
    !selectionState.isCollapsed() ? invariant2(false) : void 0;
    var blockMap = contentState.getBlockMap();
    var fragment = randomizeBlockMapKeys(fragmentBlockMap);
    var targetKey = selectionState.getStartKey();
    var targetOffset = selectionState.getStartOffset();
    var targetBlock = blockMap.get(targetKey);
    if (targetBlock instanceof ContentBlockNode) {
      !targetBlock.getChildKeys().isEmpty() ? invariant2(false) : void 0;
    }
    if (fragment.size === 1) {
      return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset, mergeBlockData);
    }
    return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);
  };
  insertFragmentIntoContentState_1 = insertFragmentIntoContentState;
  return insertFragmentIntoContentState_1;
}
var insertTextIntoContentState_1;
var hasRequiredInsertTextIntoContentState;
function requireInsertTextIntoContentState() {
  if (hasRequiredInsertTextIntoContentState) return insertTextIntoContentState_1;
  hasRequiredInsertTextIntoContentState = 1;
  var Immutable2 = requireImmutable();
  var insertIntoList = requireInsertIntoList();
  var invariant2 = requireInvariant();
  var Repeat2 = Immutable2.Repeat;
  function insertTextIntoContentState(contentState, selectionState, text, characterMetadata) {
    !selectionState.isCollapsed() ? invariant2(false) : void 0;
    var len = null;
    if (text != null) {
      len = text.length;
    }
    if (len == null || len === 0) {
      return contentState;
    }
    var blockMap = contentState.getBlockMap();
    var key = selectionState.getStartKey();
    var offset = selectionState.getStartOffset();
    var block = blockMap.get(key);
    var blockText = block.getText();
    var newBlock = block.merge({
      text: blockText.slice(0, offset) + text + blockText.slice(offset, block.getLength()),
      characterList: insertIntoList(block.getCharacterList(), Repeat2(characterMetadata, len).toList(), offset)
    });
    var newOffset = offset + len;
    return contentState.merge({
      blockMap: blockMap.set(key, newBlock),
      selectionAfter: selectionState.merge({
        anchorOffset: newOffset,
        focusOffset: newOffset
      })
    });
  }
  insertTextIntoContentState_1 = insertTextIntoContentState;
  return insertTextIntoContentState_1;
}
var modifyBlockForContentState_1;
var hasRequiredModifyBlockForContentState;
function requireModifyBlockForContentState() {
  if (hasRequiredModifyBlockForContentState) return modifyBlockForContentState_1;
  hasRequiredModifyBlockForContentState = 1;
  var Immutable2 = requireImmutable();
  var Map2 = Immutable2.Map;
  function modifyBlockForContentState(contentState, selectionState, operation) {
    var startKey = selectionState.getStartKey();
    var endKey = selectionState.getEndKey();
    var blockMap = contentState.getBlockMap();
    var newBlocks = blockMap.toSeq().skipUntil(function(_23, k2) {
      return k2 === startKey;
    }).takeUntil(function(_23, k2) {
      return k2 === endKey;
    }).concat(Map2([[endKey, blockMap.get(endKey)]])).map(operation);
    return contentState.merge({
      blockMap: blockMap.merge(newBlocks),
      selectionBefore: selectionState,
      selectionAfter: selectionState
    });
  }
  modifyBlockForContentState_1 = modifyBlockForContentState;
  return modifyBlockForContentState_1;
}
var getNextDelimiterBlockKey_1;
var hasRequiredGetNextDelimiterBlockKey;
function requireGetNextDelimiterBlockKey() {
  if (hasRequiredGetNextDelimiterBlockKey) return getNextDelimiterBlockKey_1;
  hasRequiredGetNextDelimiterBlockKey = 1;
  var ContentBlockNode = requireContentBlockNode();
  var getNextDelimiterBlockKey = function getNextDelimiterBlockKey2(block, blockMap) {
    var isExperimentalTreeBlock = block instanceof ContentBlockNode;
    if (!isExperimentalTreeBlock) {
      return null;
    }
    var nextSiblingKey = block.getNextSiblingKey();
    if (nextSiblingKey) {
      return nextSiblingKey;
    }
    var parent = block.getParentKey();
    if (!parent) {
      return null;
    }
    var nextNonDescendantBlock = blockMap.get(parent);
    while (nextNonDescendantBlock && !nextNonDescendantBlock.getNextSiblingKey()) {
      var parentKey = nextNonDescendantBlock.getParentKey();
      nextNonDescendantBlock = parentKey ? blockMap.get(parentKey) : null;
    }
    if (!nextNonDescendantBlock) {
      return null;
    }
    return nextNonDescendantBlock.getNextSiblingKey();
  };
  getNextDelimiterBlockKey_1 = getNextDelimiterBlockKey;
  return getNextDelimiterBlockKey_1;
}
var removeRangeFromContentState_1;
var hasRequiredRemoveRangeFromContentState;
function requireRemoveRangeFromContentState() {
  if (hasRequiredRemoveRangeFromContentState) return removeRangeFromContentState_1;
  hasRequiredRemoveRangeFromContentState = 1;
  var ContentBlockNode = requireContentBlockNode();
  var getNextDelimiterBlockKey = requireGetNextDelimiterBlockKey();
  var Immutable2 = requireImmutable();
  Immutable2.List;
  var Map2 = Immutable2.Map;
  var transformBlock = function transformBlock2(key, blockMap, func) {
    if (!key) {
      return;
    }
    var block = blockMap.get(key);
    if (!block) {
      return;
    }
    blockMap.set(key, func(block));
  };
  var getAncestorsKeys = function getAncestorsKeys2(blockKey, blockMap) {
    var parents = [];
    if (!blockKey) {
      return parents;
    }
    var blockNode = blockMap.get(blockKey);
    while (blockNode && blockNode.getParentKey()) {
      var parentKey = blockNode.getParentKey();
      if (parentKey) {
        parents.push(parentKey);
      }
      blockNode = parentKey ? blockMap.get(parentKey) : null;
    }
    return parents;
  };
  var getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys2(block, blockMap) {
    var nextDelimiters = [];
    if (!block) {
      return nextDelimiters;
    }
    var nextDelimiter = getNextDelimiterBlockKey(block, blockMap);
    while (nextDelimiter && blockMap.get(nextDelimiter)) {
      var _block = blockMap.get(nextDelimiter);
      nextDelimiters.push(nextDelimiter);
      nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey(_block, blockMap) : null;
    }
    return nextDelimiters;
  };
  var getNextValidSibling = function getNextValidSibling2(block, blockMap, originalBlockMap) {
    if (!block) {
      return null;
    }
    var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();
    while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {
      nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;
    }
    return nextValidSiblingKey;
  };
  var getPrevValidSibling = function getPrevValidSibling2(block, blockMap, originalBlockMap) {
    if (!block) {
      return null;
    }
    var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();
    while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {
      prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;
    }
    return prevValidSiblingKey;
  };
  var updateBlockMapLinks = function updateBlockMapLinks2(blockMap, startBlock, endBlock, originalBlockMap) {
    return blockMap.withMutations(function(blocks) {
      transformBlock(startBlock.getKey(), blocks, function(block) {
        return block.merge({
          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
        });
      });
      transformBlock(endBlock.getKey(), blocks, function(block) {
        return block.merge({
          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
        });
      });
      getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function(parentKey) {
        return transformBlock(parentKey, blocks, function(block) {
          return block.merge({
            children: block.getChildKeys().filter(function(key) {
              return blocks.get(key);
            }),
            nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
            prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
          });
        });
      });
      transformBlock(startBlock.getNextSiblingKey(), blocks, function(block) {
        return block.merge({
          prevSibling: startBlock.getPrevSiblingKey()
        });
      });
      transformBlock(startBlock.getPrevSiblingKey(), blocks, function(block) {
        return block.merge({
          nextSibling: getNextValidSibling(block, blocks, originalBlockMap)
        });
      });
      transformBlock(endBlock.getNextSiblingKey(), blocks, function(block) {
        return block.merge({
          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
        });
      });
      transformBlock(endBlock.getPrevSiblingKey(), blocks, function(block) {
        return block.merge({
          nextSibling: endBlock.getNextSiblingKey()
        });
      });
      getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function(parentKey) {
        transformBlock(parentKey, blocks, function(block) {
          return block.merge({
            children: block.getChildKeys().filter(function(key) {
              return blocks.get(key);
            }),
            nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
            prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
          });
        });
      });
      getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function(delimiterKey) {
        return transformBlock(delimiterKey, blocks, function(block) {
          return block.merge({
            nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
            prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
          });
        });
      });
      if (blockMap.get(startBlock.getKey()) == null && blockMap.get(endBlock.getKey()) != null && endBlock.getParentKey() === startBlock.getKey() && endBlock.getPrevSiblingKey() == null) {
        var prevSiblingKey = startBlock.getPrevSiblingKey();
        transformBlock(endBlock.getKey(), blocks, function(block) {
          return block.merge({
            prevSibling: prevSiblingKey
          });
        });
        transformBlock(prevSiblingKey, blocks, function(block) {
          return block.merge({
            nextSibling: endBlock.getKey()
          });
        });
        var prevSibling = prevSiblingKey ? blockMap.get(prevSiblingKey) : null;
        var newParentKey = prevSibling ? prevSibling.getParentKey() : null;
        startBlock.getChildKeys().forEach(function(childKey) {
          transformBlock(childKey, blocks, function(block) {
            return block.merge({
              parent: newParentKey
              // set to null if there is no parent
            });
          });
        });
        if (newParentKey != null) {
          var newParent = blockMap.get(newParentKey);
          transformBlock(newParentKey, blocks, function(block) {
            return block.merge({
              children: newParent.getChildKeys().concat(startBlock.getChildKeys())
            });
          });
        }
        transformBlock(startBlock.getChildKeys().find(function(key) {
          var block = blockMap.get(key);
          return block.getNextSiblingKey() === null;
        }), blocks, function(block) {
          return block.merge({
            nextSibling: startBlock.getNextSiblingKey()
          });
        });
      }
    });
  };
  var removeRangeFromContentState = function removeRangeFromContentState2(contentState, selectionState) {
    if (selectionState.isCollapsed()) {
      return contentState;
    }
    var blockMap = contentState.getBlockMap();
    var startKey = selectionState.getStartKey();
    var startOffset = selectionState.getStartOffset();
    var endKey = selectionState.getEndKey();
    var endOffset = selectionState.getEndOffset();
    var startBlock = blockMap.get(startKey);
    var endBlock = blockMap.get(endKey);
    var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode;
    var parentAncestors = [];
    if (isExperimentalTreeBlock) {
      var endBlockchildrenKeys = endBlock.getChildKeys();
      var endBlockAncestors = getAncestorsKeys(endKey, blockMap);
      if (endBlock.getNextSiblingKey()) {
        parentAncestors = parentAncestors.concat(endBlockAncestors);
      }
      if (!endBlockchildrenKeys.isEmpty()) {
        parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));
      }
      parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock, blockMap), blockMap));
    }
    var characterList;
    if (startBlock === endBlock) {
      characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);
    } else {
      characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));
    }
    var modifiedStart = startBlock.merge({
      text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),
      characterList
    });
    var shouldDeleteParent = isExperimentalTreeBlock && startOffset === 0 && endOffset === 0 && endBlock.getParentKey() === startKey && endBlock.getPrevSiblingKey() == null;
    var newBlocks = shouldDeleteParent ? Map2([[startKey, null]]) : blockMap.toSeq().skipUntil(function(_23, k2) {
      return k2 === startKey;
    }).takeUntil(function(_23, k2) {
      return k2 === endKey;
    }).filter(function(_23, k2) {
      return parentAncestors.indexOf(k2) === -1;
    }).concat(Map2([[endKey, null]])).map(function(_23, k2) {
      return k2 === startKey ? modifiedStart : null;
    });
    var updatedBlockMap = blockMap.merge(newBlocks).filter(function(block) {
      return !!block;
    });
    if (isExperimentalTreeBlock && startBlock !== endBlock) {
      updatedBlockMap = updateBlockMapLinks(updatedBlockMap, startBlock, endBlock, blockMap);
    }
    return contentState.merge({
      blockMap: updatedBlockMap,
      selectionBefore: selectionState,
      selectionAfter: selectionState.merge({
        anchorKey: startKey,
        anchorOffset: startOffset,
        focusKey: startKey,
        focusOffset: startOffset,
        isBackward: false
      })
    });
  };
  var removeFromList = function removeFromList2(targetList, startOffset, endOffset) {
    if (startOffset === 0) {
      while (startOffset < endOffset) {
        targetList = targetList.shift();
        startOffset++;
      }
    } else if (endOffset === targetList.count()) {
      while (endOffset > startOffset) {
        targetList = targetList.pop();
        endOffset--;
      }
    } else {
      var head = targetList.slice(0, startOffset);
      var tail = targetList.slice(endOffset);
      targetList = head.concat(tail).toList();
    }
    return targetList;
  };
  removeRangeFromContentState_1 = removeRangeFromContentState;
  return removeRangeFromContentState_1;
}
var splitBlockInContentState_1;
var hasRequiredSplitBlockInContentState;
function requireSplitBlockInContentState() {
  if (hasRequiredSplitBlockInContentState) return splitBlockInContentState_1;
  hasRequiredSplitBlockInContentState = 1;
  var ContentBlockNode = requireContentBlockNode();
  var generateRandomKey = requireGenerateRandomKey();
  var Immutable2 = requireImmutable();
  var invariant2 = requireInvariant();
  var modifyBlockForContentState = requireModifyBlockForContentState();
  var List2 = Immutable2.List, Map2 = Immutable2.Map;
  var transformBlock = function transformBlock2(key, blockMap, func) {
    if (!key) {
      return;
    }
    var block = blockMap.get(key);
    if (!block) {
      return;
    }
    blockMap.set(key, func(block));
  };
  var updateBlockMapLinks = function updateBlockMapLinks2(blockMap, originalBlock, belowBlock) {
    return blockMap.withMutations(function(blocks) {
      var originalBlockKey = originalBlock.getKey();
      var belowBlockKey = belowBlock.getKey();
      transformBlock(originalBlock.getParentKey(), blocks, function(block) {
        var parentChildrenList = block.getChildKeys();
        var insertionIndex = parentChildrenList.indexOf(originalBlockKey) + 1;
        var newChildrenArray = parentChildrenList.toArray();
        newChildrenArray.splice(insertionIndex, 0, belowBlockKey);
        return block.merge({
          children: List2(newChildrenArray)
        });
      });
      transformBlock(originalBlock.getNextSiblingKey(), blocks, function(block) {
        return block.merge({
          prevSibling: belowBlockKey
        });
      });
      transformBlock(originalBlockKey, blocks, function(block) {
        return block.merge({
          nextSibling: belowBlockKey
        });
      });
      transformBlock(belowBlockKey, blocks, function(block) {
        return block.merge({
          prevSibling: originalBlockKey
        });
      });
    });
  };
  var splitBlockInContentState = function splitBlockInContentState2(contentState, selectionState) {
    !selectionState.isCollapsed() ? invariant2(false) : void 0;
    var key = selectionState.getAnchorKey();
    var blockMap = contentState.getBlockMap();
    var blockToSplit = blockMap.get(key);
    var text = blockToSplit.getText();
    if (!text) {
      var blockType = blockToSplit.getType();
      if (blockType === "unordered-list-item" || blockType === "ordered-list-item") {
        return modifyBlockForContentState(contentState, selectionState, function(block) {
          return block.merge({
            type: "unstyled",
            depth: 0
          });
        });
      }
    }
    var offset = selectionState.getAnchorOffset();
    var chars2 = blockToSplit.getCharacterList();
    var keyBelow = generateRandomKey();
    var isExperimentalTreeBlock = blockToSplit instanceof ContentBlockNode;
    var blockAbove = blockToSplit.merge({
      text: text.slice(0, offset),
      characterList: chars2.slice(0, offset)
    });
    var blockBelow = blockAbove.merge({
      key: keyBelow,
      text: text.slice(offset),
      characterList: chars2.slice(offset),
      data: Map2()
    });
    var blocksBefore = blockMap.toSeq().takeUntil(function(v2) {
      return v2 === blockToSplit;
    });
    var blocksAfter = blockMap.toSeq().skipUntil(function(v2) {
      return v2 === blockToSplit;
    }).rest();
    var newBlocks = blocksBefore.concat([[key, blockAbove], [keyBelow, blockBelow]], blocksAfter).toOrderedMap();
    if (isExperimentalTreeBlock) {
      !blockToSplit.getChildKeys().isEmpty() ? invariant2(false) : void 0;
      newBlocks = updateBlockMapLinks(newBlocks, blockAbove, blockBelow);
    }
    return contentState.merge({
      blockMap: newBlocks,
      selectionBefore: selectionState,
      selectionAfter: selectionState.merge({
        anchorKey: keyBelow,
        anchorOffset: 0,
        focusKey: keyBelow,
        focusOffset: 0,
        isBackward: false
      })
    });
  };
  splitBlockInContentState_1 = splitBlockInContentState;
  return splitBlockInContentState_1;
}
var DraftModifier_1;
var hasRequiredDraftModifier;
function requireDraftModifier() {
  if (hasRequiredDraftModifier) return DraftModifier_1;
  hasRequiredDraftModifier = 1;
  var CharacterMetadata = requireCharacterMetadata();
  var ContentStateInlineStyle = requireContentStateInlineStyle();
  var applyEntityToContentState = requireApplyEntityToContentState();
  var getCharacterRemovalRange = requireGetCharacterRemovalRange();
  var getContentStateFragment = requireGetContentStateFragment();
  var Immutable2 = requireImmutable();
  var insertFragmentIntoContentState = requireInsertFragmentIntoContentState();
  var insertTextIntoContentState = requireInsertTextIntoContentState();
  var invariant2 = requireInvariant();
  var modifyBlockForContentState = requireModifyBlockForContentState();
  var removeEntitiesAtEdges = requireRemoveEntitiesAtEdges();
  var removeRangeFromContentState = requireRemoveRangeFromContentState();
  var splitBlockInContentState = requireSplitBlockInContentState();
  var OrderedSet2 = Immutable2.OrderedSet;
  var DraftModifier = {
    replaceText: function replaceText(contentState, rangeToReplace, text, inlineStyle, entityKey) {
      var withoutEntities = removeEntitiesAtEdges(contentState, rangeToReplace);
      var withoutText = removeRangeFromContentState(withoutEntities, rangeToReplace);
      var character = CharacterMetadata.create({
        style: inlineStyle || OrderedSet2(),
        entity: entityKey || null
      });
      return insertTextIntoContentState(withoutText, withoutText.getSelectionAfter(), text, character);
    },
    insertText: function insertText(contentState, targetRange, text, inlineStyle, entityKey) {
      !targetRange.isCollapsed() ? invariant2(false) : void 0;
      return DraftModifier.replaceText(contentState, targetRange, text, inlineStyle, entityKey);
    },
    moveText: function moveText(contentState, removalRange, targetRange) {
      var movedFragment = getContentStateFragment(contentState, removalRange);
      var afterRemoval = DraftModifier.removeRange(contentState, removalRange, "backward");
      return DraftModifier.replaceWithFragment(afterRemoval, targetRange, movedFragment);
    },
    replaceWithFragment: function replaceWithFragment(contentState, targetRange, fragment) {
      var mergeBlockData2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "REPLACE_WITH_NEW_DATA";
      var withoutEntities = removeEntitiesAtEdges(contentState, targetRange);
      var withoutText = removeRangeFromContentState(withoutEntities, targetRange);
      return insertFragmentIntoContentState(withoutText, withoutText.getSelectionAfter(), fragment, mergeBlockData2);
    },
    removeRange: function removeRange(contentState, rangeToRemove, removalDirection) {
      var startKey, endKey, startBlock, endBlock;
      if (rangeToRemove.getIsBackward()) {
        rangeToRemove = rangeToRemove.merge({
          anchorKey: rangeToRemove.getFocusKey(),
          anchorOffset: rangeToRemove.getFocusOffset(),
          focusKey: rangeToRemove.getAnchorKey(),
          focusOffset: rangeToRemove.getAnchorOffset(),
          isBackward: false
        });
      }
      startKey = rangeToRemove.getAnchorKey();
      endKey = rangeToRemove.getFocusKey();
      startBlock = contentState.getBlockForKey(startKey);
      endBlock = contentState.getBlockForKey(endKey);
      var startOffset = rangeToRemove.getStartOffset();
      var endOffset = rangeToRemove.getEndOffset();
      var startEntityKey = startBlock.getEntityAt(startOffset);
      var endEntityKey = endBlock.getEntityAt(endOffset - 1);
      if (startKey === endKey) {
        if (startEntityKey && startEntityKey === endEntityKey) {
          var adjustedRemovalRange = getCharacterRemovalRange(contentState.getEntityMap(), startBlock, endBlock, rangeToRemove, removalDirection);
          return removeRangeFromContentState(contentState, adjustedRemovalRange);
        }
      }
      var withoutEntities = removeEntitiesAtEdges(contentState, rangeToRemove);
      return removeRangeFromContentState(withoutEntities, rangeToRemove);
    },
    splitBlock: function splitBlock(contentState, selectionState) {
      var withoutEntities = removeEntitiesAtEdges(contentState, selectionState);
      var withoutText = removeRangeFromContentState(withoutEntities, selectionState);
      return splitBlockInContentState(withoutText, withoutText.getSelectionAfter());
    },
    applyInlineStyle: function applyInlineStyle(contentState, selectionState, inlineStyle) {
      return ContentStateInlineStyle.add(contentState, selectionState, inlineStyle);
    },
    removeInlineStyle: function removeInlineStyle(contentState, selectionState, inlineStyle) {
      return ContentStateInlineStyle.remove(contentState, selectionState, inlineStyle);
    },
    setBlockType: function setBlockType(contentState, selectionState, blockType) {
      return modifyBlockForContentState(contentState, selectionState, function(block) {
        return block.merge({
          type: blockType,
          depth: 0
        });
      });
    },
    setBlockData: function setBlockData(contentState, selectionState, blockData) {
      return modifyBlockForContentState(contentState, selectionState, function(block) {
        return block.merge({
          data: blockData
        });
      });
    },
    mergeBlockData: function mergeBlockData(contentState, selectionState, blockData) {
      return modifyBlockForContentState(contentState, selectionState, function(block) {
        return block.merge({
          data: block.getData().merge(blockData)
        });
      });
    },
    applyEntity: function applyEntity(contentState, selectionState, entityKey) {
      var withoutEntities = removeEntitiesAtEdges(contentState, selectionState);
      return applyEntityToContentState(withoutEntities, selectionState, entityKey);
    }
  };
  DraftModifier_1 = DraftModifier;
  return DraftModifier_1;
}
var getOwnObjectValues_1;
var hasRequiredGetOwnObjectValues;
function requireGetOwnObjectValues() {
  if (hasRequiredGetOwnObjectValues) return getOwnObjectValues_1;
  hasRequiredGetOwnObjectValues = 1;
  function getOwnObjectValues(obj) {
    return Object.keys(obj).map(function(key) {
      return obj[key];
    });
  }
  getOwnObjectValues_1 = getOwnObjectValues;
  return getOwnObjectValues_1;
}
var BlockTree_1;
var hasRequiredBlockTree;
function requireBlockTree() {
  if (hasRequiredBlockTree) return BlockTree_1;
  hasRequiredBlockTree = 1;
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectWithoutPropertiesLoose2(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  var findRangesImmutable = requireFindRangesImmutable();
  var getOwnObjectValues = requireGetOwnObjectValues();
  var Immutable2 = requireImmutable();
  var List2 = Immutable2.List, Repeat2 = Immutable2.Repeat, Record3 = Immutable2.Record;
  var returnTrue2 = function returnTrue3() {
    return true;
  };
  var defaultLeafRange = {
    start: null,
    end: null
  };
  var LeafRange = Record3(defaultLeafRange);
  var defaultDecoratorRange = {
    start: null,
    end: null,
    decoratorKey: null,
    leaves: null
  };
  var DecoratorRange = Record3(defaultDecoratorRange);
  var BlockTree = {
    /**
     * Generate a block tree for a given ContentBlock/decorator pair.
     */
    generate: function generate(contentState, block, decorator) {
      var textLength = block.getLength();
      if (!textLength) {
        return List2.of(new DecoratorRange({
          start: 0,
          end: 0,
          decoratorKey: null,
          leaves: List2.of(new LeafRange({
            start: 0,
            end: 0
          }))
        }));
      }
      var leafSets = [];
      var decorations = decorator ? decorator.getDecorations(block, contentState) : List2(Repeat2(null, textLength));
      var chars2 = block.getCharacterList();
      findRangesImmutable(decorations, areEqual, returnTrue2, function(start, end) {
        leafSets.push(new DecoratorRange({
          start,
          end,
          decoratorKey: decorations.get(start),
          leaves: generateLeaves(chars2.slice(start, end).toList(), start)
        }));
      });
      return List2(leafSets);
    },
    fromJS: function fromJS2(_ref) {
      var leaves = _ref.leaves, other = _objectWithoutPropertiesLoose2(_ref, ["leaves"]);
      return new DecoratorRange(_objectSpread3({}, other, {
        leaves: leaves != null ? List2(Array.isArray(leaves) ? leaves : getOwnObjectValues(leaves)).map(function(leaf) {
          return LeafRange(leaf);
        }) : null
      }));
    }
  };
  function generateLeaves(characters, offset) {
    var leaves = [];
    var inlineStyles = characters.map(function(c2) {
      return c2.getStyle();
    }).toList();
    findRangesImmutable(inlineStyles, areEqual, returnTrue2, function(start, end) {
      leaves.push(new LeafRange({
        start: start + offset,
        end: end + offset
      }));
    });
    return List2(leaves);
  }
  function areEqual(a2, b2) {
    return a2 === b2;
  }
  BlockTree_1 = BlockTree;
  return BlockTree_1;
}
var DraftEntityInstance_1;
var hasRequiredDraftEntityInstance;
function requireDraftEntityInstance() {
  if (hasRequiredDraftEntityInstance) return DraftEntityInstance_1;
  hasRequiredDraftEntityInstance = 1;
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var Immutable2 = requireImmutable();
  var Record3 = Immutable2.Record;
  var DraftEntityInstanceRecord = Record3({
    type: "TOKEN",
    mutability: "IMMUTABLE",
    data: Object
  });
  var DraftEntityInstance = /* @__PURE__ */ (function(_DraftEntityInstanceR) {
    _inheritsLoose2(DraftEntityInstance2, _DraftEntityInstanceR);
    function DraftEntityInstance2() {
      return _DraftEntityInstanceR.apply(this, arguments) || this;
    }
    var _proto = DraftEntityInstance2.prototype;
    _proto.getType = function getType2() {
      return this.get("type");
    };
    _proto.getMutability = function getMutability() {
      return this.get("mutability");
    };
    _proto.getData = function getData3() {
      return this.get("data");
    };
    return DraftEntityInstance2;
  })(DraftEntityInstanceRecord);
  DraftEntityInstance_1 = DraftEntityInstance;
  return DraftEntityInstance_1;
}
var uuid_1;
var hasRequiredUuid;
function requireUuid() {
  if (hasRequiredUuid) return uuid_1;
  hasRequiredUuid = 1;
  function uuid() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
      var r2 = Math.random() * 16 | 0;
      var v2 = c2 == "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    });
  }
  uuid_1 = uuid;
  return uuid_1;
}
var DraftEntity_1;
var hasRequiredDraftEntity;
function requireDraftEntity() {
  if (hasRequiredDraftEntity) return DraftEntity_1;
  hasRequiredDraftEntity = 1;
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var DraftEntityInstance = requireDraftEntityInstance();
  var Immutable2 = requireImmutable();
  var invariant2 = requireInvariant();
  var uuid = requireUuid();
  var Map2 = Immutable2.Map;
  var instances = Map2();
  var instanceKey = uuid();
  function logWarning(oldMethodCall, newMethodCall) {
    console.warn("WARNING: " + oldMethodCall + ' will be deprecated soon!\nPlease use "' + newMethodCall + '" instead.');
  }
  var DraftEntity = {
    /**
     * WARNING: This method will be deprecated soon!
     * Please use 'contentState.getLastCreatedEntityKey' instead.
     * ---
     * Get the random key string from whatever entity was last created.
     * We need this to support the new API, as part of transitioning to put Entity
     * storage in contentState.
     */
    getLastCreatedEntityKey: function getLastCreatedEntityKey() {
      logWarning("DraftEntity.getLastCreatedEntityKey", "contentState.getLastCreatedEntityKey");
      return DraftEntity.__getLastCreatedEntityKey();
    },
    /**
     * WARNING: This method will be deprecated soon!
     * Please use 'contentState.createEntity' instead.
     * ---
     * Create a DraftEntityInstance and store it for later retrieval.
     *
     * A random key string will be generated and returned. This key may
     * be used to track the entity's usage in a ContentBlock, and for
     * retrieving data about the entity at render time.
     */
    create: function create3(type, mutability, data) {
      logWarning("DraftEntity.create", "contentState.createEntity");
      return DraftEntity.__create(type, mutability, data);
    },
    /**
     * WARNING: This method will be deprecated soon!
     * Please use 'contentState.addEntity' instead.
     * ---
     * Add an existing DraftEntityInstance to the DraftEntity map. This is
     * useful when restoring instances from the server.
     */
    add: function add2(instance2) {
      logWarning("DraftEntity.add", "contentState.addEntity");
      return DraftEntity.__add(instance2);
    },
    /**
     * WARNING: This method will be deprecated soon!
     * Please use 'contentState.getEntity' instead.
     * ---
     * Retrieve the entity corresponding to the supplied key string.
     */
    get: function get11(key) {
      logWarning("DraftEntity.get", "contentState.getEntity");
      return DraftEntity.__get(key);
    },
    /**
     * Get all the entities in the content state.
     */
    __getAll: function __getAll() {
      return instances;
    },
    /**
     * Load the entity map with the given set of entities.
     */
    __loadWithEntities: function __loadWithEntities(entities) {
      instances = entities;
      instanceKey = uuid();
    },
    /**
     * WARNING: This method will be deprecated soon!
     * Please use 'contentState.mergeEntityData' instead.
     * ---
     * Entity instances are immutable. If you need to update the data for an
     * instance, this method will merge your data updates and return a new
     * instance.
     */
    mergeData: function mergeData(key, toMerge) {
      logWarning("DraftEntity.mergeData", "contentState.mergeEntityData");
      return DraftEntity.__mergeData(key, toMerge);
    },
    /**
     * WARNING: This method will be deprecated soon!
     * Please use 'contentState.replaceEntityData' instead.
     * ---
     * Completely replace the data for a given instance.
     */
    replaceData: function replaceData(key, newData) {
      logWarning("DraftEntity.replaceData", "contentState.replaceEntityData");
      return DraftEntity.__replaceData(key, newData);
    },
    // ***********************************WARNING******************************
    // --- the above public API will be deprecated in the next version of Draft!
    // The methods below this line are private - don't call them directly.
    /**
     * Get the random key string from whatever entity was last created.
     * We need this to support the new API, as part of transitioning to put Entity
     * storage in contentState.
     */
    __getLastCreatedEntityKey: function __getLastCreatedEntityKey() {
      return instanceKey;
    },
    /**
     * Create a DraftEntityInstance and store it for later retrieval.
     *
     * A random key string will be generated and returned. This key may
     * be used to track the entity's usage in a ContentBlock, and for
     * retrieving data about the entity at render time.
     */
    __create: function __create(type, mutability, data) {
      return DraftEntity.__add(new DraftEntityInstance({
        type,
        mutability,
        data: data || {}
      }));
    },
    /**
     * Add an existing DraftEntityInstance to the DraftEntity map. This is
     * useful when restoring instances from the server.
     */
    __add: function __add(instance2) {
      instanceKey = uuid();
      instances = instances.set(instanceKey, instance2);
      return instanceKey;
    },
    /**
     * Retrieve the entity corresponding to the supplied key string.
     */
    __get: function __get(key) {
      var instance2 = instances.get(key);
      !!!instance2 ? invariant2(false) : void 0;
      return instance2;
    },
    /**
     * Entity instances are immutable. If you need to update the data for an
     * instance, this method will merge your data updates and return a new
     * instance.
     */
    __mergeData: function __mergeData(key, toMerge) {
      var instance2 = DraftEntity.__get(key);
      var newData = _objectSpread3({}, instance2.getData(), toMerge);
      var newInstance = instance2.set("data", newData);
      instances = instances.set(key, newInstance);
      return newInstance;
    },
    /**
     * Completely replace the data for a given instance.
     */
    __replaceData: function __replaceData(key, newData) {
      var instance2 = DraftEntity.__get(key);
      var newInstance = instance2.set("data", newData);
      instances = instances.set(key, newInstance);
      return newInstance;
    }
  };
  DraftEntity_1 = DraftEntity;
  return DraftEntity_1;
}
var SelectionState_1;
var hasRequiredSelectionState;
function requireSelectionState() {
  if (hasRequiredSelectionState) return SelectionState_1;
  hasRequiredSelectionState = 1;
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var Immutable2 = requireImmutable();
  var Record3 = Immutable2.Record;
  var defaultRecord = {
    anchorKey: "",
    anchorOffset: 0,
    focusKey: "",
    focusOffset: 0,
    isBackward: false,
    hasFocus: false
  };
  var SelectionStateRecord = Record3(defaultRecord);
  var SelectionState = /* @__PURE__ */ (function(_SelectionStateRecord) {
    _inheritsLoose2(SelectionState2, _SelectionStateRecord);
    function SelectionState2() {
      return _SelectionStateRecord.apply(this, arguments) || this;
    }
    var _proto = SelectionState2.prototype;
    _proto.serialize = function serialize() {
      return "Anchor: " + this.getAnchorKey() + ":" + this.getAnchorOffset() + ", Focus: " + this.getFocusKey() + ":" + this.getFocusOffset() + ", Is Backward: " + String(this.getIsBackward()) + ", Has Focus: " + String(this.getHasFocus());
    };
    _proto.getAnchorKey = function getAnchorKey() {
      return this.get("anchorKey");
    };
    _proto.getAnchorOffset = function getAnchorOffset() {
      return this.get("anchorOffset");
    };
    _proto.getFocusKey = function getFocusKey() {
      return this.get("focusKey");
    };
    _proto.getFocusOffset = function getFocusOffset() {
      return this.get("focusOffset");
    };
    _proto.getIsBackward = function getIsBackward() {
      return this.get("isBackward");
    };
    _proto.getHasFocus = function getHasFocus() {
      return this.get("hasFocus");
    };
    _proto.hasEdgeWithin = function hasEdgeWithin(blockKey, start, end) {
      var anchorKey = this.getAnchorKey();
      var focusKey = this.getFocusKey();
      if (anchorKey === focusKey && anchorKey === blockKey) {
        var selectionStart = this.getStartOffset();
        var selectionEnd = this.getEndOffset();
        return start <= selectionStart && selectionStart <= end || // selectionStart is between start and end, or
        start <= selectionEnd && selectionEnd <= end;
      }
      if (blockKey !== anchorKey && blockKey !== focusKey) {
        return false;
      }
      var offsetToCheck = blockKey === anchorKey ? this.getAnchorOffset() : this.getFocusOffset();
      return start <= offsetToCheck && end >= offsetToCheck;
    };
    _proto.isCollapsed = function isCollapsed() {
      return this.getAnchorKey() === this.getFocusKey() && this.getAnchorOffset() === this.getFocusOffset();
    };
    _proto.getStartKey = function getStartKey() {
      return this.getIsBackward() ? this.getFocusKey() : this.getAnchorKey();
    };
    _proto.getStartOffset = function getStartOffset() {
      return this.getIsBackward() ? this.getFocusOffset() : this.getAnchorOffset();
    };
    _proto.getEndKey = function getEndKey() {
      return this.getIsBackward() ? this.getAnchorKey() : this.getFocusKey();
    };
    _proto.getEndOffset = function getEndOffset() {
      return this.getIsBackward() ? this.getAnchorOffset() : this.getFocusOffset();
    };
    SelectionState2.createEmpty = function createEmpty(key) {
      return new SelectionState2({
        anchorKey: key,
        anchorOffset: 0,
        focusKey: key,
        focusOffset: 0,
        isBackward: false,
        hasFocus: false
      });
    };
    return SelectionState2;
  })(SelectionStateRecord);
  SelectionState_1 = SelectionState;
  return SelectionState_1;
}
var gkx;
var hasRequiredGkx;
function requireGkx() {
  if (hasRequiredGkx) return gkx;
  hasRequiredGkx = 1;
  gkx = function(name) {
    if (typeof window !== "undefined" && window.__DRAFT_GKX) {
      return !!window.__DRAFT_GKX[name];
    }
    return false;
  };
  return gkx;
}
var sanitizeDraftText_1;
var hasRequiredSanitizeDraftText;
function requireSanitizeDraftText() {
  if (hasRequiredSanitizeDraftText) return sanitizeDraftText_1;
  hasRequiredSanitizeDraftText = 1;
  var REGEX_BLOCK_DELIMITER = new RegExp("\r", "g");
  function sanitizeDraftText(input) {
    return input.replace(REGEX_BLOCK_DELIMITER, "");
  }
  sanitizeDraftText_1 = sanitizeDraftText;
  return sanitizeDraftText_1;
}
var ContentState_1;
var hasRequiredContentState;
function requireContentState() {
  if (hasRequiredContentState) return ContentState_1;
  hasRequiredContentState = 1;
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var BlockMapBuilder = requireBlockMapBuilder();
  var CharacterMetadata = requireCharacterMetadata();
  var ContentBlock = requireContentBlock();
  var ContentBlockNode = requireContentBlockNode();
  var DraftEntity = requireDraftEntity();
  var SelectionState = requireSelectionState();
  var generateRandomKey = requireGenerateRandomKey();
  var getOwnObjectValues = requireGetOwnObjectValues();
  var gkx2 = requireGkx();
  var Immutable2 = requireImmutable();
  var sanitizeDraftText = requireSanitizeDraftText();
  var List2 = Immutable2.List, Record3 = Immutable2.Record, Repeat2 = Immutable2.Repeat, ImmutableMap = Immutable2.Map, OrderedMap2 = Immutable2.OrderedMap;
  var defaultRecord = {
    entityMap: null,
    blockMap: null,
    selectionBefore: null,
    selectionAfter: null
  };
  var ContentStateRecord = Record3(defaultRecord);
  var ContentBlockNodeRecord = gkx2("draft_tree_data_support") ? ContentBlockNode : ContentBlock;
  var ContentState = /* @__PURE__ */ (function(_ContentStateRecord) {
    _inheritsLoose2(ContentState2, _ContentStateRecord);
    function ContentState2() {
      return _ContentStateRecord.apply(this, arguments) || this;
    }
    var _proto = ContentState2.prototype;
    _proto.getEntityMap = function getEntityMap() {
      return DraftEntity;
    };
    _proto.getBlockMap = function getBlockMap() {
      return this.get("blockMap");
    };
    _proto.getSelectionBefore = function getSelectionBefore() {
      return this.get("selectionBefore");
    };
    _proto.getSelectionAfter = function getSelectionAfter() {
      return this.get("selectionAfter");
    };
    _proto.getBlockForKey = function getBlockForKey(key) {
      var block = this.getBlockMap().get(key);
      return block;
    };
    _proto.getKeyBefore = function getKeyBefore(key) {
      return this.getBlockMap().reverse().keySeq().skipUntil(function(v2) {
        return v2 === key;
      }).skip(1).first();
    };
    _proto.getKeyAfter = function getKeyAfter(key) {
      return this.getBlockMap().keySeq().skipUntil(function(v2) {
        return v2 === key;
      }).skip(1).first();
    };
    _proto.getBlockAfter = function getBlockAfter(key) {
      return this.getBlockMap().skipUntil(function(_23, k2) {
        return k2 === key;
      }).skip(1).first();
    };
    _proto.getBlockBefore = function getBlockBefore(key) {
      return this.getBlockMap().reverse().skipUntil(function(_23, k2) {
        return k2 === key;
      }).skip(1).first();
    };
    _proto.getBlocksAsArray = function getBlocksAsArray() {
      return this.getBlockMap().toArray();
    };
    _proto.getFirstBlock = function getFirstBlock() {
      return this.getBlockMap().first();
    };
    _proto.getLastBlock = function getLastBlock() {
      return this.getBlockMap().last();
    };
    _proto.getPlainText = function getPlainText(delimiter) {
      return this.getBlockMap().map(function(block) {
        return block ? block.getText() : "";
      }).join(delimiter || "\n");
    };
    _proto.getLastCreatedEntityKey = function getLastCreatedEntityKey() {
      return DraftEntity.__getLastCreatedEntityKey();
    };
    _proto.hasText = function hasText() {
      var blockMap = this.getBlockMap();
      return blockMap.size > 1 || // make sure that there are no zero width space chars
      escape(blockMap.first().getText()).replace(/%u200B/g, "").length > 0;
    };
    _proto.createEntity = function createEntity(type, mutability, data) {
      DraftEntity.__create(type, mutability, data);
      return this;
    };
    _proto.mergeEntityData = function mergeEntityData(key, toMerge) {
      DraftEntity.__mergeData(key, toMerge);
      return this;
    };
    _proto.replaceEntityData = function replaceEntityData(key, newData) {
      DraftEntity.__replaceData(key, newData);
      return this;
    };
    _proto.addEntity = function addEntity(instance2) {
      DraftEntity.__add(instance2);
      return this;
    };
    _proto.getEntity = function getEntity(key) {
      return DraftEntity.__get(key);
    };
    _proto.getAllEntities = function getAllEntities() {
      return DraftEntity.__getAll();
    };
    _proto.loadWithEntities = function loadWithEntities(entities) {
      return DraftEntity.__loadWithEntities(entities);
    };
    ContentState2.createFromBlockArray = function createFromBlockArray(blocks, entityMap) {
      var theBlocks = Array.isArray(blocks) ? blocks : blocks.contentBlocks;
      var blockMap = BlockMapBuilder.createFromArray(theBlocks);
      var selectionState = blockMap.isEmpty() ? new SelectionState() : SelectionState.createEmpty(blockMap.first().getKey());
      return new ContentState2({
        blockMap,
        entityMap: entityMap || DraftEntity,
        selectionBefore: selectionState,
        selectionAfter: selectionState
      });
    };
    ContentState2.createFromText = function createFromText(text) {
      var delimiter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /\r\n?|\n/g;
      var strings = text.split(delimiter);
      var blocks = strings.map(function(block) {
        block = sanitizeDraftText(block);
        return new ContentBlockNodeRecord({
          key: generateRandomKey(),
          text: block,
          type: "unstyled",
          characterList: List2(Repeat2(CharacterMetadata.EMPTY, block.length))
        });
      });
      return ContentState2.createFromBlockArray(blocks);
    };
    ContentState2.fromJS = function fromJS2(state) {
      return new ContentState2(_objectSpread3({}, state, {
        blockMap: OrderedMap2(state.blockMap).map(ContentState2.createContentBlockFromJS),
        selectionBefore: new SelectionState(state.selectionBefore),
        selectionAfter: new SelectionState(state.selectionAfter)
      }));
    };
    ContentState2.createContentBlockFromJS = function createContentBlockFromJS(block) {
      var characterList = block.characterList;
      return new ContentBlockNodeRecord(_objectSpread3({}, block, {
        data: ImmutableMap(block.data),
        characterList: characterList != null ? List2((Array.isArray(characterList) ? characterList : getOwnObjectValues(characterList)).map(function(c2) {
          return CharacterMetadata.fromJS(c2);
        })) : void 0
      }));
    };
    return ContentState2;
  })(ContentStateRecord);
  ContentState_1 = ContentState;
  return ContentState_1;
}
var UnicodeBidiDirection_1;
var hasRequiredUnicodeBidiDirection;
function requireUnicodeBidiDirection() {
  if (hasRequiredUnicodeBidiDirection) return UnicodeBidiDirection_1;
  hasRequiredUnicodeBidiDirection = 1;
  var invariant2 = requireInvariant();
  var NEUTRAL = "NEUTRAL";
  var LTR = "LTR";
  var RTL = "RTL";
  var globalDir = null;
  function isStrong(dir) {
    return dir === LTR || dir === RTL;
  }
  function getHTMLDir(dir) {
    !isStrong(dir) ? invariant2(false) : void 0;
    return dir === LTR ? "ltr" : "rtl";
  }
  function getHTMLDirIfDifferent(dir, otherDir) {
    !isStrong(dir) ? invariant2(false) : void 0;
    !isStrong(otherDir) ? invariant2(false) : void 0;
    return dir === otherDir ? null : getHTMLDir(dir);
  }
  function setGlobalDir(dir) {
    globalDir = dir;
  }
  function initGlobalDir() {
    setGlobalDir(LTR);
  }
  function getGlobalDir() {
    if (!globalDir) {
      this.initGlobalDir();
    }
    !globalDir ? invariant2(false) : void 0;
    return globalDir;
  }
  var UnicodeBidiDirection = {
    // Values
    NEUTRAL,
    LTR,
    RTL,
    // Helpers
    isStrong,
    getHTMLDir,
    getHTMLDirIfDifferent,
    // Global Direction
    setGlobalDir,
    initGlobalDir,
    getGlobalDir
  };
  UnicodeBidiDirection_1 = UnicodeBidiDirection;
  return UnicodeBidiDirection_1;
}
var UnicodeBidi_1;
var hasRequiredUnicodeBidi;
function requireUnicodeBidi() {
  if (hasRequiredUnicodeBidi) return UnicodeBidi_1;
  hasRequiredUnicodeBidi = 1;
  var UnicodeBidiDirection = requireUnicodeBidiDirection();
  var invariant2 = requireInvariant();
  var RANGE_BY_BIDI_TYPE = {
    L: "A-Za-z-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
    R: "----------------------",
    AL: "------------------------------"
  };
  var REGEX_STRONG = new RegExp("[" + RANGE_BY_BIDI_TYPE.L + RANGE_BY_BIDI_TYPE.R + RANGE_BY_BIDI_TYPE.AL + "]");
  var REGEX_RTL = new RegExp("[" + RANGE_BY_BIDI_TYPE.R + RANGE_BY_BIDI_TYPE.AL + "]");
  function firstStrongChar(str) {
    var match2 = REGEX_STRONG.exec(str);
    return match2 == null ? null : match2[0];
  }
  function firstStrongCharDir(str) {
    var strongChar = firstStrongChar(str);
    if (strongChar == null) {
      return UnicodeBidiDirection.NEUTRAL;
    }
    return REGEX_RTL.exec(strongChar) ? UnicodeBidiDirection.RTL : UnicodeBidiDirection.LTR;
  }
  function resolveBlockDir(str, fallback) {
    fallback = fallback || UnicodeBidiDirection.NEUTRAL;
    if (!str.length) {
      return fallback;
    }
    var blockDir = firstStrongCharDir(str);
    return blockDir === UnicodeBidiDirection.NEUTRAL ? fallback : blockDir;
  }
  function getDirection(str, strongFallback) {
    if (!strongFallback) {
      strongFallback = UnicodeBidiDirection.getGlobalDir();
    }
    !UnicodeBidiDirection.isStrong(strongFallback) ? invariant2(false) : void 0;
    return resolveBlockDir(str, strongFallback);
  }
  function isDirectionLTR(str, strongFallback) {
    return getDirection(str, strongFallback) === UnicodeBidiDirection.LTR;
  }
  function isDirectionRTL(str, strongFallback) {
    return getDirection(str, strongFallback) === UnicodeBidiDirection.RTL;
  }
  var UnicodeBidi = {
    firstStrongChar,
    firstStrongCharDir,
    resolveBlockDir,
    getDirection,
    isDirectionLTR,
    isDirectionRTL
  };
  UnicodeBidi_1 = UnicodeBidi;
  return UnicodeBidi_1;
}
var UnicodeBidiService_1;
var hasRequiredUnicodeBidiService;
function requireUnicodeBidiService() {
  if (hasRequiredUnicodeBidiService) return UnicodeBidiService_1;
  hasRequiredUnicodeBidiService = 1;
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var UnicodeBidi = requireUnicodeBidi();
  var UnicodeBidiDirection = requireUnicodeBidiDirection();
  var invariant2 = requireInvariant();
  var UnicodeBidiService = /* @__PURE__ */ (function() {
    function UnicodeBidiService2(defaultDir) {
      _defineProperty2(this, "_defaultDir", void 0);
      _defineProperty2(this, "_lastDir", void 0);
      if (!defaultDir) {
        defaultDir = UnicodeBidiDirection.getGlobalDir();
      } else {
        !UnicodeBidiDirection.isStrong(defaultDir) ? invariant2(false) : void 0;
      }
      this._defaultDir = defaultDir;
      this.reset();
    }
    var _proto = UnicodeBidiService2.prototype;
    _proto.reset = function reset2() {
      this._lastDir = this._defaultDir;
    };
    _proto.getDirection = function getDirection(str) {
      this._lastDir = UnicodeBidi.getDirection(str, this._lastDir);
      return this._lastDir;
    };
    return UnicodeBidiService2;
  })();
  UnicodeBidiService_1 = UnicodeBidiService;
  return UnicodeBidiService_1;
}
var nullthrows_1;
var hasRequiredNullthrows;
function requireNullthrows() {
  if (hasRequiredNullthrows) return nullthrows_1;
  hasRequiredNullthrows = 1;
  var nullthrows = function nullthrows2(x2) {
    if (x2 != null) {
      return x2;
    }
    throw new Error("Got unexpected null or undefined");
  };
  nullthrows_1 = nullthrows;
  return nullthrows_1;
}
var EditorBidiService_1;
var hasRequiredEditorBidiService;
function requireEditorBidiService() {
  if (hasRequiredEditorBidiService) return EditorBidiService_1;
  hasRequiredEditorBidiService = 1;
  var UnicodeBidiService = requireUnicodeBidiService();
  var Immutable2 = requireImmutable();
  var nullthrows = requireNullthrows();
  var OrderedMap2 = Immutable2.OrderedMap;
  var bidiService;
  var EditorBidiService = {
    getDirectionMap: function getDirectionMap(content, prevBidiMap) {
      if (!bidiService) {
        bidiService = new UnicodeBidiService();
      } else {
        bidiService.reset();
      }
      var blockMap = content.getBlockMap();
      var nextBidi = blockMap.valueSeq().map(function(block) {
        return nullthrows(bidiService).getDirection(block.getText());
      });
      var bidiMap = OrderedMap2(blockMap.keySeq().zip(nextBidi));
      if (prevBidiMap != null && Immutable2.is(prevBidiMap, bidiMap)) {
        return prevBidiMap;
      }
      return bidiMap;
    }
  };
  EditorBidiService_1 = EditorBidiService;
  return EditorBidiService_1;
}
var EditorState_1;
var hasRequiredEditorState;
function requireEditorState() {
  if (hasRequiredEditorState) return EditorState_1;
  hasRequiredEditorState = 1;
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var BlockTree = requireBlockTree();
  var ContentState = requireContentState();
  var EditorBidiService = requireEditorBidiService();
  var SelectionState = requireSelectionState();
  var Immutable2 = requireImmutable();
  var OrderedSet2 = Immutable2.OrderedSet, Record3 = Immutable2.Record, Stack2 = Immutable2.Stack, OrderedMap2 = Immutable2.OrderedMap, List2 = Immutable2.List;
  var defaultRecord = {
    allowUndo: true,
    currentContent: null,
    decorator: null,
    directionMap: null,
    forceSelection: false,
    inCompositionMode: false,
    inlineStyleOverride: null,
    lastChangeType: null,
    nativelyRenderedContent: null,
    redoStack: Stack2(),
    selection: null,
    treeMap: null,
    undoStack: Stack2()
  };
  var EditorStateRecord = Record3(defaultRecord);
  var EditorState = /* @__PURE__ */ (function() {
    EditorState2.createEmpty = function createEmpty(decorator) {
      return this.createWithText("", decorator);
    };
    EditorState2.createWithText = function createWithText(text, decorator) {
      return EditorState2.createWithContent(ContentState.createFromText(text), decorator);
    };
    EditorState2.createWithContent = function createWithContent(contentState, decorator) {
      if (contentState.getBlockMap().count() === 0) {
        return EditorState2.createEmpty(decorator);
      }
      var firstKey = contentState.getBlockMap().first().getKey();
      return EditorState2.create({
        currentContent: contentState,
        undoStack: Stack2(),
        redoStack: Stack2(),
        decorator: decorator || null,
        selection: SelectionState.createEmpty(firstKey)
      });
    };
    EditorState2.create = function create3(config) {
      var currentContent = config.currentContent, decorator = config.decorator;
      var recordConfig = _objectSpread3({}, config, {
        treeMap: generateNewTreeMap(currentContent, decorator),
        directionMap: EditorBidiService.getDirectionMap(currentContent)
      });
      return new EditorState2(new EditorStateRecord(recordConfig));
    };
    EditorState2.fromJS = function fromJS2(config) {
      return new EditorState2(new EditorStateRecord(_objectSpread3({}, config, {
        directionMap: config.directionMap != null ? OrderedMap2(config.directionMap) : config.directionMap,
        inlineStyleOverride: config.inlineStyleOverride != null ? OrderedSet2(config.inlineStyleOverride) : config.inlineStyleOverride,
        nativelyRenderedContent: config.nativelyRenderedContent != null ? ContentState.fromJS(config.nativelyRenderedContent) : config.nativelyRenderedContent,
        redoStack: config.redoStack != null ? Stack2(config.redoStack.map(function(v2) {
          return ContentState.fromJS(v2);
        })) : config.redoStack,
        selection: config.selection != null ? new SelectionState(config.selection) : config.selection,
        treeMap: config.treeMap != null ? OrderedMap2(config.treeMap).map(function(v2) {
          return List2(v2).map(function(v3) {
            return BlockTree.fromJS(v3);
          });
        }) : config.treeMap,
        undoStack: config.undoStack != null ? Stack2(config.undoStack.map(function(v2) {
          return ContentState.fromJS(v2);
        })) : config.undoStack,
        currentContent: ContentState.fromJS(config.currentContent)
      })));
    };
    EditorState2.set = function set3(editorState, put) {
      var map3 = editorState.getImmutable().withMutations(function(state) {
        var existingDecorator = state.get("decorator");
        var decorator = existingDecorator;
        if (put.decorator === null) {
          decorator = null;
        } else if (put.decorator) {
          decorator = put.decorator;
        }
        var newContent = put.currentContent || editorState.getCurrentContent();
        if (decorator !== existingDecorator) {
          var treeMap = state.get("treeMap");
          var newTreeMap;
          if (decorator && existingDecorator) {
            newTreeMap = regenerateTreeForNewDecorator(newContent, newContent.getBlockMap(), treeMap, decorator, existingDecorator);
          } else {
            newTreeMap = generateNewTreeMap(newContent, decorator);
          }
          state.merge({
            decorator,
            treeMap: newTreeMap,
            nativelyRenderedContent: null
          });
          return;
        }
        var existingContent = editorState.getCurrentContent();
        if (newContent !== existingContent) {
          state.set("treeMap", regenerateTreeForNewBlocks(editorState, newContent.getBlockMap(), newContent.getEntityMap(), decorator));
        }
        state.merge(put);
      });
      return new EditorState2(map3);
    };
    var _proto = EditorState2.prototype;
    _proto.toJS = function toJS2() {
      return this.getImmutable().toJS();
    };
    _proto.getAllowUndo = function getAllowUndo() {
      return this.getImmutable().get("allowUndo");
    };
    _proto.getCurrentContent = function getCurrentContent() {
      return this.getImmutable().get("currentContent");
    };
    _proto.getUndoStack = function getUndoStack() {
      return this.getImmutable().get("undoStack");
    };
    _proto.getRedoStack = function getRedoStack() {
      return this.getImmutable().get("redoStack");
    };
    _proto.getSelection = function getSelection() {
      return this.getImmutable().get("selection");
    };
    _proto.getDecorator = function getDecorator() {
      return this.getImmutable().get("decorator");
    };
    _proto.isInCompositionMode = function isInCompositionMode() {
      return this.getImmutable().get("inCompositionMode");
    };
    _proto.mustForceSelection = function mustForceSelection() {
      return this.getImmutable().get("forceSelection");
    };
    _proto.getNativelyRenderedContent = function getNativelyRenderedContent() {
      return this.getImmutable().get("nativelyRenderedContent");
    };
    _proto.getLastChangeType = function getLastChangeType() {
      return this.getImmutable().get("lastChangeType");
    };
    _proto.getInlineStyleOverride = function getInlineStyleOverride() {
      return this.getImmutable().get("inlineStyleOverride");
    };
    EditorState2.setInlineStyleOverride = function setInlineStyleOverride(editorState, inlineStyleOverride) {
      return EditorState2.set(editorState, {
        inlineStyleOverride
      });
    };
    _proto.getCurrentInlineStyle = function getCurrentInlineStyle() {
      var override = this.getInlineStyleOverride();
      if (override != null) {
        return override;
      }
      var content = this.getCurrentContent();
      var selection = this.getSelection();
      if (selection.isCollapsed()) {
        return getInlineStyleForCollapsedSelection(content, selection);
      }
      return getInlineStyleForNonCollapsedSelection(content, selection);
    };
    _proto.getBlockTree = function getBlockTree(blockKey) {
      return this.getImmutable().getIn(["treeMap", blockKey]);
    };
    _proto.isSelectionAtStartOfContent = function isSelectionAtStartOfContent() {
      var firstKey = this.getCurrentContent().getBlockMap().first().getKey();
      return this.getSelection().hasEdgeWithin(firstKey, 0, 0);
    };
    _proto.isSelectionAtEndOfContent = function isSelectionAtEndOfContent() {
      var content = this.getCurrentContent();
      var blockMap = content.getBlockMap();
      var last3 = blockMap.last();
      var end = last3.getLength();
      return this.getSelection().hasEdgeWithin(last3.getKey(), end, end);
    };
    _proto.getDirectionMap = function getDirectionMap() {
      return this.getImmutable().get("directionMap");
    };
    EditorState2.acceptSelection = function acceptSelection(editorState, selection) {
      return updateSelection(editorState, selection, false);
    };
    EditorState2.forceSelection = function forceSelection(editorState, selection) {
      if (!selection.getHasFocus()) {
        selection = selection.set("hasFocus", true);
      }
      return updateSelection(editorState, selection, true);
    };
    EditorState2.moveSelectionToEnd = function moveSelectionToEnd(editorState) {
      var content = editorState.getCurrentContent();
      var lastBlock = content.getLastBlock();
      var lastKey = lastBlock.getKey();
      var length = lastBlock.getLength();
      return EditorState2.acceptSelection(editorState, new SelectionState({
        anchorKey: lastKey,
        anchorOffset: length,
        focusKey: lastKey,
        focusOffset: length,
        isBackward: false
      }));
    };
    EditorState2.moveFocusToEnd = function moveFocusToEnd(editorState) {
      var afterSelectionMove = EditorState2.moveSelectionToEnd(editorState);
      return EditorState2.forceSelection(afterSelectionMove, afterSelectionMove.getSelection());
    };
    EditorState2.push = function push(editorState, contentState, changeType) {
      var forceSelection = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      if (editorState.getCurrentContent() === contentState) {
        return editorState;
      }
      var directionMap = EditorBidiService.getDirectionMap(contentState, editorState.getDirectionMap());
      if (!editorState.getAllowUndo()) {
        return EditorState2.set(editorState, {
          currentContent: contentState,
          directionMap,
          lastChangeType: changeType,
          selection: contentState.getSelectionAfter(),
          forceSelection,
          inlineStyleOverride: null
        });
      }
      var selection = editorState.getSelection();
      var currentContent = editorState.getCurrentContent();
      var undoStack = editorState.getUndoStack();
      var newContent = contentState;
      if (selection !== currentContent.getSelectionAfter() || mustBecomeBoundary(editorState, changeType)) {
        undoStack = undoStack.push(currentContent);
        newContent = newContent.set("selectionBefore", selection);
      } else if (changeType === "insert-characters" || changeType === "backspace-character" || changeType === "delete-character") {
        newContent = newContent.set("selectionBefore", currentContent.getSelectionBefore());
      }
      var inlineStyleOverride = editorState.getInlineStyleOverride();
      var overrideChangeTypes = ["adjust-depth", "change-block-type", "split-block"];
      if (overrideChangeTypes.indexOf(changeType) === -1) {
        inlineStyleOverride = null;
      }
      var editorStateChanges = {
        currentContent: newContent,
        directionMap,
        undoStack,
        redoStack: Stack2(),
        lastChangeType: changeType,
        selection: contentState.getSelectionAfter(),
        forceSelection,
        inlineStyleOverride
      };
      return EditorState2.set(editorState, editorStateChanges);
    };
    EditorState2.undo = function undo(editorState) {
      if (!editorState.getAllowUndo()) {
        return editorState;
      }
      var undoStack = editorState.getUndoStack();
      var newCurrentContent = undoStack.peek();
      if (!newCurrentContent) {
        return editorState;
      }
      var currentContent = editorState.getCurrentContent();
      var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());
      return EditorState2.set(editorState, {
        currentContent: newCurrentContent,
        directionMap,
        undoStack: undoStack.shift(),
        redoStack: editorState.getRedoStack().push(currentContent),
        forceSelection: true,
        inlineStyleOverride: null,
        lastChangeType: "undo",
        nativelyRenderedContent: null,
        selection: currentContent.getSelectionBefore()
      });
    };
    EditorState2.redo = function redo(editorState) {
      if (!editorState.getAllowUndo()) {
        return editorState;
      }
      var redoStack = editorState.getRedoStack();
      var newCurrentContent = redoStack.peek();
      if (!newCurrentContent) {
        return editorState;
      }
      var currentContent = editorState.getCurrentContent();
      var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());
      return EditorState2.set(editorState, {
        currentContent: newCurrentContent,
        directionMap,
        undoStack: editorState.getUndoStack().push(currentContent),
        redoStack: redoStack.shift(),
        forceSelection: true,
        inlineStyleOverride: null,
        lastChangeType: "redo",
        nativelyRenderedContent: null,
        selection: newCurrentContent.getSelectionAfter()
      });
    };
    function EditorState2(immutable2) {
      _defineProperty2(this, "_immutable", void 0);
      this._immutable = immutable2;
    }
    _proto.getImmutable = function getImmutable() {
      return this._immutable;
    };
    return EditorState2;
  })();
  function updateSelection(editorState, selection, forceSelection) {
    return EditorState.set(editorState, {
      selection,
      forceSelection,
      nativelyRenderedContent: null,
      inlineStyleOverride: null
    });
  }
  function generateNewTreeMap(contentState, decorator) {
    return contentState.getBlockMap().map(function(block) {
      return BlockTree.generate(contentState, block, decorator);
    }).toOrderedMap();
  }
  function regenerateTreeForNewBlocks(editorState, newBlockMap, newEntityMap, decorator) {
    var contentState = editorState.getCurrentContent().set("entityMap", newEntityMap);
    var prevBlockMap = contentState.getBlockMap();
    var prevTreeMap = editorState.getImmutable().get("treeMap");
    return prevTreeMap.merge(newBlockMap.toSeq().filter(function(block, key) {
      return block !== prevBlockMap.get(key);
    }).map(function(block) {
      return BlockTree.generate(contentState, block, decorator);
    }));
  }
  function regenerateTreeForNewDecorator(content, blockMap, previousTreeMap, decorator, existingDecorator) {
    return previousTreeMap.merge(blockMap.toSeq().filter(function(block) {
      return decorator.getDecorations(block, content) !== existingDecorator.getDecorations(block, content);
    }).map(function(block) {
      return BlockTree.generate(content, block, decorator);
    }));
  }
  function mustBecomeBoundary(editorState, changeType) {
    var lastChangeType = editorState.getLastChangeType();
    return changeType !== lastChangeType || changeType !== "insert-characters" && changeType !== "backspace-character" && changeType !== "delete-character";
  }
  function getInlineStyleForCollapsedSelection(content, selection) {
    var startKey = selection.getStartKey();
    var startOffset = selection.getStartOffset();
    var startBlock = content.getBlockForKey(startKey);
    if (startOffset > 0) {
      return startBlock.getInlineStyleAt(startOffset - 1);
    }
    if (startBlock.getLength()) {
      return startBlock.getInlineStyleAt(0);
    }
    return lookUpwardForInlineStyle(content, startKey);
  }
  function getInlineStyleForNonCollapsedSelection(content, selection) {
    var startKey = selection.getStartKey();
    var startOffset = selection.getStartOffset();
    var startBlock = content.getBlockForKey(startKey);
    if (startOffset < startBlock.getLength()) {
      return startBlock.getInlineStyleAt(startOffset);
    }
    if (startOffset > 0) {
      return startBlock.getInlineStyleAt(startOffset - 1);
    }
    return lookUpwardForInlineStyle(content, startKey);
  }
  function lookUpwardForInlineStyle(content, fromKey) {
    var lastNonEmpty = content.getBlockMap().reverse().skipUntil(function(_23, k2) {
      return k2 === fromKey;
    }).skip(1).skipUntil(function(block, _23) {
      return block.getLength();
    }).first();
    if (lastNonEmpty) {
      return lastNonEmpty.getInlineStyleAt(lastNonEmpty.getLength() - 1);
    }
    return OrderedSet2();
  }
  EditorState_1 = EditorState;
  return EditorState_1;
}
var moveBlockInContentState_1;
var hasRequiredMoveBlockInContentState;
function requireMoveBlockInContentState() {
  if (hasRequiredMoveBlockInContentState) return moveBlockInContentState_1;
  hasRequiredMoveBlockInContentState = 1;
  var ContentBlockNode = requireContentBlockNode();
  var getNextDelimiterBlockKey = requireGetNextDelimiterBlockKey();
  var Immutable2 = requireImmutable();
  var invariant2 = requireInvariant();
  var OrderedMap2 = Immutable2.OrderedMap, List2 = Immutable2.List;
  var transformBlock = function transformBlock2(key, blockMap, func) {
    if (!key) {
      return;
    }
    var block = blockMap.get(key);
    if (!block) {
      return;
    }
    blockMap.set(key, func(block));
  };
  var updateBlockMapLinks = function updateBlockMapLinks2(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {
    if (!isExperimentalTreeBlock) {
      return blockMap;
    }
    var isInsertedAfterTarget = insertionMode === "after";
    var originalBlockKey = originalBlockToBeMoved.getKey();
    var originalTargetKey = originalTargetBlock.getKey();
    var originalParentKey = originalBlockToBeMoved.getParentKey();
    var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();
    var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();
    var newParentKey = originalTargetBlock.getParentKey();
    var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;
    var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();
    return blockMap.withMutations(function(blocks) {
      transformBlock(originalParentKey, blocks, function(block) {
        var parentChildrenList = block.getChildKeys();
        return block.merge({
          children: parentChildrenList["delete"](parentChildrenList.indexOf(originalBlockKey))
        });
      });
      transformBlock(originalPrevSiblingKey, blocks, function(block) {
        return block.merge({
          nextSibling: originalNextSiblingKey
        });
      });
      transformBlock(originalNextSiblingKey, blocks, function(block) {
        return block.merge({
          prevSibling: originalPrevSiblingKey
        });
      });
      transformBlock(newNextSiblingKey, blocks, function(block) {
        return block.merge({
          prevSibling: originalBlockKey
        });
      });
      transformBlock(newPrevSiblingKey, blocks, function(block) {
        return block.merge({
          nextSibling: originalBlockKey
        });
      });
      transformBlock(newParentKey, blocks, function(block) {
        var newParentChildrenList = block.getChildKeys();
        var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);
        var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;
        var newChildrenArray = newParentChildrenList.toArray();
        newChildrenArray.splice(insertionIndex, 0, originalBlockKey);
        return block.merge({
          children: List2(newChildrenArray)
        });
      });
      transformBlock(originalBlockKey, blocks, function(block) {
        return block.merge({
          nextSibling: newNextSiblingKey,
          prevSibling: newPrevSiblingKey,
          parent: newParentKey
        });
      });
    });
  };
  var moveBlockInContentState = function moveBlockInContentState2(contentState, blockToBeMoved, targetBlock, insertionMode) {
    !(insertionMode !== "replace") ? invariant2(false) : void 0;
    var targetKey = targetBlock.getKey();
    var blockKey = blockToBeMoved.getKey();
    !(blockKey !== targetKey) ? invariant2(false) : void 0;
    var blockMap = contentState.getBlockMap();
    var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;
    var blocksToBeMoved = [blockToBeMoved];
    var blockMapWithoutBlocksToBeMoved = blockMap["delete"](blockKey);
    if (isExperimentalTreeBlock) {
      blocksToBeMoved = [];
      blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function(blocks) {
        var nextSiblingKey = blockToBeMoved.getNextSiblingKey();
        var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);
        blocks.toSeq().skipUntil(function(block) {
          return block.getKey() === blockKey;
        }).takeWhile(function(block) {
          var key = block.getKey();
          var isBlockToBeMoved = key === blockKey;
          var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;
          var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);
          return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);
        }).forEach(function(block) {
          blocksToBeMoved.push(block);
          blocks["delete"](block.getKey());
        });
      });
    }
    var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function(v2) {
      return v2 === targetBlock;
    });
    var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function(v2) {
      return v2 === targetBlock;
    }).skip(1);
    var slicedBlocks = blocksToBeMoved.map(function(block) {
      return [block.getKey(), block];
    });
    var newBlocks = OrderedMap2();
    if (insertionMode === "before") {
      var blockBefore = contentState.getBlockBefore(targetKey);
      !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? invariant2(false) : void 0;
      newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();
    } else if (insertionMode === "after") {
      var blockAfter = contentState.getBlockAfter(targetKey);
      !(!blockAfter || blockAfter.getKey() !== blockKey) ? invariant2(false) : void 0;
      newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();
    }
    return contentState.merge({
      blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),
      selectionBefore: contentState.getSelectionAfter(),
      selectionAfter: contentState.getSelectionAfter().merge({
        anchorKey: blockKey,
        focusKey: blockKey
      })
    });
  };
  moveBlockInContentState_1 = moveBlockInContentState;
  return moveBlockInContentState_1;
}
var AtomicBlockUtils_1;
var hasRequiredAtomicBlockUtils;
function requireAtomicBlockUtils() {
  if (hasRequiredAtomicBlockUtils) return AtomicBlockUtils_1;
  hasRequiredAtomicBlockUtils = 1;
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var BlockMapBuilder = requireBlockMapBuilder();
  var CharacterMetadata = requireCharacterMetadata();
  var ContentBlock = requireContentBlock();
  var ContentBlockNode = requireContentBlockNode();
  var DraftModifier = requireDraftModifier();
  var EditorState = requireEditorState();
  var generateRandomKey = requireGenerateRandomKey();
  var gkx2 = requireGkx();
  var Immutable2 = requireImmutable();
  var moveBlockInContentState = requireMoveBlockInContentState();
  var experimentalTreeDataSupport = gkx2("draft_tree_data_support");
  var ContentBlockRecord = experimentalTreeDataSupport ? ContentBlockNode : ContentBlock;
  var List2 = Immutable2.List, Repeat2 = Immutable2.Repeat;
  var AtomicBlockUtils = {
    insertAtomicBlock: function insertAtomicBlock(editorState, entityKey, character) {
      var contentState = editorState.getCurrentContent();
      var selectionState = editorState.getSelection();
      var afterRemoval = DraftModifier.removeRange(contentState, selectionState, "backward");
      var targetSelection = afterRemoval.getSelectionAfter();
      var afterSplit = DraftModifier.splitBlock(afterRemoval, targetSelection);
      var insertionTarget = afterSplit.getSelectionAfter();
      var asAtomicBlock = DraftModifier.setBlockType(afterSplit, insertionTarget, "atomic");
      var charData = CharacterMetadata.create({
        entity: entityKey
      });
      var atomicBlockConfig = {
        key: generateRandomKey(),
        type: "atomic",
        text: character,
        characterList: List2(Repeat2(charData, character.length))
      };
      var atomicDividerBlockConfig = {
        key: generateRandomKey(),
        type: "unstyled"
      };
      if (experimentalTreeDataSupport) {
        atomicBlockConfig = _objectSpread3({}, atomicBlockConfig, {
          nextSibling: atomicDividerBlockConfig.key
        });
        atomicDividerBlockConfig = _objectSpread3({}, atomicDividerBlockConfig, {
          prevSibling: atomicBlockConfig.key
        });
      }
      var fragmentArray = [new ContentBlockRecord(atomicBlockConfig), new ContentBlockRecord(atomicDividerBlockConfig)];
      var fragment = BlockMapBuilder.createFromArray(fragmentArray);
      var withAtomicBlock = DraftModifier.replaceWithFragment(asAtomicBlock, insertionTarget, fragment);
      var newContent = withAtomicBlock.merge({
        selectionBefore: selectionState,
        selectionAfter: withAtomicBlock.getSelectionAfter().set("hasFocus", true)
      });
      return EditorState.push(editorState, newContent, "insert-fragment");
    },
    moveAtomicBlock: function moveAtomicBlock(editorState, atomicBlock, targetRange, insertionMode) {
      var contentState = editorState.getCurrentContent();
      var selectionState = editorState.getSelection();
      var withMovedAtomicBlock;
      if (insertionMode === "before" || insertionMode === "after") {
        var targetBlock = contentState.getBlockForKey(insertionMode === "before" ? targetRange.getStartKey() : targetRange.getEndKey());
        withMovedAtomicBlock = moveBlockInContentState(contentState, atomicBlock, targetBlock, insertionMode);
      } else {
        var afterRemoval = DraftModifier.removeRange(contentState, targetRange, "backward");
        var selectionAfterRemoval = afterRemoval.getSelectionAfter();
        var _targetBlock = afterRemoval.getBlockForKey(selectionAfterRemoval.getFocusKey());
        if (selectionAfterRemoval.getStartOffset() === 0) {
          withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, "before");
        } else if (selectionAfterRemoval.getEndOffset() === _targetBlock.getLength()) {
          withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, "after");
        } else {
          var afterSplit = DraftModifier.splitBlock(afterRemoval, selectionAfterRemoval);
          var selectionAfterSplit = afterSplit.getSelectionAfter();
          var _targetBlock2 = afterSplit.getBlockForKey(selectionAfterSplit.getFocusKey());
          withMovedAtomicBlock = moveBlockInContentState(afterSplit, atomicBlock, _targetBlock2, "before");
        }
      }
      var newContent = withMovedAtomicBlock.merge({
        selectionBefore: selectionState,
        selectionAfter: withMovedAtomicBlock.getSelectionAfter().set("hasFocus", true)
      });
      return EditorState.push(editorState, newContent, "move-block");
    }
  };
  AtomicBlockUtils_1 = AtomicBlockUtils;
  return AtomicBlockUtils_1;
}
var CompositeDraftDecorator_1;
var hasRequiredCompositeDraftDecorator;
function requireCompositeDraftDecorator() {
  if (hasRequiredCompositeDraftDecorator) return CompositeDraftDecorator_1;
  hasRequiredCompositeDraftDecorator = 1;
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var Immutable2 = requireImmutable();
  var List2 = Immutable2.List;
  var DELIMITER = ".";
  var CompositeDraftDecorator = /* @__PURE__ */ (function() {
    function CompositeDraftDecorator2(decorators) {
      _defineProperty2(this, "_decorators", void 0);
      this._decorators = decorators.slice();
    }
    var _proto = CompositeDraftDecorator2.prototype;
    _proto.getDecorations = function getDecorations(block, contentState) {
      var decorations = Array(block.getText().length).fill(null);
      this._decorators.forEach(function(decorator, ii) {
        var counter = 0;
        var strategy = decorator.strategy;
        var callback = function callback2(start, end) {
          if (canOccupySlice(decorations, start, end)) {
            occupySlice(decorations, start, end, ii + DELIMITER + counter);
            counter++;
          }
        };
        strategy(block, callback, contentState);
      });
      return List2(decorations);
    };
    _proto.getComponentForKey = function getComponentForKey(key) {
      var componentKey = parseInt(key.split(DELIMITER)[0], 10);
      return this._decorators[componentKey].component;
    };
    _proto.getPropsForKey = function getPropsForKey(key) {
      var componentKey = parseInt(key.split(DELIMITER)[0], 10);
      return this._decorators[componentKey].props;
    };
    return CompositeDraftDecorator2;
  })();
  function canOccupySlice(decorations, start, end) {
    for (var ii = start; ii < end; ii++) {
      if (decorations[ii] != null) {
        return false;
      }
    }
    return true;
  }
  function occupySlice(targetArr, start, end, componentKey) {
    for (var ii = start; ii < end; ii++) {
      targetArr[ii] = componentKey;
    }
  }
  CompositeDraftDecorator_1 = CompositeDraftDecorator;
  return CompositeDraftDecorator_1;
}
var cx_1;
var hasRequiredCx;
function requireCx() {
  if (hasRequiredCx) return cx_1;
  hasRequiredCx = 1;
  function cx(classNames) {
    if (typeof classNames == "object") {
      return Object.keys(classNames).filter(function(className) {
        return classNames[className];
      }).map(replace2).join(" ");
    }
    return Array.prototype.map.call(arguments, replace2).join(" ");
  }
  function replace2(str) {
    return str.replace(/\//g, "-");
  }
  cx_1 = cx;
  return cx_1;
}
var DefaultDraftBlockRenderMap_1;
var hasRequiredDefaultDraftBlockRenderMap;
function requireDefaultDraftBlockRenderMap() {
  if (hasRequiredDefaultDraftBlockRenderMap) return DefaultDraftBlockRenderMap_1;
  hasRequiredDefaultDraftBlockRenderMap = 1;
  var React2 = requireReact();
  var cx = requireCx();
  var _require = requireImmutable(), Map2 = _require.Map;
  var UL_WRAP = React2.createElement("ul", {
    className: cx("public/DraftStyleDefault/ul")
  });
  var OL_WRAP = React2.createElement("ol", {
    className: cx("public/DraftStyleDefault/ol")
  });
  var PRE_WRAP = React2.createElement("pre", {
    className: cx("public/DraftStyleDefault/pre")
  });
  var DefaultDraftBlockRenderMap = Map2({
    "header-one": {
      element: "h1"
    },
    "header-two": {
      element: "h2"
    },
    "header-three": {
      element: "h3"
    },
    "header-four": {
      element: "h4"
    },
    "header-five": {
      element: "h5"
    },
    "header-six": {
      element: "h6"
    },
    section: {
      element: "section"
    },
    article: {
      element: "article"
    },
    "unordered-list-item": {
      element: "li",
      wrapper: UL_WRAP
    },
    "ordered-list-item": {
      element: "li",
      wrapper: OL_WRAP
    },
    blockquote: {
      element: "blockquote"
    },
    atomic: {
      element: "figure"
    },
    "code-block": {
      element: "pre",
      wrapper: PRE_WRAP
    },
    unstyled: {
      element: "div",
      aliasedElements: ["p"]
    }
  });
  DefaultDraftBlockRenderMap_1 = DefaultDraftBlockRenderMap;
  return DefaultDraftBlockRenderMap_1;
}
var DefaultDraftInlineStyle;
var hasRequiredDefaultDraftInlineStyle;
function requireDefaultDraftInlineStyle() {
  if (hasRequiredDefaultDraftInlineStyle) return DefaultDraftInlineStyle;
  hasRequiredDefaultDraftInlineStyle = 1;
  DefaultDraftInlineStyle = {
    BOLD: {
      fontWeight: "bold"
    },
    CODE: {
      fontFamily: "monospace",
      wordWrap: "break-word"
    },
    ITALIC: {
      fontStyle: "italic"
    },
    STRIKETHROUGH: {
      textDecoration: "line-through"
    },
    UNDERLINE: {
      textDecoration: "underline"
    }
  };
  return DefaultDraftInlineStyle;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign) return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject2(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i2 = 0; i2 < 10; i2++) {
        test2["_" + String.fromCharCode(i2)] = i2;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
        return test2[n2];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err2) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to2 = toObject2(target);
    var symbols;
    for (var s2 = 1; s2 < arguments.length; s2++) {
      from = Object(arguments[s2]);
      for (var key in from) {
        if (hasOwnProperty2.call(from, key)) {
          to2[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i2 = 0; i2 < symbols.length; i2++) {
          if (propIsEnumerable.call(from, symbols[i2])) {
            to2[symbols[i2]] = from[symbols[i2]];
          }
        }
      }
    }
    return to2;
  };
  return objectAssign;
}
var uaParser$1 = { exports: {} };
var uaParser = uaParser$1.exports;
var hasRequiredUaParser;
function requireUaParser() {
  if (hasRequiredUaParser) return uaParser$1.exports;
  hasRequiredUaParser = 1;
  (function(module, exports) {
    (function(window2, undefined$1) {
      var LIBVERSION = "0.7.41", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION2 = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 500;
      var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HONOR = "Honor", HUAWEI = "Huawei", LENOVO = "Lenovo", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", NVIDIA = "Nvidia", ONEPLUS = "OnePlus", OPERA = "Opera", OPPO = "OPPO", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS", SUFFIX_BROWSER = " Browser";
      var extend2 = function(regexes2, extensions) {
        var mergedRegexes = {};
        for (var i2 in regexes2) {
          if (extensions[i2] && extensions[i2].length % 2 === 0) {
            mergedRegexes[i2] = extensions[i2].concat(regexes2[i2]);
          } else {
            mergedRegexes[i2] = regexes2[i2];
          }
        }
        return mergedRegexes;
      }, enumerize = function(arr2) {
        var enums = {};
        for (var i2 = 0; i2 < arr2.length; i2++) {
          enums[arr2[i2].toUpperCase()] = arr2[i2];
        }
        return enums;
      }, has5 = function(str1, str2) {
        return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
      }, lowerize = function(str) {
        return str.toLowerCase();
      }, majorize = function(version2) {
        return typeof version2 === STR_TYPE ? version2.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined$1;
      }, trim = function(str, len) {
        if (typeof str === STR_TYPE) {
          str = str.replace(/^\s\s*/, EMPTY);
          return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
        }
      };
      var rgxMapper = function(ua, arrays) {
        var i2 = 0, j2, k2, p2, q2, matches2, match2;
        while (i2 < arrays.length && !matches2) {
          var regex = arrays[i2], props = arrays[i2 + 1];
          j2 = k2 = 0;
          while (j2 < regex.length && !matches2) {
            if (!regex[j2]) {
              break;
            }
            matches2 = regex[j2++].exec(ua);
            if (!!matches2) {
              for (p2 = 0; p2 < props.length; p2++) {
                match2 = matches2[++k2];
                q2 = props[p2];
                if (typeof q2 === OBJ_TYPE && q2.length > 0) {
                  if (q2.length === 2) {
                    if (typeof q2[1] == FUNC_TYPE) {
                      this[q2[0]] = q2[1].call(this, match2);
                    } else {
                      this[q2[0]] = q2[1];
                    }
                  } else if (q2.length === 3) {
                    if (typeof q2[1] === FUNC_TYPE && !(q2[1].exec && q2[1].test)) {
                      this[q2[0]] = match2 ? q2[1].call(this, match2, q2[2]) : undefined$1;
                    } else {
                      this[q2[0]] = match2 ? match2.replace(q2[1], q2[2]) : undefined$1;
                    }
                  } else if (q2.length === 4) {
                    this[q2[0]] = match2 ? q2[3].call(this, match2.replace(q2[1], q2[2])) : undefined$1;
                  }
                } else {
                  this[q2] = match2 ? match2 : undefined$1;
                }
              }
            }
          }
          i2 += 2;
        }
      }, strMapper = function(str, map3) {
        for (var i2 in map3) {
          if (typeof map3[i2] === OBJ_TYPE && map3[i2].length > 0) {
            for (var j2 = 0; j2 < map3[i2].length; j2++) {
              if (has5(map3[i2][j2], str)) {
                return i2 === UNKNOWN ? undefined$1 : i2;
              }
            }
          } else if (has5(map3[i2], str)) {
            return i2 === UNKNOWN ? undefined$1 : i2;
          }
        }
        return map3.hasOwnProperty("*") ? map3["*"] : str;
      };
      var oldSafariMap = {
        "1.0": "/8",
        "1.2": "/1",
        "1.3": "/3",
        "2.0": "/412",
        "2.0.2": "/416",
        "2.0.3": "/417",
        "2.0.4": "/419",
        "?": "/"
      }, windowsVersionMap = {
        "ME": "4.90",
        "NT 3.11": "NT3.51",
        "NT 4.0": "NT4.0",
        "2000": "NT 5.0",
        "XP": ["NT 5.1", "NT 5.2"],
        "Vista": "NT 6.0",
        "7": "NT 6.1",
        "8": "NT 6.2",
        "8.1": "NT 6.3",
        "10": ["NT 6.4", "NT 10.0"],
        "RT": "ARM"
      };
      var regexes = {
        browser: [
          [
            /\b(?:crmo|crios)\/([\w\.]+)/i
            // Chrome for Android/iOS
          ],
          [VERSION2, [NAME, "Chrome"]],
          [
            /edg(?:e|ios|a)?\/([\w\.]+)/i
            // Microsoft Edge
          ],
          [VERSION2, [NAME, "Edge"]],
          [
            // Presto based
            /(opera mini)\/([-\w\.]+)/i,
            // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
            // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
            // Opera
          ],
          [NAME, VERSION2],
          [
            /opios[\/ ]+([\w\.]+)/i
            // Opera mini on iphone >= 8.0
          ],
          [VERSION2, [NAME, OPERA + " Mini"]],
          [
            /\bop(?:rg)?x\/([\w\.]+)/i
            // Opera GX
          ],
          [VERSION2, [NAME, OPERA + " GX"]],
          [
            /\bopr\/([\w\.]+)/i
            // Opera Webkit
          ],
          [VERSION2, [NAME, OPERA]],
          [
            // Mixed
            /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
            // Baidu
          ],
          [VERSION2, [NAME, "Baidu"]],
          [
            /\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i
            // Maxthon
          ],
          [VERSION2, [NAME, "Maxthon"]],
          [
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,
            // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
            // Trident based
            /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,
            // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet
            /(?:ms|\()(ie) ([\w\.]+)/i,
            // Internet Explorer
            // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i,
            // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon
            /(heytap|ovi|115)browser\/([\d\.]+)/i,
            // HeyTap/Ovi/115
            /(weibo)__([\d\.]+)/i
            // Weibo
          ],
          [NAME, VERSION2],
          [
            /quark(?:pc)?\/([-\w\.]+)/i
            // Quark
          ],
          [VERSION2, [NAME, "Quark"]],
          [
            /\bddg\/([\w\.]+)/i
            // DuckDuckGo
          ],
          [VERSION2, [NAME, "DuckDuckGo"]],
          [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
            // UCBrowser
          ],
          [VERSION2, [NAME, "UC" + BROWSER]],
          [
            /microm.+\bqbcore\/([\w\.]+)/i,
            // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i,
            /micromessenger\/([\w\.]+)/i
            // WeChat
          ],
          [VERSION2, [NAME, "WeChat"]],
          [
            /konqueror\/([\w\.]+)/i
            // Konqueror
          ],
          [VERSION2, [NAME, "Konqueror"]],
          [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
            // IE11
          ],
          [VERSION2, [NAME, "IE"]],
          [
            /ya(?:search)?browser\/([\w\.]+)/i
            // Yandex
          ],
          [VERSION2, [NAME, "Yandex"]],
          [
            /slbrowser\/([\w\.]+)/i
            // Smart Lenovo Browser
          ],
          [VERSION2, [NAME, "Smart Lenovo " + BROWSER]],
          [
            /(avast|avg)\/([\w\.]+)/i
            // Avast/AVG Secure Browser
          ],
          [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION2],
          [
            /\bfocus\/([\w\.]+)/i
            // Firefox Focus
          ],
          [VERSION2, [NAME, FIREFOX + " Focus"]],
          [
            /\bopt\/([\w\.]+)/i
            // Opera Touch
          ],
          [VERSION2, [NAME, OPERA + " Touch"]],
          [
            /coc_coc\w+\/([\w\.]+)/i
            // Coc Coc Browser
          ],
          [VERSION2, [NAME, "Coc Coc"]],
          [
            /dolfin\/([\w\.]+)/i
            // Dolphin
          ],
          [VERSION2, [NAME, "Dolphin"]],
          [
            /coast\/([\w\.]+)/i
            // Opera Coast
          ],
          [VERSION2, [NAME, OPERA + " Coast"]],
          [
            /miuibrowser\/([\w\.]+)/i
            // MIUI Browser
          ],
          [VERSION2, [NAME, "MIUI" + SUFFIX_BROWSER]],
          [
            /fxios\/([\w\.-]+)/i
            // Firefox for iOS
          ],
          [VERSION2, [NAME, FIREFOX]],
          [
            /\bqihoobrowser\/?([\w\.]*)/i
            // 360
          ],
          [VERSION2, [NAME, "360"]],
          [
            /\b(qq)\/([\w\.]+)/i
            // QQ
          ],
          [[NAME, /(.+)/, "$1Browser"], VERSION2],
          [
            /(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i
          ],
          [[NAME, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION2],
          [
            // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
            /samsungbrowser\/([\w\.]+)/i
            // Samsung Internet
          ],
          [VERSION2, [NAME, SAMSUNG + " Internet"]],
          [
            /metasr[\/ ]?([\d\.]+)/i
            // Sogou Explorer
          ],
          [VERSION2, [NAME, "Sogou Explorer"]],
          [
            /(sogou)mo\w+\/([\d\.]+)/i
            // Sogou Mobile
          ],
          [[NAME, "Sogou Mobile"], VERSION2],
          [
            /(electron)\/([\w\.]+) safari/i,
            // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
            // Tesla
            /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i
            // QQ/2345
          ],
          [NAME, VERSION2],
          [
            /(lbbrowser|rekonq)/i,
            // LieBao Browser/Rekonq
            /\[(linkedin)app\]/i
            // LinkedIn App for iOS & Android
          ],
          [NAME],
          [
            /ome\/([\w\.]+) \w* ?(iron) saf/i,
            // Iron
            /ome\/([\w\.]+).+qihu (360)[es]e/i
            // 360
          ],
          [VERSION2, NAME],
          [
            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
            // Facebook App for iOS & Android
          ],
          [[NAME, FACEBOOK], VERSION2],
          [
            /(Klarna)\/([\w\.]+)/i,
            // Klarna Shopping Browser for iOS & Android
            /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
            // Kakao App
            /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
            // Naver InApp
            /(daum)apps[\/ ]([\w\.]+)/i,
            // Daum App
            /safari (line)\/([\w\.]+)/i,
            // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,
            // Line App for Android
            /(alipay)client\/([\w\.]+)/i,
            // Alipay
            /(twitter)(?:and| f.+e\/([\w\.]+))/i,
            // Twitter
            /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
            // Chromium/Instagram/Snapchat
          ],
          [NAME, VERSION2],
          [
            /\bgsa\/([\w\.]+) .*safari\//i
            // Google Search Appliance on iOS
          ],
          [VERSION2, [NAME, "GSA"]],
          [
            /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
            // TikTok
          ],
          [VERSION2, [NAME, "TikTok"]],
          [
            /headlesschrome(?:\/([\w\.]+)| )/i
            // Chrome Headless
          ],
          [VERSION2, [NAME, CHROME + " Headless"]],
          [
            / wv\).+(chrome)\/([\w\.]+)/i
            // Chrome WebView
          ],
          [[NAME, CHROME + " WebView"], VERSION2],
          [
            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
            // Android Browser
          ],
          [VERSION2, [NAME, "Android " + BROWSER]],
          [
            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
            // Chrome/OmniWeb/Arora/Tizen/Nokia
          ],
          [NAME, VERSION2],
          [
            /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
            // Mobile Safari
          ],
          [VERSION2, [NAME, "Mobile Safari"]],
          [
            /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
            // Safari & Safari Mobile
          ],
          [VERSION2, NAME],
          [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
            // Safari < 3.0
          ],
          [NAME, [VERSION2, strMapper, oldSafariMap]],
          [
            /(webkit|khtml)\/([\w\.]+)/i
          ],
          [NAME, VERSION2],
          [
            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i
            // Netscape
          ],
          [[NAME, "Netscape"], VERSION2],
          [
            /(wolvic|librewolf)\/([\w\.]+)/i
            // Wolvic/LibreWolf
          ],
          [NAME, VERSION2],
          [
            /mobile vr; rv:([\w\.]+)\).+firefox/i
            // Firefox Reality
          ],
          [VERSION2, [NAME, FIREFOX + " Reality"]],
          [
            /ekiohf.+(flow)\/([\w\.]+)/i,
            // Flow
            /(swiftfox)/i,
            // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
            // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
            // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,
            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
            // Mozilla
            // Other
            /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
            // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser/Ladybird
            /\b(links) \(([\w\.]+)/i
            // Links
          ],
          [NAME, [VERSION2, /_/g, "."]],
          [
            /(cobalt)\/([\w\.]+)/i
            // Cobalt
          ],
          [NAME, [VERSION2, /master.|lts./, ""]]
        ],
        cpu: [
          [
            /\b((amd|x|x86[-_]?|wow|win)64)\b/i
            // AMD64 (x64)
          ],
          [[ARCHITECTURE, "amd64"]],
          [
            /(ia32(?=;))/i,
            // IA32 (quicktime)
            /\b((i[346]|x)86)(pc)?\b/i
            // IA32 (x86)
          ],
          [[ARCHITECTURE, "ia32"]],
          [
            /\b(aarch64|arm(v?[89]e?l?|_?64))\b/i
            // ARM64
          ],
          [[ARCHITECTURE, "arm64"]],
          [
            /\b(arm(v[67])?ht?n?[fl]p?)\b/i
            // ARMHF
          ],
          [[ARCHITECTURE, "armhf"]],
          [
            // PocketPC mistakenly identified as PowerPC
            /( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i
          ],
          [[ARCHITECTURE, "arm"]],
          [
            /((ppc|powerpc)(64)?)( mac|;|\))/i
            // PowerPC
          ],
          [[ARCHITECTURE, /ower/, EMPTY, lowerize]],
          [
            / sun4\w[;\)]/i
            // SPARC
          ],
          [[ARCHITECTURE, "sparc"]],
          [
            /\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i
            // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
          ],
          [[ARCHITECTURE, lowerize]]
        ],
        device: [
          [
            //////////////////////////
            // MOBILES & TABLETS
            /////////////////////////
            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
          [
            /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
            /samsung[- ]((?!sm-[lr])[-\w]+)/i,
            /sec-(sgh\w+)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
          [
            // Apple
            /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
            // iPod/iPhone
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
          [
            /\((ipad);[-\w\),; ]+apple/i,
            // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
          [
            /(macintosh);/i
          ],
          [MODEL, [VENDOR, APPLE]],
          [
            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
          [
            // Honor
            /\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i
          ],
          [MODEL, [VENDOR, HONOR], [TYPE, TABLET]],
          [
            /honor([-\w ]+)[;\)]/i
          ],
          [MODEL, [VENDOR, HONOR], [TYPE, MOBILE]],
          [
            // Huawei
            /\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
          [
            /(?:huawei)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
          [
            // Xiaomi
            /oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i,
            /\b((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i
            // Mi Pad tablets
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
          [
            /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
            // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,
            // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
            // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
            // Xiaomi Redmi
            /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
            // Xiaomi Redmi 'numeric' models
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i,
            // Xiaomi Mi
            / ([\w ]+) miui\/v?\d/i
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
          [
            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
          ],
          [MODEL, [VENDOR, OPPO], [TYPE, MOBILE]],
          [
            /\b(opd2(\d{3}a?))(?: bui|\))/i
          ],
          [MODEL, [VENDOR, strMapper, { "OnePlus": ["304", "403", "203"], "*": OPPO }], [TYPE, TABLET]],
          [
            // Vivo
            /vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
          ],
          [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
          [
            // Realme
            /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
          ],
          [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
          [
            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ](\w*)/i,
            /((?:moto(?! 360)[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
          [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
          [
            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, TABLET]],
          [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+((?!browser|netcast|android tv|watch)\w+)/i,
            /\blg-?([\d\w]+) bui/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
          [
            // Lenovo
            /(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i,
            /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i
          ],
          [MODEL, [VENDOR, LENOVO], [TYPE, TABLET]],
          [
            // Nokia
            /(nokia) (t[12][01])/i
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i,
            /nokia[-_ ]?(([-\w\. ]*))/i
          ],
          [[MODEL, /_/g, " "], [TYPE, MOBILE], [VENDOR, "Nokia"]],
          [
            // Google
            /(pixel (c|tablet))\b/i
            // Google Pixel C/Tablet
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
          [
            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
            // Google Pixel
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
          [
            // Sony
            /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
          ],
          [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
          [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
          ],
          [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
          [
            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
          ],
          [MODEL, [VENDOR, ONEPLUS], [TYPE, MOBILE]],
          [
            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,
            // Kindle Fire without Silk / Echo Show
            /(kf[a-z]+)( bui|\)).+silk\//i
            // Kindle Fire HD
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
          [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
            // Fire Phone
          ],
          [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
          [
            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i
            // BlackBerry PlayBook
          ],
          [MODEL, VENDOR, [TYPE, TABLET]],
          [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i
            // BlackBerry 10
          ],
          [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
          [
            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
          [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
          [
            // HTC
            /(nexus 9)/i
            // HTC Nexus 9
          ],
          [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
          [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
            // HTC
            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
            // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
          ],
          [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
          [
            // TCL
            /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i
          ],
          [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]],
          [
            // itel
            /(itel) ((\w+))/i
          ],
          [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { "tablet": ["p10001l", "w7001"], "*": "mobile" }]],
          [
            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
          ],
          [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
          [
            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
          ],
          [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
          [
            // Ulefone
            /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
          [
            // Energizer
            /; (energy ?\w+)(?: bui|\))/i,
            /; energizer ([\w ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Energizer"], [TYPE, MOBILE]],
          [
            // Cat
            /; cat (b35);/i,
            /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Cat"], [TYPE, MOBILE]],
          [
            // Smartfren
            /((?:new )?andromax[\w- ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Smartfren"], [TYPE, MOBILE]],
          [
            // Nothing
            /droid.+; (a(?:015|06[35]|142p?))/i
          ],
          [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]],
          [
            // Archos
            /; (x67 5g|tikeasy \w+|ac[1789]\d\w+)( b|\))/i,
            /archos ?(5|gamepad2?|([\w ]*[t1789]|hello) ?\d+[\w ]*)( b|\))/i
          ],
          [MODEL, [VENDOR, "Archos"], [TYPE, TABLET]],
          [
            /archos ([\w ]+)( b|\))/i,
            /; (ac[3-6]\d\w{2,8})( b|\))/i
          ],
          [MODEL, [VENDOR, "Archos"], [TYPE, MOBILE]],
          [
            // MIXED
            /(imo) (tab \w+)/i,
            // IMO
            /(infinix) (x1101b?)/i
            // Infinix XPad
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
            // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Infinix/Tecno/Micromax/Advan
            /; (hmd|imo) ([\w ]+?)(?: bui|\))/i,
            // HMD/IMO
            /(hp) ([\w ]+\w)/i,
            // HP iPAQ
            /(microsoft); (lumia[\w ]+)/i,
            // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i,
            // Lenovo
            /(oppo) ?([\w ]+) bui/i
            // OPPO
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kobo)\s(ereader|touch)/i,
            // Kobo
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,
            // HP TouchPad
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(nook)[\w ]+build\/(\w+)/i,
            // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,
            // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
            // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,
            // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,
            // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i
            // Vodafone
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(surface duo)/i
            // Surface Duo
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
          [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i
            // Fairphone
          ],
          [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
          [
            /(u304aa)/i
            // AT&T
          ],
          [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
          [
            /\bsie-(\w*)/i
            // Siemens
          ],
          [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
          [
            /\b(rct\w+) b/i
            // RCA Tablets
          ],
          [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
          [
            /\b(venue[\d ]{2,7}) b/i
            // Dell Venue Tablets
          ],
          [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
          [
            /\b(q(?:mv|ta)\w+) b/i
            // Verizon Tablet
          ],
          [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
          [
            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
            // Barnes & Noble Tablet
          ],
          [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
          [
            /\b(tm\d{3}\w+) b/i
          ],
          [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
          [
            /\b(k88) b/i
            // ZTE K Series Tablet
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
          [
            /\b(nx\d{3}j) b/i
            // ZTE Nubia
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
          [
            /\b(gen\d{3}) b.+49h/i
            // Swiss GEN Mobile
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
          [
            /\b(zur\d{3}) b/i
            // Swiss ZUR Tablet
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
          [
            /\b((zeki)?tb.*\b) b/i
            // Zeki Tablets
          ],
          [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
          [
            /\b([yr]\d{2}) b/i,
            /\b(dragon[- ]+touch |dt)(\w{5}) b/i
            // Dragon Touch Tablet
          ],
          [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
          [
            /\b(ns-?\w{0,9}) b/i
            // Insignia Tablets
          ],
          [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
          [
            /\b((nxa|next)-?\w{0,9}) b/i
            // NextBook Tablets
          ],
          [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
          [
            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
            // Voice Xtreme Phones
          ],
          [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
          [
            /\b(lvtel\-)?(v1[12]) b/i
            // LvTel Phones
          ],
          [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
          [
            /\b(ph-1) /i
            // Essential PH-1
          ],
          [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
          [
            /\b(v(100md|700na|7011|917g).*\b) b/i
            // Envizen Tablets
          ],
          [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
          [
            /\b(trio[-\w\. ]+) b/i
            // MachSpeed Tablets
          ],
          [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
          [
            /\btu_(1491) b/i
            // Rotor Tablets
          ],
          [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
          [
            /((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i
            // Nvidia Tablets
          ],
          [MODEL, [VENDOR, NVIDIA], [TYPE, TABLET]],
          [
            /(sprint) (\w+)/i
            // Sprint Phones
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kin\.[onetw]{3})/i
            // Microsoft Kin
          ],
          [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
          [
            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
            // Zebra
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
          [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
          [
            ///////////////////
            // SMARTTVS
            ///////////////////
            /smart-tv.+(samsung)/i
            // Samsung
          ],
          [VENDOR, [TYPE, SMARTTV]],
          [
            /hbbtv.+maple;(\d+)/i
          ],
          [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
          [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
            // LG SmartTV
          ],
          [[VENDOR, LG], [TYPE, SMARTTV]],
          [
            /(apple) ?tv/i
            // Apple TV
          ],
          [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
          [
            /crkey/i
            // Google Chromecast
          ],
          [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
          [
            /droid.+aft(\w+)( bui|\))/i
            // Fire TV
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
          [
            /(shield \w+ tv)/i
            // Nvidia Shield TV
          ],
          [MODEL, [VENDOR, NVIDIA], [TYPE, SMARTTV]],
          [
            /\(dtv[\);].+(aquos)/i,
            /(aquos-tv[\w ]+)\)/i
            // Sharp
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
          [
            /(bravia[\w ]+)( bui|\))/i
            // Sony
          ],
          [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
          [
            /(mi(tv|box)-?\w+) bui/i
            // Xiaomi
          ],
          [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
          [
            /Hbbtv.*(technisat) (.*);/i
            // TechniSAT
          ],
          [VENDOR, MODEL, [TYPE, SMARTTV]],
          [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
            // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
            // HbbTV devices
          ],
          [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]],
          [
            // SmartTV from Unidentified Vendors
            /droid.+; ([\w- ]+) (?:android tv|smart[- ]?tv)/i
          ],
          [MODEL, [TYPE, SMARTTV]],
          [
            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
          ],
          [[TYPE, SMARTTV]],
          [
            ///////////////////
            // CONSOLES
            ///////////////////
            /(ouya)/i,
            // Ouya
            /(nintendo) ([wids3utch]+)/i
            // Nintendo
          ],
          [VENDOR, MODEL, [TYPE, CONSOLE]],
          [
            /droid.+; (shield)( bui|\))/i
            // Nvidia Portable
          ],
          [MODEL, [VENDOR, NVIDIA], [TYPE, CONSOLE]],
          [
            /(playstation \w+)/i
            // Playstation
          ],
          [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
          [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i
            // Microsoft Xbox
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
          [
            ///////////////////
            // WEARABLES
            ///////////////////
            /\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i
            // Samsung Galaxy Watch
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]],
          [
            /((pebble))app/i,
            // Pebble
            /(asus|google|lg|oppo) ((pixel |zen)?watch[\w ]*)( bui|\))/i
            // Asus ZenWatch / LG Watch / Pixel Watch
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /(ow(?:19|20)?we?[1-3]{1,3})/i
            // Oppo Watch
          ],
          [MODEL, [VENDOR, OPPO], [TYPE, WEARABLE]],
          [
            /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
            // Apple Watch
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
          [
            /(opwwe\d{3})/i
            // OnePlus Watch
          ],
          [MODEL, [VENDOR, ONEPLUS], [TYPE, WEARABLE]],
          [
            /(moto 360)/i
            // Motorola 360
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, WEARABLE]],
          [
            /(smartwatch 3)/i
            // Sony SmartWatch
          ],
          [MODEL, [VENDOR, SONY], [TYPE, WEARABLE]],
          [
            /(g watch r)/i
            // LG G Watch R
          ],
          [MODEL, [VENDOR, LG], [TYPE, WEARABLE]],
          [
            /droid.+; (wt63?0{2,3})\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
          [
            ///////////////////
            // XR
            ///////////////////
            /droid.+; (glass) \d/i
            // Google Glass
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
          [
            /(pico) (4|neo3(?: link|pro)?)/i
            // Pico
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /; (quest( \d| pro)?)/i
            // Oculus Quest
          ],
          [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
          [
            ///////////////////
            // EMBEDDED
            ///////////////////
            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
            // Tesla
          ],
          [VENDOR, [TYPE, EMBEDDED]],
          [
            /(aeobc)\b/i
            // Echo Dot
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
          [
            /(homepod).+mac os/i
            // Apple HomePod
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, EMBEDDED]],
          [
            /windows iot/i
          ],
          [[TYPE, EMBEDDED]],
          [
            ////////////////////
            // MIXED (GENERIC)
            ///////////////////
            /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
            // Android Phones from Unidentified Vendors
          ],
          [MODEL, [TYPE, MOBILE]],
          [
            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
            // Android Tablets from Unidentified Vendors
          ],
          [MODEL, [TYPE, TABLET]],
          [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
            // Unidentifiable Tablet
          ],
          [[TYPE, TABLET]],
          [
            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
            // Unidentifiable Mobile
          ],
          [[TYPE, MOBILE]],
          [
            /droid .+?; ([\w\. -]+)( bui|\))/i
            // Generic Android Device
          ],
          [MODEL, [VENDOR, "Generic"]]
        ],
        engine: [
          [
            /windows.+ edge\/([\w\.]+)/i
            // EdgeHTML
          ],
          [VERSION2, [NAME, EDGE + "HTML"]],
          [
            /(arkweb)\/([\w\.]+)/i
            // ArkWeb
          ],
          [NAME, VERSION2],
          [
            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
            // Blink
          ],
          [VERSION2, [NAME, "Blink"]],
          [
            /(presto)\/([\w\.]+)/i,
            // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,
            // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo
            /ekioh(flow)\/([\w\.]+)/i,
            // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
            // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i,
            // iCab
            /\b(libweb)/i
            // LibWeb
          ],
          [NAME, VERSION2],
          [
            /ladybird\//i
          ],
          [[NAME, "LibWeb"]],
          [
            /rv\:([\w\.]{1,9})\b.+(gecko)/i
            // Gecko
          ],
          [VERSION2, NAME]
        ],
        os: [
          [
            // Windows
            /microsoft (windows) (vista|xp)/i
            // Windows (iTunes)
          ],
          [NAME, VERSION2],
          [
            /(windows (?:phone(?: os)?|mobile|iot))[\/ ]?([\d\.\w ]*)/i
            // Windows Phone
          ],
          [NAME, [VERSION2, strMapper, windowsVersionMap]],
          [
            /windows nt 6\.2; (arm)/i,
            // Windows RT
            /windows[\/ ]([ntce\d\. ]+\w)(?!.+xbox)/i,
            /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
          ],
          [[VERSION2, strMapper, windowsVersionMap], [NAME, "Windows"]],
          [
            // iOS/macOS
            /[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i,
            // iOS
            /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
            /cfnetwork\/.+darwin/i
          ],
          [[VERSION2, /_/g, "."], [NAME, "iOS"]],
          [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+haiku)/i
            // Mac OS
          ],
          [[NAME, MAC_OS], [VERSION2, /_/g, "."]],
          [
            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
            // Android-x86/HarmonyOS
          ],
          [VERSION2, NAME],
          [
            /(ubuntu) ([\w\.]+) like android/i
            // Ubuntu Touch
          ],
          [[NAME, /(.+)/, "$1 Touch"], VERSION2],
          [
            // Android/Blackberry/WebOS/QNX/Bada/RIM/KaiOS/Maemo/MeeGo/S40/Sailfish OS/OpenHarmony/Tizen
            /(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen|webos)\w*[-\/; ]?([\d\.]*)/i
          ],
          [NAME, VERSION2],
          [
            /\(bb(10);/i
            // BlackBerry 10
          ],
          [VERSION2, [NAME, BLACKBERRY]],
          [
            /(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i
            // Symbian
          ],
          [VERSION2, [NAME, "Symbian"]],
          [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
            // Firefox OS
          ],
          [VERSION2, [NAME, FIREFOX + " OS"]],
          [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
            // WebOS
          ],
          [VERSION2, [NAME, "webOS"]],
          [
            /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
            // watchOS
          ],
          [VERSION2, [NAME, "watchOS"]],
          [
            // Google Chromecast
            /crkey\/([\d\.]+)/i
            // Google Chromecast
          ],
          [VERSION2, [NAME, CHROME + "cast"]],
          [
            /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
            // Chromium OS
          ],
          [[NAME, CHROMIUM_OS], VERSION2],
          [
            // Smart TVs
            /panasonic;(viera)/i,
            // Panasonic Viera
            /(netrange)mmh/i,
            // Netrange
            /(nettv)\/(\d+\.[\w\.]+)/i,
            // NetTV
            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,
            // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,
            // Microsoft Xbox (360, One, X, S, Series X, Series S)
            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,
            // Mint
            /(mageia|vectorlinux)[; ]/i,
            // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
            // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux)(?: arm\w*| x86\w*| ?)([\w\.]*)/i,
            // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,
            // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
            // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i
            // Haiku
          ],
          [NAME, VERSION2],
          [
            /(sunos) ?([\w\.\d]*)/i
            // Solaris
          ],
          [[NAME, "Solaris"], VERSION2],
          [
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
            // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
            // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
            /(unix) ?([\w\.]*)/i
            // UNIX
          ],
          [NAME, VERSION2]
        ]
      };
      var UAParser = function(ua, extensions) {
        if (typeof ua === OBJ_TYPE) {
          extensions = ua;
          ua = undefined$1;
        }
        if (!(this instanceof UAParser)) {
          return new UAParser(ua, extensions).getResult();
        }
        var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined$1;
        var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
        var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined$1;
        var _rgxmap = extensions ? extend2(regexes, extensions) : regexes;
        var _isSelfNav = _navigator && _navigator.userAgent == _ua;
        this.getBrowser = function() {
          var _browser = {};
          _browser[NAME] = undefined$1;
          _browser[VERSION2] = undefined$1;
          rgxMapper.call(_browser, _ua, _rgxmap.browser);
          _browser[MAJOR] = majorize(_browser[VERSION2]);
          if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
            _browser[NAME] = "Brave";
          }
          return _browser;
        };
        this.getCPU = function() {
          var _cpu = {};
          _cpu[ARCHITECTURE] = undefined$1;
          rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
          return _cpu;
        };
        this.getDevice = function() {
          var _device = {};
          _device[VENDOR] = undefined$1;
          _device[MODEL] = undefined$1;
          _device[TYPE] = undefined$1;
          rgxMapper.call(_device, _ua, _rgxmap.device);
          if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
            _device[TYPE] = MOBILE;
          }
          if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
            _device[MODEL] = "iPad";
            _device[TYPE] = TABLET;
          }
          return _device;
        };
        this.getEngine = function() {
          var _engine = {};
          _engine[NAME] = undefined$1;
          _engine[VERSION2] = undefined$1;
          rgxMapper.call(_engine, _ua, _rgxmap.engine);
          return _engine;
        };
        this.getOS = function() {
          var _os = {};
          _os[NAME] = undefined$1;
          _os[VERSION2] = undefined$1;
          rgxMapper.call(_os, _ua, _rgxmap.os);
          if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != "Unknown") {
            _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
          }
          return _os;
        };
        this.getResult = function() {
          return {
            ua: this.getUA(),
            browser: this.getBrowser(),
            engine: this.getEngine(),
            os: this.getOS(),
            device: this.getDevice(),
            cpu: this.getCPU()
          };
        };
        this.getUA = function() {
          return _ua;
        };
        this.setUA = function(ua2) {
          _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;
          return this;
        };
        this.setUA(_ua);
        return this;
      };
      UAParser.VERSION = LIBVERSION;
      UAParser.BROWSER = enumerize([NAME, VERSION2, MAJOR]);
      UAParser.CPU = enumerize([ARCHITECTURE]);
      UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
      UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION2]);
      {
        if (module.exports) {
          exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
      }
      var $2 = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
      if ($2 && !$2.ua) {
        var parser = new UAParser();
        $2.ua = parser.getResult();
        $2.ua.get = function() {
          return parser.getUA();
        };
        $2.ua.set = function(ua) {
          parser.setUA(ua);
          var result = parser.getResult();
          for (var prop in result) {
            $2.ua[prop] = result[prop];
          }
        };
      }
    })(typeof window === "object" ? window : uaParser);
  })(uaParser$1, uaParser$1.exports);
  return uaParser$1.exports;
}
var UserAgentData;
var hasRequiredUserAgentData;
function requireUserAgentData() {
  if (hasRequiredUserAgentData) return UserAgentData;
  hasRequiredUserAgentData = 1;
  var UAParser = requireUaParser();
  var UNKNOWN = "Unknown";
  var PLATFORM_MAP = {
    "Mac OS": "Mac OS X"
  };
  function convertPlatformName(name) {
    return PLATFORM_MAP[name] || name;
  }
  function getBrowserVersion(version2) {
    if (!version2) {
      return {
        major: "",
        minor: ""
      };
    }
    var parts = version2.split(".");
    return {
      major: parts[0],
      minor: parts[1]
    };
  }
  var parser = new UAParser();
  var results = parser.getResult();
  var browserVersionData = getBrowserVersion(results.browser.version);
  var uaData = {
    browserArchitecture: results.cpu.architecture || UNKNOWN,
    browserFullVersion: results.browser.version || UNKNOWN,
    browserMinorVersion: browserVersionData.minor || UNKNOWN,
    browserName: results.browser.name || UNKNOWN,
    browserVersion: results.browser.major || UNKNOWN,
    deviceName: results.device.model || UNKNOWN,
    engineName: results.engine.name || UNKNOWN,
    engineVersion: results.engine.version || UNKNOWN,
    platformArchitecture: results.cpu.architecture || UNKNOWN,
    platformName: convertPlatformName(results.os.name) || UNKNOWN,
    platformVersion: results.os.version || UNKNOWN,
    platformFullVersion: results.os.version || UNKNOWN
  };
  UserAgentData = uaData;
  return UserAgentData;
}
var VersionRange_1;
var hasRequiredVersionRange;
function requireVersionRange() {
  if (hasRequiredVersionRange) return VersionRange_1;
  hasRequiredVersionRange = 1;
  var invariant2 = requireInvariant();
  var componentRegex = /\./;
  var orRegex = /\|\|/;
  var rangeRegex = /\s+\-\s+/;
  var modifierRegex = /^(<=|<|=|>=|~>|~|>|)?\s*(.+)/;
  var numericRegex = /^(\d*)(.*)/;
  function checkOrExpression(range, version2) {
    var expressions = range.split(orRegex);
    if (expressions.length > 1) {
      return expressions.some(function(range2) {
        return VersionRange.contains(range2, version2);
      });
    } else {
      range = expressions[0].trim();
      return checkRangeExpression(range, version2);
    }
  }
  function checkRangeExpression(range, version2) {
    var expressions = range.split(rangeRegex);
    !(expressions.length > 0 && expressions.length <= 2) ? invariant2(false) : void 0;
    if (expressions.length === 1) {
      return checkSimpleExpression(expressions[0], version2);
    } else {
      var startVersion = expressions[0], endVersion = expressions[1];
      !(isSimpleVersion(startVersion) && isSimpleVersion(endVersion)) ? invariant2(false) : void 0;
      return checkSimpleExpression(">=" + startVersion, version2) && checkSimpleExpression("<=" + endVersion, version2);
    }
  }
  function checkSimpleExpression(range, version2) {
    range = range.trim();
    if (range === "") {
      return true;
    }
    var versionComponents = version2.split(componentRegex);
    var _getModifierAndCompon = getModifierAndComponents(range), modifier = _getModifierAndCompon.modifier, rangeComponents = _getModifierAndCompon.rangeComponents;
    switch (modifier) {
      case "<":
        return checkLessThan(versionComponents, rangeComponents);
      case "<=":
        return checkLessThanOrEqual(versionComponents, rangeComponents);
      case ">=":
        return checkGreaterThanOrEqual(versionComponents, rangeComponents);
      case ">":
        return checkGreaterThan(versionComponents, rangeComponents);
      case "~":
      case "~>":
        return checkApproximateVersion(versionComponents, rangeComponents);
      default:
        return checkEqual(versionComponents, rangeComponents);
    }
  }
  function checkLessThan(a2, b2) {
    return compareComponents(a2, b2) === -1;
  }
  function checkLessThanOrEqual(a2, b2) {
    var result = compareComponents(a2, b2);
    return result === -1 || result === 0;
  }
  function checkEqual(a2, b2) {
    return compareComponents(a2, b2) === 0;
  }
  function checkGreaterThanOrEqual(a2, b2) {
    var result = compareComponents(a2, b2);
    return result === 1 || result === 0;
  }
  function checkGreaterThan(a2, b2) {
    return compareComponents(a2, b2) === 1;
  }
  function checkApproximateVersion(a2, b2) {
    var lowerBound = b2.slice();
    var upperBound = b2.slice();
    if (upperBound.length > 1) {
      upperBound.pop();
    }
    var lastIndex = upperBound.length - 1;
    var numeric = parseInt(upperBound[lastIndex], 10);
    if (isNumber2(numeric)) {
      upperBound[lastIndex] = numeric + 1 + "";
    }
    return checkGreaterThanOrEqual(a2, lowerBound) && checkLessThan(a2, upperBound);
  }
  function getModifierAndComponents(range) {
    var rangeComponents = range.split(componentRegex);
    var matches2 = rangeComponents[0].match(modifierRegex);
    !matches2 ? invariant2(false) : void 0;
    return {
      modifier: matches2[1],
      rangeComponents: [matches2[2]].concat(rangeComponents.slice(1))
    };
  }
  function isNumber2(number2) {
    return !isNaN(number2) && isFinite(number2);
  }
  function isSimpleVersion(range) {
    return !getModifierAndComponents(range).modifier;
  }
  function zeroPad(array2, length) {
    for (var i2 = array2.length; i2 < length; i2++) {
      array2[i2] = "0";
    }
  }
  function normalizeVersions(a2, b2) {
    a2 = a2.slice();
    b2 = b2.slice();
    zeroPad(a2, b2.length);
    for (var i2 = 0; i2 < b2.length; i2++) {
      var matches2 = b2[i2].match(/^[x*]$/i);
      if (matches2) {
        b2[i2] = a2[i2] = "0";
        if (matches2[0] === "*" && i2 === b2.length - 1) {
          for (var j2 = i2; j2 < a2.length; j2++) {
            a2[j2] = "0";
          }
        }
      }
    }
    zeroPad(b2, a2.length);
    return [a2, b2];
  }
  function compareNumeric(a2, b2) {
    var aPrefix = a2.match(numericRegex)[1];
    var bPrefix = b2.match(numericRegex)[1];
    var aNumeric = parseInt(aPrefix, 10);
    var bNumeric = parseInt(bPrefix, 10);
    if (isNumber2(aNumeric) && isNumber2(bNumeric) && aNumeric !== bNumeric) {
      return compare(aNumeric, bNumeric);
    } else {
      return compare(a2, b2);
    }
  }
  function compare(a2, b2) {
    !(typeof a2 === typeof b2) ? invariant2(false) : void 0;
    if (a2 > b2) {
      return 1;
    } else if (a2 < b2) {
      return -1;
    } else {
      return 0;
    }
  }
  function compareComponents(a2, b2) {
    var _normalizeVersions = normalizeVersions(a2, b2), aNormalized = _normalizeVersions[0], bNormalized = _normalizeVersions[1];
    for (var i2 = 0; i2 < bNormalized.length; i2++) {
      var result = compareNumeric(aNormalized[i2], bNormalized[i2]);
      if (result) {
        return result;
      }
    }
    return 0;
  }
  var VersionRange = {
    /**
     * Checks whether `version` satisfies the `range` specification.
     *
     * We support a subset of the expressions defined in
     * https://www.npmjs.org/doc/misc/semver.html:
     *
     *    version   Must match version exactly
     *    =version  Same as just version
     *    >version  Must be greater than version
     *    >=version Must be greater than or equal to version
     *    <version  Must be less than version
     *    <=version Must be less than or equal to version
     *    ~version  Must be at least version, but less than the next significant
     *              revision above version:
     *              "~1.2.3" is equivalent to ">= 1.2.3 and < 1.3"
     *    ~>version Equivalent to ~version
     *    1.2.x     Must match "1.2.x", where "x" is a wildcard that matches
     *              anything
     *    1.2.*     Similar to "1.2.x", but "*" in the trailing position is a
     *              "greedy" wildcard, so will match any number of additional
     *              components:
     *              "1.2.*" will match "1.2.1", "1.2.1.1", "1.2.1.1.1" etc
     *    *         Any version
     *    ""        (Empty string) Same as *
     *    v1 - v2   Equivalent to ">= v1 and <= v2"
     *    r1 || r2  Passes if either r1 or r2 are satisfied
     *
     * @param {string} range
     * @param {string} version
     * @returns {boolean}
     */
    contains: function contains(range, version2) {
      return checkOrExpression(range.trim(), version2.trim());
    }
  };
  VersionRange_1 = VersionRange;
  return VersionRange_1;
}
var mapObject_1;
var hasRequiredMapObject;
function requireMapObject() {
  if (hasRequiredMapObject) return mapObject_1;
  hasRequiredMapObject = 1;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  function mapObject(object2, callback, context2) {
    if (!object2) {
      return null;
    }
    var result = {};
    for (var name in object2) {
      if (hasOwnProperty2.call(object2, name)) {
        result[name] = callback.call(context2, object2[name], name, object2);
      }
    }
    return result;
  }
  mapObject_1 = mapObject;
  return mapObject_1;
}
var memoizeStringOnly_1;
var hasRequiredMemoizeStringOnly;
function requireMemoizeStringOnly() {
  if (hasRequiredMemoizeStringOnly) return memoizeStringOnly_1;
  hasRequiredMemoizeStringOnly = 1;
  function memoizeStringOnly(callback) {
    var cache2 = {};
    return function(string2) {
      if (!cache2.hasOwnProperty(string2)) {
        cache2[string2] = callback.call(this, string2);
      }
      return cache2[string2];
    };
  }
  memoizeStringOnly_1 = memoizeStringOnly;
  return memoizeStringOnly_1;
}
var UserAgent_1;
var hasRequiredUserAgent;
function requireUserAgent() {
  if (hasRequiredUserAgent) return UserAgent_1;
  hasRequiredUserAgent = 1;
  var UserAgentData2 = requireUserAgentData();
  var VersionRange = requireVersionRange();
  var mapObject = requireMapObject();
  var memoizeStringOnly = requireMemoizeStringOnly();
  function compare(name, version2, query, normalizer) {
    if (name === query) {
      return true;
    }
    if (!query.startsWith(name)) {
      return false;
    }
    var range = query.slice(name.length);
    if (version2) {
      range = normalizer ? normalizer(range) : range;
      return VersionRange.contains(range, version2);
    }
    return false;
  }
  function normalizePlatformVersion(version2) {
    if (UserAgentData2.platformName === "Windows") {
      return version2.replace(/^\s*NT/, "");
    }
    return version2;
  }
  var UserAgent = {
    /**
     * Check if the User Agent browser matches `query`.
     *
     * `query` should be a string like "Chrome" or "Chrome > 33".
     *
     * Valid browser names include:
     *
     * - ACCESS NetFront
     * - AOL
     * - Amazon Silk
     * - Android
     * - BlackBerry
     * - BlackBerry PlayBook
     * - Chrome
     * - Chrome for iOS
     * - Chrome frame
     * - Facebook PHP SDK
     * - Facebook for iOS
     * - Firefox
     * - IE
     * - IE Mobile
     * - Mobile Safari
     * - Motorola Internet Browser
     * - Nokia
     * - Openwave Mobile Browser
     * - Opera
     * - Opera Mini
     * - Opera Mobile
     * - Safari
     * - UIWebView
     * - Unknown
     * - webOS
     * - etc...
     *
     * An authoritative list can be found in the PHP `BrowserDetector` class and
     * related classes in the same file (see calls to `new UserAgentBrowser` here:
     * https://fburl.com/50728104).
     *
     * @note Function results are memoized
     *
     * @param {string} query Query of the form "Name [range expression]"
     * @return {boolean}
     */
    isBrowser: function isBrowser(query) {
      return compare(UserAgentData2.browserName, UserAgentData2.browserFullVersion, query);
    },
    /**
     * Check if the User Agent browser uses a 32 or 64 bit architecture.
     *
     * @note Function results are memoized
     *
     * @param {string} query Query of the form "32" or "64".
     * @return {boolean}
     */
    isBrowserArchitecture: function isBrowserArchitecture(query) {
      return compare(UserAgentData2.browserArchitecture, null, query);
    },
    /**
     * Check if the User Agent device matches `query`.
     *
     * `query` should be a string like "iPhone" or "iPad".
     *
     * Valid device names include:
     *
     * - Kindle
     * - Kindle Fire
     * - Unknown
     * - iPad
     * - iPhone
     * - iPod
     * - etc...
     *
     * An authoritative list can be found in the PHP `DeviceDetector` class and
     * related classes in the same file (see calls to `new UserAgentDevice` here:
     * https://fburl.com/50728332).
     *
     * @note Function results are memoized
     *
     * @param {string} query Query of the form "Name"
     * @return {boolean}
     */
    isDevice: function isDevice(query) {
      return compare(UserAgentData2.deviceName, null, query);
    },
    /**
     * Check if the User Agent rendering engine matches `query`.
     *
     * `query` should be a string like "WebKit" or "WebKit >= 537".
     *
     * Valid engine names include:
     *
     * - Gecko
     * - Presto
     * - Trident
     * - WebKit
     * - etc...
     *
     * An authoritative list can be found in the PHP `RenderingEngineDetector`
     * class related classes in the same file (see calls to `new
     * UserAgentRenderingEngine` here: https://fburl.com/50728617).
     *
     * @note Function results are memoized
     *
     * @param {string} query Query of the form "Name [range expression]"
     * @return {boolean}
     */
    isEngine: function isEngine(query) {
      return compare(UserAgentData2.engineName, UserAgentData2.engineVersion, query);
    },
    /**
     * Check if the User Agent platform matches `query`.
     *
     * `query` should be a string like "Windows" or "iOS 5 - 6".
     *
     * Valid platform names include:
     *
     * - Android
     * - BlackBerry OS
     * - Java ME
     * - Linux
     * - Mac OS X
     * - Mac OS X Calendar
     * - Mac OS X Internet Account
     * - Symbian
     * - SymbianOS
     * - Windows
     * - Windows Mobile
     * - Windows Phone
     * - iOS
     * - iOS Facebook Integration Account
     * - iOS Facebook Social Sharing UI
     * - webOS
     * - Chrome OS
     * - etc...
     *
     * An authoritative list can be found in the PHP `PlatformDetector` class and
     * related classes in the same file (see calls to `new UserAgentPlatform`
     * here: https://fburl.com/50729226).
     *
     * @note Function results are memoized
     *
     * @param {string} query Query of the form "Name [range expression]"
     * @return {boolean}
     */
    isPlatform: function isPlatform(query) {
      return compare(UserAgentData2.platformName, UserAgentData2.platformFullVersion, query, normalizePlatformVersion);
    },
    /**
     * Check if the User Agent platform is a 32 or 64 bit architecture.
     *
     * @note Function results are memoized
     *
     * @param {string} query Query of the form "32" or "64".
     * @return {boolean}
     */
    isPlatformArchitecture: function isPlatformArchitecture(query) {
      return compare(UserAgentData2.platformArchitecture, null, query);
    }
  };
  UserAgent_1 = mapObject(UserAgent, memoizeStringOnly);
  return UserAgent_1;
}
var getCorrectDocumentFromNode_1;
var hasRequiredGetCorrectDocumentFromNode;
function requireGetCorrectDocumentFromNode() {
  if (hasRequiredGetCorrectDocumentFromNode) return getCorrectDocumentFromNode_1;
  hasRequiredGetCorrectDocumentFromNode = 1;
  function getCorrectDocumentFromNode(node) {
    if (!node || !node.ownerDocument) {
      return document;
    }
    return node.ownerDocument;
  }
  getCorrectDocumentFromNode_1 = getCorrectDocumentFromNode;
  return getCorrectDocumentFromNode_1;
}
var isElement_1;
var hasRequiredIsElement;
function requireIsElement() {
  if (hasRequiredIsElement) return isElement_1;
  hasRequiredIsElement = 1;
  function isElement(node) {
    if (!node || !node.ownerDocument) {
      return false;
    }
    return node.nodeType === Node.ELEMENT_NODE;
  }
  isElement_1 = isElement;
  return isElement_1;
}
var getSelectionOffsetKeyForNode_1;
var hasRequiredGetSelectionOffsetKeyForNode;
function requireGetSelectionOffsetKeyForNode() {
  if (hasRequiredGetSelectionOffsetKeyForNode) return getSelectionOffsetKeyForNode_1;
  hasRequiredGetSelectionOffsetKeyForNode = 1;
  var isElement = requireIsElement();
  function getSelectionOffsetKeyForNode(node) {
    if (isElement(node)) {
      var castedNode = node;
      var offsetKey = castedNode.getAttribute("data-offset-key");
      if (offsetKey) {
        return offsetKey;
      }
      for (var ii = 0; ii < castedNode.childNodes.length; ii++) {
        var childOffsetKey = getSelectionOffsetKeyForNode(castedNode.childNodes[ii]);
        if (childOffsetKey) {
          return childOffsetKey;
        }
      }
    }
    return null;
  }
  getSelectionOffsetKeyForNode_1 = getSelectionOffsetKeyForNode;
  return getSelectionOffsetKeyForNode_1;
}
var findAncestorOffsetKey_1;
var hasRequiredFindAncestorOffsetKey;
function requireFindAncestorOffsetKey() {
  if (hasRequiredFindAncestorOffsetKey) return findAncestorOffsetKey_1;
  hasRequiredFindAncestorOffsetKey = 1;
  var getCorrectDocumentFromNode = requireGetCorrectDocumentFromNode();
  var getSelectionOffsetKeyForNode = requireGetSelectionOffsetKeyForNode();
  function findAncestorOffsetKey(node) {
    var searchNode = node;
    while (searchNode && searchNode !== getCorrectDocumentFromNode(node).documentElement) {
      var key = getSelectionOffsetKeyForNode(searchNode);
      if (key != null) {
        return key;
      }
      searchNode = searchNode.parentNode;
    }
    return null;
  }
  findAncestorOffsetKey_1 = findAncestorOffsetKey;
  return findAncestorOffsetKey_1;
}
var getWindowForNode_1;
var hasRequiredGetWindowForNode;
function requireGetWindowForNode() {
  if (hasRequiredGetWindowForNode) return getWindowForNode_1;
  hasRequiredGetWindowForNode = 1;
  function getWindowForNode(node) {
    if (!node || !node.ownerDocument || !node.ownerDocument.defaultView) {
      return window;
    }
    return node.ownerDocument.defaultView;
  }
  getWindowForNode_1 = getWindowForNode;
  return getWindowForNode_1;
}
var DOMObserver_1;
var hasRequiredDOMObserver;
function requireDOMObserver() {
  if (hasRequiredDOMObserver) return DOMObserver_1;
  hasRequiredDOMObserver = 1;
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var UserAgent = requireUserAgent();
  var findAncestorOffsetKey = requireFindAncestorOffsetKey();
  var getWindowForNode = requireGetWindowForNode();
  var Immutable2 = requireImmutable();
  var invariant2 = requireInvariant();
  var nullthrows = requireNullthrows();
  var Map2 = Immutable2.Map;
  var DOM_OBSERVER_OPTIONS = {
    subtree: true,
    characterData: true,
    childList: true,
    characterDataOldValue: false,
    attributes: false
  };
  var USE_CHAR_DATA = UserAgent.isBrowser("IE <= 11");
  var DOMObserver = /* @__PURE__ */ (function() {
    function DOMObserver2(container) {
      var _this = this;
      _defineProperty2(this, "observer", void 0);
      _defineProperty2(this, "container", void 0);
      _defineProperty2(this, "mutations", void 0);
      _defineProperty2(this, "onCharData", void 0);
      this.container = container;
      this.mutations = Map2();
      var containerWindow = getWindowForNode(container);
      if (containerWindow.MutationObserver && !USE_CHAR_DATA) {
        this.observer = new containerWindow.MutationObserver(function(mutations) {
          return _this.registerMutations(mutations);
        });
      } else {
        this.onCharData = function(e2) {
          !(e2.target instanceof Node) ? invariant2(false) : void 0;
          _this.registerMutation({
            type: "characterData",
            target: e2.target
          });
        };
      }
    }
    var _proto = DOMObserver2.prototype;
    _proto.start = function start() {
      if (this.observer) {
        this.observer.observe(this.container, DOM_OBSERVER_OPTIONS);
      } else {
        this.container.addEventListener("DOMCharacterDataModified", this.onCharData);
      }
    };
    _proto.stopAndFlushMutations = function stopAndFlushMutations() {
      var observer = this.observer;
      if (observer) {
        this.registerMutations(observer.takeRecords());
        observer.disconnect();
      } else {
        this.container.removeEventListener("DOMCharacterDataModified", this.onCharData);
      }
      var mutations = this.mutations;
      this.mutations = Map2();
      return mutations;
    };
    _proto.registerMutations = function registerMutations(mutations) {
      for (var i2 = 0; i2 < mutations.length; i2++) {
        this.registerMutation(mutations[i2]);
      }
    };
    _proto.getMutationTextContent = function getMutationTextContent(mutation) {
      var type = mutation.type, target = mutation.target, removedNodes = mutation.removedNodes;
      if (type === "characterData") {
        if (target.textContent !== "") {
          if (USE_CHAR_DATA) {
            return target.textContent.replace("\n", "");
          }
          return target.textContent;
        }
      } else if (type === "childList") {
        if (removedNodes && removedNodes.length) {
          return "";
        } else if (target.textContent !== "") {
          return target.textContent;
        }
      }
      return null;
    };
    _proto.registerMutation = function registerMutation(mutation) {
      var textContent = this.getMutationTextContent(mutation);
      if (textContent != null) {
        var offsetKey = nullthrows(findAncestorOffsetKey(mutation.target));
        this.mutations = this.mutations.set(offsetKey, textContent);
      }
    };
    return DOMObserver2;
  })();
  DOMObserver_1 = DOMObserver;
  return DOMObserver_1;
}
var DraftOffsetKey_1;
var hasRequiredDraftOffsetKey;
function requireDraftOffsetKey() {
  if (hasRequiredDraftOffsetKey) return DraftOffsetKey_1;
  hasRequiredDraftOffsetKey = 1;
  var KEY_DELIMITER = "-";
  var DraftOffsetKey = {
    encode: function encode2(blockKey, decoratorKey, leafKey) {
      return blockKey + KEY_DELIMITER + decoratorKey + KEY_DELIMITER + leafKey;
    },
    decode: function decode2(offsetKey) {
      var _offsetKey$split$reve = offsetKey.split(KEY_DELIMITER).reverse(), leafKey = _offsetKey$split$reve[0], decoratorKey = _offsetKey$split$reve[1], blockKeyParts = _offsetKey$split$reve.slice(2);
      return {
        // Recomposes the parts of blockKey after reversing them
        blockKey: blockKeyParts.reverse().join(KEY_DELIMITER),
        decoratorKey: parseInt(decoratorKey, 10),
        leafKey: parseInt(leafKey, 10)
      };
    }
  };
  DraftOffsetKey_1 = DraftOffsetKey;
  return DraftOffsetKey_1;
}
var Keys;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys) return Keys;
  hasRequiredKeys = 1;
  Keys = {
    BACKSPACE: 8,
    TAB: 9,
    RETURN: 13,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    DELETE: 46,
    COMMA: 188,
    PERIOD: 190,
    A: 65,
    Z: 90,
    ZERO: 48,
    NUMPAD_0: 96,
    NUMPAD_9: 105
  };
  return Keys;
}
var DraftJsDebugLogging;
var hasRequiredDraftJsDebugLogging;
function requireDraftJsDebugLogging() {
  if (hasRequiredDraftJsDebugLogging) return DraftJsDebugLogging;
  hasRequiredDraftJsDebugLogging = 1;
  DraftJsDebugLogging = {
    logBlockedSelectionEvent: function logBlockedSelectionEvent() {
      return null;
    },
    logSelectionStateFailure: function logSelectionStateFailure() {
      return null;
    }
  };
  return DraftJsDebugLogging;
}
var isHTMLElement_1;
var hasRequiredIsHTMLElement;
function requireIsHTMLElement() {
  if (hasRequiredIsHTMLElement) return isHTMLElement_1;
  hasRequiredIsHTMLElement = 1;
  function isHTMLElement2(node) {
    if (!node || !node.ownerDocument) {
      return false;
    }
    if (!node.ownerDocument.defaultView) {
      return node instanceof HTMLElement;
    }
    if (node instanceof node.ownerDocument.defaultView.HTMLElement) {
      return true;
    }
    return false;
  }
  isHTMLElement_1 = isHTMLElement2;
  return isHTMLElement_1;
}
var getContentEditableContainer_1;
var hasRequiredGetContentEditableContainer;
function requireGetContentEditableContainer() {
  if (hasRequiredGetContentEditableContainer) return getContentEditableContainer_1;
  hasRequiredGetContentEditableContainer = 1;
  var invariant2 = requireInvariant();
  var isHTMLElement2 = requireIsHTMLElement();
  function getContentEditableContainer(editor) {
    var editorNode = editor.editorContainer;
    !editorNode ? invariant2(false) : void 0;
    !isHTMLElement2(editorNode.firstChild) ? invariant2(false) : void 0;
    var htmlElement = editorNode.firstChild;
    return htmlElement;
  }
  getContentEditableContainer_1 = getContentEditableContainer;
  return getContentEditableContainer_1;
}
var getUpdatedSelectionState_1;
var hasRequiredGetUpdatedSelectionState;
function requireGetUpdatedSelectionState() {
  if (hasRequiredGetUpdatedSelectionState) return getUpdatedSelectionState_1;
  hasRequiredGetUpdatedSelectionState = 1;
  var DraftOffsetKey = requireDraftOffsetKey();
  var nullthrows = requireNullthrows();
  function getUpdatedSelectionState(editorState, anchorKey, anchorOffset, focusKey, focusOffset) {
    var selection = nullthrows(editorState.getSelection());
    if (!anchorKey || !focusKey) {
      return selection;
    }
    var anchorPath = DraftOffsetKey.decode(anchorKey);
    var anchorBlockKey = anchorPath.blockKey;
    var anchorLeafBlockTree = editorState.getBlockTree(anchorBlockKey);
    var anchorLeaf = anchorLeafBlockTree && anchorLeafBlockTree.getIn([anchorPath.decoratorKey, "leaves", anchorPath.leafKey]);
    var focusPath = DraftOffsetKey.decode(focusKey);
    var focusBlockKey = focusPath.blockKey;
    var focusLeafBlockTree = editorState.getBlockTree(focusBlockKey);
    var focusLeaf = focusLeafBlockTree && focusLeafBlockTree.getIn([focusPath.decoratorKey, "leaves", focusPath.leafKey]);
    if (!anchorLeaf || !focusLeaf) {
      return selection;
    }
    var anchorLeafStart = anchorLeaf.get("start");
    var focusLeafStart = focusLeaf.get("start");
    var anchorBlockOffset = anchorLeaf ? anchorLeafStart + anchorOffset : null;
    var focusBlockOffset = focusLeaf ? focusLeafStart + focusOffset : null;
    var areEqual = selection.getAnchorKey() === anchorBlockKey && selection.getAnchorOffset() === anchorBlockOffset && selection.getFocusKey() === focusBlockKey && selection.getFocusOffset() === focusBlockOffset;
    if (areEqual) {
      return selection;
    }
    var isBackward = false;
    if (anchorBlockKey === focusBlockKey) {
      var anchorLeafEnd = anchorLeaf.get("end");
      var focusLeafEnd = focusLeaf.get("end");
      if (focusLeafStart === anchorLeafStart && focusLeafEnd === anchorLeafEnd) {
        isBackward = focusOffset < anchorOffset;
      } else {
        isBackward = focusLeafStart < anchorLeafStart;
      }
    } else {
      var startKey = editorState.getCurrentContent().getBlockMap().keySeq().skipUntil(function(v2) {
        return v2 === anchorBlockKey || v2 === focusBlockKey;
      }).first();
      isBackward = startKey === focusBlockKey;
    }
    return selection.merge({
      anchorKey: anchorBlockKey,
      anchorOffset: anchorBlockOffset,
      focusKey: focusBlockKey,
      focusOffset: focusBlockOffset,
      isBackward
    });
  }
  getUpdatedSelectionState_1 = getUpdatedSelectionState;
  return getUpdatedSelectionState_1;
}
var getDraftEditorSelectionWithNodes_1;
var hasRequiredGetDraftEditorSelectionWithNodes;
function requireGetDraftEditorSelectionWithNodes() {
  if (hasRequiredGetDraftEditorSelectionWithNodes) return getDraftEditorSelectionWithNodes_1;
  hasRequiredGetDraftEditorSelectionWithNodes = 1;
  var findAncestorOffsetKey = requireFindAncestorOffsetKey();
  var getSelectionOffsetKeyForNode = requireGetSelectionOffsetKeyForNode();
  var getUpdatedSelectionState = requireGetUpdatedSelectionState();
  var invariant2 = requireInvariant();
  var isElement = requireIsElement();
  var nullthrows = requireNullthrows();
  function getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {
    var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;
    var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE;
    if (anchorIsTextNode && focusIsTextNode) {
      return {
        selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),
        needsRecovery: false
      };
    }
    var anchorPoint = null;
    var focusPoint = null;
    var needsRecovery = true;
    if (anchorIsTextNode) {
      anchorPoint = {
        key: nullthrows(findAncestorOffsetKey(anchorNode)),
        offset: anchorOffset
      };
      focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);
    } else if (focusIsTextNode) {
      focusPoint = {
        key: nullthrows(findAncestorOffsetKey(focusNode)),
        offset: focusOffset
      };
      anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);
    } else {
      anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);
      focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);
      if (anchorNode === focusNode && anchorOffset === focusOffset) {
        needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== "BR";
      }
    }
    return {
      selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),
      needsRecovery
    };
  }
  function getFirstLeaf(node) {
    while (node.firstChild && // data-blocks has no offset
    (isElement(node.firstChild) && node.firstChild.getAttribute("data-blocks") === "true" || getSelectionOffsetKeyForNode(node.firstChild))) {
      node = node.firstChild;
    }
    return node;
  }
  function getLastLeaf(node) {
    while (node.lastChild && // data-blocks has no offset
    (isElement(node.lastChild) && node.lastChild.getAttribute("data-blocks") === "true" || getSelectionOffsetKeyForNode(node.lastChild))) {
      node = node.lastChild;
    }
    return node;
  }
  function getPointForNonTextNode(editorRoot, startNode, childOffset) {
    var node = startNode;
    var offsetKey = findAncestorOffsetKey(node);
    !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? invariant2(false) : void 0;
    if (editorRoot === node) {
      node = node.firstChild;
      !isElement(node) ? invariant2(false) : void 0;
      var castedNode = node;
      node = castedNode;
      !(node.getAttribute("data-contents") === "true") ? invariant2(false) : void 0;
      if (childOffset > 0) {
        childOffset = node.childNodes.length;
      }
    }
    if (childOffset === 0) {
      var key = null;
      if (offsetKey != null) {
        key = offsetKey;
      } else {
        var firstLeaf = getFirstLeaf(node);
        key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));
      }
      return {
        key,
        offset: 0
      };
    }
    var nodeBeforeCursor = node.childNodes[childOffset - 1];
    var leafKey = null;
    var textLength = null;
    if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {
      leafKey = nullthrows(offsetKey);
      textLength = getTextContentLength(nodeBeforeCursor);
    } else {
      var lastLeaf = getLastLeaf(nodeBeforeCursor);
      leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));
      textLength = getTextContentLength(lastLeaf);
    }
    return {
      key: leafKey,
      offset: textLength
    };
  }
  function getTextContentLength(node) {
    var textContent = node.textContent;
    return textContent === "\n" ? 0 : textContent.length;
  }
  getDraftEditorSelectionWithNodes_1 = getDraftEditorSelectionWithNodes;
  return getDraftEditorSelectionWithNodes_1;
}
var getDraftEditorSelection_1;
var hasRequiredGetDraftEditorSelection;
function requireGetDraftEditorSelection() {
  if (hasRequiredGetDraftEditorSelection) return getDraftEditorSelection_1;
  hasRequiredGetDraftEditorSelection = 1;
  var getDraftEditorSelectionWithNodes = requireGetDraftEditorSelectionWithNodes();
  function getDraftEditorSelection(editorState, root) {
    var selection = root.ownerDocument.defaultView.getSelection();
    var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset, rangeCount = selection.rangeCount;
    if (
      // No active selection.
      rangeCount === 0 || // No selection, ever. As in, the user hasn't selected anything since
      // opening the document.
      anchorNode == null || focusNode == null
    ) {
      return {
        selectionState: editorState.getSelection().set("hasFocus", false),
        needsRecovery: false
      };
    }
    return getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset);
  }
  getDraftEditorSelection_1 = getDraftEditorSelection;
  return getDraftEditorSelection_1;
}
var editOnSelect_1;
var hasRequiredEditOnSelect;
function requireEditOnSelect() {
  if (hasRequiredEditOnSelect) return editOnSelect_1;
  hasRequiredEditOnSelect = 1;
  var DraftJsDebugLogging2 = requireDraftJsDebugLogging();
  var EditorState = requireEditorState();
  var getContentEditableContainer = requireGetContentEditableContainer();
  var getDraftEditorSelection = requireGetDraftEditorSelection();
  function editOnSelect(editor) {
    if (editor._blockSelectEvents || editor._latestEditorState !== editor.props.editorState) {
      if (editor._blockSelectEvents) {
        var _editorState = editor.props.editorState;
        var selectionState = _editorState.getSelection();
        DraftJsDebugLogging2.logBlockedSelectionEvent({
          // For now I don't think we need any other info
          anonymizedDom: "N/A",
          extraParams: JSON.stringify({
            stacktrace: new Error().stack
          }),
          selectionState: JSON.stringify(selectionState.toJS())
        });
      }
      return;
    }
    var editorState = editor.props.editorState;
    var documentSelection = getDraftEditorSelection(editorState, getContentEditableContainer(editor));
    var updatedSelectionState = documentSelection.selectionState;
    if (updatedSelectionState !== editorState.getSelection()) {
      if (documentSelection.needsRecovery) {
        editorState = EditorState.forceSelection(editorState, updatedSelectionState);
      } else {
        editorState = EditorState.acceptSelection(editorState, updatedSelectionState);
      }
      editor.update(editorState);
    }
  }
  editOnSelect_1 = editOnSelect;
  return editOnSelect_1;
}
var draftKeyUtils;
var hasRequiredDraftKeyUtils;
function requireDraftKeyUtils() {
  if (hasRequiredDraftKeyUtils) return draftKeyUtils;
  hasRequiredDraftKeyUtils = 1;
  function notEmptyKey(key) {
    return key != null && key != "";
  }
  draftKeyUtils = {
    notEmptyKey
  };
  return draftKeyUtils;
}
var getEntityKeyForSelection_1;
var hasRequiredGetEntityKeyForSelection;
function requireGetEntityKeyForSelection() {
  if (hasRequiredGetEntityKeyForSelection) return getEntityKeyForSelection_1;
  hasRequiredGetEntityKeyForSelection = 1;
  var _require = requireDraftKeyUtils(), notEmptyKey = _require.notEmptyKey;
  function getEntityKeyForSelection(contentState, targetSelection) {
    var entityKey;
    if (targetSelection.isCollapsed()) {
      var key = targetSelection.getAnchorKey();
      var offset = targetSelection.getAnchorOffset();
      if (offset > 0) {
        entityKey = contentState.getBlockForKey(key).getEntityAt(offset - 1);
        if (entityKey !== contentState.getBlockForKey(key).getEntityAt(offset)) {
          return null;
        }
        return filterKey(contentState.getEntityMap(), entityKey);
      }
      return null;
    }
    var startKey = targetSelection.getStartKey();
    var startOffset = targetSelection.getStartOffset();
    var startBlock = contentState.getBlockForKey(startKey);
    entityKey = startOffset === startBlock.getLength() ? null : startBlock.getEntityAt(startOffset);
    return filterKey(contentState.getEntityMap(), entityKey);
  }
  function filterKey(entityMap, entityKey) {
    if (notEmptyKey(entityKey)) {
      var entity = entityMap.__get(entityKey);
      return entity.getMutability() === "MUTABLE" ? entityKey : null;
    }
    return null;
  }
  getEntityKeyForSelection_1 = getEntityKeyForSelection;
  return getEntityKeyForSelection_1;
}
var DraftEditorCompositionHandler_1;
var hasRequiredDraftEditorCompositionHandler;
function requireDraftEditorCompositionHandler() {
  if (hasRequiredDraftEditorCompositionHandler) return DraftEditorCompositionHandler_1;
  hasRequiredDraftEditorCompositionHandler = 1;
  var DOMObserver = requireDOMObserver();
  var DraftModifier = requireDraftModifier();
  var DraftOffsetKey = requireDraftOffsetKey();
  var EditorState = requireEditorState();
  var Keys2 = requireKeys();
  var UserAgent = requireUserAgent();
  var editOnSelect = requireEditOnSelect();
  var getContentEditableContainer = requireGetContentEditableContainer();
  var getDraftEditorSelection = requireGetDraftEditorSelection();
  var getEntityKeyForSelection = requireGetEntityKeyForSelection();
  var nullthrows = requireNullthrows();
  var isIE = UserAgent.isBrowser("IE");
  var RESOLVE_DELAY = 20;
  var resolved = false;
  var stillComposing = false;
  var domObserver = null;
  function startDOMObserver(editor) {
    if (!domObserver) {
      domObserver = new DOMObserver(getContentEditableContainer(editor));
      domObserver.start();
    }
  }
  var DraftEditorCompositionHandler = {
    /**
     * A `compositionstart` event has fired while we're still in composition
     * mode. Continue the current composition session to prevent a re-render.
     */
    onCompositionStart: function onCompositionStart(editor) {
      stillComposing = true;
      startDOMObserver(editor);
    },
    /**
     * Attempt to end the current composition session.
     *
     * Defer handling because browser will still insert the chars into active
     * element after `compositionend`. If a `compositionstart` event fires
     * before `resolveComposition` executes, our composition session will
     * continue.
     *
     * The `resolved` flag is useful because certain IME interfaces fire the
     * `compositionend` event multiple times, thus queueing up multiple attempts
     * at handling the composition. Since handling the same composition event
     * twice could break the DOM, we only use the first event. Example: Arabic
     * Google Input Tools on Windows 8.1 fires `compositionend` three times.
     */
    onCompositionEnd: function onCompositionEnd(editor) {
      resolved = false;
      stillComposing = false;
      setTimeout(function() {
        if (!resolved) {
          DraftEditorCompositionHandler.resolveComposition(editor);
        }
      }, RESOLVE_DELAY);
    },
    onSelect: editOnSelect,
    /**
     * In Safari, keydown events may fire when committing compositions. If
     * the arrow keys are used to commit, prevent default so that the cursor
     * doesn't move, otherwise it will jump back noticeably on re-render.
     */
    onKeyDown: function onKeyDown(editor, e2) {
      if (!stillComposing) {
        DraftEditorCompositionHandler.resolveComposition(editor);
        editor._onKeyDown(e2);
        return;
      }
      if (e2.which === Keys2.RIGHT || e2.which === Keys2.LEFT) {
        e2.preventDefault();
      }
    },
    /**
     * Keypress events may fire when committing compositions. In Firefox,
     * pressing RETURN commits the composition and inserts extra newline
     * characters that we do not want. `preventDefault` allows the composition
     * to be committed while preventing the extra characters.
     */
    onKeyPress: function onKeyPress(_editor, e2) {
      if (e2.which === Keys2.RETURN) {
        e2.preventDefault();
      }
    },
    /**
     * Attempt to insert composed characters into the document.
     *
     * If we are still in a composition session, do nothing. Otherwise, insert
     * the characters into the document and terminate the composition session.
     *
     * If no characters were composed -- for instance, the user
     * deleted all composed characters and committed nothing new --
     * force a re-render. We also re-render when the composition occurs
     * at the beginning of a leaf, to ensure that if the browser has
     * created a new text node for the composition, we will discard it.
     *
     * Resetting innerHTML will move focus to the beginning of the editor,
     * so we update to force it back to the correct place.
     */
    resolveComposition: function resolveComposition(editor) {
      if (stillComposing) {
        return;
      }
      var mutations = nullthrows(domObserver).stopAndFlushMutations();
      domObserver = null;
      resolved = true;
      var editorState = EditorState.set(editor._latestEditorState, {
        inCompositionMode: false
      });
      editor.exitCurrentMode();
      if (!mutations.size) {
        editor.update(editorState);
        return;
      }
      var contentState = editorState.getCurrentContent();
      mutations.forEach(function(composedChars, offsetKey) {
        var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey), blockKey = _DraftOffsetKey$decod.blockKey, decoratorKey = _DraftOffsetKey$decod.decoratorKey, leafKey = _DraftOffsetKey$decod.leafKey;
        var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, "leaves", leafKey]), start = _editorState$getBlock.start, end = _editorState$getBlock.end;
        var replacementRange = editorState.getSelection().merge({
          anchorKey: blockKey,
          focusKey: blockKey,
          anchorOffset: start,
          focusOffset: end,
          isBackward: false
        });
        var entityKey = getEntityKeyForSelection(contentState, replacementRange);
        var currentStyle = contentState.getBlockForKey(blockKey).getInlineStyleAt(start);
        contentState = DraftModifier.replaceText(contentState, replacementRange, composedChars, currentStyle, entityKey);
        editorState = EditorState.set(editorState, {
          currentContent: contentState
        });
      });
      var documentSelection = getDraftEditorSelection(editorState, getContentEditableContainer(editor));
      var compositionEndSelectionState = documentSelection.selectionState;
      editor.restoreEditorDOM();
      var editorStateWithUpdatedSelection = isIE ? EditorState.forceSelection(editorState, compositionEndSelectionState) : EditorState.acceptSelection(editorState, compositionEndSelectionState);
      editor.update(EditorState.push(editorStateWithUpdatedSelection, contentState, "insert-characters"));
    }
  };
  DraftEditorCompositionHandler_1 = DraftEditorCompositionHandler;
  return DraftEditorCompositionHandler_1;
}
var DraftEditorDecoratedLeaves_react;
var hasRequiredDraftEditorDecoratedLeaves_react;
function requireDraftEditorDecoratedLeaves_react() {
  if (hasRequiredDraftEditorDecoratedLeaves_react) return DraftEditorDecoratedLeaves_react;
  hasRequiredDraftEditorDecoratedLeaves_react = 1;
  var _assign = requireObjectAssign();
  function _extends2() {
    _extends2 = _assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var DraftOffsetKey = requireDraftOffsetKey();
  var React2 = requireReact();
  var UnicodeBidi = requireUnicodeBidi();
  var UnicodeBidiDirection = requireUnicodeBidiDirection();
  var DraftEditorDecoratedLeaves = /* @__PURE__ */ (function(_React$Component) {
    _inheritsLoose2(DraftEditorDecoratedLeaves2, _React$Component);
    function DraftEditorDecoratedLeaves2() {
      return _React$Component.apply(this, arguments) || this;
    }
    var _proto = DraftEditorDecoratedLeaves2.prototype;
    _proto.render = function render3() {
      var _this$props = this.props, block = _this$props.block, children = _this$props.children, contentState = _this$props.contentState, decorator = _this$props.decorator, decoratorKey = _this$props.decoratorKey, direction = _this$props.direction, leafSet = _this$props.leafSet, text = _this$props.text;
      var blockKey = block.getKey();
      var leavesForLeafSet = leafSet.get("leaves");
      var DecoratorComponent = decorator.getComponentForKey(decoratorKey);
      var decoratorProps = decorator.getPropsForKey(decoratorKey);
      var decoratorOffsetKey = DraftOffsetKey.encode(blockKey, parseInt(decoratorKey, 10), 0);
      var decoratedText = text.slice(leavesForLeafSet.first().get("start"), leavesForLeafSet.last().get("end"));
      var dir = UnicodeBidiDirection.getHTMLDirIfDifferent(UnicodeBidi.getDirection(decoratedText), direction);
      return React2.createElement(DecoratorComponent, _extends2({}, decoratorProps, {
        contentState,
        decoratedText,
        dir,
        key: decoratorOffsetKey,
        entityKey: block.getEntityAt(leafSet.get("start")),
        offsetKey: decoratorOffsetKey
      }), children);
    };
    return DraftEditorDecoratedLeaves2;
  })(React2.Component);
  DraftEditorDecoratedLeaves_react = DraftEditorDecoratedLeaves;
  return DraftEditorDecoratedLeaves_react;
}
var DraftEditorTextNode_react;
var hasRequiredDraftEditorTextNode_react;
function requireDraftEditorTextNode_react() {
  if (hasRequiredDraftEditorTextNode_react) return DraftEditorTextNode_react;
  hasRequiredDraftEditorTextNode_react = 1;
  function _assertThisInitialized2(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var React2 = requireReact();
  var UserAgent = requireUserAgent();
  var invariant2 = requireInvariant();
  var isElement = requireIsElement();
  var useNewlineChar = UserAgent.isBrowser("IE <= 11");
  function isNewline(node) {
    return useNewlineChar ? node.textContent === "\n" : node.tagName === "BR";
  }
  var NEWLINE_A = function NEWLINE_A2(ref) {
    return useNewlineChar ? React2.createElement("span", {
      key: "A",
      "data-text": "true",
      ref
    }, "\n") : React2.createElement("br", {
      key: "A",
      "data-text": "true",
      ref
    });
  };
  var NEWLINE_B = function NEWLINE_B2(ref) {
    return useNewlineChar ? React2.createElement("span", {
      key: "B",
      "data-text": "true",
      ref
    }, "\n") : React2.createElement("br", {
      key: "B",
      "data-text": "true",
      ref
    });
  };
  var DraftEditorTextNode = /* @__PURE__ */ (function(_React$Component) {
    _inheritsLoose2(DraftEditorTextNode2, _React$Component);
    function DraftEditorTextNode2(props) {
      var _this;
      _this = _React$Component.call(this, props) || this;
      _defineProperty2(_assertThisInitialized2(_this), "_forceFlag", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_node", void 0);
      _this._forceFlag = false;
      return _this;
    }
    var _proto = DraftEditorTextNode2.prototype;
    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var node = this._node;
      var shouldBeNewline = nextProps.children === "";
      !isElement(node) ? invariant2(false) : void 0;
      var elementNode = node;
      if (shouldBeNewline) {
        return !isNewline(elementNode);
      }
      return elementNode.textContent !== nextProps.children;
    };
    _proto.componentDidMount = function componentDidMount() {
      this._forceFlag = !this._forceFlag;
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      this._forceFlag = !this._forceFlag;
    };
    _proto.render = function render3() {
      var _this2 = this;
      if (this.props.children === "") {
        return this._forceFlag ? NEWLINE_A(function(ref) {
          return _this2._node = ref;
        }) : NEWLINE_B(function(ref) {
          return _this2._node = ref;
        });
      }
      return React2.createElement("span", {
        key: this._forceFlag ? "A" : "B",
        "data-text": "true",
        ref: function ref(_ref) {
          return _this2._node = _ref;
        }
      }, this.props.children);
    };
    return DraftEditorTextNode2;
  })(React2.Component);
  DraftEditorTextNode_react = DraftEditorTextNode;
  return DraftEditorTextNode_react;
}
var isHTMLBRElement_1;
var hasRequiredIsHTMLBRElement;
function requireIsHTMLBRElement() {
  if (hasRequiredIsHTMLBRElement) return isHTMLBRElement_1;
  hasRequiredIsHTMLBRElement = 1;
  var isElement = requireIsElement();
  function isHTMLBRElement(node) {
    if (!node || !node.ownerDocument) {
      return false;
    }
    return isElement(node) && node.nodeName === "BR";
  }
  isHTMLBRElement_1 = isHTMLBRElement;
  return isHTMLBRElement_1;
}
var DraftEffects;
var hasRequiredDraftEffects;
function requireDraftEffects() {
  if (hasRequiredDraftEffects) return DraftEffects;
  hasRequiredDraftEffects = 1;
  DraftEffects = {
    initODS: function initODS() {
    },
    handleExtensionCausedError: function handleExtensionCausedError() {
    }
  };
  return DraftEffects;
}
var isNode_1;
var hasRequiredIsNode;
function requireIsNode() {
  if (hasRequiredIsNode) return isNode_1;
  hasRequiredIsNode = 1;
  function isNode2(object2) {
    var doc = object2 ? object2.ownerDocument || object2 : document;
    var defaultView = doc.defaultView || window;
    return !!(object2 && (typeof defaultView.Node === "function" ? object2 instanceof defaultView.Node : typeof object2 === "object" && typeof object2.nodeType === "number" && typeof object2.nodeName === "string"));
  }
  isNode_1 = isNode2;
  return isNode_1;
}
var isTextNode_1;
var hasRequiredIsTextNode;
function requireIsTextNode() {
  if (hasRequiredIsTextNode) return isTextNode_1;
  hasRequiredIsTextNode = 1;
  var isNode2 = requireIsNode();
  function isTextNode(object2) {
    return isNode2(object2) && object2.nodeType == 3;
  }
  isTextNode_1 = isTextNode;
  return isTextNode_1;
}
var containsNode_1;
var hasRequiredContainsNode;
function requireContainsNode() {
  if (hasRequiredContainsNode) return containsNode_1;
  hasRequiredContainsNode = 1;
  var isTextNode = requireIsTextNode();
  function containsNode(outerNode, innerNode) {
    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      return containsNode(outerNode, innerNode.parentNode);
    } else if ("contains" in outerNode) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
  containsNode_1 = containsNode;
  return containsNode_1;
}
var getActiveElement_1;
var hasRequiredGetActiveElement;
function requireGetActiveElement() {
  if (hasRequiredGetActiveElement) return getActiveElement_1;
  hasRequiredGetActiveElement = 1;
  function getActiveElement(doc) {
    doc = doc || (typeof document !== "undefined" ? document : void 0);
    if (typeof doc === "undefined") {
      return null;
    }
    try {
      return doc.activeElement || doc.body;
    } catch (e2) {
      return doc.body;
    }
  }
  getActiveElement_1 = getActiveElement;
  return getActiveElement_1;
}
var setDraftEditorSelection_1;
var hasRequiredSetDraftEditorSelection;
function requireSetDraftEditorSelection() {
  if (hasRequiredSetDraftEditorSelection) return setDraftEditorSelection_1;
  hasRequiredSetDraftEditorSelection = 1;
  var DraftEffects2 = requireDraftEffects();
  var DraftJsDebugLogging2 = requireDraftJsDebugLogging();
  var UserAgent = requireUserAgent();
  var containsNode = requireContainsNode();
  var getActiveElement = requireGetActiveElement();
  var getCorrectDocumentFromNode = requireGetCorrectDocumentFromNode();
  var invariant2 = requireInvariant();
  var isElement = requireIsElement();
  var isIE = UserAgent.isBrowser("IE");
  function getAnonymizedDOM(node, getNodeLabels) {
    if (!node) {
      return "[empty]";
    }
    var anonymized = anonymizeTextWithin(node, getNodeLabels);
    if (anonymized.nodeType === Node.TEXT_NODE) {
      return anonymized.textContent;
    }
    !isElement(anonymized) ? invariant2(false) : void 0;
    var castedElement = anonymized;
    return castedElement.outerHTML;
  }
  function anonymizeTextWithin(node, getNodeLabels) {
    var labels = getNodeLabels !== void 0 ? getNodeLabels(node) : [];
    if (node.nodeType === Node.TEXT_NODE) {
      var length = node.textContent.length;
      return getCorrectDocumentFromNode(node).createTextNode("[text " + length + (labels.length ? " | " + labels.join(", ") : "") + "]");
    }
    var clone2 = node.cloneNode();
    if (clone2.nodeType === 1 && labels.length) {
      clone2.setAttribute("data-labels", labels.join(", "));
    }
    var childNodes = node.childNodes;
    for (var ii = 0; ii < childNodes.length; ii++) {
      clone2.appendChild(anonymizeTextWithin(childNodes[ii], getNodeLabels));
    }
    return clone2;
  }
  function getAnonymizedEditorDOM(node, getNodeLabels) {
    var currentNode = node;
    var castedNode = currentNode;
    while (currentNode) {
      if (isElement(currentNode) && castedNode.hasAttribute("contenteditable")) {
        return getAnonymizedDOM(currentNode, getNodeLabels);
      } else {
        currentNode = currentNode.parentNode;
        castedNode = currentNode;
      }
    }
    return "Could not find contentEditable parent of node";
  }
  function getNodeLength(node) {
    return node.nodeValue === null ? node.childNodes.length : node.nodeValue.length;
  }
  function setDraftEditorSelection(selectionState, node, blockKey, nodeStart, nodeEnd) {
    var documentObject = getCorrectDocumentFromNode(node);
    if (!containsNode(documentObject.documentElement, node)) {
      return;
    }
    var selection = documentObject.defaultView.getSelection();
    var anchorKey = selectionState.getAnchorKey();
    var anchorOffset = selectionState.getAnchorOffset();
    var focusKey = selectionState.getFocusKey();
    var focusOffset = selectionState.getFocusOffset();
    var isBackward = selectionState.getIsBackward();
    if (!selection.extend && isBackward) {
      var tempKey = anchorKey;
      var tempOffset = anchorOffset;
      anchorKey = focusKey;
      anchorOffset = focusOffset;
      focusKey = tempKey;
      focusOffset = tempOffset;
      isBackward = false;
    }
    var hasAnchor = anchorKey === blockKey && nodeStart <= anchorOffset && nodeEnd >= anchorOffset;
    var hasFocus = focusKey === blockKey && nodeStart <= focusOffset && nodeEnd >= focusOffset;
    if (hasAnchor && hasFocus) {
      selection.removeAllRanges();
      addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
      addFocusToSelection(selection, node, focusOffset - nodeStart, selectionState);
      return;
    }
    if (!isBackward) {
      if (hasAnchor) {
        selection.removeAllRanges();
        addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
      }
      if (hasFocus) {
        addFocusToSelection(selection, node, focusOffset - nodeStart, selectionState);
      }
    } else {
      if (hasFocus) {
        selection.removeAllRanges();
        addPointToSelection(selection, node, focusOffset - nodeStart, selectionState);
      }
      if (hasAnchor) {
        var storedFocusNode = selection.focusNode;
        var storedFocusOffset = selection.focusOffset;
        selection.removeAllRanges();
        addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
        addFocusToSelection(selection, storedFocusNode, storedFocusOffset, selectionState);
      }
    }
  }
  function addFocusToSelection(selection, node, offset, selectionState) {
    var activeElement = getActiveElement();
    var extend2 = selection.extend;
    if (extend2 && node != null && containsNode(activeElement, node)) {
      if (offset > getNodeLength(node)) {
        DraftJsDebugLogging2.logSelectionStateFailure({
          anonymizedDom: getAnonymizedEditorDOM(node),
          extraParams: JSON.stringify({
            offset
          }),
          selectionState: JSON.stringify(selectionState.toJS())
        });
      }
      var nodeWasFocus = node === selection.focusNode;
      try {
        if (selection.rangeCount > 0 && selection.extend) {
          selection.extend(node, offset);
        }
      } catch (e2) {
        DraftJsDebugLogging2.logSelectionStateFailure({
          anonymizedDom: getAnonymizedEditorDOM(node, function(n2) {
            var labels = [];
            if (n2 === activeElement) {
              labels.push("active element");
            }
            if (n2 === selection.anchorNode) {
              labels.push("selection anchor node");
            }
            if (n2 === selection.focusNode) {
              labels.push("selection focus node");
            }
            return labels;
          }),
          extraParams: JSON.stringify({
            activeElementName: activeElement ? activeElement.nodeName : null,
            nodeIsFocus: node === selection.focusNode,
            nodeWasFocus,
            selectionRangeCount: selection.rangeCount,
            selectionAnchorNodeName: selection.anchorNode ? selection.anchorNode.nodeName : null,
            selectionAnchorOffset: selection.anchorOffset,
            selectionFocusNodeName: selection.focusNode ? selection.focusNode.nodeName : null,
            selectionFocusOffset: selection.focusOffset,
            message: e2 ? "" + e2 : null,
            offset
          }, null, 2),
          selectionState: JSON.stringify(selectionState.toJS(), null, 2)
        });
        throw e2;
      }
    } else {
      if (node && selection.rangeCount > 0) {
        var range = selection.getRangeAt(0);
        range.setEnd(node, offset);
        selection.addRange(range.cloneRange());
      }
    }
  }
  function addPointToSelection(selection, node, offset, selectionState) {
    var range = getCorrectDocumentFromNode(node).createRange();
    if (offset > getNodeLength(node)) {
      DraftJsDebugLogging2.logSelectionStateFailure({
        anonymizedDom: getAnonymizedEditorDOM(node),
        extraParams: JSON.stringify({
          offset
        }),
        selectionState: JSON.stringify(selectionState.toJS())
      });
      DraftEffects2.handleExtensionCausedError();
    }
    range.setStart(node, offset);
    if (isIE) {
      try {
        selection.addRange(range);
      } catch (e2) {
      }
    } else {
      selection.addRange(range);
    }
  }
  setDraftEditorSelection_1 = {
    setDraftEditorSelection,
    addFocusToSelection
  };
  return setDraftEditorSelection_1;
}
var DraftEditorLeaf_react;
var hasRequiredDraftEditorLeaf_react;
function requireDraftEditorLeaf_react() {
  if (hasRequiredDraftEditorLeaf_react) return DraftEditorLeaf_react;
  hasRequiredDraftEditorLeaf_react = 1;
  var _assign = requireObjectAssign();
  function _assertThisInitialized2(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var DraftEditorTextNode = requireDraftEditorTextNode_react();
  var React2 = requireReact();
  var invariant2 = requireInvariant();
  var isHTMLBRElement = requireIsHTMLBRElement();
  var setDraftEditorSelection = requireSetDraftEditorSelection().setDraftEditorSelection;
  var DraftEditorLeaf = /* @__PURE__ */ (function(_React$Component) {
    _inheritsLoose2(DraftEditorLeaf2, _React$Component);
    function DraftEditorLeaf2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _defineProperty2(_assertThisInitialized2(_this), "leaf", void 0);
      return _this;
    }
    var _proto = DraftEditorLeaf2.prototype;
    _proto._setSelection = function _setSelection() {
      var selection = this.props.selection;
      if (selection == null || !selection.getHasFocus()) {
        return;
      }
      var _this$props = this.props, block = _this$props.block, start = _this$props.start, text = _this$props.text;
      var blockKey = block.getKey();
      var end = start + text.length;
      if (!selection.hasEdgeWithin(blockKey, start, end)) {
        return;
      }
      var node = this.leaf;
      !node ? invariant2(false) : void 0;
      var child = node.firstChild;
      !child ? invariant2(false) : void 0;
      var targetNode;
      if (child.nodeType === Node.TEXT_NODE) {
        targetNode = child;
      } else if (isHTMLBRElement(child)) {
        targetNode = node;
      } else {
        targetNode = child.firstChild;
        !targetNode ? invariant2(false) : void 0;
      }
      setDraftEditorSelection(selection, targetNode, blockKey, start, end);
    };
    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var leafNode = this.leaf;
      !leafNode ? invariant2(false) : void 0;
      var shouldUpdate = leafNode.textContent !== nextProps.text || nextProps.styleSet !== this.props.styleSet || nextProps.forceSelection;
      return shouldUpdate;
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      this._setSelection();
    };
    _proto.componentDidMount = function componentDidMount() {
      this._setSelection();
    };
    _proto.render = function render3() {
      var _this2 = this;
      var block = this.props.block;
      var text = this.props.text;
      if (text.endsWith("\n") && this.props.isLast) {
        text += "\n";
      }
      var _this$props2 = this.props, customStyleMap = _this$props2.customStyleMap, customStyleFn = _this$props2.customStyleFn, offsetKey = _this$props2.offsetKey, styleSet = _this$props2.styleSet;
      var styleObj = styleSet.reduce(function(map3, styleName) {
        var mergedStyles = {};
        var style = customStyleMap[styleName];
        if (style !== void 0 && map3.textDecoration !== style.textDecoration) {
          mergedStyles.textDecoration = [map3.textDecoration, style.textDecoration].join(" ").trim();
        }
        return _assign(map3, style, mergedStyles);
      }, {});
      if (customStyleFn) {
        var newStyles = customStyleFn(styleSet, block);
        styleObj = _assign(styleObj, newStyles);
      }
      return React2.createElement("span", {
        "data-offset-key": offsetKey,
        ref: function ref(_ref) {
          return _this2.leaf = _ref;
        },
        style: styleObj
      }, React2.createElement(DraftEditorTextNode, null, text));
    };
    return DraftEditorLeaf2;
  })(React2.Component);
  DraftEditorLeaf_react = DraftEditorLeaf;
  return DraftEditorLeaf_react;
}
var DraftEditorNode_react;
var hasRequiredDraftEditorNode_react;
function requireDraftEditorNode_react() {
  if (hasRequiredDraftEditorNode_react) return DraftEditorNode_react;
  hasRequiredDraftEditorNode_react = 1;
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var DraftEditorDecoratedLeaves = requireDraftEditorDecoratedLeaves_react();
  var DraftEditorLeaf = requireDraftEditorLeaf_react();
  var DraftOffsetKey = requireDraftOffsetKey();
  var Immutable2 = requireImmutable();
  var React2 = requireReact();
  var cx = requireCx();
  Immutable2.List;
  var DraftEditorNode = /* @__PURE__ */ (function(_React$Component) {
    _inheritsLoose2(DraftEditorNode2, _React$Component);
    function DraftEditorNode2() {
      return _React$Component.apply(this, arguments) || this;
    }
    var _proto = DraftEditorNode2.prototype;
    _proto.render = function render3() {
      var _this$props = this.props, block = _this$props.block, contentState = _this$props.contentState, customStyleFn = _this$props.customStyleFn, customStyleMap = _this$props.customStyleMap, decorator = _this$props.decorator, direction = _this$props.direction, forceSelection = _this$props.forceSelection, hasSelection = _this$props.hasSelection, selection = _this$props.selection, tree = _this$props.tree;
      var blockKey = block.getKey();
      var text = block.getText();
      var lastLeafSet = tree.size - 1;
      var children = this.props.children || tree.map(function(leafSet, ii) {
        var decoratorKey = leafSet.get("decoratorKey");
        var leavesForLeafSet = leafSet.get("leaves");
        var lastLeaf = leavesForLeafSet.size - 1;
        var Leaves = leavesForLeafSet.map(function(leaf, jj) {
          var offsetKey = DraftOffsetKey.encode(blockKey, ii, jj);
          var start = leaf.get("start");
          var end = leaf.get("end");
          return React2.createElement(DraftEditorLeaf, {
            key: offsetKey,
            offsetKey,
            block,
            start,
            selection: hasSelection ? selection : null,
            forceSelection,
            text: text.slice(start, end),
            styleSet: block.getInlineStyleAt(start),
            customStyleMap,
            customStyleFn,
            isLast: decoratorKey === lastLeafSet && jj === lastLeaf
          });
        }).toArray();
        if (!decoratorKey || !decorator) {
          return Leaves;
        }
        return React2.createElement(DraftEditorDecoratedLeaves, {
          block,
          children: Leaves,
          contentState,
          decorator,
          decoratorKey,
          direction,
          leafSet,
          text,
          key: ii
        });
      }).toArray();
      return React2.createElement("div", {
        "data-offset-key": DraftOffsetKey.encode(blockKey, 0, 0),
        className: cx({
          "public/DraftStyleDefault/block": true,
          "public/DraftStyleDefault/ltr": direction === "LTR",
          "public/DraftStyleDefault/rtl": direction === "RTL"
        })
      }, children);
    };
    return DraftEditorNode2;
  })(React2.Component);
  DraftEditorNode_react = DraftEditorNode;
  return DraftEditorNode_react;
}
var Scroll_1;
var hasRequiredScroll;
function requireScroll() {
  if (hasRequiredScroll) return Scroll_1;
  hasRequiredScroll = 1;
  function _isViewportScrollElement(element, doc) {
    return !!doc && (element === doc.documentElement || element === doc.body);
  }
  var Scroll = {
    /**
     * @param {DOMElement} element
     * @return {number}
     */
    getTop: function getTop(element) {
      var doc = element.ownerDocument;
      return _isViewportScrollElement(element, doc) ? (
        // In practice, they will either both have the same value,
        // or one will be zero and the other will be the scroll position
        // of the viewport. So we can use `X || Y` instead of `Math.max(X, Y)`
        doc.body.scrollTop || doc.documentElement.scrollTop
      ) : element.scrollTop;
    },
    /**
     * @param {DOMElement} element
     * @param {number} newTop
     */
    setTop: function setTop(element, newTop) {
      var doc = element.ownerDocument;
      if (_isViewportScrollElement(element, doc)) {
        doc.body.scrollTop = doc.documentElement.scrollTop = newTop;
      } else {
        element.scrollTop = newTop;
      }
    },
    /**
     * @param {DOMElement} element
     * @return {number}
     */
    getLeft: function getLeft(element) {
      var doc = element.ownerDocument;
      return _isViewportScrollElement(element, doc) ? doc.body.scrollLeft || doc.documentElement.scrollLeft : element.scrollLeft;
    },
    /**
     * @param {DOMElement} element
     * @param {number} newLeft
     */
    setLeft: function setLeft(element, newLeft) {
      var doc = element.ownerDocument;
      if (_isViewportScrollElement(element, doc)) {
        doc.body.scrollLeft = doc.documentElement.scrollLeft = newLeft;
      } else {
        element.scrollLeft = newLeft;
      }
    }
  };
  Scroll_1 = Scroll;
  return Scroll_1;
}
var camelize_1;
var hasRequiredCamelize;
function requireCamelize() {
  if (hasRequiredCamelize) return camelize_1;
  hasRequiredCamelize = 1;
  var _hyphenPattern = /-(.)/g;
  function camelize(string2) {
    return string2.replace(_hyphenPattern, function(_23, character) {
      return character.toUpperCase();
    });
  }
  camelize_1 = camelize;
  return camelize_1;
}
var hyphenate_1;
var hasRequiredHyphenate;
function requireHyphenate() {
  if (hasRequiredHyphenate) return hyphenate_1;
  hasRequiredHyphenate = 1;
  var _uppercasePattern = /([A-Z])/g;
  function hyphenate(string2) {
    return string2.replace(_uppercasePattern, "-$1").toLowerCase();
  }
  hyphenate_1 = hyphenate;
  return hyphenate_1;
}
var getStyleProperty_1;
var hasRequiredGetStyleProperty;
function requireGetStyleProperty() {
  if (hasRequiredGetStyleProperty) return getStyleProperty_1;
  hasRequiredGetStyleProperty = 1;
  var camelize = requireCamelize();
  var hyphenate = requireHyphenate();
  function asString(value) {
    return value == null ? value : String(value);
  }
  function getStyleProperty(node, name) {
    var computedStyle;
    if (window.getComputedStyle) {
      computedStyle = window.getComputedStyle(node, null);
      if (computedStyle) {
        return asString(computedStyle.getPropertyValue(hyphenate(name)));
      }
    }
    if (document.defaultView && document.defaultView.getComputedStyle) {
      computedStyle = document.defaultView.getComputedStyle(node, null);
      if (computedStyle) {
        return asString(computedStyle.getPropertyValue(hyphenate(name)));
      }
      if (name === "display") {
        return "none";
      }
    }
    if (node.currentStyle) {
      if (name === "float") {
        return asString(node.currentStyle.cssFloat || node.currentStyle.styleFloat);
      }
      return asString(node.currentStyle[camelize(name)]);
    }
    return asString(node.style && node.style[camelize(name)]);
  }
  getStyleProperty_1 = getStyleProperty;
  return getStyleProperty_1;
}
var Style_1;
var hasRequiredStyle;
function requireStyle() {
  if (hasRequiredStyle) return Style_1;
  hasRequiredStyle = 1;
  var getStyleProperty = requireGetStyleProperty();
  function _isNodeScrollable(element, name) {
    var overflow = Style.get(element, name);
    return overflow === "auto" || overflow === "scroll";
  }
  var Style = {
    /**
     * Gets the style property for the supplied node. This will return either the
     * computed style, if available, or the declared style.
     *
     * @param {DOMNode} node
     * @param {string} name Style property name.
     * @return {?string} Style property value.
     */
    get: getStyleProperty,
    /**
     * Determines the nearest ancestor of a node that is scrollable.
     *
     * NOTE: This can be expensive if used repeatedly or on a node nested deeply.
     *
     * @param {?DOMNode} node Node from which to start searching.
     * @return {?DOMWindow|DOMElement} Scroll parent of the supplied node.
     */
    getScrollParent: function getScrollParent(node) {
      if (!node) {
        return null;
      }
      var ownerDocument = node.ownerDocument;
      while (node && node !== ownerDocument.body) {
        if (_isNodeScrollable(node, "overflow") || _isNodeScrollable(node, "overflowY") || _isNodeScrollable(node, "overflowX")) {
          return node;
        }
        node = node.parentNode;
      }
      return ownerDocument.defaultView || ownerDocument.parentWindow;
    }
  };
  Style_1 = Style;
  return Style_1;
}
var getElementRect_1;
var hasRequiredGetElementRect;
function requireGetElementRect() {
  if (hasRequiredGetElementRect) return getElementRect_1;
  hasRequiredGetElementRect = 1;
  var containsNode = requireContainsNode();
  function getElementRect(elem) {
    var docElem = elem.ownerDocument.documentElement;
    if (!("getBoundingClientRect" in elem) || !containsNode(docElem, elem)) {
      return {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
    }
    var rect = elem.getBoundingClientRect();
    return {
      left: Math.round(rect.left) - docElem.clientLeft,
      right: Math.round(rect.right) - docElem.clientLeft,
      top: Math.round(rect.top) - docElem.clientTop,
      bottom: Math.round(rect.bottom) - docElem.clientTop
    };
  }
  getElementRect_1 = getElementRect;
  return getElementRect_1;
}
var getElementPosition_1;
var hasRequiredGetElementPosition;
function requireGetElementPosition() {
  if (hasRequiredGetElementPosition) return getElementPosition_1;
  hasRequiredGetElementPosition = 1;
  var getElementRect = requireGetElementRect();
  function getElementPosition(element) {
    var rect = getElementRect(element);
    return {
      x: rect.left,
      y: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
  }
  getElementPosition_1 = getElementPosition;
  return getElementPosition_1;
}
var getDocumentScrollElement_1;
var hasRequiredGetDocumentScrollElement;
function requireGetDocumentScrollElement() {
  if (hasRequiredGetDocumentScrollElement) return getDocumentScrollElement_1;
  hasRequiredGetDocumentScrollElement = 1;
  var isWebkit = typeof navigator !== "undefined" && navigator.userAgent.indexOf("AppleWebKit") > -1;
  function getDocumentScrollElement(doc) {
    doc = doc || document;
    if (doc.scrollingElement) {
      return doc.scrollingElement;
    }
    return !isWebkit && doc.compatMode === "CSS1Compat" ? doc.documentElement : doc.body;
  }
  getDocumentScrollElement_1 = getDocumentScrollElement;
  return getDocumentScrollElement_1;
}
var getUnboundedScrollPosition_1;
var hasRequiredGetUnboundedScrollPosition;
function requireGetUnboundedScrollPosition() {
  if (hasRequiredGetUnboundedScrollPosition) return getUnboundedScrollPosition_1;
  hasRequiredGetUnboundedScrollPosition = 1;
  function getUnboundedScrollPosition(scrollable) {
    if (scrollable.Window && scrollable instanceof scrollable.Window) {
      return {
        x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
        y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
      };
    }
    return {
      x: scrollable.scrollLeft,
      y: scrollable.scrollTop
    };
  }
  getUnboundedScrollPosition_1 = getUnboundedScrollPosition;
  return getUnboundedScrollPosition_1;
}
var getScrollPosition_1;
var hasRequiredGetScrollPosition;
function requireGetScrollPosition() {
  if (hasRequiredGetScrollPosition) return getScrollPosition_1;
  hasRequiredGetScrollPosition = 1;
  var getDocumentScrollElement = requireGetDocumentScrollElement();
  var getUnboundedScrollPosition = requireGetUnboundedScrollPosition();
  function getScrollPosition2(scrollable) {
    var documentScrollElement = getDocumentScrollElement(scrollable.ownerDocument || scrollable.document);
    if (scrollable.Window && scrollable instanceof scrollable.Window) {
      scrollable = documentScrollElement;
    }
    var scrollPosition = getUnboundedScrollPosition(scrollable);
    var viewport = scrollable === documentScrollElement ? scrollable.ownerDocument.documentElement : scrollable;
    var xMax = scrollable.scrollWidth - viewport.clientWidth;
    var yMax = scrollable.scrollHeight - viewport.clientHeight;
    scrollPosition.x = Math.max(0, Math.min(scrollPosition.x, xMax));
    scrollPosition.y = Math.max(0, Math.min(scrollPosition.y, yMax));
    return scrollPosition;
  }
  getScrollPosition_1 = getScrollPosition2;
  return getScrollPosition_1;
}
var getViewportDimensions_1;
var hasRequiredGetViewportDimensions;
function requireGetViewportDimensions() {
  if (hasRequiredGetViewportDimensions) return getViewportDimensions_1;
  hasRequiredGetViewportDimensions = 1;
  function getViewportWidth() {
    var width;
    if (document.documentElement) {
      width = document.documentElement.clientWidth;
    }
    if (!width && document.body) {
      width = document.body.clientWidth;
    }
    return width || 0;
  }
  function getViewportHeight() {
    var height;
    if (document.documentElement) {
      height = document.documentElement.clientHeight;
    }
    if (!height && document.body) {
      height = document.body.clientHeight;
    }
    return height || 0;
  }
  function getViewportDimensions() {
    return {
      width: window.innerWidth || getViewportWidth(),
      height: window.innerHeight || getViewportHeight()
    };
  }
  getViewportDimensions.withoutScrollbars = function() {
    return {
      width: getViewportWidth(),
      height: getViewportHeight()
    };
  };
  getViewportDimensions_1 = getViewportDimensions;
  return getViewportDimensions_1;
}
var DraftEditorBlockNode_react;
var hasRequiredDraftEditorBlockNode_react;
function requireDraftEditorBlockNode_react() {
  if (hasRequiredDraftEditorBlockNode_react) return DraftEditorBlockNode_react;
  hasRequiredDraftEditorBlockNode_react = 1;
  var _assign = requireObjectAssign();
  function _extends2() {
    _extends2 = _assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _assertThisInitialized2(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var DraftEditorNode = requireDraftEditorNode_react();
  var DraftOffsetKey = requireDraftOffsetKey();
  var React2 = requireReact();
  var Scroll = requireScroll();
  var Style = requireStyle();
  var getElementPosition = requireGetElementPosition();
  var getScrollPosition2 = requireGetScrollPosition();
  var getViewportDimensions = requireGetViewportDimensions();
  var Immutable2 = requireImmutable();
  var invariant2 = requireInvariant();
  var isHTMLElement2 = requireIsHTMLElement();
  var SCROLL_BUFFER = 10;
  Immutable2.List;
  var isBlockOnSelectionEdge = function isBlockOnSelectionEdge2(selection, key) {
    return selection.getAnchorKey() === key || selection.getFocusKey() === key;
  };
  var shouldNotAddWrapperElement = function shouldNotAddWrapperElement2(block, contentState) {
    var nextSiblingKey = block.getNextSiblingKey();
    return nextSiblingKey ? contentState.getBlockForKey(nextSiblingKey).getType() === block.getType() : false;
  };
  var applyWrapperElementToSiblings = function applyWrapperElementToSiblings2(wrapperTemplate, Element, nodes) {
    var wrappedSiblings = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = nodes.reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var sibling = _step.value;
        if (sibling.type !== Element) {
          break;
        }
        wrappedSiblings.push(sibling);
      }
    } catch (err2) {
      _didIteratorError = true;
      _iteratorError = err2;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    nodes.splice(nodes.indexOf(wrappedSiblings[0]), wrappedSiblings.length + 1);
    var childrenIs = wrappedSiblings.reverse();
    var key = childrenIs[0].key;
    nodes.push(React2.cloneElement(wrapperTemplate, {
      key: "".concat(key, "-wrap"),
      "data-offset-key": DraftOffsetKey.encode(key, 0, 0)
    }, childrenIs));
    return nodes;
  };
  var getDraftRenderConfig = function getDraftRenderConfig2(block, blockRenderMap) {
    var configForType = blockRenderMap.get(block.getType()) || blockRenderMap.get("unstyled");
    var wrapperTemplate = configForType.wrapper;
    var Element = configForType.element || blockRenderMap.get("unstyled").element;
    return {
      Element,
      wrapperTemplate
    };
  };
  var getCustomRenderConfig = function getCustomRenderConfig2(block, blockRendererFn) {
    var customRenderer = blockRendererFn(block);
    if (!customRenderer) {
      return {};
    }
    var CustomComponent = customRenderer.component, customProps = customRenderer.props, customEditable = customRenderer.editable;
    return {
      CustomComponent,
      customProps,
      customEditable
    };
  };
  var getElementPropsConfig = function getElementPropsConfig2(block, editorKey, offsetKey, blockStyleFn, customConfig, ref) {
    var elementProps = {
      "data-block": true,
      "data-editor": editorKey,
      "data-offset-key": offsetKey,
      key: block.getKey(),
      ref
    };
    var customClass = blockStyleFn(block);
    if (customClass) {
      elementProps.className = customClass;
    }
    if (customConfig.customEditable !== void 0) {
      elementProps = _objectSpread3({}, elementProps, {
        contentEditable: customConfig.customEditable,
        suppressContentEditableWarning: true
      });
    }
    return elementProps;
  };
  var DraftEditorBlockNode = /* @__PURE__ */ (function(_React$Component) {
    _inheritsLoose2(DraftEditorBlockNode2, _React$Component);
    function DraftEditorBlockNode2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _defineProperty2(_assertThisInitialized2(_this), "wrapperRef", React2.createRef());
      return _this;
    }
    var _proto = DraftEditorBlockNode2.prototype;
    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var _this$props = this.props, block = _this$props.block, direction = _this$props.direction, tree = _this$props.tree;
      var isContainerNode = !block.getChildKeys().isEmpty();
      var blockHasChanged = block !== nextProps.block || tree !== nextProps.tree || direction !== nextProps.direction || isBlockOnSelectionEdge(nextProps.selection, nextProps.block.getKey()) && nextProps.forceSelection;
      return isContainerNode || blockHasChanged;
    };
    _proto.componentDidMount = function componentDidMount() {
      var selection = this.props.selection;
      var endKey = selection.getEndKey();
      if (!selection.getHasFocus() || endKey !== this.props.block.getKey()) {
        return;
      }
      var blockNode = this.wrapperRef.current;
      if (!blockNode) {
        return;
      }
      var scrollParent = Style.getScrollParent(blockNode);
      var scrollPosition = getScrollPosition2(scrollParent);
      var scrollDelta;
      if (scrollParent === window) {
        var nodePosition = getElementPosition(blockNode);
        var nodeBottom = nodePosition.y + nodePosition.height;
        var viewportHeight = getViewportDimensions().height;
        scrollDelta = nodeBottom - viewportHeight;
        if (scrollDelta > 0) {
          window.scrollTo(scrollPosition.x, scrollPosition.y + scrollDelta + SCROLL_BUFFER);
        }
      } else {
        !isHTMLElement2(blockNode) ? invariant2(false) : void 0;
        var htmlBlockNode = blockNode;
        var blockBottom = htmlBlockNode.offsetHeight + htmlBlockNode.offsetTop;
        var scrollBottom = scrollParent.offsetHeight + scrollPosition.y;
        scrollDelta = blockBottom - scrollBottom;
        if (scrollDelta > 0) {
          Scroll.setTop(scrollParent, Scroll.getTop(scrollParent) + scrollDelta + SCROLL_BUFFER);
        }
      }
    };
    _proto.render = function render3() {
      var _this2 = this;
      var _this$props2 = this.props, block = _this$props2.block, blockRenderMap = _this$props2.blockRenderMap, blockRendererFn = _this$props2.blockRendererFn, blockStyleFn = _this$props2.blockStyleFn, contentState = _this$props2.contentState, decorator = _this$props2.decorator, editorKey = _this$props2.editorKey, editorState = _this$props2.editorState, customStyleFn = _this$props2.customStyleFn, customStyleMap = _this$props2.customStyleMap, direction = _this$props2.direction, forceSelection = _this$props2.forceSelection, selection = _this$props2.selection, tree = _this$props2.tree;
      var children = null;
      if (block.children.size) {
        children = block.children.reduce(function(acc, key) {
          var offsetKey2 = DraftOffsetKey.encode(key, 0, 0);
          var child = contentState.getBlockForKey(key);
          var customConfig2 = getCustomRenderConfig(child, blockRendererFn);
          var Component2 = customConfig2.CustomComponent || DraftEditorBlockNode2;
          var _getDraftRenderConfig = getDraftRenderConfig(child, blockRenderMap), Element2 = _getDraftRenderConfig.Element, wrapperTemplate = _getDraftRenderConfig.wrapperTemplate;
          var elementProps2 = getElementPropsConfig(child, editorKey, offsetKey2, blockStyleFn, customConfig2, null);
          var childProps = _objectSpread3({}, _this2.props, {
            tree: editorState.getBlockTree(key),
            blockProps: customConfig2.customProps,
            offsetKey: offsetKey2,
            block: child
          });
          acc.push(React2.createElement(Element2, elementProps2, React2.createElement(Component2, childProps)));
          if (!wrapperTemplate || shouldNotAddWrapperElement(child, contentState)) {
            return acc;
          }
          applyWrapperElementToSiblings(wrapperTemplate, Element2, acc);
          return acc;
        }, []);
      }
      var blockKey = block.getKey();
      var offsetKey = DraftOffsetKey.encode(blockKey, 0, 0);
      var customConfig = getCustomRenderConfig(block, blockRendererFn);
      var Component = customConfig.CustomComponent;
      var blockNode = Component != null ? React2.createElement(Component, _extends2({}, this.props, {
        tree: editorState.getBlockTree(blockKey),
        blockProps: customConfig.customProps,
        offsetKey,
        block
      })) : React2.createElement(DraftEditorNode, {
        block,
        children,
        contentState,
        customStyleFn,
        customStyleMap,
        decorator,
        direction,
        forceSelection,
        hasSelection: isBlockOnSelectionEdge(selection, blockKey),
        selection,
        tree
      });
      if (block.getParentKey()) {
        return blockNode;
      }
      var _getDraftRenderConfig2 = getDraftRenderConfig(block, blockRenderMap), Element = _getDraftRenderConfig2.Element;
      var elementProps = getElementPropsConfig(block, editorKey, offsetKey, blockStyleFn, customConfig, this.wrapperRef);
      return React2.createElement(Element, elementProps, blockNode);
    };
    return DraftEditorBlockNode2;
  })(React2.Component);
  DraftEditorBlockNode_react = DraftEditorBlockNode;
  return DraftEditorBlockNode_react;
}
var DraftEditorContentsExperimental_react;
var hasRequiredDraftEditorContentsExperimental_react;
function requireDraftEditorContentsExperimental_react() {
  if (hasRequiredDraftEditorContentsExperimental_react) return DraftEditorContentsExperimental_react;
  hasRequiredDraftEditorContentsExperimental_react = 1;
  var _assign = requireObjectAssign();
  function _extends2() {
    _extends2 = _assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var DraftEditorBlockNode = requireDraftEditorBlockNode_react();
  var DraftOffsetKey = requireDraftOffsetKey();
  var React2 = requireReact();
  var nullthrows = requireNullthrows();
  var DraftEditorContentsExperimental = /* @__PURE__ */ (function(_React$Component) {
    _inheritsLoose2(DraftEditorContentsExperimental2, _React$Component);
    function DraftEditorContentsExperimental2() {
      return _React$Component.apply(this, arguments) || this;
    }
    var _proto = DraftEditorContentsExperimental2.prototype;
    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var prevEditorState = this.props.editorState;
      var nextEditorState = nextProps.editorState;
      var prevDirectionMap = prevEditorState.getDirectionMap();
      var nextDirectionMap = nextEditorState.getDirectionMap();
      if (prevDirectionMap !== nextDirectionMap) {
        return true;
      }
      var didHaveFocus = prevEditorState.getSelection().getHasFocus();
      var nowHasFocus = nextEditorState.getSelection().getHasFocus();
      if (didHaveFocus !== nowHasFocus) {
        return true;
      }
      var nextNativeContent = nextEditorState.getNativelyRenderedContent();
      var wasComposing = prevEditorState.isInCompositionMode();
      var nowComposing = nextEditorState.isInCompositionMode();
      if (prevEditorState === nextEditorState || nextNativeContent !== null && nextEditorState.getCurrentContent() === nextNativeContent || wasComposing && nowComposing) {
        return false;
      }
      var prevContent = prevEditorState.getCurrentContent();
      var nextContent = nextEditorState.getCurrentContent();
      var prevDecorator = prevEditorState.getDecorator();
      var nextDecorator = nextEditorState.getDecorator();
      return wasComposing !== nowComposing || prevContent !== nextContent || prevDecorator !== nextDecorator || nextEditorState.mustForceSelection();
    };
    _proto.render = function render3() {
      var _this$props = this.props, blockRenderMap = _this$props.blockRenderMap, blockRendererFn = _this$props.blockRendererFn, blockStyleFn = _this$props.blockStyleFn, customStyleMap = _this$props.customStyleMap, customStyleFn = _this$props.customStyleFn, editorState = _this$props.editorState, editorKey = _this$props.editorKey, textDirectionality = _this$props.textDirectionality;
      var content = editorState.getCurrentContent();
      var selection = editorState.getSelection();
      var forceSelection = editorState.mustForceSelection();
      var decorator = editorState.getDecorator();
      var directionMap = nullthrows(editorState.getDirectionMap());
      var blocksAsArray = content.getBlocksAsArray();
      var rootBlock = blocksAsArray[0];
      var processedBlocks = [];
      var nodeBlock = rootBlock;
      while (nodeBlock) {
        var blockKey = nodeBlock.getKey();
        var blockProps = {
          blockRenderMap,
          blockRendererFn,
          blockStyleFn,
          contentState: content,
          customStyleFn,
          customStyleMap,
          decorator,
          editorKey,
          editorState,
          forceSelection,
          selection,
          block: nodeBlock,
          direction: textDirectionality ? textDirectionality : directionMap.get(blockKey),
          tree: editorState.getBlockTree(blockKey)
        };
        var configForType = blockRenderMap.get(nodeBlock.getType()) || blockRenderMap.get("unstyled");
        var wrapperTemplate = configForType.wrapper;
        processedBlocks.push({
          /* $FlowFixMe[incompatible-type] (>=0.112.0 site=www,mobile) This
           * comment suppresses an error found when Flow v0.112 was deployed. To
           * see the error delete this comment and run Flow. */
          block: React2.createElement(DraftEditorBlockNode, _extends2({
            key: blockKey
          }, blockProps)),
          wrapperTemplate,
          key: blockKey,
          offsetKey: DraftOffsetKey.encode(blockKey, 0, 0)
        });
        var nextBlockKey = nodeBlock.getNextSiblingKey();
        nodeBlock = nextBlockKey ? content.getBlockForKey(nextBlockKey) : null;
      }
      var outputBlocks = [];
      for (var ii = 0; ii < processedBlocks.length; ) {
        var info = processedBlocks[ii];
        if (info.wrapperTemplate) {
          var blocks = [];
          do {
            blocks.push(processedBlocks[ii].block);
            ii++;
          } while (ii < processedBlocks.length && processedBlocks[ii].wrapperTemplate === info.wrapperTemplate);
          var wrapperElement = React2.cloneElement(info.wrapperTemplate, {
            key: info.key + "-wrap",
            "data-offset-key": info.offsetKey
          }, blocks);
          outputBlocks.push(wrapperElement);
        } else {
          outputBlocks.push(info.block);
          ii++;
        }
      }
      return React2.createElement("div", {
        "data-contents": "true"
      }, outputBlocks);
    };
    return DraftEditorContentsExperimental2;
  })(React2.Component);
  DraftEditorContentsExperimental_react = DraftEditorContentsExperimental;
  return DraftEditorContentsExperimental_react;
}
var DraftEditorBlock_react;
var hasRequiredDraftEditorBlock_react;
function requireDraftEditorBlock_react() {
  if (hasRequiredDraftEditorBlock_react) return DraftEditorBlock_react;
  hasRequiredDraftEditorBlock_react = 1;
  var _assign = requireObjectAssign();
  function _extends2() {
    _extends2 = _assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _assertThisInitialized2(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var DraftEditorLeaf = requireDraftEditorLeaf_react();
  var DraftOffsetKey = requireDraftOffsetKey();
  var React2 = requireReact();
  var Scroll = requireScroll();
  var Style = requireStyle();
  var UnicodeBidi = requireUnicodeBidi();
  var UnicodeBidiDirection = requireUnicodeBidiDirection();
  var cx = requireCx();
  var getElementPosition = requireGetElementPosition();
  var getScrollPosition2 = requireGetScrollPosition();
  var getViewportDimensions = requireGetViewportDimensions();
  var invariant2 = requireInvariant();
  var isHTMLElement2 = requireIsHTMLElement();
  var nullthrows = requireNullthrows();
  var SCROLL_BUFFER = 10;
  var isBlockOnSelectionEdge = function isBlockOnSelectionEdge2(selection, key) {
    return selection.getAnchorKey() === key || selection.getFocusKey() === key;
  };
  var DraftEditorBlock = /* @__PURE__ */ (function(_React$Component) {
    _inheritsLoose2(DraftEditorBlock2, _React$Component);
    function DraftEditorBlock2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _defineProperty2(_assertThisInitialized2(_this), "_node", void 0);
      return _this;
    }
    var _proto = DraftEditorBlock2.prototype;
    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      return this.props.block !== nextProps.block || this.props.tree !== nextProps.tree || this.props.direction !== nextProps.direction || isBlockOnSelectionEdge(nextProps.selection, nextProps.block.getKey()) && nextProps.forceSelection;
    };
    _proto.componentDidMount = function componentDidMount() {
      if (this.props.preventScroll) {
        return;
      }
      var selection = this.props.selection;
      var endKey = selection.getEndKey();
      if (!selection.getHasFocus() || endKey !== this.props.block.getKey()) {
        return;
      }
      var blockNode = this._node;
      if (blockNode == null) {
        return;
      }
      var scrollParent = Style.getScrollParent(blockNode);
      var scrollPosition = getScrollPosition2(scrollParent);
      var scrollDelta;
      if (scrollParent === window) {
        var nodePosition = getElementPosition(blockNode);
        var nodeBottom = nodePosition.y + nodePosition.height;
        var viewportHeight = getViewportDimensions().height;
        scrollDelta = nodeBottom - viewportHeight;
        if (scrollDelta > 0) {
          window.scrollTo(scrollPosition.x, scrollPosition.y + scrollDelta + SCROLL_BUFFER);
        }
      } else {
        !isHTMLElement2(blockNode) ? invariant2(false) : void 0;
        var blockBottom = blockNode.offsetHeight + blockNode.offsetTop;
        var pOffset = scrollParent.offsetTop + scrollParent.offsetHeight;
        var scrollBottom = pOffset + scrollPosition.y;
        scrollDelta = blockBottom - scrollBottom;
        if (scrollDelta > 0) {
          Scroll.setTop(scrollParent, Scroll.getTop(scrollParent) + scrollDelta + SCROLL_BUFFER);
        }
      }
    };
    _proto._renderChildren = function _renderChildren() {
      var _this2 = this;
      var block = this.props.block;
      var blockKey = block.getKey();
      var text = block.getText();
      var lastLeafSet = this.props.tree.size - 1;
      var hasSelection = isBlockOnSelectionEdge(this.props.selection, blockKey);
      return this.props.tree.map(function(leafSet, ii) {
        var leavesForLeafSet = leafSet.get("leaves");
        if (leavesForLeafSet.size === 0) {
          return null;
        }
        var lastLeaf = leavesForLeafSet.size - 1;
        var leaves = leavesForLeafSet.map(function(leaf, jj) {
          var offsetKey = DraftOffsetKey.encode(blockKey, ii, jj);
          var start2 = leaf.get("start");
          var end2 = leaf.get("end");
          return React2.createElement(DraftEditorLeaf, {
            key: offsetKey,
            offsetKey,
            block,
            start: start2,
            selection: hasSelection ? _this2.props.selection : null,
            forceSelection: _this2.props.forceSelection,
            text: text.slice(start2, end2),
            styleSet: block.getInlineStyleAt(start2),
            customStyleMap: _this2.props.customStyleMap,
            customStyleFn: _this2.props.customStyleFn,
            isLast: ii === lastLeafSet && jj === lastLeaf
          });
        }).toArray();
        var decoratorKey = leafSet.get("decoratorKey");
        if (decoratorKey == null) {
          return leaves;
        }
        if (!_this2.props.decorator) {
          return leaves;
        }
        var decorator = nullthrows(_this2.props.decorator);
        var DecoratorComponent = decorator.getComponentForKey(decoratorKey);
        if (!DecoratorComponent) {
          return leaves;
        }
        var decoratorProps = decorator.getPropsForKey(decoratorKey);
        var decoratorOffsetKey = DraftOffsetKey.encode(blockKey, ii, 0);
        var start = leavesForLeafSet.first().get("start");
        var end = leavesForLeafSet.last().get("end");
        var decoratedText = text.slice(start, end);
        var entityKey = block.getEntityAt(leafSet.get("start"));
        var dir = UnicodeBidiDirection.getHTMLDirIfDifferent(UnicodeBidi.getDirection(decoratedText), _this2.props.direction);
        var commonProps = {
          contentState: _this2.props.contentState,
          decoratedText,
          dir,
          start,
          end,
          blockKey,
          entityKey,
          offsetKey: decoratorOffsetKey
        };
        return React2.createElement(DecoratorComponent, _extends2({}, decoratorProps, commonProps, {
          key: decoratorOffsetKey
        }), leaves);
      }).toArray();
    };
    _proto.render = function render3() {
      var _this3 = this;
      var _this$props = this.props, direction = _this$props.direction, offsetKey = _this$props.offsetKey;
      var className = cx({
        "public/DraftStyleDefault/block": true,
        "public/DraftStyleDefault/ltr": direction === "LTR",
        "public/DraftStyleDefault/rtl": direction === "RTL"
      });
      return React2.createElement("div", {
        "data-offset-key": offsetKey,
        className,
        ref: function ref(_ref) {
          return _this3._node = _ref;
        }
      }, this._renderChildren());
    };
    return DraftEditorBlock2;
  })(React2.Component);
  DraftEditorBlock_react = DraftEditorBlock;
  return DraftEditorBlock_react;
}
var joinClasses_1;
var hasRequiredJoinClasses;
function requireJoinClasses() {
  if (hasRequiredJoinClasses) return joinClasses_1;
  hasRequiredJoinClasses = 1;
  function joinClasses(className) {
    var newClassName = className || "";
    var argLength = arguments.length;
    if (argLength > 1) {
      for (var index = 1; index < argLength; index++) {
        var nextClass = arguments[index];
        if (nextClass) {
          newClassName = (newClassName ? newClassName + " " : "") + nextClass;
        }
      }
    }
    return newClassName;
  }
  joinClasses_1 = joinClasses;
  return joinClasses_1;
}
var DraftEditorContentsCore_react;
var hasRequiredDraftEditorContentsCore_react;
function requireDraftEditorContentsCore_react() {
  if (hasRequiredDraftEditorContentsCore_react) return DraftEditorContentsCore_react;
  hasRequiredDraftEditorContentsCore_react = 1;
  var _assign = requireObjectAssign();
  function _extends2() {
    _extends2 = _assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var DraftEditorBlock = requireDraftEditorBlock_react();
  var DraftOffsetKey = requireDraftOffsetKey();
  var React2 = requireReact();
  var cx = requireCx();
  var joinClasses = requireJoinClasses();
  var nullthrows = requireNullthrows();
  var getListItemClasses = function getListItemClasses2(type, depth, shouldResetCount, direction) {
    return cx({
      "public/DraftStyleDefault/unorderedListItem": type === "unordered-list-item",
      "public/DraftStyleDefault/orderedListItem": type === "ordered-list-item",
      "public/DraftStyleDefault/reset": shouldResetCount,
      "public/DraftStyleDefault/depth0": depth === 0,
      "public/DraftStyleDefault/depth1": depth === 1,
      "public/DraftStyleDefault/depth2": depth === 2,
      "public/DraftStyleDefault/depth3": depth === 3,
      "public/DraftStyleDefault/depth4": depth >= 4,
      "public/DraftStyleDefault/listLTR": direction === "LTR",
      "public/DraftStyleDefault/listRTL": direction === "RTL"
    });
  };
  var DraftEditorContents = /* @__PURE__ */ (function(_React$Component) {
    _inheritsLoose2(DraftEditorContents2, _React$Component);
    function DraftEditorContents2() {
      return _React$Component.apply(this, arguments) || this;
    }
    var _proto = DraftEditorContents2.prototype;
    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var prevEditorState = this.props.editorState;
      var nextEditorState = nextProps.editorState;
      var prevDirectionMap = prevEditorState.getDirectionMap();
      var nextDirectionMap = nextEditorState.getDirectionMap();
      if (prevDirectionMap !== nextDirectionMap) {
        return true;
      }
      var didHaveFocus = prevEditorState.getSelection().getHasFocus();
      var nowHasFocus = nextEditorState.getSelection().getHasFocus();
      if (didHaveFocus !== nowHasFocus) {
        return true;
      }
      var nextNativeContent = nextEditorState.getNativelyRenderedContent();
      var wasComposing = prevEditorState.isInCompositionMode();
      var nowComposing = nextEditorState.isInCompositionMode();
      if (prevEditorState === nextEditorState || nextNativeContent !== null && nextEditorState.getCurrentContent() === nextNativeContent || wasComposing && nowComposing) {
        return false;
      }
      var prevContent = prevEditorState.getCurrentContent();
      var nextContent = nextEditorState.getCurrentContent();
      var prevDecorator = prevEditorState.getDecorator();
      var nextDecorator = nextEditorState.getDecorator();
      return wasComposing !== nowComposing || prevContent !== nextContent || prevDecorator !== nextDecorator || nextEditorState.mustForceSelection();
    };
    _proto.render = function render3() {
      var _this$props = this.props, blockRenderMap = _this$props.blockRenderMap, blockRendererFn = _this$props.blockRendererFn, blockStyleFn = _this$props.blockStyleFn, customStyleMap = _this$props.customStyleMap, customStyleFn = _this$props.customStyleFn, editorState = _this$props.editorState, editorKey = _this$props.editorKey, preventScroll = _this$props.preventScroll, textDirectionality = _this$props.textDirectionality;
      var content = editorState.getCurrentContent();
      var selection = editorState.getSelection();
      var forceSelection = editorState.mustForceSelection();
      var decorator = editorState.getDecorator();
      var directionMap = nullthrows(editorState.getDirectionMap());
      var blocksAsArray = content.getBlocksAsArray();
      var processedBlocks = [];
      var currentDepth = null;
      var lastWrapperTemplate = null;
      for (var ii = 0; ii < blocksAsArray.length; ii++) {
        var _block = blocksAsArray[ii];
        var key = _block.getKey();
        var blockType = _block.getType();
        var customRenderer = blockRendererFn(_block);
        var CustomComponent = void 0, customProps = void 0, customEditable = void 0;
        if (customRenderer) {
          CustomComponent = customRenderer.component;
          customProps = customRenderer.props;
          customEditable = customRenderer.editable;
        }
        var direction = textDirectionality ? textDirectionality : directionMap.get(key);
        var offsetKey = DraftOffsetKey.encode(key, 0, 0);
        var componentProps = {
          contentState: content,
          block: _block,
          blockProps: customProps,
          blockStyleFn,
          customStyleMap,
          customStyleFn,
          decorator,
          direction,
          forceSelection,
          offsetKey,
          preventScroll,
          selection,
          tree: editorState.getBlockTree(key)
        };
        var configForType = blockRenderMap.get(blockType) || blockRenderMap.get("unstyled");
        var wrapperTemplate = configForType.wrapper;
        var Element = configForType.element || blockRenderMap.get("unstyled").element;
        var depth = _block.getDepth();
        var _className = "";
        if (blockStyleFn) {
          _className = blockStyleFn(_block);
        }
        if (Element === "li") {
          var shouldResetCount = lastWrapperTemplate !== wrapperTemplate || currentDepth === null || depth > currentDepth;
          _className = joinClasses(_className, getListItemClasses(blockType, depth, shouldResetCount, direction));
        }
        var Component = CustomComponent || DraftEditorBlock;
        var childProps = {
          className: _className,
          "data-block": true,
          "data-editor": editorKey,
          "data-offset-key": offsetKey,
          key
        };
        if (customEditable !== void 0) {
          childProps = _objectSpread3({}, childProps, {
            contentEditable: customEditable,
            suppressContentEditableWarning: true
          });
        }
        var child = React2.createElement(
          Element,
          childProps,
          /* $FlowFixMe[incompatible-type] (>=0.112.0 site=www,mobile) This
           * comment suppresses an error found when Flow v0.112 was deployed. To
           * see the error delete this comment and run Flow. */
          React2.createElement(Component, _extends2({}, componentProps, {
            key
          }))
        );
        processedBlocks.push({
          block: child,
          wrapperTemplate,
          key,
          offsetKey
        });
        if (wrapperTemplate) {
          currentDepth = _block.getDepth();
        } else {
          currentDepth = null;
        }
        lastWrapperTemplate = wrapperTemplate;
      }
      var outputBlocks = [];
      for (var _ii = 0; _ii < processedBlocks.length; ) {
        var info = processedBlocks[_ii];
        if (info.wrapperTemplate) {
          var blocks = [];
          do {
            blocks.push(processedBlocks[_ii].block);
            _ii++;
          } while (_ii < processedBlocks.length && processedBlocks[_ii].wrapperTemplate === info.wrapperTemplate);
          var wrapperElement = React2.cloneElement(info.wrapperTemplate, {
            key: info.key + "-wrap",
            "data-offset-key": info.offsetKey
          }, blocks);
          outputBlocks.push(wrapperElement);
        } else {
          outputBlocks.push(info.block);
          _ii++;
        }
      }
      return React2.createElement("div", {
        "data-contents": "true"
      }, outputBlocks);
    };
    return DraftEditorContents2;
  })(React2.Component);
  DraftEditorContentsCore_react = DraftEditorContents;
  return DraftEditorContentsCore_react;
}
var DraftEditorContents_react;
var hasRequiredDraftEditorContents_react;
function requireDraftEditorContents_react() {
  if (hasRequiredDraftEditorContents_react) return DraftEditorContents_react;
  hasRequiredDraftEditorContents_react = 1;
  var gkx2 = requireGkx();
  var experimentalTreeDataSupport = gkx2("draft_tree_data_support");
  DraftEditorContents_react = experimentalTreeDataSupport ? requireDraftEditorContentsExperimental_react() : requireDraftEditorContentsCore_react();
  return DraftEditorContents_react;
}
var PhotosMimeType_1;
var hasRequiredPhotosMimeType;
function requirePhotosMimeType() {
  if (hasRequiredPhotosMimeType) return PhotosMimeType_1;
  hasRequiredPhotosMimeType = 1;
  var PhotosMimeType = {
    isImage: function isImage(mimeString) {
      return getParts(mimeString)[0] === "image";
    },
    isJpeg: function isJpeg(mimeString) {
      var parts = getParts(mimeString);
      return PhotosMimeType.isImage(mimeString) && // see http://fburl.com/10972194
      (parts[1] === "jpeg" || parts[1] === "pjpeg");
    }
  };
  function getParts(mimeString) {
    return mimeString.split("/");
  }
  PhotosMimeType_1 = PhotosMimeType;
  return PhotosMimeType_1;
}
var createArrayFromMixed_1;
var hasRequiredCreateArrayFromMixed;
function requireCreateArrayFromMixed() {
  if (hasRequiredCreateArrayFromMixed) return createArrayFromMixed_1;
  hasRequiredCreateArrayFromMixed = 1;
  var invariant2 = requireInvariant();
  function toArray3(obj) {
    var length = obj.length;
    !(!Array.isArray(obj) && (typeof obj === "object" || typeof obj === "function")) ? invariant2(false) : void 0;
    !(typeof length === "number") ? invariant2(false) : void 0;
    !(length === 0 || length - 1 in obj) ? invariant2(false) : void 0;
    !(typeof obj.callee !== "function") ? invariant2(false) : void 0;
    if (obj.hasOwnProperty) {
      try {
        return Array.prototype.slice.call(obj);
      } catch (e2) {
      }
    }
    var ret = Array(length);
    for (var ii = 0; ii < length; ii++) {
      ret[ii] = obj[ii];
    }
    return ret;
  }
  function hasArrayNature(obj) {
    return (
      // not null/false
      !!obj && // arrays are objects, NodeLists are functions in Safari
      (typeof obj == "object" || typeof obj == "function") && // quacks like an array
      "length" in obj && // not window
      !("setInterval" in obj) && // no DOM node should be considered an array-like
      // a 'select' element has 'length' and 'item' properties on IE8
      typeof obj.nodeType != "number" && // a real array
      (Array.isArray(obj) || // arguments
      "callee" in obj || // HTMLCollection/NodeList
      "item" in obj)
    );
  }
  function createArrayFromMixed(obj) {
    if (!hasArrayNature(obj)) {
      return [obj];
    } else if (Array.isArray(obj)) {
      return obj.slice();
    } else {
      return toArray3(obj);
    }
  }
  createArrayFromMixed_1 = createArrayFromMixed;
  return createArrayFromMixed_1;
}
var emptyFunction_1;
var hasRequiredEmptyFunction;
function requireEmptyFunction() {
  if (hasRequiredEmptyFunction) return emptyFunction_1;
  hasRequiredEmptyFunction = 1;
  function makeEmptyFunction(arg) {
    return function() {
      return arg;
    };
  }
  var emptyFunction = function emptyFunction2() {
  };
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function() {
    return this;
  };
  emptyFunction.thatReturnsArgument = function(arg) {
    return arg;
  };
  emptyFunction_1 = emptyFunction;
  return emptyFunction_1;
}
var DataTransfer_1;
var hasRequiredDataTransfer;
function requireDataTransfer() {
  if (hasRequiredDataTransfer) return DataTransfer_1;
  hasRequiredDataTransfer = 1;
  var PhotosMimeType = requirePhotosMimeType();
  var createArrayFromMixed = requireCreateArrayFromMixed();
  var emptyFunction = requireEmptyFunction();
  var CR_LF_REGEX = new RegExp("\r\n", "g");
  var LF_ONLY = "\n";
  var RICH_TEXT_TYPES = {
    "text/rtf": 1,
    "text/html": 1
  };
  function getFileFromDataTransfer(item) {
    if (item.kind == "file") {
      return item.getAsFile();
    }
  }
  var DataTransfer = /* @__PURE__ */ (function() {
    function DataTransfer2(data) {
      this.data = data;
      this.types = data.types ? createArrayFromMixed(data.types) : [];
    }
    var _proto = DataTransfer2.prototype;
    _proto.isRichText = function isRichText() {
      if (this.getHTML() && this.getText()) {
        return true;
      }
      if (this.isImage()) {
        return false;
      }
      return this.types.some(function(type) {
        return RICH_TEXT_TYPES[type];
      });
    };
    _proto.getText = function getText() {
      var text;
      if (this.data.getData) {
        if (!this.types.length) {
          text = this.data.getData("Text");
        } else if (this.types.indexOf("text/plain") != -1) {
          text = this.data.getData("text/plain");
        }
      }
      return text ? text.replace(CR_LF_REGEX, LF_ONLY) : null;
    };
    _proto.getHTML = function getHTML() {
      if (this.data.getData) {
        if (!this.types.length) {
          return this.data.getData("Text");
        } else if (this.types.indexOf("text/html") != -1) {
          return this.data.getData("text/html");
        }
      }
    };
    _proto.isLink = function isLink() {
      return this.types.some(function(type) {
        return type.indexOf("Url") != -1 || type.indexOf("text/uri-list") != -1 || type.indexOf("text/x-moz-url");
      });
    };
    _proto.getLink = function getLink() {
      if (this.data.getData) {
        if (this.types.indexOf("text/x-moz-url") != -1) {
          var url = this.data.getData("text/x-moz-url").split("\n");
          return url[0];
        }
        return this.types.indexOf("text/uri-list") != -1 ? this.data.getData("text/uri-list") : this.data.getData("url");
      }
      return null;
    };
    _proto.isImage = function isImage() {
      var isImage2 = this.types.some(function(type2) {
        return type2.indexOf("application/x-moz-file") != -1;
      });
      if (isImage2) {
        return true;
      }
      var items = this.getFiles();
      for (var i2 = 0; i2 < items.length; i2++) {
        var type = items[i2].type;
        if (!PhotosMimeType.isImage(type)) {
          return false;
        }
      }
      return true;
    };
    _proto.getCount = function getCount() {
      if (this.data.hasOwnProperty("items")) {
        return this.data.items.length;
      } else if (this.data.hasOwnProperty("mozItemCount")) {
        return this.data.mozItemCount;
      } else if (this.data.files) {
        return this.data.files.length;
      }
      return null;
    };
    _proto.getFiles = function getFiles() {
      if (this.data.items) {
        return Array.prototype.slice.call(this.data.items).map(getFileFromDataTransfer).filter(emptyFunction.thatReturnsArgument);
      } else if (this.data.files) {
        return Array.prototype.slice.call(this.data.files);
      } else {
        return [];
      }
    };
    _proto.hasFiles = function hasFiles() {
      return this.getFiles().length > 0;
    };
    return DataTransfer2;
  })();
  DataTransfer_1 = DataTransfer;
  return DataTransfer_1;
}
var getTextContentFromFiles_1;
var hasRequiredGetTextContentFromFiles;
function requireGetTextContentFromFiles() {
  if (hasRequiredGetTextContentFromFiles) return getTextContentFromFiles_1;
  hasRequiredGetTextContentFromFiles = 1;
  var invariant2 = requireInvariant();
  var TEXT_CLIPPING_REGEX = /\.textClipping$/;
  var TEXT_TYPES = {
    "text/plain": true,
    "text/html": true,
    "text/rtf": true
  };
  var TEXT_SIZE_UPPER_BOUND = 5e3;
  function getTextContentFromFiles(files, callback) {
    var readCount = 0;
    var results = [];
    files.forEach(function(file) {
      readFile(file, function(text) {
        readCount++;
        text && results.push(text.slice(0, TEXT_SIZE_UPPER_BOUND));
        if (readCount == files.length) {
          callback(results.join("\r"));
        }
      });
    });
  }
  function readFile(file, callback) {
    if (!globalThis.FileReader || file.type && !(file.type in TEXT_TYPES)) {
      callback("");
      return;
    }
    if (file.type === "") {
      var _contents = "";
      if (TEXT_CLIPPING_REGEX.test(file.name)) {
        _contents = file.name.replace(TEXT_CLIPPING_REGEX, "");
      }
      callback(_contents);
      return;
    }
    var reader = new FileReader();
    reader.onload = function() {
      var result = reader.result;
      !(typeof result === "string") ? invariant2(false) : void 0;
      callback(result);
    };
    reader.onerror = function() {
      callback("");
    };
    reader.readAsText(file);
  }
  getTextContentFromFiles_1 = getTextContentFromFiles;
  return getTextContentFromFiles_1;
}
var isEventHandled_1;
var hasRequiredIsEventHandled;
function requireIsEventHandled() {
  if (hasRequiredIsEventHandled) return isEventHandled_1;
  hasRequiredIsEventHandled = 1;
  function isEventHandled(value) {
    return value === "handled" || value === true;
  }
  isEventHandled_1 = isEventHandled;
  return isEventHandled_1;
}
var DraftEditorDragHandler_1;
var hasRequiredDraftEditorDragHandler;
function requireDraftEditorDragHandler() {
  if (hasRequiredDraftEditorDragHandler) return DraftEditorDragHandler_1;
  hasRequiredDraftEditorDragHandler = 1;
  var DataTransfer = requireDataTransfer();
  var DraftModifier = requireDraftModifier();
  var EditorState = requireEditorState();
  var findAncestorOffsetKey = requireFindAncestorOffsetKey();
  var getCorrectDocumentFromNode = requireGetCorrectDocumentFromNode();
  var getTextContentFromFiles = requireGetTextContentFromFiles();
  var getUpdatedSelectionState = requireGetUpdatedSelectionState();
  var getWindowForNode = requireGetWindowForNode();
  var isEventHandled = requireIsEventHandled();
  var nullthrows = requireNullthrows();
  function getSelectionForEvent(event2, editorState) {
    var node = null;
    var offset = null;
    var eventTargetDocument = getCorrectDocumentFromNode(event2.currentTarget);
    if (typeof eventTargetDocument.caretRangeFromPoint === "function") {
      var dropRange = eventTargetDocument.caretRangeFromPoint(event2.x, event2.y);
      node = dropRange.startContainer;
      offset = dropRange.startOffset;
    } else if (event2.rangeParent) {
      node = event2.rangeParent;
      offset = event2.rangeOffset;
    } else {
      return null;
    }
    node = nullthrows(node);
    offset = nullthrows(offset);
    var offsetKey = nullthrows(findAncestorOffsetKey(node));
    return getUpdatedSelectionState(editorState, offsetKey, offset, offsetKey, offset);
  }
  var DraftEditorDragHandler = {
    /**
     * Drag originating from input terminated.
     */
    onDragEnd: function onDragEnd(editor) {
      editor.exitCurrentMode();
      endDrag(editor);
    },
    /**
     * Handle data being dropped.
     */
    onDrop: function onDrop(editor, e2) {
      var data = new DataTransfer(e2.nativeEvent.dataTransfer);
      var editorState = editor._latestEditorState;
      var dropSelection = getSelectionForEvent(e2.nativeEvent, editorState);
      e2.preventDefault();
      editor._dragCount = 0;
      editor.exitCurrentMode();
      if (dropSelection == null) {
        return;
      }
      var files = data.getFiles();
      if (files.length > 0) {
        if (editor.props.handleDroppedFiles && isEventHandled(editor.props.handleDroppedFiles(dropSelection, files))) {
          return;
        }
        getTextContentFromFiles(files, function(fileText) {
          fileText && editor.update(insertTextAtSelection(editorState, dropSelection, fileText));
        });
        return;
      }
      var dragType = editor._internalDrag ? "internal" : "external";
      if (editor.props.handleDrop && isEventHandled(editor.props.handleDrop(dropSelection, data, dragType))) ;
      else if (editor._internalDrag) {
        editor.update(moveText(editorState, dropSelection));
      } else {
        editor.update(insertTextAtSelection(editorState, dropSelection, data.getText()));
      }
      endDrag(editor);
    }
  };
  function endDrag(editor) {
    editor._internalDrag = false;
    var editorNode = editor.editorContainer;
    if (editorNode) {
      var mouseUpEvent = new MouseEvent("mouseup", {
        view: getWindowForNode(editorNode),
        bubbles: true,
        cancelable: true
      });
      editorNode.dispatchEvent(mouseUpEvent);
    }
  }
  function moveText(editorState, targetSelection) {
    var newContentState = DraftModifier.moveText(editorState.getCurrentContent(), editorState.getSelection(), targetSelection);
    return EditorState.push(editorState, newContentState, "insert-fragment");
  }
  function insertTextAtSelection(editorState, selection, text) {
    var newContentState = DraftModifier.insertText(editorState.getCurrentContent(), selection, text, editorState.getCurrentInlineStyle());
    return EditorState.push(editorState, newContentState, "insert-fragment");
  }
  DraftEditorDragHandler_1 = DraftEditorDragHandler;
  return DraftEditorDragHandler_1;
}
var isSelectionAtLeafStart_1;
var hasRequiredIsSelectionAtLeafStart;
function requireIsSelectionAtLeafStart() {
  if (hasRequiredIsSelectionAtLeafStart) return isSelectionAtLeafStart_1;
  hasRequiredIsSelectionAtLeafStart = 1;
  function isSelectionAtLeafStart(editorState) {
    var selection = editorState.getSelection();
    var anchorKey = selection.getAnchorKey();
    var blockTree = editorState.getBlockTree(anchorKey);
    var offset = selection.getStartOffset();
    var isAtStart = false;
    blockTree.some(function(leafSet) {
      if (offset === leafSet.get("start")) {
        isAtStart = true;
        return true;
      }
      if (offset < leafSet.get("end")) {
        return leafSet.get("leaves").some(function(leaf) {
          var leafStart = leaf.get("start");
          if (offset === leafStart) {
            isAtStart = true;
            return true;
          }
          return false;
        });
      }
      return false;
    });
    return isAtStart;
  }
  isSelectionAtLeafStart_1 = isSelectionAtLeafStart;
  return isSelectionAtLeafStart_1;
}
var setImmediate$2 = {};
var hasRequiredSetImmediate$1;
function requireSetImmediate$1() {
  if (hasRequiredSetImmediate$1) return setImmediate$2;
  hasRequiredSetImmediate$1 = 1;
  (function(global2, undefined$1) {
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2 + 1];
      }
      var task = { callback, args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle2) {
      delete tasksByHandle[handle2];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined$1, args);
          break;
      }
    }
    function runIfPresent(handle2) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle2);
      } else {
        var task = tasksByHandle[handle2];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate(handle2);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle2) {
        process.nextTick(function() {
          runIfPresent(handle2);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event2) {
        if (event2.source === global2 && typeof event2.data === "string" && event2.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event2.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle2) {
        global2.postMessage(messagePrefix + handle2, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel();
      channel.port1.onmessage = function(event2) {
        var handle2 = event2.data;
        runIfPresent(handle2);
      };
      registerImmediate = function(handle2) {
        channel.port2.postMessage(handle2);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;
      registerImmediate = function(handle2) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle2);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle2) {
        setTimeout(runIfPresent, 0, handle2);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof globalThis === "undefined" ? setImmediate$2 : globalThis : self);
  return setImmediate$2;
}
var setImmediate$1;
var hasRequiredSetImmediate;
function requireSetImmediate() {
  if (hasRequiredSetImmediate) return setImmediate$1;
  hasRequiredSetImmediate = 1;
  requireSetImmediate$1();
  setImmediate$1 = globalThis.setImmediate;
  return setImmediate$1;
}
var editOnBeforeInput_1;
var hasRequiredEditOnBeforeInput;
function requireEditOnBeforeInput() {
  if (hasRequiredEditOnBeforeInput) return editOnBeforeInput_1;
  hasRequiredEditOnBeforeInput = 1;
  var DraftModifier = requireDraftModifier();
  var EditorState = requireEditorState();
  var UserAgent = requireUserAgent();
  var getEntityKeyForSelection = requireGetEntityKeyForSelection();
  var isEventHandled = requireIsEventHandled();
  var isSelectionAtLeafStart = requireIsSelectionAtLeafStart();
  var nullthrows = requireNullthrows();
  var setImmediate2 = requireSetImmediate();
  var FF_QUICKFIND_CHAR = "'";
  var FF_QUICKFIND_LINK_CHAR = "/";
  var isFirefox = UserAgent.isBrowser("Firefox");
  function mustPreventDefaultForCharacter(character) {
    return isFirefox && (character == FF_QUICKFIND_CHAR || character == FF_QUICKFIND_LINK_CHAR);
  }
  function replaceText(editorState, text, inlineStyle, entityKey, forceSelection) {
    var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), text, inlineStyle, entityKey);
    return EditorState.push(editorState, contentState, "insert-characters", forceSelection);
  }
  function editOnBeforeInput(editor, e2) {
    if (editor._pendingStateFromBeforeInput !== void 0) {
      editor.update(editor._pendingStateFromBeforeInput);
      editor._pendingStateFromBeforeInput = void 0;
    }
    var editorState = editor._latestEditorState;
    var chars2 = e2.data;
    if (!chars2) {
      return;
    }
    if (editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(chars2, editorState, e2.timeStamp))) {
      e2.preventDefault();
      return;
    }
    var selection = editorState.getSelection();
    var selectionStart = selection.getStartOffset();
    var anchorKey = selection.getAnchorKey();
    if (!selection.isCollapsed()) {
      e2.preventDefault();
      editor.update(replaceText(editorState, chars2, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()), true));
      return;
    }
    var newEditorState = replaceText(editorState, chars2, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()), false);
    var mustPreventNative = false;
    if (!mustPreventNative) {
      mustPreventNative = isSelectionAtLeafStart(editor._latestCommittedEditorState);
    }
    if (!mustPreventNative) {
      var oldBlockTree = editorState.getBlockTree(anchorKey);
      var newBlockTree = newEditorState.getBlockTree(anchorKey);
      mustPreventNative = oldBlockTree.size !== newBlockTree.size || oldBlockTree.zip(newBlockTree).some(function(_ref) {
        var oldLeafSet = _ref[0], newLeafSet = _ref[1];
        var oldStart = oldLeafSet.get("start");
        var adjustedStart = oldStart + (oldStart >= selectionStart ? chars2.length : 0);
        var oldEnd = oldLeafSet.get("end");
        var adjustedEnd = oldEnd + (oldEnd >= selectionStart ? chars2.length : 0);
        var newStart = newLeafSet.get("start");
        var newEnd = newLeafSet.get("end");
        var newDecoratorKey = newLeafSet.get("decoratorKey");
        return (
          // Different decorators
          oldLeafSet.get("decoratorKey") !== newDecoratorKey || // Different number of inline styles
          oldLeafSet.get("leaves").size !== newLeafSet.get("leaves").size || // Different effective decorator position
          adjustedStart !== newStart || adjustedEnd !== newEnd || // Decorator already existed and its length changed
          newDecoratorKey != null && newEnd - newStart !== oldEnd - oldStart
        );
      });
    }
    if (!mustPreventNative) {
      mustPreventNative = mustPreventDefaultForCharacter(chars2);
    }
    if (!mustPreventNative) {
      mustPreventNative = nullthrows(newEditorState.getDirectionMap()).get(anchorKey) !== nullthrows(editorState.getDirectionMap()).get(anchorKey);
    }
    if (mustPreventNative) {
      e2.preventDefault();
      newEditorState = EditorState.set(newEditorState, {
        forceSelection: true
      });
      editor.update(newEditorState);
      return;
    }
    newEditorState = EditorState.set(newEditorState, {
      nativelyRenderedContent: newEditorState.getCurrentContent()
    });
    editor._pendingStateFromBeforeInput = newEditorState;
    setImmediate2(function() {
      if (editor._pendingStateFromBeforeInput !== void 0) {
        editor.update(editor._pendingStateFromBeforeInput);
        editor._pendingStateFromBeforeInput = void 0;
      }
    });
  }
  editOnBeforeInput_1 = editOnBeforeInput;
  return editOnBeforeInput_1;
}
var editOnBlur_1;
var hasRequiredEditOnBlur;
function requireEditOnBlur() {
  if (hasRequiredEditOnBlur) return editOnBlur_1;
  hasRequiredEditOnBlur = 1;
  var EditorState = requireEditorState();
  var containsNode = requireContainsNode();
  var getActiveElement = requireGetActiveElement();
  function editOnBlur(editor, e2) {
    var ownerDocument = e2.currentTarget.ownerDocument;
    if (
      // This ESLint rule conflicts with `sketchy-null-bool` flow check
      // eslint-disable-next-line no-extra-boolean-cast
      !Boolean(editor.props.preserveSelectionOnBlur) && getActiveElement(ownerDocument) === ownerDocument.body
    ) {
      var _selection = ownerDocument.defaultView.getSelection();
      var editorNode = editor.editor;
      if (_selection.rangeCount === 1 && containsNode(editorNode, _selection.anchorNode) && containsNode(editorNode, _selection.focusNode)) {
        _selection.removeAllRanges();
      }
    }
    var editorState = editor._latestEditorState;
    var currentSelection = editorState.getSelection();
    if (!currentSelection.getHasFocus()) {
      return;
    }
    var selection = currentSelection.set("hasFocus", false);
    editor.props.onBlur && editor.props.onBlur(e2);
    editor.update(EditorState.acceptSelection(editorState, selection));
  }
  editOnBlur_1 = editOnBlur;
  return editOnBlur_1;
}
var editOnCompositionStart_1;
var hasRequiredEditOnCompositionStart;
function requireEditOnCompositionStart() {
  if (hasRequiredEditOnCompositionStart) return editOnCompositionStart_1;
  hasRequiredEditOnCompositionStart = 1;
  var EditorState = requireEditorState();
  function editOnCompositionStart(editor, e2) {
    editor.setMode("composite");
    editor.update(EditorState.set(editor._latestEditorState, {
      inCompositionMode: true
    }));
    editor._onCompositionStart(e2);
  }
  editOnCompositionStart_1 = editOnCompositionStart;
  return editOnCompositionStart_1;
}
var getFragmentFromSelection_1;
var hasRequiredGetFragmentFromSelection;
function requireGetFragmentFromSelection() {
  if (hasRequiredGetFragmentFromSelection) return getFragmentFromSelection_1;
  hasRequiredGetFragmentFromSelection = 1;
  var getContentStateFragment = requireGetContentStateFragment();
  function getFragmentFromSelection(editorState) {
    var selectionState = editorState.getSelection();
    if (selectionState.isCollapsed()) {
      return null;
    }
    return getContentStateFragment(editorState.getCurrentContent(), selectionState);
  }
  getFragmentFromSelection_1 = getFragmentFromSelection;
  return getFragmentFromSelection_1;
}
var editOnCopy_1;
var hasRequiredEditOnCopy;
function requireEditOnCopy() {
  if (hasRequiredEditOnCopy) return editOnCopy_1;
  hasRequiredEditOnCopy = 1;
  var getFragmentFromSelection = requireGetFragmentFromSelection();
  function editOnCopy(editor, e2) {
    var editorState = editor._latestEditorState;
    var selection = editorState.getSelection();
    if (selection.isCollapsed()) {
      e2.preventDefault();
      return;
    }
    editor.setClipboard(getFragmentFromSelection(editor._latestEditorState));
  }
  editOnCopy_1 = editOnCopy;
  return editOnCopy_1;
}
var isInstanceOfNode_1;
var hasRequiredIsInstanceOfNode;
function requireIsInstanceOfNode() {
  if (hasRequiredIsInstanceOfNode) return isInstanceOfNode_1;
  hasRequiredIsInstanceOfNode = 1;
  function isInstanceOfNode(target) {
    if (!target || !("ownerDocument" in target)) {
      return false;
    }
    if ("ownerDocument" in target) {
      var node = target;
      if (!node.ownerDocument.defaultView) {
        return node instanceof Node;
      }
      if (node instanceof node.ownerDocument.defaultView.Node) {
        return true;
      }
    }
    return false;
  }
  isInstanceOfNode_1 = isInstanceOfNode;
  return isInstanceOfNode_1;
}
var editOnCut_1;
var hasRequiredEditOnCut;
function requireEditOnCut() {
  if (hasRequiredEditOnCut) return editOnCut_1;
  hasRequiredEditOnCut = 1;
  var DraftModifier = requireDraftModifier();
  var EditorState = requireEditorState();
  var Style = requireStyle();
  var getFragmentFromSelection = requireGetFragmentFromSelection();
  var getScrollPosition2 = requireGetScrollPosition();
  var isNode2 = requireIsInstanceOfNode();
  function editOnCut(editor, e2) {
    var editorState = editor._latestEditorState;
    var selection = editorState.getSelection();
    var element = e2.target;
    var scrollPosition;
    if (selection.isCollapsed()) {
      e2.preventDefault();
      return;
    }
    if (isNode2(element)) {
      var node = element;
      scrollPosition = getScrollPosition2(Style.getScrollParent(node));
    }
    var fragment = getFragmentFromSelection(editorState);
    editor.setClipboard(fragment);
    editor.setMode("cut");
    setTimeout(function() {
      editor.restoreEditorDOM(scrollPosition);
      editor.exitCurrentMode();
      editor.update(removeFragment(editorState));
    }, 0);
  }
  function removeFragment(editorState) {
    var newContent = DraftModifier.removeRange(editorState.getCurrentContent(), editorState.getSelection(), "forward");
    return EditorState.push(editorState, newContent, "remove-range");
  }
  editOnCut_1 = editOnCut;
  return editOnCut_1;
}
var editOnDragOver_1;
var hasRequiredEditOnDragOver;
function requireEditOnDragOver() {
  if (hasRequiredEditOnDragOver) return editOnDragOver_1;
  hasRequiredEditOnDragOver = 1;
  function editOnDragOver(editor, e2) {
    editor.setMode("drag");
    e2.preventDefault();
  }
  editOnDragOver_1 = editOnDragOver;
  return editOnDragOver_1;
}
var editOnDragStart_1;
var hasRequiredEditOnDragStart;
function requireEditOnDragStart() {
  if (hasRequiredEditOnDragStart) return editOnDragStart_1;
  hasRequiredEditOnDragStart = 1;
  function editOnDragStart(editor) {
    editor._internalDrag = true;
    editor.setMode("drag");
  }
  editOnDragStart_1 = editOnDragStart;
  return editOnDragStart_1;
}
var editOnFocus_1;
var hasRequiredEditOnFocus;
function requireEditOnFocus() {
  if (hasRequiredEditOnFocus) return editOnFocus_1;
  hasRequiredEditOnFocus = 1;
  var EditorState = requireEditorState();
  var UserAgent = requireUserAgent();
  function editOnFocus(editor, e2) {
    var editorState = editor._latestEditorState;
    var currentSelection = editorState.getSelection();
    if (currentSelection.getHasFocus()) {
      return;
    }
    var selection = currentSelection.set("hasFocus", true);
    editor.props.onFocus && editor.props.onFocus(e2);
    if (UserAgent.isBrowser("Chrome < 60.0.3081.0")) {
      editor.update(EditorState.forceSelection(editorState, selection));
    } else {
      editor.update(EditorState.acceptSelection(editorState, selection));
    }
  }
  editOnFocus_1 = editOnFocus;
  return editOnFocus_1;
}
var UnicodeUtils_1;
var hasRequiredUnicodeUtils;
function requireUnicodeUtils() {
  if (hasRequiredUnicodeUtils) return UnicodeUtils_1;
  hasRequiredUnicodeUtils = 1;
  var invariant2 = requireInvariant();
  var SURROGATE_HIGH_START = 55296;
  var SURROGATE_HIGH_END = 56319;
  var SURROGATE_LOW_START = 56320;
  var SURROGATE_LOW_END = 57343;
  var SURROGATE_UNITS_REGEX = /[\uD800-\uDFFF]/;
  function isCodeUnitInSurrogateRange(codeUnit) {
    return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;
  }
  function isSurrogatePair(str, index) {
    !(0 <= index && index < str.length) ? invariant2(false) : void 0;
    if (index + 1 === str.length) {
      return false;
    }
    var first3 = str.charCodeAt(index);
    var second = str.charCodeAt(index + 1);
    return SURROGATE_HIGH_START <= first3 && first3 <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;
  }
  function hasSurrogateUnit(str) {
    return SURROGATE_UNITS_REGEX.test(str);
  }
  function getUTF16Length(str, pos) {
    return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));
  }
  function strlen(str) {
    if (!hasSurrogateUnit(str)) {
      return str.length;
    }
    var len = 0;
    for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {
      len++;
    }
    return len;
  }
  function substr(str, start, length) {
    start = start || 0;
    length = length === void 0 ? Infinity : length || 0;
    if (!hasSurrogateUnit(str)) {
      return str.substr(start, length);
    }
    var size = str.length;
    if (size <= 0 || start > size || length <= 0) {
      return "";
    }
    var posA = 0;
    if (start > 0) {
      for (; start > 0 && posA < size; start--) {
        posA += getUTF16Length(str, posA);
      }
      if (posA >= size) {
        return "";
      }
    } else if (start < 0) {
      for (posA = size; start < 0 && 0 < posA; start++) {
        posA -= getUTF16Length(str, posA - 1);
      }
      if (posA < 0) {
        posA = 0;
      }
    }
    var posB = size;
    if (length < size) {
      for (posB = posA; length > 0 && posB < size; length--) {
        posB += getUTF16Length(str, posB);
      }
    }
    return str.substring(posA, posB);
  }
  function substring(str, start, end) {
    start = start || 0;
    end = end === void 0 ? Infinity : end || 0;
    if (start < 0) {
      start = 0;
    }
    if (end < 0) {
      end = 0;
    }
    var length = Math.abs(end - start);
    start = start < end ? start : end;
    return substr(str, start, length);
  }
  function getCodePoints(str) {
    var codePoints = [];
    for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {
      codePoints.push(str.codePointAt(pos));
    }
    return codePoints;
  }
  var UnicodeUtils = {
    getCodePoints,
    getUTF16Length,
    hasSurrogateUnit,
    isCodeUnitInSurrogateRange,
    isSurrogatePair,
    strlen,
    substring,
    substr
  };
  UnicodeUtils_1 = UnicodeUtils;
  return UnicodeUtils_1;
}
var warning_1;
var hasRequiredWarning;
function requireWarning() {
  if (hasRequiredWarning) return warning_1;
  hasRequiredWarning = 1;
  var emptyFunction = requireEmptyFunction();
  var warning = emptyFunction;
  warning_1 = warning;
  return warning_1;
}
var moveSelectionBackward_1;
var hasRequiredMoveSelectionBackward;
function requireMoveSelectionBackward() {
  if (hasRequiredMoveSelectionBackward) return moveSelectionBackward_1;
  hasRequiredMoveSelectionBackward = 1;
  requireWarning();
  function moveSelectionBackward(editorState, maxDistance) {
    var selection = editorState.getSelection();
    var content = editorState.getCurrentContent();
    var key = selection.getStartKey();
    var offset = selection.getStartOffset();
    var focusKey = key;
    var focusOffset = 0;
    if (maxDistance > offset) {
      var keyBefore = content.getKeyBefore(key);
      if (keyBefore == null) {
        focusKey = key;
      } else {
        focusKey = keyBefore;
        var blockBefore = content.getBlockForKey(keyBefore);
        focusOffset = blockBefore.getText().length;
      }
    } else {
      focusOffset = offset - maxDistance;
    }
    return selection.merge({
      focusKey,
      focusOffset,
      isBackward: true
    });
  }
  moveSelectionBackward_1 = moveSelectionBackward;
  return moveSelectionBackward_1;
}
var removeTextWithStrategy_1;
var hasRequiredRemoveTextWithStrategy;
function requireRemoveTextWithStrategy() {
  if (hasRequiredRemoveTextWithStrategy) return removeTextWithStrategy_1;
  hasRequiredRemoveTextWithStrategy = 1;
  var DraftModifier = requireDraftModifier();
  var gkx2 = requireGkx();
  var experimentalTreeDataSupport = gkx2("draft_tree_data_support");
  function removeTextWithStrategy(editorState, strategy, direction) {
    var selection = editorState.getSelection();
    var content = editorState.getCurrentContent();
    var target = selection;
    var anchorKey = selection.getAnchorKey();
    var focusKey = selection.getFocusKey();
    var anchorBlock = content.getBlockForKey(anchorKey);
    if (experimentalTreeDataSupport) {
      if (direction === "forward") {
        if (anchorKey !== focusKey) {
          return content;
        }
      }
    }
    if (selection.isCollapsed()) {
      if (direction === "forward") {
        if (editorState.isSelectionAtEndOfContent()) {
          return content;
        }
        if (experimentalTreeDataSupport) {
          var isAtEndOfBlock = selection.getAnchorOffset() === content.getBlockForKey(anchorKey).getLength();
          if (isAtEndOfBlock) {
            var anchorBlockSibling = content.getBlockForKey(anchorBlock.nextSibling);
            if (!anchorBlockSibling || anchorBlockSibling.getLength() === 0) {
              return content;
            }
          }
        }
      } else if (editorState.isSelectionAtStartOfContent()) {
        return content;
      }
      target = strategy(editorState);
      if (target === selection) {
        return content;
      }
    }
    return DraftModifier.removeRange(content, target, direction);
  }
  removeTextWithStrategy_1 = removeTextWithStrategy;
  return removeTextWithStrategy_1;
}
var keyCommandPlainBackspace_1;
var hasRequiredKeyCommandPlainBackspace;
function requireKeyCommandPlainBackspace() {
  if (hasRequiredKeyCommandPlainBackspace) return keyCommandPlainBackspace_1;
  hasRequiredKeyCommandPlainBackspace = 1;
  var EditorState = requireEditorState();
  var UnicodeUtils = requireUnicodeUtils();
  var moveSelectionBackward = requireMoveSelectionBackward();
  var removeTextWithStrategy = requireRemoveTextWithStrategy();
  function keyCommandPlainBackspace(editorState) {
    var afterRemoval = removeTextWithStrategy(editorState, function(strategyState) {
      var selection2 = strategyState.getSelection();
      var content = strategyState.getCurrentContent();
      var key = selection2.getAnchorKey();
      var offset = selection2.getAnchorOffset();
      var charBehind = content.getBlockForKey(key).getText()[offset - 1];
      return moveSelectionBackward(strategyState, charBehind ? UnicodeUtils.getUTF16Length(charBehind, 0) : 1);
    }, "backward");
    if (afterRemoval === editorState.getCurrentContent()) {
      return editorState;
    }
    var selection = editorState.getSelection();
    return EditorState.push(editorState, afterRemoval.set("selectionBefore", selection), selection.isCollapsed() ? "backspace-character" : "remove-range");
  }
  keyCommandPlainBackspace_1 = keyCommandPlainBackspace;
  return keyCommandPlainBackspace_1;
}
var editOnInput_1;
var hasRequiredEditOnInput;
function requireEditOnInput() {
  if (hasRequiredEditOnInput) return editOnInput_1;
  hasRequiredEditOnInput = 1;
  var DraftModifier = requireDraftModifier();
  var DraftOffsetKey = requireDraftOffsetKey();
  var EditorState = requireEditorState();
  var UserAgent = requireUserAgent();
  var _require = requireDraftKeyUtils(), notEmptyKey = _require.notEmptyKey;
  var findAncestorOffsetKey = requireFindAncestorOffsetKey();
  var keyCommandPlainBackspace = requireKeyCommandPlainBackspace();
  var nullthrows = requireNullthrows();
  var isGecko = UserAgent.isEngine("Gecko");
  var DOUBLE_NEWLINE = "\n\n";
  function onInputType(inputType, editorState) {
    switch (inputType) {
      case "deleteContentBackward":
        return keyCommandPlainBackspace(editorState);
    }
    return editorState;
  }
  function editOnInput(editor, e2) {
    if (editor._pendingStateFromBeforeInput !== void 0) {
      editor.update(editor._pendingStateFromBeforeInput);
      editor._pendingStateFromBeforeInput = void 0;
    }
    var castedEditorElement = editor.editor;
    var domSelection = castedEditorElement.ownerDocument.defaultView.getSelection();
    var anchorNode = domSelection.anchorNode, isCollapsed = domSelection.isCollapsed;
    var isNotTextOrElementNode = (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.TEXT_NODE && (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.ELEMENT_NODE;
    if (anchorNode == null || isNotTextOrElementNode) {
      return;
    }
    if (anchorNode.nodeType === Node.TEXT_NODE && (anchorNode.previousSibling !== null || anchorNode.nextSibling !== null)) {
      var span = anchorNode.parentNode;
      if (span == null) {
        return;
      }
      anchorNode.nodeValue = span.textContent;
      for (var child = span.firstChild; child != null; child = child.nextSibling) {
        if (child !== anchorNode) {
          span.removeChild(child);
        }
      }
    }
    var domText = anchorNode.textContent;
    var editorState = editor._latestEditorState;
    var offsetKey = nullthrows(findAncestorOffsetKey(anchorNode));
    var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey), blockKey = _DraftOffsetKey$decod.blockKey, decoratorKey = _DraftOffsetKey$decod.decoratorKey, leafKey = _DraftOffsetKey$decod.leafKey;
    var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, "leaves", leafKey]), start = _editorState$getBlock.start, end = _editorState$getBlock.end;
    var content = editorState.getCurrentContent();
    var block = content.getBlockForKey(blockKey);
    var modelText = block.getText().slice(start, end);
    if (domText.endsWith(DOUBLE_NEWLINE)) {
      domText = domText.slice(0, -1);
    }
    if (domText === modelText) {
      var inputType = e2.nativeEvent.inputType;
      if (inputType) {
        var newEditorState = onInputType(inputType, editorState);
        if (newEditorState !== editorState) {
          editor.restoreEditorDOM();
          editor.update(newEditorState);
          return;
        }
      }
      return;
    }
    var selection = editorState.getSelection();
    var targetRange = selection.merge({
      anchorOffset: start,
      focusOffset: end,
      isBackward: false
    });
    var entityKey = block.getEntityAt(start);
    var entity = notEmptyKey(entityKey) ? content.getEntity(entityKey) : null;
    var entityType = entity != null ? entity.getMutability() : null;
    var preserveEntity = entityType === "MUTABLE";
    var changeType = preserveEntity ? "spellcheck-change" : "apply-entity";
    var newContent = DraftModifier.replaceText(content, targetRange, domText, block.getInlineStyleAt(start), preserveEntity ? block.getEntityAt(start) : null);
    var anchorOffset, focusOffset, startOffset, endOffset;
    if (isGecko) {
      anchorOffset = domSelection.anchorOffset;
      focusOffset = domSelection.focusOffset;
      startOffset = start + Math.min(anchorOffset, focusOffset);
      endOffset = startOffset + Math.abs(anchorOffset - focusOffset);
      anchorOffset = startOffset;
      focusOffset = endOffset;
    } else {
      var charDelta = domText.length - modelText.length;
      startOffset = selection.getStartOffset();
      endOffset = selection.getEndOffset();
      anchorOffset = isCollapsed ? endOffset + charDelta : startOffset;
      focusOffset = endOffset + charDelta;
    }
    var contentWithAdjustedDOMSelection = newContent.merge({
      selectionBefore: content.getSelectionAfter(),
      selectionAfter: selection.merge({
        anchorOffset,
        focusOffset
      })
    });
    editor.update(EditorState.push(editorState, contentWithAdjustedDOMSelection, changeType));
  }
  editOnInput_1 = editOnInput;
  return editOnInput_1;
}
var isSoftNewlineEvent_1;
var hasRequiredIsSoftNewlineEvent;
function requireIsSoftNewlineEvent() {
  if (hasRequiredIsSoftNewlineEvent) return isSoftNewlineEvent_1;
  hasRequiredIsSoftNewlineEvent = 1;
  var Keys2 = requireKeys();
  function isSoftNewlineEvent(e2) {
    return e2.which === Keys2.RETURN && (e2.getModifierState("Shift") || e2.getModifierState("Alt") || e2.getModifierState("Control"));
  }
  isSoftNewlineEvent_1 = isSoftNewlineEvent;
  return isSoftNewlineEvent_1;
}
var KeyBindingUtil_1;
var hasRequiredKeyBindingUtil;
function requireKeyBindingUtil() {
  if (hasRequiredKeyBindingUtil) return KeyBindingUtil_1;
  hasRequiredKeyBindingUtil = 1;
  var UserAgent = requireUserAgent();
  var isSoftNewlineEvent = requireIsSoftNewlineEvent();
  var isOSX = UserAgent.isPlatform("Mac OS X");
  var KeyBindingUtil = {
    /**
     * Check whether the ctrlKey modifier is *not* being used in conjunction with
     * the altKey modifier. If they are combined, the result is an `altGraph`
     * key modifier, which should not be handled by this set of key bindings.
     */
    isCtrlKeyCommand: function isCtrlKeyCommand(e2) {
      return !!e2.ctrlKey && !e2.altKey;
    },
    isOptionKeyCommand: function isOptionKeyCommand(e2) {
      return isOSX && e2.altKey;
    },
    usesMacOSHeuristics: function usesMacOSHeuristics() {
      return isOSX;
    },
    hasCommandModifier: function hasCommandModifier(e2) {
      return isOSX ? !!e2.metaKey && !e2.altKey : KeyBindingUtil.isCtrlKeyCommand(e2);
    },
    isSoftNewlineEvent
  };
  KeyBindingUtil_1 = KeyBindingUtil;
  return KeyBindingUtil_1;
}
var SecondaryClipboard_1;
var hasRequiredSecondaryClipboard;
function requireSecondaryClipboard() {
  if (hasRequiredSecondaryClipboard) return SecondaryClipboard_1;
  hasRequiredSecondaryClipboard = 1;
  var DraftModifier = requireDraftModifier();
  var EditorState = requireEditorState();
  var getContentStateFragment = requireGetContentStateFragment();
  var nullthrows = requireNullthrows();
  var clipboard = null;
  var SecondaryClipboard = {
    cut: function cut(editorState) {
      var content = editorState.getCurrentContent();
      var selection = editorState.getSelection();
      var targetRange = null;
      if (selection.isCollapsed()) {
        var anchorKey = selection.getAnchorKey();
        var blockEnd = content.getBlockForKey(anchorKey).getLength();
        if (blockEnd === selection.getAnchorOffset()) {
          var keyAfter = content.getKeyAfter(anchorKey);
          if (keyAfter == null) {
            return editorState;
          }
          targetRange = selection.set("focusKey", keyAfter).set("focusOffset", 0);
        } else {
          targetRange = selection.set("focusOffset", blockEnd);
        }
      } else {
        targetRange = selection;
      }
      targetRange = nullthrows(targetRange);
      clipboard = getContentStateFragment(content, targetRange);
      var afterRemoval = DraftModifier.removeRange(content, targetRange, "forward");
      if (afterRemoval === content) {
        return editorState;
      }
      return EditorState.push(editorState, afterRemoval, "remove-range");
    },
    paste: function paste(editorState) {
      if (!clipboard) {
        return editorState;
      }
      var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), clipboard);
      return EditorState.push(editorState, newContent, "insert-fragment");
    }
  };
  SecondaryClipboard_1 = SecondaryClipboard;
  return SecondaryClipboard_1;
}
var getRangeClientRects_1;
var hasRequiredGetRangeClientRects;
function requireGetRangeClientRects() {
  if (hasRequiredGetRangeClientRects) return getRangeClientRects_1;
  hasRequiredGetRangeClientRects = 1;
  var UserAgent = requireUserAgent();
  var invariant2 = requireInvariant();
  var isChrome = UserAgent.isBrowser("Chrome");
  function getRangeClientRectsChrome(range) {
    var tempRange = range.cloneRange();
    var clientRects = [];
    for (var ancestor = range.endContainer; ancestor != null; ancestor = ancestor.parentNode) {
      var atCommonAncestor = ancestor === range.commonAncestorContainer;
      if (atCommonAncestor) {
        tempRange.setStart(range.startContainer, range.startOffset);
      } else {
        tempRange.setStart(tempRange.endContainer, 0);
      }
      var rects = Array.from(tempRange.getClientRects());
      clientRects.push(rects);
      if (atCommonAncestor) {
        var _ref;
        clientRects.reverse();
        return (_ref = []).concat.apply(_ref, clientRects);
      }
      tempRange.setEndBefore(ancestor);
    }
    invariant2(false);
  }
  var getRangeClientRects = isChrome ? getRangeClientRectsChrome : function(range) {
    return Array.from(range.getClientRects());
  };
  getRangeClientRects_1 = getRangeClientRects;
  return getRangeClientRects_1;
}
var expandRangeToStartOfLine_1;
var hasRequiredExpandRangeToStartOfLine;
function requireExpandRangeToStartOfLine() {
  if (hasRequiredExpandRangeToStartOfLine) return expandRangeToStartOfLine_1;
  hasRequiredExpandRangeToStartOfLine = 1;
  var UnicodeUtils = requireUnicodeUtils();
  var getCorrectDocumentFromNode = requireGetCorrectDocumentFromNode();
  var getRangeClientRects = requireGetRangeClientRects();
  var invariant2 = requireInvariant();
  function getLineHeightPx(element) {
    var computed = getComputedStyle(element);
    var correctDocument = getCorrectDocumentFromNode(element);
    var div = correctDocument.createElement("div");
    div.style.fontFamily = computed.fontFamily;
    div.style.fontSize = computed.fontSize;
    div.style.fontStyle = computed.fontStyle;
    div.style.fontWeight = computed.fontWeight;
    div.style.lineHeight = computed.lineHeight;
    div.style.position = "absolute";
    div.textContent = "M";
    var documentBody = correctDocument.body;
    !documentBody ? invariant2(false) : void 0;
    documentBody.appendChild(div);
    var rect = div.getBoundingClientRect();
    documentBody.removeChild(div);
    return rect.height;
  }
  function areRectsOnOneLine(rects, lineHeight) {
    var minTop = Infinity;
    var minBottom = Infinity;
    var maxTop = -Infinity;
    var maxBottom = -Infinity;
    for (var ii = 0; ii < rects.length; ii++) {
      var rect = rects[ii];
      if (rect.width === 0 || rect.width === 1) {
        continue;
      }
      minTop = Math.min(minTop, rect.top);
      minBottom = Math.min(minBottom, rect.bottom);
      maxTop = Math.max(maxTop, rect.top);
      maxBottom = Math.max(maxBottom, rect.bottom);
    }
    return maxTop <= minBottom && maxTop - minTop < lineHeight && maxBottom - minBottom < lineHeight;
  }
  function getNodeLength(node) {
    switch (node.nodeType) {
      case Node.DOCUMENT_TYPE_NODE:
        return 0;
      case Node.TEXT_NODE:
      case Node.PROCESSING_INSTRUCTION_NODE:
      case Node.COMMENT_NODE:
        return node.length;
      default:
        return node.childNodes.length;
    }
  }
  function expandRangeToStartOfLine(range) {
    !range.collapsed ? invariant2(false) : void 0;
    range = range.cloneRange();
    var containingElement = range.startContainer;
    if (containingElement.nodeType !== 1) {
      containingElement = containingElement.parentNode;
    }
    var lineHeight = getLineHeightPx(containingElement);
    var bestContainer = range.endContainer;
    var bestOffset = range.endOffset;
    range.setStart(range.startContainer, 0);
    while (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {
      bestContainer = range.startContainer;
      bestOffset = range.startOffset;
      !bestContainer.parentNode ? invariant2(false) : void 0;
      range.setStartBefore(bestContainer);
      if (bestContainer.nodeType === 1 && getComputedStyle(bestContainer).display !== "inline") {
        break;
      }
    }
    var currentContainer = bestContainer;
    var maxIndexToConsider = bestOffset - 1;
    do {
      var nodeValue = currentContainer.nodeValue;
      var ii = maxIndexToConsider;
      for (; ii >= 0; ii--) {
        if (nodeValue != null && ii > 0 && UnicodeUtils.isSurrogatePair(nodeValue, ii - 1)) {
          continue;
        }
        range.setStart(currentContainer, ii);
        if (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {
          bestContainer = currentContainer;
          bestOffset = ii;
        } else {
          break;
        }
      }
      if (ii === -1 || currentContainer.childNodes.length === 0) {
        break;
      }
      currentContainer = currentContainer.childNodes[ii];
      maxIndexToConsider = getNodeLength(currentContainer);
    } while (true);
    range.setStart(bestContainer, bestOffset);
    return range;
  }
  expandRangeToStartOfLine_1 = expandRangeToStartOfLine;
  return expandRangeToStartOfLine_1;
}
var keyCommandBackspaceToStartOfLine_1;
var hasRequiredKeyCommandBackspaceToStartOfLine;
function requireKeyCommandBackspaceToStartOfLine() {
  if (hasRequiredKeyCommandBackspaceToStartOfLine) return keyCommandBackspaceToStartOfLine_1;
  hasRequiredKeyCommandBackspaceToStartOfLine = 1;
  var EditorState = requireEditorState();
  var expandRangeToStartOfLine = requireExpandRangeToStartOfLine();
  var getDraftEditorSelectionWithNodes = requireGetDraftEditorSelectionWithNodes();
  var moveSelectionBackward = requireMoveSelectionBackward();
  var removeTextWithStrategy = requireRemoveTextWithStrategy();
  function keyCommandBackspaceToStartOfLine(editorState, e2) {
    var afterRemoval = removeTextWithStrategy(editorState, function(strategyState) {
      var selection = strategyState.getSelection();
      if (selection.isCollapsed() && selection.getAnchorOffset() === 0) {
        return moveSelectionBackward(strategyState, 1);
      }
      var ownerDocument = e2.currentTarget.ownerDocument;
      var domSelection = ownerDocument.defaultView.getSelection();
      var range = domSelection.getRangeAt(0);
      range = expandRangeToStartOfLine(range);
      return getDraftEditorSelectionWithNodes(strategyState, null, range.endContainer, range.endOffset, range.startContainer, range.startOffset).selectionState;
    }, "backward");
    if (afterRemoval === editorState.getCurrentContent()) {
      return editorState;
    }
    return EditorState.push(editorState, afterRemoval, "remove-range");
  }
  keyCommandBackspaceToStartOfLine_1 = keyCommandBackspaceToStartOfLine;
  return keyCommandBackspaceToStartOfLine_1;
}
var TokenizeUtil;
var hasRequiredTokenizeUtil;
function requireTokenizeUtil() {
  if (hasRequiredTokenizeUtil) return TokenizeUtil;
  hasRequiredTokenizeUtil = 1;
  var PUNCTUATION = "[.,+*?$|#{}()'\\^\\-\\[\\]\\\\\\/!@%\"~=<>_:;-----------]";
  TokenizeUtil = {
    getPunctuation: function getPunctuation() {
      return PUNCTUATION;
    }
  };
  return TokenizeUtil;
}
var DraftRemovableWord_1;
var hasRequiredDraftRemovableWord;
function requireDraftRemovableWord() {
  if (hasRequiredDraftRemovableWord) return DraftRemovableWord_1;
  hasRequiredDraftRemovableWord = 1;
  var TokenizeUtil2 = requireTokenizeUtil();
  var punctuation = TokenizeUtil2.getPunctuation();
  var CHAMELEON_CHARS = "[']";
  var WHITESPACE_AND_PUNCTUATION = "\\s|(?![_])" + punctuation;
  var DELETE_STRING = "^(?:" + WHITESPACE_AND_PUNCTUATION + ")*(?:" + CHAMELEON_CHARS + "|(?!" + WHITESPACE_AND_PUNCTUATION + ").)*(?:(?!" + WHITESPACE_AND_PUNCTUATION + ").)";
  var DELETE_REGEX = new RegExp(DELETE_STRING);
  var BACKSPACE_STRING = "(?:(?!" + WHITESPACE_AND_PUNCTUATION + ").)(?:" + CHAMELEON_CHARS + "|(?!" + WHITESPACE_AND_PUNCTUATION + ").)*(?:" + WHITESPACE_AND_PUNCTUATION + ")*$";
  var BACKSPACE_REGEX = new RegExp(BACKSPACE_STRING);
  function getRemovableWord(text, isBackward) {
    var matches2 = isBackward ? BACKSPACE_REGEX.exec(text) : DELETE_REGEX.exec(text);
    return matches2 ? matches2[0] : text;
  }
  var DraftRemovableWord = {
    getBackward: function getBackward(text) {
      return getRemovableWord(text, true);
    },
    getForward: function getForward(text) {
      return getRemovableWord(text, false);
    }
  };
  DraftRemovableWord_1 = DraftRemovableWord;
  return DraftRemovableWord_1;
}
var keyCommandBackspaceWord_1;
var hasRequiredKeyCommandBackspaceWord;
function requireKeyCommandBackspaceWord() {
  if (hasRequiredKeyCommandBackspaceWord) return keyCommandBackspaceWord_1;
  hasRequiredKeyCommandBackspaceWord = 1;
  var DraftRemovableWord = requireDraftRemovableWord();
  var EditorState = requireEditorState();
  var moveSelectionBackward = requireMoveSelectionBackward();
  var removeTextWithStrategy = requireRemoveTextWithStrategy();
  function keyCommandBackspaceWord(editorState) {
    var afterRemoval = removeTextWithStrategy(editorState, function(strategyState) {
      var selection = strategyState.getSelection();
      var offset = selection.getStartOffset();
      if (offset === 0) {
        return moveSelectionBackward(strategyState, 1);
      }
      var key = selection.getStartKey();
      var content = strategyState.getCurrentContent();
      var text = content.getBlockForKey(key).getText().slice(0, offset);
      var toRemove = DraftRemovableWord.getBackward(text);
      return moveSelectionBackward(strategyState, toRemove.length || 1);
    }, "backward");
    if (afterRemoval === editorState.getCurrentContent()) {
      return editorState;
    }
    return EditorState.push(editorState, afterRemoval, "remove-range");
  }
  keyCommandBackspaceWord_1 = keyCommandBackspaceWord;
  return keyCommandBackspaceWord_1;
}
var moveSelectionForward_1;
var hasRequiredMoveSelectionForward;
function requireMoveSelectionForward() {
  if (hasRequiredMoveSelectionForward) return moveSelectionForward_1;
  hasRequiredMoveSelectionForward = 1;
  requireWarning();
  function moveSelectionForward(editorState, maxDistance) {
    var selection = editorState.getSelection();
    var key = selection.getStartKey();
    var offset = selection.getStartOffset();
    var content = editorState.getCurrentContent();
    var focusKey = key;
    var focusOffset;
    var block = content.getBlockForKey(key);
    if (maxDistance > block.getText().length - offset) {
      focusKey = content.getKeyAfter(key);
      focusOffset = 0;
    } else {
      focusOffset = offset + maxDistance;
    }
    return selection.merge({
      focusKey,
      focusOffset
    });
  }
  moveSelectionForward_1 = moveSelectionForward;
  return moveSelectionForward_1;
}
var keyCommandDeleteWord_1;
var hasRequiredKeyCommandDeleteWord;
function requireKeyCommandDeleteWord() {
  if (hasRequiredKeyCommandDeleteWord) return keyCommandDeleteWord_1;
  hasRequiredKeyCommandDeleteWord = 1;
  var DraftRemovableWord = requireDraftRemovableWord();
  var EditorState = requireEditorState();
  var moveSelectionForward = requireMoveSelectionForward();
  var removeTextWithStrategy = requireRemoveTextWithStrategy();
  function keyCommandDeleteWord(editorState) {
    var afterRemoval = removeTextWithStrategy(editorState, function(strategyState) {
      var selection = strategyState.getSelection();
      var offset = selection.getStartOffset();
      var key = selection.getStartKey();
      var content = strategyState.getCurrentContent();
      var text = content.getBlockForKey(key).getText().slice(offset);
      var toRemove = DraftRemovableWord.getForward(text);
      return moveSelectionForward(strategyState, toRemove.length || 1);
    }, "forward");
    if (afterRemoval === editorState.getCurrentContent()) {
      return editorState;
    }
    return EditorState.push(editorState, afterRemoval, "remove-range");
  }
  keyCommandDeleteWord_1 = keyCommandDeleteWord;
  return keyCommandDeleteWord_1;
}
var keyCommandInsertNewline_1;
var hasRequiredKeyCommandInsertNewline;
function requireKeyCommandInsertNewline() {
  if (hasRequiredKeyCommandInsertNewline) return keyCommandInsertNewline_1;
  hasRequiredKeyCommandInsertNewline = 1;
  var DraftModifier = requireDraftModifier();
  var EditorState = requireEditorState();
  function keyCommandInsertNewline(editorState) {
    var contentState = DraftModifier.splitBlock(editorState.getCurrentContent(), editorState.getSelection());
    return EditorState.push(editorState, contentState, "split-block");
  }
  keyCommandInsertNewline_1 = keyCommandInsertNewline;
  return keyCommandInsertNewline_1;
}
var keyCommandMoveSelectionToEndOfBlock_1;
var hasRequiredKeyCommandMoveSelectionToEndOfBlock;
function requireKeyCommandMoveSelectionToEndOfBlock() {
  if (hasRequiredKeyCommandMoveSelectionToEndOfBlock) return keyCommandMoveSelectionToEndOfBlock_1;
  hasRequiredKeyCommandMoveSelectionToEndOfBlock = 1;
  var EditorState = requireEditorState();
  function keyCommandMoveSelectionToEndOfBlock(editorState) {
    var selection = editorState.getSelection();
    var endKey = selection.getEndKey();
    var content = editorState.getCurrentContent();
    var textLength = content.getBlockForKey(endKey).getLength();
    return EditorState.set(editorState, {
      selection: selection.merge({
        anchorKey: endKey,
        anchorOffset: textLength,
        focusKey: endKey,
        focusOffset: textLength,
        isBackward: false
      }),
      forceSelection: true
    });
  }
  keyCommandMoveSelectionToEndOfBlock_1 = keyCommandMoveSelectionToEndOfBlock;
  return keyCommandMoveSelectionToEndOfBlock_1;
}
var keyCommandMoveSelectionToStartOfBlock_1;
var hasRequiredKeyCommandMoveSelectionToStartOfBlock;
function requireKeyCommandMoveSelectionToStartOfBlock() {
  if (hasRequiredKeyCommandMoveSelectionToStartOfBlock) return keyCommandMoveSelectionToStartOfBlock_1;
  hasRequiredKeyCommandMoveSelectionToStartOfBlock = 1;
  var EditorState = requireEditorState();
  function keyCommandMoveSelectionToStartOfBlock(editorState) {
    var selection = editorState.getSelection();
    var startKey = selection.getStartKey();
    return EditorState.set(editorState, {
      selection: selection.merge({
        anchorKey: startKey,
        anchorOffset: 0,
        focusKey: startKey,
        focusOffset: 0,
        isBackward: false
      }),
      forceSelection: true
    });
  }
  keyCommandMoveSelectionToStartOfBlock_1 = keyCommandMoveSelectionToStartOfBlock;
  return keyCommandMoveSelectionToStartOfBlock_1;
}
var keyCommandPlainDelete_1;
var hasRequiredKeyCommandPlainDelete;
function requireKeyCommandPlainDelete() {
  if (hasRequiredKeyCommandPlainDelete) return keyCommandPlainDelete_1;
  hasRequiredKeyCommandPlainDelete = 1;
  var EditorState = requireEditorState();
  var UnicodeUtils = requireUnicodeUtils();
  var moveSelectionForward = requireMoveSelectionForward();
  var removeTextWithStrategy = requireRemoveTextWithStrategy();
  function keyCommandPlainDelete(editorState) {
    var afterRemoval = removeTextWithStrategy(editorState, function(strategyState) {
      var selection2 = strategyState.getSelection();
      var content = strategyState.getCurrentContent();
      var key = selection2.getAnchorKey();
      var offset = selection2.getAnchorOffset();
      var charAhead = content.getBlockForKey(key).getText()[offset];
      return moveSelectionForward(strategyState, charAhead ? UnicodeUtils.getUTF16Length(charAhead, 0) : 1);
    }, "forward");
    if (afterRemoval === editorState.getCurrentContent()) {
      return editorState;
    }
    var selection = editorState.getSelection();
    return EditorState.push(editorState, afterRemoval.set("selectionBefore", selection), selection.isCollapsed() ? "delete-character" : "remove-range");
  }
  keyCommandPlainDelete_1 = keyCommandPlainDelete;
  return keyCommandPlainDelete_1;
}
var keyCommandTransposeCharacters_1;
var hasRequiredKeyCommandTransposeCharacters;
function requireKeyCommandTransposeCharacters() {
  if (hasRequiredKeyCommandTransposeCharacters) return keyCommandTransposeCharacters_1;
  hasRequiredKeyCommandTransposeCharacters = 1;
  var DraftModifier = requireDraftModifier();
  var EditorState = requireEditorState();
  var getContentStateFragment = requireGetContentStateFragment();
  function keyCommandTransposeCharacters(editorState) {
    var selection = editorState.getSelection();
    if (!selection.isCollapsed()) {
      return editorState;
    }
    var offset = selection.getAnchorOffset();
    if (offset === 0) {
      return editorState;
    }
    var blockKey = selection.getAnchorKey();
    var content = editorState.getCurrentContent();
    var block = content.getBlockForKey(blockKey);
    var length = block.getLength();
    if (length <= 1) {
      return editorState;
    }
    var removalRange;
    var finalSelection;
    if (offset === length) {
      removalRange = selection.set("anchorOffset", offset - 1);
      finalSelection = selection;
    } else {
      removalRange = selection.set("focusOffset", offset + 1);
      finalSelection = removalRange.set("anchorOffset", offset + 1);
    }
    var movedFragment = getContentStateFragment(content, removalRange);
    var afterRemoval = DraftModifier.removeRange(content, removalRange, "backward");
    var selectionAfter = afterRemoval.getSelectionAfter();
    var targetOffset = selectionAfter.getAnchorOffset() - 1;
    var targetRange = selectionAfter.merge({
      anchorOffset: targetOffset,
      focusOffset: targetOffset
    });
    var afterInsert = DraftModifier.replaceWithFragment(afterRemoval, targetRange, movedFragment);
    var newEditorState = EditorState.push(editorState, afterInsert, "insert-fragment");
    return EditorState.acceptSelection(newEditorState, finalSelection);
  }
  keyCommandTransposeCharacters_1 = keyCommandTransposeCharacters;
  return keyCommandTransposeCharacters_1;
}
var keyCommandUndo_1;
var hasRequiredKeyCommandUndo;
function requireKeyCommandUndo() {
  if (hasRequiredKeyCommandUndo) return keyCommandUndo_1;
  hasRequiredKeyCommandUndo = 1;
  var EditorState = requireEditorState();
  function keyCommandUndo(e2, editorState, updateFn) {
    var undoneState = EditorState.undo(editorState);
    if (editorState.getLastChangeType() === "spellcheck-change") {
      var nativelyRenderedContent = undoneState.getCurrentContent();
      updateFn(EditorState.set(undoneState, {
        nativelyRenderedContent
      }));
      return;
    }
    e2.preventDefault();
    if (!editorState.getNativelyRenderedContent()) {
      updateFn(undoneState);
      return;
    }
    updateFn(EditorState.set(editorState, {
      nativelyRenderedContent: null
    }));
    setTimeout(function() {
      updateFn(undoneState);
    }, 0);
  }
  keyCommandUndo_1 = keyCommandUndo;
  return keyCommandUndo_1;
}
var editOnKeyDown_1;
var hasRequiredEditOnKeyDown;
function requireEditOnKeyDown() {
  if (hasRequiredEditOnKeyDown) return editOnKeyDown_1;
  hasRequiredEditOnKeyDown = 1;
  var DraftModifier = requireDraftModifier();
  var EditorState = requireEditorState();
  var KeyBindingUtil = requireKeyBindingUtil();
  var Keys2 = requireKeys();
  var SecondaryClipboard = requireSecondaryClipboard();
  var UserAgent = requireUserAgent();
  var isEventHandled = requireIsEventHandled();
  var keyCommandBackspaceToStartOfLine = requireKeyCommandBackspaceToStartOfLine();
  var keyCommandBackspaceWord = requireKeyCommandBackspaceWord();
  var keyCommandDeleteWord = requireKeyCommandDeleteWord();
  var keyCommandInsertNewline = requireKeyCommandInsertNewline();
  var keyCommandMoveSelectionToEndOfBlock = requireKeyCommandMoveSelectionToEndOfBlock();
  var keyCommandMoveSelectionToStartOfBlock = requireKeyCommandMoveSelectionToStartOfBlock();
  var keyCommandPlainBackspace = requireKeyCommandPlainBackspace();
  var keyCommandPlainDelete = requireKeyCommandPlainDelete();
  var keyCommandTransposeCharacters = requireKeyCommandTransposeCharacters();
  var keyCommandUndo = requireKeyCommandUndo();
  var isOptionKeyCommand = KeyBindingUtil.isOptionKeyCommand;
  var isChrome = UserAgent.isBrowser("Chrome");
  function onKeyCommand(command, editorState, e2) {
    switch (command) {
      case "redo":
        return EditorState.redo(editorState);
      case "delete":
        return keyCommandPlainDelete(editorState);
      case "delete-word":
        return keyCommandDeleteWord(editorState);
      case "backspace":
        return keyCommandPlainBackspace(editorState);
      case "backspace-word":
        return keyCommandBackspaceWord(editorState);
      case "backspace-to-start-of-line":
        return keyCommandBackspaceToStartOfLine(editorState, e2);
      case "split-block":
        return keyCommandInsertNewline(editorState);
      case "transpose-characters":
        return keyCommandTransposeCharacters(editorState);
      case "move-selection-to-start-of-block":
        return keyCommandMoveSelectionToStartOfBlock(editorState);
      case "move-selection-to-end-of-block":
        return keyCommandMoveSelectionToEndOfBlock(editorState);
      case "secondary-cut":
        return SecondaryClipboard.cut(editorState);
      case "secondary-paste":
        return SecondaryClipboard.paste(editorState);
      default:
        return editorState;
    }
  }
  function editOnKeyDown(editor, e2) {
    var keyCode = e2.which;
    var editorState = editor._latestEditorState;
    function callDeprecatedHandler(handlerName) {
      var deprecatedHandler = editor.props[handlerName];
      if (deprecatedHandler) {
        deprecatedHandler(e2);
        return true;
      } else {
        return false;
      }
    }
    switch (keyCode) {
      case Keys2.RETURN:
        e2.preventDefault();
        if (editor.props.handleReturn && isEventHandled(editor.props.handleReturn(e2, editorState))) {
          return;
        }
        break;
      case Keys2.ESC:
        e2.preventDefault();
        if (callDeprecatedHandler("onEscape")) {
          return;
        }
        break;
      case Keys2.TAB:
        if (callDeprecatedHandler("onTab")) {
          return;
        }
        break;
      case Keys2.UP:
        if (callDeprecatedHandler("onUpArrow")) {
          return;
        }
        break;
      case Keys2.RIGHT:
        if (callDeprecatedHandler("onRightArrow")) {
          return;
        }
        break;
      case Keys2.DOWN:
        if (callDeprecatedHandler("onDownArrow")) {
          return;
        }
        break;
      case Keys2.LEFT:
        if (callDeprecatedHandler("onLeftArrow")) {
          return;
        }
        break;
      case Keys2.SPACE:
        if (isChrome && isOptionKeyCommand(e2)) {
          e2.preventDefault();
        }
    }
    var command = editor.props.keyBindingFn(e2);
    if (command == null || command === "") {
      if (keyCode === Keys2.SPACE && isChrome && isOptionKeyCommand(e2)) {
        var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), "");
        editor.update(EditorState.push(editorState, contentState, "insert-characters"));
      }
      return;
    }
    if (command === "undo") {
      keyCommandUndo(e2, editorState, editor.update);
      return;
    }
    e2.preventDefault();
    if (editor.props.handleKeyCommand && isEventHandled(editor.props.handleKeyCommand(command, editorState, e2.timeStamp))) {
      return;
    }
    var newState = onKeyCommand(command, editorState, e2);
    if (newState !== editorState) {
      editor.update(newState);
    }
  }
  editOnKeyDown_1 = editOnKeyDown;
  return editOnKeyDown_1;
}
var URI_1;
var hasRequiredURI;
function requireURI() {
  if (hasRequiredURI) return URI_1;
  hasRequiredURI = 1;
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var URI = /* @__PURE__ */ (function() {
    function URI2(uri) {
      _defineProperty2(this, "_uri", void 0);
      this._uri = uri;
    }
    var _proto = URI2.prototype;
    _proto.toString = function toString5() {
      return this._uri;
    };
    return URI2;
  })();
  URI_1 = URI;
  return URI_1;
}
var getSafeBodyFromHTML_1;
var hasRequiredGetSafeBodyFromHTML;
function requireGetSafeBodyFromHTML() {
  if (hasRequiredGetSafeBodyFromHTML) return getSafeBodyFromHTML_1;
  hasRequiredGetSafeBodyFromHTML = 1;
  var UserAgent = requireUserAgent();
  var invariant2 = requireInvariant();
  var isOldIE = UserAgent.isBrowser("IE <= 9");
  function getSafeBodyFromHTML(html) {
    var doc;
    var root = null;
    if (!isOldIE && document.implementation && document.implementation.createHTMLDocument) {
      doc = document.implementation.createHTMLDocument("foo");
      !doc.documentElement ? invariant2(false) : void 0;
      doc.documentElement.innerHTML = html;
      root = doc.getElementsByTagName("body")[0];
    }
    return root;
  }
  getSafeBodyFromHTML_1 = getSafeBodyFromHTML;
  return getSafeBodyFromHTML_1;
}
var isHTMLAnchorElement_1;
var hasRequiredIsHTMLAnchorElement;
function requireIsHTMLAnchorElement() {
  if (hasRequiredIsHTMLAnchorElement) return isHTMLAnchorElement_1;
  hasRequiredIsHTMLAnchorElement = 1;
  var isElement = requireIsElement();
  function isHTMLAnchorElement(node) {
    if (!node || !node.ownerDocument) {
      return false;
    }
    return isElement(node) && node.nodeName === "A";
  }
  isHTMLAnchorElement_1 = isHTMLAnchorElement;
  return isHTMLAnchorElement_1;
}
var isHTMLImageElement_1;
var hasRequiredIsHTMLImageElement;
function requireIsHTMLImageElement() {
  if (hasRequiredIsHTMLImageElement) return isHTMLImageElement_1;
  hasRequiredIsHTMLImageElement = 1;
  var isElement = requireIsElement();
  function isHTMLImageElement(node) {
    if (!node || !node.ownerDocument) {
      return false;
    }
    return isElement(node) && node.nodeName === "IMG";
  }
  isHTMLImageElement_1 = isHTMLImageElement;
  return isHTMLImageElement_1;
}
var convertFromHTMLToContentBlocks_1;
var hasRequiredConvertFromHTMLToContentBlocks;
function requireConvertFromHTMLToContentBlocks() {
  if (hasRequiredConvertFromHTMLToContentBlocks) return convertFromHTMLToContentBlocks_1;
  hasRequiredConvertFromHTMLToContentBlocks = 1;
  var _knownListItemDepthCl;
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var CharacterMetadata = requireCharacterMetadata();
  var ContentBlock = requireContentBlock();
  var ContentBlockNode = requireContentBlockNode();
  var DefaultDraftBlockRenderMap = requireDefaultDraftBlockRenderMap();
  var DraftEntity = requireDraftEntity();
  var URI = requireURI();
  var cx = requireCx();
  var generateRandomKey = requireGenerateRandomKey();
  var getSafeBodyFromHTML = requireGetSafeBodyFromHTML();
  var gkx2 = requireGkx();
  var _require = requireImmutable(), List2 = _require.List, Map2 = _require.Map, OrderedSet2 = _require.OrderedSet;
  var isHTMLAnchorElement = requireIsHTMLAnchorElement();
  var isHTMLBRElement = requireIsHTMLBRElement();
  var isHTMLElement2 = requireIsHTMLElement();
  var isHTMLImageElement = requireIsHTMLImageElement();
  var experimentalTreeDataSupport = gkx2("draft_tree_data_support");
  var NBSP = "&nbsp;";
  var SPACE = " ";
  var REGEX_CR = new RegExp("\r", "g");
  var REGEX_LF = new RegExp("\n", "g");
  var REGEX_LEADING_LF = new RegExp("^\n", "g");
  var REGEX_NBSP = new RegExp(NBSP, "g");
  var REGEX_CARRIAGE = new RegExp("&#13;?", "g");
  var REGEX_ZWS = new RegExp("&#8203;?", "g");
  var boldValues = ["bold", "bolder", "500", "600", "700", "800", "900"];
  var notBoldValues = ["light", "lighter", "normal", "100", "200", "300", "400"];
  var anchorAttr = ["className", "href", "rel", "target", "title"];
  var imgAttr = ["alt", "className", "height", "src", "width"];
  var knownListItemDepthClasses = (_knownListItemDepthCl = {}, _defineProperty2(_knownListItemDepthCl, cx("public/DraftStyleDefault/depth0"), 0), _defineProperty2(_knownListItemDepthCl, cx("public/DraftStyleDefault/depth1"), 1), _defineProperty2(_knownListItemDepthCl, cx("public/DraftStyleDefault/depth2"), 2), _defineProperty2(_knownListItemDepthCl, cx("public/DraftStyleDefault/depth3"), 3), _defineProperty2(_knownListItemDepthCl, cx("public/DraftStyleDefault/depth4"), 4), _knownListItemDepthCl);
  var HTMLTagToRawInlineStyleMap = Map2({
    b: "BOLD",
    code: "CODE",
    del: "STRIKETHROUGH",
    em: "ITALIC",
    i: "ITALIC",
    s: "STRIKETHROUGH",
    strike: "STRIKETHROUGH",
    strong: "BOLD",
    u: "UNDERLINE",
    mark: "HIGHLIGHT"
  });
  var buildBlockTypeMap = function buildBlockTypeMap2(blockRenderMap) {
    var blockTypeMap = {};
    blockRenderMap.mapKeys(function(blockType, desc) {
      var elements = [desc.element];
      if (desc.aliasedElements !== void 0) {
        elements.push.apply(elements, desc.aliasedElements);
      }
      elements.forEach(function(element) {
        if (blockTypeMap[element] === void 0) {
          blockTypeMap[element] = blockType;
        } else if (typeof blockTypeMap[element] === "string") {
          blockTypeMap[element] = [blockTypeMap[element], blockType];
        } else {
          blockTypeMap[element].push(blockType);
        }
      });
    });
    return Map2(blockTypeMap);
  };
  var detectInlineStyle = function detectInlineStyle2(node) {
    if (isHTMLElement2(node)) {
      var element = node;
      if (element.style.fontFamily.includes("monospace")) {
        return "CODE";
      }
    }
    return null;
  };
  var getListItemDepth = function getListItemDepth2(node) {
    var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    Object.keys(knownListItemDepthClasses).some(function(depthClass) {
      if (node.classList.contains(depthClass)) {
        depth = knownListItemDepthClasses[depthClass];
      }
    });
    return depth;
  };
  var isValidAnchor = function isValidAnchor2(node) {
    if (!isHTMLAnchorElement(node)) {
      return false;
    }
    var anchorNode = node;
    if (!anchorNode.href || anchorNode.protocol !== "http:" && anchorNode.protocol !== "https:" && anchorNode.protocol !== "mailto:" && anchorNode.protocol !== "tel:") {
      return false;
    }
    try {
      var _23 = new URI(anchorNode.href);
      return true;
    } catch (_24) {
      return false;
    }
  };
  var isValidImage = function isValidImage2(node) {
    if (!isHTMLImageElement(node)) {
      return false;
    }
    var imageNode = node;
    return !!(imageNode.attributes.getNamedItem("src") && imageNode.attributes.getNamedItem("src").value);
  };
  var styleFromNodeAttributes = function styleFromNodeAttributes2(node, style) {
    if (!isHTMLElement2(node)) {
      return style;
    }
    var htmlElement = node;
    var fontWeight = htmlElement.style.fontWeight;
    var fontStyle = htmlElement.style.fontStyle;
    var textDecoration = htmlElement.style.textDecoration;
    return style.withMutations(function(style2) {
      if (boldValues.indexOf(fontWeight) >= 0) {
        style2.add("BOLD");
      } else if (notBoldValues.indexOf(fontWeight) >= 0) {
        style2.remove("BOLD");
      }
      if (fontStyle === "italic") {
        style2.add("ITALIC");
      } else if (fontStyle === "normal") {
        style2.remove("ITALIC");
      }
      if (textDecoration === "underline") {
        style2.add("UNDERLINE");
      }
      if (textDecoration === "line-through") {
        style2.add("STRIKETHROUGH");
      }
      if (textDecoration === "none") {
        style2.remove("UNDERLINE");
        style2.remove("STRIKETHROUGH");
      }
    });
  };
  var isListNode = function isListNode2(nodeName) {
    return nodeName === "ul" || nodeName === "ol";
  };
  var ContentBlocksBuilder = /* @__PURE__ */ (function() {
    function ContentBlocksBuilder2(blockTypeMap, disambiguate) {
      _defineProperty2(this, "characterList", List2());
      _defineProperty2(this, "currentBlockType", "unstyled");
      _defineProperty2(this, "currentDepth", 0);
      _defineProperty2(this, "currentEntity", null);
      _defineProperty2(this, "currentText", "");
      _defineProperty2(this, "wrapper", null);
      _defineProperty2(this, "blockConfigs", []);
      _defineProperty2(this, "contentBlocks", []);
      _defineProperty2(this, "entityMap", DraftEntity);
      _defineProperty2(this, "blockTypeMap", void 0);
      _defineProperty2(this, "disambiguate", void 0);
      this.clear();
      this.blockTypeMap = blockTypeMap;
      this.disambiguate = disambiguate;
    }
    var _proto = ContentBlocksBuilder2.prototype;
    _proto.clear = function clear3() {
      this.characterList = List2();
      this.blockConfigs = [];
      this.currentBlockType = "unstyled";
      this.currentDepth = 0;
      this.currentEntity = null;
      this.currentText = "";
      this.entityMap = DraftEntity;
      this.wrapper = null;
      this.contentBlocks = [];
    };
    _proto.addDOMNode = function addDOMNode(node) {
      var _this$blockConfigs;
      this.contentBlocks = [];
      this.currentDepth = 0;
      (_this$blockConfigs = this.blockConfigs).push.apply(_this$blockConfigs, this._toBlockConfigs([node], OrderedSet2()));
      this._trimCurrentText();
      if (this.currentText !== "") {
        this.blockConfigs.push(this._makeBlockConfig());
      }
      return this;
    };
    _proto.getContentBlocks = function getContentBlocks() {
      if (this.contentBlocks.length === 0) {
        if (experimentalTreeDataSupport) {
          this._toContentBlocks(this.blockConfigs);
        } else {
          this._toFlatContentBlocks(this.blockConfigs);
        }
      }
      return {
        contentBlocks: this.contentBlocks,
        entityMap: this.entityMap
      };
    };
    _proto._makeBlockConfig = function _makeBlockConfig() {
      var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var key = config.key || generateRandomKey();
      var block = _objectSpread3({
        key,
        type: this.currentBlockType,
        text: this.currentText,
        characterList: this.characterList,
        depth: this.currentDepth,
        parent: null,
        children: List2(),
        prevSibling: null,
        nextSibling: null,
        childConfigs: []
      }, config);
      this.characterList = List2();
      this.currentBlockType = "unstyled";
      this.currentText = "";
      return block;
    };
    _proto._toBlockConfigs = function _toBlockConfigs(nodes, style) {
      var blockConfigs = [];
      for (var i2 = 0; i2 < nodes.length; i2++) {
        var node = nodes[i2];
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName === "body" || isListNode(nodeName)) {
          this._trimCurrentText();
          if (this.currentText !== "") {
            blockConfigs.push(this._makeBlockConfig());
          }
          var wasCurrentDepth = this.currentDepth;
          var wasWrapper = this.wrapper;
          if (isListNode(nodeName)) {
            this.wrapper = nodeName;
            if (isListNode(wasWrapper)) {
              this.currentDepth++;
            }
          }
          blockConfigs.push.apply(blockConfigs, this._toBlockConfigs(Array.from(node.childNodes), style));
          this.currentDepth = wasCurrentDepth;
          this.wrapper = wasWrapper;
          continue;
        }
        var blockType = this.blockTypeMap.get(nodeName);
        if (blockType !== void 0) {
          this._trimCurrentText();
          if (this.currentText !== "") {
            blockConfigs.push(this._makeBlockConfig());
          }
          var _wasCurrentDepth = this.currentDepth;
          var _wasWrapper = this.wrapper;
          this.wrapper = nodeName === "pre" ? "pre" : this.wrapper;
          if (typeof blockType !== "string") {
            blockType = this.disambiguate(nodeName, this.wrapper) || blockType[0] || "unstyled";
          }
          if (!experimentalTreeDataSupport && isHTMLElement2(node) && (blockType === "unordered-list-item" || blockType === "ordered-list-item")) {
            var htmlElement = node;
            this.currentDepth = getListItemDepth(htmlElement, this.currentDepth);
          }
          var key = generateRandomKey();
          var childConfigs = this._toBlockConfigs(Array.from(node.childNodes), style);
          this._trimCurrentText();
          blockConfigs.push(this._makeBlockConfig({
            key,
            childConfigs,
            type: blockType
          }));
          this.currentDepth = _wasCurrentDepth;
          this.wrapper = _wasWrapper;
          continue;
        }
        if (nodeName === "#text") {
          this._addTextNode(node, style);
          continue;
        }
        if (nodeName === "br") {
          this._addBreakNode(node, style);
          continue;
        }
        if (isValidImage(node)) {
          this._addImgNode(node, style);
          continue;
        }
        if (isValidAnchor(node)) {
          this._addAnchorNode(node, blockConfigs, style);
          continue;
        }
        var newStyle = style;
        if (HTMLTagToRawInlineStyleMap.has(nodeName)) {
          newStyle = newStyle.add(HTMLTagToRawInlineStyleMap.get(nodeName));
        }
        newStyle = styleFromNodeAttributes(node, newStyle);
        var inlineStyle = detectInlineStyle(node);
        if (inlineStyle != null) {
          newStyle = newStyle.add(inlineStyle);
        }
        blockConfigs.push.apply(blockConfigs, this._toBlockConfigs(Array.from(node.childNodes), newStyle));
      }
      return blockConfigs;
    };
    _proto._appendText = function _appendText(text, style) {
      var _this$characterList;
      this.currentText += text;
      var characterMetadata = CharacterMetadata.create({
        style,
        entity: this.currentEntity
      });
      this.characterList = (_this$characterList = this.characterList).push.apply(_this$characterList, Array(text.length).fill(characterMetadata));
    };
    _proto._trimCurrentText = function _trimCurrentText() {
      var l2 = this.currentText.length;
      var begin = l2 - this.currentText.trimLeft().length;
      var end = this.currentText.trimRight().length;
      var entity = this.characterList.findEntry(function(characterMetadata) {
        return characterMetadata.getEntity() !== null;
      });
      begin = entity !== void 0 ? Math.min(begin, entity[0]) : begin;
      entity = this.characterList.reverse().findEntry(function(characterMetadata) {
        return characterMetadata.getEntity() !== null;
      });
      end = entity !== void 0 ? Math.max(end, l2 - entity[0]) : end;
      if (begin > end) {
        this.currentText = "";
        this.characterList = List2();
      } else {
        this.currentText = this.currentText.slice(begin, end);
        this.characterList = this.characterList.slice(begin, end);
      }
    };
    _proto._addTextNode = function _addTextNode(node, style) {
      var text = node.textContent;
      var trimmedText = text.trim();
      if (trimmedText === "" && this.wrapper !== "pre") {
        text = " ";
      }
      if (this.wrapper !== "pre") {
        text = text.replace(REGEX_LEADING_LF, "");
        text = text.replace(REGEX_LF, SPACE);
      }
      this._appendText(text, style);
    };
    _proto._addBreakNode = function _addBreakNode(node, style) {
      if (!isHTMLBRElement(node)) {
        return;
      }
      this._appendText("\n", style);
    };
    _proto._addImgNode = function _addImgNode(node, style) {
      if (!isHTMLImageElement(node)) {
        return;
      }
      var image = node;
      var entityConfig = {};
      imgAttr.forEach(function(attr) {
        var imageAttribute = image.getAttribute(attr);
        if (imageAttribute) {
          entityConfig[attr] = imageAttribute;
        }
      });
      this.currentEntity = this.entityMap.__create("IMAGE", "IMMUTABLE", entityConfig);
      if (gkx2("draftjs_fix_paste_for_img")) {
        if (image.getAttribute("role") !== "presentation") {
          this._appendText("", style);
        }
      } else {
        this._appendText("", style);
      }
      this.currentEntity = null;
    };
    _proto._addAnchorNode = function _addAnchorNode(node, blockConfigs, style) {
      if (!isHTMLAnchorElement(node)) {
        return;
      }
      var anchor = node;
      var entityConfig = {};
      anchorAttr.forEach(function(attr) {
        var anchorAttribute = anchor.getAttribute(attr);
        if (anchorAttribute) {
          entityConfig[attr] = anchorAttribute;
        }
      });
      entityConfig.url = new URI(anchor.href).toString();
      this.currentEntity = this.entityMap.__create("LINK", "MUTABLE", entityConfig || {});
      blockConfigs.push.apply(blockConfigs, this._toBlockConfigs(Array.from(node.childNodes), style));
      this.currentEntity = null;
    };
    _proto._toContentBlocks = function _toContentBlocks(blockConfigs) {
      var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var l2 = blockConfigs.length - 1;
      for (var i2 = 0; i2 <= l2; i2++) {
        var config = blockConfigs[i2];
        config.parent = parent;
        config.prevSibling = i2 > 0 ? blockConfigs[i2 - 1].key : null;
        config.nextSibling = i2 < l2 ? blockConfigs[i2 + 1].key : null;
        config.children = List2(config.childConfigs.map(function(child) {
          return child.key;
        }));
        this.contentBlocks.push(new ContentBlockNode(_objectSpread3({}, config)));
        this._toContentBlocks(config.childConfigs, config.key);
      }
    };
    _proto._hoistContainersInBlockConfigs = function _hoistContainersInBlockConfigs(blockConfigs) {
      var _this = this;
      var hoisted = List2(blockConfigs).flatMap(function(blockConfig) {
        if (blockConfig.type !== "unstyled" || blockConfig.text !== "") {
          return [blockConfig];
        }
        return _this._hoistContainersInBlockConfigs(blockConfig.childConfigs);
      });
      return hoisted;
    };
    _proto._toFlatContentBlocks = function _toFlatContentBlocks(blockConfigs) {
      var _this2 = this;
      var cleanConfigs = this._hoistContainersInBlockConfigs(blockConfigs);
      cleanConfigs.forEach(function(config) {
        var _this2$_extractTextFr = _this2._extractTextFromBlockConfigs(config.childConfigs), text = _this2$_extractTextFr.text, characterList = _this2$_extractTextFr.characterList;
        _this2.contentBlocks.push(new ContentBlock(_objectSpread3({}, config, {
          text: config.text + text,
          characterList: config.characterList.concat(characterList)
        })));
      });
    };
    _proto._extractTextFromBlockConfigs = function _extractTextFromBlockConfigs(blockConfigs) {
      var l2 = blockConfigs.length - 1;
      var text = "";
      var characterList = List2();
      for (var i2 = 0; i2 <= l2; i2++) {
        var config = blockConfigs[i2];
        text += config.text;
        characterList = characterList.concat(config.characterList);
        if (text !== "" && config.type !== "unstyled") {
          text += "\n";
          characterList = characterList.push(characterList.last());
        }
        var children = this._extractTextFromBlockConfigs(config.childConfigs);
        text += children.text;
        characterList = characterList.concat(children.characterList);
      }
      return {
        text,
        characterList
      };
    };
    return ContentBlocksBuilder2;
  })();
  var convertFromHTMLToContentBlocks = function convertFromHTMLToContentBlocks2(html) {
    var DOMBuilder = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getSafeBodyFromHTML;
    var blockRenderMap = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DefaultDraftBlockRenderMap;
    html = html.trim().replace(REGEX_CR, "").replace(REGEX_NBSP, SPACE).replace(REGEX_CARRIAGE, "").replace(REGEX_ZWS, "");
    var safeBody = DOMBuilder(html);
    if (!safeBody) {
      return null;
    }
    var blockTypeMap = buildBlockTypeMap(blockRenderMap);
    var disambiguate = function disambiguate2(tag, wrapper) {
      if (tag === "li") {
        return wrapper === "ol" ? "ordered-list-item" : "unordered-list-item";
      }
      return null;
    };
    return new ContentBlocksBuilder(blockTypeMap, disambiguate).addDOMNode(safeBody).getContentBlocks();
  };
  convertFromHTMLToContentBlocks_1 = convertFromHTMLToContentBlocks;
  return convertFromHTMLToContentBlocks_1;
}
var DraftPasteProcessor_1;
var hasRequiredDraftPasteProcessor;
function requireDraftPasteProcessor() {
  if (hasRequiredDraftPasteProcessor) return DraftPasteProcessor_1;
  hasRequiredDraftPasteProcessor = 1;
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ContentBlock = requireContentBlock();
  var ContentBlockNode = requireContentBlockNode();
  var convertFromHTMLToContentBlocks = requireConvertFromHTMLToContentBlocks();
  var generateRandomKey = requireGenerateRandomKey();
  var getSafeBodyFromHTML = requireGetSafeBodyFromHTML();
  var gkx2 = requireGkx();
  var Immutable2 = requireImmutable();
  var sanitizeDraftText = requireSanitizeDraftText();
  var List2 = Immutable2.List, Repeat2 = Immutable2.Repeat;
  var experimentalTreeDataSupport = gkx2("draft_tree_data_support");
  var ContentBlockRecord = experimentalTreeDataSupport ? ContentBlockNode : ContentBlock;
  var DraftPasteProcessor = {
    processHTML: function processHTML(html, blockRenderMap) {
      return convertFromHTMLToContentBlocks(html, getSafeBodyFromHTML, blockRenderMap);
    },
    processText: function processText(textBlocks, character, type) {
      return textBlocks.reduce(function(acc, textLine, index) {
        textLine = sanitizeDraftText(textLine);
        var key = generateRandomKey();
        var blockNodeConfig = {
          key,
          type,
          text: textLine,
          characterList: List2(Repeat2(character, textLine.length))
        };
        if (experimentalTreeDataSupport && index !== 0) {
          var prevSiblingIndex = index - 1;
          var previousBlock = acc[prevSiblingIndex] = acc[prevSiblingIndex].merge({
            nextSibling: key
          });
          blockNodeConfig = _objectSpread3({}, blockNodeConfig, {
            prevSibling: previousBlock.getKey()
          });
        }
        acc.push(new ContentBlockRecord(blockNodeConfig));
        return acc;
      }, []);
    }
  };
  DraftPasteProcessor_1 = DraftPasteProcessor;
  return DraftPasteProcessor_1;
}
var adjustBlockDepthForContentState_1;
var hasRequiredAdjustBlockDepthForContentState;
function requireAdjustBlockDepthForContentState() {
  if (hasRequiredAdjustBlockDepthForContentState) return adjustBlockDepthForContentState_1;
  hasRequiredAdjustBlockDepthForContentState = 1;
  function adjustBlockDepthForContentState(contentState, selectionState, adjustment, maxDepth) {
    var startKey = selectionState.getStartKey();
    var endKey = selectionState.getEndKey();
    var blockMap = contentState.getBlockMap();
    var blocks = blockMap.toSeq().skipUntil(function(_23, k2) {
      return k2 === startKey;
    }).takeUntil(function(_23, k2) {
      return k2 === endKey;
    }).concat([[endKey, blockMap.get(endKey)]]).map(function(block) {
      var depth = block.getDepth() + adjustment;
      depth = Math.max(0, Math.min(depth, maxDepth));
      return block.set("depth", depth);
    });
    blockMap = blockMap.merge(blocks);
    return contentState.merge({
      blockMap,
      selectionBefore: selectionState,
      selectionAfter: selectionState
    });
  }
  adjustBlockDepthForContentState_1 = adjustBlockDepthForContentState;
  return adjustBlockDepthForContentState_1;
}
var RichTextEditorUtil_1;
var hasRequiredRichTextEditorUtil;
function requireRichTextEditorUtil() {
  if (hasRequiredRichTextEditorUtil) return RichTextEditorUtil_1;
  hasRequiredRichTextEditorUtil = 1;
  var DraftModifier = requireDraftModifier();
  var EditorState = requireEditorState();
  var adjustBlockDepthForContentState = requireAdjustBlockDepthForContentState();
  var nullthrows = requireNullthrows();
  var RichTextEditorUtil = {
    currentBlockContainsLink: function currentBlockContainsLink(editorState) {
      var selection = editorState.getSelection();
      var contentState = editorState.getCurrentContent();
      var entityMap = contentState.getEntityMap();
      return contentState.getBlockForKey(selection.getAnchorKey()).getCharacterList().slice(selection.getStartOffset(), selection.getEndOffset()).some(function(v2) {
        var entity = v2.getEntity();
        return !!entity && entityMap.__get(entity).getType() === "LINK";
      });
    },
    getCurrentBlockType: function getCurrentBlockType(editorState) {
      var selection = editorState.getSelection();
      return editorState.getCurrentContent().getBlockForKey(selection.getStartKey()).getType();
    },
    getDataObjectForLinkURL: function getDataObjectForLinkURL(uri) {
      return {
        url: uri.toString()
      };
    },
    handleKeyCommand: function handleKeyCommand(editorState, command, eventTimeStamp) {
      switch (command) {
        case "bold":
          return RichTextEditorUtil.toggleInlineStyle(editorState, "BOLD");
        case "italic":
          return RichTextEditorUtil.toggleInlineStyle(editorState, "ITALIC");
        case "underline":
          return RichTextEditorUtil.toggleInlineStyle(editorState, "UNDERLINE");
        case "code":
          return RichTextEditorUtil.toggleCode(editorState);
        case "backspace":
        case "backspace-word":
        case "backspace-to-start-of-line":
          return RichTextEditorUtil.onBackspace(editorState);
        case "delete":
        case "delete-word":
        case "delete-to-end-of-block":
          return RichTextEditorUtil.onDelete(editorState);
        default:
          return null;
      }
    },
    insertSoftNewline: function insertSoftNewline(editorState) {
      var contentState = DraftModifier.insertText(editorState.getCurrentContent(), editorState.getSelection(), "\n", editorState.getCurrentInlineStyle(), null);
      var newEditorState = EditorState.push(editorState, contentState, "insert-characters");
      return EditorState.forceSelection(newEditorState, contentState.getSelectionAfter());
    },
    /**
     * For collapsed selections at the start of styled blocks, backspace should
     * just remove the existing style.
     */
    onBackspace: function onBackspace(editorState) {
      var selection = editorState.getSelection();
      if (!selection.isCollapsed() || selection.getAnchorOffset() || selection.getFocusOffset()) {
        return null;
      }
      var content = editorState.getCurrentContent();
      var startKey = selection.getStartKey();
      var blockBefore = content.getBlockBefore(startKey);
      if (blockBefore && blockBefore.getType() === "atomic") {
        var blockMap = content.getBlockMap()["delete"](blockBefore.getKey());
        var withoutAtomicBlock = content.merge({
          blockMap,
          selectionAfter: selection
        });
        if (withoutAtomicBlock !== content) {
          return EditorState.push(editorState, withoutAtomicBlock, "remove-range");
        }
      }
      var withoutBlockStyle = RichTextEditorUtil.tryToRemoveBlockStyle(editorState);
      if (withoutBlockStyle) {
        return EditorState.push(editorState, withoutBlockStyle, "change-block-type");
      }
      return null;
    },
    onDelete: function onDelete(editorState) {
      var selection = editorState.getSelection();
      if (!selection.isCollapsed()) {
        return null;
      }
      var content = editorState.getCurrentContent();
      var startKey = selection.getStartKey();
      var block = content.getBlockForKey(startKey);
      var length = block.getLength();
      if (selection.getStartOffset() < length) {
        return null;
      }
      var blockAfter = content.getBlockAfter(startKey);
      if (!blockAfter || blockAfter.getType() !== "atomic") {
        return null;
      }
      var atomicBlockTarget = selection.merge({
        focusKey: blockAfter.getKey(),
        focusOffset: blockAfter.getLength()
      });
      var withoutAtomicBlock = DraftModifier.removeRange(content, atomicBlockTarget, "forward");
      if (withoutAtomicBlock !== content) {
        return EditorState.push(editorState, withoutAtomicBlock, "remove-range");
      }
      return null;
    },
    onTab: function onTab(event2, editorState, maxDepth) {
      var selection = editorState.getSelection();
      var key = selection.getAnchorKey();
      if (key !== selection.getFocusKey()) {
        return editorState;
      }
      var content = editorState.getCurrentContent();
      var block = content.getBlockForKey(key);
      var type = block.getType();
      if (type !== "unordered-list-item" && type !== "ordered-list-item") {
        return editorState;
      }
      event2.preventDefault();
      var depth = block.getDepth();
      if (!event2.shiftKey && depth === maxDepth) {
        return editorState;
      }
      var withAdjustment = adjustBlockDepthForContentState(content, selection, event2.shiftKey ? -1 : 1, maxDepth);
      return EditorState.push(editorState, withAdjustment, "adjust-depth");
    },
    toggleBlockType: function toggleBlockType(editorState, blockType) {
      var selection = editorState.getSelection();
      var startKey = selection.getStartKey();
      var endKey = selection.getEndKey();
      var content = editorState.getCurrentContent();
      var target = selection;
      if (startKey !== endKey && selection.getEndOffset() === 0) {
        var blockBefore = nullthrows(content.getBlockBefore(endKey));
        endKey = blockBefore.getKey();
        target = target.merge({
          anchorKey: startKey,
          anchorOffset: selection.getStartOffset(),
          focusKey: endKey,
          focusOffset: blockBefore.getLength(),
          isBackward: false
        });
      }
      var hasAtomicBlock = content.getBlockMap().skipWhile(function(_23, k2) {
        return k2 !== startKey;
      }).reverse().skipWhile(function(_23, k2) {
        return k2 !== endKey;
      }).some(function(v2) {
        return v2.getType() === "atomic";
      });
      if (hasAtomicBlock) {
        return editorState;
      }
      var typeToSet = content.getBlockForKey(startKey).getType() === blockType ? "unstyled" : blockType;
      return EditorState.push(editorState, DraftModifier.setBlockType(content, target, typeToSet), "change-block-type");
    },
    toggleCode: function toggleCode(editorState) {
      var selection = editorState.getSelection();
      var anchorKey = selection.getAnchorKey();
      var focusKey = selection.getFocusKey();
      if (selection.isCollapsed() || anchorKey !== focusKey) {
        return RichTextEditorUtil.toggleBlockType(editorState, "code-block");
      }
      return RichTextEditorUtil.toggleInlineStyle(editorState, "CODE");
    },
    /**
     * Toggle the specified inline style for the selection. If the
     * user's selection is collapsed, apply or remove the style for the
     * internal state. If it is not collapsed, apply the change directly
     * to the document state.
     */
    toggleInlineStyle: function toggleInlineStyle(editorState, inlineStyle) {
      var selection = editorState.getSelection();
      var currentStyle = editorState.getCurrentInlineStyle();
      if (selection.isCollapsed()) {
        return EditorState.setInlineStyleOverride(editorState, currentStyle.has(inlineStyle) ? currentStyle.remove(inlineStyle) : currentStyle.add(inlineStyle));
      }
      var content = editorState.getCurrentContent();
      var newContent;
      if (currentStyle.has(inlineStyle)) {
        newContent = DraftModifier.removeInlineStyle(content, selection, inlineStyle);
      } else {
        newContent = DraftModifier.applyInlineStyle(content, selection, inlineStyle);
      }
      return EditorState.push(editorState, newContent, "change-inline-style");
    },
    toggleLink: function toggleLink(editorState, targetSelection, entityKey) {
      var withoutLink = DraftModifier.applyEntity(editorState.getCurrentContent(), targetSelection, entityKey);
      return EditorState.push(editorState, withoutLink, "apply-entity");
    },
    /**
     * When a collapsed cursor is at the start of a styled block, changes block
     * type to 'unstyled'. Returns null if selection does not meet that criteria.
     */
    tryToRemoveBlockStyle: function tryToRemoveBlockStyle(editorState) {
      var selection = editorState.getSelection();
      var offset = selection.getAnchorOffset();
      if (selection.isCollapsed() && offset === 0) {
        var key = selection.getAnchorKey();
        var content = editorState.getCurrentContent();
        var block = content.getBlockForKey(key);
        var type = block.getType();
        var blockBefore = content.getBlockBefore(key);
        if (type === "code-block" && blockBefore && blockBefore.getType() === "code-block" && blockBefore.getLength() !== 0) {
          return null;
        }
        if (type !== "unstyled") {
          return DraftModifier.setBlockType(content, selection, "unstyled");
        }
      }
      return null;
    }
  };
  RichTextEditorUtil_1 = RichTextEditorUtil;
  return RichTextEditorUtil_1;
}
var splitTextIntoTextBlocks_1;
var hasRequiredSplitTextIntoTextBlocks;
function requireSplitTextIntoTextBlocks() {
  if (hasRequiredSplitTextIntoTextBlocks) return splitTextIntoTextBlocks_1;
  hasRequiredSplitTextIntoTextBlocks = 1;
  var NEWLINE_REGEX = /\r\n?|\n/g;
  function splitTextIntoTextBlocks(text) {
    return text.split(NEWLINE_REGEX);
  }
  splitTextIntoTextBlocks_1 = splitTextIntoTextBlocks;
  return splitTextIntoTextBlocks_1;
}
var editOnPaste_1;
var hasRequiredEditOnPaste;
function requireEditOnPaste() {
  if (hasRequiredEditOnPaste) return editOnPaste_1;
  hasRequiredEditOnPaste = 1;
  var BlockMapBuilder = requireBlockMapBuilder();
  var CharacterMetadata = requireCharacterMetadata();
  var DataTransfer = requireDataTransfer();
  var DraftModifier = requireDraftModifier();
  var DraftPasteProcessor = requireDraftPasteProcessor();
  var EditorState = requireEditorState();
  var RichTextEditorUtil = requireRichTextEditorUtil();
  var getEntityKeyForSelection = requireGetEntityKeyForSelection();
  var getTextContentFromFiles = requireGetTextContentFromFiles();
  var isEventHandled = requireIsEventHandled();
  var splitTextIntoTextBlocks = requireSplitTextIntoTextBlocks();
  function editOnPaste(editor, e2) {
    e2.preventDefault();
    var data = new DataTransfer(e2.clipboardData);
    if (!data.isRichText()) {
      var files = data.getFiles();
      var defaultFileText = data.getText();
      if (files.length > 0) {
        if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {
          return;
        }
        getTextContentFromFiles(files, function(fileText) {
          fileText = fileText || defaultFileText;
          if (!fileText) {
            return;
          }
          var editorState2 = editor._latestEditorState;
          var blocks = splitTextIntoTextBlocks(fileText);
          var character2 = CharacterMetadata.create({
            style: editorState2.getCurrentInlineStyle(),
            entity: getEntityKeyForSelection(editorState2.getCurrentContent(), editorState2.getSelection())
          });
          var currentBlockType2 = RichTextEditorUtil.getCurrentBlockType(editorState2);
          var text2 = DraftPasteProcessor.processText(blocks, character2, currentBlockType2);
          var fragment = BlockMapBuilder.createFromArray(text2);
          var withInsertedText = DraftModifier.replaceWithFragment(editorState2.getCurrentContent(), editorState2.getSelection(), fragment);
          editor.update(EditorState.push(editorState2, withInsertedText, "insert-fragment"));
        });
        return;
      }
    }
    var textBlocks = [];
    var text = data.getText();
    var html = data.getHTML();
    var editorState = editor._latestEditorState;
    if (editor.props.formatPastedText) {
      var _editor$props$formatP = editor.props.formatPastedText(text, html), formattedText = _editor$props$formatP.text, formattedHtml = _editor$props$formatP.html;
      text = formattedText;
      html = formattedHtml;
    }
    if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {
      return;
    }
    if (text) {
      textBlocks = splitTextIntoTextBlocks(text);
    }
    if (!editor.props.stripPastedStyles) {
      var internalClipboard = editor.getClipboard();
      if (!editor.props.formatPastedText && data.isRichText() && internalClipboard) {
        var _html;
        if (
          // If the editorKey is present in the pasted HTML, it should be safe to
          // assume this is an internal paste.
          ((_html = html) === null || _html === void 0 ? void 0 : _html.indexOf(editor.getEditorKey())) !== -1 || // The copy may have been made within a single block, in which case the
          // editor key won't be part of the paste. In this case, just check
          // whether the pasted text matches the internal clipboard.
          textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text
        ) {
          editor.update(insertFragment(editor._latestEditorState, internalClipboard));
          return;
        }
      } else if (internalClipboard && data.types.includes("com.apple.webarchive") && !data.types.includes("text/html") && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {
        editor.update(insertFragment(editor._latestEditorState, internalClipboard));
        return;
      }
      if (html) {
        var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);
        if (htmlFragment) {
          var contentBlocks = htmlFragment.contentBlocks, entityMap = htmlFragment.entityMap;
          if (contentBlocks) {
            var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);
            editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));
            return;
          }
        }
      }
      editor.setClipboard(null);
    }
    if (textBlocks.length) {
      var character = CharacterMetadata.create({
        style: editorState.getCurrentInlineStyle(),
        entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())
      });
      var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);
      var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);
      var textMap = BlockMapBuilder.createFromArray(textFragment);
      editor.update(insertFragment(editor._latestEditorState, textMap));
    }
  }
  function insertFragment(editorState, fragment, entityMap) {
    var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);
    return EditorState.push(editorState, newContent.set("entityMap", entityMap), "insert-fragment");
  }
  function areTextBlocksAndClipboardEqual(textBlocks, blockMap) {
    return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function(block, ii) {
      return block.getText() === textBlocks[ii];
    });
  }
  editOnPaste_1 = editOnPaste;
  return editOnPaste_1;
}
var DraftEditorEditHandler_1;
var hasRequiredDraftEditorEditHandler;
function requireDraftEditorEditHandler() {
  if (hasRequiredDraftEditorEditHandler) return DraftEditorEditHandler_1;
  hasRequiredDraftEditorEditHandler = 1;
  var UserAgent = requireUserAgent();
  var onBeforeInput = requireEditOnBeforeInput();
  var onBlur = requireEditOnBlur();
  var onCompositionStart = requireEditOnCompositionStart();
  var onCopy = requireEditOnCopy();
  var onCut = requireEditOnCut();
  var onDragOver = requireEditOnDragOver();
  var onDragStart = requireEditOnDragStart();
  var onFocus2 = requireEditOnFocus();
  var onInput = requireEditOnInput();
  var onKeyDown = requireEditOnKeyDown();
  var onPaste = requireEditOnPaste();
  var onSelect = requireEditOnSelect();
  var isChrome = UserAgent.isBrowser("Chrome");
  var isFirefox = UserAgent.isBrowser("Firefox");
  var selectionHandler = isChrome || isFirefox ? onSelect : function(e2) {
  };
  var DraftEditorEditHandler = {
    onBeforeInput,
    onBlur,
    onCompositionStart,
    onCopy,
    onCut,
    onDragOver,
    onDragStart,
    onFocus: onFocus2,
    onInput,
    onKeyDown,
    onPaste,
    onSelect,
    // In certain cases, contenteditable on chrome does not fire the onSelect
    // event, causing problems with cursor positioning. Therefore, the selection
    // state update handler is added to more events to ensure that the selection
    // state is always synced with the actual cursor positions.
    onMouseUp: selectionHandler,
    onKeyUp: selectionHandler
  };
  DraftEditorEditHandler_1 = DraftEditorEditHandler;
  return DraftEditorEditHandler_1;
}
var DraftEditorFlushControlled;
var hasRequiredDraftEditorFlushControlled;
function requireDraftEditorFlushControlled() {
  if (hasRequiredDraftEditorFlushControlled) return DraftEditorFlushControlled;
  hasRequiredDraftEditorFlushControlled = 1;
  var ReactDOMComet = requireReactDom();
  var flushControlled = ReactDOMComet.unstable_flushControlled;
  DraftEditorFlushControlled = flushControlled;
  return DraftEditorFlushControlled;
}
var DraftEditorPlaceholder_react;
var hasRequiredDraftEditorPlaceholder_react;
function requireDraftEditorPlaceholder_react() {
  if (hasRequiredDraftEditorPlaceholder_react) return DraftEditorPlaceholder_react;
  hasRequiredDraftEditorPlaceholder_react = 1;
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var React2 = requireReact();
  var cx = requireCx();
  var DraftEditorPlaceholder = /* @__PURE__ */ (function(_React$Component) {
    _inheritsLoose2(DraftEditorPlaceholder2, _React$Component);
    function DraftEditorPlaceholder2() {
      return _React$Component.apply(this, arguments) || this;
    }
    var _proto = DraftEditorPlaceholder2.prototype;
    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      return this.props.text !== nextProps.text || this.props.editorState.getSelection().getHasFocus() !== nextProps.editorState.getSelection().getHasFocus();
    };
    _proto.render = function render3() {
      var hasFocus = this.props.editorState.getSelection().getHasFocus();
      var className = cx({
        "public/DraftEditorPlaceholder/root": true,
        "public/DraftEditorPlaceholder/hasFocus": hasFocus
      });
      var contentStyle = {
        whiteSpace: "pre-wrap"
      };
      return React2.createElement("div", {
        className
      }, React2.createElement("div", {
        className: cx("public/DraftEditorPlaceholder/inner"),
        id: this.props.accessibilityID,
        style: contentStyle
      }, this.props.text));
    };
    return DraftEditorPlaceholder2;
  })(React2.Component);
  DraftEditorPlaceholder_react = DraftEditorPlaceholder;
  return DraftEditorPlaceholder_react;
}
var getDefaultKeyBinding_1;
var hasRequiredGetDefaultKeyBinding;
function requireGetDefaultKeyBinding() {
  if (hasRequiredGetDefaultKeyBinding) return getDefaultKeyBinding_1;
  hasRequiredGetDefaultKeyBinding = 1;
  var KeyBindingUtil = requireKeyBindingUtil();
  var Keys2 = requireKeys();
  var UserAgent = requireUserAgent();
  var isOSX = UserAgent.isPlatform("Mac OS X");
  var shouldFixFirefoxMovement = isOSX && UserAgent.isBrowser("Firefox < 29");
  var hasCommandModifier = KeyBindingUtil.hasCommandModifier, isCtrlKeyCommand = KeyBindingUtil.isCtrlKeyCommand;
  function shouldRemoveWord(e2) {
    return isOSX && e2.altKey || isCtrlKeyCommand(e2);
  }
  function getZCommand(e2) {
    if (!hasCommandModifier(e2)) {
      return null;
    }
    return e2.shiftKey ? "redo" : "undo";
  }
  function getDeleteCommand(e2) {
    if (!isOSX && e2.shiftKey) {
      return null;
    }
    return shouldRemoveWord(e2) ? "delete-word" : "delete";
  }
  function getBackspaceCommand(e2) {
    if (hasCommandModifier(e2) && isOSX) {
      return "backspace-to-start-of-line";
    }
    return shouldRemoveWord(e2) ? "backspace-word" : "backspace";
  }
  function getDefaultKeyBinding(e2) {
    switch (e2.keyCode) {
      case 66:
        return hasCommandModifier(e2) ? "bold" : null;
      case 68:
        return isCtrlKeyCommand(e2) ? "delete" : null;
      case 72:
        return isCtrlKeyCommand(e2) ? "backspace" : null;
      case 73:
        return hasCommandModifier(e2) ? "italic" : null;
      case 74:
        return hasCommandModifier(e2) ? "code" : null;
      case 75:
        return isOSX && isCtrlKeyCommand(e2) ? "secondary-cut" : null;
      case 77:
        return isCtrlKeyCommand(e2) ? "split-block" : null;
      case 79:
        return isCtrlKeyCommand(e2) ? "split-block" : null;
      case 84:
        return isOSX && isCtrlKeyCommand(e2) ? "transpose-characters" : null;
      case 85:
        return hasCommandModifier(e2) ? "underline" : null;
      case 87:
        return isOSX && isCtrlKeyCommand(e2) ? "backspace-word" : null;
      case 89:
        if (isCtrlKeyCommand(e2)) {
          return isOSX ? "secondary-paste" : "redo";
        }
        return null;
      case 90:
        return getZCommand(e2) || null;
      case Keys2.RETURN:
        return "split-block";
      case Keys2.DELETE:
        return getDeleteCommand(e2);
      case Keys2.BACKSPACE:
        return getBackspaceCommand(e2);
      // LEFT/RIGHT handlers serve as a workaround for a Firefox bug.
      case Keys2.LEFT:
        return shouldFixFirefoxMovement && hasCommandModifier(e2) ? "move-selection-to-start-of-block" : null;
      case Keys2.RIGHT:
        return shouldFixFirefoxMovement && hasCommandModifier(e2) ? "move-selection-to-end-of-block" : null;
      default:
        return null;
    }
  }
  getDefaultKeyBinding_1 = getDefaultKeyBinding;
  return getDefaultKeyBinding_1;
}
var DraftEditor_react;
var hasRequiredDraftEditor_react;
function requireDraftEditor_react() {
  if (hasRequiredDraftEditor_react) return DraftEditor_react;
  hasRequiredDraftEditor_react = 1;
  var _assign = requireObjectAssign();
  function _extends2() {
    _extends2 = _assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _assertThisInitialized2(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var DefaultDraftBlockRenderMap = requireDefaultDraftBlockRenderMap();
  var DefaultDraftInlineStyle2 = requireDefaultDraftInlineStyle();
  var DraftEditorCompositionHandler = requireDraftEditorCompositionHandler();
  var DraftEditorContents = requireDraftEditorContents_react();
  var DraftEditorDragHandler = requireDraftEditorDragHandler();
  var DraftEditorEditHandler = requireDraftEditorEditHandler();
  var flushControlled = requireDraftEditorFlushControlled();
  var DraftEditorPlaceholder = requireDraftEditorPlaceholder_react();
  var DraftEffects2 = requireDraftEffects();
  var EditorState = requireEditorState();
  var React2 = requireReact();
  var Scroll = requireScroll();
  var Style = requireStyle();
  var UserAgent = requireUserAgent();
  var cx = requireCx();
  var generateRandomKey = requireGenerateRandomKey();
  var getDefaultKeyBinding = requireGetDefaultKeyBinding();
  var getScrollPosition2 = requireGetScrollPosition();
  var gkx2 = requireGkx();
  var invariant2 = requireInvariant();
  var isHTMLElement2 = requireIsHTMLElement();
  var nullthrows = requireNullthrows();
  var isIE = UserAgent.isBrowser("IE");
  var allowSpellCheck = !isIE;
  var handlerMap = {
    edit: DraftEditorEditHandler,
    composite: DraftEditorCompositionHandler,
    drag: DraftEditorDragHandler,
    cut: null,
    render: null
  };
  var didInitODS = false;
  var UpdateDraftEditorFlags = /* @__PURE__ */ (function(_React$Component) {
    _inheritsLoose2(UpdateDraftEditorFlags2, _React$Component);
    function UpdateDraftEditorFlags2() {
      return _React$Component.apply(this, arguments) || this;
    }
    var _proto = UpdateDraftEditorFlags2.prototype;
    _proto.render = function render3() {
      return null;
    };
    _proto.componentDidMount = function componentDidMount() {
      this._update();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      this._update();
    };
    _proto._update = function _update() {
      var editor = this.props.editor;
      editor._latestEditorState = this.props.editorState;
      editor._blockSelectEvents = true;
    };
    return UpdateDraftEditorFlags2;
  })(React2.Component);
  var DraftEditor = /* @__PURE__ */ (function(_React$Component2) {
    _inheritsLoose2(DraftEditor2, _React$Component2);
    function DraftEditor2(props) {
      var _this;
      _this = _React$Component2.call(this, props) || this;
      _defineProperty2(_assertThisInitialized2(_this), "_blockSelectEvents", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_clipboard", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_handler", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_dragCount", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_internalDrag", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_editorKey", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_placeholderAccessibilityID", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_latestEditorState", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_latestCommittedEditorState", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_pendingStateFromBeforeInput", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onBeforeInput", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onBlur", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onCharacterData", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onCompositionEnd", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onCompositionStart", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onCopy", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onCut", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onDragEnd", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onDragOver", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onDragStart", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onDrop", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onInput", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onFocus", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onKeyDown", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onKeyPress", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onKeyUp", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onMouseDown", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onMouseUp", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onPaste", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_onSelect", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "editor", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "editorContainer", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "focus", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "blur", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "setMode", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "exitCurrentMode", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "restoreEditorDOM", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "setClipboard", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "getClipboard", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "getEditorKey", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "update", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "onDragEnter", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "onDragLeave", void 0);
      _defineProperty2(_assertThisInitialized2(_this), "_handleEditorContainerRef", function(node) {
        _this.editorContainer = node;
        _this.editor = node !== null ? node.firstChild : null;
      });
      _defineProperty2(_assertThisInitialized2(_this), "focus", function(scrollPosition) {
        var editorState = _this.props.editorState;
        var alreadyHasFocus = editorState.getSelection().getHasFocus();
        var editorNode = _this.editor;
        if (!editorNode) {
          return;
        }
        var scrollParent = Style.getScrollParent(editorNode);
        var _ref = scrollPosition || getScrollPosition2(scrollParent), x2 = _ref.x, y2 = _ref.y;
        !isHTMLElement2(editorNode) ? invariant2(false) : void 0;
        editorNode.focus();
        if (scrollParent === window) {
          window.scrollTo(x2, y2);
        } else {
          Scroll.setTop(scrollParent, y2);
        }
        if (!alreadyHasFocus) {
          _this.update(EditorState.forceSelection(editorState, editorState.getSelection()));
        }
      });
      _defineProperty2(_assertThisInitialized2(_this), "blur", function() {
        var editorNode = _this.editor;
        if (!editorNode) {
          return;
        }
        !isHTMLElement2(editorNode) ? invariant2(false) : void 0;
        editorNode.blur();
      });
      _defineProperty2(_assertThisInitialized2(_this), "setMode", function(mode) {
        var _this$props = _this.props, onPaste = _this$props.onPaste, onCut = _this$props.onCut, onCopy = _this$props.onCopy;
        var editHandler = _objectSpread3({}, handlerMap.edit);
        if (onPaste) {
          editHandler.onPaste = onPaste;
        }
        if (onCut) {
          editHandler.onCut = onCut;
        }
        if (onCopy) {
          editHandler.onCopy = onCopy;
        }
        var handler = _objectSpread3({}, handlerMap, {
          edit: editHandler
        });
        _this._handler = handler[mode];
      });
      _defineProperty2(_assertThisInitialized2(_this), "exitCurrentMode", function() {
        _this.setMode("edit");
      });
      _defineProperty2(_assertThisInitialized2(_this), "restoreEditorDOM", function(scrollPosition) {
        _this.setState({
          contentsKey: _this.state.contentsKey + 1
        }, function() {
          _this.focus(scrollPosition);
        });
      });
      _defineProperty2(_assertThisInitialized2(_this), "setClipboard", function(clipboard) {
        _this._clipboard = clipboard;
      });
      _defineProperty2(_assertThisInitialized2(_this), "getClipboard", function() {
        return _this._clipboard;
      });
      _defineProperty2(_assertThisInitialized2(_this), "update", function(editorState) {
        _this._latestEditorState = editorState;
        _this.props.onChange(editorState);
      });
      _defineProperty2(_assertThisInitialized2(_this), "onDragEnter", function() {
        _this._dragCount++;
      });
      _defineProperty2(_assertThisInitialized2(_this), "onDragLeave", function() {
        _this._dragCount--;
        if (_this._dragCount === 0) {
          _this.exitCurrentMode();
        }
      });
      _this._blockSelectEvents = false;
      _this._clipboard = null;
      _this._handler = null;
      _this._dragCount = 0;
      _this._editorKey = props.editorKey || generateRandomKey();
      _this._placeholderAccessibilityID = "placeholder-" + _this._editorKey;
      _this._latestEditorState = props.editorState;
      _this._latestCommittedEditorState = props.editorState;
      _this._onBeforeInput = _this._buildHandler("onBeforeInput");
      _this._onBlur = _this._buildHandler("onBlur");
      _this._onCharacterData = _this._buildHandler("onCharacterData");
      _this._onCompositionEnd = _this._buildHandler("onCompositionEnd");
      _this._onCompositionStart = _this._buildHandler("onCompositionStart");
      _this._onCopy = _this._buildHandler("onCopy");
      _this._onCut = _this._buildHandler("onCut");
      _this._onDragEnd = _this._buildHandler("onDragEnd");
      _this._onDragOver = _this._buildHandler("onDragOver");
      _this._onDragStart = _this._buildHandler("onDragStart");
      _this._onDrop = _this._buildHandler("onDrop");
      _this._onInput = _this._buildHandler("onInput");
      _this._onFocus = _this._buildHandler("onFocus");
      _this._onKeyDown = _this._buildHandler("onKeyDown");
      _this._onKeyPress = _this._buildHandler("onKeyPress");
      _this._onKeyUp = _this._buildHandler("onKeyUp");
      _this._onMouseDown = _this._buildHandler("onMouseDown");
      _this._onMouseUp = _this._buildHandler("onMouseUp");
      _this._onPaste = _this._buildHandler("onPaste");
      _this._onSelect = _this._buildHandler("onSelect");
      _this.getEditorKey = function() {
        return _this._editorKey;
      };
      _this.state = {
        contentsKey: 0
      };
      return _this;
    }
    var _proto2 = DraftEditor2.prototype;
    _proto2._buildHandler = function _buildHandler(eventName) {
      var _this2 = this;
      return function(e2) {
        if (!_this2.props.readOnly) {
          var method = _this2._handler && _this2._handler[eventName];
          if (method) {
            if (flushControlled) {
              flushControlled(function() {
                return method(_this2, e2);
              });
            } else {
              method(_this2, e2);
            }
          }
        }
      };
    };
    _proto2._showPlaceholder = function _showPlaceholder() {
      return !!this.props.placeholder && !this.props.editorState.isInCompositionMode() && !this.props.editorState.getCurrentContent().hasText();
    };
    _proto2._renderPlaceholder = function _renderPlaceholder() {
      if (this._showPlaceholder()) {
        var placeHolderProps = {
          text: nullthrows(this.props.placeholder),
          editorState: this.props.editorState,
          textAlignment: this.props.textAlignment,
          accessibilityID: this._placeholderAccessibilityID
        };
        return React2.createElement(DraftEditorPlaceholder, placeHolderProps);
      }
      return null;
    };
    _proto2._renderARIADescribedBy = function _renderARIADescribedBy() {
      var describedBy = this.props.ariaDescribedBy || "";
      var placeholderID = this._showPlaceholder() ? this._placeholderAccessibilityID : "";
      return describedBy.replace("{{editor_id_placeholder}}", placeholderID) || void 0;
    };
    _proto2.render = function render3() {
      var _this$props2 = this.props, blockRenderMap = _this$props2.blockRenderMap, blockRendererFn2 = _this$props2.blockRendererFn, blockStyleFn2 = _this$props2.blockStyleFn, customStyleFn = _this$props2.customStyleFn, customStyleMap = _this$props2.customStyleMap, editorState = _this$props2.editorState, preventScroll = _this$props2.preventScroll, readOnly = _this$props2.readOnly, textAlignment = _this$props2.textAlignment, textDirectionality = _this$props2.textDirectionality;
      var rootClass = cx({
        "DraftEditor/root": true,
        "DraftEditor/alignLeft": textAlignment === "left",
        "DraftEditor/alignRight": textAlignment === "right",
        "DraftEditor/alignCenter": textAlignment === "center"
      });
      var contentStyle = {
        outline: "none",
        // fix parent-draggable Safari bug. #1326
        userSelect: "text",
        WebkitUserSelect: "text",
        whiteSpace: "pre-wrap",
        wordWrap: "break-word"
      };
      var ariaRole = this.props.role || "textbox";
      var ariaExpanded = ariaRole === "combobox" ? !!this.props.ariaExpanded : null;
      var editorContentsProps = {
        blockRenderMap,
        blockRendererFn: blockRendererFn2,
        blockStyleFn: blockStyleFn2,
        customStyleMap: _objectSpread3({}, DefaultDraftInlineStyle2, customStyleMap),
        customStyleFn,
        editorKey: this._editorKey,
        editorState,
        preventScroll,
        textDirectionality
      };
      return React2.createElement("div", {
        className: rootClass
      }, this._renderPlaceholder(), React2.createElement("div", {
        className: cx("DraftEditor/editorContainer"),
        ref: this._handleEditorContainerRef
      }, React2.createElement("div", {
        "aria-activedescendant": readOnly ? null : this.props.ariaActiveDescendantID,
        "aria-autocomplete": readOnly ? null : this.props.ariaAutoComplete,
        "aria-controls": readOnly ? null : this.props.ariaControls,
        "aria-describedby": this._renderARIADescribedBy(),
        "aria-expanded": readOnly ? null : ariaExpanded,
        "aria-label": this.props.ariaLabel,
        "aria-labelledby": this.props.ariaLabelledBy,
        "aria-multiline": this.props.ariaMultiline,
        "aria-owns": readOnly ? null : this.props.ariaOwneeID,
        autoCapitalize: this.props.autoCapitalize,
        autoComplete: this.props.autoComplete,
        autoCorrect: this.props.autoCorrect,
        className: cx({
          // Chrome's built-in translation feature mutates the DOM in ways
          // that Draft doesn't expect (ex: adding <font> tags inside
          // DraftEditorLeaf spans) and causes problems. We add notranslate
          // here which makes its autotranslation skip over this subtree.
          notranslate: !readOnly,
          "public/DraftEditor/content": true
        }),
        contentEditable: !readOnly,
        "data-testid": this.props.webDriverTestID,
        onBeforeInput: this._onBeforeInput,
        onBlur: this._onBlur,
        onCompositionEnd: this._onCompositionEnd,
        onCompositionStart: this._onCompositionStart,
        onCopy: this._onCopy,
        onCut: this._onCut,
        onDragEnd: this._onDragEnd,
        onDragEnter: this.onDragEnter,
        onDragLeave: this.onDragLeave,
        onDragOver: this._onDragOver,
        onDragStart: this._onDragStart,
        onDrop: this._onDrop,
        onFocus: this._onFocus,
        onInput: this._onInput,
        onKeyDown: this._onKeyDown,
        onKeyPress: this._onKeyPress,
        onKeyUp: this._onKeyUp,
        onMouseUp: this._onMouseUp,
        onPaste: this._onPaste,
        onSelect: this._onSelect,
        ref: this.props.editorRef,
        role: readOnly ? null : ariaRole,
        spellCheck: allowSpellCheck && this.props.spellCheck,
        style: contentStyle,
        suppressContentEditableWarning: true,
        tabIndex: this.props.tabIndex
      }, React2.createElement(UpdateDraftEditorFlags, {
        editor: this,
        editorState
      }), React2.createElement(DraftEditorContents, _extends2({}, editorContentsProps, {
        key: "contents" + this.state.contentsKey
      })))));
    };
    _proto2.componentDidMount = function componentDidMount() {
      this._blockSelectEvents = false;
      if (!didInitODS && gkx2("draft_ods_enabled")) {
        didInitODS = true;
        DraftEffects2.initODS();
      }
      this.setMode("edit");
      if (isIE) {
        if (!this.editor) {
          globalThis.execCommand("AutoUrlDetect", false, false);
        } else {
          this.editor.ownerDocument.execCommand("AutoUrlDetect", false, false);
        }
      }
    };
    _proto2.componentDidUpdate = function componentDidUpdate() {
      this._blockSelectEvents = false;
      this._latestEditorState = this.props.editorState;
      this._latestCommittedEditorState = this.props.editorState;
    };
    return DraftEditor2;
  })(React2.Component);
  _defineProperty2(DraftEditor, "defaultProps", {
    ariaDescribedBy: "{{editor_id_placeholder}}",
    blockRenderMap: DefaultDraftBlockRenderMap,
    blockRendererFn: function blockRendererFn() {
      return null;
    },
    blockStyleFn: function blockStyleFn() {
      return "";
    },
    keyBindingFn: getDefaultKeyBinding,
    readOnly: false,
    spellCheck: false,
    stripPastedStyles: false
  });
  DraftEditor_react = DraftEditor;
  return DraftEditor_react;
}
var RawDraftContentState = {};
var hasRequiredRawDraftContentState;
function requireRawDraftContentState() {
  if (hasRequiredRawDraftContentState) return RawDraftContentState;
  hasRequiredRawDraftContentState = 1;
  return RawDraftContentState;
}
var DraftStringKey_1;
var hasRequiredDraftStringKey;
function requireDraftStringKey() {
  if (hasRequiredDraftStringKey) return DraftStringKey_1;
  hasRequiredDraftStringKey = 1;
  var DraftStringKey = {
    stringify: function stringify(key) {
      return "_" + String(key);
    },
    unstringify: function unstringify(key) {
      return key.slice(1);
    }
  };
  DraftStringKey_1 = DraftStringKey;
  return DraftStringKey_1;
}
var encodeEntityRanges_1;
var hasRequiredEncodeEntityRanges;
function requireEncodeEntityRanges() {
  if (hasRequiredEncodeEntityRanges) return encodeEntityRanges_1;
  hasRequiredEncodeEntityRanges = 1;
  var DraftStringKey = requireDraftStringKey();
  var UnicodeUtils = requireUnicodeUtils();
  var strlen = UnicodeUtils.strlen;
  function encodeEntityRanges(block, storageMap) {
    var encoded = [];
    block.findEntityRanges(function(character) {
      return !!character.getEntity();
    }, function(start, end) {
      var text = block.getText();
      var key = block.getEntityAt(start);
      encoded.push({
        offset: strlen(text.slice(0, start)),
        length: strlen(text.slice(start, end)),
        // Encode the key as a number for range storage.
        key: Number(storageMap[DraftStringKey.stringify(key)])
      });
    });
    return encoded;
  }
  encodeEntityRanges_1 = encodeEntityRanges;
  return encodeEntityRanges_1;
}
var encodeInlineStyleRanges_1;
var hasRequiredEncodeInlineStyleRanges;
function requireEncodeInlineStyleRanges() {
  if (hasRequiredEncodeInlineStyleRanges) return encodeInlineStyleRanges_1;
  hasRequiredEncodeInlineStyleRanges = 1;
  var UnicodeUtils = requireUnicodeUtils();
  var findRangesImmutable = requireFindRangesImmutable();
  var areEqual = function areEqual2(a2, b2) {
    return a2 === b2;
  };
  var isTruthy = function isTruthy2(a2) {
    return !!a2;
  };
  var EMPTY_ARRAY = [];
  function getEncodedInlinesForType(block, styleList, styleToEncode) {
    var ranges = [];
    var filteredInlines = styleList.map(function(style) {
      return style.has(styleToEncode);
    }).toList();
    findRangesImmutable(
      filteredInlines,
      areEqual,
      // We only want to keep ranges with nonzero style values.
      isTruthy,
      function(start, end) {
        var text = block.getText();
        ranges.push({
          offset: UnicodeUtils.strlen(text.slice(0, start)),
          length: UnicodeUtils.strlen(text.slice(start, end)),
          style: styleToEncode
        });
      }
    );
    return ranges;
  }
  function encodeInlineStyleRanges(block) {
    var styleList = block.getCharacterList().map(function(c2) {
      return c2.getStyle();
    }).toList();
    var ranges = styleList.flatten().toSet().map(function(style) {
      return getEncodedInlinesForType(block, styleList, style);
    });
    return Array.prototype.concat.apply(EMPTY_ARRAY, ranges.toJS());
  }
  encodeInlineStyleRanges_1 = encodeInlineStyleRanges;
  return encodeInlineStyleRanges_1;
}
var convertFromDraftStateToRaw_1;
var hasRequiredConvertFromDraftStateToRaw;
function requireConvertFromDraftStateToRaw() {
  if (hasRequiredConvertFromDraftStateToRaw) return convertFromDraftStateToRaw_1;
  hasRequiredConvertFromDraftStateToRaw = 1;
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ContentBlock = requireContentBlock();
  var ContentBlockNode = requireContentBlockNode();
  var DraftStringKey = requireDraftStringKey();
  var encodeEntityRanges = requireEncodeEntityRanges();
  var encodeInlineStyleRanges = requireEncodeInlineStyleRanges();
  var invariant2 = requireInvariant();
  var createRawBlock = function createRawBlock2(block, entityStorageMap) {
    return {
      key: block.getKey(),
      text: block.getText(),
      type: block.getType(),
      depth: block.getDepth(),
      inlineStyleRanges: encodeInlineStyleRanges(block),
      entityRanges: encodeEntityRanges(block, entityStorageMap),
      data: block.getData().toObject()
    };
  };
  var insertRawBlock = function insertRawBlock2(block, entityMap, rawBlocks, blockCacheRef) {
    if (block instanceof ContentBlock) {
      rawBlocks.push(createRawBlock(block, entityMap));
      return;
    }
    !(block instanceof ContentBlockNode) ? invariant2(false) : void 0;
    var parentKey = block.getParentKey();
    var rawBlock = blockCacheRef[block.getKey()] = _objectSpread3({}, createRawBlock(block, entityMap), {
      children: []
    });
    if (parentKey) {
      blockCacheRef[parentKey].children.push(rawBlock);
      return;
    }
    rawBlocks.push(rawBlock);
  };
  var encodeRawBlocks = function encodeRawBlocks2(contentState, rawState) {
    var entityMap = rawState.entityMap;
    var rawBlocks = [];
    var blockCacheRef = {};
    var entityCacheRef = {};
    var entityStorageKey = 0;
    contentState.getBlockMap().forEach(function(block) {
      block.findEntityRanges(function(character) {
        return character.getEntity() !== null;
      }, function(start) {
        var entityKey = block.getEntityAt(start);
        var stringifiedEntityKey = DraftStringKey.stringify(entityKey);
        if (entityCacheRef[stringifiedEntityKey]) {
          return;
        }
        entityCacheRef[stringifiedEntityKey] = entityKey;
        entityMap[stringifiedEntityKey] = "".concat(entityStorageKey);
        entityStorageKey++;
      });
      insertRawBlock(block, entityMap, rawBlocks, blockCacheRef);
    });
    return {
      blocks: rawBlocks,
      entityMap
    };
  };
  var encodeRawEntityMap = function encodeRawEntityMap2(contentState, rawState) {
    var blocks = rawState.blocks, entityMap = rawState.entityMap;
    var rawEntityMap = {};
    Object.keys(entityMap).forEach(function(key, index) {
      var entity = contentState.getEntity(DraftStringKey.unstringify(key));
      rawEntityMap[index] = {
        type: entity.getType(),
        mutability: entity.getMutability(),
        data: entity.getData()
      };
    });
    return {
      blocks,
      entityMap: rawEntityMap
    };
  };
  var convertFromDraftStateToRaw = function convertFromDraftStateToRaw2(contentState) {
    var rawDraftContentState = {
      entityMap: {},
      blocks: []
    };
    rawDraftContentState = encodeRawBlocks(contentState, rawDraftContentState);
    rawDraftContentState = encodeRawEntityMap(contentState, rawDraftContentState);
    return rawDraftContentState;
  };
  convertFromDraftStateToRaw_1 = convertFromDraftStateToRaw;
  return convertFromDraftStateToRaw_1;
}
var DraftTreeAdapter_1;
var hasRequiredDraftTreeAdapter;
function requireDraftTreeAdapter() {
  if (hasRequiredDraftTreeAdapter) return DraftTreeAdapter_1;
  hasRequiredDraftTreeAdapter = 1;
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var generateRandomKey = requireGenerateRandomKey();
  var invariant2 = requireInvariant();
  var traverseInDepthOrder = function traverseInDepthOrder2(blocks, fn2) {
    var stack = [].concat(blocks).reverse();
    while (stack.length) {
      var _block = stack.pop();
      fn2(_block);
      var children = _block.children;
      !Array.isArray(children) ? invariant2(false) : void 0;
      stack = stack.concat([].concat(children.reverse()));
    }
  };
  var isListBlock = function isListBlock2(block) {
    if (!(block && block.type)) {
      return false;
    }
    var type = block.type;
    return type === "unordered-list-item" || type === "ordered-list-item";
  };
  var addDepthToChildren = function addDepthToChildren2(block) {
    if (Array.isArray(block.children)) {
      block.children = block.children.map(function(child) {
        return child.type === block.type ? _objectSpread3({}, child, {
          depth: (block.depth || 0) + 1
        }) : child;
      });
    }
  };
  var DraftTreeAdapter = {
    /**
     * Converts from a tree raw state back to draft raw state
     */
    fromRawTreeStateToRawState: function fromRawTreeStateToRawState(draftTreeState) {
      var blocks = draftTreeState.blocks;
      var transformedBlocks = [];
      !Array.isArray(blocks) ? invariant2(false) : void 0;
      if (!Array.isArray(blocks) || !blocks.length) {
        return draftTreeState;
      }
      traverseInDepthOrder(blocks, function(block) {
        var newBlock = _objectSpread3({}, block);
        if (isListBlock(block)) {
          newBlock.depth = newBlock.depth || 0;
          addDepthToChildren(block);
          if (block.children != null && block.children.length > 0) {
            return;
          }
        }
        delete newBlock.children;
        transformedBlocks.push(newBlock);
      });
      draftTreeState.blocks = transformedBlocks;
      return _objectSpread3({}, draftTreeState, {
        blocks: transformedBlocks
      });
    },
    /**
     * Converts from draft raw state to tree draft state
     */
    fromRawStateToRawTreeState: function fromRawStateToRawTreeState(draftState) {
      var transformedBlocks = [];
      var parentStack = [];
      draftState.blocks.forEach(function(block) {
        var isList2 = isListBlock(block);
        var depth = block.depth || 0;
        var treeBlock = _objectSpread3({}, block, {
          children: []
        });
        if (!isList2) {
          transformedBlocks.push(treeBlock);
          return;
        }
        var lastParent = parentStack[0];
        if (lastParent == null && depth === 0) {
          transformedBlocks.push(treeBlock);
        } else if (lastParent == null || lastParent.depth < depth - 1) {
          var newParent = {
            key: generateRandomKey(),
            text: "",
            depth: depth - 1,
            type: block.type,
            children: [],
            entityRanges: [],
            inlineStyleRanges: []
          };
          parentStack.unshift(newParent);
          if (depth === 1) {
            transformedBlocks.push(newParent);
          } else if (lastParent != null) {
            lastParent.children.push(newParent);
          }
          newParent.children.push(treeBlock);
        } else if (lastParent.depth === depth - 1) {
          lastParent.children.push(treeBlock);
        } else {
          while (lastParent != null && lastParent.depth >= depth) {
            parentStack.shift();
            lastParent = parentStack[0];
          }
          if (depth > 0) {
            lastParent.children.push(treeBlock);
          } else {
            transformedBlocks.push(treeBlock);
          }
        }
      });
      return _objectSpread3({}, draftState, {
        blocks: transformedBlocks
      });
    }
  };
  DraftTreeAdapter_1 = DraftTreeAdapter;
  return DraftTreeAdapter_1;
}
var DraftTreeInvariants_1;
var hasRequiredDraftTreeInvariants;
function requireDraftTreeInvariants() {
  if (hasRequiredDraftTreeInvariants) return DraftTreeInvariants_1;
  hasRequiredDraftTreeInvariants = 1;
  requireWarning();
  var DraftTreeInvariants = {
    /**
     * Check if the block is valid
     */
    isValidBlock: function isValidBlock(block, blockMap) {
      var key = block.getKey();
      var parentKey = block.getParentKey();
      if (parentKey != null) {
        var parent = blockMap.get(parentKey);
        if (!parent.getChildKeys().includes(key)) {
          return false;
        }
      }
      var children = block.getChildKeys().map(function(k2) {
        return blockMap.get(k2);
      });
      if (!children.every(function(c2) {
        return c2.getParentKey() === key;
      })) {
        return false;
      }
      var prevSiblingKey = block.getPrevSiblingKey();
      if (prevSiblingKey != null) {
        var prevSibling = blockMap.get(prevSiblingKey);
        if (prevSibling.getNextSiblingKey() !== key) {
          return false;
        }
      }
      var nextSiblingKey = block.getNextSiblingKey();
      if (nextSiblingKey != null) {
        var nextSibling = blockMap.get(nextSiblingKey);
        if (nextSibling.getPrevSiblingKey() !== key) {
          return false;
        }
      }
      if (nextSiblingKey !== null && prevSiblingKey !== null) {
        if (prevSiblingKey === nextSiblingKey) {
          return false;
        }
      }
      if (block.text != "") {
        if (block.getChildKeys().size > 0) {
          return false;
        }
      }
      return true;
    },
    /**
     * Checks that this is a connected tree on all the blocks
     * starting from the first block, traversing nextSibling and child pointers
     * should be a tree (preorder traversal - parent, then children)
     * num of connected node === number of blocks
     */
    isConnectedTree: function isConnectedTree(blockMap) {
      var eligibleFirstNodes = blockMap.toArray().filter(function(block) {
        return block.getParentKey() == null && block.getPrevSiblingKey() == null;
      });
      if (eligibleFirstNodes.length !== 1) {
        return false;
      }
      var firstNode = eligibleFirstNodes.shift();
      var nodesSeen = 0;
      var currentKey = firstNode.getKey();
      var visitedStack = [];
      while (currentKey != null) {
        var currentNode = blockMap.get(currentKey);
        var childKeys = currentNode.getChildKeys();
        var nextSiblingKey = currentNode.getNextSiblingKey();
        if (childKeys.size > 0) {
          if (nextSiblingKey != null) {
            visitedStack.unshift(nextSiblingKey);
          }
          var children = childKeys.map(function(k2) {
            return blockMap.get(k2);
          });
          var _firstNode = children.find(function(block) {
            return block.getPrevSiblingKey() == null;
          });
          if (_firstNode == null) {
            return false;
          }
          currentKey = _firstNode.getKey();
        } else {
          if (currentNode.getNextSiblingKey() != null) {
            currentKey = currentNode.getNextSiblingKey();
          } else {
            currentKey = visitedStack.shift();
          }
        }
        nodesSeen++;
      }
      if (nodesSeen !== blockMap.size) {
        return false;
      }
      return true;
    },
    /**
     * Checks that the block map is a connected tree with valid blocks
     */
    isValidTree: function isValidTree(blockMap) {
      var _this = this;
      var blocks = blockMap.toArray();
      if (!blocks.every(function(block) {
        return _this.isValidBlock(block, blockMap);
      })) {
        return false;
      }
      return this.isConnectedTree(blockMap);
    }
  };
  DraftTreeInvariants_1 = DraftTreeInvariants;
  return DraftTreeInvariants_1;
}
var createCharacterList_1;
var hasRequiredCreateCharacterList;
function requireCreateCharacterList() {
  if (hasRequiredCreateCharacterList) return createCharacterList_1;
  hasRequiredCreateCharacterList = 1;
  var CharacterMetadata = requireCharacterMetadata();
  var Immutable2 = requireImmutable();
  var List2 = Immutable2.List;
  function createCharacterList(inlineStyles, entities) {
    var characterArray = inlineStyles.map(function(style, ii) {
      var entity = entities[ii];
      return CharacterMetadata.create({
        style,
        entity
      });
    });
    return List2(characterArray);
  }
  createCharacterList_1 = createCharacterList;
  return createCharacterList_1;
}
var decodeEntityRanges_1;
var hasRequiredDecodeEntityRanges;
function requireDecodeEntityRanges() {
  if (hasRequiredDecodeEntityRanges) return decodeEntityRanges_1;
  hasRequiredDecodeEntityRanges = 1;
  var UnicodeUtils = requireUnicodeUtils();
  var substr = UnicodeUtils.substr;
  function decodeEntityRanges(text, ranges) {
    var entities = Array(text.length).fill(null);
    if (ranges) {
      ranges.forEach(function(range) {
        var start = substr(text, 0, range.offset).length;
        var end = start + substr(text, range.offset, range.length).length;
        for (var ii = start; ii < end; ii++) {
          entities[ii] = range.key;
        }
      });
    }
    return entities;
  }
  decodeEntityRanges_1 = decodeEntityRanges;
  return decodeEntityRanges_1;
}
var decodeInlineStyleRanges_1;
var hasRequiredDecodeInlineStyleRanges;
function requireDecodeInlineStyleRanges() {
  if (hasRequiredDecodeInlineStyleRanges) return decodeInlineStyleRanges_1;
  hasRequiredDecodeInlineStyleRanges = 1;
  var UnicodeUtils = requireUnicodeUtils();
  var _require = requireImmutable(), OrderedSet2 = _require.OrderedSet;
  var substr = UnicodeUtils.substr;
  var EMPTY_SET2 = OrderedSet2();
  function decodeInlineStyleRanges(text, ranges) {
    var styles2 = Array(text.length).fill(EMPTY_SET2);
    if (ranges) {
      ranges.forEach(function(range) {
        var cursor = substr(text, 0, range.offset).length;
        var end = cursor + substr(text, range.offset, range.length).length;
        while (cursor < end) {
          styles2[cursor] = styles2[cursor].add(range.style);
          cursor++;
        }
      });
    }
    return styles2;
  }
  decodeInlineStyleRanges_1 = decodeInlineStyleRanges;
  return decodeInlineStyleRanges_1;
}
var convertFromRawToDraftState_1;
var hasRequiredConvertFromRawToDraftState;
function requireConvertFromRawToDraftState() {
  if (hasRequiredConvertFromRawToDraftState) return convertFromRawToDraftState_1;
  hasRequiredConvertFromRawToDraftState = 1;
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ContentBlock = requireContentBlock();
  var ContentBlockNode = requireContentBlockNode();
  var ContentState = requireContentState();
  var DraftEntity = requireDraftEntity();
  var DraftTreeAdapter = requireDraftTreeAdapter();
  requireDraftTreeInvariants();
  var SelectionState = requireSelectionState();
  var createCharacterList = requireCreateCharacterList();
  var decodeEntityRanges = requireDecodeEntityRanges();
  var decodeInlineStyleRanges = requireDecodeInlineStyleRanges();
  var generateRandomKey = requireGenerateRandomKey();
  var gkx2 = requireGkx();
  var Immutable2 = requireImmutable();
  var invariant2 = requireInvariant();
  var experimentalTreeDataSupport = gkx2("draft_tree_data_support");
  var List2 = Immutable2.List, Map2 = Immutable2.Map, OrderedMap2 = Immutable2.OrderedMap;
  var decodeBlockNodeConfig = function decodeBlockNodeConfig2(block, entityMap) {
    var key = block.key, type = block.type, data = block.data, text = block.text, depth = block.depth;
    var blockNodeConfig = {
      text,
      depth: depth || 0,
      type: type || "unstyled",
      key: key || generateRandomKey(),
      data: Map2(data),
      characterList: decodeCharacterList(block, entityMap)
    };
    return blockNodeConfig;
  };
  var decodeCharacterList = function decodeCharacterList2(block, entityMap) {
    var text = block.text, rawEntityRanges = block.entityRanges, rawInlineStyleRanges = block.inlineStyleRanges;
    var entityRanges = rawEntityRanges || [];
    var inlineStyleRanges = rawInlineStyleRanges || [];
    return createCharacterList(decodeInlineStyleRanges(text, inlineStyleRanges), decodeEntityRanges(text, entityRanges.filter(function(range) {
      return entityMap.hasOwnProperty(range.key);
    }).map(function(range) {
      return _objectSpread3({}, range, {
        key: entityMap[range.key]
      });
    })));
  };
  var addKeyIfMissing = function addKeyIfMissing2(block) {
    return _objectSpread3({}, block, {
      key: block.key || generateRandomKey()
    });
  };
  var updateNodeStack = function updateNodeStack2(stack, nodes, parentRef) {
    var nodesWithParentRef = nodes.map(function(block) {
      return _objectSpread3({}, block, {
        parentRef
      });
    });
    return stack.concat(nodesWithParentRef.reverse());
  };
  var decodeContentBlockNodes = function decodeContentBlockNodes2(blocks, entityMap) {
    return blocks.map(addKeyIfMissing).reduce(function(blockMap, block, index) {
      !Array.isArray(block.children) ? invariant2(false) : void 0;
      var children = block.children.map(addKeyIfMissing);
      var contentBlockNode = new ContentBlockNode(_objectSpread3({}, decodeBlockNodeConfig(block, entityMap), {
        prevSibling: index === 0 ? null : blocks[index - 1].key,
        nextSibling: index === blocks.length - 1 ? null : blocks[index + 1].key,
        children: List2(children.map(function(child) {
          return child.key;
        }))
      }));
      blockMap = blockMap.set(contentBlockNode.getKey(), contentBlockNode);
      var stack = updateNodeStack([], children, contentBlockNode);
      while (stack.length > 0) {
        var node = stack.pop();
        var parentRef = node.parentRef;
        var siblings = parentRef.getChildKeys();
        var _index = siblings.indexOf(node.key);
        var isValidBlock = Array.isArray(node.children);
        if (!isValidBlock) {
          !isValidBlock ? invariant2(false) : void 0;
          break;
        }
        var _children = node.children.map(addKeyIfMissing);
        var _contentBlockNode = new ContentBlockNode(_objectSpread3({}, decodeBlockNodeConfig(node, entityMap), {
          parent: parentRef.getKey(),
          children: List2(_children.map(function(child) {
            return child.key;
          })),
          prevSibling: _index === 0 ? null : siblings.get(_index - 1),
          nextSibling: _index === siblings.size - 1 ? null : siblings.get(_index + 1)
        }));
        blockMap = blockMap.set(_contentBlockNode.getKey(), _contentBlockNode);
        stack = updateNodeStack(stack, _children, _contentBlockNode);
      }
      return blockMap;
    }, OrderedMap2());
  };
  var decodeContentBlocks = function decodeContentBlocks2(blocks, entityMap) {
    return OrderedMap2(blocks.map(function(block) {
      var contentBlock = new ContentBlock(decodeBlockNodeConfig(block, entityMap));
      return [contentBlock.getKey(), contentBlock];
    }));
  };
  var decodeRawBlocks = function decodeRawBlocks2(rawState, entityMap) {
    var isTreeRawBlock = rawState.blocks.find(function(block) {
      return Array.isArray(block.children) && block.children.length > 0;
    });
    var rawBlocks = experimentalTreeDataSupport && !isTreeRawBlock ? DraftTreeAdapter.fromRawStateToRawTreeState(rawState).blocks : rawState.blocks;
    if (!experimentalTreeDataSupport) {
      return decodeContentBlocks(isTreeRawBlock ? DraftTreeAdapter.fromRawTreeStateToRawState(rawState).blocks : rawBlocks, entityMap);
    }
    var blockMap = decodeContentBlockNodes(rawBlocks, entityMap);
    return blockMap;
  };
  var decodeRawEntityMap = function decodeRawEntityMap2(rawState) {
    var rawEntityMap = rawState.entityMap;
    var entityMap = {};
    Object.keys(rawEntityMap).forEach(function(rawEntityKey) {
      var _rawEntityMap$rawEnti = rawEntityMap[rawEntityKey], type = _rawEntityMap$rawEnti.type, mutability = _rawEntityMap$rawEnti.mutability, data = _rawEntityMap$rawEnti.data;
      entityMap[rawEntityKey] = DraftEntity.__create(type, mutability, data || {});
    });
    return entityMap;
  };
  var convertFromRawToDraftState = function convertFromRawToDraftState2(rawState) {
    !Array.isArray(rawState.blocks) ? invariant2(false) : void 0;
    var entityMap = decodeRawEntityMap(rawState);
    var blockMap = decodeRawBlocks(rawState, entityMap);
    var selectionState = blockMap.isEmpty() ? new SelectionState() : SelectionState.createEmpty(blockMap.first().getKey());
    return new ContentState({
      blockMap,
      entityMap,
      selectionBefore: selectionState,
      selectionAfter: selectionState
    });
  };
  convertFromRawToDraftState_1 = convertFromRawToDraftState;
  return convertFromRawToDraftState_1;
}
var getRangeBoundingClientRect_1;
var hasRequiredGetRangeBoundingClientRect;
function requireGetRangeBoundingClientRect() {
  if (hasRequiredGetRangeBoundingClientRect) return getRangeBoundingClientRect_1;
  hasRequiredGetRangeBoundingClientRect = 1;
  var getRangeClientRects = requireGetRangeClientRects();
  function getRangeBoundingClientRect(range) {
    var rects = getRangeClientRects(range);
    var top = 0;
    var right = 0;
    var bottom = 0;
    var left = 0;
    if (rects.length) {
      if (rects.length > 1 && rects[0].width === 0) {
        var _rects$ = rects[1];
        top = _rects$.top;
        right = _rects$.right;
        bottom = _rects$.bottom;
        left = _rects$.left;
      } else {
        var _rects$2 = rects[0];
        top = _rects$2.top;
        right = _rects$2.right;
        bottom = _rects$2.bottom;
        left = _rects$2.left;
      }
      for (var ii = 1; ii < rects.length; ii++) {
        var rect = rects[ii];
        if (rect.height !== 0 && rect.width !== 0) {
          top = Math.min(top, rect.top);
          right = Math.max(right, rect.right);
          bottom = Math.max(bottom, rect.bottom);
          left = Math.min(left, rect.left);
        }
      }
    }
    return {
      top,
      right,
      bottom,
      left,
      width: right - left,
      height: bottom - top
    };
  }
  getRangeBoundingClientRect_1 = getRangeBoundingClientRect;
  return getRangeBoundingClientRect_1;
}
var getVisibleSelectionRect_1;
var hasRequiredGetVisibleSelectionRect;
function requireGetVisibleSelectionRect() {
  if (hasRequiredGetVisibleSelectionRect) return getVisibleSelectionRect_1;
  hasRequiredGetVisibleSelectionRect = 1;
  var getRangeBoundingClientRect = requireGetRangeBoundingClientRect();
  function getVisibleSelectionRect(global) {
    var selection = global.getSelection();
    if (!selection.rangeCount) {
      return null;
    }
    var range = selection.getRangeAt(0);
    var boundingRect = getRangeBoundingClientRect(range);
    var top = boundingRect.top, right = boundingRect.right, bottom = boundingRect.bottom, left = boundingRect.left;
    if (top === 0 && right === 0 && bottom === 0 && left === 0) {
      return null;
    }
    return boundingRect;
  }
  getVisibleSelectionRect_1 = getVisibleSelectionRect;
  return getVisibleSelectionRect_1;
}
var Draft;
var hasRequiredDraft;
function requireDraft() {
  if (hasRequiredDraft) return Draft;
  hasRequiredDraft = 1;
  var AtomicBlockUtils = requireAtomicBlockUtils();
  var BlockMapBuilder = requireBlockMapBuilder();
  var CharacterMetadata = requireCharacterMetadata();
  var CompositeDraftDecorator = requireCompositeDraftDecorator();
  var ContentBlock = requireContentBlock();
  var ContentState = requireContentState();
  var DefaultDraftBlockRenderMap = requireDefaultDraftBlockRenderMap();
  var DefaultDraftInlineStyle2 = requireDefaultDraftInlineStyle();
  var DraftEditor = requireDraftEditor_react();
  var DraftEditorBlock = requireDraftEditorBlock_react();
  var DraftEntity = requireDraftEntity();
  var DraftModifier = requireDraftModifier();
  var DraftEntityInstance = requireDraftEntityInstance();
  var EditorState = requireEditorState();
  var KeyBindingUtil = requireKeyBindingUtil();
  var RawDraftContentState2 = requireRawDraftContentState();
  var RichTextEditorUtil = requireRichTextEditorUtil();
  var SelectionState = requireSelectionState();
  var convertFromDraftStateToRaw = requireConvertFromDraftStateToRaw();
  var convertFromRawToDraftState = requireConvertFromRawToDraftState();
  var generateRandomKey = requireGenerateRandomKey();
  var getDefaultKeyBinding = requireGetDefaultKeyBinding();
  var getVisibleSelectionRect = requireGetVisibleSelectionRect();
  var convertFromHTML = requireConvertFromHTMLToContentBlocks();
  var DraftPublic = {
    Editor: DraftEditor,
    EditorBlock: DraftEditorBlock,
    EditorState,
    CompositeDecorator: CompositeDraftDecorator,
    Entity: DraftEntity,
    EntityInstance: DraftEntityInstance,
    BlockMapBuilder,
    CharacterMetadata,
    ContentBlock,
    ContentState,
    RawDraftContentState: RawDraftContentState2,
    SelectionState,
    AtomicBlockUtils,
    KeyBindingUtil,
    Modifier: DraftModifier,
    RichUtils: RichTextEditorUtil,
    DefaultDraftBlockRenderMap,
    DefaultDraftInlineStyle: DefaultDraftInlineStyle2,
    convertFromHTML,
    convertFromRaw: convertFromRawToDraftState,
    convertToRaw: convertFromDraftStateToRaw,
    genKey: generateRandomKey,
    getDefaultKeyBinding,
    getVisibleSelectionRect
  };
  Draft = DraftPublic;
  return Draft;
}
var DraftExports = requireDraft();
var reactDraftWysiwyg = { exports: {} };
var DELETE = "delete";
var SHIFT = 5;
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;
var NOT_SET = {};
function MakeRef() {
  return { value: false };
}
function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
}
function OwnerID() {
}
function ensureSize(iter) {
  if (iter.size === void 0) {
    iter.size = iter.__iterate(returnTrue);
  }
  return iter.size;
}
function wrapIndex(iter, index) {
  if (typeof index !== "number") {
    var uint32Index = index >>> 0;
    if ("" + uint32Index !== index || uint32Index === 4294967295) {
      return NaN;
    }
    index = uint32Index;
  }
  return index < 0 ? ensureSize(iter) + index : index;
}
function returnTrue() {
  return true;
}
function wholeSlice(begin, end, size) {
  return (begin === 0 && !isNeg(begin) || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
}
function resolveBegin(begin, size) {
  return resolveIndex(begin, size, 0);
}
function resolveEnd(end, size) {
  return resolveIndex(end, size, size);
}
function resolveIndex(index, size, defaultIndex) {
  return index === void 0 ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === void 0 || size === index ? index : Math.min(size, index) | 0;
}
function isNeg(value) {
  return value < 0 || value === 0 && 1 / value === -Infinity;
}
var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isCollection(maybeCollection) {
  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
}
var IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";
function isKeyed(maybeKeyed) {
  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
}
var IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";
function isIndexed(maybeIndexed) {
  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
}
function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}
var Collection = function Collection2(value) {
  return isCollection(value) ? value : Seq(value);
};
var KeyedCollection = /* @__PURE__ */ (function(Collection3) {
  function KeyedCollection2(value) {
    return isKeyed(value) ? value : KeyedSeq(value);
  }
  if (Collection3) KeyedCollection2.__proto__ = Collection3;
  KeyedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  KeyedCollection2.prototype.constructor = KeyedCollection2;
  return KeyedCollection2;
})(Collection);
var IndexedCollection = /* @__PURE__ */ (function(Collection3) {
  function IndexedCollection2(value) {
    return isIndexed(value) ? value : IndexedSeq(value);
  }
  if (Collection3) IndexedCollection2.__proto__ = Collection3;
  IndexedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  IndexedCollection2.prototype.constructor = IndexedCollection2;
  return IndexedCollection2;
})(Collection);
var SetCollection = /* @__PURE__ */ (function(Collection3) {
  function SetCollection2(value) {
    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
  }
  if (Collection3) SetCollection2.__proto__ = Collection3;
  SetCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  SetCollection2.prototype.constructor = SetCollection2;
  return SetCollection2;
})(Collection);
Collection.Keyed = KeyedCollection;
Collection.Indexed = IndexedCollection;
Collection.Set = SetCollection;
var IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";
function isSeq(maybeSeq) {
  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
}
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
function isRecord(maybeRecord) {
  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
}
function isImmutable(maybeImmutable) {
  return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}
var IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";
function isOrdered(maybeOrdered) {
  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
}
var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;
var REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = "@@iterator";
var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
var Iterator = function Iterator2(next) {
  this.next = next;
};
Iterator.prototype.toString = function toString() {
  return "[Iterator]";
};
Iterator.KEYS = ITERATE_KEYS;
Iterator.VALUES = ITERATE_VALUES;
Iterator.ENTRIES = ITERATE_ENTRIES;
Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
  return this.toString();
};
Iterator.prototype[ITERATOR_SYMBOL] = function() {
  return this;
};
function iteratorValue(type, k2, v2, iteratorResult) {
  var value = type === 0 ? k2 : type === 1 ? v2 : [k2, v2];
  iteratorResult ? iteratorResult.value = value : iteratorResult = {
    value,
    done: false
  };
  return iteratorResult;
}
function iteratorDone() {
  return { value: void 0, done: true };
}
function hasIterator(maybeIterable) {
  if (Array.isArray(maybeIterable)) {
    return true;
  }
  return !!getIteratorFn(maybeIterable);
}
function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === "function";
}
function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}
function getIteratorFn(iterable) {
  var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === "function") {
    return iteratorFn;
  }
}
function isEntriesIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.entries;
}
function isKeysIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.keys;
}
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function isArrayLike(value) {
  if (Array.isArray(value) || typeof value === "string") {
    return true;
  }
  return value && typeof value === "object" && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? (
    // Only {length: 0} is considered Array-like.
    Object.keys(value).length === 1
  ) : (
    // An object is only Array-like if it has a property where the last value
    // in the array-like may be found (which could be undefined).
    value.hasOwnProperty(value.length - 1)
  ));
}
var Seq = /* @__PURE__ */ (function(Collection3) {
  function Seq2(value) {
    return value === void 0 || value === null ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);
  }
  if (Collection3) Seq2.__proto__ = Collection3;
  Seq2.prototype = Object.create(Collection3 && Collection3.prototype);
  Seq2.prototype.constructor = Seq2;
  Seq2.prototype.toSeq = function toSeq3() {
    return this;
  };
  Seq2.prototype.toString = function toString5() {
    return this.__toString("Seq {", "}");
  };
  Seq2.prototype.cacheResult = function cacheResult() {
    if (!this._cache && this.__iterateUncached) {
      this._cache = this.entrySeq().toArray();
      this.size = this._cache.length;
    }
    return this;
  };
  Seq2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var cache2 = this._cache;
    if (cache2) {
      var size = cache2.length;
      var i2 = 0;
      while (i2 !== size) {
        var entry = cache2[reverse3 ? size - ++i2 : i2++];
        if (fn2(entry[1], entry[0], this) === false) {
          break;
        }
      }
      return i2;
    }
    return this.__iterateUncached(fn2, reverse3);
  };
  Seq2.prototype.__iterator = function __iterator2(type, reverse3) {
    var cache2 = this._cache;
    if (cache2) {
      var size = cache2.length;
      var i2 = 0;
      return new Iterator(function() {
        if (i2 === size) {
          return iteratorDone();
        }
        var entry = cache2[reverse3 ? size - ++i2 : i2++];
        return iteratorValue(type, entry[0], entry[1]);
      });
    }
    return this.__iteratorUncached(type, reverse3);
  };
  return Seq2;
})(Collection);
var KeyedSeq = /* @__PURE__ */ (function(Seq2) {
  function KeyedSeq2(value) {
    return value === void 0 || value === null ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
  }
  if (Seq2) KeyedSeq2.__proto__ = Seq2;
  KeyedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  KeyedSeq2.prototype.constructor = KeyedSeq2;
  KeyedSeq2.prototype.toKeyedSeq = function toKeyedSeq3() {
    return this;
  };
  return KeyedSeq2;
})(Seq);
var IndexedSeq = /* @__PURE__ */ (function(Seq2) {
  function IndexedSeq2(value) {
    return value === void 0 || value === null ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
  }
  if (Seq2) IndexedSeq2.__proto__ = Seq2;
  IndexedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  IndexedSeq2.prototype.constructor = IndexedSeq2;
  IndexedSeq2.of = function of() {
    return IndexedSeq2(arguments);
  };
  IndexedSeq2.prototype.toIndexedSeq = function toIndexedSeq2() {
    return this;
  };
  IndexedSeq2.prototype.toString = function toString5() {
    return this.__toString("Seq [", "]");
  };
  return IndexedSeq2;
})(Seq);
var SetSeq = /* @__PURE__ */ (function(Seq2) {
  function SetSeq2(value) {
    return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
  }
  if (Seq2) SetSeq2.__proto__ = Seq2;
  SetSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  SetSeq2.prototype.constructor = SetSeq2;
  SetSeq2.of = function of() {
    return SetSeq2(arguments);
  };
  SetSeq2.prototype.toSetSeq = function toSetSeq2() {
    return this;
  };
  return SetSeq2;
})(Seq);
Seq.isSeq = isSeq;
Seq.Keyed = KeyedSeq;
Seq.Set = SetSeq;
Seq.Indexed = IndexedSeq;
Seq.prototype[IS_SEQ_SYMBOL] = true;
var ArraySeq = /* @__PURE__ */ (function(IndexedSeq2) {
  function ArraySeq2(array2) {
    this._array = array2;
    this.size = array2.length;
  }
  if (IndexedSeq2) ArraySeq2.__proto__ = IndexedSeq2;
  ArraySeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  ArraySeq2.prototype.constructor = ArraySeq2;
  ArraySeq2.prototype.get = function get11(index, notSetValue) {
    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
  };
  ArraySeq2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var array2 = this._array;
    var size = array2.length;
    var i2 = 0;
    while (i2 !== size) {
      var ii = reverse3 ? size - ++i2 : i2++;
      if (fn2(array2[ii], ii, this) === false) {
        break;
      }
    }
    return i2;
  };
  ArraySeq2.prototype.__iterator = function __iterator2(type, reverse3) {
    var array2 = this._array;
    var size = array2.length;
    var i2 = 0;
    return new Iterator(function() {
      if (i2 === size) {
        return iteratorDone();
      }
      var ii = reverse3 ? size - ++i2 : i2++;
      return iteratorValue(type, ii, array2[ii]);
    });
  };
  return ArraySeq2;
})(IndexedSeq);
var ObjectSeq = /* @__PURE__ */ (function(KeyedSeq2) {
  function ObjectSeq2(object2) {
    var keys2 = Object.keys(object2).concat(
      Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object2) : []
    );
    this._object = object2;
    this._keys = keys2;
    this.size = keys2.length;
  }
  if (KeyedSeq2) ObjectSeq2.__proto__ = KeyedSeq2;
  ObjectSeq2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  ObjectSeq2.prototype.constructor = ObjectSeq2;
  ObjectSeq2.prototype.get = function get11(key, notSetValue) {
    if (notSetValue !== void 0 && !this.has(key)) {
      return notSetValue;
    }
    return this._object[key];
  };
  ObjectSeq2.prototype.has = function has5(key) {
    return hasOwnProperty$1.call(this._object, key);
  };
  ObjectSeq2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var object2 = this._object;
    var keys2 = this._keys;
    var size = keys2.length;
    var i2 = 0;
    while (i2 !== size) {
      var key = keys2[reverse3 ? size - ++i2 : i2++];
      if (fn2(object2[key], key, this) === false) {
        break;
      }
    }
    return i2;
  };
  ObjectSeq2.prototype.__iterator = function __iterator2(type, reverse3) {
    var object2 = this._object;
    var keys2 = this._keys;
    var size = keys2.length;
    var i2 = 0;
    return new Iterator(function() {
      if (i2 === size) {
        return iteratorDone();
      }
      var key = keys2[reverse3 ? size - ++i2 : i2++];
      return iteratorValue(type, key, object2[key]);
    });
  };
  return ObjectSeq2;
})(KeyedSeq);
ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
var CollectionSeq = /* @__PURE__ */ (function(IndexedSeq2) {
  function CollectionSeq2(collection) {
    this._collection = collection;
    this.size = collection.length || collection.size;
  }
  if (IndexedSeq2) CollectionSeq2.__proto__ = IndexedSeq2;
  CollectionSeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  CollectionSeq2.prototype.constructor = CollectionSeq2;
  CollectionSeq2.prototype.__iterateUncached = function __iterateUncached(fn2, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn2, reverse3);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    var iterations = 0;
    if (isIterator(iterator)) {
      var step;
      while (!(step = iterator.next()).done) {
        if (fn2(step.value, iterations++, this) === false) {
          break;
        }
      }
    }
    return iterations;
  };
  CollectionSeq2.prototype.__iteratorUncached = function __iteratorUncached(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    if (!isIterator(iterator)) {
      return new Iterator(iteratorDone);
    }
    var iterations = 0;
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value);
    });
  };
  return CollectionSeq2;
})(IndexedSeq);
var EMPTY_SEQ;
function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}
function keyedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq.fromEntrySeq();
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of [k, v] entries, or keyed object: " + value
  );
}
function indexedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  throw new TypeError(
    "Expected Array or collection object of values: " + value
  );
}
function seqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of values, or keyed object: " + value
  );
}
function maybeIndexedSeqFromValue(value) {
  return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : void 0;
}
var IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";
function isMap(maybeMap) {
  return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
}
function isOrderedMap(maybeOrderedMap) {
  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}
function isValueObject(maybeValue) {
  return Boolean(
    maybeValue && typeof maybeValue.equals === "function" && typeof maybeValue.hashCode === "function"
  );
}
function is(valueA, valueB) {
  if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
}
var imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul2(a2, b2) {
  a2 |= 0;
  b2 |= 0;
  var c2 = a2 & 65535;
  var d2 = b2 & 65535;
  return c2 * d2 + ((a2 >>> 16) * d2 + c2 * (b2 >>> 16) << 16 >>> 0) | 0;
};
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
var defaultValueOf = Object.prototype.valueOf;
function hash(o2) {
  if (o2 == null) {
    return hashNullish(o2);
  }
  if (typeof o2.hashCode === "function") {
    return smi(o2.hashCode(o2));
  }
  var v2 = valueOf$1(o2);
  if (v2 == null) {
    return hashNullish(v2);
  }
  switch (typeof v2) {
    case "boolean":
      return v2 ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v2);
    case "string":
      return v2.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v2) : hashString(v2);
    case "object":
    case "function":
      return hashJSObj(v2);
    case "symbol":
      return hashSymbol(v2);
    default:
      if (typeof v2.toString === "function") {
        return hashString(v2.toString());
      }
      throw new Error("Value type " + typeof v2 + " cannot be hashed.");
  }
}
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : (
    /* undefined */
    1108378659
  );
}
function hashNumber(n2) {
  if (n2 !== n2 || n2 === Infinity) {
    return 0;
  }
  var hash2 = n2 | 0;
  if (hash2 !== n2) {
    hash2 ^= n2 * 4294967295;
  }
  while (n2 > 4294967295) {
    n2 /= 4294967295;
    hash2 ^= n2;
  }
  return smi(hash2);
}
function cachedHashString(string2) {
  var hashed = stringHashCache[string2];
  if (hashed === void 0) {
    hashed = hashString(string2);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string2] = hashed;
  }
  return hashed;
}
function hashString(string2) {
  var hashed = 0;
  for (var ii = 0; ii < string2.length; ii++) {
    hashed = 31 * hashed + string2.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
function hashSymbol(sym) {
  var hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
function hashJSObj(obj) {
  var hashed;
  if (usingWeakMap) {
    hashed = weakMap.get(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = obj[UID_HASH_KEY];
  if (hashed !== void 0) {
    return hashed;
  }
  if (!canDefineProperty) {
    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hashed !== void 0) {
      return hashed;
    }
    hashed = getIENodeHash(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = nextHash();
  if (usingWeakMap) {
    weakMap.set(obj, hashed);
  } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
    throw new Error("Non-extensible objects are not allowed as keys.");
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hashed
    });
  } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(
        this,
        arguments
      );
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
  } else if (obj.nodeType !== void 0) {
    obj[UID_HASH_KEY] = hashed;
  } else {
    throw new Error("Unable to set a non-enumerable property on object.");
  }
  return hashed;
}
var isExtensible = Object.isExtensible;
var canDefineProperty = (function() {
  try {
    Object.defineProperty({}, "@", {});
    return true;
  } catch (e2) {
    return false;
  }
})();
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1:
        return node.uniqueID;
      case 9:
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}
function valueOf$1(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
  var nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
var usingWeakMap = typeof WeakMap === "function";
var weakMap;
if (usingWeakMap) {
  weakMap = /* @__PURE__ */ new WeakMap();
}
var symbolMap = /* @__PURE__ */ Object.create(null);
var _objHashUID = 0;
var UID_HASH_KEY = "__immutablehash__";
if (typeof Symbol === "function") {
  UID_HASH_KEY = Symbol(UID_HASH_KEY);
}
var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};
var ToKeyedSequence = /* @__PURE__ */ (function(KeyedSeq2) {
  function ToKeyedSequence2(indexed, useKeys) {
    this._iter = indexed;
    this._useKeys = useKeys;
    this.size = indexed.size;
  }
  if (KeyedSeq2) ToKeyedSequence2.__proto__ = KeyedSeq2;
  ToKeyedSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  ToKeyedSequence2.prototype.constructor = ToKeyedSequence2;
  ToKeyedSequence2.prototype.get = function get11(key, notSetValue) {
    return this._iter.get(key, notSetValue);
  };
  ToKeyedSequence2.prototype.has = function has5(key) {
    return this._iter.has(key);
  };
  ToKeyedSequence2.prototype.valueSeq = function valueSeq2() {
    return this._iter.valueSeq();
  };
  ToKeyedSequence2.prototype.reverse = function reverse3() {
    var this$1$1 = this;
    var reversedSequence = reverseFactory(this, true);
    if (!this._useKeys) {
      reversedSequence.valueSeq = function() {
        return this$1$1._iter.toSeq().reverse();
      };
    }
    return reversedSequence;
  };
  ToKeyedSequence2.prototype.map = function map3(mapper, context2) {
    var this$1$1 = this;
    var mappedSequence = mapFactory(this, mapper, context2);
    if (!this._useKeys) {
      mappedSequence.valueSeq = function() {
        return this$1$1._iter.toSeq().map(mapper, context2);
      };
    }
    return mappedSequence;
  };
  ToKeyedSequence2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(v2, k2) {
      return fn2(v2, k2, this$1$1);
    }, reverse3);
  };
  ToKeyedSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
    return this._iter.__iterator(type, reverse3);
  };
  return ToKeyedSequence2;
})(KeyedSeq);
ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
var ToIndexedSequence = /* @__PURE__ */ (function(IndexedSeq2) {
  function ToIndexedSequence2(iter) {
    this._iter = iter;
    this.size = iter.size;
  }
  if (IndexedSeq2) ToIndexedSequence2.__proto__ = IndexedSeq2;
  ToIndexedSequence2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  ToIndexedSequence2.prototype.constructor = ToIndexedSequence2;
  ToIndexedSequence2.prototype.includes = function includes3(value) {
    return this._iter.includes(value);
  };
  ToIndexedSequence2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    var i2 = 0;
    reverse3 && ensureSize(this);
    return this._iter.__iterate(
      function(v2) {
        return fn2(v2, reverse3 ? this$1$1.size - ++i2 : i2++, this$1$1);
      },
      reverse3
    );
  };
  ToIndexedSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
    var this$1$1 = this;
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    var i2 = 0;
    reverse3 && ensureSize(this);
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(
        type,
        reverse3 ? this$1$1.size - ++i2 : i2++,
        step.value,
        step
      );
    });
  };
  return ToIndexedSequence2;
})(IndexedSeq);
var ToSetSequence = /* @__PURE__ */ (function(SetSeq2) {
  function ToSetSequence2(iter) {
    this._iter = iter;
    this.size = iter.size;
  }
  if (SetSeq2) ToSetSequence2.__proto__ = SetSeq2;
  ToSetSequence2.prototype = Object.create(SetSeq2 && SetSeq2.prototype);
  ToSetSequence2.prototype.constructor = ToSetSequence2;
  ToSetSequence2.prototype.has = function has5(key) {
    return this._iter.includes(key);
  };
  ToSetSequence2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(v2) {
      return fn2(v2, v2, this$1$1);
    }, reverse3);
  };
  ToSetSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, step.value, step.value, step);
    });
  };
  return ToSetSequence2;
})(SetSeq);
var FromEntriesSequence = /* @__PURE__ */ (function(KeyedSeq2) {
  function FromEntriesSequence2(entries3) {
    this._iter = entries3;
    this.size = entries3.size;
  }
  if (KeyedSeq2) FromEntriesSequence2.__proto__ = KeyedSeq2;
  FromEntriesSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  FromEntriesSequence2.prototype.constructor = FromEntriesSequence2;
  FromEntriesSequence2.prototype.entrySeq = function entrySeq2() {
    return this._iter.toSeq();
  };
  FromEntriesSequence2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(entry) {
      if (entry) {
        validateEntry(entry);
        var indexedCollection = isCollection(entry);
        return fn2(
          indexedCollection ? entry.get(1) : entry[1],
          indexedCollection ? entry.get(0) : entry[0],
          this$1$1
        );
      }
    }, reverse3);
  };
  FromEntriesSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return iteratorValue(
            type,
            indexedCollection ? entry.get(0) : entry[0],
            indexedCollection ? entry.get(1) : entry[1],
            step
          );
        }
      }
    });
  };
  return FromEntriesSequence2;
})(KeyedSeq);
ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;
  flipSequence.flip = function() {
    return collection;
  };
  flipSequence.reverse = function() {
    var reversedSequence = collection.reverse.apply(this);
    reversedSequence.flip = function() {
      return collection.reverse();
    };
    return reversedSequence;
  };
  flipSequence.has = function(key) {
    return collection.includes(key);
  };
  flipSequence.includes = function(key) {
    return collection.has(key);
  };
  flipSequence.cacheResult = cacheResultThrough;
  flipSequence.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(function(v2, k2) {
      return fn2(k2, v2, this$1$1) !== false;
    }, reverse3);
  };
  flipSequence.__iteratorUncached = function(type, reverse3) {
    if (type === ITERATE_ENTRIES) {
      var iterator = collection.__iterator(type, reverse3);
      return new Iterator(function() {
        var step = iterator.next();
        if (!step.done) {
          var k2 = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k2;
        }
        return step;
      });
    }
    return collection.__iterator(
      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
      reverse3
    );
  };
  return flipSequence;
}
function mapFactory(collection, mapper, context2) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;
  mappedSequence.has = function(key) {
    return collection.has(key);
  };
  mappedSequence.get = function(key, notSetValue) {
    var v2 = collection.get(key, NOT_SET);
    return v2 === NOT_SET ? notSetValue : mapper.call(context2, v2, key, collection);
  };
  mappedSequence.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(
      function(v2, k2, c2) {
        return fn2(mapper.call(context2, v2, k2, c2), k2, this$1$1) !== false;
      },
      reverse3
    );
  };
  mappedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key = entry[0];
      return iteratorValue(
        type,
        key,
        mapper.call(context2, entry[1], key, collection),
        step
      );
    });
  };
  return mappedSequence;
}
function reverseFactory(collection, useKeys) {
  var this$1$1 = this;
  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;
  reversedSequence.reverse = function() {
    return collection;
  };
  if (collection.flip) {
    reversedSequence.flip = function() {
      var flipSequence = flipFactory(collection);
      flipSequence.reverse = function() {
        return collection.flip();
      };
      return flipSequence;
    };
  }
  reversedSequence.get = function(key, notSetValue) {
    return collection.get(useKeys ? key : -1 - key, notSetValue);
  };
  reversedSequence.has = function(key) {
    return collection.has(useKeys ? key : -1 - key);
  };
  reversedSequence.includes = function(value) {
    return collection.includes(value);
  };
  reversedSequence.cacheResult = cacheResultThrough;
  reversedSequence.__iterate = function(fn2, reverse3) {
    var this$1$12 = this;
    var i2 = 0;
    reverse3 && ensureSize(collection);
    return collection.__iterate(
      function(v2, k2) {
        return fn2(v2, useKeys ? k2 : reverse3 ? this$1$12.size - ++i2 : i2++, this$1$12);
      },
      !reverse3
    );
  };
  reversedSequence.__iterator = function(type, reverse3) {
    var i2 = 0;
    reverse3 && ensureSize(collection);
    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      return iteratorValue(
        type,
        useKeys ? entry[0] : reverse3 ? this$1$1.size - ++i2 : i2++,
        entry[1],
        step
      );
    });
  };
  return reversedSequence;
}
function filterFactory(collection, predicate, context2, useKeys) {
  var filterSequence = makeSequence(collection);
  if (useKeys) {
    filterSequence.has = function(key) {
      var v2 = collection.get(key, NOT_SET);
      return v2 !== NOT_SET && !!predicate.call(context2, v2, key, collection);
    };
    filterSequence.get = function(key, notSetValue) {
      var v2 = collection.get(key, NOT_SET);
      return v2 !== NOT_SET && predicate.call(context2, v2, key, collection) ? v2 : notSetValue;
    };
  }
  filterSequence.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(function(v2, k2, c2) {
      if (predicate.call(context2, v2, k2, c2)) {
        iterations++;
        return fn2(v2, useKeys ? k2 : iterations - 1, this$1$1);
      }
    }, reverse3);
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterations = 0;
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        var value = entry[1];
        if (predicate.call(context2, value, key, collection)) {
          return iteratorValue(type, useKeys ? key : iterations++, value, step);
        }
      }
    });
  };
  return filterSequence;
}
function countByFactory(collection, grouper, context2) {
  var groups = Map$1().asMutable();
  collection.__iterate(function(v2, k2) {
    groups.update(grouper.call(context2, v2, k2, collection), 0, function(a2) {
      return a2 + 1;
    });
  });
  return groups.asImmutable();
}
function groupByFactory(collection, grouper, context2) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map$1()).asMutable();
  collection.__iterate(function(v2, k2) {
    groups.update(
      grouper.call(context2, v2, k2, collection),
      function(a2) {
        return a2 = a2 || [], a2.push(isKeyedIter ? [k2, v2] : v2), a2;
      }
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr2) {
    return reify(collection, coerce(arr2));
  }).asImmutable();
}
function partitionFactory(collection, predicate, context2) {
  var isKeyedIter = isKeyed(collection);
  var groups = [[], []];
  collection.__iterate(function(v2, k2) {
    groups[predicate.call(context2, v2, k2, collection) ? 1 : 0].push(
      isKeyedIter ? [k2, v2] : v2
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr2) {
    return reify(collection, coerce(arr2));
  });
}
function sliceFactory(collection, begin, end, useKeys) {
  var originalSize = collection.size;
  if (wholeSlice(begin, end, originalSize)) {
    return collection;
  }
  if (typeof originalSize === "undefined" && (begin < 0 || end < 0)) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
  }
  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end, originalSize);
  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;
  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }
  var sliceSeq = makeSequence(collection);
  sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || void 0;
  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
    };
  }
  sliceSeq.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    if (sliceSize === 0) {
      return 0;
    }
    if (reverse3) {
      return this.cacheResult().__iterate(fn2, reverse3);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v2, k2) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return fn2(v2, useKeys ? k2 : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
      }
    });
    return iterations;
  };
  sliceSeq.__iteratorUncached = function(type, reverse3) {
    if (sliceSize !== 0 && reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    if (sliceSize === 0) {
      return new Iterator(iteratorDone);
    }
    var iterator = collection.__iterator(type, reverse3);
    var skipped = 0;
    var iterations = 0;
    return new Iterator(function() {
      while (skipped++ < resolvedBegin) {
        iterator.next();
      }
      if (++iterations > sliceSize) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (useKeys || type === ITERATE_VALUES || step.done) {
        return step;
      }
      if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations - 1, void 0, step);
      }
      return iteratorValue(type, iterations - 1, step.value[1], step);
    });
  };
  return sliceSeq;
}
function takeWhileFactory(collection, predicate, context2) {
  var takeSequence = makeSequence(collection);
  takeSequence.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn2, reverse3);
    }
    var iterations = 0;
    collection.__iterate(
      function(v2, k2, c2) {
        return predicate.call(context2, v2, k2, c2) && ++iterations && fn2(v2, k2, this$1$1);
      }
    );
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterating = true;
    return new Iterator(function() {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k2 = entry[0];
      var v2 = entry[1];
      if (!predicate.call(context2, v2, k2, this$1$1)) {
        iterating = false;
        return iteratorDone();
      }
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k2, v2, step);
    });
  };
  return takeSequence;
}
function skipWhileFactory(collection, predicate, context2, useKeys) {
  var skipSequence = makeSequence(collection);
  skipSequence.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn2, reverse3);
    }
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v2, k2, c2) {
      if (!(isSkipping && (isSkipping = predicate.call(context2, v2, k2, c2)))) {
        iterations++;
        return fn2(v2, useKeys ? k2 : iterations - 1, this$1$1);
      }
    });
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var skipping = true;
    var iterations = 0;
    return new Iterator(function() {
      var step;
      var k2;
      var v2;
      do {
        step = iterator.next();
        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          }
          if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, void 0, step);
          }
          return iteratorValue(type, iterations++, step.value[1], step);
        }
        var entry = step.value;
        k2 = entry[0];
        v2 = entry[1];
        skipping && (skipping = predicate.call(context2, v2, k2, this$1$1));
      } while (skipping);
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k2, v2, step);
    });
  };
  return skipSequence;
}
function concatFactory(collection, values2) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection].concat(values2).map(function(v2) {
    if (!isCollection(v2)) {
      v2 = isKeyedCollection ? keyedSeqFromValue(v2) : indexedSeqFromValue(Array.isArray(v2) ? v2 : [v2]);
    } else if (isKeyedCollection) {
      v2 = KeyedCollection(v2);
    }
    return v2;
  }).filter(function(v2) {
    return v2.size !== 0;
  });
  if (iters.length === 0) {
    return collection;
  }
  if (iters.length === 1) {
    var singleton = iters[0];
    if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
      return singleton;
    }
  }
  var concatSeq = new ArraySeq(iters);
  if (isKeyedCollection) {
    concatSeq = concatSeq.toKeyedSeq();
  } else if (!isIndexed(collection)) {
    concatSeq = concatSeq.toSetSeq();
  }
  concatSeq = concatSeq.flatten(true);
  concatSeq.size = iters.reduce(function(sum, seq) {
    if (sum !== void 0) {
      var size = seq.size;
      if (size !== void 0) {
        return sum + size;
      }
    }
  }, 0);
  return concatSeq;
}
function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);
  flatSequence.__iterateUncached = function(fn2, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn2, reverse3);
    }
    var iterations = 0;
    var stopped = false;
    function flatDeep(iter, currentDepth) {
      iter.__iterate(function(v2, k2) {
        if ((!depth || currentDepth < depth) && isCollection(v2)) {
          flatDeep(v2, currentDepth + 1);
        } else {
          iterations++;
          if (fn2(v2, useKeys ? k2 : iterations - 1, flatSequence) === false) {
            stopped = true;
          }
        }
        return !stopped;
      }, reverse3);
    }
    flatDeep(collection, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(type, reverse3);
    var stack = [];
    var iterations = 0;
    return new Iterator(function() {
      while (iterator) {
        var step = iterator.next();
        if (step.done !== false) {
          iterator = stack.pop();
          continue;
        }
        var v2 = step.value;
        if (type === ITERATE_ENTRIES) {
          v2 = v2[1];
        }
        if ((!depth || stack.length < depth) && isCollection(v2)) {
          stack.push(iterator);
          iterator = v2.__iterator(type, reverse3);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v2, step);
        }
      }
      return iteratorDone();
    });
  };
  return flatSequence;
}
function flatMapFactory(collection, mapper, context2) {
  var coerce = collectionClass(collection);
  return collection.toSeq().map(function(v2, k2) {
    return coerce(mapper.call(context2, v2, k2, collection));
  }).flatten(true);
}
function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;
  interposedSequence.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(
      function(v2) {
        return (!iterations || fn2(separator, iterations++, this$1$1) !== false) && fn2(v2, iterations++, this$1$1) !== false;
      },
      reverse3
    );
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_VALUES, reverse3);
    var iterations = 0;
    var step;
    return new Iterator(function() {
      if (!step || iterations % 2) {
        step = iterator.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
    });
  };
  return interposedSequence;
}
function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  var isKeyedCollection = isKeyed(collection);
  var index = 0;
  var entries3 = collection.toSeq().map(function(v2, k2) {
    return [k2, v2, index++, mapper ? mapper(v2, k2, collection) : v2];
  }).valueSeq().toArray();
  entries3.sort(function(a2, b2) {
    return comparator(a2[3], b2[3]) || a2[2] - b2[2];
  }).forEach(
    isKeyedCollection ? function(v2, i2) {
      entries3[i2].length = 2;
    } : function(v2, i2) {
      entries3[i2] = v2[1];
    }
  );
  return isKeyedCollection ? KeyedSeq(entries3) : isIndexed(collection) ? IndexedSeq(entries3) : SetSeq(entries3);
}
function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  if (mapper) {
    var entry = collection.toSeq().map(function(v2, k2) {
      return [v2, mapper(v2, k2, collection)];
    }).reduce(function(a2, b2) {
      return maxCompare(comparator, a2[1], b2[1]) ? b2 : a2;
    });
    return entry && entry[0];
  }
  return collection.reduce(function(a2, b2) {
    return maxCompare(comparator, a2, b2) ? b2 : a2;
  });
}
function maxCompare(comparator, a2, b2) {
  var comp = comparator(b2, a2);
  return comp === 0 && b2 !== a2 && (b2 === void 0 || b2 === null || b2 !== b2) || comp > 0;
}
function zipWithFactory(keyIter, zipper, iters, zipAll2) {
  var zipSequence = makeSequence(keyIter);
  var sizes = new ArraySeq(iters).map(function(i2) {
    return i2.size;
  });
  zipSequence.size = zipAll2 ? sizes.max() : sizes.min();
  zipSequence.__iterate = function(fn2, reverse3) {
    var iterator = this.__iterator(ITERATE_VALUES, reverse3);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      if (fn2(step.value, iterations++, this) === false) {
        break;
      }
    }
    return iterations;
  };
  zipSequence.__iteratorUncached = function(type, reverse3) {
    var iterators = iters.map(
      function(i2) {
        return i2 = Collection(i2), getIterator(reverse3 ? i2.reverse() : i2);
      }
    );
    var iterations = 0;
    var isDone = false;
    return new Iterator(function() {
      var steps;
      if (!isDone) {
        steps = iterators.map(function(i2) {
          return i2.next();
        });
        isDone = zipAll2 ? steps.every(function(s2) {
          return s2.done;
        }) : steps.some(function(s2) {
          return s2.done;
        });
      }
      if (isDone) {
        return iteratorDone();
      }
      return iteratorValue(
        type,
        iterations++,
        zipper.apply(
          null,
          steps.map(function(s2) {
            return s2.value;
          })
        )
      );
    });
  };
  return zipSequence;
}
function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}
function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError("Expected [K, V] tuple: " + entry);
  }
}
function collectionClass(collection) {
  return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
}
function makeSequence(collection) {
  return Object.create(
    (isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype
  );
}
function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();
    this.size = this._iter.size;
    return this;
  }
  return Seq.prototype.cacheResult.call(this);
}
function defaultComparator(a2, b2) {
  if (a2 === void 0 && b2 === void 0) {
    return 0;
  }
  if (a2 === void 0) {
    return 1;
  }
  if (b2 === void 0) {
    return -1;
  }
  return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
}
function arrCopy(arr2, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr2.length - offset);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr2[ii + offset];
  }
  return newArr;
}
function invariant$1(condition, error2) {
  if (!condition) {
    throw new Error(error2);
  }
}
function assertNotInfinite(size) {
  invariant$1(
    size !== Infinity,
    "Cannot perform this action with an infinite size."
  );
}
function coerceKeyPath(keyPath) {
  if (isArrayLike(keyPath) && typeof keyPath !== "string") {
    return keyPath;
  }
  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }
  throw new TypeError(
    "Invalid keyPath: expected Ordered Collection or Array: " + keyPath
  );
}
var toString2 = Object.prototype.toString;
function isPlainObject$1(value) {
  if (!value || typeof value !== "object" || toString2.call(value) !== "[object Object]") {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  var parentProto = proto;
  var nextProto = Object.getPrototypeOf(proto);
  while (nextProto !== null) {
    parentProto = nextProto;
    nextProto = Object.getPrototypeOf(parentProto);
  }
  return parentProto === proto;
}
function isDataStructure(value) {
  return typeof value === "object" && (isImmutable(value) || Array.isArray(value) || isPlainObject$1(value));
}
function quoteString(value) {
  try {
    return typeof value === "string" ? JSON.stringify(value) : String(value);
  } catch (_ignoreError) {
    return JSON.stringify(value);
  }
}
function has(collection, key) {
  return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty$1.call(collection, key);
}
function get(collection, key, notSetValue) {
  return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === "function" ? collection.get(key) : collection[key];
}
function shallowCopy(from) {
  if (Array.isArray(from)) {
    return arrCopy(from);
  }
  var to2 = {};
  for (var key in from) {
    if (hasOwnProperty$1.call(from, key)) {
      to2[key] = from[key];
    }
  }
  return to2;
}
function remove2(collection, key) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.remove) {
      throw new TypeError(
        "Cannot update immutable value without .remove() method: " + collection
      );
    }
    return collection.remove(key);
  }
  if (!hasOwnProperty$1.call(collection, key)) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  if (Array.isArray(collectionCopy)) {
    collectionCopy.splice(key, 1);
  } else {
    delete collectionCopy[key];
  }
  return collectionCopy;
}
function set(collection, key, value) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.set) {
      throw new TypeError(
        "Cannot update immutable value without .set() method: " + collection
      );
    }
    return collection.set(key, value);
  }
  if (hasOwnProperty$1.call(collection, key) && value === collection[key]) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  collectionCopy[key] = value;
  return collectionCopy;
}
function updateIn$1(collection, keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = void 0;
  }
  var updatedValue = updateInDeeply(
    isImmutable(collection),
    collection,
    coerceKeyPath(keyPath),
    0,
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? notSetValue : updatedValue;
}
function updateInDeeply(inImmutable, existing, keyPath, i2, notSetValue, updater) {
  var wasNotSet = existing === NOT_SET;
  if (i2 === keyPath.length) {
    var existingValue = wasNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }
  if (!wasNotSet && !isDataStructure(existing)) {
    throw new TypeError(
      "Cannot update within non-data-structure value in path [" + keyPath.slice(0, i2).map(quoteString) + "]: " + existing
    );
  }
  var key = keyPath[i2];
  var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
  var nextUpdated = updateInDeeply(
    nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),
    nextExisting,
    keyPath,
    i2 + 1,
    notSetValue,
    updater
  );
  return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove2(existing, key) : set(
    wasNotSet ? inImmutable ? emptyMap() : {} : existing,
    key,
    nextUpdated
  );
}
function setIn$1(collection, keyPath, value) {
  return updateIn$1(collection, keyPath, NOT_SET, function() {
    return value;
  });
}
function setIn(keyPath, v2) {
  return setIn$1(this, keyPath, v2);
}
function removeIn(collection, keyPath) {
  return updateIn$1(collection, keyPath, function() {
    return NOT_SET;
  });
}
function deleteIn(keyPath) {
  return removeIn(this, keyPath);
}
function update$1(collection, key, notSetValue, updater) {
  return updateIn$1(collection, [key], notSetValue, updater);
}
function update$2(key, notSetValue, updater) {
  return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);
}
function updateIn(keyPath, notSetValue, updater) {
  return updateIn$1(this, keyPath, notSetValue, updater);
}
function merge$1() {
  var iters = [], len = arguments.length;
  while (len--) iters[len] = arguments[len];
  return mergeIntoKeyedWith(this, iters);
}
function mergeWith$1(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  if (typeof merger !== "function") {
    throw new TypeError("Invalid merger function: " + merger);
  }
  return mergeIntoKeyedWith(this, iters, merger);
}
function mergeIntoKeyedWith(collection, collections, merger) {
  var iters = [];
  for (var ii = 0; ii < collections.length; ii++) {
    var collection$1 = KeyedCollection(collections[ii]);
    if (collection$1.size !== 0) {
      iters.push(collection$1);
    }
  }
  if (iters.length === 0) {
    return collection;
  }
  if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
    return collection.constructor(iters[0]);
  }
  return collection.withMutations(function(collection2) {
    var mergeIntoCollection = merger ? function(value, key) {
      update$1(
        collection2,
        key,
        NOT_SET,
        function(oldVal) {
          return oldVal === NOT_SET ? value : merger(oldVal, value, key);
        }
      );
    } : function(value, key) {
      collection2.set(key, value);
    };
    for (var ii2 = 0; ii2 < iters.length; ii2++) {
      iters[ii2].forEach(mergeIntoCollection);
    }
  });
}
function merge(collection) {
  var sources = [], len = arguments.length - 1;
  while (len-- > 0) sources[len] = arguments[len + 1];
  return mergeWithSources(collection, sources);
}
function mergeWith(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while (len-- > 0) sources[len] = arguments[len + 2];
  return mergeWithSources(collection, sources, merger);
}
function mergeDeep$1(collection) {
  var sources = [], len = arguments.length - 1;
  while (len-- > 0) sources[len] = arguments[len + 1];
  return mergeDeepWithSources(collection, sources);
}
function mergeDeepWith$1(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while (len-- > 0) sources[len] = arguments[len + 2];
  return mergeDeepWithSources(collection, sources, merger);
}
function mergeDeepWithSources(collection, sources, merger) {
  return mergeWithSources(collection, sources, deepMergerWith(merger));
}
function mergeWithSources(collection, sources, merger) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot merge into non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    return typeof merger === "function" && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
  }
  var isArray = Array.isArray(collection);
  var merged = collection;
  var Collection3 = isArray ? IndexedCollection : KeyedCollection;
  var mergeItem = isArray ? function(value) {
    if (merged === collection) {
      merged = shallowCopy(merged);
    }
    merged.push(value);
  } : function(value, key) {
    var hasVal = hasOwnProperty$1.call(merged, key);
    var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
    if (!hasVal || nextVal !== merged[key]) {
      if (merged === collection) {
        merged = shallowCopy(merged);
      }
      merged[key] = nextVal;
    }
  };
  for (var i2 = 0; i2 < sources.length; i2++) {
    Collection3(sources[i2]).forEach(mergeItem);
  }
  return merged;
}
function deepMergerWith(merger) {
  function deepMerger(oldValue, newValue, key) {
    return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
  }
  return deepMerger;
}
function areMergeable(oldDataStructure, newDataStructure) {
  var oldSeq = Seq(oldDataStructure);
  var newSeq = Seq(newDataStructure);
  return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
}
function mergeDeep() {
  var iters = [], len = arguments.length;
  while (len--) iters[len] = arguments[len];
  return mergeDeepWithSources(this, iters);
}
function mergeDeepWith(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  return mergeDeepWithSources(this, iters, merger);
}
function mergeIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  return updateIn$1(this, keyPath, emptyMap(), function(m2) {
    return mergeWithSources(m2, iters);
  });
}
function mergeDeepIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  return updateIn$1(
    this,
    keyPath,
    emptyMap(),
    function(m2) {
      return mergeDeepWithSources(m2, iters);
    }
  );
}
function withMutations(fn2) {
  var mutable = this.asMutable();
  fn2(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}
function asMutable() {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}
function asImmutable() {
  return this.__ensureOwner();
}
function wasAltered() {
  return this.__altered;
}
var Map$1 = /* @__PURE__ */ (function(KeyedCollection2) {
  function Map2(value) {
    return value === void 0 || value === null ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map3) {
      var iter = KeyedCollection2(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v2, k2) {
        return map3.set(k2, v2);
      });
    });
  }
  if (KeyedCollection2) Map2.__proto__ = KeyedCollection2;
  Map2.prototype = Object.create(KeyedCollection2 && KeyedCollection2.prototype);
  Map2.prototype.constructor = Map2;
  Map2.of = function of() {
    var keyValues = [], len = arguments.length;
    while (len--) keyValues[len] = arguments[len];
    return emptyMap().withMutations(function(map3) {
      for (var i2 = 0; i2 < keyValues.length; i2 += 2) {
        if (i2 + 1 >= keyValues.length) {
          throw new Error("Missing value for key: " + keyValues[i2]);
        }
        map3.set(keyValues[i2], keyValues[i2 + 1]);
      }
    });
  };
  Map2.prototype.toString = function toString5() {
    return this.__toString("Map {", "}");
  };
  Map2.prototype.get = function get11(k2, notSetValue) {
    return this._root ? this._root.get(0, void 0, k2, notSetValue) : notSetValue;
  };
  Map2.prototype.set = function set3(k2, v2) {
    return updateMap(this, k2, v2);
  };
  Map2.prototype.remove = function remove4(k2) {
    return updateMap(this, k2, NOT_SET);
  };
  Map2.prototype.deleteAll = function deleteAll(keys2) {
    var collection = Collection(keys2);
    if (collection.size === 0) {
      return this;
    }
    return this.withMutations(function(map3) {
      collection.forEach(function(key) {
        return map3.remove(key);
      });
    });
  };
  Map2.prototype.clear = function clear3() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._root = null;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyMap();
  };
  Map2.prototype.sort = function sort2(comparator) {
    return OrderedMap(sortFactory(this, comparator));
  };
  Map2.prototype.sortBy = function sortBy2(mapper, comparator) {
    return OrderedMap(sortFactory(this, comparator, mapper));
  };
  Map2.prototype.map = function map3(mapper, context2) {
    var this$1$1 = this;
    return this.withMutations(function(map4) {
      map4.forEach(function(value, key) {
        map4.set(key, mapper.call(context2, value, key, this$1$1));
      });
    });
  };
  Map2.prototype.__iterator = function __iterator2(type, reverse3) {
    return new MapIterator(this, type, reverse3);
  };
  Map2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    this._root && this._root.iterate(function(entry) {
      iterations++;
      return fn2(entry[1], entry[0], this$1$1);
    }, reverse3);
    return iterations;
  };
  Map2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  };
  return Map2;
})(KeyedCollection);
Map$1.isMap = isMap;
var MapPrototype = Map$1.prototype;
MapPrototype[IS_MAP_SYMBOL] = true;
MapPrototype[DELETE] = MapPrototype.remove;
MapPrototype.removeAll = MapPrototype.deleteAll;
MapPrototype.setIn = setIn;
MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
MapPrototype.update = update$2;
MapPrototype.updateIn = updateIn;
MapPrototype.merge = MapPrototype.concat = merge$1;
MapPrototype.mergeWith = mergeWith$1;
MapPrototype.mergeDeep = mergeDeep;
MapPrototype.mergeDeepWith = mergeDeepWith;
MapPrototype.mergeIn = mergeIn;
MapPrototype.mergeDeepIn = mergeDeepIn;
MapPrototype.withMutations = withMutations;
MapPrototype.wasAltered = wasAltered;
MapPrototype.asImmutable = asImmutable;
MapPrototype["@@transducer/init"] = MapPrototype.asMutable = asMutable;
MapPrototype["@@transducer/step"] = function(result, arr2) {
  return result.set(arr2[0], arr2[1]);
};
MapPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
var ArrayMapNode = function ArrayMapNode2(ownerID, entries3) {
  this.ownerID = ownerID;
  this.entries = entries3;
};
ArrayMapNode.prototype.get = function get2(shift, keyHash, key, notSetValue) {
  var entries3 = this.entries;
  for (var ii = 0, len = entries3.length; ii < len; ii++) {
    if (is(key, entries3[ii][0])) {
      return entries3[ii][1];
    }
  }
  return notSetValue;
};
ArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var entries3 = this.entries;
  var idx = 0;
  var len = entries3.length;
  for (; idx < len; idx++) {
    if (is(key, entries3[idx][0])) {
      break;
    }
  }
  var exists = idx < len;
  if (exists ? entries3[idx][1] === value : removed) {
    return this;
  }
  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);
  if (removed && entries3.length === 1) {
    return;
  }
  if (!exists && !removed && entries3.length >= MAX_ARRAY_MAP_SIZE) {
    return createNodes(ownerID, entries3, key, value);
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries3 : arrCopy(entries3);
  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }
  if (isEditable) {
    this.entries = newEntries;
    return this;
  }
  return new ArrayMapNode(ownerID, newEntries);
};
var BitmapIndexedNode = function BitmapIndexedNode2(ownerID, bitmap, nodes) {
  this.ownerID = ownerID;
  this.bitmap = bitmap;
  this.nodes = nodes;
};
BitmapIndexedNode.prototype.get = function get3(shift, keyHash, key, notSetValue) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
  var bitmap = this.bitmap;
  return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(
    shift + SHIFT,
    keyHash,
    key,
    notSetValue
  );
};
BitmapIndexedNode.prototype.update = function update2(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var bit = 1 << keyHashFrag;
  var bitmap = this.bitmap;
  var exists = (bitmap & bit) !== 0;
  if (!exists && value === NOT_SET) {
    return this;
  }
  var idx = popCount(bitmap & bit - 1);
  var nodes = this.nodes;
  var node = exists ? nodes[idx] : void 0;
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }
  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
  }
  if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
    return nodes[idx ^ 1];
  }
  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
    return newNode;
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
  var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
  if (isEditable) {
    this.bitmap = newBitmap;
    this.nodes = newNodes;
    return this;
  }
  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
};
var HashArrayMapNode = function HashArrayMapNode2(ownerID, count2, nodes) {
  this.ownerID = ownerID;
  this.count = count2;
  this.nodes = nodes;
};
HashArrayMapNode.prototype.get = function get4(shift, keyHash, key, notSetValue) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var node = this.nodes[idx];
  return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
};
HashArrayMapNode.prototype.update = function update3(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var removed = value === NOT_SET;
  var nodes = this.nodes;
  var node = nodes[idx];
  if (removed && !node) {
    return this;
  }
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }
  var newCount = this.count;
  if (!node) {
    newCount++;
  } else if (!newNode) {
    newCount--;
    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
      return packNodes(ownerID, nodes, newCount, idx);
    }
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newNodes = setAt(nodes, idx, newNode, isEditable);
  if (isEditable) {
    this.count = newCount;
    this.nodes = newNodes;
    return this;
  }
  return new HashArrayMapNode(ownerID, newCount, newNodes);
};
var HashCollisionNode = function HashCollisionNode2(ownerID, keyHash, entries3) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entries = entries3;
};
HashCollisionNode.prototype.get = function get5(shift, keyHash, key, notSetValue) {
  var entries3 = this.entries;
  for (var ii = 0, len = entries3.length; ii < len; ii++) {
    if (is(key, entries3[ii][0])) {
      return entries3[ii][1];
    }
  }
  return notSetValue;
};
HashCollisionNode.prototype.update = function update4(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var removed = value === NOT_SET;
  if (keyHash !== this.keyHash) {
    if (removed) {
      return this;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
  }
  var entries3 = this.entries;
  var idx = 0;
  var len = entries3.length;
  for (; idx < len; idx++) {
    if (is(key, entries3[idx][0])) {
      break;
    }
  }
  var exists = idx < len;
  if (exists ? entries3[idx][1] === value : removed) {
    return this;
  }
  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);
  if (removed && len === 2) {
    return new ValueNode(ownerID, this.keyHash, entries3[idx ^ 1]);
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries3 : arrCopy(entries3);
  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }
  if (isEditable) {
    this.entries = newEntries;
    return this;
  }
  return new HashCollisionNode(ownerID, this.keyHash, newEntries);
};
var ValueNode = function ValueNode2(ownerID, keyHash, entry) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entry = entry;
};
ValueNode.prototype.get = function get6(shift, keyHash, key, notSetValue) {
  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
};
ValueNode.prototype.update = function update5(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var keyMatch = is(key, this.entry[0]);
  if (keyMatch ? value === this.entry[1] : removed) {
    return this;
  }
  SetRef(didAlter);
  if (removed) {
    SetRef(didChangeSize);
    return;
  }
  if (keyMatch) {
    if (ownerID && ownerID === this.ownerID) {
      this.entry[1] = value;
      return this;
    }
    return new ValueNode(ownerID, this.keyHash, [key, value]);
  }
  SetRef(didChangeSize);
  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
};
ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn2, reverse3) {
  var entries3 = this.entries;
  for (var ii = 0, maxIndex = entries3.length - 1; ii <= maxIndex; ii++) {
    if (fn2(entries3[reverse3 ? maxIndex - ii : ii]) === false) {
      return false;
    }
  }
};
BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn2, reverse3) {
  var nodes = this.nodes;
  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
    var node = nodes[reverse3 ? maxIndex - ii : ii];
    if (node && node.iterate(fn2, reverse3) === false) {
      return false;
    }
  }
};
ValueNode.prototype.iterate = function(fn2, reverse3) {
  return fn2(this.entry);
};
var MapIterator = /* @__PURE__ */ (function(Iterator3) {
  function MapIterator2(map3, type, reverse3) {
    this._type = type;
    this._reverse = reverse3;
    this._stack = map3._root && mapIteratorFrame(map3._root);
  }
  if (Iterator3) MapIterator2.__proto__ = Iterator3;
  MapIterator2.prototype = Object.create(Iterator3 && Iterator3.prototype);
  MapIterator2.prototype.constructor = MapIterator2;
  MapIterator2.prototype.next = function next() {
    var type = this._type;
    var stack = this._stack;
    while (stack) {
      var node = stack.node;
      var index = stack.index++;
      var maxIndex = void 0;
      if (node.entry) {
        if (index === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;
        if (index <= maxIndex) {
          return mapIteratorValue(
            type,
            node.entries[this._reverse ? maxIndex - index : index]
          );
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index <= maxIndex) {
          var subNode = node.nodes[this._reverse ? maxIndex - index : index];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack = this._stack = mapIteratorFrame(subNode, stack);
          }
          continue;
        }
      }
      stack = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  };
  return MapIterator2;
})(Iterator);
function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
function makeMap(size, root, ownerID, hash2) {
  var map3 = Object.create(MapPrototype);
  map3.size = size;
  map3._root = root;
  map3.__ownerID = ownerID;
  map3.__hash = hash2;
  map3.__altered = false;
  return map3;
}
var EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map3, k2, v2) {
  var newRoot;
  var newSize;
  if (!map3._root) {
    if (v2 === NOT_SET) {
      return map3;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map3.__ownerID, [[k2, v2]]);
  } else {
    var didChangeSize = MakeRef();
    var didAlter = MakeRef();
    newRoot = updateNode(
      map3._root,
      map3.__ownerID,
      0,
      void 0,
      k2,
      v2,
      didChangeSize,
      didAlter
    );
    if (!didAlter.value) {
      return map3;
    }
    newSize = map3.size + (didChangeSize.value ? v2 === NOT_SET ? -1 : 1 : 0);
  }
  if (map3.__ownerID) {
    map3.size = newSize;
    map3._root = newRoot;
    map3.__hash = void 0;
    map3.__altered = true;
    return map3;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(
    ownerID,
    shift,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }
  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var newNode;
  var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries3, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  var node = new ValueNode(ownerID, hash(key), [key, value]);
  for (var ii = 0; ii < entries3.length; ii++) {
    var entry = entries3[ii];
    node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
  }
  return node;
}
function packNodes(ownerID, nodes, count2, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count2);
  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count2 = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count2 + 1, expandedNodes);
}
function popCount(x2) {
  x2 -= x2 >> 1 & 1431655765;
  x2 = (x2 & 858993459) + (x2 >> 2 & 858993459);
  x2 = x2 + (x2 >> 4) & 252645135;
  x2 += x2 >> 8;
  x2 += x2 >> 16;
  return x2 & 127;
}
function setAt(array2, idx, val, canEdit) {
  var newArray = canEdit ? array2 : arrCopy(array2);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array2, idx, val, canEdit) {
  var newLen = array2.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array2[idx] = val;
    return array2;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array2[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array2, idx, canEdit) {
  var newLen = array2.length - 1;
  if (canEdit && idx === newLen) {
    array2.pop();
    return array2;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array2[ii + after];
  }
  return newArray;
}
var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
var IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";
function isList(maybeList) {
  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
}
var List = /* @__PURE__ */ (function(IndexedCollection2) {
  function List2(value) {
    var empty = emptyList();
    if (value === void 0 || value === null) {
      return empty;
    }
    if (isList(value)) {
      return value;
    }
    var iter = IndexedCollection2(value);
    var size = iter.size;
    if (size === 0) {
      return empty;
    }
    assertNotInfinite(size);
    if (size > 0 && size < SIZE) {
      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
    }
    return empty.withMutations(function(list) {
      list.setSize(size);
      iter.forEach(function(v2, i2) {
        return list.set(i2, v2);
      });
    });
  }
  if (IndexedCollection2) List2.__proto__ = IndexedCollection2;
  List2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
  List2.prototype.constructor = List2;
  List2.of = function of() {
    return this(arguments);
  };
  List2.prototype.toString = function toString5() {
    return this.__toString("List [", "]");
  };
  List2.prototype.get = function get11(index, notSetValue) {
    index = wrapIndex(this, index);
    if (index >= 0 && index < this.size) {
      index += this._origin;
      var node = listNodeFor(this, index);
      return node && node.array[index & MASK];
    }
    return notSetValue;
  };
  List2.prototype.set = function set3(index, value) {
    return updateList(this, index, value);
  };
  List2.prototype.remove = function remove4(index) {
    return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
  };
  List2.prototype.insert = function insert(index, value) {
    return this.splice(index, 0, value);
  };
  List2.prototype.clear = function clear3() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = this._origin = this._capacity = 0;
      this._level = SHIFT;
      this._root = this._tail = this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyList();
  };
  List2.prototype.push = function push() {
    var values2 = arguments;
    var oldSize = this.size;
    return this.withMutations(function(list) {
      setListBounds(list, 0, oldSize + values2.length);
      for (var ii = 0; ii < values2.length; ii++) {
        list.set(oldSize + ii, values2[ii]);
      }
    });
  };
  List2.prototype.pop = function pop() {
    return setListBounds(this, 0, -1);
  };
  List2.prototype.unshift = function unshift() {
    var values2 = arguments;
    return this.withMutations(function(list) {
      setListBounds(list, -values2.length);
      for (var ii = 0; ii < values2.length; ii++) {
        list.set(ii, values2[ii]);
      }
    });
  };
  List2.prototype.shift = function shift() {
    return setListBounds(this, 1);
  };
  List2.prototype.concat = function concat2() {
    var arguments$1 = arguments;
    var seqs = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      var argument = arguments$1[i2];
      var seq = IndexedCollection2(
        typeof argument !== "string" && hasIterator(argument) ? argument : [argument]
      );
      if (seq.size !== 0) {
        seqs.push(seq);
      }
    }
    if (seqs.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
      return this.constructor(seqs[0]);
    }
    return this.withMutations(function(list) {
      seqs.forEach(function(seq2) {
        return seq2.forEach(function(value) {
          return list.push(value);
        });
      });
    });
  };
  List2.prototype.setSize = function setSize(size) {
    return setListBounds(this, 0, size);
  };
  List2.prototype.map = function map3(mapper, context2) {
    var this$1$1 = this;
    return this.withMutations(function(list) {
      for (var i2 = 0; i2 < this$1$1.size; i2++) {
        list.set(i2, mapper.call(context2, list.get(i2), i2, this$1$1));
      }
    });
  };
  List2.prototype.slice = function slice4(begin, end) {
    var size = this.size;
    if (wholeSlice(begin, end, size)) {
      return this;
    }
    return setListBounds(
      this,
      resolveBegin(begin, size),
      resolveEnd(end, size)
    );
  };
  List2.prototype.__iterator = function __iterator2(type, reverse3) {
    var index = reverse3 ? this.size : 0;
    var values2 = iterateList(this, reverse3);
    return new Iterator(function() {
      var value = values2();
      return value === DONE ? iteratorDone() : iteratorValue(type, reverse3 ? --index : index++, value);
    });
  };
  List2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var index = reverse3 ? this.size : 0;
    var values2 = iterateList(this, reverse3);
    var value;
    while ((value = values2()) !== DONE) {
      if (fn2(value, reverse3 ? --index : index++, this) === false) {
        break;
      }
    }
    return index;
  };
  List2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyList();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeList(
      this._origin,
      this._capacity,
      this._level,
      this._root,
      this._tail,
      ownerID,
      this.__hash
    );
  };
  return List2;
})(IndexedCollection);
List.isList = isList;
var ListPrototype = List.prototype;
ListPrototype[IS_LIST_SYMBOL] = true;
ListPrototype[DELETE] = ListPrototype.remove;
ListPrototype.merge = ListPrototype.concat;
ListPrototype.setIn = setIn;
ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
ListPrototype.update = update$2;
ListPrototype.updateIn = updateIn;
ListPrototype.mergeIn = mergeIn;
ListPrototype.mergeDeepIn = mergeDeepIn;
ListPrototype.withMutations = withMutations;
ListPrototype.wasAltered = wasAltered;
ListPrototype.asImmutable = asImmutable;
ListPrototype["@@transducer/init"] = ListPrototype.asMutable = asMutable;
ListPrototype["@@transducer/step"] = function(result, arr2) {
  return result.push(arr2);
};
ListPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
var VNode = function VNode2(array2, ownerID) {
  this.array = array2;
  this.ownerID = ownerID;
};
VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
  if (index === level ? 1 << level : this.array.length === 0) {
    return this;
  }
  var originIndex = index >>> level & MASK;
  if (originIndex >= this.array.length) {
    return new VNode([], ownerID);
  }
  var removingFirst = originIndex === 0;
  var newChild;
  if (level > 0) {
    var oldChild = this.array[originIndex];
    newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
    if (newChild === oldChild && removingFirst) {
      return this;
    }
  }
  if (removingFirst && !newChild) {
    return this;
  }
  var editable = editableVNode(this, ownerID);
  if (!removingFirst) {
    for (var ii = 0; ii < originIndex; ii++) {
      editable.array[ii] = void 0;
    }
  }
  if (newChild) {
    editable.array[originIndex] = newChild;
  }
  return editable;
};
VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
  if (index === (level ? 1 << level : 0) || this.array.length === 0) {
    return this;
  }
  var sizeIndex = index - 1 >>> level & MASK;
  if (sizeIndex >= this.array.length) {
    return this;
  }
  var newChild;
  if (level > 0) {
    var oldChild = this.array[sizeIndex];
    newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
    if (newChild === oldChild && sizeIndex === this.array.length - 1) {
      return this;
    }
  }
  var editable = editableVNode(this, ownerID);
  editable.array.splice(sizeIndex + 1);
  if (newChild) {
    editable.array[sizeIndex] = newChild;
  }
  return editable;
};
var DONE = {};
function iterateList(list, reverse3) {
  var left = list._origin;
  var right = list._capacity;
  var tailPos = getTailOffset(right);
  var tail = list._tail;
  return iterateNodeOrLeaf(list._root, list._level, 0);
  function iterateNodeOrLeaf(node, level, offset) {
    return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
  }
  function iterateLeaf(node, offset) {
    var array2 = offset === tailPos ? tail && tail.array : node && node.array;
    var from = offset > left ? 0 : left - offset;
    var to2 = right - offset;
    if (to2 > SIZE) {
      to2 = SIZE;
    }
    return function() {
      if (from === to2) {
        return DONE;
      }
      var idx = reverse3 ? --to2 : from++;
      return array2 && array2[idx];
    };
  }
  function iterateNode(node, level, offset) {
    var values2;
    var array2 = node && node.array;
    var from = offset > left ? 0 : left - offset >> level;
    var to2 = (right - offset >> level) + 1;
    if (to2 > SIZE) {
      to2 = SIZE;
    }
    return function() {
      while (true) {
        if (values2) {
          var value = values2();
          if (value !== DONE) {
            return value;
          }
          values2 = null;
        }
        if (from === to2) {
          return DONE;
        }
        var idx = reverse3 ? --to2 : from++;
        values2 = iterateNodeOrLeaf(
          array2 && array2[idx],
          level - SHIFT,
          offset + (idx << level)
        );
      }
    };
  }
}
function makeList(origin, capacity, level, root, tail, ownerID, hash2) {
  var list = Object.create(ListPrototype);
  list.size = capacity - origin;
  list._origin = origin;
  list._capacity = capacity;
  list._level = level;
  list._root = root;
  list._tail = tail;
  list.__ownerID = ownerID;
  list.__hash = hash2;
  list.__altered = false;
  return list;
}
var EMPTY_LIST;
function emptyList() {
  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}
function updateList(list, index, value) {
  index = wrapIndex(list, index);
  if (index !== index) {
    return list;
  }
  if (index >= list.size || index < 0) {
    return list.withMutations(function(list2) {
      index < 0 ? setListBounds(list2, index).set(0, value) : setListBounds(list2, 0, index + 1).set(index, value);
    });
  }
  index += list._origin;
  var newTail = list._tail;
  var newRoot = list._root;
  var didAlter = MakeRef();
  if (index >= getTailOffset(list._capacity)) {
    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
  } else {
    newRoot = updateVNode(
      newRoot,
      list.__ownerID,
      list._level,
      index,
      value,
      didAlter
    );
  }
  if (!didAlter.value) {
    return list;
  }
  if (list.__ownerID) {
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}
function updateVNode(node, ownerID, level, index, value, didAlter) {
  var idx = index >>> level & MASK;
  var nodeHas = node && idx < node.array.length;
  if (!nodeHas && value === void 0) {
    return node;
  }
  var newNode;
  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(
      lowerNode,
      ownerID,
      level - SHIFT,
      index,
      value,
      didAlter
    );
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }
  if (nodeHas && node.array[idx] === value) {
    return node;
  }
  if (didAlter) {
    SetRef(didAlter);
  }
  newNode = editableVNode(node, ownerID);
  if (value === void 0 && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value;
  }
  return newNode;
}
function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}
function listNodeFor(list, rawIndex) {
  if (rawIndex >= getTailOffset(list._capacity)) {
    return list._tail;
  }
  if (rawIndex < 1 << list._level + SHIFT) {
    var node = list._root;
    var level = list._level;
    while (node && level > 0) {
      node = node.array[rawIndex >>> level & MASK];
      level -= SHIFT;
    }
    return node;
  }
}
function setListBounds(list, begin, end) {
  if (begin !== void 0) {
    begin |= 0;
  }
  if (end !== void 0) {
    end |= 0;
  }
  var owner = list.__ownerID || new OwnerID();
  var oldOrigin = list._origin;
  var oldCapacity = list._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list;
  }
  if (newOrigin >= newCapacity) {
    return list.clear();
  }
  var newLevel = list._level;
  var newRoot = list._root;
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [void 0, newRoot] : [],
      owner
    );
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }
  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity);
  while (newTailOffset >= 1 << newLevel + SHIFT) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [newRoot] : [],
      owner
    );
    newLevel += SHIFT;
  }
  var oldTail = list._tail;
  var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = oldTailOffset >>> level & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
  }
  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  }
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;
    while (newRoot) {
      var beginIndex = newOrigin >>> newLevel & MASK;
      if (beginIndex !== newTailOffset >>> newLevel & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(
        owner,
        newLevel,
        newTailOffset - offsetShift
      );
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }
  if (list.__ownerID) {
    list.size = newCapacity - newOrigin;
    list._origin = newOrigin;
    list._capacity = newCapacity;
    list._level = newLevel;
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}
function getTailOffset(size) {
  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
}
var OrderedMap = /* @__PURE__ */ (function(Map2) {
  function OrderedMap2(value) {
    return value === void 0 || value === null ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map3) {
      var iter = KeyedCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v2, k2) {
        return map3.set(k2, v2);
      });
    });
  }
  if (Map2) OrderedMap2.__proto__ = Map2;
  OrderedMap2.prototype = Object.create(Map2 && Map2.prototype);
  OrderedMap2.prototype.constructor = OrderedMap2;
  OrderedMap2.of = function of() {
    return this(arguments);
  };
  OrderedMap2.prototype.toString = function toString5() {
    return this.__toString("OrderedMap {", "}");
  };
  OrderedMap2.prototype.get = function get11(k2, notSetValue) {
    var index = this._map.get(k2);
    return index !== void 0 ? this._list.get(index)[1] : notSetValue;
  };
  OrderedMap2.prototype.clear = function clear3() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._map.clear();
      this._list.clear();
      this.__altered = true;
      return this;
    }
    return emptyOrderedMap();
  };
  OrderedMap2.prototype.set = function set3(k2, v2) {
    return updateOrderedMap(this, k2, v2);
  };
  OrderedMap2.prototype.remove = function remove4(k2) {
    return updateOrderedMap(this, k2, NOT_SET);
  };
  OrderedMap2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    return this._list.__iterate(
      function(entry) {
        return entry && fn2(entry[1], entry[0], this$1$1);
      },
      reverse3
    );
  };
  OrderedMap2.prototype.__iterator = function __iterator2(type, reverse3) {
    return this._list.fromEntrySeq().__iterator(type, reverse3);
  };
  OrderedMap2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    var newList = this._list.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return emptyOrderedMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      this._map = newMap;
      this._list = newList;
      return this;
    }
    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  };
  return OrderedMap2;
})(Map$1);
OrderedMap.isOrderedMap = isOrderedMap;
OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
function makeOrderedMap(map3, list, ownerID, hash2) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map3 ? map3.size : 0;
  omap._map = map3;
  omap._list = list;
  omap.__ownerID = ownerID;
  omap.__hash = hash2;
  omap.__altered = false;
  return omap;
}
var EMPTY_ORDERED_MAP;
function emptyOrderedMap() {
  return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}
function updateOrderedMap(omap, k2, v2) {
  var map3 = omap._map;
  var list = omap._list;
  var i2 = map3.get(k2);
  var has5 = i2 !== void 0;
  var newMap;
  var newList;
  if (v2 === NOT_SET) {
    if (!has5) {
      return omap;
    }
    if (list.size >= SIZE && list.size >= map3.size * 2) {
      newList = list.filter(function(entry, idx) {
        return entry !== void 0 && i2 !== idx;
      });
      newMap = newList.toKeyedSeq().map(function(entry) {
        return entry[0];
      }).flip().toMap();
      if (omap.__ownerID) {
        newMap.__ownerID = newList.__ownerID = omap.__ownerID;
      }
    } else {
      newMap = map3.remove(k2);
      newList = i2 === list.size - 1 ? list.pop() : list.set(i2, void 0);
    }
  } else if (has5) {
    if (v2 === list.get(i2)[1]) {
      return omap;
    }
    newMap = map3;
    newList = list.set(i2, [k2, v2]);
  } else {
    newMap = map3.set(k2, list.size);
    newList = list.set(list.size, [k2, v2]);
  }
  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = void 0;
    omap.__altered = true;
    return omap;
  }
  return makeOrderedMap(newMap, newList);
}
var IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";
function isStack(maybeStack) {
  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
}
var Stack = /* @__PURE__ */ (function(IndexedCollection2) {
  function Stack2(value) {
    return value === void 0 || value === null ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
  }
  if (IndexedCollection2) Stack2.__proto__ = IndexedCollection2;
  Stack2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
  Stack2.prototype.constructor = Stack2;
  Stack2.of = function of() {
    return this(arguments);
  };
  Stack2.prototype.toString = function toString5() {
    return this.__toString("Stack [", "]");
  };
  Stack2.prototype.get = function get11(index, notSetValue) {
    var head = this._head;
    index = wrapIndex(this, index);
    while (head && index--) {
      head = head.next;
    }
    return head ? head.value : notSetValue;
  };
  Stack2.prototype.peek = function peek2() {
    return this._head && this._head.value;
  };
  Stack2.prototype.push = function push() {
    var arguments$1 = arguments;
    if (arguments.length === 0) {
      return this;
    }
    var newSize = this.size + arguments.length;
    var head = this._head;
    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments$1[ii],
        next: head
      };
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.pushAll = function pushAll(iter) {
    iter = IndexedCollection2(iter);
    if (iter.size === 0) {
      return this;
    }
    if (this.size === 0 && isStack(iter)) {
      return iter;
    }
    assertNotInfinite(iter.size);
    var newSize = this.size;
    var head = this._head;
    iter.__iterate(
      function(value) {
        newSize++;
        head = {
          value,
          next: head
        };
      },
      /* reverse */
      true
    );
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.pop = function pop() {
    return this.slice(1);
  };
  Stack2.prototype.clear = function clear3() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._head = void 0;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyStack();
  };
  Stack2.prototype.slice = function slice4(begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    var resolvedBegin = resolveBegin(begin, this.size);
    var resolvedEnd = resolveEnd(end, this.size);
    if (resolvedEnd !== this.size) {
      return IndexedCollection2.prototype.slice.call(this, begin, end);
    }
    var newSize = this.size - resolvedBegin;
    var head = this._head;
    while (resolvedBegin--) {
      head = head.next;
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyStack();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeStack(this.size, this._head, ownerID, this.__hash);
  };
  Stack2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return new ArraySeq(this.toArray()).__iterate(
        function(v2, k2) {
          return fn2(v2, k2, this$1$1);
        },
        reverse3
      );
    }
    var iterations = 0;
    var node = this._head;
    while (node) {
      if (fn2(node.value, iterations++, this) === false) {
        break;
      }
      node = node.next;
    }
    return iterations;
  };
  Stack2.prototype.__iterator = function __iterator2(type, reverse3) {
    if (reverse3) {
      return new ArraySeq(this.toArray()).__iterator(type, reverse3);
    }
    var iterations = 0;
    var node = this._head;
    return new Iterator(function() {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type, iterations++, value);
      }
      return iteratorDone();
    });
  };
  return Stack2;
})(IndexedCollection);
Stack.isStack = isStack;
var StackPrototype = Stack.prototype;
StackPrototype[IS_STACK_SYMBOL] = true;
StackPrototype.shift = StackPrototype.pop;
StackPrototype.unshift = StackPrototype.push;
StackPrototype.unshiftAll = StackPrototype.pushAll;
StackPrototype.withMutations = withMutations;
StackPrototype.wasAltered = wasAltered;
StackPrototype.asImmutable = asImmutable;
StackPrototype["@@transducer/init"] = StackPrototype.asMutable = asMutable;
StackPrototype["@@transducer/step"] = function(result, arr2) {
  return result.unshift(arr2);
};
StackPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
function makeStack(size, head, ownerID, hash2) {
  var map3 = Object.create(StackPrototype);
  map3.size = size;
  map3._head = head;
  map3.__ownerID = ownerID;
  map3.__hash = hash2;
  map3.__altered = false;
  return map3;
}
var EMPTY_STACK;
function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}
var IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";
function isSet(maybeSet) {
  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
}
function isOrderedSet(maybeOrderedSet) {
  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (!isCollection(b2) || a2.size !== void 0 && b2.size !== void 0 && a2.size !== b2.size || a2.__hash !== void 0 && b2.__hash !== void 0 && a2.__hash !== b2.__hash || isKeyed(a2) !== isKeyed(b2) || isIndexed(a2) !== isIndexed(b2) || isOrdered(a2) !== isOrdered(b2)) {
    return false;
  }
  if (a2.size === 0 && b2.size === 0) {
    return true;
  }
  var notAssociative = !isAssociative(a2);
  if (isOrdered(a2)) {
    var entries3 = a2.entries();
    return b2.every(function(v2, k2) {
      var entry = entries3.next().value;
      return entry && is(entry[1], v2) && (notAssociative || is(entry[0], k2));
    }) && entries3.next().done;
  }
  var flipped = false;
  if (a2.size === void 0) {
    if (b2.size === void 0) {
      if (typeof a2.cacheResult === "function") {
        a2.cacheResult();
      }
    } else {
      flipped = true;
      var _23 = a2;
      a2 = b2;
      b2 = _23;
    }
  }
  var allEqual = true;
  var bSize = b2.__iterate(function(v2, k2) {
    if (notAssociative ? !a2.has(v2) : flipped ? !is(v2, a2.get(k2, NOT_SET)) : !is(a2.get(k2, NOT_SET), v2)) {
      allEqual = false;
      return false;
    }
  });
  return allEqual && a2.size === bSize;
}
function mixin(ctor, methods2) {
  var keyCopier = function(key) {
    ctor.prototype[key] = methods2[key];
  };
  Object.keys(methods2).forEach(keyCopier);
  Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods2).forEach(keyCopier);
  return ctor;
}
function toJS(value) {
  if (!value || typeof value !== "object") {
    return value;
  }
  if (!isCollection(value)) {
    if (!isDataStructure(value)) {
      return value;
    }
    value = Seq(value);
  }
  if (isKeyed(value)) {
    var result$1 = {};
    value.__iterate(function(v2, k2) {
      result$1[k2] = toJS(v2);
    });
    return result$1;
  }
  var result = [];
  value.__iterate(function(v2) {
    result.push(toJS(v2));
  });
  return result;
}
var Set$1 = /* @__PURE__ */ (function(SetCollection2) {
  function Set2(value) {
    return value === void 0 || value === null ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set3) {
      var iter = SetCollection2(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v2) {
        return set3.add(v2);
      });
    });
  }
  if (SetCollection2) Set2.__proto__ = SetCollection2;
  Set2.prototype = Object.create(SetCollection2 && SetCollection2.prototype);
  Set2.prototype.constructor = Set2;
  Set2.of = function of() {
    return this(arguments);
  };
  Set2.fromKeys = function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  };
  Set2.intersect = function intersect(sets2) {
    sets2 = Collection(sets2).toArray();
    return sets2.length ? SetPrototype.intersect.apply(Set2(sets2.pop()), sets2) : emptySet();
  };
  Set2.union = function union(sets2) {
    sets2 = Collection(sets2).toArray();
    return sets2.length ? SetPrototype.union.apply(Set2(sets2.pop()), sets2) : emptySet();
  };
  Set2.prototype.toString = function toString5() {
    return this.__toString("Set {", "}");
  };
  Set2.prototype.has = function has5(value) {
    return this._map.has(value);
  };
  Set2.prototype.add = function add2(value) {
    return updateSet(this, this._map.set(value, value));
  };
  Set2.prototype.remove = function remove4(value) {
    return updateSet(this, this._map.remove(value));
  };
  Set2.prototype.clear = function clear3() {
    return updateSet(this, this._map.clear());
  };
  Set2.prototype.map = function map3(mapper, context2) {
    var this$1$1 = this;
    var didChanges = false;
    var newMap = updateSet(
      this,
      this._map.mapEntries(function(ref) {
        var v2 = ref[1];
        var mapped = mapper.call(context2, v2, v2, this$1$1);
        if (mapped !== v2) {
          didChanges = true;
        }
        return [mapped, mapped];
      }, context2)
    );
    return didChanges ? newMap : this;
  };
  Set2.prototype.union = function union() {
    var iters = [], len = arguments.length;
    while (len--) iters[len] = arguments[len];
    iters = iters.filter(function(x2) {
      return x2.size !== 0;
    });
    if (iters.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
      return this.constructor(iters[0]);
    }
    return this.withMutations(function(set3) {
      for (var ii = 0; ii < iters.length; ii++) {
        if (typeof iters[ii] === "string") {
          set3.add(iters[ii]);
        } else {
          SetCollection2(iters[ii]).forEach(function(value) {
            return set3.add(value);
          });
        }
      }
    });
  };
  Set2.prototype.intersect = function intersect() {
    var iters = [], len = arguments.length;
    while (len--) iters[len] = arguments[len];
    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function(iter) {
      return SetCollection2(iter);
    });
    var toRemove = [];
    this.forEach(function(value) {
      if (!iters.every(function(iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function(set3) {
      toRemove.forEach(function(value) {
        set3.remove(value);
      });
    });
  };
  Set2.prototype.subtract = function subtract2() {
    var iters = [], len = arguments.length;
    while (len--) iters[len] = arguments[len];
    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function(iter) {
      return SetCollection2(iter);
    });
    var toRemove = [];
    this.forEach(function(value) {
      if (iters.some(function(iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function(set3) {
      toRemove.forEach(function(value) {
        set3.remove(value);
      });
    });
  };
  Set2.prototype.sort = function sort2(comparator) {
    return OrderedSet(sortFactory(this, comparator));
  };
  Set2.prototype.sortBy = function sortBy2(mapper, comparator) {
    return OrderedSet(sortFactory(this, comparator, mapper));
  };
  Set2.prototype.wasAltered = function wasAltered3() {
    return this._map.wasAltered();
  };
  Set2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    return this._map.__iterate(function(k2) {
      return fn2(k2, k2, this$1$1);
    }, reverse3);
  };
  Set2.prototype.__iterator = function __iterator2(type, reverse3) {
    return this._map.__iterator(type, reverse3);
  };
  Set2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return this.__empty();
      }
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return this.__make(newMap, ownerID);
  };
  return Set2;
})(SetCollection);
Set$1.isSet = isSet;
var SetPrototype = Set$1.prototype;
SetPrototype[IS_SET_SYMBOL] = true;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
SetPrototype.withMutations = withMutations;
SetPrototype.asImmutable = asImmutable;
SetPrototype["@@transducer/init"] = SetPrototype.asMutable = asMutable;
SetPrototype["@@transducer/step"] = function(result, arr2) {
  return result.add(arr2);
};
SetPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
SetPrototype.__empty = emptySet;
SetPrototype.__make = makeSet;
function updateSet(set3, newMap) {
  if (set3.__ownerID) {
    set3.size = newMap.size;
    set3._map = newMap;
    return set3;
  }
  return newMap === set3._map ? set3 : newMap.size === 0 ? set3.__empty() : set3.__make(newMap);
}
function makeSet(map3, ownerID) {
  var set3 = Object.create(SetPrototype);
  set3.size = map3 ? map3.size : 0;
  set3._map = map3;
  set3.__ownerID = ownerID;
  return set3;
}
var EMPTY_SET;
function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}
var Range = /* @__PURE__ */ (function(IndexedSeq2) {
  function Range2(start, end, step) {
    if (!(this instanceof Range2)) {
      return new Range2(start, end, step);
    }
    invariant$1(step !== 0, "Cannot step a Range by 0");
    start = start || 0;
    if (end === void 0) {
      end = Infinity;
    }
    step = step === void 0 ? 1 : Math.abs(step);
    if (end < start) {
      step = -step;
    }
    this._start = start;
    this._end = end;
    this._step = step;
    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
    if (this.size === 0) {
      if (EMPTY_RANGE) {
        return EMPTY_RANGE;
      }
      EMPTY_RANGE = this;
    }
  }
  if (IndexedSeq2) Range2.__proto__ = IndexedSeq2;
  Range2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  Range2.prototype.constructor = Range2;
  Range2.prototype.toString = function toString5() {
    if (this.size === 0) {
      return "Range []";
    }
    return "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
  };
  Range2.prototype.get = function get11(index, notSetValue) {
    return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
  };
  Range2.prototype.includes = function includes3(searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
  };
  Range2.prototype.slice = function slice4(begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    begin = resolveBegin(begin, this.size);
    end = resolveEnd(end, this.size);
    if (end <= begin) {
      return new Range2(0, 0);
    }
    return new Range2(
      this.get(begin, this._end),
      this.get(end, this._end),
      this._step
    );
  };
  Range2.prototype.indexOf = function indexOf2(searchValue) {
    var offsetValue = searchValue - this._start;
    if (offsetValue % this._step === 0) {
      var index = offsetValue / this._step;
      if (index >= 0 && index < this.size) {
        return index;
      }
    }
    return -1;
  };
  Range2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
    return this.indexOf(searchValue);
  };
  Range2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var size = this.size;
    var step = this._step;
    var value = reverse3 ? this._start + (size - 1) * step : this._start;
    var i2 = 0;
    while (i2 !== size) {
      if (fn2(value, reverse3 ? size - ++i2 : i2++, this) === false) {
        break;
      }
      value += reverse3 ? -step : step;
    }
    return i2;
  };
  Range2.prototype.__iterator = function __iterator2(type, reverse3) {
    var size = this.size;
    var step = this._step;
    var value = reverse3 ? this._start + (size - 1) * step : this._start;
    var i2 = 0;
    return new Iterator(function() {
      if (i2 === size) {
        return iteratorDone();
      }
      var v2 = value;
      value += reverse3 ? -step : step;
      return iteratorValue(type, reverse3 ? size - ++i2 : i2++, v2);
    });
  };
  Range2.prototype.equals = function equals3(other) {
    return other instanceof Range2 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
  };
  return Range2;
})(IndexedSeq);
var EMPTY_RANGE;
function getIn$1(collection, searchKeyPath, notSetValue) {
  var keyPath = coerceKeyPath(searchKeyPath);
  var i2 = 0;
  while (i2 !== keyPath.length) {
    collection = get(collection, keyPath[i2++], NOT_SET);
    if (collection === NOT_SET) {
      return notSetValue;
    }
  }
  return collection;
}
function getIn(searchKeyPath, notSetValue) {
  return getIn$1(this, searchKeyPath, notSetValue);
}
function hasIn$1(collection, keyPath) {
  return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
}
function hasIn(searchKeyPath) {
  return hasIn$1(this, searchKeyPath);
}
function toObject() {
  assertNotInfinite(this.size);
  var object2 = {};
  this.__iterate(function(v2, k2) {
    object2[k2] = v2;
  });
  return object2;
}
Collection.isIterable = isCollection;
Collection.isKeyed = isKeyed;
Collection.isIndexed = isIndexed;
Collection.isAssociative = isAssociative;
Collection.isOrdered = isOrdered;
Collection.Iterator = Iterator;
mixin(Collection, {
  // ### Conversion to other types
  toArray: function toArray() {
    assertNotInfinite(this.size);
    var array2 = new Array(this.size || 0);
    var useTuples = isKeyed(this);
    var i2 = 0;
    this.__iterate(function(v2, k2) {
      array2[i2++] = useTuples ? [k2, v2] : v2;
    });
    return array2;
  },
  toIndexedSeq: function toIndexedSeq() {
    return new ToIndexedSequence(this);
  },
  toJS: function toJS$1() {
    return toJS(this);
  },
  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, true);
  },
  toMap: function toMap() {
    return Map$1(this.toKeyedSeq());
  },
  toObject,
  toOrderedMap: function toOrderedMap() {
    return OrderedMap(this.toKeyedSeq());
  },
  toOrderedSet: function toOrderedSet() {
    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
  },
  toSet: function toSet() {
    return Set$1(isKeyed(this) ? this.valueSeq() : this);
  },
  toSetSeq: function toSetSeq() {
    return new ToSetSequence(this);
  },
  toSeq: function toSeq() {
    return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
  },
  toStack: function toStack() {
    return Stack(isKeyed(this) ? this.valueSeq() : this);
  },
  toList: function toList() {
    return List(isKeyed(this) ? this.valueSeq() : this);
  },
  // ### Common JavaScript methods and properties
  toString: function toString3() {
    return "[Collection]";
  },
  __toString: function __toString(head, tail) {
    if (this.size === 0) {
      return head + tail;
    }
    return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
  },
  // ### ES6 Collection methods (ES6 Array and Map)
  concat: function concat() {
    var values2 = [], len = arguments.length;
    while (len--) values2[len] = arguments[len];
    return reify(this, concatFactory(this, values2));
  },
  includes: function includes(searchValue) {
    return this.some(function(value) {
      return is(value, searchValue);
    });
  },
  entries: function entries() {
    return this.__iterator(ITERATE_ENTRIES);
  },
  every: function every(predicate, context2) {
    assertNotInfinite(this.size);
    var returnValue = true;
    this.__iterate(function(v2, k2, c2) {
      if (!predicate.call(context2, v2, k2, c2)) {
        returnValue = false;
        return false;
      }
    });
    return returnValue;
  },
  filter: function filter(predicate, context2) {
    return reify(this, filterFactory(this, predicate, context2, true));
  },
  partition: function partition(predicate, context2) {
    return partitionFactory(this, predicate, context2);
  },
  find: function find(predicate, context2, notSetValue) {
    var entry = this.findEntry(predicate, context2);
    return entry ? entry[1] : notSetValue;
  },
  forEach: function forEach(sideEffect, context2) {
    assertNotInfinite(this.size);
    return this.__iterate(context2 ? sideEffect.bind(context2) : sideEffect);
  },
  join: function join(separator) {
    assertNotInfinite(this.size);
    separator = separator !== void 0 ? "" + separator : ",";
    var joined = "";
    var isFirst = true;
    this.__iterate(function(v2) {
      isFirst ? isFirst = false : joined += separator;
      joined += v2 !== null && v2 !== void 0 ? v2.toString() : "";
    });
    return joined;
  },
  keys: function keys() {
    return this.__iterator(ITERATE_KEYS);
  },
  map: function map2(mapper, context2) {
    return reify(this, mapFactory(this, mapper, context2));
  },
  reduce: function reduce$1(reducer2, initialReduction, context2) {
    return reduce(
      this,
      reducer2,
      initialReduction,
      context2,
      arguments.length < 2,
      false
    );
  },
  reduceRight: function reduceRight(reducer2, initialReduction, context2) {
    return reduce(
      this,
      reducer2,
      initialReduction,
      context2,
      arguments.length < 2,
      true
    );
  },
  reverse: function reverse() {
    return reify(this, reverseFactory(this, true));
  },
  slice: function slice(begin, end) {
    return reify(this, sliceFactory(this, begin, end, true));
  },
  some: function some(predicate, context2) {
    assertNotInfinite(this.size);
    var returnValue = false;
    this.__iterate(function(v2, k2, c2) {
      if (predicate.call(context2, v2, k2, c2)) {
        returnValue = true;
        return false;
      }
    });
    return returnValue;
  },
  sort: function sort(comparator) {
    return reify(this, sortFactory(this, comparator));
  },
  values: function values() {
    return this.__iterator(ITERATE_VALUES);
  },
  // ### More sequential methods
  butLast: function butLast() {
    return this.slice(0, -1);
  },
  isEmpty: function isEmpty() {
    return this.size !== void 0 ? this.size === 0 : !this.some(function() {
      return true;
    });
  },
  count: function count(predicate, context2) {
    return ensureSize(
      predicate ? this.toSeq().filter(predicate, context2) : this
    );
  },
  countBy: function countBy(grouper, context2) {
    return countByFactory(this, grouper, context2);
  },
  equals: function equals(other) {
    return deepEqual(this, other);
  },
  entrySeq: function entrySeq() {
    var collection = this;
    if (collection._cache) {
      return new ArraySeq(collection._cache);
    }
    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
    entriesSequence.fromEntrySeq = function() {
      return collection.toSeq();
    };
    return entriesSequence;
  },
  filterNot: function filterNot(predicate, context2) {
    return this.filter(not(predicate), context2);
  },
  findEntry: function findEntry(predicate, context2, notSetValue) {
    var found = notSetValue;
    this.__iterate(function(v2, k2, c2) {
      if (predicate.call(context2, v2, k2, c2)) {
        found = [k2, v2];
        return false;
      }
    });
    return found;
  },
  findKey: function findKey(predicate, context2) {
    var entry = this.findEntry(predicate, context2);
    return entry && entry[0];
  },
  findLast: function findLast(predicate, context2, notSetValue) {
    return this.toKeyedSeq().reverse().find(predicate, context2, notSetValue);
  },
  findLastEntry: function findLastEntry(predicate, context2, notSetValue) {
    return this.toKeyedSeq().reverse().findEntry(predicate, context2, notSetValue);
  },
  findLastKey: function findLastKey(predicate, context2) {
    return this.toKeyedSeq().reverse().findKey(predicate, context2);
  },
  first: function first(notSetValue) {
    return this.find(returnTrue, null, notSetValue);
  },
  flatMap: function flatMap(mapper, context2) {
    return reify(this, flatMapFactory(this, mapper, context2));
  },
  flatten: function flatten2(depth) {
    return reify(this, flattenFactory(this, depth, true));
  },
  fromEntrySeq: function fromEntrySeq() {
    return new FromEntriesSequence(this);
  },
  get: function get7(searchKey, notSetValue) {
    return this.find(function(_23, key) {
      return is(key, searchKey);
    }, void 0, notSetValue);
  },
  getIn,
  groupBy: function groupBy(grouper, context2) {
    return groupByFactory(this, grouper, context2);
  },
  has: function has2(searchKey) {
    return this.get(searchKey, NOT_SET) !== NOT_SET;
  },
  hasIn,
  isSubset: function isSubset(iter) {
    iter = typeof iter.includes === "function" ? iter : Collection(iter);
    return this.every(function(value) {
      return iter.includes(value);
    });
  },
  isSuperset: function isSuperset(iter) {
    iter = typeof iter.isSubset === "function" ? iter : Collection(iter);
    return iter.isSubset(this);
  },
  keyOf: function keyOf(searchValue) {
    return this.findKey(function(value) {
      return is(value, searchValue);
    });
  },
  keySeq: function keySeq() {
    return this.toSeq().map(keyMapper).toIndexedSeq();
  },
  last: function last(notSetValue) {
    return this.toSeq().reverse().first(notSetValue);
  },
  lastKeyOf: function lastKeyOf(searchValue) {
    return this.toKeyedSeq().reverse().keyOf(searchValue);
  },
  max: function max(comparator) {
    return maxFactory(this, comparator);
  },
  maxBy: function maxBy(mapper, comparator) {
    return maxFactory(this, comparator, mapper);
  },
  min: function min(comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator
    );
  },
  minBy: function minBy(mapper, comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator,
      mapper
    );
  },
  rest: function rest() {
    return this.slice(1);
  },
  skip: function skip(amount) {
    return amount === 0 ? this : this.slice(Math.max(0, amount));
  },
  skipLast: function skipLast(amount) {
    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
  },
  skipWhile: function skipWhile(predicate, context2) {
    return reify(this, skipWhileFactory(this, predicate, context2, true));
  },
  skipUntil: function skipUntil(predicate, context2) {
    return this.skipWhile(not(predicate), context2);
  },
  sortBy: function sortBy(mapper, comparator) {
    return reify(this, sortFactory(this, comparator, mapper));
  },
  take: function take(amount) {
    return this.slice(0, Math.max(0, amount));
  },
  takeLast: function takeLast(amount) {
    return this.slice(-Math.max(0, amount));
  },
  takeWhile: function takeWhile(predicate, context2) {
    return reify(this, takeWhileFactory(this, predicate, context2));
  },
  takeUntil: function takeUntil(predicate, context2) {
    return this.takeWhile(not(predicate), context2);
  },
  update: function update6(fn2) {
    return fn2(this);
  },
  valueSeq: function valueSeq() {
    return this.toIndexedSeq();
  },
  // ### Hashable Object
  hashCode: function hashCode() {
    return this.__hash || (this.__hash = hashCollection(this));
  }
  // ### Internal
  // abstract __iterate(fn, reverse)
  // abstract __iterator(type, reverse)
});
var CollectionPrototype = Collection.prototype;
CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
CollectionPrototype.toJSON = CollectionPrototype.toArray;
CollectionPrototype.__toStringMapper = quoteString;
CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
  return this.toString();
};
CollectionPrototype.chain = CollectionPrototype.flatMap;
CollectionPrototype.contains = CollectionPrototype.includes;
mixin(KeyedCollection, {
  // ### More sequential methods
  flip: function flip() {
    return reify(this, flipFactory(this));
  },
  mapEntries: function mapEntries(mapper, context2) {
    var this$1$1 = this;
    var iterations = 0;
    return reify(
      this,
      this.toSeq().map(function(v2, k2) {
        return mapper.call(context2, [k2, v2], iterations++, this$1$1);
      }).fromEntrySeq()
    );
  },
  mapKeys: function mapKeys(mapper, context2) {
    var this$1$1 = this;
    return reify(
      this,
      this.toSeq().flip().map(function(k2, v2) {
        return mapper.call(context2, k2, v2, this$1$1);
      }).flip()
    );
  }
});
var KeyedCollectionPrototype = KeyedCollection.prototype;
KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
KeyedCollectionPrototype.toJSON = toObject;
KeyedCollectionPrototype.__toStringMapper = function(v2, k2) {
  return quoteString(k2) + ": " + quoteString(v2);
};
mixin(IndexedCollection, {
  // ### Conversion to other types
  toKeyedSeq: function toKeyedSeq2() {
    return new ToKeyedSequence(this, false);
  },
  // ### ES6 Collection methods (ES6 Array and Map)
  filter: function filter2(predicate, context2) {
    return reify(this, filterFactory(this, predicate, context2, false));
  },
  findIndex: function findIndex(predicate, context2) {
    var entry = this.findEntry(predicate, context2);
    return entry ? entry[0] : -1;
  },
  indexOf: function indexOf(searchValue) {
    var key = this.keyOf(searchValue);
    return key === void 0 ? -1 : key;
  },
  lastIndexOf: function lastIndexOf(searchValue) {
    var key = this.lastKeyOf(searchValue);
    return key === void 0 ? -1 : key;
  },
  reverse: function reverse2() {
    return reify(this, reverseFactory(this, false));
  },
  slice: function slice2(begin, end) {
    return reify(this, sliceFactory(this, begin, end, false));
  },
  splice: function splice(index, removeNum) {
    var numArgs = arguments.length;
    removeNum = Math.max(removeNum || 0, 0);
    if (numArgs === 0 || numArgs === 2 && !removeNum) {
      return this;
    }
    index = resolveBegin(index, index < 0 ? this.count() : this.size);
    var spliced = this.slice(0, index);
    return reify(
      this,
      numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
    );
  },
  // ### More collection methods
  findLastIndex: function findLastIndex(predicate, context2) {
    var entry = this.findLastEntry(predicate, context2);
    return entry ? entry[0] : -1;
  },
  first: function first2(notSetValue) {
    return this.get(0, notSetValue);
  },
  flatten: function flatten3(depth) {
    return reify(this, flattenFactory(this, depth, false));
  },
  get: function get8(index, notSetValue) {
    index = wrapIndex(this, index);
    return index < 0 || this.size === Infinity || this.size !== void 0 && index > this.size ? notSetValue : this.find(function(_23, key) {
      return key === index;
    }, void 0, notSetValue);
  },
  has: function has3(index) {
    index = wrapIndex(this, index);
    return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
  },
  interpose: function interpose(separator) {
    return reify(this, interposeFactory(this, separator));
  },
  interleave: function interleave() {
    var collections = [this].concat(arrCopy(arguments));
    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
    var interleaved = zipped.flatten(true);
    if (zipped.size) {
      interleaved.size = zipped.size * collections.length;
    }
    return reify(this, interleaved);
  },
  keySeq: function keySeq2() {
    return Range(0, this.size);
  },
  last: function last2(notSetValue) {
    return this.get(-1, notSetValue);
  },
  skipWhile: function skipWhile2(predicate, context2) {
    return reify(this, skipWhileFactory(this, predicate, context2, false));
  },
  zip: function zip() {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections));
  },
  zipAll: function zipAll() {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections, true));
  },
  zipWith: function zipWith(zipper) {
    var collections = arrCopy(arguments);
    collections[0] = this;
    return reify(this, zipWithFactory(this, zipper, collections));
  }
});
var IndexedCollectionPrototype = IndexedCollection.prototype;
IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
mixin(SetCollection, {
  // ### ES6 Collection methods (ES6 Array and Map)
  get: function get9(value, notSetValue) {
    return this.has(value) ? value : notSetValue;
  },
  includes: function includes2(value) {
    return this.has(value);
  },
  // ### More sequential methods
  keySeq: function keySeq3() {
    return this.valueSeq();
  }
});
var SetCollectionPrototype = SetCollection.prototype;
SetCollectionPrototype.has = CollectionPrototype.includes;
SetCollectionPrototype.contains = SetCollectionPrototype.includes;
SetCollectionPrototype.keys = SetCollectionPrototype.values;
mixin(KeyedSeq, KeyedCollectionPrototype);
mixin(IndexedSeq, IndexedCollectionPrototype);
mixin(SetSeq, SetCollectionPrototype);
function reduce(collection, reducer2, reduction, context2, useFirst, reverse3) {
  assertNotInfinite(collection.size);
  collection.__iterate(function(v2, k2, c2) {
    if (useFirst) {
      useFirst = false;
      reduction = v2;
    } else {
      reduction = reducer2.call(context2, reduction, v2, k2, c2);
    }
  }, reverse3);
  return reduction;
}
function keyMapper(v2, k2) {
  return k2;
}
function entryMapper(v2, k2) {
  return [k2, v2];
}
function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
function neg(predicate) {
  return function() {
    return -predicate.apply(this, arguments);
  };
}
function defaultZipper() {
  return arrCopy(arguments);
}
function defaultNegComparator(a2, b2) {
  return a2 < b2 ? 1 : a2 > b2 ? -1 : 0;
}
function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }
  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h2 = ordered ? 1 : 0;
  var size = collection.__iterate(
    keyed ? ordered ? function(v2, k2) {
      h2 = 31 * h2 + hashMerge(hash(v2), hash(k2)) | 0;
    } : function(v2, k2) {
      h2 = h2 + hashMerge(hash(v2), hash(k2)) | 0;
    } : ordered ? function(v2) {
      h2 = 31 * h2 + hash(v2) | 0;
    } : function(v2) {
      h2 = h2 + hash(v2) | 0;
    }
  );
  return murmurHashOfSize(size, h2);
}
function murmurHashOfSize(size, h2) {
  h2 = imul(h2, 3432918353);
  h2 = imul(h2 << 15 | h2 >>> -15, 461845907);
  h2 = imul(h2 << 13 | h2 >>> -13, 5);
  h2 = (h2 + 3864292196 | 0) ^ size;
  h2 = imul(h2 ^ h2 >>> 16, 2246822507);
  h2 = imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = smi(h2 ^ h2 >>> 16);
  return h2;
}
function hashMerge(a2, b2) {
  return a2 ^ b2 + 2654435769 + (a2 << 6) + (a2 >> 2) | 0;
}
var OrderedSet = /* @__PURE__ */ (function(Set2) {
  function OrderedSet2(value) {
    return value === void 0 || value === null ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set3) {
      var iter = SetCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v2) {
        return set3.add(v2);
      });
    });
  }
  if (Set2) OrderedSet2.__proto__ = Set2;
  OrderedSet2.prototype = Object.create(Set2 && Set2.prototype);
  OrderedSet2.prototype.constructor = OrderedSet2;
  OrderedSet2.of = function of() {
    return this(arguments);
  };
  OrderedSet2.fromKeys = function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  };
  OrderedSet2.prototype.toString = function toString5() {
    return this.__toString("OrderedSet {", "}");
  };
  return OrderedSet2;
})(Set$1);
OrderedSet.isOrderedSet = isOrderedSet;
var OrderedSetPrototype = OrderedSet.prototype;
OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
OrderedSetPrototype.__empty = emptyOrderedSet;
OrderedSetPrototype.__make = makeOrderedSet;
function makeOrderedSet(map3, ownerID) {
  var set3 = Object.create(OrderedSetPrototype);
  set3.size = map3 ? map3.size : 0;
  set3._map = map3;
  set3.__ownerID = ownerID;
  return set3;
}
var EMPTY_ORDERED_SET;
function emptyOrderedSet() {
  return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}
var PairSorting = {
  LeftThenRight: -1,
  RightThenLeft: 1
};
function throwOnInvalidDefaultValues(defaultValues) {
  if (isRecord(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead."
    );
  }
  if (isImmutable(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead."
    );
  }
  if (defaultValues === null || typeof defaultValues !== "object") {
    throw new Error(
      "Can not call `Record` with a non-object as default values. Use a plain javascript object instead."
    );
  }
}
var Record = function Record2(defaultValues, name) {
  var hasInitialized;
  throwOnInvalidDefaultValues(defaultValues);
  var RecordType = function Record3(values2) {
    var this$1$1 = this;
    if (values2 instanceof RecordType) {
      return values2;
    }
    if (!(this instanceof RecordType)) {
      return new RecordType(values2);
    }
    if (!hasInitialized) {
      hasInitialized = true;
      var keys2 = Object.keys(defaultValues);
      var indices = RecordTypePrototype._indices = {};
      RecordTypePrototype._name = name;
      RecordTypePrototype._keys = keys2;
      RecordTypePrototype._defaultValues = defaultValues;
      for (var i2 = 0; i2 < keys2.length; i2++) {
        var propName = keys2[i2];
        indices[propName] = i2;
        if (RecordTypePrototype[propName]) {
          typeof console === "object" && console.warn && console.warn(
            "Cannot define " + recordName(this) + ' with property "' + propName + '" since that property name is part of the Record API.'
          );
        } else {
          setProp(RecordTypePrototype, propName);
        }
      }
    }
    this.__ownerID = void 0;
    this._values = List().withMutations(function(l2) {
      l2.setSize(this$1$1._keys.length);
      KeyedCollection(values2).forEach(function(v2, k2) {
        l2.set(this$1$1._indices[k2], v2 === this$1$1._defaultValues[k2] ? void 0 : v2);
      });
    });
    return this;
  };
  var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
  RecordTypePrototype.constructor = RecordType;
  if (name) {
    RecordType.displayName = name;
  }
  return RecordType;
};
Record.prototype.toString = function toString4() {
  var str = recordName(this) + " { ";
  var keys2 = this._keys;
  var k2;
  for (var i2 = 0, l2 = keys2.length; i2 !== l2; i2++) {
    k2 = keys2[i2];
    str += (i2 ? ", " : "") + k2 + ": " + quoteString(this.get(k2));
  }
  return str + " }";
};
Record.prototype.equals = function equals2(other) {
  return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));
};
Record.prototype.hashCode = function hashCode2() {
  return recordSeq(this).hashCode();
};
Record.prototype.has = function has4(k2) {
  return this._indices.hasOwnProperty(k2);
};
Record.prototype.get = function get10(k2, notSetValue) {
  if (!this.has(k2)) {
    return notSetValue;
  }
  var index = this._indices[k2];
  var value = this._values.get(index);
  return value === void 0 ? this._defaultValues[k2] : value;
};
Record.prototype.set = function set2(k2, v2) {
  if (this.has(k2)) {
    var newValues = this._values.set(
      this._indices[k2],
      v2 === this._defaultValues[k2] ? void 0 : v2
    );
    if (newValues !== this._values && !this.__ownerID) {
      return makeRecord(this, newValues);
    }
  }
  return this;
};
Record.prototype.remove = function remove3(k2) {
  return this.set(k2);
};
Record.prototype.clear = function clear() {
  var newValues = this._values.clear().setSize(this._keys.length);
  return this.__ownerID ? this : makeRecord(this, newValues);
};
Record.prototype.wasAltered = function wasAltered2() {
  return this._values.wasAltered();
};
Record.prototype.toSeq = function toSeq2() {
  return recordSeq(this);
};
Record.prototype.toJS = function toJS$12() {
  return toJS(this);
};
Record.prototype.entries = function entries2() {
  return this.__iterator(ITERATE_ENTRIES);
};
Record.prototype.__iterator = function __iterator(type, reverse3) {
  return recordSeq(this).__iterator(type, reverse3);
};
Record.prototype.__iterate = function __iterate(fn2, reverse3) {
  return recordSeq(this).__iterate(fn2, reverse3);
};
Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  var newValues = this._values.__ensureOwner(ownerID);
  if (!ownerID) {
    this.__ownerID = ownerID;
    this._values = newValues;
    return this;
  }
  return makeRecord(this, newValues, ownerID);
};
Record.isRecord = isRecord;
Record.getDescriptiveName = recordName;
var RecordPrototype = Record.prototype;
RecordPrototype[IS_RECORD_SYMBOL] = true;
RecordPrototype[DELETE] = RecordPrototype.remove;
RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
RecordPrototype.getIn = getIn;
RecordPrototype.hasIn = CollectionPrototype.hasIn;
RecordPrototype.merge = merge$1;
RecordPrototype.mergeWith = mergeWith$1;
RecordPrototype.mergeIn = mergeIn;
RecordPrototype.mergeDeep = mergeDeep;
RecordPrototype.mergeDeepWith = mergeDeepWith;
RecordPrototype.mergeDeepIn = mergeDeepIn;
RecordPrototype.setIn = setIn;
RecordPrototype.update = update$2;
RecordPrototype.updateIn = updateIn;
RecordPrototype.withMutations = withMutations;
RecordPrototype.asMutable = asMutable;
RecordPrototype.asImmutable = asImmutable;
RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
RecordPrototype.inspect = RecordPrototype.toSource = function() {
  return this.toString();
};
function makeRecord(likeRecord, values2, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._values = values2;
  record.__ownerID = ownerID;
  return record;
}
function recordName(record) {
  return record.constructor.displayName || record.constructor.name || "Record";
}
function recordSeq(record) {
  return keyedSeqFromValue(record._keys.map(function(k2) {
    return [k2, record.get(k2)];
  }));
}
function setProp(prototype, name) {
  try {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant$1(this.__ownerID, "Cannot set on an immutable record.");
        this.set(name, value);
      }
    });
  } catch (error2) {
  }
}
var Repeat = /* @__PURE__ */ (function(IndexedSeq2) {
  function Repeat2(value, times) {
    if (!(this instanceof Repeat2)) {
      return new Repeat2(value, times);
    }
    this._value = value;
    this.size = times === void 0 ? Infinity : Math.max(0, times);
    if (this.size === 0) {
      if (EMPTY_REPEAT) {
        return EMPTY_REPEAT;
      }
      EMPTY_REPEAT = this;
    }
  }
  if (IndexedSeq2) Repeat2.__proto__ = IndexedSeq2;
  Repeat2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  Repeat2.prototype.constructor = Repeat2;
  Repeat2.prototype.toString = function toString5() {
    if (this.size === 0) {
      return "Repeat []";
    }
    return "Repeat [ " + this._value + " " + this.size + " times ]";
  };
  Repeat2.prototype.get = function get11(index, notSetValue) {
    return this.has(index) ? this._value : notSetValue;
  };
  Repeat2.prototype.includes = function includes3(searchValue) {
    return is(this._value, searchValue);
  };
  Repeat2.prototype.slice = function slice4(begin, end) {
    var size = this.size;
    return wholeSlice(begin, end, size) ? this : new Repeat2(
      this._value,
      resolveEnd(end, size) - resolveBegin(begin, size)
    );
  };
  Repeat2.prototype.reverse = function reverse3() {
    return this;
  };
  Repeat2.prototype.indexOf = function indexOf2(searchValue) {
    if (is(this._value, searchValue)) {
      return 0;
    }
    return -1;
  };
  Repeat2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
    if (is(this._value, searchValue)) {
      return this.size;
    }
    return -1;
  };
  Repeat2.prototype.__iterate = function __iterate2(fn2, reverse3) {
    var size = this.size;
    var i2 = 0;
    while (i2 !== size) {
      if (fn2(this._value, reverse3 ? size - ++i2 : i2++, this) === false) {
        break;
      }
    }
    return i2;
  };
  Repeat2.prototype.__iterator = function __iterator2(type, reverse3) {
    var this$1$1 = this;
    var size = this.size;
    var i2 = 0;
    return new Iterator(
      function() {
        return i2 === size ? iteratorDone() : iteratorValue(type, reverse3 ? size - ++i2 : i2++, this$1$1._value);
      }
    );
  };
  Repeat2.prototype.equals = function equals3(other) {
    return other instanceof Repeat2 ? is(this._value, other._value) : deepEqual(this, other);
  };
  return Repeat2;
})(IndexedSeq);
var EMPTY_REPEAT;
function fromJS(value, converter) {
  return fromJSWith(
    [],
    converter || defaultConverter,
    value,
    "",
    converter && converter.length > 2 ? [] : void 0,
    { "": value }
  );
}
function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
  if (typeof value !== "string" && !isImmutable(value) && (isArrayLike(value) || hasIterator(value) || isPlainObject$1(value))) {
    if (~stack.indexOf(value)) {
      throw new TypeError("Cannot convert circular structure to Immutable");
    }
    stack.push(value);
    keyPath && key !== "" && keyPath.push(key);
    var converted = converter.call(
      parentValue,
      key,
      Seq(value).map(
        function(v2, k2) {
          return fromJSWith(stack, converter, v2, k2, keyPath, value);
        }
      ),
      keyPath && keyPath.slice()
    );
    stack.pop();
    keyPath && keyPath.pop();
    return converted;
  }
  return value;
}
function defaultConverter(k2, v2) {
  return isIndexed(v2) ? v2.toList() : isKeyed(v2) ? v2.toMap() : v2.toSet();
}
var version = "4.3.7";
var Immutable = {
  version,
  Collection,
  // Note: Iterable is deprecated
  Iterable: Collection,
  Seq,
  Map: Map$1,
  OrderedMap,
  List,
  Stack,
  Set: Set$1,
  OrderedSet,
  PairSorting,
  Record,
  Range,
  Repeat,
  is,
  fromJS,
  hash,
  isImmutable,
  isCollection,
  isKeyed,
  isIndexed,
  isAssociative,
  isOrdered,
  isValueObject,
  isPlainObject: isPlainObject$1,
  isSeq,
  isList,
  isMap,
  isOrderedMap,
  isStack,
  isSet,
  isOrderedSet,
  isRecord,
  get,
  getIn: getIn$1,
  has,
  hasIn: hasIn$1,
  merge,
  mergeDeep: mergeDeep$1,
  mergeWith,
  mergeDeepWith: mergeDeepWith$1,
  remove: remove2,
  removeIn,
  set,
  setIn: setIn$1,
  update: update$1,
  updateIn: updateIn$1
};
var Iterable = Collection;
const immutable_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Collection,
  Iterable,
  List,
  Map: Map$1,
  OrderedMap,
  OrderedSet,
  PairSorting,
  Range,
  Record,
  Repeat,
  Seq,
  Set: Set$1,
  Stack,
  default: Immutable,
  fromJS,
  get,
  getIn: getIn$1,
  has,
  hasIn: hasIn$1,
  hash,
  is,
  isAssociative,
  isCollection,
  isImmutable,
  isIndexed,
  isKeyed,
  isList,
  isMap,
  isOrdered,
  isOrderedMap,
  isOrderedSet,
  isPlainObject: isPlainObject$1,
  isRecord,
  isSeq,
  isSet,
  isStack,
  isValueObject,
  merge,
  mergeDeep: mergeDeep$1,
  mergeDeepWith: mergeDeepWith$1,
  mergeWith,
  remove: remove2,
  removeIn,
  set,
  setIn: setIn$1,
  update: update$1,
  updateIn: updateIn$1,
  version
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(immutable_es);
var hasRequiredReactDraftWysiwyg;
function requireReactDraftWysiwyg() {
  if (hasRequiredReactDraftWysiwyg) return reactDraftWysiwyg.exports;
  hasRequiredReactDraftWysiwyg = 1;
  (function(module, exports) {
    !(function(t2, e2) {
      module.exports = e2(requireReact(), requireDraft(), require$$2);
    })(window, function(n2, o2, r2) {
      return a2 = {}, i2.m = c2 = [function(t2, e2, n3) {
        t2.exports = n3(10)();
      }, function(t2, e2) {
        t2.exports = n2;
      }, function(t2, e2, n3) {
        var o3;
        /*!
          Copyright (c) 2017 Jed Watson.
          Licensed under the MIT License (MIT), see
          http://jedwatson.github.io/classnames
        */
        !(function() {
          var c3 = {}.hasOwnProperty;
          function a3() {
            for (var t3 = [], e3 = 0; e3 < arguments.length; e3++) {
              var n4 = arguments[e3];
              if (n4) {
                var o4 = typeof n4;
                if ("string" == o4 || "number" == o4) t3.push(n4);
                else if (Array.isArray(n4) && n4.length) {
                  var r3 = a3.apply(null, n4);
                  r3 && t3.push(r3);
                } else if ("object" == o4) for (var i3 in n4) c3.call(n4, i3) && n4[i3] && t3.push(i3);
              }
            }
            return t3.join(" ");
          }
          t2.exports ? (a3.default = a3, t2.exports = a3) : void 0 === (o3 = (function() {
            return a3;
          }).apply(e2, [])) || (t2.exports = o3);
        })();
      }, function(t2, e2) {
        t2.exports = o2;
      }, function(t2, e2, n3) {
        function r3(t3) {
          if (a3[t3]) return a3[t3].exports;
          var e3 = a3[t3] = { i: t3, l: false, exports: {} };
          return c3[t3].call(e3.exports, e3, e3.exports, r3), e3.l = true, e3.exports;
        }
        var o3, i3, c3, a3;
        t2.exports = (o3 = n3(3), i3 = n3(5), a3 = {}, r3.m = c3 = [function(t3, e3) {
          t3.exports = o3;
        }, function(t3, e3) {
          t3.exports = i3;
        }, function(t3, e3, n4) {
          t3.exports = n4(3);
        }, function(t3, e3, n4) {
          n4.r(e3);
          var M2 = n4(0), i4 = n4(1);
          function j2(t4) {
            var e4 = t4.getSelection(), n5 = t4.getCurrentContent(), o5 = e4.getStartKey(), r5 = e4.getEndKey(), i5 = n5.getBlockMap();
            return i5.toSeq().skipUntil(function(t5, e5) {
              return e5 === o5;
            }).takeUntil(function(t5, e5) {
              return e5 === r5;
            }).concat([[r5, i5.get(r5)]]);
          }
          function u2(t4) {
            return j2(t4).toList();
          }
          function l2(t4) {
            if (t4) return u2(t4).get(0);
          }
          function o4(t4) {
            if (t4) {
              var n5 = l2(t4), e4 = t4.getCurrentContent().getBlockMap().toSeq().toList(), o5 = 0;
              if (e4.forEach(function(t5, e5) {
                t5.get("key") === n5.get("key") && (o5 = e5 - 1);
              }), -1 < o5) return e4.get(o5);
            }
          }
          function r4(t4) {
            return t4 ? t4.getCurrentContent().getBlockMap().toList() : new i4.List();
          }
          function c4(t4) {
            var e4 = u2(t4);
            if (!e4.some(function(t5) {
              return t5.type !== e4.get(0).type;
            })) return e4.get(0).type;
          }
          function a4(t4) {
            var e4 = M2.RichUtils.tryToRemoveBlockStyle(t4);
            return e4 ? M2.EditorState.push(t4, e4, "change-block-type") : t4;
          }
          function s2(t4) {
            var e4 = "", n5 = t4.getSelection(), o5 = n5.getAnchorOffset(), r5 = n5.getFocusOffset(), i5 = u2(t4);
            if (0 < i5.size) {
              if (n5.getIsBackward()) {
                var c5 = o5;
                o5 = r5, r5 = c5;
              }
              for (var a5 = 0; a5 < i5.size; a5 += 1) {
                var l3 = 0 === a5 ? o5 : 0, s3 = a5 === i5.size - 1 ? r5 : i5.get(a5).getText().length;
                e4 += i5.get(a5).getText().slice(l3, s3);
              }
            }
            return e4;
          }
          function p2(t4) {
            var e4 = t4.getCurrentContent(), n5 = t4.getSelection(), o5 = M2.Modifier.removeRange(e4, n5, "forward"), r5 = o5.getSelectionAfter(), i5 = o5.getBlockForKey(r5.getStartKey());
            return o5 = M2.Modifier.insertText(o5, r5, "\n", i5.getInlineStyleAt(r5.getStartOffset()), null), M2.EditorState.push(t4, o5, "insert-fragment");
          }
          function d2(t4) {
            var e4 = M2.Modifier.splitBlock(t4.getCurrentContent(), t4.getSelection());
            return a4(M2.EditorState.push(t4, e4, "split-block"));
          }
          function f2(t4) {
            var e4 = t4.getCurrentContent().getBlockMap().toList(), n5 = t4.getSelection().merge({ anchorKey: e4.first().get("key"), anchorOffset: 0, focusKey: e4.last().get("key"), focusOffset: e4.last().getLength() }), o5 = M2.Modifier.removeRange(t4.getCurrentContent(), n5, "forward");
            return M2.EditorState.push(t4, o5, "remove-range");
          }
          function y2(t4, e4) {
            var n5 = M2.Modifier.setBlockData(t4.getCurrentContent(), t4.getSelection(), e4);
            return M2.EditorState.push(t4, n5, "change-block-data");
          }
          function m2(t4) {
            var o5 = new i4.Map({}), e4 = u2(t4);
            if (e4 && 0 < e4.size) for (var n5 = function(t5) {
              var n6 = e4.get(t5).getData();
              if (!n6 || 0 === n6.size) return o5 = o5.clear(), "break";
              if (0 === t5) o5 = n6;
              else if (o5.forEach(function(t6, e5) {
                n6.get(e5) && n6.get(e5) === t6 || (o5 = o5.delete(e5));
              }), 0 === o5.size) return o5 = o5.clear(), "break";
            }, r5 = 0; r5 < e4.size && "break" !== n5(r5); r5 += 1) ;
            return o5;
          }
          var g2 = Object(i4.Map)({ code: { element: "pre" } }), b2 = M2.DefaultDraftBlockRenderMap.merge(g2);
          function h2(t4) {
            if (t4) {
              var e4 = t4.getType();
              return "unordered-list-item" === e4 || "ordered-list-item" === e4;
            }
            return false;
          }
          function v2(t4, e4, n5) {
            var o5, r5 = t4.getSelection();
            o5 = r5.getIsBackward() ? r5.getFocusKey() : r5.getAnchorKey();
            var i5 = t4.getCurrentContent(), c5 = i5.getBlockForKey(o5), a5 = c5.getType();
            if ("unordered-list-item" !== a5 && "ordered-list-item" !== a5) return t4;
            var l3 = i5.getBlockBefore(o5);
            if (!l3) return t4;
            if (l3.getType() !== a5) return t4;
            var s3 = c5.getDepth();
            if (1 === e4 && s3 === n5) return t4;
            var u3, p3, d3, f3, y3, m3, g3, b3 = Math.min(l3.getDepth() + 1, n5), h3 = (p3 = e4, d3 = b3, f3 = (u3 = t4).getSelection(), y3 = u3.getCurrentContent(), m3 = y3.getBlockMap(), g3 = j2(u3).map(function(t5) {
              var e5 = t5.getDepth() + p3;
              return e5 = Math.max(0, Math.min(e5, d3)), t5.set("depth", e5);
            }), m3 = m3.merge(g3), y3.merge({ blockMap: m3, selectionBefore: f3, selectionAfter: f3 }));
            return M2.EditorState.push(t4, h3, "adjust-depth");
          }
          function N2(t4, e4) {
            var n5;
            return 13 === (n5 = e4).which && (n5.getModifierState("Shift") || n5.getModifierState("Alt") || n5.getModifierState("Control")) ? t4.getSelection().isCollapsed() ? M2.RichUtils.insertSoftNewline(t4) : p2(t4) : (function(t5) {
              var e5 = t5.getSelection();
              if (e5.isCollapsed()) {
                var n6 = t5.getCurrentContent(), o5 = e5.getStartKey(), r5 = n6.getBlockForKey(o5);
                if (!h2(r5) && "unstyled" !== r5.getType() && r5.getLength() === e5.getStartOffset()) return d2(t5);
                if (h2(r5) && 0 === r5.getLength()) {
                  var i5 = r5.getDepth();
                  if (0 === i5) return a4(t5);
                  if (0 < i5) return v2(t5, -1, i5);
                }
              }
            })(t4);
          }
          function E2(e4, t4) {
            var n5 = Object.keys(e4);
            if (Object.getOwnPropertySymbols) {
              var o5 = Object.getOwnPropertySymbols(e4);
              t4 && (o5 = o5.filter(function(t5) {
                return Object.getOwnPropertyDescriptor(e4, t5).enumerable;
              })), n5.push.apply(n5, o5);
            }
            return n5;
          }
          function S2(t4, e4, n5) {
            return e4 in t4 ? Object.defineProperty(t4, e4, { value: n5, enumerable: true, configurable: true, writable: true }) : t4[e4] = n5, t4;
          }
          function w2(t4) {
            return (w2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            })(t4);
          }
          function C(t4) {
            var e4 = t4.getSelection();
            if (e4.isCollapsed()) {
              var n5 = {}, o5 = t4.getCurrentInlineStyle().toList().toJS();
              if (o5) return ["BOLD", "ITALIC", "UNDERLINE", "STRIKETHROUGH", "CODE", "SUPERSCRIPT", "SUBSCRIPT"].forEach(function(t5) {
                n5[t5] = 0 <= o5.indexOf(t5);
              }), n5;
            }
            var c5 = e4.getStartOffset(), a5 = e4.getEndOffset(), l3 = u2(t4);
            if (0 < l3.size) {
              var r5 = (function() {
                for (var n6 = { BOLD: true, ITALIC: true, UNDERLINE: true, STRIKETHROUGH: true, CODE: true, SUPERSCRIPT: true, SUBSCRIPT: true }, o6 = 0; o6 < l3.size; o6 += 1) {
                  var t5 = 0 === o6 ? c5 : 0, e5 = o6 === l3.size - 1 ? a5 : l3.get(o6).getText().length;
                  t5 === e5 && 0 === t5 ? (t5 = 1, e5 = 2) : t5 === e5 && --t5;
                  for (var r6 = function(t6) {
                    var e6 = l3.get(o6).getInlineStyleAt(t6);
                    ["BOLD", "ITALIC", "UNDERLINE", "STRIKETHROUGH", "CODE", "SUPERSCRIPT", "SUBSCRIPT"].forEach(function(t7) {
                      n6[t7] = n6[t7] && e6.get(t7) === t7;
                    });
                  }, i5 = t5; i5 < e5; i5 += 1) r6(i5);
                }
                return { v: n6 };
              })();
              if ("object" === w2(r5)) return r5.v;
            }
            return {};
          }
          function L(t4) {
            var e4, n5 = t4.getSelection(), o5 = n5.getStartOffset(), r5 = n5.getEndOffset();
            o5 === r5 && 0 === o5 ? r5 = 1 : o5 === r5 && --o5;
            for (var i5 = l2(t4), c5 = o5; c5 < r5; c5 += 1) {
              var a5 = i5.getEntityAt(c5);
              if (!a5) {
                e4 = void 0;
                break;
              }
              if (c5 === o5) e4 = a5;
              else if (e4 !== a5) {
                e4 = void 0;
                break;
              }
            }
            return e4;
          }
          function D2(t4, e4) {
            var n5, o5 = l2(t4);
            return o5.findEntityRanges(function(t5) {
              return t5.get("entity") === e4;
            }, function(t5, e5) {
              n5 = { start: t5, end: e5, text: o5.get("text").slice(t5, e5) };
            }), n5;
          }
          function k2(t4, e4, n5) {
            x2[t4]["".concat(t4.toLowerCase(), "-").concat(n5)] = S2({}, "".concat(e4), n5);
          }
          function O2() {
            return (function(e4) {
              for (var t4 = 1; t4 < arguments.length; t4++) {
                var n5 = null != arguments[t4] ? arguments[t4] : {};
                t4 % 2 ? E2(Object(n5), true).forEach(function(t5) {
                  S2(e4, t5, n5[t5]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n5)) : E2(Object(n5)).forEach(function(t5) {
                  Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(n5, t5));
                });
              }
              return e4;
            })({}, x2.color, {}, x2.bgcolor, {}, x2.fontSize, {}, x2.fontFamily, { CODE: x2.CODE, SUPERSCRIPT: x2.SUPERSCRIPT, SUBSCRIPT: x2.SUBSCRIPT });
          }
          var x2 = { color: {}, bgcolor: {}, fontSize: {}, fontFamily: {}, CODE: { fontFamily: "monospace", wordWrap: "break-word", background: "#f1f1f1", borderRadius: 3, padding: "1px 3px" }, SUPERSCRIPT: { fontSize: 11, position: "relative", top: -8, display: "inline-flex" }, SUBSCRIPT: { fontSize: 11, position: "relative", bottom: -8, display: "inline-flex" } };
          function I(t4, e4, n5) {
            var o5 = t4.getSelection(), r5 = Object.keys(x2[e4]).reduce(function(t5, e5) {
              return M2.Modifier.removeInlineStyle(t5, o5, e5);
            }, t4.getCurrentContent()), i5 = M2.EditorState.push(t4, r5, "changeinline-style"), c5 = t4.getCurrentInlineStyle();
            if (o5.isCollapsed() && (i5 = c5.reduce(function(t5, e5) {
              return M2.RichUtils.toggleInlineStyle(t5, e5);
            }, i5)), "SUPERSCRIPT" === e4 || "SUBSCRIPT" == e4) c5.has(n5) || (i5 = M2.RichUtils.toggleInlineStyle(i5, n5));
            else {
              var a5 = "bgcolor" === e4 ? "backgroundColor" : e4;
              c5.has("".concat(a5, "-").concat(n5)) || (i5 = M2.RichUtils.toggleInlineStyle(i5, "".concat(e4.toLowerCase(), "-").concat(n5)), k2(e4, a5, n5));
            }
            return i5;
          }
          function T(t4) {
            t4 && t4.getCurrentContent().getBlockMap().map(function(t5) {
              return t5.get("characterList");
            }).toList().flatten().forEach(function(t5) {
              t5 && 0 === t5.indexOf("color-") ? k2("color", "color", t5.substr(6)) : t5 && 0 === t5.indexOf("bgcolor-") ? k2("bgcolor", "backgroundColor", t5.substr(8)) : t5 && 0 === t5.indexOf("fontsize-") ? k2("fontSize", "fontSize", +t5.substr(9)) : t5 && 0 === t5.indexOf("fontfamily-") && k2("fontFamily", "fontFamily", t5.substr(11));
            });
          }
          function A2(t4, e4, n5) {
            var o5 = t4.getInlineStyleAt(n5).toList().filter(function(t5) {
              return t5.startsWith(e4.toLowerCase());
            });
            if (o5 && 0 < o5.size) return o5.get(0);
          }
          function z2(o5, s3) {
            if (o5 && s3 && 0 < s3.length) {
              var t4 = (function() {
                var t5 = o5.getSelection(), i5 = {};
                if (t5.isCollapsed()) return s3.forEach(function(t6) {
                  i5[t6] = (function(t7, e5) {
                    var n6 = t7.getCurrentInlineStyle().toList().filter(function(t8) {
                      return t8.startsWith(e5.toLowerCase());
                    });
                    if (n6 && 0 < n6.size) return n6.get(0);
                  })(o5, t6);
                }), { v: i5 };
                var c5 = t5.getStartOffset(), a5 = t5.getEndOffset(), l3 = u2(o5);
                if (0 < l3.size) {
                  for (var e4 = function(n6) {
                    var t6 = 0 === n6 ? c5 : 0, e5 = n6 === l3.size - 1 ? a5 : l3.get(n6).getText().length;
                    t6 === e5 && 0 === t6 ? (t6 = 1, e5 = 2) : t6 === e5 && --t6;
                    for (var o6 = function(e6) {
                      e6 === t6 ? s3.forEach(function(t7) {
                        i5[t7] = A2(l3.get(n6), t7, e6);
                      }) : s3.forEach(function(t7) {
                        i5[t7] && i5[t7] !== A2(l3.get(n6), t7, e6) && (i5[t7] = void 0);
                      });
                    }, r5 = t6; r5 < e5; r5 += 1) o6(r5);
                  }, n5 = 0; n5 < l3.size; n5 += 1) e4(n5);
                  return { v: i5 };
                }
              })();
              if ("object" === w2(t4)) return t4.v;
            }
            return {};
          }
          function _23(e4) {
            var t4 = e4.getCurrentInlineStyle(), n5 = e4.getCurrentContent();
            return t4.forEach(function(t5) {
              n5 = M2.Modifier.removeInlineStyle(n5, e4.getSelection(), t5);
            }), M2.EditorState.push(e4, n5, "change-inline-style");
          }
          n4.d(e3, "isListBlock", function() {
            return h2;
          }), n4.d(e3, "changeDepth", function() {
            return v2;
          }), n4.d(e3, "handleNewLine", function() {
            return N2;
          }), n4.d(e3, "getEntityRange", function() {
            return D2;
          }), n4.d(e3, "getCustomStyleMap", function() {
            return O2;
          }), n4.d(e3, "toggleCustomInlineStyle", function() {
            return I;
          }), n4.d(e3, "getSelectionEntity", function() {
            return L;
          }), n4.d(e3, "extractInlineStyle", function() {
            return T;
          }), n4.d(e3, "removeAllInlineStyles", function() {
            return _23;
          }), n4.d(e3, "getSelectionInlineStyle", function() {
            return C;
          }), n4.d(e3, "getSelectionCustomInlineStyle", function() {
            return z2;
          }), n4.d(e3, "getSelectedBlocksMap", function() {
            return j2;
          }), n4.d(e3, "getSelectedBlocksList", function() {
            return u2;
          }), n4.d(e3, "getSelectedBlock", function() {
            return l2;
          }), n4.d(e3, "getBlockBeforeSelectedBlock", function() {
            return o4;
          }), n4.d(e3, "getAllBlocks", function() {
            return r4;
          }), n4.d(e3, "getSelectedBlocksType", function() {
            return c4;
          }), n4.d(e3, "removeSelectedBlocksStyle", function() {
            return a4;
          }), n4.d(e3, "getSelectionText", function() {
            return s2;
          }), n4.d(e3, "addLineBreakRemovingSelection", function() {
            return p2;
          }), n4.d(e3, "insertNewUnstyledBlock", function() {
            return d2;
          }), n4.d(e3, "clearEditorContent", function() {
            return f2;
          }), n4.d(e3, "setBlockData", function() {
            return y2;
          }), n4.d(e3, "getSelectedBlocksMetadata", function() {
            return m2;
          }), n4.d(e3, "blockRenderMap", function() {
            return b2;
          });
        }], r3.c = a3, r3.d = function(t3, e3, n4) {
          r3.o(t3, e3) || Object.defineProperty(t3, e3, { enumerable: true, get: n4 });
        }, r3.r = function(t3) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
        }, r3.t = function(e3, t3) {
          if (1 & t3 && (e3 = r3(e3)), 8 & t3) return e3;
          if (4 & t3 && "object" == typeof e3 && e3 && e3.__esModule) return e3;
          var n4 = /* @__PURE__ */ Object.create(null);
          if (r3.r(n4), Object.defineProperty(n4, "default", { enumerable: true, value: e3 }), 2 & t3 && "string" != typeof e3) for (var o4 in e3) r3.d(n4, o4, (function(t4) {
            return e3[t4];
          }).bind(null, o4));
          return n4;
        }, r3.n = function(t3) {
          var e3 = t3 && t3.__esModule ? function() {
            return t3.default;
          } : function() {
            return t3;
          };
          return r3.d(e3, "a", e3), e3;
        }, r3.o = function(t3, e3) {
          return Object.prototype.hasOwnProperty.call(t3, e3);
        }, r3.p = "", r3(r3.s = 2));
      }, function(t2, e2) {
        t2.exports = r2;
      }, function(t2, e2, n3) {
        function r3(t3) {
          if (a3[t3]) return a3[t3].exports;
          var e3 = a3[t3] = { i: t3, l: false, exports: {} };
          return c3[t3].call(e3.exports, e3, e3.exports, r3), e3.l = true, e3.exports;
        }
        var o3, i3, c3, a3;
        t2.exports = (o3 = n3(5), i3 = n3(3), a3 = {}, r3.m = c3 = [function(t3, e3) {
          t3.exports = o3;
        }, function(t3, e3) {
          t3.exports = i3;
        }, function(t3, e3, n4) {
          t3.exports = n4(3);
        }, function(t3, e3, n4) {
          n4.r(e3);
          var j2 = n4(1), s2 = n4(0), v2 = function(t4, e4, n5) {
            var o5, r4 = t4.textContent;
            return "" === r4.trim() ? { chunk: (o5 = n5, { text: " ", inlines: [new s2.OrderedSet()], entities: [o5], blocks: [] }) } : { chunk: { text: r4, inlines: Array(r4.length).fill(e4), entities: Array(r4.length).fill(n5), blocks: [] } };
          }, N2 = function() {
            return { text: "\n", inlines: [new s2.OrderedSet()], entities: new Array(1), blocks: [] };
          }, E2 = function() {
            return { text: "", inlines: [], entities: [], blocks: [] };
          }, S2 = function(t4, e4) {
            return { text: "", inlines: [], entities: [], blocks: [{ type: t4, depth: 0, data: e4 || new s2.Map({}) }] };
          }, w2 = function(t4, e4, n5) {
            return { text: "\r", inlines: [], entities: [], blocks: [{ type: t4, depth: Math.max(0, Math.min(4, e4)), data: n5 || new s2.Map({}) }] };
          }, C = function(t4) {
            return { text: "\r ", inlines: [new s2.OrderedSet()], entities: [t4], blocks: [{ type: "atomic", depth: 0, data: new s2.Map({}) }] };
          }, L = function(t4, e4) {
            return { text: t4.text + e4.text, inlines: t4.inlines.concat(e4.inlines), entities: t4.entities.concat(e4.entities), blocks: t4.blocks.concat(e4.blocks) };
          }, D2 = new s2.Map({ "header-one": { element: "h1" }, "header-two": { element: "h2" }, "header-three": { element: "h3" }, "header-four": { element: "h4" }, "header-five": { element: "h5" }, "header-six": { element: "h6" }, "unordered-list-item": { element: "li", wrapper: "ul" }, "ordered-list-item": { element: "li", wrapper: "ol" }, blockquote: { element: "blockquote" }, code: { element: "pre" }, atomic: { element: "figure" }, unstyled: { element: "p", aliasedElements: ["div"] } }), k2 = { code: "CODE", del: "STRIKETHROUGH", em: "ITALIC", strong: "BOLD", ins: "UNDERLINE", sub: "SUBSCRIPT", sup: "SUPERSCRIPT" };
          function O2(t4) {
            return t4.style.textAlign ? new s2.Map({ "text-align": t4.style.textAlign }) : t4.style.marginLeft ? new s2.Map({ "margin-left": t4.style.marginLeft }) : void 0;
          }
          var x2 = function(t4) {
            var e4 = void 0;
            if (t4 instanceof HTMLAnchorElement) {
              var n5 = {};
              e4 = t4.dataset && void 0 !== t4.dataset.mention ? (n5.url = t4.href, n5.text = t4.innerHTML, n5.value = t4.dataset.value, j2.Entity.__create("MENTION", "IMMUTABLE", n5)) : (n5.url = t4.getAttribute && t4.getAttribute("href") || t4.href, n5.title = t4.innerHTML, n5.targetOption = t4.target, j2.Entity.__create("LINK", "MUTABLE", n5));
            }
            return e4;
          };
          n4.d(e3, "default", function() {
            return o4;
          });
          var u2 = " ", p2 = new RegExp("&nbsp;", "g"), I = true;
          function o4(t4, e4) {
            var n5, o5, r4, i4 = (n5 = e4, o5 = t4.trim().replace(p2, u2), (r4 = (function(t5) {
              var e5, n6 = null;
              return document.implementation && document.implementation.createHTMLDocument && ((e5 = document.implementation.createHTMLDocument("foo")).documentElement.innerHTML = t5, n6 = e5.getElementsByTagName("body")[0]), n6;
            })(o5)) ? (I = true, { chunk: (function t5(e5, n6, o6, r5, i5, c5) {
              var a5 = e5.nodeName.toLowerCase();
              if (c5) {
                var l3 = c5(a5, e5);
                if (l3) {
                  var s3 = j2.Entity.__create(l3.type, l3.mutability, l3.data || {});
                  return { chunk: C(s3) };
                }
              }
              if ("#text" === a5 && "\n" !== e5.textContent) return v2(e5, n6, i5);
              if ("br" === a5) return { chunk: N2() };
              if ("img" === a5 && e5 instanceof HTMLImageElement) {
                var u3 = {};
                u3.src = e5.getAttribute && e5.getAttribute("src") || e5.src, u3.alt = e5.alt, u3.height = e5.style.height, u3.width = e5.style.width, e5.style.float && (u3.alignment = e5.style.float);
                var p3 = j2.Entity.__create("IMAGE", "MUTABLE", u3);
                return { chunk: C(p3) };
              }
              if ("video" === a5 && e5 instanceof HTMLVideoElement) {
                var d2 = {};
                d2.src = e5.getAttribute && e5.getAttribute("src") || e5.src, d2.alt = e5.alt, d2.height = e5.style.height, d2.width = e5.style.width, e5.style.float && (d2.alignment = e5.style.float);
                var f2 = j2.Entity.__create("VIDEO", "MUTABLE", d2);
                return { chunk: C(f2) };
              }
              if ("iframe" === a5 && e5 instanceof HTMLIFrameElement) {
                var y2 = {};
                y2.src = e5.getAttribute && e5.getAttribute("src") || e5.src, y2.height = e5.height, y2.width = e5.width;
                var m2 = j2.Entity.__create("EMBEDDED_LINK", "MUTABLE", y2);
                return { chunk: C(m2) };
              }
              var g2, b2 = (function(e6, n7) {
                var t6 = D2.filter(function(t7) {
                  return t7.element === e6 && (!t7.wrapper || t7.wrapper === n7) || t7.wrapper === e6 || t7.aliasedElements && -1 < t7.aliasedElements.indexOf(e6);
                }).keySeq().toSet().toArray();
                if (1 === t6.length) return t6[0];
              })(a5, r5);
              b2 && ("ul" === a5 || "ol" === a5 ? (r5 = a5, o6 += 1) : ("unordered-list-item" !== b2 && "ordered-list-item" !== b2 && (r5 = "", o6 = -1), I ? (g2 = S2(b2, O2(e5)), I = false) : g2 = w2(b2, o6, O2(e5)))), g2 = g2 || E2(), n6 = (function(t6, e6, n7) {
                var o7, r6 = k2[t6];
                if (r6) o7 = n7.add(r6).toOrderedSet();
                else if (e6 instanceof HTMLElement) {
                  var l4 = e6;
                  o7 = (o7 = n7).withMutations(function(t7) {
                    var e7 = l4.style.color, n8 = l4.style.backgroundColor, o8 = l4.style.fontSize, r7 = l4.style.fontFamily.replace(/^"|"$/g, ""), i6 = l4.style.fontWeight, c6 = l4.style.textDecoration, a6 = l4.style.fontStyle;
                    e7 && t7.add("color-".concat(e7.replace(/ /g, ""))), n8 && t7.add("bgcolor-".concat(n8.replace(/ /g, ""))), o8 && t7.add("fontsize-".concat(o8.replace(/px$/g, ""))), r7 && t7.add("fontfamily-".concat(r7)), "bold" === i6 && t7.add(k2.strong), "underline" === c6 && t7.add(k2.ins), "italic" === a6 && t7.add(k2.em);
                  }).toOrderedSet();
                }
                return o7;
              })(a5, e5, n6);
              for (var h2 = e5.firstChild; h2; ) {
                var M2 = t5(h2, n6, o6, r5, x2(h2) || i5, c5).chunk;
                g2 = L(g2, M2), h2 = h2.nextSibling;
              }
              return { chunk: g2 };
            })(r4, new s2.OrderedSet(), -1, "", void 0, n5).chunk }) : null);
            if (i4) {
              var c4 = i4.chunk, a4 = new s2.OrderedMap({});
              c4.entities && c4.entities.forEach(function(t5) {
                t5 && (a4 = a4.set(t5, j2.Entity.__get(t5)));
              });
              var l2 = 0;
              return { contentBlocks: c4.text.split("\r").map(function(t5, e5) {
                var n6 = l2 + t5.length, o6 = c4 && c4.inlines.slice(l2, n6), r5 = c4 && c4.entities.slice(l2, n6), i5 = new s2.List(o6.map(function(t6, e6) {
                  var n7 = { style: t6, entity: null };
                  return r5[e6] && (n7.entity = r5[e6]), j2.CharacterMetadata.create(n7);
                }));
                return l2 = n6, new j2.ContentBlock({ key: Object(j2.genKey)(), type: c4 && c4.blocks[e5] && c4.blocks[e5].type || "unstyled", depth: c4 && c4.blocks[e5] && c4.blocks[e5].depth, data: c4 && c4.blocks[e5] && c4.blocks[e5].data || new s2.Map({}), text: t5, characterList: i5 });
              }), entityMap: a4 };
            }
            return null;
          }
        }], r3.c = a3, r3.d = function(t3, e3, n4) {
          r3.o(t3, e3) || Object.defineProperty(t3, e3, { enumerable: true, get: n4 });
        }, r3.r = function(t3) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
        }, r3.t = function(e3, t3) {
          if (1 & t3 && (e3 = r3(e3)), 8 & t3) return e3;
          if (4 & t3 && "object" == typeof e3 && e3 && e3.__esModule) return e3;
          var n4 = /* @__PURE__ */ Object.create(null);
          if (r3.r(n4), Object.defineProperty(n4, "default", { enumerable: true, value: e3 }), 2 & t3 && "string" != typeof e3) for (var o4 in e3) r3.d(n4, o4, (function(t4) {
            return e3[t4];
          }).bind(null, o4));
          return n4;
        }, r3.n = function(t3) {
          var e3 = t3 && t3.__esModule ? function() {
            return t3.default;
          } : function() {
            return t3;
          };
          return r3.d(e3, "a", e3), e3;
        }, r3.o = function(t3, e3) {
          return Object.prototype.hasOwnProperty.call(t3, e3);
        }, r3.p = "", r3(r3.s = 2));
      }, function(t2, e2, l2) {
        function o3(n3) {
          return Array.prototype.slice.call(arguments, 1).forEach(function(e3) {
            e3 && Object.keys(e3).forEach(function(t3) {
              n3[t3] = e3[t3];
            });
          }), n3;
        }
        function s2(t3) {
          return Object.prototype.toString.call(t3);
        }
        function u2(t3) {
          return "[object Function]" === s2(t3);
        }
        function p2(t3) {
          return t3.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
        }
        var r3 = { fuzzyLink: true, fuzzyEmail: true, fuzzyIP: false };
        var i3 = { "http:": { validate: function(t3, e3, n3) {
          var o4 = t3.slice(e3);
          return n3.re.http || (n3.re.http = new RegExp("^\\/\\/" + n3.re.src_auth + n3.re.src_host_port_strict + n3.re.src_path, "i")), n3.re.http.test(o4) ? o4.match(n3.re.http)[0].length : 0;
        } }, "https:": "http:", "ftp:": "http:", "//": { validate: function(t3, e3, n3) {
          var o4 = t3.slice(e3);
          return n3.re.no_http || (n3.re.no_http = new RegExp("^" + n3.re.src_auth + "(?:localhost|(?:(?:" + n3.re.src_domain + ")\\.)+" + n3.re.src_domain_root + ")" + n3.re.src_port + n3.re.src_host_terminator + n3.re.src_path, "i")), n3.re.no_http.test(o4) ? 3 <= e3 && ":" === t3[e3 - 3] ? 0 : 3 <= e3 && "/" === t3[e3 - 3] ? 0 : o4.match(n3.re.no_http)[0].length : 0;
        } }, "mailto:": { validate: function(t3, e3, n3) {
          var o4 = t3.slice(e3);
          return n3.re.mailto || (n3.re.mailto = new RegExp("^" + n3.re.src_email_name + "@" + n3.re.src_host_strict, "i")), n3.re.mailto.test(o4) ? o4.match(n3.re.mailto)[0].length : 0;
        } } }, d2 = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", c3 = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
        function f2() {
          return function(t3, e3) {
            e3.normalize(t3);
          };
        }
        function a3(r4) {
          var e3 = r4.re = l2(21)(r4.__opts__), t3 = r4.__tlds__.slice();
          function n3(t4) {
            return t4.replace("%TLDS%", e3.src_tlds);
          }
          r4.onCompile(), r4.__tlds_replaced__ || t3.push(d2), t3.push(e3.src_xn), e3.src_tlds = t3.join("|"), e3.email_fuzzy = RegExp(n3(e3.tpl_email_fuzzy), "i"), e3.link_fuzzy = RegExp(n3(e3.tpl_link_fuzzy), "i"), e3.link_no_ip_fuzzy = RegExp(n3(e3.tpl_link_no_ip_fuzzy), "i"), e3.host_fuzzy_test = RegExp(n3(e3.tpl_host_fuzzy_test), "i");
          var i4 = [];
          function c4(t4, e4) {
            throw new Error('(LinkifyIt) Invalid schema "' + t4 + '": ' + e4);
          }
          r4.__compiled__ = {}, Object.keys(r4.__schemas__).forEach(function(t4) {
            var e4 = r4.__schemas__[t4];
            if (null !== e4) {
              var o5, n4 = { validate: null, link: null };
              if (r4.__compiled__[t4] = n4, "[object Object]" === s2(e4)) return "[object RegExp]" === s2(e4.validate) ? n4.validate = (o5 = e4.validate, function(t5, e5) {
                var n5 = t5.slice(e5);
                return o5.test(n5) ? n5.match(o5)[0].length : 0;
              }) : u2(e4.validate) ? n4.validate = e4.validate : c4(t4, e4), void (u2(e4.normalize) ? n4.normalize = e4.normalize : e4.normalize ? c4(t4, e4) : n4.normalize = f2());
              if ("[object String]" !== s2(e4)) c4(t4, e4);
              else i4.push(t4);
            }
          }), i4.forEach(function(t4) {
            r4.__compiled__[r4.__schemas__[t4]] && (r4.__compiled__[t4].validate = r4.__compiled__[r4.__schemas__[t4]].validate, r4.__compiled__[t4].normalize = r4.__compiled__[r4.__schemas__[t4]].normalize);
          }), r4.__compiled__[""] = { validate: null, normalize: f2() };
          var o4, a4 = Object.keys(r4.__compiled__).filter(function(t4) {
            return 0 < t4.length && r4.__compiled__[t4];
          }).map(p2).join("|");
          r4.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + e3.src_ZPCc + "))(" + a4 + ")", "i"), r4.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + e3.src_ZPCc + "))(" + a4 + ")", "ig"), r4.re.pretest = RegExp("(" + r4.re.schema_test.source + ")|(" + r4.re.host_fuzzy_test.source + ")|@", "i"), (o4 = r4).__index__ = -1, o4.__text_cache__ = "";
        }
        function y2(t3, e3) {
          var n3 = t3.__index__, o4 = t3.__last_index__, r4 = t3.__text_cache__.slice(n3, o4);
          this.schema = t3.__schema__.toLowerCase(), this.index = n3 + e3, this.lastIndex = o4 + e3, this.raw = r4, this.text = r4, this.url = r4;
        }
        function m2(t3, e3) {
          var n3 = new y2(t3, e3);
          return t3.__compiled__[n3.schema].normalize(n3, t3), n3;
        }
        function g2(t3, e3) {
          if (!(this instanceof g2)) return new g2(t3, e3);
          var n3;
          e3 || (n3 = t3, Object.keys(n3 || {}).reduce(function(t4, e4) {
            return t4 || r3.hasOwnProperty(e4);
          }, false) && (e3 = t3, t3 = {})), this.__opts__ = o3({}, r3, e3), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = o3({}, i3, t3), this.__compiled__ = {}, this.__tlds__ = c3, this.__tlds_replaced__ = false, this.re = {}, a3(this);
        }
        g2.prototype.add = function(t3, e3) {
          return this.__schemas__[t3] = e3, a3(this), this;
        }, g2.prototype.set = function(t3) {
          return this.__opts__ = o3(this.__opts__, t3), this;
        }, g2.prototype.test = function(t3) {
          if (this.__text_cache__ = t3, this.__index__ = -1, !t3.length) return false;
          var e3, n3, o4, r4, i4, c4, a4, l3;
          if (this.re.schema_test.test(t3)) {
            for ((a4 = this.re.schema_search).lastIndex = 0; null !== (e3 = a4.exec(t3)); ) if (r4 = this.testSchemaAt(t3, e3[2], a4.lastIndex)) {
              this.__schema__ = e3[2], this.__index__ = e3.index + e3[1].length, this.__last_index__ = e3.index + e3[0].length + r4;
              break;
            }
          }
          return this.__opts__.fuzzyLink && this.__compiled__["http:"] && 0 <= (l3 = t3.search(this.re.host_fuzzy_test)) && (this.__index__ < 0 || l3 < this.__index__) && null !== (n3 = t3.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) && (i4 = n3.index + n3[1].length, (this.__index__ < 0 || i4 < this.__index__) && (this.__schema__ = "", this.__index__ = i4, this.__last_index__ = n3.index + n3[0].length)), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && 0 <= t3.indexOf("@") && null !== (o4 = t3.match(this.re.email_fuzzy)) && (i4 = o4.index + o4[1].length, c4 = o4.index + o4[0].length, (this.__index__ < 0 || i4 < this.__index__ || i4 === this.__index__ && c4 > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = i4, this.__last_index__ = c4)), 0 <= this.__index__;
        }, g2.prototype.pretest = function(t3) {
          return this.re.pretest.test(t3);
        }, g2.prototype.testSchemaAt = function(t3, e3, n3) {
          return this.__compiled__[e3.toLowerCase()] ? this.__compiled__[e3.toLowerCase()].validate(t3, n3, this) : 0;
        }, g2.prototype.match = function(t3) {
          var e3 = 0, n3 = [];
          0 <= this.__index__ && this.__text_cache__ === t3 && (n3.push(m2(this, e3)), e3 = this.__last_index__);
          for (var o4 = e3 ? t3.slice(e3) : t3; this.test(o4); ) n3.push(m2(this, e3)), o4 = o4.slice(this.__last_index__), e3 += this.__last_index__;
          return n3.length ? n3 : null;
        }, g2.prototype.tlds = function(t3, e3) {
          return t3 = Array.isArray(t3) ? t3 : [t3], e3 ? this.__tlds__ = this.__tlds__.concat(t3).sort().filter(function(t4, e4, n3) {
            return t4 !== n3[e4 - 1];
          }).reverse() : (this.__tlds__ = t3.slice(), this.__tlds_replaced__ = true), a3(this), this;
        }, g2.prototype.normalize = function(t3) {
          t3.schema || (t3.url = "http://" + t3.url), "mailto:" !== t3.schema || /^mailto:/i.test(t3.url) || (t3.url = "mailto:" + t3.url);
        }, g2.prototype.onCompile = function() {
        }, t2.exports = g2;
      }, function(t2, e2, n3) {
        t2.exports = n3(40);
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
        var a3 = n3(11);
        function o3() {
        }
        function r3() {
        }
        r3.resetWarningCache = o3, t2.exports = function() {
          function t3(t4, e4, n5, o4, r4, i3) {
            if (i3 !== a3) {
              var c3 = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
              throw c3.name = "Invariant Violation", c3;
            }
          }
          function e3() {
            return t3;
          }
          var n4 = { array: t3.isRequired = t3, bigint: t3, bool: t3, func: t3, number: t3, object: t3, string: t3, symbol: t3, any: t3, arrayOf: e3, element: t3, elementType: t3, instanceOf: e3, node: t3, objectOf: e3, oneOf: e3, oneOfType: e3, shape: e3, exact: e3, checkPropTypes: r3, resetWarningCache: o3 };
          return n4.PropTypes = n4;
        };
      }, function(t2, e2, n3) {
        t2.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, o3) {
        t2.exports = function(t3) {
          var e3 = {};
          e3.src_Any = o3(22).source, e3.src_Cc = o3(23).source, e3.src_Z = o3(24).source, e3.src_P = o3(25).source, e3.src_ZPCc = [e3.src_Z, e3.src_P, e3.src_Cc].join("|"), e3.src_ZCc = [e3.src_Z, e3.src_Cc].join("|");
          var n3 = "[><]";
          return e3.src_pseudo_letter = "(?:(?![><]|" + e3.src_ZPCc + ")" + e3.src_Any + ")", e3.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e3.src_auth = "(?:(?:(?!" + e3.src_ZCc + "|[@/\\[\\]()]).)+@)?", e3.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e3.src_host_terminator = "(?=$|[><]|" + e3.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + e3.src_ZPCc + "))", e3.src_path = "(?:[/?#](?:(?!" + e3.src_ZCc + "|" + n3 + "|[()[\\]{}.,\"'?!\\-]).|\\[(?:(?!" + e3.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e3.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e3.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e3.src_ZCc + '|["]).)+\\"|\\\'(?:(?!' + e3.src_ZCc + "|[']).)+\\'|\\'(?=" + e3.src_pseudo_letter + "|[-]).|\\.{2,4}[a-zA-Z0-9%/]|\\.(?!" + e3.src_ZCc + "|[.]).|" + (t3 && t3["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + "\\,(?!" + e3.src_ZCc + ").|\\!(?!" + e3.src_ZCc + "|[!]).|\\?(?!" + e3.src_ZCc + "|[?]).)+|\\/)?", e3.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e3.src_xn = "xn--[a-z0-9\\-]{1,59}", e3.src_domain_root = "(?:" + e3.src_xn + "|" + e3.src_pseudo_letter + "{1,63})", e3.src_domain = "(?:" + e3.src_xn + "|(?:" + e3.src_pseudo_letter + ")|(?:" + e3.src_pseudo_letter + "(?:-|" + e3.src_pseudo_letter + "){0,61}" + e3.src_pseudo_letter + "))", e3.src_host = "(?:(?:(?:(?:" + e3.src_domain + ")\\.)*" + e3.src_domain + "))", e3.tpl_host_fuzzy = "(?:" + e3.src_ip4 + "|(?:(?:(?:" + e3.src_domain + ")\\.)+(?:%TLDS%)))", e3.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e3.src_domain + ")\\.)+(?:%TLDS%))", e3.src_host_strict = e3.src_host + e3.src_host_terminator, e3.tpl_host_fuzzy_strict = e3.tpl_host_fuzzy + e3.src_host_terminator, e3.src_host_port_strict = e3.src_host + e3.src_port + e3.src_host_terminator, e3.tpl_host_port_fuzzy_strict = e3.tpl_host_fuzzy + e3.src_port + e3.src_host_terminator, e3.tpl_host_port_no_ip_fuzzy_strict = e3.tpl_host_no_ip_fuzzy + e3.src_port + e3.src_host_terminator, e3.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e3.src_ZPCc + "|>|$))", e3.tpl_email_fuzzy = '(^|[><]|"|\\(|' + e3.src_ZCc + ")(" + e3.src_email_name + "@" + e3.tpl_host_fuzzy_strict + ")", e3.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + e3.src_ZPCc + "))((?![$+<=>^`|])" + e3.tpl_host_port_fuzzy_strict + e3.src_path + ")", e3.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + e3.src_ZPCc + "))((?![$+<=>^`|])" + e3.tpl_host_port_no_ip_fuzzy_strict + e3.src_path + ")", e3;
        };
      }, function(t2, e2) {
        t2.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      }, function(t2, e2) {
        t2.exports = /[\0-\x1F\x7F-\x9F]/;
      }, function(t2, e2) {
        t2.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
      }, function(t2, e2) {
        t2.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
      }, function(t2, e2, n3) {
        n3.r(e2), n3.d(e2, "Editor", function() {
          return ar2;
        });
        var f2 = n3(1), N2 = n3.n(f2), o3 = n3(0), y2 = n3.n(o3), E2 = n3(3), S2 = n3(4), r3 = n3(2), w2 = n3.n(r3);
        function c3(t3, e3, n4) {
          return Object.defineProperty(t3, "prototype", { writable: false }), t3;
        }
        var a3 = c3(function t3() {
          var n4 = this;
          !(function(t4, e3) {
            if (!(t4 instanceof e3)) throw new TypeError("Cannot call a class as a function");
          })(this, t3), this.callBacks = [], this.suggestionCallback = void 0, this.editorFlag = false, this.suggestionFlag = false, this.closeAllModals = function(e3) {
            n4.callBacks.forEach(function(t4) {
              t4(e3);
            });
          }, this.init = function(t4) {
            var e3 = document.getElementById(t4);
            e3 && e3.addEventListener("click", function() {
              n4.editorFlag = true;
            }), document && (document.addEventListener("click", function() {
              n4.editorFlag ? n4.editorFlag = false : (n4.closeAllModals(), n4.suggestionCallback && n4.suggestionCallback());
            }), document.addEventListener("keydown", function(t5) {
              "Escape" === t5.key && n4.closeAllModals();
            }));
          }, this.onEditorClick = function() {
            n4.closeModals(), !n4.suggestionFlag && n4.suggestionCallback ? n4.suggestionCallback() : n4.suggestionFlag = false;
          }, this.closeModals = function(t4) {
            n4.closeAllModals(t4);
          }, this.registerCallBack = function(t4) {
            n4.callBacks.push(t4);
          }, this.deregisterCallBack = function(e3) {
            n4.callBacks = n4.callBacks.filter(function(t4) {
              return t4 !== e3;
            });
          }, this.setSuggestionCallback = function(t4) {
            n4.suggestionCallback = t4;
          }, this.removeSuggestionCallback = function() {
            n4.suggestionCallback = void 0;
          }, this.onSuggestionClick = function() {
            n4.suggestionFlag = true;
          };
        });
        function s2(t3, e3, n4) {
          return Object.defineProperty(t3, "prototype", { writable: false }), t3;
        }
        var u2, p2 = s2(function t3() {
          var e3 = this;
          !(function(t4, e4) {
            if (!(t4 instanceof e4)) throw new TypeError("Cannot call a class as a function");
          })(this, t3), this.inputFocused = false, this.editorMouseDown = false, this.onEditorMouseDown = function() {
            e3.editorFocused = true;
          }, this.onInputMouseDown = function() {
            e3.inputFocused = true;
          }, this.isEditorBlur = function(t4) {
            return "INPUT" !== t4.target.tagName && "LABEL" !== t4.target.tagName && "TEXTAREA" !== t4.target.tagName || e3.editorFocused ? !("INPUT" === t4.target.tagName && "LABEL" === t4.target.tagName && "TEXTAREA" === t4.target.tagName || e3.inputFocused) && !(e3.editorFocused = false) : !(e3.inputFocused = false);
          }, this.isEditorFocused = function() {
            return !e3.inputFocused || (e3.inputFocused = false);
          }, this.isToolbarFocused = function() {
            return !e3.editorFocused || (e3.editorFocused = false);
          }, this.isInputFocused = function() {
            return e3.inputFocused;
          };
        }), d2 = [], C = { onKeyDown: function(e3) {
          d2.forEach(function(t3) {
            t3(e3);
          });
        }, registerCallBack: function(t3) {
          d2.push(t3);
        }, deregisterCallBack: function(e3) {
          d2 = d2.filter(function(t3) {
            return t3 !== e3;
          });
        } }, m2 = function() {
          u2 = true;
        }, g2 = function() {
          u2 = false;
        }, b2 = function() {
          return u2;
        };
        function L(t3) {
          var e3 = t3.getData() && t3.getData().get("text-align");
          return e3 ? "rdw-".concat(e3, "-aligned-block") : "";
        }
        function h2(t3, e3) {
          if (t3) for (var n4 in t3) !{}.hasOwnProperty.call(t3, n4) || e3(n4, t3[n4]);
        }
        function M2(t3, e3) {
          var n4 = false;
          if (t3) {
            for (var o4 in t3) if ({}.hasOwnProperty.call(t3, o4) && e3 === o4) {
              n4 = true;
              break;
            }
          }
          return n4;
        }
        function j2(t3) {
          t3.stopPropagation();
        }
        function v2(t3) {
          return t3[t3.options[0]].icon;
        }
        function D2(t3, o4) {
          if (t3 && void 0 === o4) return t3;
          var r4 = {};
          return h2(t3, function(t4, e3) {
            var n4;
            n4 = e3, "[object Object]" === Object.prototype.toString.call(n4) ? r4[t4] = D2(e3, o4[t4]) : r4[t4] = void 0 !== o4[t4] ? o4[t4] : e3;
          }), r4;
        }
        var k2 = n3(6), O2 = n3.n(k2), x2 = n3(5);
        n3(9);
        function I(t3) {
          return (I = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function T(t3, e3, n4) {
          return e3 in t3 ? Object.defineProperty(t3, e3, { value: n4, enumerable: true, configurable: true, writable: true }) : t3[e3] = n4, t3;
        }
        function A2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function z2(t3, e3) {
          return (z2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function _23(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = P(o4);
            if (r4) {
              var n4 = P(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === I(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function P(t3) {
          return (P = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var R = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && z2(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, o4 = _23(i3);
          function i3() {
            var r4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3);
            for (var t4 = arguments.length, e4 = new Array(t4), n4 = 0; n4 < t4; n4++) e4[n4] = arguments[n4];
            return (r4 = o4.call.apply(o4, [this].concat(e4))).onClick = function() {
              var t5 = r4.props, e5 = t5.disabled, n5 = t5.onClick, o5 = t5.value;
              e5 || n5(o5);
            }, r4;
          }
          return t3 = i3, (e3 = [{ key: "render", value: function() {
            var t4, e4 = this.props, n4 = e4.children, o5 = e4.className, r4 = e4.activeClassName, i4 = e4.active, c4 = e4.disabled, a4 = e4.title;
            return N2.a.createElement("div", { className: w2()("rdw-option-wrapper", o5, (T(t4 = {}, "rdw-option-active ".concat(r4), i4), T(t4, "rdw-option-disabled", c4), t4)), onClick: this.onClick, "aria-selected": i4, title: a4 }, n4);
          } }]) && A2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        R.propTypes = { onClick: y2.a.func.isRequired, children: y2.a.any, value: y2.a.string, className: y2.a.string, activeClassName: y2.a.string, active: y2.a.bool, disabled: y2.a.bool, title: y2.a.string }, R.defaultProps = { activeClassName: "" };
        n3(12);
        function U2(t3) {
          return (U2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function B(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function F(t3, e3) {
          return (F = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Y2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Q(o4);
            if (r4) {
              var n4 = Q(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === U2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Q(t3) {
          return (Q = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var H2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && F(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, r4 = Y2(i3);
          function i3() {
            var o4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3);
            for (var t4 = arguments.length, e4 = new Array(t4), n4 = 0; n4 < t4; n4++) e4[n4] = arguments[n4];
            return (o4 = r4.call.apply(r4, [this].concat(e4))).state = { highlighted: -1 }, o4.onChange = function(t5) {
              var e5 = o4.props.onChange;
              e5 && e5(t5), o4.toggleExpansion();
            }, o4.setHighlighted = function(t5) {
              o4.setState({ highlighted: t5 });
            }, o4.toggleExpansion = function() {
              var t5 = o4.props, e5 = t5.doExpand, n5 = t5.doCollapse;
              t5.expanded ? n5() : e5();
            }, o4;
          }
          return t3 = i3, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props.expanded;
            t4.expanded && !e4 && this.setState({ highlighted: -1 });
          } }, { key: "render", value: function() {
            var n4 = this, t4 = this.props, e4 = t4.expanded, o4 = t4.children, r5 = t4.className, i4 = t4.optionWrapperClassName, c4 = t4.ariaLabel, a4 = t4.onExpandEvent, l2 = t4.title, s3 = this.state.highlighted, u3 = o4.slice(1, o4.length);
            return N2.a.createElement("div", { className: w2()("rdw-dropdown-wrapper", r5), "aria-expanded": e4, "aria-label": c4 || "rdw-dropdown" }, N2.a.createElement("a", { className: "rdw-dropdown-selectedtext", onClick: a4, title: l2 }, o4[0], N2.a.createElement("div", { className: w2()({ "rdw-dropdown-carettoclose": e4, "rdw-dropdown-carettoopen": !e4 }) })), e4 ? N2.a.createElement("ul", { className: w2()("rdw-dropdown-optionwrapper", i4), onClick: j2 }, N2.a.Children.map(u3, function(t5, e5) {
              return t5 && N2.a.cloneElement(t5, { onSelect: n4.onChange, highlighted: s3 === e5, setHighlighted: n4.setHighlighted, index: e5 });
            })) : void 0);
          } }]) && B(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        H2.propTypes = { children: y2.a.any, onChange: y2.a.func, className: y2.a.string, expanded: y2.a.bool, doExpand: y2.a.func, doCollapse: y2.a.func, onExpandEvent: y2.a.func, optionWrapperClassName: y2.a.string, ariaLabel: y2.a.string, title: y2.a.string };
        n3(13);
        function Z2(t3) {
          return (Z2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function W(t3, e3, n4) {
          return e3 in t3 ? Object.defineProperty(t3, e3, { value: n4, enumerable: true, configurable: true, writable: true }) : t3[e3] = n4, t3;
        }
        function G2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function J2(t3, e3) {
          return (J2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function V2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = q2(o4);
            if (r4) {
              var n4 = q2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === Z2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function q2(t3) {
          return (q2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var K2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && J2(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = V2(r4);
          function r4() {
            var i3;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, r4);
            for (var t4 = arguments.length, e4 = new Array(t4), n4 = 0; n4 < t4; n4++) e4[n4] = arguments[n4];
            return (i3 = o4.call.apply(o4, [this].concat(e4))).onClick = function(t5) {
              var e5 = i3.props, n5 = e5.onSelect, o5 = e5.onClick, r5 = e5.value;
              e5.disabled || (n5 && n5(r5), o5 && (t5.stopPropagation(), o5(r5)));
            }, i3.setHighlighted = function() {
              var t5 = i3.props;
              (0, t5.setHighlighted)(t5.index);
            }, i3.resetHighlighted = function() {
              (0, i3.props.setHighlighted)(-1);
            }, i3;
          }
          return t3 = r4, (e3 = [{ key: "render", value: function() {
            var t4, e4 = this.props, n4 = e4.children, o5 = e4.active, r5 = e4.disabled, i3 = e4.highlighted, c4 = e4.className, a4 = e4.activeClassName, l2 = e4.disabledClassName, s3 = e4.highlightedClassName, u3 = e4.title;
            return N2.a.createElement("li", { className: w2()("rdw-dropdownoption-default", c4, (W(t4 = {}, "rdw-dropdownoption-active ".concat(a4), o5), W(t4, "rdw-dropdownoption-highlighted ".concat(s3), i3), W(t4, "rdw-dropdownoption-disabled ".concat(l2), r5), t4)), onMouseEnter: this.setHighlighted, onMouseLeave: this.resetHighlighted, onClick: this.onClick, title: u3 }, n4);
          } }]) && G2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        K2.propTypes = { children: y2.a.any, value: y2.a.any, onClick: y2.a.func, onSelect: y2.a.func, setHighlighted: y2.a.func, index: y2.a.number, disabled: y2.a.bool, active: y2.a.bool, highlighted: y2.a.bool, className: y2.a.string, activeClassName: y2.a.string, disabledClassName: y2.a.string, highlightedClassName: y2.a.string, title: y2.a.string }, K2.defaultProps = { activeClassName: "", disabledClassName: "", highlightedClassName: "" };
        n3(14);
        function X2(t3) {
          return (X2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function $2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function tt(t3, e3) {
          return (tt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function et2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = nt(o4);
            if (r4) {
              var n4 = nt(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === X2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function nt(t3) {
          return (nt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var ot2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && tt(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = et2(r4);
          function r4() {
            return (function(t4, e4) {
              if (!(t4 instanceof e4)) throw new TypeError("Cannot call a class as a function");
            })(this, r4), o4.apply(this, arguments);
          }
          return t3 = r4, (e3 = [{ key: "renderInFlatList", value: function() {
            var t4 = this.props, n4 = t4.config, o5 = t4.currentState, r5 = t4.onChange, i3 = t4.translations;
            return N2.a.createElement("div", { className: w2()("rdw-inline-wrapper", n4.className), "aria-label": "rdw-inline-control" }, n4.options.map(function(t5, e4) {
              return N2.a.createElement(R, { key: e4, value: t5, onClick: r5, className: w2()(n4[t5].className), active: true === o5[t5] || "MONOSPACE" === t5 && o5.CODE, title: n4[t5].title || i3["components.controls.inline.".concat(t5)] }, N2.a.createElement("img", { alt: "", src: n4[t5].icon }));
            }));
          } }, { key: "renderInDropDown", value: function() {
            var t4 = this.props, n4 = t4.config, e4 = t4.expanded, o5 = t4.doExpand, r5 = t4.onExpandEvent, i3 = t4.doCollapse, c4 = t4.currentState, a4 = t4.onChange, l2 = t4.translations, s3 = n4.className, u3 = n4.dropdownClassName, p3 = n4.title;
            return N2.a.createElement(H2, { className: w2()("rdw-inline-dropdown", s3), optionWrapperClassName: w2()(u3), onChange: a4, expanded: e4, doExpand: o5, doCollapse: i3, onExpandEvent: r5, "aria-label": "rdw-inline-control", title: p3 }, N2.a.createElement("img", { src: v2(n4), alt: "" }), n4.options.map(function(t5, e5) {
              return N2.a.createElement(K2, { key: e5, value: t5, className: w2()("rdw-inline-dropdownoption", n4[t5].className), active: true === c4[t5] || "MONOSPACE" === t5 && c4.CODE, title: n4[t5].title || l2["components.controls.inline.".concat(t5)] }, N2.a.createElement("img", { src: n4[t5].icon, alt: "" }));
            }));
          } }, { key: "render", value: function() {
            return this.props.config.inDropdown ? this.renderInDropDown() : this.renderInFlatList();
          } }]) && $2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        function rt2(t3) {
          return (rt2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function it(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function ct2(t3, e3) {
          return (ct2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function at2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = lt(o4);
            if (r4) {
              var n4 = lt(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === rt2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function lt(t3) {
          return (lt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        ot2.propTypes = { expanded: y2.a.bool, doExpand: y2.a.func, doCollapse: y2.a.func, onExpandEvent: y2.a.func, config: y2.a.object, onChange: y2.a.func, currentState: y2.a.object, translations: y2.a.object };
        var st2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && ct2(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, r4 = at2(i3);
          function i3(t4) {
            var l2;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3), (l2 = r4.call(this, t4)).onExpandEvent = function() {
              l2.signalExpanded = !l2.state.expanded;
            }, l2.expandCollapse = function() {
              l2.setState({ expanded: l2.signalExpanded }), l2.signalExpanded = false;
            }, l2.toggleInlineStyle = function(t5) {
              var e5 = "monospace" === t5 ? "CODE" : t5.toUpperCase(), n5 = l2.props, o5 = n5.editorState, r5 = n5.onChange, i4 = E2.RichUtils.toggleInlineStyle(o5, e5);
              if ("subscript" === t5 || "superscript" === t5) {
                var c4 = "subscript" === t5 ? "SUPERSCRIPT" : "SUBSCRIPT", a4 = E2.Modifier.removeInlineStyle(i4.getCurrentContent(), i4.getSelection(), c4);
                i4 = E2.EditorState.push(i4, a4, "change-inline-style");
              }
              i4 && r5(i4);
            }, l2.changeKeys = function(t5) {
              if (t5) {
                var n5 = {};
                return h2(t5, function(t6, e5) {
                  n5["CODE" === t6 ? "monospace" : t6.toLowerCase()] = e5;
                }), n5;
              }
            }, l2.doExpand = function() {
              l2.setState({ expanded: true });
            }, l2.doCollapse = function() {
              l2.setState({ expanded: false });
            };
            var e4 = l2.props, n4 = e4.editorState, o4 = e4.modalHandler;
            return l2.state = { currentStyles: n4 ? l2.changeKeys(Object(S2.getSelectionInlineStyle)(n4)) : {} }, o4.registerCallBack(l2.expandCollapse), l2;
          }
          return t3 = i3, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props.editorState;
            e4 && e4 !== t4.editorState && this.setState({ currentStyles: this.changeKeys(Object(S2.getSelectionInlineStyle)(e4)) });
          } }, { key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.translations, o4 = this.state, r5 = o4.expanded, i4 = o4.currentStyles, c4 = e4.component || ot2;
            return N2.a.createElement(c4, { config: e4, translations: n4, currentState: i4, expanded: r5, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse, onChange: this.toggleInlineStyle });
          } }]) && it(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        st2.propTypes = { onChange: y2.a.func.isRequired, editorState: y2.a.object.isRequired, modalHandler: y2.a.object, config: y2.a.object, translations: y2.a.object };
        n3(15);
        function ut(t3) {
          return (ut = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function pt2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function dt(t3, e3) {
          return (dt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function ft(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = yt(o4);
            if (r4) {
              var n4 = yt(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === ut(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function yt(t3) {
          return (yt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var mt2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && dt(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = ft(r4);
          function r4(t4) {
            var e4;
            return (function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, r4), (e4 = o4.call(this, t4)).getBlockTypes = function(t5) {
              return [{ label: "Normal", displayName: t5["components.controls.blocktype.normal"] }, { label: "H1", displayName: t5["components.controls.blocktype.h1"] }, { label: "H2", displayName: t5["components.controls.blocktype.h2"] }, { label: "H3", displayName: t5["components.controls.blocktype.h3"] }, { label: "H4", displayName: t5["components.controls.blocktype.h4"] }, { label: "H5", displayName: t5["components.controls.blocktype.h5"] }, { label: "H6", displayName: t5["components.controls.blocktype.h6"] }, { label: "Blockquote", displayName: t5["components.controls.blocktype.blockquote"] }, { label: "Code", displayName: t5["components.controls.blocktype.code"] }];
            }, e4.state = { blockTypes: e4.getBlockTypes(t4.translations) }, e4;
          }
          return t3 = r4, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props.translations;
            e4 !== t4.translations && this.setState({ blockTypes: this.getBlockTypes(e4) });
          } }, { key: "renderFlat", value: function(t4) {
            var e4 = this.props, n4 = e4.config.className, o5 = e4.onChange, r5 = e4.currentState.blockType;
            return N2.a.createElement("div", { className: w2()("rdw-inline-wrapper", n4) }, t4.map(function(t5, e5) {
              return N2.a.createElement(R, { key: e5, value: t5.label, active: r5 === t5.label, onClick: o5 }, t5.displayName);
            }));
          } }, { key: "renderInDropdown", value: function(t4) {
            var e4 = this.props, n4 = e4.config, o5 = n4.className, r5 = n4.dropdownClassName, i3 = n4.title, c4 = e4.currentState.blockType, a4 = e4.expanded, l2 = e4.doExpand, s3 = e4.onExpandEvent, u3 = e4.doCollapse, p3 = e4.onChange, d3 = e4.translations, f3 = this.state.blockTypes.filter(function(t5) {
              return t5.label === c4;
            }), y3 = f3 && f3[0] && f3[0].displayName;
            return N2.a.createElement("div", { className: "rdw-block-wrapper", "aria-label": "rdw-block-control" }, N2.a.createElement(H2, { className: w2()("rdw-block-dropdown", o5), optionWrapperClassName: w2()(r5), onChange: p3, expanded: a4, doExpand: l2, doCollapse: u3, onExpandEvent: s3, title: i3 || d3["components.controls.blocktype.blocktype"] }, N2.a.createElement("span", null, y3 || d3["components.controls.blocktype.blocktype"]), t4.map(function(t5, e5) {
              return N2.a.createElement(K2, { active: c4 === t5.label, value: t5.label, key: e5 }, t5.displayName);
            })));
          } }, { key: "render", value: function() {
            var n4 = this.props.config, t4 = n4.inDropdown, e4 = this.state.blockTypes.filter(function(t5) {
              var e5 = t5.label;
              return -1 < n4.options.indexOf(e5);
            });
            return t4 ? this.renderInDropdown(e4) : this.renderFlat(e4);
          } }]) && pt2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        mt2.propTypes = { expanded: y2.a.bool, onExpandEvent: y2.a.func, doExpand: y2.a.func, doCollapse: y2.a.func, onChange: y2.a.func, config: y2.a.object, currentState: y2.a.object, translations: y2.a.object };
        var gt2 = mt2;
        function bt2(t3) {
          return (bt2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function ht2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function Mt(t3, e3) {
          return (Mt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function jt2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = vt2(o4);
            if (r4) {
              var n4 = vt2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === bt2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function vt2(t3) {
          return (vt2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var Nt = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Mt(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = jt2(r4);
          function r4(t4) {
            var c4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, r4), (c4 = o4.call(this, t4)).onExpandEvent = function() {
              c4.signalExpanded = !c4.state.expanded;
            }, c4.expandCollapse = function() {
              c4.setState({ expanded: c4.signalExpanded }), c4.signalExpanded = false;
            }, c4.blocksTypes = [{ label: "Normal", style: "unstyled" }, { label: "H1", style: "header-one" }, { label: "H2", style: "header-two" }, { label: "H3", style: "header-three" }, { label: "H4", style: "header-four" }, { label: "H5", style: "header-five" }, { label: "H6", style: "header-six" }, { label: "Blockquote", style: "blockquote" }, { label: "Code", style: "code" }], c4.doExpand = function() {
              c4.setState({ expanded: true });
            }, c4.doCollapse = function() {
              c4.setState({ expanded: false });
            }, c4.toggleBlockType = function(e5) {
              var t5 = c4.blocksTypes.find(function(t6) {
                return t6.label === e5;
              }).style, n5 = c4.props, o5 = n5.editorState, r5 = n5.onChange, i3 = E2.RichUtils.toggleBlockType(o5, t5);
              i3 && r5(i3);
            };
            var e4 = t4.editorState, n4 = t4.modalHandler;
            return c4.state = { expanded: false, currentBlockType: e4 ? Object(S2.getSelectedBlocksType)(e4) : "unstyled" }, n4.registerCallBack(c4.expandCollapse), c4;
          }
          return t3 = r4, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props.editorState;
            e4 && e4 !== t4.editorState && this.setState({ currentBlockType: Object(S2.getSelectedBlocksType)(e4) });
          } }, { key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.translations, o5 = this.state, r5 = o5.expanded, i3 = o5.currentBlockType, c4 = e4.component || gt2, a4 = this.blocksTypes.find(function(t5) {
              return t5.style === i3;
            });
            return N2.a.createElement(c4, { config: e4, translations: n4, currentState: { blockType: a4 && a4.label }, onChange: this.toggleBlockType, expanded: r5, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse });
          } }]) && ht2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        Nt.propTypes = { onChange: y2.a.func.isRequired, editorState: y2.a.object, modalHandler: y2.a.object, config: y2.a.object, translations: y2.a.object };
        var Et2 = Nt;
        n3(16);
        function St(t3) {
          return (St = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function wt2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function Ct(t3, e3) {
          return (Ct = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Lt(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Dt2(o4);
            if (r4) {
              var n4 = Dt2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === St(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Dt2(t3) {
          return (Dt2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var kt2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Ct(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, r4 = Lt(i3);
          function i3() {
            var t4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3);
            for (var e4 = arguments.length, n4 = new Array(e4), o4 = 0; o4 < e4; o4++) n4[o4] = arguments[o4];
            return (t4 = r4.call.apply(r4, [this].concat(n4))).state = { defaultFontSize: void 0 }, t4;
          }
          return t3 = i3, (e3 = [{ key: "componentDidMount", value: function() {
            var t4 = document.getElementsByClassName("DraftEditor-root");
            if (t4 && 0 < t4.length) {
              var e4 = window.getComputedStyle(t4[0]).getPropertyValue("font-size");
              e4 = e4.substring(0, e4.length - 2), this.setState({ defaultFontSize: e4 });
            }
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = e4.icon, o4 = e4.className, r5 = e4.dropdownClassName, i4 = e4.options, c4 = e4.title, a4 = t4.onChange, l2 = t4.expanded, s3 = t4.doCollapse, u3 = t4.onExpandEvent, p3 = t4.doExpand, d3 = t4.translations, f3 = this.props.currentState.fontSize, y3 = this.state.defaultFontSize;
            return y3 = Number(y3), f3 = f3 || i4 && 0 <= i4.indexOf(y3) && y3, N2.a.createElement("div", { className: "rdw-fontsize-wrapper", "aria-label": "rdw-font-size-control" }, N2.a.createElement(H2, { className: w2()("rdw-fontsize-dropdown", o4), optionWrapperClassName: w2()(r5), onChange: a4, expanded: l2, doExpand: p3, doCollapse: s3, onExpandEvent: u3, title: c4 || d3["components.controls.fontsize.fontsize"] }, f3 ? N2.a.createElement("span", null, f3) : N2.a.createElement("img", { src: n4, alt: "" }), i4.map(function(t5, e5) {
              return N2.a.createElement(K2, { className: "rdw-fontsize-option", active: f3 === t5, value: t5, key: e5 }, t5);
            })));
          } }]) && wt2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        function Ot(t3) {
          return (Ot = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function xt(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function It2(t3, e3) {
          return (It2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Tt2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = At(o4);
            if (r4) {
              var n4 = At(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === Ot(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function At(t3) {
          return (At = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        kt2.propTypes = { expanded: y2.a.bool, onExpandEvent: y2.a.func, doExpand: y2.a.func, doCollapse: y2.a.func, onChange: y2.a.func, config: y2.a.object, currentState: y2.a.object, translations: y2.a.object };
        var zt2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && It2(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = Tt2(r4);
          function r4(t4) {
            var i3;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, r4), (i3 = o4.call(this, t4)).onExpandEvent = function() {
              i3.signalExpanded = !i3.state.expanded;
            }, i3.expandCollapse = function() {
              i3.setState({ expanded: i3.signalExpanded }), i3.signalExpanded = false;
            }, i3.doExpand = function() {
              i3.setState({ expanded: true });
            }, i3.doCollapse = function() {
              i3.setState({ expanded: false });
            }, i3.toggleFontSize = function(t5) {
              var e5 = i3.props, n5 = e5.editorState, o5 = e5.onChange, r5 = Object(S2.toggleCustomInlineStyle)(n5, "fontSize", t5);
              r5 && o5(r5);
            };
            var e4 = t4.editorState, n4 = t4.modalHandler;
            return i3.state = { expanded: void 0, currentFontSize: e4 ? Object(S2.getSelectionCustomInlineStyle)(e4, ["FONTSIZE"]).FONTSIZE : void 0 }, n4.registerCallBack(i3.expandCollapse), i3;
          }
          return t3 = r4, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props.editorState;
            e4 && e4 !== t4.editorState && this.setState({ currentFontSize: Object(S2.getSelectionCustomInlineStyle)(e4, ["FONTSIZE"]).FONTSIZE });
          } }, { key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.translations, o5 = this.state, r5 = o5.expanded, i3 = o5.currentFontSize, c4 = e4.component || kt2, a4 = i3 && Number(i3.substring(9));
            return N2.a.createElement(c4, { config: e4, translations: n4, currentState: { fontSize: a4 }, onChange: this.toggleFontSize, expanded: r5, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse });
          } }]) && xt(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        zt2.propTypes = { onChange: y2.a.func.isRequired, editorState: y2.a.object, modalHandler: y2.a.object, config: y2.a.object, translations: y2.a.object };
        n3(17);
        function _t(t3) {
          return (_t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function Pt2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function Rt2(t3, e3) {
          return (Rt2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Ut(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Bt(o4);
            if (r4) {
              var n4 = Bt(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === _t(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Bt(t3) {
          return (Bt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var Ft = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Rt2(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, r4 = Ut(i3);
          function i3() {
            var t4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3);
            for (var e4 = arguments.length, n4 = new Array(e4), o4 = 0; o4 < e4; o4++) n4[o4] = arguments[o4];
            return (t4 = r4.call.apply(r4, [this].concat(n4))).state = { defaultFontFamily: void 0 }, t4;
          }
          return t3 = i3, (e3 = [{ key: "componentDidMount", value: function() {
            var t4 = document.getElementsByClassName("DraftEditor-root");
            if (t4 && 0 < t4.length) {
              var e4 = window.getComputedStyle(t4[0]).getPropertyValue("font-family");
              this.setState({ defaultFontFamily: e4 });
            }
          } }, { key: "render", value: function() {
            var e4 = this.state.defaultFontFamily, t4 = this.props, n4 = t4.config, o4 = n4.className, r5 = n4.dropdownClassName, i4 = n4.options, c4 = n4.title, a4 = t4.translations, l2 = t4.onChange, s3 = t4.expanded, u3 = t4.doCollapse, p3 = t4.onExpandEvent, d3 = t4.doExpand, f3 = this.props.currentState.fontFamily;
            return f3 = f3 || i4 && e4 && i4.some(function(t5) {
              return t5.toLowerCase() === e4.toLowerCase();
            }) && e4, N2.a.createElement("div", { className: "rdw-fontfamily-wrapper", "aria-label": "rdw-font-family-control" }, N2.a.createElement(H2, { className: w2()("rdw-fontfamily-dropdown", o4), optionWrapperClassName: w2()("rdw-fontfamily-optionwrapper", r5), onChange: l2, expanded: s3, doExpand: d3, doCollapse: u3, onExpandEvent: p3, title: c4 || a4["components.controls.fontfamily.fontfamily"] }, N2.a.createElement("span", { className: "rdw-fontfamily-placeholder" }, f3 || a4["components.controls.fontfamily.fontfamily"]), i4.map(function(t5, e5) {
              return N2.a.createElement(K2, { active: f3 === t5, value: t5, key: e5 }, t5);
            })));
          } }]) && Pt2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        Ft.propTypes = { expanded: y2.a.bool, onExpandEvent: y2.a.func, doExpand: y2.a.func, doCollapse: y2.a.func, onChange: y2.a.func, config: y2.a.object, currentState: y2.a.object, translations: y2.a.object };
        var Yt2 = Ft;
        function Qt(t3) {
          return (Qt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function Ht2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function Zt2(t3, e3) {
          return (Zt2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Wt(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Gt2(o4);
            if (r4) {
              var n4 = Gt2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === Qt(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Gt2(t3) {
          return (Gt2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var Jt = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Zt2(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = Wt(r4);
          function r4(t4) {
            var i3;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, r4), (i3 = o4.call(this, t4)).onExpandEvent = function() {
              i3.signalExpanded = !i3.state.expanded;
            }, i3.expandCollapse = function() {
              i3.setState({ expanded: i3.signalExpanded }), i3.signalExpanded = false;
            }, i3.doExpand = function() {
              i3.setState({ expanded: true });
            }, i3.doCollapse = function() {
              i3.setState({ expanded: false });
            }, i3.toggleFontFamily = function(t5) {
              var e5 = i3.props, n5 = e5.editorState, o5 = e5.onChange, r5 = Object(S2.toggleCustomInlineStyle)(n5, "fontFamily", t5);
              r5 && o5(r5);
            };
            var e4 = t4.editorState, n4 = t4.modalHandler;
            return i3.state = { expanded: void 0, currentFontFamily: e4 ? Object(S2.getSelectionCustomInlineStyle)(e4, ["FONTFAMILY"]).FONTFAMILY : void 0 }, n4.registerCallBack(i3.expandCollapse), i3;
          }
          return t3 = r4, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props.editorState;
            e4 && e4 !== t4.editorState && this.setState({ currentFontFamily: Object(S2.getSelectionCustomInlineStyle)(e4, ["FONTFAMILY"]).FONTFAMILY });
          } }, { key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.translations, o5 = this.state, r5 = o5.expanded, i3 = o5.currentFontFamily, c4 = e4.component || Yt2, a4 = i3 && i3.substring(11);
            return N2.a.createElement(c4, { translations: n4, config: e4, currentState: { fontFamily: a4 }, onChange: this.toggleFontFamily, expanded: r5, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse });
          } }]) && Ht2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        Jt.propTypes = { onChange: y2.a.func.isRequired, editorState: y2.a.object, modalHandler: y2.a.object, config: y2.a.object, translations: y2.a.object };
        n3(18);
        function Vt2(t3) {
          return (Vt2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function qt2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function Kt(t3, e3) {
          return (Kt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Xt(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = $t2(o4);
            if (r4) {
              var n4 = $t2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === Vt2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function $t2(t3) {
          return ($t2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var te2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Kt(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, r4 = Xt(i3);
          function i3() {
            var e4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3);
            for (var t4 = arguments.length, n4 = new Array(t4), o4 = 0; o4 < t4; o4++) n4[o4] = arguments[o4];
            return (e4 = r4.call.apply(r4, [this].concat(n4))).options = ["unordered", "ordered", "indent", "outdent"], e4.toggleBlockType = function(t5) {
              (0, e4.props.onChange)(t5);
            }, e4.indent = function() {
              (0, e4.props.onChange)("indent");
            }, e4.outdent = function() {
              (0, e4.props.onChange)("outdent");
            }, e4;
          }
          return t3 = i3, (e3 = [{ key: "renderInFlatList", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.currentState.listType, o4 = t4.translations, r5 = t4.indentDisabled, i4 = t4.outdentDisabled, c4 = e4.options, a4 = e4.unordered, l2 = e4.ordered, s3 = e4.indent, u3 = e4.outdent, p3 = e4.className;
            return N2.a.createElement("div", { className: w2()("rdw-list-wrapper", p3), "aria-label": "rdw-list-control" }, 0 <= c4.indexOf("unordered") && N2.a.createElement(R, { value: "unordered", onClick: this.toggleBlockType, className: w2()(a4.className), active: "unordered" === n4, title: a4.title || o4["components.controls.list.unordered"] }, N2.a.createElement("img", { src: a4.icon, alt: "" })), 0 <= c4.indexOf("ordered") && N2.a.createElement(R, { value: "ordered", onClick: this.toggleBlockType, className: w2()(l2.className), active: "ordered" === n4, title: l2.title || o4["components.controls.list.ordered"] }, N2.a.createElement("img", { src: l2.icon, alt: "" })), 0 <= c4.indexOf("indent") && N2.a.createElement(R, { onClick: this.indent, disabled: r5, className: w2()(s3.className), title: s3.title || o4["components.controls.list.indent"] }, N2.a.createElement("img", { src: s3.icon, alt: "" })), 0 <= c4.indexOf("outdent") && N2.a.createElement(R, { onClick: this.outdent, disabled: i4, className: w2()(u3.className), title: u3.title || o4["components.controls.list.outdent"] }, N2.a.createElement("img", { src: u3.icon, alt: "" })));
          } }, { key: "renderInDropDown", value: function() {
            var n4 = this, t4 = this.props, o4 = t4.config, e4 = t4.expanded, r5 = t4.doCollapse, i4 = t4.doExpand, c4 = t4.onExpandEvent, a4 = t4.onChange, l2 = t4.currentState.listType, s3 = t4.translations, u3 = o4.options, p3 = o4.className, d3 = o4.dropdownClassName, f3 = o4.title;
            return N2.a.createElement(H2, { className: w2()("rdw-list-dropdown", p3), optionWrapperClassName: w2()(d3), onChange: a4, expanded: e4, doExpand: i4, doCollapse: r5, onExpandEvent: c4, "aria-label": "rdw-list-control", title: f3 || s3["components.controls.list.list"] }, N2.a.createElement("img", { src: v2(o4), alt: "" }), this.options.filter(function(t5) {
              return 0 <= u3.indexOf(t5);
            }).map(function(t5, e5) {
              return N2.a.createElement(K2, { key: e5, value: t5, disabled: n4.props["".concat(t5, "Disabled")], className: w2()("rdw-list-dropdownOption", o4[t5].className), active: l2 === t5, title: o4[t5].title || s3["components.controls.list.".concat(t5)] }, N2.a.createElement("img", { src: o4[t5].icon, alt: "" }));
            }));
          } }, { key: "render", value: function() {
            return this.props.config.inDropdown ? this.renderInDropDown() : this.renderInFlatList();
          } }]) && qt2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        function ee2(t3) {
          return (ee2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function ne2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function oe2(t3, e3) {
          return (oe2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function re2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = ie2(o4);
            if (r4) {
              var n4 = ie2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === ee2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function ie2(t3) {
          return (ie2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        te2.propTypes = { expanded: y2.a.bool, doExpand: y2.a.func, doCollapse: y2.a.func, onExpandEvent: y2.a.func, config: y2.a.object, onChange: y2.a.func, currentState: y2.a.object, translations: y2.a.object, indentDisabled: y2.a.bool, outdentDisabled: y2.a.bool };
        var ce2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && oe2(t4, e4);
          })(c4, f2["Component"]);
          var t3, e3, r4 = re2(c4);
          function c4(t4) {
            var i3;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, c4), (i3 = r4.call(this, t4)).onExpandEvent = function() {
              i3.signalExpanded = !i3.state.expanded;
            }, i3.onChange = function(t5) {
              "unordered" === t5 ? i3.toggleBlockType("unordered-list-item") : "ordered" === t5 ? i3.toggleBlockType("ordered-list-item") : "indent" === t5 ? i3.adjustDepth(1) : i3.adjustDepth(-1);
            }, i3.expandCollapse = function() {
              i3.setState({ expanded: i3.signalExpanded }), i3.signalExpanded = false;
            }, i3.doExpand = function() {
              i3.setState({ expanded: true });
            }, i3.doCollapse = function() {
              i3.setState({ expanded: false });
            }, i3.toggleBlockType = function(t5) {
              var e5 = i3.props, n5 = e5.onChange, o5 = e5.editorState, r5 = E2.RichUtils.toggleBlockType(o5, t5);
              r5 && n5(r5);
            }, i3.adjustDepth = function(t5) {
              var e5 = i3.props, n5 = e5.onChange, o5 = e5.editorState, r5 = Object(S2.changeDepth)(o5, t5, 4);
              r5 && n5(r5);
            }, i3.isIndentDisabled = function() {
              var t5 = i3.props.editorState, e5 = i3.state.currentBlock, n5 = Object(S2.getBlockBeforeSelectedBlock)(t5);
              return !n5 || !Object(S2.isListBlock)(e5) || n5.get("type") !== e5.get("type") || n5.get("depth") < e5.get("depth");
            }, i3.isOutdentDisabled = function() {
              var t5 = i3.state.currentBlock;
              return !t5 || !Object(S2.isListBlock)(t5) || t5.get("depth") <= 0;
            };
            var e4 = i3.props, n4 = e4.editorState, o4 = e4.modalHandler;
            return i3.state = { expanded: false, currentBlock: n4 ? Object(S2.getSelectedBlock)(n4) : void 0 }, o4.registerCallBack(i3.expandCollapse), i3;
          }
          return t3 = c4, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props.editorState;
            e4 && e4 !== t4.editorState && this.setState({ currentBlock: Object(S2.getSelectedBlock)(e4) });
          } }, { key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4, e4 = this.props, n4 = e4.config, o4 = e4.translations, r5 = this.state, i3 = r5.expanded, c5 = r5.currentBlock, a4 = n4.component || te2;
            "unordered-list-item" === c5.get("type") ? t4 = "unordered" : "ordered-list-item" === c5.get("type") && (t4 = "ordered");
            var l2 = this.isIndentDisabled(), s3 = this.isOutdentDisabled();
            return N2.a.createElement(a4, { config: n4, translations: o4, currentState: { listType: t4 }, expanded: i3, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse, onChange: this.onChange, indentDisabled: l2, outdentDisabled: s3 });
          } }]) && ne2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), c4;
        })();
        ce2.propTypes = { onChange: y2.a.func.isRequired, editorState: y2.a.object.isRequired, modalHandler: y2.a.object, config: y2.a.object, translations: y2.a.object };
        n3(19);
        function ae2(t3) {
          return (ae2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function le2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function se2(t3, e3) {
          return (se2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function ue2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = pe2(o4);
            if (r4) {
              var n4 = pe2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === ae2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function pe2(t3) {
          return (pe2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var de = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && se2(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = ue2(r4);
          function r4() {
            return (function(t4, e4) {
              if (!(t4 instanceof e4)) throw new TypeError("Cannot call a class as a function");
            })(this, r4), o4.apply(this, arguments);
          }
          return t3 = r4, (e3 = [{ key: "renderInFlatList", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = e4.options, o5 = e4.left, r5 = e4.center, i3 = e4.right, c4 = e4.justify, a4 = e4.className, l2 = t4.onChange, s3 = t4.currentState.textAlignment, u3 = t4.translations;
            return N2.a.createElement("div", { className: w2()("rdw-text-align-wrapper", a4), "aria-label": "rdw-textalign-control" }, 0 <= n4.indexOf("left") && N2.a.createElement(R, { value: "left", className: w2()(o5.className), active: "left" === s3, onClick: l2, title: o5.title || u3["components.controls.textalign.left"] }, N2.a.createElement("img", { src: o5.icon, alt: "" })), 0 <= n4.indexOf("center") && N2.a.createElement(R, { value: "center", className: w2()(r5.className), active: "center" === s3, onClick: l2, title: r5.title || u3["components.controls.textalign.center"] }, N2.a.createElement("img", { src: r5.icon, alt: "" })), 0 <= n4.indexOf("right") && N2.a.createElement(R, { value: "right", className: w2()(i3.className), active: "right" === s3, onClick: l2, title: i3.title || u3["components.controls.textalign.right"] }, N2.a.createElement("img", { src: i3.icon, alt: "" })), 0 <= n4.indexOf("justify") && N2.a.createElement(R, { value: "justify", className: w2()(c4.className), active: "justify" === s3, onClick: l2, title: c4.title || u3["components.controls.textalign.justify"] }, N2.a.createElement("img", { src: c4.icon, alt: "" })));
          } }, { key: "renderInDropDown", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.expanded, o5 = t4.doExpand, r5 = t4.onExpandEvent, i3 = t4.doCollapse, c4 = t4.currentState.textAlignment, a4 = t4.onChange, l2 = t4.translations, s3 = e4.options, u3 = e4.left, p3 = e4.center, d3 = e4.right, f3 = e4.justify, y3 = e4.className, m3 = e4.dropdownClassName, g3 = e4.title;
            return N2.a.createElement(H2, { className: w2()("rdw-text-align-dropdown", y3), optionWrapperClassName: w2()(m3), onChange: a4, expanded: n4, doExpand: o5, doCollapse: i3, onExpandEvent: r5, "aria-label": "rdw-textalign-control", title: g3 || l2["components.controls.textalign.textalign"] }, N2.a.createElement("img", { src: c4 && e4[c4] && e4[c4].icon || v2(e4), alt: "" }), 0 <= s3.indexOf("left") && N2.a.createElement(K2, { value: "left", active: "left" === c4, className: w2()("rdw-text-align-dropdownOption", u3.className), title: u3.title || l2["components.controls.textalign.left"] }, N2.a.createElement("img", { src: u3.icon, alt: "" })), 0 <= s3.indexOf("center") && N2.a.createElement(K2, { value: "center", active: "center" === c4, className: w2()("rdw-text-align-dropdownOption", p3.className), title: p3.title || l2["components.controls.textalign.center"] }, N2.a.createElement("img", { src: p3.icon, alt: "" })), 0 <= s3.indexOf("right") && N2.a.createElement(K2, { value: "right", active: "right" === c4, className: w2()("rdw-text-align-dropdownOption", d3.className), title: d3.title || l2["components.controls.textalign.right"] }, N2.a.createElement("img", { src: d3.icon, alt: "" })), 0 <= s3.indexOf("justify") && N2.a.createElement(K2, { value: "justify", active: "justify" === c4, className: w2()("rdw-text-align-dropdownOption", f3.className), title: f3.title || l2["components.controls.textalign.justify"] }, N2.a.createElement("img", { src: f3.icon, alt: "" })));
          } }, { key: "render", value: function() {
            return this.props.config.inDropdown ? this.renderInDropDown() : this.renderInFlatList();
          } }]) && le2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        function fe(t3) {
          return (fe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function ye2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function me(t3, e3) {
          return (me = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function ge2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = be2(o4);
            if (r4) {
              var n4 = be2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === fe(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function be2(t3) {
          return (be2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        de.propTypes = { expanded: y2.a.bool, doExpand: y2.a.func, doCollapse: y2.a.func, onExpandEvent: y2.a.func, config: y2.a.object, onChange: y2.a.func, currentState: y2.a.object, translations: y2.a.object };
        var he2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && me(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, o4 = ge2(i3);
          function i3(t4) {
            var r4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3), (r4 = o4.call(this, t4)).onExpandEvent = function() {
              r4.signalExpanded = !r4.state.expanded;
            }, r4.expandCollapse = function() {
              r4.setState({ expanded: r4.signalExpanded }), r4.signalExpanded = false;
            }, r4.doExpand = function() {
              r4.setState({ expanded: true });
            }, r4.doCollapse = function() {
              r4.setState({ expanded: false });
            }, r4.addBlockAlignmentData = function(t5) {
              var e5 = r4.props, n4 = e5.editorState, o5 = e5.onChange;
              o5(r4.state.currentTextAlignment !== t5 ? Object(S2.setBlockData)(n4, { "text-align": t5 }) : Object(S2.setBlockData)(n4, { "text-align": void 0 }));
            };
            var e4 = r4.props.modalHandler;
            return r4.state = { currentTextAlignment: void 0 }, e4.registerCallBack(r4.expandCollapse), r4;
          }
          return t3 = i3, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props.editorState;
            e4 !== t4.editorState && this.setState({ currentTextAlignment: Object(S2.getSelectedBlocksMetadata)(e4).get("text-align") });
          } }, { key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.translations, o5 = this.state, r4 = o5.expanded, i4 = o5.currentTextAlignment, c4 = e4.component || de;
            return N2.a.createElement(c4, { config: e4, translations: n4, expanded: r4, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse, currentState: { textAlignment: i4 }, onChange: this.addBlockAlignmentData });
          } }]) && ye2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        he2.propTypes = { editorState: y2.a.object.isRequired, onChange: y2.a.func.isRequired, modalHandler: y2.a.object, config: y2.a.object, translations: y2.a.object };
        n3(20);
        function Me2(t3) {
          return (Me2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function je2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function ve2(t3, e3) {
          return (ve2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Ne2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Ee2(o4);
            if (r4) {
              var n4 = Ee2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === Me2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Ee2(t3) {
          return (Ee2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var Se2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && ve2(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = Ne2(r4);
          function r4() {
            var u3;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, r4);
            for (var t4 = arguments.length, e4 = new Array(t4), n4 = 0; n4 < t4; n4++) e4[n4] = arguments[n4];
            return (u3 = o4.call.apply(o4, [this].concat(e4))).state = { currentStyle: "color" }, u3.onChange = function(t5) {
              (0, u3.props.onChange)(u3.state.currentStyle, t5);
            }, u3.setCurrentStyleColor = function() {
              u3.setState({ currentStyle: "color" });
            }, u3.setCurrentStyleBgcolor = function() {
              u3.setState({ currentStyle: "bgcolor" });
            }, u3.renderModal = function() {
              var t5 = u3.props, e5 = t5.config, n5 = e5.popupClassName, o5 = e5.colors, r5 = t5.currentState, i3 = r5.color, c4 = r5.bgColor, a4 = t5.translations, l2 = u3.state.currentStyle, s3 = "color" === l2 ? i3 : c4;
              return N2.a.createElement("div", { className: w2()("rdw-colorpicker-modal", n5), onClick: j2 }, N2.a.createElement("span", { className: "rdw-colorpicker-modal-header" }, N2.a.createElement("span", { className: w2()("rdw-colorpicker-modal-style-label", { "rdw-colorpicker-modal-style-label-active": "color" === l2 }), onClick: u3.setCurrentStyleColor }, a4["components.controls.colorpicker.text"]), N2.a.createElement("span", { className: w2()("rdw-colorpicker-modal-style-label", { "rdw-colorpicker-modal-style-label-active": "bgcolor" === l2 }), onClick: u3.setCurrentStyleBgcolor }, a4["components.controls.colorpicker.background"])), N2.a.createElement("span", { className: "rdw-colorpicker-modal-options" }, o5.map(function(t6, e6) {
                return N2.a.createElement(R, { value: t6, key: e6, className: "rdw-colorpicker-option", activeClassName: "rdw-colorpicker-option-active", active: s3 === t6, onClick: u3.onChange }, N2.a.createElement("span", { style: { backgroundColor: t6 }, className: "rdw-colorpicker-cube" }));
              })));
            }, u3;
          }
          return t3 = r4, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            this.props.expanded && !t4.expanded && this.setState({ currentStyle: "color" });
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = e4.icon, o5 = e4.className, r5 = e4.title, i3 = t4.expanded, c4 = t4.onExpandEvent, a4 = t4.translations;
            return N2.a.createElement("div", { className: "rdw-colorpicker-wrapper", "aria-haspopup": "true", "aria-expanded": i3, "aria-label": "rdw-color-picker", title: r5 || a4["components.controls.colorpicker.colorpicker"] }, N2.a.createElement(R, { onClick: c4, className: w2()(o5) }, N2.a.createElement("img", { src: n4, alt: "" })), i3 ? this.renderModal() : void 0);
          } }]) && je2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        Se2.propTypes = { expanded: y2.a.bool, onExpandEvent: y2.a.func, onChange: y2.a.func, config: y2.a.object, currentState: y2.a.object, translations: y2.a.object };
        var we2 = Se2;
        function Ce2(t3) {
          return (Ce2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function Le2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function De2(t3, e3) {
          return (De2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function ke2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Oe2(o4);
            if (r4) {
              var n4 = Oe2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === Ce2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Oe2(t3) {
          return (Oe2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var xe2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && De2(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, r4 = ke2(i3);
          function i3(t4) {
            var c4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3), (c4 = r4.call(this, t4)).state = { expanded: false, currentColor: void 0, currentBgColor: void 0 }, c4.onExpandEvent = function() {
              c4.signalExpanded = !c4.state.expanded;
            }, c4.expandCollapse = function() {
              c4.setState({ expanded: c4.signalExpanded }), c4.signalExpanded = false;
            }, c4.doExpand = function() {
              c4.setState({ expanded: true });
            }, c4.doCollapse = function() {
              c4.setState({ expanded: false });
            }, c4.toggleColor = function(t5, e5) {
              var n5 = c4.props, o5 = n5.editorState, r5 = n5.onChange, i4 = Object(S2.toggleCustomInlineStyle)(o5, t5, e5);
              i4 && r5(i4), c4.doCollapse();
            };
            var e4 = t4.editorState, n4 = t4.modalHandler, o4 = { expanded: false, currentColor: void 0, currentBgColor: void 0 };
            return e4 && (o4.currentColor = Object(S2.getSelectionCustomInlineStyle)(e4, ["COLOR"]).COLOR, o4.currentBgColor = Object(S2.getSelectionCustomInlineStyle)(e4, ["BGCOLOR"]).BGCOLOR), c4.state = o4, n4.registerCallBack(c4.expandCollapse), c4;
          }
          return t3 = i3, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props.editorState;
            e4 && e4 !== t4.editorState && this.setState({ currentColor: Object(S2.getSelectionCustomInlineStyle)(e4, ["COLOR"]).COLOR, currentBgColor: Object(S2.getSelectionCustomInlineStyle)(e4, ["BGCOLOR"]).BGCOLOR });
          } }, { key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.translations, o4 = this.state, r5 = o4.currentColor, i4 = o4.currentBgColor, c4 = o4.expanded, a4 = e4.component || we2, l2 = r5 && r5.substring(6), s3 = i4 && i4.substring(8);
            return N2.a.createElement(a4, { config: e4, translations: n4, onChange: this.toggleColor, expanded: c4, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse, currentState: { color: l2, bgColor: s3 } });
          } }]) && Le2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        xe2.propTypes = { onChange: y2.a.func.isRequired, editorState: y2.a.object.isRequired, modalHandler: y2.a.object, config: y2.a.object, translations: y2.a.object };
        var Ie2 = xe2, Te2 = n3(7), Ae2 = n3.n(Te2);
        n3(26);
        function ze2(t3) {
          return (ze2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function _e2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function Pe2(t3, e3) {
          return (Pe2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Re2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Ue2(o4);
            if (r4) {
              var n4 = Ue2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === ze2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Ue2(t3) {
          return (Ue2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var Be2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Pe2(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = Re2(r4);
          function r4() {
            var c4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, r4);
            for (var t4 = arguments.length, e4 = new Array(t4), n4 = 0; n4 < t4; n4++) e4[n4] = arguments[n4];
            return (c4 = o4.call.apply(o4, [this].concat(e4))).state = { showModal: false, linkTarget: "", linkTitle: "", linkTargetOption: c4.props.config.defaultTargetOption }, c4.removeLink = function() {
              (0, c4.props.onChange)("unlink");
            }, c4.addLink = function() {
              var t5 = c4.props.onChange, e5 = c4.state;
              t5("link", e5.linkTitle, e5.linkTarget, e5.linkTargetOption);
            }, c4.updateValue = function(t5) {
              var e5, n5, o5;
              c4.setState((e5 = {}, n5 = "".concat(t5.target.name), o5 = t5.target.value, n5 in e5 ? Object.defineProperty(e5, n5, { value: o5, enumerable: true, configurable: true, writable: true }) : e5[n5] = o5, e5));
            }, c4.updateTargetOption = function(t5) {
              c4.setState({ linkTargetOption: t5.target.checked ? "_blank" : "_self" });
            }, c4.hideModal = function() {
              c4.setState({ showModal: false });
            }, c4.signalExpandShowModal = function() {
              var t5 = c4.props, e5 = t5.onExpandEvent, n5 = t5.currentState, o5 = n5.link, r5 = n5.selectionText, i3 = c4.state.linkTargetOption;
              e5(), c4.setState({ showModal: true, linkTarget: o5 && o5.target || "", linkTargetOption: o5 && o5.targetOption || i3, linkTitle: o5 && o5.title || r5 });
            }, c4.forceExpandAndShowModal = function() {
              var t5 = c4.props, e5 = t5.doExpand, n5 = t5.currentState, o5 = n5.link, r5 = n5.selectionText, i3 = c4.state.linkTargetOption;
              e5(), c4.setState({ showModal: true, linkTarget: o5 && o5.target, linkTargetOption: o5 && o5.targetOption || i3, linkTitle: o5 && o5.title || r5 });
            }, c4;
          }
          return t3 = r4, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            t4.expanded && !this.props.expanded && this.setState({ showModal: false, linkTarget: "", linkTitle: "", linkTargetOption: this.props.config.defaultTargetOption });
          } }, { key: "renderAddLinkModal", value: function() {
            var t4 = this.props, e4 = t4.config.popupClassName, n4 = t4.doCollapse, o5 = t4.translations, r5 = this.state, i3 = r5.linkTitle, c4 = r5.linkTarget, a4 = r5.linkTargetOption;
            return N2.a.createElement("div", { className: w2()("rdw-link-modal", e4), onClick: j2 }, N2.a.createElement("label", { className: "rdw-link-modal-label", htmlFor: "linkTitle" }, o5["components.controls.link.linkTitle"]), N2.a.createElement("input", { id: "linkTitle", className: "rdw-link-modal-input", onChange: this.updateValue, onBlur: this.updateValue, name: "linkTitle", value: i3 }), N2.a.createElement("label", { className: "rdw-link-modal-label", htmlFor: "linkTarget" }, o5["components.controls.link.linkTarget"]), N2.a.createElement("input", { id: "linkTarget", className: "rdw-link-modal-input", onChange: this.updateValue, onBlur: this.updateValue, name: "linkTarget", value: c4 }), N2.a.createElement("label", { className: "rdw-link-modal-target-option", htmlFor: "openLinkInNewWindow" }, N2.a.createElement("input", { id: "openLinkInNewWindow", type: "checkbox", defaultChecked: "_blank" === a4, value: "_blank", onChange: this.updateTargetOption }), N2.a.createElement("span", null, o5["components.controls.link.linkTargetOption"])), N2.a.createElement("span", { className: "rdw-link-modal-buttonsection" }, N2.a.createElement("button", { className: "rdw-link-modal-btn", onClick: this.addLink, disabled: !c4 || !i3 }, o5["generic.add"]), N2.a.createElement("button", { className: "rdw-link-modal-btn", onClick: n4 }, o5["generic.cancel"])));
          } }, { key: "renderInFlatList", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = e4.options, o5 = e4.link, r5 = e4.unlink, i3 = e4.className, c4 = t4.currentState, a4 = t4.expanded, l2 = t4.translations, s3 = this.state.showModal;
            return N2.a.createElement("div", { className: w2()("rdw-link-wrapper", i3), "aria-label": "rdw-link-control" }, 0 <= n4.indexOf("link") && N2.a.createElement(R, { value: "unordered-list-item", className: w2()(o5.className), onClick: this.signalExpandShowModal, "aria-haspopup": "true", "aria-expanded": s3, title: o5.title || l2["components.controls.link.link"] }, N2.a.createElement("img", { src: o5.icon, alt: "" })), 0 <= n4.indexOf("unlink") && N2.a.createElement(R, { disabled: !c4.link, value: "ordered-list-item", className: w2()(r5.className), onClick: this.removeLink, title: r5.title || l2["components.controls.link.unlink"] }, N2.a.createElement("img", { src: r5.icon, alt: "" })), a4 && s3 ? this.renderAddLinkModal() : void 0);
          } }, { key: "renderInDropDown", value: function() {
            var t4 = this.props, e4 = t4.expanded, n4 = t4.onExpandEvent, o5 = t4.doCollapse, r5 = t4.doExpand, i3 = t4.onChange, c4 = t4.config, a4 = t4.currentState, l2 = t4.translations, s3 = c4.options, u3 = c4.link, p3 = c4.unlink, d3 = c4.className, f3 = c4.dropdownClassName, y3 = c4.title, m3 = this.state.showModal;
            return N2.a.createElement("div", { className: "rdw-link-wrapper", "aria-haspopup": "true", "aria-label": "rdw-link-control", "aria-expanded": e4, title: y3 }, N2.a.createElement(H2, { className: w2()("rdw-link-dropdown", d3), optionWrapperClassName: w2()(f3), onChange: i3, expanded: e4 && !m3, doExpand: r5, doCollapse: o5, onExpandEvent: n4 }, N2.a.createElement("img", { src: v2(c4), alt: "" }), 0 <= s3.indexOf("link") && N2.a.createElement(K2, { onClick: this.forceExpandAndShowModal, className: w2()("rdw-link-dropdownoption", u3.className), title: u3.title || l2["components.controls.link.link"] }, N2.a.createElement("img", { src: u3.icon, alt: "" })), 0 <= s3.indexOf("unlink") && N2.a.createElement(K2, { onClick: this.removeLink, disabled: !a4.link, className: w2()("rdw-link-dropdownoption", p3.className), title: p3.title || l2["components.controls.link.unlink"] }, N2.a.createElement("img", { src: p3.icon, alt: "" }))), e4 && m3 ? this.renderAddLinkModal() : void 0);
          } }, { key: "render", value: function() {
            return this.props.config.inDropdown ? this.renderInDropDown() : this.renderInFlatList();
          } }]) && _e2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        Be2.propTypes = { expanded: y2.a.bool, doExpand: y2.a.func, doCollapse: y2.a.func, onExpandEvent: y2.a.func, config: y2.a.object, onChange: y2.a.func, currentState: y2.a.object, translations: y2.a.object };
        var Fe2 = Be2;
        function Ye2(t3) {
          return (Ye2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function Qe2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function He(t3, e3) {
          return (He = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Ze2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = We2(o4);
            if (r4) {
              var n4 = We2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === Ye2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function We2(t3) {
          return (We2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        function Ge2(e3, t3) {
          var n4 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var o4 = Object.getOwnPropertySymbols(e3);
            t3 && (o4 = o4.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n4.push.apply(n4, o4);
          }
          return n4;
        }
        function Je2(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n4 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Ge2(Object(n4), true).forEach(function(t4) {
              Ve2(e3, t4, n4[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n4)) : Ge2(Object(n4)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n4, t4));
            });
          }
          return e3;
        }
        function Ve2(t3, e3, n4) {
          return e3 in t3 ? Object.defineProperty(t3, e3, { value: n4, enumerable: true, configurable: true, writable: true }) : t3[e3] = n4, t3;
        }
        function qe2(t3) {
          var e3 = Ke2.match(t3.target);
          return Je2(Je2({}, t3), {}, { target: e3 && e3[0] && e3[0].url || t3.target });
        }
        var Ke2 = Ae2()(), Xe2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && He(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, r4 = Ze2(i3);
          function i3(t4) {
            var d3;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3), (d3 = r4.call(this, t4)).onExpandEvent = function() {
              d3.signalExpanded = !d3.state.expanded;
            }, d3.onChange = function(t5, e5, n5, o5) {
              var r5 = d3.props.config.linkCallback;
              if ("link" === t5) {
                var i4 = (r5 || qe2)({ title: e5, target: n5, targetOption: o5 });
                d3.addLink(i4.title, i4.target, i4.targetOption);
              } else d3.removeLink();
            }, d3.getCurrentValues = function() {
              var t5 = d3.props.editorState, e5 = d3.state.currentEntity, n5 = t5.getCurrentContent(), o5 = {};
              if (e5 && "LINK" === n5.getEntity(e5).get("type")) {
                o5.link = {};
                var r5 = e5 && Object(S2.getEntityRange)(t5, e5);
                o5.link.target = e5 && n5.getEntity(e5).get("data").url, o5.link.targetOption = e5 && n5.getEntity(e5).get("data").targetOption, o5.link.title = r5 && r5.text;
              }
              return o5.selectionText = Object(S2.getSelectionText)(t5), o5;
            }, d3.doExpand = function() {
              d3.setState({ expanded: true });
            }, d3.expandCollapse = function() {
              d3.setState({ expanded: d3.signalExpanded }), d3.signalExpanded = false;
            }, d3.doCollapse = function() {
              d3.setState({ expanded: false });
            }, d3.removeLink = function() {
              var t5 = d3.props, e5 = t5.editorState, n5 = t5.onChange, o5 = d3.state.currentEntity, r5 = e5.getSelection();
              if (o5) {
                var i4 = Object(S2.getEntityRange)(e5, o5);
                r5 = r5.getIsBackward() ? r5.merge({ anchorOffset: i4.end, focusOffset: i4.start }) : r5.merge({ anchorOffset: i4.start, focusOffset: i4.end }), n5(E2.RichUtils.toggleLink(e5, r5, null));
              }
            }, d3.addLink = function(t5, e5, n5) {
              var o5 = d3.props, r5 = o5.editorState, i4 = o5.onChange, c4 = d3.state.currentEntity, a4 = r5.getSelection();
              if (c4) {
                var l2 = Object(S2.getEntityRange)(r5, c4);
                a4 = a4.getIsBackward() ? a4.merge({ anchorOffset: l2.end, focusOffset: l2.start }) : a4.merge({ anchorOffset: l2.start, focusOffset: l2.end });
              }
              var s3 = r5.getCurrentContent().createEntity("LINK", "MUTABLE", { url: e5, targetOption: n5 }).getLastCreatedEntityKey(), u3 = E2.Modifier.replaceText(r5.getCurrentContent(), a4, "".concat(t5), r5.getCurrentInlineStyle(), s3), p3 = E2.EditorState.push(r5, u3, "insert-characters");
              a4 = p3.getSelection().merge({ anchorOffset: a4.get("anchorOffset") + t5.length, focusOffset: a4.get("anchorOffset") + t5.length }), p3 = E2.EditorState.acceptSelection(p3, a4), u3 = E2.Modifier.insertText(p3.getCurrentContent(), a4, " ", p3.getCurrentInlineStyle(), void 0), i4(E2.EditorState.push(p3, u3, "insert-characters")), d3.doCollapse();
            };
            var e4 = d3.props, n4 = e4.editorState, o4 = e4.modalHandler;
            return d3.state = { expanded: false, link: void 0, selectionText: void 0, currentEntity: n4 ? Object(S2.getSelectionEntity)(n4) : void 0 }, o4.registerCallBack(d3.expandCollapse), d3;
          }
          return t3 = i3, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props.editorState;
            e4 && e4 !== t4.editorState && this.setState({ currentEntity: Object(S2.getSelectionEntity)(e4) });
          } }, { key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.translations, o4 = this.state.expanded, r5 = this.getCurrentValues(), i4 = r5.link, c4 = r5.selectionText, a4 = e4.component || Fe2;
            return N2.a.createElement(a4, { config: e4, translations: n4, expanded: o4, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse, currentState: { link: i4, selectionText: c4 }, onChange: this.onChange });
          } }]) && Qe2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        Xe2.propTypes = { editorState: y2.a.object.isRequired, onChange: y2.a.func.isRequired, modalHandler: y2.a.object, config: y2.a.object, translations: y2.a.object };
        var $e2 = Xe2;
        n3(27);
        function tn2(t3) {
          return (tn2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function en(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function nn(t3, e3) {
          return (nn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function on(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = rn(o4);
            if (r4) {
              var n4 = rn(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === tn2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function rn(t3) {
          return (rn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var cn = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && nn(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, o4 = on(i3);
          function i3() {
            var r4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3);
            for (var t4 = arguments.length, e4 = new Array(t4), n4 = 0; n4 < t4; n4++) e4[n4] = arguments[n4];
            return (r4 = o4.call.apply(o4, [this].concat(e4))).state = { embeddedLink: "", height: r4.props.config.defaultSize.height, width: r4.props.config.defaultSize.width }, r4.onChange = function() {
              var t5 = r4.props.onChange, e5 = r4.state;
              t5(e5.embeddedLink, e5.height, e5.width);
            }, r4.updateValue = function(t5) {
              var e5, n5, o5;
              r4.setState((e5 = {}, n5 = "".concat(t5.target.name), o5 = t5.target.value, n5 in e5 ? Object.defineProperty(e5, n5, { value: o5, enumerable: true, configurable: true, writable: true }) : e5[n5] = o5, e5));
            }, r4;
          }
          return t3 = i3, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props, n4 = e4.expanded, o5 = e4.config;
            if (!n4 && t4.expanded) {
              var r4 = o5.defaultSize, i4 = r4.height, c4 = r4.width;
              this.setState({ embeddedLink: "", height: i4, width: c4 });
            }
          } }, { key: "rendeEmbeddedLinkModal", value: function() {
            var t4 = this.state, e4 = t4.embeddedLink, n4 = t4.height, o5 = t4.width, r4 = this.props, i4 = r4.config.popupClassName, c4 = r4.doCollapse, a4 = r4.translations;
            return N2.a.createElement("div", { className: w2()("rdw-embedded-modal", i4), onClick: j2 }, N2.a.createElement("div", { className: "rdw-embedded-modal-header" }, N2.a.createElement("span", { className: "rdw-embedded-modal-header-option" }, a4["components.controls.embedded.embeddedlink"], N2.a.createElement("span", { className: "rdw-embedded-modal-header-label" }))), N2.a.createElement("div", { className: "rdw-embedded-modal-link-section" }, N2.a.createElement("span", { className: "rdw-embedded-modal-link-input-wrapper" }, N2.a.createElement("input", { className: "rdw-embedded-modal-link-input", placeholder: a4["components.controls.embedded.enterlink"], onChange: this.updateValue, onBlur: this.updateValue, value: e4, name: "embeddedLink" }), N2.a.createElement("span", { className: "rdw-image-mandatory-sign" }, "*")), N2.a.createElement("div", { className: "rdw-embedded-modal-size" }, N2.a.createElement("span", null, N2.a.createElement("input", { onChange: this.updateValue, onBlur: this.updateValue, value: n4, name: "height", className: "rdw-embedded-modal-size-input", placeholder: "Height" }), N2.a.createElement("span", { className: "rdw-image-mandatory-sign" }, "*")), N2.a.createElement("span", null, N2.a.createElement("input", { onChange: this.updateValue, onBlur: this.updateValue, value: o5, name: "width", className: "rdw-embedded-modal-size-input", placeholder: "Width" }), N2.a.createElement("span", { className: "rdw-image-mandatory-sign" }, "*")))), N2.a.createElement("span", { className: "rdw-embedded-modal-btn-section" }, N2.a.createElement("button", { type: "button", className: "rdw-embedded-modal-btn", onClick: this.onChange, disabled: !e4 || !n4 || !o5 }, a4["generic.add"]), N2.a.createElement("button", { type: "button", className: "rdw-embedded-modal-btn", onClick: c4 }, a4["generic.cancel"])));
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = e4.icon, o5 = e4.className, r4 = e4.title, i4 = t4.expanded, c4 = t4.onExpandEvent, a4 = t4.translations;
            return N2.a.createElement("div", { className: "rdw-embedded-wrapper", "aria-haspopup": "true", "aria-expanded": i4, "aria-label": "rdw-embedded-control" }, N2.a.createElement(R, { className: w2()(o5), value: "unordered-list-item", onClick: c4, title: r4 || a4["components.controls.embedded.embedded"] }, N2.a.createElement("img", { src: n4, alt: "" })), i4 ? this.rendeEmbeddedLinkModal() : void 0);
          } }]) && en(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        cn.propTypes = { expanded: y2.a.bool, onExpandEvent: y2.a.func, onChange: y2.a.func, config: y2.a.object, translations: y2.a.object, doCollapse: y2.a.func };
        var an2 = cn;
        function ln(t3) {
          return (ln = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function sn(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function un2(t3, e3) {
          return (un2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function pn2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = dn2(o4);
            if (r4) {
              var n4 = dn2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === ln(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function dn2(t3) {
          return (dn2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var fn2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && un2(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = pn2(r4);
          function r4() {
            var s3;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, r4);
            for (var t4 = arguments.length, e4 = new Array(t4), n4 = 0; n4 < t4; n4++) e4[n4] = arguments[n4];
            return (s3 = o4.call.apply(o4, [this].concat(e4))).state = { expanded: false }, s3.onExpandEvent = function() {
              s3.signalExpanded = !s3.state.expanded;
            }, s3.expandCollapse = function() {
              s3.setState({ expanded: s3.signalExpanded }), s3.signalExpanded = false;
            }, s3.doExpand = function() {
              s3.setState({ expanded: true });
            }, s3.doCollapse = function() {
              s3.setState({ expanded: false });
            }, s3.addEmbeddedLink = function(t5, e5, n5) {
              var o5 = s3.props, r5 = o5.editorState, i3 = o5.onChange, c4 = o5.config.embedCallback, a4 = c4 ? c4(t5) : t5, l2 = r5.getCurrentContent().createEntity("EMBEDDED_LINK", "MUTABLE", { src: a4, height: e5, width: n5 }).getLastCreatedEntityKey();
              i3(E2.AtomicBlockUtils.insertAtomicBlock(r5, l2, " ")), s3.doCollapse();
            }, s3;
          }
          return t3 = r4, (e3 = [{ key: "componentDidMount", value: function() {
            this.props.modalHandler.registerCallBack(this.expandCollapse);
          } }, { key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.translations, o5 = this.state.expanded, r5 = e4.component || an2;
            return N2.a.createElement(r5, { config: e4, translations: n4, onChange: this.addEmbeddedLink, expanded: o5, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse });
          } }]) && sn(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        fn2.propTypes = { editorState: y2.a.object.isRequired, onChange: y2.a.func.isRequired, modalHandler: y2.a.object, config: y2.a.object, translations: y2.a.object };
        var yn2 = fn2;
        n3(28);
        function mn2(t3) {
          return (mn2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function gn2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function bn2(t3, e3) {
          return (bn2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function hn2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Mn2(o4);
            if (r4) {
              var n4 = Mn2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === mn2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Mn2(t3) {
          return (Mn2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var jn2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && bn2(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, r4 = hn2(i3);
          function i3() {
            var e4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3);
            for (var t4 = arguments.length, n4 = new Array(t4), o4 = 0; o4 < t4; o4++) n4[o4] = arguments[o4];
            return (e4 = r4.call.apply(r4, [this].concat(n4))).onChange = function(t5) {
              (0, e4.props.onChange)(t5.target.innerHTML);
            }, e4;
          }
          return t3 = i3, (e3 = [{ key: "renderEmojiModal", value: function() {
            var n4 = this, t4 = this.props.config, e4 = t4.popupClassName, o4 = t4.emojis;
            return N2.a.createElement("div", { className: w2()("rdw-emoji-modal", e4), onClick: j2 }, o4.map(function(t5, e5) {
              return N2.a.createElement("span", { key: e5, className: "rdw-emoji-icon", alt: "", onClick: n4.onChange }, t5);
            }));
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = e4.icon, o4 = e4.className, r5 = e4.title, i4 = t4.expanded, c4 = t4.onExpandEvent, a4 = t4.translations;
            return N2.a.createElement("div", { className: "rdw-emoji-wrapper", "aria-haspopup": "true", "aria-label": "rdw-emoji-control", "aria-expanded": i4, title: r5 || a4["components.controls.emoji.emoji"] }, N2.a.createElement(R, { className: w2()(o4), value: "unordered-list-item", onClick: c4 }, N2.a.createElement("img", { src: n4, alt: "" })), i4 ? this.renderEmojiModal() : void 0);
          } }]) && gn2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        jn2.propTypes = { expanded: y2.a.bool, onExpandEvent: y2.a.func, onChange: y2.a.func, config: y2.a.object, translations: y2.a.object };
        var vn = jn2;
        function Nn2(t3) {
          return (Nn2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function En2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function Sn2(t3, e3) {
          return (Sn2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function wn(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Cn2(o4);
            if (r4) {
              var n4 = Cn2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === Nn2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Cn2(t3) {
          return (Cn2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var Ln2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Sn2(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = wn(r4);
          function r4() {
            var i3;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, r4);
            for (var t4 = arguments.length, e4 = new Array(t4), n4 = 0; n4 < t4; n4++) e4[n4] = arguments[n4];
            return (i3 = o4.call.apply(o4, [this].concat(e4))).state = { expanded: false }, i3.onExpandEvent = function() {
              i3.signalExpanded = !i3.state.expanded;
            }, i3.expandCollapse = function() {
              i3.setState({ expanded: i3.signalExpanded }), i3.signalExpanded = false;
            }, i3.doExpand = function() {
              i3.setState({ expanded: true });
            }, i3.doCollapse = function() {
              i3.setState({ expanded: false });
            }, i3.addEmoji = function(t5) {
              var e5 = i3.props, n5 = e5.editorState, o5 = e5.onChange, r5 = E2.Modifier.replaceText(n5.getCurrentContent(), n5.getSelection(), t5, n5.getCurrentInlineStyle());
              o5(E2.EditorState.push(n5, r5, "insert-characters")), i3.doCollapse();
            }, i3;
          }
          return t3 = r4, (e3 = [{ key: "componentDidMount", value: function() {
            this.props.modalHandler.registerCallBack(this.expandCollapse);
          } }, { key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.translations, o5 = this.state.expanded, r5 = e4.component || vn;
            return N2.a.createElement(r5, { config: e4, translations: n4, onChange: this.addEmoji, expanded: o5, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse, onCollpase: this.closeModal });
          } }]) && En2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        Ln2.propTypes = { editorState: y2.a.object.isRequired, onChange: y2.a.func.isRequired, modalHandler: y2.a.object, config: y2.a.object, translations: y2.a.object };
        function Dn2() {
          return N2.a.createElement("div", { className: "rdw-spinner" }, N2.a.createElement("div", { className: "rdw-bounce1" }), N2.a.createElement("div", { className: "rdw-bounce2" }), N2.a.createElement("div", { className: "rdw-bounce3" }));
        }
        n3(29), n3(30);
        function kn2(t3) {
          return (kn2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function On2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function xn2(t3, e3) {
          return (xn2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function In2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Tn2(o4);
            if (r4) {
              var n4 = Tn2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === kn2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Tn2(t3) {
          return (Tn2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var An2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && xn2(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = In2(r4);
          function r4() {
            var a4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, r4);
            for (var t4 = arguments.length, e4 = new Array(t4), n4 = 0; n4 < t4; n4++) e4[n4] = arguments[n4];
            return (a4 = o4.call.apply(o4, [this].concat(e4))).state = { imgSrc: "", dragEnter: false, uploadHighlighted: a4.props.config.uploadEnabled && !!a4.props.config.uploadCallback, showImageLoading: false, height: a4.props.config.defaultSize.height, width: a4.props.config.defaultSize.width, alt: "" }, a4.onDragEnter = function(t5) {
              a4.stopPropagation(t5), a4.setState({ dragEnter: true });
            }, a4.onImageDrop = function(t5) {
              var e5, n5;
              t5.preventDefault(), t5.stopPropagation(), a4.setState({ dragEnter: false }), n5 = t5.dataTransfer.items ? (e5 = t5.dataTransfer.items, true) : (e5 = t5.dataTransfer.files, false);
              for (var o5 = 0; o5 < e5.length; o5 += 1) if ((!n5 || "file" === e5[o5].kind) && e5[o5].type.match("^image/")) {
                var r5 = n5 ? e5[o5].getAsFile() : e5[o5];
                a4.uploadImage(r5);
              }
            }, a4.showImageUploadOption = function() {
              a4.setState({ uploadHighlighted: true });
            }, a4.addImageFromState = function() {
              var t5 = a4.state, e5 = t5.imgSrc, n5 = t5.alt, o5 = a4.state, r5 = o5.height, i3 = o5.width, c4 = a4.props.onChange;
              isNaN(r5) || (r5 += "px"), isNaN(i3) || (i3 += "px"), c4(e5, r5, i3, n5);
            }, a4.showImageURLOption = function() {
              a4.setState({ uploadHighlighted: false });
            }, a4.toggleShowImageLoading = function() {
              var t5 = !a4.state.showImageLoading;
              a4.setState({ showImageLoading: t5 });
            }, a4.updateValue = function(t5) {
              var e5, n5, o5;
              a4.setState((e5 = {}, n5 = "".concat(t5.target.name), o5 = t5.target.value, n5 in e5 ? Object.defineProperty(e5, n5, { value: o5, enumerable: true, configurable: true, writable: true }) : e5[n5] = o5, e5));
            }, a4.selectImage = function(t5) {
              t5.target.files && 0 < t5.target.files.length && a4.uploadImage(t5.target.files[0]);
            }, a4.uploadImage = function(t5) {
              a4.toggleShowImageLoading(), (0, a4.props.config.uploadCallback)(t5).then(function(t6) {
                var e5 = t6.data;
                a4.setState({ showImageLoading: false, dragEnter: false, imgSrc: e5.link || e5.url }), a4.fileUpload = false;
              }).catch(function() {
                a4.setState({ showImageLoading: false, dragEnter: false });
              });
            }, a4.fileUploadClick = function(t5) {
              a4.fileUpload = true, t5.stopPropagation();
            }, a4.stopPropagation = function(t5) {
              a4.fileUpload ? a4.fileUpload = false : (t5.preventDefault(), t5.stopPropagation());
            }, a4;
          }
          return t3 = r4, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props.config;
            t4.expanded && !this.props.expanded ? this.setState({ imgSrc: "", dragEnter: false, uploadHighlighted: e4.uploadEnabled && !!e4.uploadCallback, showImageLoading: false, height: e4.defaultSize.height, width: e4.defaultSize.width, alt: "" }) : e4.uploadCallback === t4.config.uploadCallback && e4.uploadEnabled === t4.config.uploadEnabled || this.setState({ uploadHighlighted: e4.uploadEnabled && !!e4.uploadCallback });
          } }, { key: "renderAddImageModal", value: function() {
            var t4 = this.state, e4 = t4.imgSrc, n4 = t4.uploadHighlighted, o5 = t4.showImageLoading, r5 = t4.dragEnter, i3 = t4.height, c4 = t4.width, a4 = t4.alt, l2 = this.props, s3 = l2.config, u3 = s3.popupClassName, p3 = s3.uploadCallback, d3 = s3.uploadEnabled, f3 = s3.urlEnabled, y3 = s3.previewImage, m3 = s3.inputAccept, g3 = s3.alt, b3 = l2.doCollapse, h3 = l2.translations;
            return N2.a.createElement("div", { className: w2()("rdw-image-modal", u3), onClick: this.stopPropagation }, N2.a.createElement("div", { className: "rdw-image-modal-header" }, d3 && p3 && N2.a.createElement("span", { onClick: this.showImageUploadOption, className: "rdw-image-modal-header-option" }, h3["components.controls.image.fileUpload"], N2.a.createElement("span", { className: w2()("rdw-image-modal-header-label", { "rdw-image-modal-header-label-highlighted": n4 }) })), f3 && N2.a.createElement("span", { onClick: this.showImageURLOption, className: "rdw-image-modal-header-option" }, h3["components.controls.image.byURL"], N2.a.createElement("span", { className: w2()("rdw-image-modal-header-label", { "rdw-image-modal-header-label-highlighted": !n4 }) }))), n4 ? N2.a.createElement("div", { onClick: this.fileUploadClick }, N2.a.createElement("div", { onDragEnter: this.onDragEnter, onDragOver: this.stopPropagation, onDrop: this.onImageDrop, className: w2()("rdw-image-modal-upload-option", { "rdw-image-modal-upload-option-highlighted": r5 }) }, N2.a.createElement("label", { htmlFor: "file", className: "rdw-image-modal-upload-option-label" }, y3 && e4 ? N2.a.createElement("img", { src: e4, alt: e4, className: "rdw-image-modal-upload-option-image-preview" }) : e4 || h3["components.controls.image.dropFileText"])), N2.a.createElement("input", { type: "file", id: "file", accept: m3, onChange: this.selectImage, className: "rdw-image-modal-upload-option-input" })) : N2.a.createElement("div", { className: "rdw-image-modal-url-section" }, N2.a.createElement("input", { className: "rdw-image-modal-url-input", placeholder: h3["components.controls.image.enterlink"], name: "imgSrc", onChange: this.updateValue, onBlur: this.updateValue, value: e4 }), N2.a.createElement("span", { className: "rdw-image-mandatory-sign" }, "*")), g3.present && N2.a.createElement("div", { className: "rdw-image-modal-size" }, N2.a.createElement("span", { className: "rdw-image-modal-alt-lbl" }, "Alt Text"), N2.a.createElement("input", { onChange: this.updateValue, onBlur: this.updateValue, value: a4, name: "alt", className: "rdw-image-modal-alt-input", placeholder: "alt" }), N2.a.createElement("span", { className: "rdw-image-mandatory-sign" }, g3.mandatory && "*")), N2.a.createElement("div", { className: "rdw-image-modal-size" }, "", N2.a.createElement("input", { onChange: this.updateValue, onBlur: this.updateValue, value: i3, name: "height", className: "rdw-image-modal-size-input", placeholder: "Height" }), N2.a.createElement("span", { className: "rdw-image-mandatory-sign" }, "*"), "", N2.a.createElement("input", { onChange: this.updateValue, onBlur: this.updateValue, value: c4, name: "width", className: "rdw-image-modal-size-input", placeholder: "Width" }), N2.a.createElement("span", { className: "rdw-image-mandatory-sign" }, "*")), N2.a.createElement("span", { className: "rdw-image-modal-btn-section" }, N2.a.createElement("button", { className: "rdw-image-modal-btn", onClick: this.addImageFromState, disabled: !e4 || !i3 || !c4 || g3.mandatory && !a4 }, h3["generic.add"]), N2.a.createElement("button", { className: "rdw-image-modal-btn", onClick: b3 }, h3["generic.cancel"])), o5 ? N2.a.createElement("div", { className: "rdw-image-modal-spinner" }, N2.a.createElement(Dn2, null)) : void 0);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = e4.icon, o5 = e4.className, r5 = e4.title, i3 = t4.expanded, c4 = t4.onExpandEvent, a4 = t4.translations;
            return N2.a.createElement("div", { className: "rdw-image-wrapper", "aria-haspopup": "true", "aria-expanded": i3, "aria-label": "rdw-image-control" }, N2.a.createElement(R, { className: w2()(o5), value: "unordered-list-item", onClick: c4, title: r5 || a4["components.controls.image.image"] }, N2.a.createElement("img", { src: n4, alt: "" })), i3 ? this.renderAddImageModal() : void 0);
          } }]) && On2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        An2.propTypes = { expanded: y2.a.bool, onExpandEvent: y2.a.func, doCollapse: y2.a.func, onChange: y2.a.func, config: y2.a.object, translations: y2.a.object };
        var zn2 = An2;
        function _n2(t3) {
          return (_n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function Pn2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function Rn2(t3, e3) {
          return (Rn2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Un2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Bn2(o4);
            if (r4) {
              var n4 = Bn2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === _n2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Bn2(t3) {
          return (Bn2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var Fn2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Rn2(t4, e4);
          })(r4, f2["Component"]);
          var t3, e3, o4 = Un2(r4);
          function r4(t4) {
            var s3;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, r4), (s3 = o4.call(this, t4)).onExpandEvent = function() {
              s3.signalExpanded = !s3.state.expanded;
            }, s3.doExpand = function() {
              s3.setState({ expanded: true });
            }, s3.doCollapse = function() {
              s3.setState({ expanded: false });
            }, s3.expandCollapse = function() {
              s3.setState({ expanded: s3.signalExpanded }), s3.signalExpanded = false;
            }, s3.addImage = function(t5, e5, n4, o5) {
              var r5 = s3.props, i3 = r5.editorState, c4 = r5.onChange, a4 = { src: t5, height: e5, width: n4 };
              r5.config.alt.present && (a4.alt = o5);
              var l2 = i3.getCurrentContent().createEntity("IMAGE", "MUTABLE", a4).getLastCreatedEntityKey();
              c4(E2.AtomicBlockUtils.insertAtomicBlock(i3, l2, " ")), s3.doCollapse();
            };
            var e4 = s3.props.modalHandler;
            return s3.state = { expanded: false }, e4.registerCallBack(s3.expandCollapse), s3;
          }
          return t3 = r4, (e3 = [{ key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.translations, o5 = this.state.expanded, r5 = e4.component || zn2;
            return N2.a.createElement(r5, { config: e4, translations: n4, onChange: this.addImage, expanded: o5, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse });
          } }]) && Pn2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), r4;
        })();
        Fn2.propTypes = { editorState: y2.a.object.isRequired, onChange: y2.a.func.isRequired, modalHandler: y2.a.object, config: y2.a.object, translations: y2.a.object };
        function Yn2(t3) {
          var e3 = t3.config, n4 = t3.onChange, o4 = t3.translations, r4 = e3.icon, i3 = e3.className, c4 = e3.title;
          return N2.a.createElement("div", { className: "rdw-remove-wrapper", "aria-label": "rdw-remove-control" }, N2.a.createElement(R, { className: w2()(i3), onClick: n4, title: c4 || o4["components.controls.remove.remove"] }, N2.a.createElement("img", { src: r4, alt: "" })));
        }
        var Qn2 = Fn2;
        n3(31);
        Yn2.propTypes = { onChange: y2.a.func, config: y2.a.object, translations: y2.a.object };
        var Hn2 = Yn2;
        function Zn2(t3) {
          return (Zn2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function Wn2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function Gn2(t3, e3) {
          return (Gn2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Jn2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Vn2(o4);
            if (r4) {
              var n4 = Vn2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === Zn2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Vn2(t3) {
          return (Vn2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var qn2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Gn2(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, r4 = Jn2(i3);
          function i3() {
            var n4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3);
            for (var t4 = arguments.length, e4 = new Array(t4), o4 = 0; o4 < t4; o4++) e4[o4] = arguments[o4];
            return (n4 = r4.call.apply(r4, [this].concat(e4))).state = { expanded: false }, n4.onExpandEvent = function() {
              n4.signalExpanded = !n4.state.expanded;
            }, n4.expandCollapse = function() {
              n4.setState({ expanded: n4.signalExpanded }), n4.signalExpanded = false;
            }, n4.removeInlineStyles = function() {
              var t5 = n4.props, e5 = t5.editorState;
              (0, t5.onChange)(n4.removeAllInlineStyles(e5));
            }, n4.removeAllInlineStyles = function(n5) {
              var o5 = n5.getCurrentContent();
              return ["BOLD", "ITALIC", "UNDERLINE", "STRIKETHROUGH", "MONOSPACE", "SUPERSCRIPT", "SUBSCRIPT"].forEach(function(t5) {
                o5 = E2.Modifier.removeInlineStyle(o5, n5.getSelection(), t5);
              }), h2(Object(S2.getSelectionCustomInlineStyle)(n5, ["FONTSIZE", "FONTFAMILY", "COLOR", "BGCOLOR"]), function(t5, e5) {
                e5 && (o5 = E2.Modifier.removeInlineStyle(o5, n5.getSelection(), e5));
              }), E2.EditorState.push(n5, o5, "change-inline-style");
            }, n4.doExpand = function() {
              n4.setState({ expanded: true });
            }, n4.doCollapse = function() {
              n4.setState({ expanded: false });
            }, n4;
          }
          return t3 = i3, (e3 = [{ key: "componentDidMount", value: function() {
            this.props.modalHandler.registerCallBack(this.expandCollapse);
          } }, { key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.translations, o4 = this.state.expanded, r5 = e4.component || Hn2;
            return N2.a.createElement(r5, { config: e4, translations: n4, expanded: o4, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse, onChange: this.removeInlineStyles });
          } }]) && Wn2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        qn2.propTypes = { onChange: y2.a.func.isRequired, editorState: y2.a.object.isRequired, config: y2.a.object, translations: y2.a.object, modalHandler: y2.a.object };
        n3(32);
        function Kn2(t3) {
          return (Kn2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function Xn2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function $n2(t3, e3) {
          return ($n2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function to2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = eo2(o4);
            if (r4) {
              var n4 = eo2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === Kn2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function eo2(t3) {
          return (eo2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var no2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && $n2(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, r4 = to2(i3);
          function i3() {
            var e4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3);
            for (var t4 = arguments.length, n4 = new Array(t4), o4 = 0; o4 < t4; o4++) n4[o4] = arguments[o4];
            return (e4 = r4.call.apply(r4, [this].concat(n4))).onChange = function(t5) {
              (0, e4.props.onChange)(t5);
            }, e4;
          }
          return t3 = i3, (e3 = [{ key: "renderInDropDown", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.expanded, o4 = t4.doExpand, r5 = t4.onExpandEvent, i4 = t4.doCollapse, c4 = t4.currentState, a4 = c4.undoDisabled, l2 = c4.redoDisabled, s3 = t4.translations, u3 = e4.options, p3 = e4.undo, d3 = e4.redo, f3 = e4.className, y3 = e4.dropdownClassName, m3 = e4.title;
            return N2.a.createElement(H2, { className: w2()("rdw-history-dropdown", f3), optionWrapperClassName: w2()(y3), expanded: n4, doExpand: o4, doCollapse: i4, onExpandEvent: r5, "aria-label": "rdw-history-control", title: m3 || s3["components.controls.history.history"] }, N2.a.createElement("img", { src: v2(e4), alt: "" }), 0 <= u3.indexOf("undo") && N2.a.createElement(K2, { value: "undo", onClick: this.onChange, disabled: a4, className: w2()("rdw-history-dropdownoption", p3.className), title: p3.title || s3["components.controls.history.undo"] }, N2.a.createElement("img", { src: p3.icon, alt: "" })), 0 <= u3.indexOf("redo") && N2.a.createElement(K2, { value: "redo", onClick: this.onChange, disabled: l2, className: w2()("rdw-history-dropdownoption", d3.className), title: d3.title || s3["components.controls.history.redo"] }, N2.a.createElement("img", { src: d3.icon, alt: "" })));
          } }, { key: "renderInFlatList", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = e4.options, o4 = e4.undo, r5 = e4.redo, i4 = e4.className, c4 = t4.currentState, a4 = c4.undoDisabled, l2 = c4.redoDisabled, s3 = t4.translations;
            return N2.a.createElement("div", { className: w2()("rdw-history-wrapper", i4), "aria-label": "rdw-history-control" }, 0 <= n4.indexOf("undo") && N2.a.createElement(R, { value: "undo", onClick: this.onChange, className: w2()(o4.className), disabled: a4, title: o4.title || s3["components.controls.history.undo"] }, N2.a.createElement("img", { src: o4.icon, alt: "" })), 0 <= n4.indexOf("redo") && N2.a.createElement(R, { value: "redo", onClick: this.onChange, className: w2()(r5.className), disabled: l2, title: r5.title || s3["components.controls.history.redo"] }, N2.a.createElement("img", { src: r5.icon, alt: "" })));
          } }, { key: "render", value: function() {
            return this.props.config.inDropdown ? this.renderInDropDown() : this.renderInFlatList();
          } }]) && Xn2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        function oo2(t3) {
          return (oo2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function ro(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function io2(t3, e3) {
          return (io2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function co(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = ao2(o4);
            if (r4) {
              var n4 = ao2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === oo2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function ao2(t3) {
          return (ao2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        no2.propTypes = { expanded: y2.a.bool, doExpand: y2.a.func, doCollapse: y2.a.func, onExpandEvent: y2.a.func, config: y2.a.object, onChange: y2.a.func, currentState: y2.a.object, translations: y2.a.object };
        var lo = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && io2(t4, e4);
          })(c4, f2["Component"]);
          var t3, e3, r4 = co(c4);
          function c4(t4) {
            var i3;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, c4), (i3 = r4.call(this, t4)).onExpandEvent = function() {
              i3.signalExpanded = !i3.state.expanded;
            }, i3.onChange = function(t5) {
              var e5 = i3.props, n5 = e5.editorState, o5 = e5.onChange, r5 = E2.EditorState[t5](n5);
              r5 && o5(r5);
            }, i3.doExpand = function() {
              i3.setState({ expanded: true });
            }, i3.doCollapse = function() {
              i3.setState({ expanded: false });
            };
            var e4 = { expanded: !(i3.expandCollapse = function() {
              i3.setState({ expanded: i3.signalExpanded }), i3.signalExpanded = false;
            }), undoDisabled: false, redoDisabled: false }, n4 = t4.editorState, o4 = t4.modalHandler;
            return n4 && (e4.undoDisabled = 0 === n4.getUndoStack().size, e4.redoDisabled = 0 === n4.getRedoStack().size), i3.state = e4, o4.registerCallBack(i3.expandCollapse), i3;
          }
          return t3 = c4, (e3 = [{ key: "componentDidUpdate", value: function(t4) {
            var e4 = this.props.editorState;
            e4 && t4.editorState !== e4 && this.setState({ undoDisabled: 0 === e4.getUndoStack().size, redoDisabled: 0 === e4.getRedoStack().size });
          } }, { key: "componentWillUnmount", value: function() {
            this.props.modalHandler.deregisterCallBack(this.expandCollapse);
          } }, { key: "render", value: function() {
            var t4 = this.props, e4 = t4.config, n4 = t4.translations, o4 = this.state, r5 = o4.undoDisabled, i3 = o4.redoDisabled, c5 = o4.expanded, a4 = e4.component || no2;
            return N2.a.createElement(a4, { config: e4, translations: n4, currentState: { undoDisabled: r5, redoDisabled: i3 }, expanded: c5, onExpandEvent: this.onExpandEvent, doExpand: this.doExpand, doCollapse: this.doCollapse, onChange: this.onChange });
          } }]) && ro(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), c4;
        })();
        lo.propTypes = { onChange: y2.a.func.isRequired, editorState: y2.a.object, modalHandler: y2.a.object, config: y2.a.object, translations: y2.a.object };
        var so2 = { inline: st2, blockType: Et2, fontSize: zt2, fontFamily: Jt, list: ce2, textAlign: he2, colorPicker: Ie2, link: $e2, embedded: yn2, emoji: Ln2, image: Qn2, remove: qn2, history: lo }, uo = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, po2 = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
        function fo2(t3) {
          return String(t3).replace(uo, "").match(po2) ? t3 : "#";
        }
        n3(33);
        function yo2(t3) {
          return (yo2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function mo2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function go2(t3, e3) {
          return (go2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function bo2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = ho2(o4);
            if (r4) {
              var n4 = ho2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === yo2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function ho2(t3) {
          return (ho2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        function Mo2(t3, e3, n4) {
          t3.findEntityRanges(function(t4) {
            var e4 = t4.getEntity();
            return null !== e4 && "LINK" === n4.getEntity(e4).getType();
          }, e3);
        }
        function jo2(t3) {
          var e3, a4 = t3.showOpenOptionOnHover;
          return (e3 = (function() {
            !(function(t5, e5) {
              if ("function" != typeof e5 && null !== e5) throw new TypeError("Super expression must either be null or a function");
              t5.prototype = Object.create(e5 && e5.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e5 && go2(t5, e5);
            })(i3, f2["Component"]);
            var t4, e4, o4 = bo2(i3);
            function i3() {
              var r4;
              !(function(t6, e6) {
                if (!(t6 instanceof e6)) throw new TypeError("Cannot call a class as a function");
              })(this, i3);
              for (var t5 = arguments.length, e5 = new Array(t5), n4 = 0; n4 < t5; n4++) e5[n4] = arguments[n4];
              return (r4 = o4.call.apply(o4, [this].concat(e5))).state = { showPopOver: false }, r4.openLink = function() {
                var t6 = r4.props, e6 = t6.entityKey, n5 = t6.contentState.getEntity(e6).getData().url, o5 = window.open(fo2(n5), "blank");
                o5 && o5.focus();
              }, r4.toggleShowPopOver = function() {
                var t6 = !r4.state.showPopOver;
                r4.setState({ showPopOver: t6 });
              }, r4;
            }
            return t4 = i3, (e4 = [{ key: "render", value: function() {
              var t5 = this.props, e5 = t5.children, n4 = t5.entityKey, o5 = t5.contentState.getEntity(n4).getData(), r4 = o5.url, i4 = o5.targetOption, c4 = this.state.showPopOver;
              return N2.a.createElement("span", { className: "rdw-link-decorator-wrapper", onMouseEnter: this.toggleShowPopOver, onMouseLeave: this.toggleShowPopOver }, N2.a.createElement("a", { href: fo2(r4), target: i4 }, e5), c4 && a4 ? N2.a.createElement("img", { src: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuMDcyIDBIOC45MTVhLjkyNS45MjUgMCAwIDAgMCAxLjg0OWgyLjkyNUw2Ljk2MSA2LjcyN2EuOTE4LjkxOCAwIDAgMC0uMjcuNjU0YzAgLjI0Ny4wOTUuNDguMjcuNjU0YS45MTguOTE4IDAgMCAwIC42NTQuMjcuOTE4LjkxOCAwIDAgMCAuNjUzLS4yN2w0Ljg4LTQuODh2Mi45MjZhLjkyNS45MjUgMCAwIDAgMS44NDggMFYuOTI0QS45MjUuOTI1IDAgMCAwIDE0LjA3MiAweiIvPjxwYXRoIGQ9Ik0xMC42MjMgMTMuNDExSDEuNTg1VjQuMzcyaDYuNzk4bDEuNTg0LTEuNTg0SC43OTJBLjc5Mi43OTIgMCAwIDAgMCAzLjU4djEwLjYyNGMwIC40MzcuMzU1Ljc5Mi43OTIuNzkyaDEwLjYyNGEuNzkyLjc5MiAwIDAgMCAuNzkyLS43OTJWNS4wMjlsLTEuNTg1IDEuNTg0djYuNzk4eiIvPjwvZz48L3N2Zz4=", alt: "", onClick: this.openLink, className: "rdw-link-decorator-icon" }) : void 0);
            } }]) && mo2(t4.prototype, e4), Object.defineProperty(t4, "prototype", { writable: false }), i3;
          })()).propTypes = { entityKey: y2.a.string.isRequired, children: y2.a.array, contentState: y2.a.object }, e3;
        }
        n3(34);
        function No2(t3, e3, n4) {
          return Object.defineProperty(t3, "prototype", { writable: false }), t3;
        }
        var Eo2 = No2(function t3(e3) {
          var n4 = this;
          !(function(t4, e4) {
            if (!(t4 instanceof e4)) throw new TypeError("Cannot call a class as a function");
          })(this, t3), this.getMentionComponent = function() {
            function t4(t5) {
              var e4 = t5.entityKey, n5 = t5.children, o4 = t5.contentState.getEntity(e4).getData(), r4 = o4.url, i3 = o4.value;
              return N2.a.createElement("a", { href: r4 || i3, className: w2()("rdw-mention-link", c4) }, n5);
            }
            var c4 = n4.className;
            return t4.propTypes = { entityKey: y2.a.number, children: y2.a.array, contentState: y2.a.object }, t4;
          }, this.getMentionDecorator = function() {
            return { strategy: n4.findMentionEntities, component: n4.getMentionComponent() };
          }, this.className = e3;
        });
        Eo2.prototype.findMentionEntities = function(t3, e3, n4) {
          t3.findEntityRanges(function(t4) {
            var e4 = t4.getEntity();
            return null !== e4 && "MENTION" === n4.getEntity(e4).getType();
          }, e3);
        };
        var So2 = Eo2;
        n3(35);
        function wo2(t3) {
          return (wo2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function Co2(t3, e3) {
          return (Co2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Lo2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Do2(o4);
            if (r4) {
              var n4 = Do2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === wo2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Do2(t3) {
          return (Do2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        function ko2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function Oo2(t3, e3, n4) {
          return e3 && ko2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), t3;
        }
        function xo2(t3, e3) {
          if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
        }
        var Io2 = Oo2(function t3(e3) {
          var p3 = this;
          xo2(this, t3), this.findSuggestionEntities = function(t4, e4) {
            if (p3.config.getEditorState()) {
              var n5 = p3.config, o5 = n5.separator, r5 = n5.trigger, i4 = n5.getSuggestions, c5 = (0, n5.getEditorState)().getSelection();
              if (c5.get("anchorKey") === t4.get("key") && c5.get("anchorKey") === c5.get("focusKey")) {
                var a5 = t4.getText(), l3 = (a5 = a5.substr(0, c5.get("focusOffset") === a5.length - 1 ? a5.length : c5.get("focusOffset") + 1)).lastIndexOf(o5 + r5), s4 = o5 + r5;
                if ((void 0 === l3 || l3 < 0) && a5[0] === r5 && (l3 = 0, s4 = r5), 0 <= l3) {
                  var u4 = a5.substr(l3 + s4.length, a5.length);
                  i4().some(function(t5) {
                    return !!t5.value && (p3.config.caseSensitive ? 0 <= t5.value.indexOf(u4) : 0 <= t5.value.toLowerCase().indexOf(u4 && u4.toLowerCase()));
                  }) && e4(0 === l3 ? 0 : l3 + 1, a5.length);
                }
              }
            }
          }, this.getSuggestionComponent = (function() {
            var t4, a5 = this.config;
            return (t4 = (function() {
              !(function(t5, e4) {
                if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
                t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && Co2(t5, e4);
              })(r5, f2["Component"]);
              var o5 = Lo2(r5);
              function r5() {
                var c5;
                xo2(this, r5);
                for (var t5 = arguments.length, e4 = new Array(t5), n5 = 0; n5 < t5; n5++) e4[n5] = arguments[n5];
                return (c5 = o5.call.apply(o5, [this].concat(e4))).state = { style: { left: 15 }, activeOption: -1, showSuggestions: true }, c5.onEditorKeyDown = function(t6) {
                  var e5 = c5.state.activeOption, n6 = {};
                  "ArrowDown" === t6.key ? (t6.preventDefault(), e5 === c5.filteredSuggestions.length - 1 ? n6.activeOption = 0 : n6.activeOption = e5 + 1) : "ArrowUp" === t6.key ? n6.activeOption = e5 <= 0 ? c5.filteredSuggestions.length - 1 : e5 - 1 : "Escape" === t6.key ? (n6.showSuggestions = false, g2()) : "Enter" === t6.key && c5.addMention(), c5.setState(n6);
                }, c5.onOptionMouseEnter = function(t6) {
                  var e5 = t6.target.getAttribute("data-index");
                  c5.setState({ activeOption: e5 });
                }, c5.onOptionMouseLeave = function() {
                  c5.setState({ activeOption: -1 });
                }, c5.setSuggestionReference = function(t6) {
                  c5.suggestion = t6;
                }, c5.setDropdownReference = function(t6) {
                  c5.dropdown = t6;
                }, c5.closeSuggestionDropdown = function() {
                  c5.setState({ showSuggestions: false });
                }, c5.filteredSuggestions = [], c5.filterSuggestions = function(t6) {
                  var e5 = t6.children[0].props.text.substr(1), n6 = a5.getSuggestions();
                  c5.filteredSuggestions = n6 && n6.filter(function(t7) {
                    return !e5 || 0 === e5.length || (a5.caseSensitive ? 0 <= t7.value.indexOf(e5) : 0 <= t7.value.toLowerCase().indexOf(e5 && e5.toLowerCase()));
                  });
                }, c5.addMention = function() {
                  var t6 = c5.state.activeOption, e5 = a5.getEditorState(), n6 = a5.onChange, o6 = a5.separator, r6 = a5.trigger, i4 = c5.filteredSuggestions[t6];
                  i4 && (function(t7, e6, n7, o7, r7) {
                    var i5 = r7.value, c6 = r7.url, a6 = t7.getCurrentContent().createEntity("MENTION", "IMMUTABLE", { text: "".concat(o7).concat(i5), value: i5, url: c6 }).getLastCreatedEntityKey(), l3 = Object(S2.getSelectedBlock)(t7).getText(), s4 = t7.getSelection().focusOffset, u4 = (l3.lastIndexOf(n7 + o7, s4) || 0) + 1, p4 = false;
                    l3.length === u4 + 1 && (s4 = l3.length), " " === l3[s4] && (p4 = true);
                    var d4 = t7.getSelection().merge({ anchorOffset: u4, focusOffset: s4 }), f3 = E2.EditorState.acceptSelection(t7, d4), y3 = E2.Modifier.replaceText(f3.getCurrentContent(), d4, "".concat(o7).concat(i5), f3.getCurrentInlineStyle(), a6);
                    f3 = E2.EditorState.push(f3, y3, "insert-characters"), p4 || (d4 = f3.getSelection().merge({ anchorOffset: u4 + i5.length + o7.length, focusOffset: u4 + i5.length + o7.length }), f3 = E2.EditorState.acceptSelection(f3, d4), y3 = E2.Modifier.insertText(f3.getCurrentContent(), d4, " ", f3.getCurrentInlineStyle(), void 0)), e6(E2.EditorState.push(f3, y3, "insert-characters"));
                  })(e5, n6, o6, r6, i4);
                }, c5;
              }
              return Oo2(r5, [{ key: "componentDidMount", value: function() {
                var t5, e4, n5, o6 = a5.getWrapperRef().getBoundingClientRect(), r6 = this.suggestion.getBoundingClientRect(), i4 = this.dropdown.getBoundingClientRect();
                o6.width < r6.left - o6.left + i4.width ? e4 = 15 : t5 = 15, o6.bottom < i4.bottom && (n5 = 0), this.setState({ style: { left: t5, right: e4, bottom: n5 } }), C.registerCallBack(this.onEditorKeyDown), m2(), a5.modalHandler.setSuggestionCallback(this.closeSuggestionDropdown), this.filterSuggestions(this.props);
              } }, { key: "componentDidUpdate", value: function(t5) {
                this.props.children !== t5.children && (this.filterSuggestions(t5), this.setState({ showSuggestions: true }));
              } }, { key: "componentWillUnmount", value: function() {
                C.deregisterCallBack(this.onEditorKeyDown), g2(), a5.modalHandler.removeSuggestionCallback();
              } }, { key: "render", value: function() {
                var n5 = this, t5 = this.props.children, e4 = this.state, o6 = e4.activeOption, r6 = e4.showSuggestions, i4 = a5.dropdownClassName, c5 = a5.optionClassName;
                return N2.a.createElement("span", { className: "rdw-suggestion-wrapper", ref: this.setSuggestionReference, onClick: a5.modalHandler.onSuggestionClick, "aria-haspopup": "true", "aria-label": "rdw-suggestion-popup" }, N2.a.createElement("span", null, t5), r6 && N2.a.createElement("span", { className: w2()("rdw-suggestion-dropdown", i4), contentEditable: "false", suppressContentEditableWarning: true, style: this.state.style, ref: this.setDropdownReference }, this.filteredSuggestions.map(function(t6, e5) {
                  return N2.a.createElement("span", { key: e5, spellCheck: false, onClick: n5.addMention, "data-index": e5, onMouseEnter: n5.onOptionMouseEnter, onMouseLeave: n5.onOptionMouseLeave, className: w2()("rdw-suggestion-option", c5, { "rdw-suggestion-option-active": e5 === o6 }) }, t6.text);
                })));
              } }]), r5;
            })()).propTypes = { children: y2.a.array }, t4;
          }).bind(this), this.getSuggestionDecorator = function() {
            return { strategy: p3.findSuggestionEntities, component: p3.getSuggestionComponent() };
          };
          var n4 = e3.separator, o4 = e3.trigger, r4 = e3.getSuggestions, i3 = e3.onChange, c4 = e3.getEditorState, a4 = e3.getWrapperRef, l2 = e3.caseSensitive, s3 = e3.dropdownClassName, u3 = e3.optionClassName, d3 = e3.modalHandler;
          this.config = { separator: n4, trigger: o4, getSuggestions: r4, onChange: i3, getEditorState: c4, getWrapperRef: a4, caseSensitive: l2, dropdownClassName: s3, optionClassName: u3, modalHandler: d3 };
        }), To2 = function(t3) {
          return [new So2(t3.mentionClassName).getMentionDecorator(), new Io2(t3).getSuggestionDecorator()];
        };
        n3(36);
        function zo2(t3, e3, n4) {
          return Object.defineProperty(t3, "prototype", { writable: false }), t3;
        }
        function _o2(t3) {
          var e3 = t3.block, n4 = t3.contentState.getEntity(e3.getEntityAt(0)).getData(), o4 = n4.src, r4 = n4.height, i3 = n4.width;
          return N2.a.createElement("iframe", { height: r4, width: i3, src: o4, frameBorder: "0", allowFullScreen: true, title: "Wysiwyg Embedded Content" });
        }
        var Po2 = zo2(function t3(e3) {
          var a4 = this;
          !(function(t4, e4) {
            if (!(t4 instanceof e4)) throw new TypeError("Cannot call a class as a function");
          })(this, t3), this.getHashtagComponent = function() {
            function t4(t5) {
              var e4 = t5.children, n4 = e4[0].props.text;
              return N2.a.createElement("a", { href: n4, className: w2()("rdw-hashtag-link", o4) }, e4);
            }
            var o4 = a4.className;
            return t4.propTypes = { children: y2.a.object }, t4;
          }, this.findHashtagEntities = function(t4, e4) {
            for (var n4 = t4.getText(), o4 = 0, r4 = 0; 0 < n4.length && 0 <= o4; ) if (n4[0] === a4.hashCharacter ? (r4 = o4 = 0, n4 = n4.substr(a4.hashCharacter.length)) : 0 <= (o4 = n4.indexOf(a4.separator + a4.hashCharacter)) && (n4 = n4.substr(o4 + (a4.separator + a4.hashCharacter).length), r4 += o4 + a4.separator.length), 0 <= o4) {
              var i3 = 0 <= n4.indexOf(a4.separator) ? n4.indexOf(a4.separator) : n4.length, c4 = n4.substr(0, i3);
              c4 && 0 < c4.length && (e4(r4, r4 + c4.length + a4.hashCharacter.length), r4 += a4.hashCharacter.length);
            }
          }, this.getHashtagDecorator = function() {
            return { strategy: a4.findHashtagEntities, component: a4.getHashtagComponent() };
          }, this.className = e3.className, this.hashCharacter = e3.hashCharacter || "#", this.separator = e3.separator || " ";
        }), Ro2 = function(t3) {
          return new Po2(t3).getHashtagDecorator();
        };
        _o2.propTypes = { block: y2.a.object, contentState: y2.a.object };
        var Uo2 = _o2;
        n3(37);
        function Bo2(t3) {
          return (Bo2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function Fo2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function Yo2(t3, e3) {
          return (Yo2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function Qo2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = Ho2(o4);
            if (r4) {
              var n4 = Ho2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === Bo2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function Ho2(t3) {
          return (Ho2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var Zo2 = function(d3) {
          var t3;
          return (t3 = (function() {
            !(function(t5, e4) {
              if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
              t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && Yo2(t5, e4);
            })(r4, f2["Component"]);
            var t4, e3, o4 = Qo2(r4);
            function r4() {
              var i3;
              !(function(t6, e5) {
                if (!(t6 instanceof e5)) throw new TypeError("Cannot call a class as a function");
              })(this, r4);
              for (var t5 = arguments.length, e4 = new Array(t5), n4 = 0; n4 < t5; n4++) e4[n4] = arguments[n4];
              return (i3 = o4.call.apply(o4, [this].concat(e4))).state = { hovered: false }, i3.setEntityAlignmentLeft = function() {
                i3.setEntityAlignment("left");
              }, i3.setEntityAlignmentRight = function() {
                i3.setEntityAlignment("right");
              }, i3.setEntityAlignmentCenter = function() {
                i3.setEntityAlignment("none");
              }, i3.setEntityAlignment = function(t6) {
                var e5 = i3.props, n5 = e5.block, o5 = e5.contentState, r5 = n5.getEntityAt(0);
                o5.mergeEntityData(r5, { alignment: t6 }), d3.onChange(E2.EditorState.push(d3.getEditorState(), o5, "change-block-data")), i3.setState({ dummy: true });
              }, i3.toggleHovered = function() {
                var t6 = !i3.state.hovered;
                i3.setState({ hovered: t6 });
              }, i3;
            }
            return t4 = r4, (e3 = [{ key: "renderAlignmentOptions", value: function(t5) {
              return N2.a.createElement("div", { className: w2()("rdw-image-alignment-options-popup", { "rdw-image-alignment-options-popup-right": "right" === t5 }) }, N2.a.createElement(R, { onClick: this.setEntityAlignmentLeft, className: "rdw-image-alignment-option" }, "L"), N2.a.createElement(R, { onClick: this.setEntityAlignmentCenter, className: "rdw-image-alignment-option" }, "C"), N2.a.createElement(R, { onClick: this.setEntityAlignmentRight, className: "rdw-image-alignment-option" }, "R"));
            } }, { key: "render", value: function() {
              var t5 = this.props, e4 = t5.block, n4 = t5.contentState, o5 = this.state.hovered, r5 = d3.isReadOnly, i3 = d3.isImageAlignmentEnabled, c4 = n4.getEntity(e4.getEntityAt(0)).getData(), a4 = c4.src, l2 = c4.alignment, s3 = c4.height, u3 = c4.width, p3 = c4.alt;
              return N2.a.createElement("span", { onMouseEnter: this.toggleHovered, onMouseLeave: this.toggleHovered, className: w2()("rdw-image-alignment", { "rdw-image-left": "left" === l2, "rdw-image-right": "right" === l2, "rdw-image-center": !l2 || "none" === l2 }) }, N2.a.createElement("span", { className: "rdw-image-imagewrapper" }, N2.a.createElement("img", { src: a4, alt: p3, style: { height: s3, width: u3 } }), !r5() && o5 && i3() ? this.renderAlignmentOptions(l2) : void 0));
            } }]) && Fo2(t4.prototype, e3), Object.defineProperty(t4, "prototype", { writable: false }), r4;
          })()).propTypes = { block: y2.a.object, contentState: y2.a.object }, t3;
        }, Wo2 = function(o4, r4) {
          return function(t3) {
            if ("function" == typeof r4) {
              var e3 = r4(t3, o4, o4.getEditorState);
              if (e3) return e3;
            }
            if ("atomic" === t3.getType()) {
              var n4 = o4.getEditorState().getCurrentContent().getEntity(t3.getEntityAt(0));
              if (n4 && "IMAGE" === n4.type) return { component: Zo2(o4), editable: false };
              if (n4 && "EMBEDDED_LINK" === n4.type) return { component: Uo2, editable: false };
            }
          };
        }, Go2 = { options: ["inline", "blockType", "fontSize", "fontFamily", "list", "textAlign", "colorPicker", "link", "embedded", "emoji", "image", "remove", "history"], inline: { inDropdown: false, className: void 0, component: void 0, dropdownClassName: void 0, options: ["bold", "italic", "underline", "strikethrough", "monospace", "superscript", "subscript"], bold: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuMjM2IDBjMS42NTIgMCAyLjk0LjI5OCAzLjg2Ni44OTMuOTI1LjU5NSAxLjM4OCAxLjQ4NSAxLjM4OCAyLjY2OSAwIC42MDEtLjE3MyAxLjEzOS0uNTE2IDEuNjEtLjM0My40NzQtLjg0NC44My0xLjQ5OSAxLjA2OC44NDMuMTY3IDEuNDc0LjUyMyAxLjg5NSAxLjA3MS40MTkuNTUuNjMgMS4xODMuNjMgMS45MDMgMCAxLjI0NS0uNDQ0IDIuMTg3LTEuMzMgMi44MjUtLjg4Ni42NDEtMi4xNDQuOTYxLTMuNzY5Ljk2MUgwdi0yLjE2N2gxLjQ5NFYyLjE2N0gwVjBoNi4yMzZ6TTQuMzA4IDUuNDQ2aDIuMDI0Yy43NTIgMCAxLjMzLS4xNDMgMS43MzQtLjQzLjQwNS0uMjg1LjYwOC0uNzAxLjYwOC0xLjI1IDAtLjYtLjIwNC0xLjA0NC0uNjEyLTEuMzMtLjQwOC0uMjg2LTEuMDE2LS40MjctMS44MjYtLjQyN0g0LjMwOHYzLjQzN3ptMCAxLjgwNFYxMWgyLjU5M2MuNzQ3IDAgMS4zMTQtLjE1MiAxLjcwNy0uNDUyLjM5LS4zLjU4OC0uNzQ1LjU4OC0xLjMzNCAwLS42MzYtLjE2OC0xLjEyNC0uNS0xLjQ2LS4zMzYtLjMzNS0uODY0LS41MDQtMS41ODItLjUwNEg0LjMwOHoiIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==", className: void 0, title: void 0 }, italic: { icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTcgM1YyaDR2MUg5Ljc1M2wtMyAxMEg4djFINHYtMWgxLjI0N2wzLTEwSDd6Ii8+PC9zdmc+", className: void 0, title: void 0 }, underline: { icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTYuMDQ1IDJ2Ljk5Mkw0Ljc4NSAzdjUuMTcyYzAgLjg1OS4yNDMgMS41MTIuNzI3IDEuOTU3czEuMTI0LjY2OCAxLjkxOC42NjhjLjgzNiAwIDEuNTA5LS4yMjEgMi4wMTktLjY2NC41MTEtLjQ0Mi43NjYtMS4wOTYuNzY2LTEuOTYxVjNsLTEuMjYtLjAwOFYySDEzdi45OTJMMTEuNzM5IDN2NS4xNzJjMCAxLjIzNC0uMzk4IDIuMTgxLTEuMTk1IDIuODQtLjc5Ny42NTktMS44MzUuOTg4LTMuMTE0Ljk4OC0xLjI0MiAwLTIuMjQ4LS4zMjktMy4wMTctLjk4OC0uNzY5LS42NTktMS4xNTItMS42MDUtMS4xNTItMi44NFYzTDIgMi45OTJWMmg0LjA0NXpNMiAxM2gxMXYxSDJ6Ii8+PC9zdmc+", className: void 0, title: void 0 }, strikethrough: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNNC4wNCA1Ljk1NGg2LjIxNWE3LjQxMiA3LjQxMiAwIDAgMC0uNzk1LS40MzggMTEuOTA3IDExLjkwNyAwIDAgMC0xLjQ0Ny0uNTU3Yy0xLjE4OC0uMzQ4LTEuOTY2LS43MTEtMi4zMzQtMS4wODgtLjM2OC0uMzc3LS41NTItLjc3LS41NTItMS4xODEgMC0uNDk1LjE4Ny0uOTA2LjU2LTEuMjMyLjM4LS4zMzEuODg3LS40OTcgMS41MjMtLjQ5Ny42OCAwIDEuMjY2LjI1NSAxLjc1Ny43NjcuMjk1LjMxNS41ODIuODkxLjg2MSAxLjczbC4xMTcuMDE2LjcwMy4wNS4xLS4wMjRjLjAyOC0uMTUyLjA0Mi0uMjc5LjA0Mi0uMzggMC0uMzM3LS4wMzktLjg1Mi0uMTE3LTEuNTQ0YTkuMzc0IDkuMzc0IDAgMCAwLS4xNzYtLjk5NUM5Ljg4LjM3OSA5LjM4NS4yNDQgOS4wMTcuMTc2IDguMzY1LjA3IDcuODk5LjAxNiA3LjYyLjAxNmMtMS40NSAwLTIuNTQ1LjM1Ny0zLjI4NyAxLjA3MS0uNzQ3LjcyLTEuMTIgMS41ODktMS4xMiAyLjYwNyAwIC41MTEuMTMzIDEuMDQuNCAxLjU4Ni4xMjkuMjUzLjI3LjQ3OC40MjcuNjc0ek04LjI4IDguMTE0Yy41NzUuMjM2Ljk1Ny40MzYgMS4xNDcuNTk5LjQ1MS40MS42NzcuODUyLjY3NyAxLjMyNCAwIC4zODMtLjEzLjc0NS0uMzkzIDEuMDg4LS4yNS4zMzgtLjU5LjU4LTEuMDIuNzI2YTMuNDE2IDMuNDE2IDAgMCAxLTEuMTYzLjIyOGMtLjQwNyAwLS43NzUtLjA2Mi0xLjEwNC0uMTg2YTIuNjk2IDIuNjk2IDAgMCAxLS44NzgtLjQ4IDMuMTMzIDMuMTMzIDAgMCAxLS42Ny0uNzk0IDEuNTI3IDEuNTI3IDAgMCAxLS4xMDQtLjIyNyA1Ny41MjMgNTcuNTIzIDAgMCAwLS4xODgtLjQ3MyAyMS4zNzEgMjEuMzcxIDAgMCAwLS4yNTEtLjU5OWwtLjg1My4wMTd2LjM3MWwtLjAxNy4zMTNhOS45MiA5LjkyIDAgMCAwIDAgLjU3M2MuMDExLjI3LjAxNy43MDkuMDE3IDEuMzE2di4xMWMwIC4wNzkuMDIyLjE0LjA2Ny4xODUuMDgzLjA2OC4yODQuMTQ3LjYwMi4yMzdsMS4xNy4zMzdjLjQ1Mi4xMy45OTYuMTk0IDEuNjMyLjE5NC42ODYgMCAxLjI1Mi0uMDU5IDEuNjk4LS4xNzdhNC42OTQgNC42OTQgMCAwIDAgMS4yOC0uNTU3Yy40MDEtLjI1OS43MDUtLjQ4Ni45MTEtLjY4My4yNjgtLjI3Ni40NjYtLjU2OC41OTQtLjg3OGE0Ljc0IDQuNzQgMCAwIDAgLjM0My0xLjc4OGMwLS4yOTgtLjAyLS41NTctLjA1OC0uNzc2SDguMjgxek0xNC45MTQgNi41N2EuMjYuMjYgMCAwIDAtLjE5My0uMDc2SC4yNjhhLjI2LjI2IDAgMCAwLS4xOTMuMDc2LjI2NC4yNjQgMCAwIDAtLjA3NS4xOTR2LjU0YzAgLjA3OS4wMjUuMTQzLjA3NS4xOTRhLjI2LjI2IDAgMCAwIC4xOTMuMDc2SDE0LjcyYS4yNi4yNiAwIDAgMCAuMTkzLS4wNzYuMjY0LjI2NCAwIDAgMCAuMDc1LS4xOTR2LS41NGEuMjY0LjI2NCAwIDAgMC0uMDc1LS4xOTR6Ii8+PC9nPjwvc3ZnPg==", className: void 0, title: void 0 }, monospace: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzQ0NCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMS4wMjEgMi45MDZjLjE4NiAxLjIxOS4zNzIgMS41LjM3MiAyLjcxOUMxLjM5MyA2LjM3NSAwIDcuMDMxIDAgNy4wMzF2LjkzOHMxLjM5My42NTYgMS4zOTMgMS40MDZjMCAxLjIxOS0uMTg2IDEuNS0uMzcyIDIuNzE5Qy43NDMgMTQuMDYzIDEuNzY0IDE1IDIuNjkzIDE1aDEuOTV2LTEuODc1cy0xLjY3Mi4xODgtMS42NzItLjkzOGMwLS44NDMuMTg2LS44NDMuMzcyLTIuNzE4LjA5My0uODQ0LS40NjQtMS41LTEuMDIyLTEuOTY5LjU1OC0uNDY5IDEuMTE1LTEuMDMxIDEuMDIyLTEuODc1QzMuMDY0IDMuNzUgMi45NyAzLjc1IDIuOTcgMi45MDZjMC0xLjEyNSAxLjY3Mi0xLjAzMSAxLjY3Mi0xLjAzMVYwaC0xLjk1QzEuNjcgMCAuNzQzLjkzOCAxLjAyIDIuOTA2ek0xMS45NzkgMi45MDZjLS4xODYgMS4yMTktLjM3MiAxLjUtLjM3MiAyLjcxOSAwIC43NSAxLjM5MyAxLjQwNiAxLjM5MyAxLjQwNnYuOTM4cy0xLjM5My42NTYtMS4zOTMgMS40MDZjMCAxLjIxOS4xODYgMS41LjM3MiAyLjcxOS4yNzggMS45NjktLjc0MyAyLjkwNi0xLjY3MiAyLjkwNmgtMS45NXYtMS44NzVzMS42NzIuMTg4IDEuNjcyLS45MzhjMC0uODQzLS4xODYtLjg0My0uMzcyLTIuNzE4LS4wOTMtLjg0NC40NjQtMS41IDEuMDIyLTEuOTY5LS41NTgtLjQ2OS0xLjExNS0xLjAzMS0xLjAyMi0xLjg3NS4xODYtMS44NzUuMzcyLTEuODc1LjM3Mi0yLjcxOSAwLTEuMTI1LTEuNjcyLTEuMDMxLTEuNjcyLTEuMDMxVjBoMS45NWMxLjAyMiAwIDEuOTUuOTM4IDEuNjcyIDIuOTA2eiIvPjwvZz48L3N2Zz4=", className: void 0, title: void 0 }, superscript: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTcuMzA1IDEwLjE2NUwxMS44NjUgMTVIOS4wNTdsLTMuMTkyLTMuNTM2TDIuNzQ2IDE1SDBsNC41MjMtNC44MzVMLjIxOCA1LjYwM2gyLjc3TDUuOTg2IDguOTEgOS4wMSA1LjYwM2gyLjY0OWwtNC4zNTQgNC41NjJ6bTYuMjM0LTMuMjY5bDEuODc5LTEuMzA2Yy42NC0uNDE2IDEuMDYyLS44MDEgMS4yNjQtMS4xNTcuMjAxLS4zNTYuMzAyLS43MzguMzAyLTEuMTQ4IDAtLjY2OS0uMjM3LTEuMjEtLjcxLTEuNjItLjQ3NC0uNDExLTEuMDk3LS42MTctMS44NjgtLjYxNy0uNzQ0IDAtMS4zNC4yMDgtMS43ODUuNjI0LS40NDcuNDE2LS42NyAxLjA0My0uNjcgMS44ODFoMS40MzZjMC0uNS4wOTQtLjg0Ni4yODEtMS4wMzguMTg4LS4xOTEuNDQ1LS4yODcuNzcyLS4yODdzLjU4NS4wOTcuNzc3LjI5MmMuMTkuMTk1LjI4Ni40MzcuMjg2LjcyNiAwIC4yOS0uMDg5LjU1LS4yNjYuNzg1cy0uNjcuNjI4LTEuNDc5IDEuMTg0Yy0uNjkxLjQ3Ny0xLjYyNy45MjctMS45MDggMS4zNWwuMDE0IDEuNTY5SDE3VjYuODk2aC0zLjQ2MXoiLz48L3N2Zz4=", className: void 0, title: void 0 }, subscript: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTExLjg2NiAxMS42NDZIOS4wNkw1Ljg2NyA3Ljk0MmwtMy4xMjEgMy43MDRIMGw0LjUyNC01LjA2NEwuMjE4IDEuODA0aDIuNzdsMyAzLjQ2NCAzLjAyMy0zLjQ2NGgyLjY1TDcuMzA2IDYuNTgybDQuNTYgNS4wNjR6bTEuNzI1IDIuMDU4bDEuODI3LTEuMzY4Yy42NC0uNDM1IDEuMDYyLS44NCAxLjI2NC0xLjIxMi4yMDItLjM3Mi4zMDItLjc3My4zMDItMS4yMDIgMC0uNy0uMjM3LTEuMjY2LS43MS0xLjY5Ni0uNDc0LS40MzEtMS4wOTctLjY0Ni0xLjg2OS0uNjQ2LS43NDQgMC0xLjM0LjIxOC0xLjc4NS42NTMtLjQ0Ni40MzYtLjY3IDEuMDkyLS42NyAxLjk3aDEuNDM2YzAtLjUyNC4wOTQtLjg4Ni4yODEtMS4wODcuMTg4LS4yLjQ0NS0uMzAxLjc3Mi0uMzAxcy41ODYuMTAyLjc3Ny4zMDZjLjE5LjIwNC4yODYuNDU4LjI4Ni43NiAwIC4zMDMtLjA4OC41NzctLjI2Ni44MjItLjE3Ny4yNDUtLjY3LjY1OC0xLjQ3OCAxLjI0LS42OTIuNS0xLjYyOC45NzEtMS45MSAxLjQxM0wxMS44NjQgMTVIMTd2LTEuMjk2aC0zLjQxeiIvPjwvc3ZnPg==", className: void 0, title: void 0 } }, blockType: { inDropdown: true, options: ["Normal", "H1", "H2", "H3", "H4", "H5", "H6", "Blockquote", "Code"], className: void 0, component: void 0, dropdownClassName: void 0, title: void 0 }, fontSize: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTEuOTIxIDMuMTE5YS40MjcuNDI3IDAgMCAwIC4zMzUuMTY0aC45N2EuNDI2LjQyNiAwIDAgMCAuMzA0LS4xMy40NDEuNDQxIDAgMCAwIC4xMjUtLjMxbC4wMDItMi40MWEuNDM0LjQzNCAwIDAgMC0uNDMtLjQzMkguNDNBLjQzNC40MzQgMCAwIDAgMCAuNDR2Mi40MDZjMCAuMjQyLjE5Mi40MzguNDMuNDM4aC45N2MuMTMgMCAuMjU0LS4wNi4zMzUtLjE2NWwuNzMtLjkzSDUuNTR2MTEuMzZjMCAuMjQxLjE5Mi40MzcuNDMuNDM3aDEuNzE3Yy4yMzcgMCAuNDMtLjE5Ni40My0uNDM3VjIuMTg4aDMuMDdsLjczNC45MzF6TTEzLjg5OCAxMS4yNjNhLjQyNS40MjUgMCAwIDAtLjQ4Mi0uMTQ2bC0uNTQ3LjE5NFY5LjYxN2EuNDQyLjQ0MiAwIDAgMC0uMTI2LS4zMS40MjYuNDI2IDAgMCAwLS4zMDQtLjEyN2gtLjQyOWEuNDM0LjQzNCAwIDAgMC0uNDMuNDM3djEuNjk0bC0uNTQ3LS4xOTRhLjQyNS40MjUgMCAwIDAtLjQ4MS4xNDYuNDQ0LjQ0NCAwIDAgMC0uMDE2LjUxMmwxLjMzMiAyLjAxN2EuNDI3LjQyNyAwIDAgMCAuNzEzIDBsMS4zMzMtMi4wMTdhLjQ0NC40NDQgMCAwIDAtLjAxNi0uNTEyeiIvPjwvZz48L3N2Zz4=", options: [8, 9, 10, 11, 12, 14, 16, 18, 24, 30, 36, 48, 60, 72, 96], className: void 0, component: void 0, dropdownClassName: void 0, title: void 0 }, fontFamily: { options: ["Arial", "Georgia", "Impact", "Tahoma", "Times New Roman", "Verdana"], className: void 0, component: void 0, dropdownClassName: void 0, title: void 0 }, list: { inDropdown: false, className: void 0, component: void 0, dropdownClassName: void 0, options: ["unordered", "ordered", "indent", "outdent"], unordered: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMS43MiAzLjQyN2MuOTUxIDAgMS43MjItLjc2OCAxLjcyMi0xLjcwOFMyLjY3LjAxIDEuNzIuMDFDLjc3LjAwOCAwIC43NzUgMCAxLjcxNWMwIC45NC43NzQgMS43MTEgMS43MiAxLjcxMXptMC0yLjYyNWMuNTEgMCAuOTIyLjQxMi45MjIuOTE0YS45Mi45MiAwIDAgMS0xLjg0MiAwIC45Mi45MiAwIDAgMSAuOTItLjkxNHpNMS43MiA4LjcwM2MuOTUxIDAgMS43MjItLjc2OCAxLjcyMi0xLjcwOFMyLjY3IDUuMjg3IDEuNzIgNS4yODdDLjc3IDUuMjg3IDAgNi4wNTIgMCA2Ljk5NXMuNzc0IDEuNzA4IDEuNzIgMS43MDh6bTAtMi42MjJjLjUxIDAgLjkyMi40MTIuOTIyLjkxNGEuOTIuOTIgMCAwIDEtMS44NDIgMGMwLS41MDUuNDE1LS45MTQuOTItLjkxNHpNMS43MiAxMy45ODJjLjk1MSAwIDEuNzIyLS43NjggMS43MjItMS43MDggMC0uOTQzLS43NzQtMS43MDgtMS43MjEtMS43MDgtLjk0NyAwLTEuNzIxLjc2OC0xLjcyMSAxLjcwOHMuNzc0IDEuNzA4IDEuNzIgMS43MDh6bTAtMi42MjVjLjUxIDAgLjkyMi40MTIuOTIyLjkxNGEuOTIuOTIgMCAxIDEtMS44NDIgMCAuOTIuOTIgMCAwIDEgLjkyLS45MTR6TTUuNzQ0IDIuMTE1aDkuODQ1YS40LjQgMCAwIDAgLjQwMS0uMzk5LjQuNCAwIDAgMC0uNDAxLS4zOTlINS43NDRhLjQuNCAwIDAgMC0uNDAyLjM5OS40LjQgMCAwIDAgLjQwMi4zOTl6TTUuNzQ0IDcuMzk0aDkuODQ1YS40LjQgMCAwIDAgLjQwMS0uMzk5LjQuNCAwIDAgMC0uNDAxLS4zOThINS43NDRhLjQuNCAwIDAgMC0uNDAyLjM5OC40LjQgMCAwIDAgLjQwMi4zOTl6TTUuNzQ0IDEyLjY3aDkuODQ1YS40LjQgMCAwIDAgLjQwMS0uMzk5LjQuNCAwIDAgMC0uNDAxLS4zOTlINS43NDRhLjQuNCAwIDAgMC0uNDAyLjQuNC40IDAgMCAwIC40MDIuMzk4eiIvPjwvZz48L3N2Zz4=", className: void 0, title: void 0 }, ordered: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNNC4yMDIgMS40NjZoOC4xNWMuMzM4IDAgLjYxMi0uMzIyLjYxMi0uNzIgMC0uMzk3LS4yNzQtLjcyLS42MTItLjcyaC04LjE1Yy0uMzM4IDAtLjYxMS4zMjMtLjYxMS43MiAwIC4zOTguMjczLjcyLjYxLjcyek0xMi4zNTIgNS43ODNoLTguMTVjLS4zMzggMC0uNjExLjMyMi0uNjExLjcyIDAgLjM5Ny4yNzMuNzIuNjEuNzJoOC4xNTFjLjMzOCAwIC42MTItLjMyMy42MTItLjcyIDAtLjM5OC0uMjc0LS43Mi0uNjEyLS43MnpNMTIuMzUyIDExLjU0aC04LjE1Yy0uMzM4IDAtLjYxMS4zMjItLjYxMS43MiAwIC4zOTYuMjczLjcxOS42MS43MTloOC4xNTFjLjMzOCAwIC42MTItLjMyMy42MTItLjcyIDAtLjM5Ny0uMjc0LS43Mi0uNjEyLS43MnpNLjc2NyAxLjI0OXYxLjgwMmMwIC4xOTUuMTM2LjM0My4zMTUuMzQzLjE3NiAwIC4zMTUtLjE1LjMxNS0uMzQzVi4zNTZjMC0uMTktLjEzMy0uMzM5LS4zMDItLjMzOS0uMTQ4IDAtLjIyMy4xMTgtLjI0Ny4xNTZhLjIyOC4yMjggMCAwIDAtLjAwMy4wMDVMLjU3OS42MjFhLjQ3NC40NzQgMCAwIDAtLjA5OC4yNzNjMCAuMTk0LjEyOC4zNTEuMjg2LjM1NXpNLjM1MiA4LjE5SDEuNTVjLjE1NyAwIC4yODUtLjE2Mi4yODUtLjM2MiAwLS4xOTgtLjEyOC0uMzU5LS4yODUtLjM1OUguNjh2LS4wMDZjMC0uMTA3LjIxLS4yODEuMzc4LS40MjIuMzM2LS4yNzguNzUzLS42MjUuNzUzLTEuMjI2IDAtLjU3LS4zNzYtMS0uODc0LTEtLjQ3NyAwLS44MzYuMzg1LS44MzYuODk3IDAgLjI5Ny4xNjQuNDAyLjMwNS40MDIuMiAwIC4zMjEtLjE3Ni4zMjEtLjM0NiAwLS4xMDYuMDIzLS4yMjguMjA0LS4yMjguMjQzIDAgLjI1LjI1NC4yNS4yODMgMCAuMjI4LS4yNTIuNDQyLS40OTUuNjQ5LS4zMDEuMjU1LS42NDIuNTQ0LS42NDIuOTkydi4zODRjMCAuMjA1LjE1OS4zNDMuMzA4LjM0M3pNMS43NyAxMC41NDNjMC0uNTkyLS4yOTYtLjkzMS0uODE0LS45MzEtLjY4IDAtLjg1OS41Ny0uODU5Ljg3MiAwIC4zNTEuMjIyLjM5LjMxOC4zOS4xODUgMCAuMzEtLjE0OC4zMS0uMzY2IDAtLjA4NC4wMjYtLjE4MS4yMjQtLjE4MS4xNDIgMCAuMi4wMjQuMi4yNjcgMCAuMjM3LS4wNDMuMjYzLS4yMTMuMjYzLS4xNjQgMC0uMjg4LjE1Mi0uMjg4LjM1NCAwIC4yLjEyNS4zNS4yOTEuMzUuMjI1IDAgLjI3LjEwOC4yNy4yODN2LjA3NWMwIC4yOTQtLjA5Ny4zNS0uMjc3LjM1LS4yNDggMC0uMjY3LS4xNS0uMjY3LS4xOTcgMC0uMTc0LS4wOTgtLjM1LS4zMTctLjM1LS4xOTIgMC0uMzA3LjE0MS0uMzA3LjM3OCAwIC40My4zMTMuODg4Ljg5NS44ODguNTY0IDAgLjkwMS0uNC45MDEtMS4wN3YtLjA3NGMwLS4yNzQtLjA3NC0uNTAyLS4yMTQtLjY2Ni4wOTYtLjE2My4xNDgtLjM4LjE0OC0uNjM1eiIvPjwvZz48L3N2Zz4=", className: void 0, title: void 0 }, indent: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNNS43MTYgMy4yMTFIMTd2MS4xOTdINS43MTZ6TTAgLjAyaDE3djEuMTk3SDB6TTAgMTIuNzgzaDE3djEuMTk3SDB6TTUuNzE2IDkuNTkzSDE3djEuMTk3SDUuNzE2ek01LjcxNiA2LjQwMkgxN3YxLjE5N0g1LjcxNnpNLjE4NyA5LjQ5MUwyLjUyIDcgLjE4NyA0LjUwOXoiLz48L2c+PC9zdmc+", className: void 0, title: void 0 }, outdent: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNNS4zOTYgMy4xOTNoMTAuNTczVjQuMzlINS4zOTZ6TS4wMzkuMDAzaDE1LjkzVjEuMkguMDM5ek0uMDM5IDEyLjc2NmgxNS45M3YxLjE5N0guMDM5ek01LjM5NiA5LjU3NWgxMC41NzN2MS4xOTdINS4zOTZ6TTUuMzk2IDYuMzg0aDEwLjU3M3YxLjE5N0g1LjM5NnpNMi4xODcgNC40OTFMMCA2Ljk4M2wyLjE4NyAyLjQ5MXoiLz48L2c+PC9zdmc+", className: void 0, title: void 0 }, title: void 0 }, textAlign: { inDropdown: false, className: void 0, component: void 0, dropdownClassName: void 0, options: ["left", "center", "right", "justify"], left: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNOC40OTMgMTQuODg3SC4zMjZhLjMyNi4zMjYgMCAwIDEgMC0uNjUyaDguMTY3YS4zMjYuMzI2IDAgMCAxIDAgLjY1MnpNMTQuNjE4IDEwLjE2MkguMzI2YS4zMjYuMzI2IDAgMCAxIDAtLjY1M2gxNC4yOTJhLjMyNi4zMjYgMCAwIDEgMCAuNjUzek04LjQ5MyA1LjQzNUguMzI2YS4zMjYuMzI2IDAgMCAxIDAtLjY1Mmg4LjE2N2EuMzI2LjMyNiAwIDAgMSAwIC42NTJ6TTE0LjYxOC43MDlILjMyNmEuMzI2LjMyNiAwIDAgMSAwLS42NTJoMTQuMjkyYS4zMjYuMzI2IDAgMCAxIDAgLjY1MnoiLz48L2c+PC9zdmc+", className: void 0, title: void 0 }, center: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTEuNTU2IDE0Ljg4N0gzLjM4OGEuMzI2LjMyNiAwIDAgMSAwLS42NTJoOC4xNjdhLjMyNi4zMjYgMCAwIDEgMCAuNjUyek0xNC42MTggMTAuMTYySC4zMjZhLjMyNi4zMjYgMCAwIDEgMC0uNjUzaDE0LjI5MmEuMzI2LjMyNiAwIDAgMSAwIC42NTN6TTExLjU1NiA1LjQzNUgzLjM4OGEuMzI2LjMyNiAwIDAgMSAwLS42NTJoOC4xNjdhLjMyNi4zMjYgMCAwIDEgMCAuNjUyek0xNC42MTguNzA5SC4zMjZhLjMyNi4zMjYgMCAwIDEgMC0uNjUyaDE0LjI5MmEuMzI2LjMyNiAwIDAgMSAwIC42NTJ6Ii8+PC9nPjwvc3ZnPg==", className: void 0, title: void 0 }, right: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuNjE4IDE0Ljg4N0g2LjQ1YS4zMjYuMzI2IDAgMCAxIDAtLjY1Mmg4LjE2N2EuMzI2LjMyNiAwIDAgMSAwIC42NTJ6TTE0LjYxOCAxMC4xNjJILjMyNmEuMzI2LjMyNiAwIDAgMSAwLS42NTNoMTQuMjkyYS4zMjYuMzI2IDAgMCAxIDAgLjY1M3pNMTQuNjE4IDUuNDM1SDYuNDVhLjMyNi4zMjYgMCAwIDEgMC0uNjUyaDguMTY3YS4zMjYuMzI2IDAgMCAxIDAgLjY1MnpNMTQuNjE4LjcwOUguMzI2YS4zMjYuMzI2IDAgMCAxIDAtLjY1MmgxNC4yOTJhLjMyNi4zMjYgMCAwIDEgMCAuNjUyeiIvPjwvZz48L3N2Zz4=", className: void 0, title: void 0 }, justify: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuNjIgMTQuODg4SC4zMjVhLjMyNi4zMjYgMCAwIDEgMC0uNjUySDE0LjYyYS4zMjYuMzI2IDAgMCAxIDAgLjY1MnpNMTQuNjIgMTAuMTYySC4zMjVhLjMyNi4zMjYgMCAwIDEgMC0uNjUySDE0LjYyYS4zMjYuMzI2IDAgMCAxIDAgLjY1MnpNMTQuNjIgNS40MzZILjMyNWEuMzI2LjMyNiAwIDAgMSAwLS42NTJIMTQuNjJhLjMyNi4zMjYgMCAwIDEgMCAuNjUyek0xNC42Mi43MUguMzI1YS4zMjYuMzI2IDAgMCAxIDAtLjY1M0gxNC42MmEuMzI2LjMyNiAwIDAgMSAwIC42NTN6Ii8+PC9nPjwvc3ZnPg==", className: void 0, title: void 0 }, title: void 0 }, colorPicker: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuNDA2LjU4NWExLjk5OCAxLjk5OCAwIDAgMC0yLjgyNSAwbC0uNTQuNTRhLjc0MS43NDEgMCAxIDAtMS4wNDggMS4wNDhsLjE3NS4xNzUtNS44MjYgNS44MjUtMi4wMjIgMi4wMjNhLjkxLjkxIDAgMCAwLS4yNjYuNjAybC0uMDA1LjEwOHYuMDAybC0uMDgxIDEuODI5YS4zMDIuMzAyIDAgMCAwIC4zMDIuMzE2aC4wMTNsLjk3LS4wNDQuNTkyLS4wMjYuMjY4LS4wMTJjLjI5Ny0uMDEzLjU3OS0uMTM3Ljc5LS4zNDdsNy43Ny03Ljc3LjE0Ni4xNDRhLjc0Ljc0IDAgMCAwIDEuMDQ4IDBjLjI5LS4yOS4yOS0uNzU5IDAtMS4wNDhsLjU0LS41NGMuNzgtLjc4Ljc4LTIuMDQ0IDAtMi44MjV6TTguNzk1IDcuMzMzbC0yLjczLjUxNSA0LjQ1Mi00LjQ1MiAxLjEwOCAxLjEwNy0yLjgzIDIuODN6TTIuMDggMTMuNjczYy0xLjE0OCAwLTIuMDguMjk1LTIuMDguNjYgMCAuMzYzLjkzMi42NTggMi4wOC42NTggMS4xNSAwIDIuMDgtLjI5NCAyLjA4LS42NTkgMC0uMzY0LS45My0uNjU5LTIuMDgtLjY1OXoiLz48L2c+PC9zdmc+", className: void 0, component: void 0, popupClassName: void 0, colors: ["rgb(97,189,109)", "rgb(26,188,156)", "rgb(84,172,210)", "rgb(44,130,201)", "rgb(147,101,184)", "rgb(71,85,119)", "rgb(204,204,204)", "rgb(65,168,95)", "rgb(0,168,133)", "rgb(61,142,185)", "rgb(41,105,176)", "rgb(85,57,130)", "rgb(40,50,78)", "rgb(0,0,0)", "rgb(247,218,100)", "rgb(251,160,38)", "rgb(235,107,86)", "rgb(226,80,65)", "rgb(163,143,132)", "rgb(239,239,239)", "rgb(255,255,255)", "rgb(250,197,28)", "rgb(243,121,52)", "rgb(209,72,65)", "rgb(184,49,47)", "rgb(124,112,107)", "rgb(209,213,216)"], title: void 0 }, link: { inDropdown: false, className: void 0, component: void 0, popupClassName: void 0, dropdownClassName: void 0, showOpenOptionOnHover: true, defaultTargetOption: "_self", options: ["link", "unlink"], link: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEzLjk2Ny45NUEzLjIyNiAzLjIyNiAwIDAgMCAxMS42Ny4wMDJjLS44NyAwLTEuNjg2LjMzNy0yLjI5Ny45NDhMNy4xMDUgMy4yMThBMy4yNDcgMy4yNDcgMCAwIDAgNi4yNCA2LjI0YTMuMjI1IDMuMjI1IDAgMCAwLTMuMDIyLjg2NUwuOTUgOS4zNzNhMy4yNTMgMy4yNTMgMCAwIDAgMCA0LjU5NCAzLjIyNiAzLjIyNiAwIDAgMCAyLjI5Ny45NDhjLjg3IDAgMS42ODYtLjMzNiAyLjI5OC0uOTQ4TDcuODEyIDExLjdhMy4yNDcgMy4yNDcgMCAwIDAgLjg2NS0zLjAyMyAzLjIyNSAzLjIyNSAwIDAgMCAzLjAyMi0uODY1bDIuMjY4LTIuMjY3YTMuMjUyIDMuMjUyIDAgMCAwIDAtNC41OTV6TTcuMTA1IDEwLjk5M0w0LjgzNyAxMy4yNmEyLjIzMyAyLjIzMyAwIDAgMS0xLjU5LjY1NSAyLjIzMyAyLjIzMyAwIDAgMS0xLjU5LS42NTUgMi4yNTIgMi4yNTIgMCAwIDEgMC0zLjE4bDIuMjY4LTIuMjY4YTIuMjMyIDIuMjMyIDAgMCAxIDEuNTktLjY1NWMuNDMgMCAuODQxLjEyIDEuMTk1LjM0M0w0Ljc3MiA5LjQzOGEuNS41IDAgMSAwIC43MDcuNzA3bDEuOTM5LTEuOTM4Yy41NDUuODY4LjQ0MiAyLjAzLS4zMTMgMi43ODV6bTYuMTU1LTYuMTU1bC0yLjI2OCAyLjI2N2EyLjIzMyAyLjIzMyAwIDAgMS0xLjU5LjY1NWMtLjQzMSAwLS44NDEtLjEyLTEuMTk1LS4zNDNsMS45MzgtMS45MzhhLjUuNSAwIDEgMC0uNzA3LS43MDdMNy40OTkgNi43MWEyLjI1MiAyLjI1MiAwIDAgMSAuMzEzLTIuNzg1bDIuMjY3LTIuMjY4YTIuMjMzIDIuMjMzIDAgMCAxIDEuNTktLjY1NSAyLjIzMyAyLjIzMyAwIDAgMSAyLjI0NiAyLjI0NWMwIC42MDMtLjIzMiAxLjE2OC0uNjU1IDEuNTl6IiBmaWxsPSIjMDAwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=", className: void 0, title: void 0 }, unlink: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTMuOTU2IDEuMDM3YTMuNTUgMy41NSAwIDAgMC01LjAxNCAwTDYuNDM2IDMuNTQ0YS41NDUuNTQ1IDAgMSAwIC43Ny43N2wyLjUwOC0yLjUwNmEyLjQzOCAyLjQzOCAwIDAgMSAxLjczNS0uNzE1Yy42NTggMCAxLjI3NS4yNTQgMS43MzYuNzE1LjQ2LjQ2MS43MTUgMS4wNzguNzE1IDEuNzM2IDAgLjY1OC0uMjU0IDEuMjc0LS43MTUgMS43MzVMOS45MDcgOC41NThhMi40NTggMi40NTggMCAwIDEtMy40NzIgMCAuNTQ1LjU0NSAwIDEgMC0uNzcxLjc3MSAzLjUzNCAzLjUzNCAwIDAgMCAyLjUwNyAxLjAzN2MuOTA4IDAgMS44MTYtLjM0NiAyLjUwNy0xLjAzN2wzLjI3OC0zLjI3OGEzLjUyIDMuNTIgMCAwIDAgMS4wMzUtMi41MDdjMC0uOTUtLjM2Ny0xLjg0LTEuMDM1LTIuNTA3eiIvPjxwYXRoIGQ9Ik03LjQgMTEuMDY1bC0yLjEyMiAyLjEyYTIuNDM3IDIuNDM3IDAgMCAxLTEuNzM1LjcxNiAyLjQzNyAyLjQzNyAwIDAgMS0xLjczNi0uNzE1IDIuNDU3IDIuNDU3IDAgMCAxIDAtMy40NzFsMy4wODYtMy4wODZhMi40MzggMi40MzggMCAwIDEgMS43MzUtLjcxNWMuNjU4IDAgMS4yNzUuMjU0IDEuNzM2LjcxNWEuNTQ1LjU0NSAwIDEgMCAuNzcxLS43NzEgMy41NSAzLjU1IDAgMCAwLTUuMDE0IDBMMS4wMzYgOC45NDRBMy41MiAzLjUyIDAgMCAwIDAgMTEuNDVjMCAuOTUuMzY3IDEuODQgMS4wMzUgMi41MDdhMy41MiAzLjUyIDAgMCAwIDIuNTA2IDEuMDM1Yy45NSAwIDEuODQtLjM2OCAyLjUwNy0xLjAzNWwyLjEyMi0yLjEyMWEuNTQ1LjU0NSAwIDAgMC0uNzcxLS43NzF6TTkuMjc0IDEyLjAwMmEuNTQ2LjU0NiAwIDAgMC0uNTQ2LjU0NXYxLjYzN2EuNTQ2LjU0NiAwIDAgMCAxLjA5MSAwdi0xLjYzN2EuNTQ1LjU0NSAwIDAgMC0uNTQ1LS41NDV6TTExLjIzIDExLjYxNmEuNTQ1LjU0NSAwIDEgMC0uNzcyLjc3MmwxLjE1NyAxLjE1NmEuNTQzLjU0MyAwIDAgMCAuNzcxIDAgLjU0NS41NDUgMCAwIDAgMC0uNzdsLTEuMTU2LTEuMTU4ek0xMi41MzcgOS44MkgxMC45YS41NDYuNTQ2IDAgMCAwIDAgMS4wOTFoMS42MzdhLjU0Ni41NDYgMCAwIDAgMC0xLjA5ek00LjkxIDMuNTQ3YS41NDYuNTQ2IDAgMCAwIC41NDUtLjU0NVYxLjM2NmEuNTQ2LjU0NiAwIDAgMC0xLjA5IDB2MS42MzZjMCAuMzAxLjI0NC41NDUuNTQ1LjU0NXpNMi44ODggMy45MzNhLjU0My41NDMgMCAwIDAgLjc3MSAwIC41NDUuNTQ1IDAgMCAwIDAtLjc3MUwyLjUwMiAyLjAwNWEuNTQ1LjU0NSAwIDEgMC0uNzcxLjc3bDEuMTU3IDEuMTU4ek0xLjYyOCA1LjczaDEuNjM2YS41NDYuNTQ2IDAgMCAwIDAtMS4wOTJIMS42MjhhLjU0Ni41NDYgMCAwIDAgMCAxLjA5MXoiLz48L2c+PC9zdmc+", className: void 0, title: void 0 }, linkCallback: void 0 }, emoji: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTciIHZpZXdCb3g9IjE1LjcyOSAyMi4wODIgMTcgMTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTI5LjcwOCAyNS4xMDRjLTMuMDIxLTMuMDIyLTcuOTM3LTMuMDIyLTEwLjk1OCAwLTMuMDIxIDMuMDItMy4wMiA3LjkzNiAwIDEwLjk1OCAzLjAyMSAzLjAyIDcuOTM3IDMuMDIgMTAuOTU4LS4wMDEgMy4wMi0zLjAyMSAzLjAyLTcuOTM2IDAtMTAuOTU3em0tLjg0NSAxMC4xMTJhNi41NiA2LjU2IDAgMCAxLTkuMjY4IDAgNi41NiA2LjU2IDAgMCAxIDAtOS4yNjcgNi41NiA2LjU2IDAgMCAxIDkuMjY4IDAgNi41NiA2LjU2IDAgMCAxIDAgOS4yNjd6bS03LjUyNC02LjczYS45MDYuOTA2IDAgMSAxIDEuODExIDAgLjkwNi45MDYgMCAwIDEtMS44MTEgMHptNC4xMDYgMGEuOTA2LjkwNiAwIDEgMSAxLjgxMiAwIC45MDYuOTA2IDAgMCAxLTEuODEyIDB6bTIuMTQxIDMuNzA4Yy0uNTYxIDEuMjk4LTEuODc1IDIuMTM3LTMuMzQ4IDIuMTM3LTEuNTA1IDAtMi44MjctLjg0My0zLjM2OS0yLjE0N2EuNDM4LjQzOCAwIDAgMSAuODEtLjMzNmMuNDA1Ljk3NiAxLjQxIDEuNjA3IDIuNTU5IDEuNjA3IDEuMTIzIDAgMi4xMjEtLjYzMSAyLjU0NC0xLjYwOGEuNDM4LjQzOCAwIDAgMSAuODA0LjM0N3oiLz48L3N2Zz4=", className: void 0, component: void 0, popupClassName: void 0, emojis: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], title: void 0 }, embedded: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuNzA4IDYuNjE1YS40MzYuNDM2IDAgMCAwLS41NDMuMjkxbC0xLjgzIDYuMDQ1YS40MzYuNDM2IDAgMCAwIC44MzMuMjUyTDcgNy4xNmEuNDM2LjQzNiAwIDAgMC0uMjktLjU0NHpNOC45MzEgNi42MTVhLjQzNi40MzYgMCAwIDAtLjU0My4yOTFsLTEuODMgNi4wNDVhLjQzNi40MzYgMCAwIDAgLjgzNC4yNTJsMS44My02LjA0NGEuNDM2LjQzNiAwIDAgMC0uMjktLjU0NHoiLz48cGF0aCBkPSJNMTYuNTY0IDBILjQzNkEuNDM2LjQzNiAwIDAgMCAwIC40MzZ2MTYuMTI4YzAgLjI0LjE5NS40MzYuNDM2LjQzNmgxNi4xMjhjLjI0IDAgLjQzNi0uMTk1LjQzNi0uNDM2Vi40MzZBLjQzNi40MzYgMCAwIDAgMTYuNTY0IDB6TTMuNDg3Ljg3MmgxMC4wMjZ2MS43NDNIMy40ODdWLjg3MnptLTIuNjE1IDBoMS43NDN2MS43NDNILjg3MlYuODcyem0xNS4yNTYgMTUuMjU2SC44NzJWMy40ODhoMTUuMjU2djEyLjY0em0wLTEzLjUxM2gtMS43NDNWLjg3MmgxLjc0M3YxLjc0M3oiLz48Y2lyY2xlIGN4PSI5My44NjciIGN5PSIyNDUuMDY0IiByPSIxMy4xMjgiIHRyYW5zZm9ybT0ibWF0cml4KC4wMzMyIDAgMCAuMDMzMiAwIDApIi8+PGNpcmNsZSBjeD0iOTMuODY3IiBjeT0iMzYwLjU5MiIgcj0iMTMuMTI4IiB0cmFuc2Zvcm09Im1hdHJpeCguMDMzMiAwIDAgLjAzMzIgMCAwKSIvPjxwYXRoIGQ9Ik0xNC4yNTQgMTIuNjQxSDEwLjJhLjQzNi40MzYgMCAwIDAgMCAuODcyaDQuMDU0YS40MzYuNDM2IDAgMCAwIDAtLjg3MnoiLz48L3N2Zz4=", className: void 0, component: void 0, popupClassName: void 0, embedCallback: void 0, defaultSize: { height: "auto", width: "auto" }, title: void 0 }, image: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuNzQxIDBILjI2Qy4xMTYgMCAwIC4xMzYgMCAuMzA0djEzLjM5MmMwIC4xNjguMTE2LjMwNC4yNTkuMzA0SDE0Ljc0Yy4xNDMgMCAuMjU5LS4xMzYuMjU5LS4zMDRWLjMwNEMxNSAuMTM2IDE0Ljg4NCAwIDE0Ljc0MSAwem0tLjI1OCAxMy4zOTFILjUxN1YuNjFoMTMuOTY2VjEzLjM5eiIvPjxwYXRoIGQ9Ik00LjEzOCA2LjczOGMuNzk0IDAgMS40NC0uNzYgMS40NC0xLjY5NXMtLjY0Ni0xLjY5NS0xLjQ0LTEuNjk1Yy0uNzk0IDAtMS40NC43Ni0xLjQ0IDEuNjk1IDAgLjkzNC42NDYgMS42OTUgMS40NCAxLjY5NXptMC0yLjc4MWMuNTA5IDAgLjkyMy40ODcuOTIzIDEuMDg2IDAgLjU5OC0uNDE0IDEuMDg2LS45MjMgMS4wODYtLjUwOSAwLS45MjMtLjQ4Ny0uOTIzLTEuMDg2IDAtLjU5OS40MTQtMS4wODYuOTIzLTEuMDg2ek0xLjgxIDEyLjE3NGMuMDYgMCAuMTIyLS4wMjUuMTcxLS4wNzZMNi4yIDcuNzI4bDIuNjY0IDMuMTM0YS4yMzIuMjMyIDAgMCAwIC4zNjYgMCAuMzQzLjM0MyAwIDAgMCAwLS40M0w3Ljk4NyA4Ljk2OWwyLjM3NC0zLjA2IDIuOTEyIDMuMTQyYy4xMDYuMTEzLjI3LjEwNS4zNjYtLjAyYS4zNDMuMzQzIDAgMCAwLS4wMTYtLjQzbC0zLjEwNC0zLjM0N2EuMjQ0LjI0NCAwIDAgMC0uMTg2LS4wOC4yNDUuMjQ1IDAgMCAwLS4xOC4xTDcuNjIyIDguNTM3IDYuMzk0IDcuMDk0YS4yMzIuMjMyIDAgMCAwLS4zNTQtLjAxM2wtNC40IDQuNTZhLjM0My4zNDMgMCAwIDAtLjAyNC40My4yNDMuMjQzIDAgMCAwIC4xOTQuMTAzeiIvPjwvZz48L3N2Zz4=", className: void 0, component: void 0, popupClassName: void 0, urlEnabled: true, uploadEnabled: true, previewImage: false, alignmentEnabled: true, uploadCallback: void 0, inputAccept: "image/gif,image/jpeg,image/jpg,image/png,image/svg", alt: { present: false, mandatory: false }, defaultSize: { height: "auto", width: "auto" }, title: void 0 }, remove: { icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNSIgaGVpZ2h0PSIxNSIgdmlld0JveD0iMCAwIDE2IDE2Ij48cGF0aCBkPSJNOC4xIDE0bDYuNC03LjJjLjYtLjcuNi0xLjgtLjEtMi41bC0yLjctMi43Yy0uMy0uNC0uOC0uNi0xLjMtLjZIOC42Yy0uNSAwLTEgLjItMS40LjZMLjUgOS4yYy0uNi43LS42IDEuOS4xIDIuNWwyLjcgMi43Yy4zLjQuOC42IDEuMy42SDE2di0xSDguMXptLTEuMy0uMXMwLS4xIDAgMGwtMi43LTIuN2MtLjQtLjQtLjQtLjkgMC0xLjNMNy41IDZoLTFsLTMgMy4zYy0uNi43LS42IDEuNy4xIDIuNEw1LjkgMTRINC42Yy0uMiAwLS40LS4xLS42LS4yTDEuMiAxMWMtLjMtLjMtLjMtLjggMC0xLjFMNC43IDZoMS44TDEwIDJoMUw3LjUgNmwzLjEgMy43LTMuNSA0Yy0uMS4xLS4yLjEtLjMuMnoiLz48L3N2Zz4=", className: void 0, component: void 0, title: void 0 }, history: { inDropdown: false, className: void 0, component: void 0, dropdownClassName: void 0, options: ["undo", "redo"], undo: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTcgMTQuODc1YzIuNjcyIDAgNC44NDYtMi4xNDUgNC44NDYtNC43ODEgMC0yLjYzNy0yLjE3NC00Ljc4MS00Ljg0Ni00Ljc4MVY4LjVMMS42MTUgNC4yNSA3IDB2My4xODhjMy44NiAwIDcgMy4wOTggNyA2LjkwNlMxMC44NiAxNyA3IDE3cy03LTMuMDk4LTctNi45MDZoMi4xNTRjMCAyLjYzNiAyLjE3NCA0Ljc4MSA0Ljg0NiA0Ljc4MXoiIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==", className: void 0, title: void 0 }, redo: { icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuNTA0IDEzLjk3N2E0LjQ5NyA0LjQ5NyAwIDAgMS00LjQ5Mi00LjQ5MiA0LjQ5NyA0LjQ5NyAwIDAgMSA0LjQ5Mi00LjQ5M3YyLjk5NWw0Ljk5LTMuOTkzTDYuNTA0IDB2Mi45OTVhNi40OTYgNi40OTYgMCAwIDAtNi40ODggNi40OWMwIDMuNTc4IDIuOTEgNi40OSA2LjQ4OCA2LjQ5YTYuNDk2IDYuNDk2IDAgMCAwIDYuNDg3LTYuNDloLTEuOTk2YTQuNDk3IDQuNDk3IDAgMCAxLTQuNDkxIDQuNDkyeiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9zdmc+", className: void 0, title: void 0 }, title: void 0 } }, Jo2 = { en: { "generic.add": "Add", "generic.cancel": "Cancel", "components.controls.blocktype.h1": "H1", "components.controls.blocktype.h2": "H2", "components.controls.blocktype.h3": "H3", "components.controls.blocktype.h4": "H4", "components.controls.blocktype.h5": "H5", "components.controls.blocktype.h6": "H6", "components.controls.blocktype.blockquote": "Blockquote", "components.controls.blocktype.code": "Code", "components.controls.blocktype.blocktype": "Block Type", "components.controls.blocktype.normal": "Normal", "components.controls.colorpicker.colorpicker": "Color Picker", "components.controls.colorpicker.text": "Text", "components.controls.colorpicker.background": "Highlight", "components.controls.embedded.embedded": "Embedded", "components.controls.embedded.embeddedlink": "Embedded Link", "components.controls.embedded.enterlink": "Enter link", "components.controls.emoji.emoji": "Emoji", "components.controls.fontfamily.fontfamily": "Font", "components.controls.fontsize.fontsize": "Font Size", "components.controls.history.history": "History", "components.controls.history.undo": "Undo", "components.controls.history.redo": "Redo", "components.controls.image.image": "Image", "components.controls.image.fileUpload": "File Upload", "components.controls.image.byURL": "URL", "components.controls.image.dropFileText": "Drop the file or click to upload", "components.controls.inline.bold": "Bold", "components.controls.inline.italic": "Italic", "components.controls.inline.underline": "Underline", "components.controls.inline.strikethrough": "Strikethrough", "components.controls.inline.monospace": "Monospace", "components.controls.inline.superscript": "Superscript", "components.controls.inline.subscript": "Subscript", "components.controls.link.linkTitle": "Link Title", "components.controls.link.linkTarget": "Link Target", "components.controls.link.linkTargetOption": "Open link in new window", "components.controls.link.link": "Link", "components.controls.link.unlink": "Unlink", "components.controls.list.list": "List", "components.controls.list.unordered": "Unordered", "components.controls.list.ordered": "Ordered", "components.controls.list.indent": "Indent", "components.controls.list.outdent": "Outdent", "components.controls.remove.remove": "Remove", "components.controls.textalign.textalign": "Text Align", "components.controls.textalign.left": "Left", "components.controls.textalign.center": "Center", "components.controls.textalign.right": "Right", "components.controls.textalign.justify": "Justify" }, fr: { "generic.add": "Ok", "generic.cancel": "Annuler", "components.controls.blocktype.h1": "Titre 1", "components.controls.blocktype.h2": "Titre 2", "components.controls.blocktype.h3": "Titre 3", "components.controls.blocktype.h4": "Titre 4", "components.controls.blocktype.h5": "Titre 5", "components.controls.blocktype.h6": "Titre 6", "components.controls.blocktype.blockquote": "Citation", "components.controls.blocktype.code": "Code", "components.controls.blocktype.blocktype": "Type bloc", "components.controls.blocktype.normal": "Normal", "components.controls.colorpicker.colorpicker": "Palette de couleur", "components.controls.colorpicker.text": "Texte", "components.controls.colorpicker.background": "Fond", "components.controls.embedded.embedded": "Embedded", "components.controls.embedded.embeddedlink": "Lien iFrame", "components.controls.embedded.enterlink": "Entrer le lien", "components.controls.emoji.emoji": "Emoji", "components.controls.fontfamily.fontfamily": "Police", "components.controls.fontsize.fontsize": "Taille de police", "components.controls.history.history": "Historique", "components.controls.history.undo": "Prcdent", "components.controls.history.redo": "Suivant", "components.controls.image.image": "Image", "components.controls.image.fileUpload": "Tlchargement", "components.controls.image.byURL": "URL", "components.controls.image.dropFileText": "Glisser une image ou cliquer pour tlcharger", "components.controls.inline.bold": "Gras", "components.controls.inline.italic": "Italique", "components.controls.inline.underline": "Souligner", "components.controls.inline.strikethrough": "Barrer", "components.controls.inline.monospace": "Monospace", "components.controls.inline.superscript": "Exposant", "components.controls.inline.subscript": "Indice", "components.controls.link.linkTitle": "Titre du lien", "components.controls.link.linkTarget": "Cible du lien", "components.controls.link.linkTargetOption": "Ouvrir le lien dans une nouvelle fentre", "components.controls.link.link": "Lier", "components.controls.link.unlink": "Dlier", "components.controls.list.list": "Liste", "components.controls.list.unordered": "Dsordonne", "components.controls.list.ordered": "Ordonne", "components.controls.list.indent": "Augmenter le retrait", "components.controls.list.outdent": "Diminuer le retrait", "components.controls.remove.remove": "Supprimer", "components.controls.textalign.textalign": "Alignement du texte", "components.controls.textalign.left": "Gauche", "components.controls.textalign.center": "Centre", "components.controls.textalign.right": "Droite", "components.controls.textalign.justify": "Justifier" }, zh: { "generic.add": "", "generic.cancel": "", "components.controls.blocktype.h1": "1", "components.controls.blocktype.h2": "2", "components.controls.blocktype.h3": "3", "components.controls.blocktype.h4": "4", "components.controls.blocktype.h5": "5", "components.controls.blocktype.h6": "6", "components.controls.blocktype.blockquote": "", "components.controls.blocktype.code": "", "components.controls.blocktype.blocktype": "", "components.controls.blocktype.normal": "", "components.controls.colorpicker.colorpicker": "", "components.controls.colorpicker.text": "", "components.controls.colorpicker.background": "", "components.controls.embedded.embedded": "", "components.controls.embedded.embeddedlink": "", "components.controls.embedded.enterlink": "", "components.controls.emoji.emoji": "", "components.controls.fontfamily.fontfamily": "", "components.controls.fontsize.fontsize": "", "components.controls.history.history": "", "components.controls.history.undo": "", "components.controls.history.redo": "", "components.controls.image.image": "", "components.controls.image.fileUpload": "", "components.controls.image.byURL": "", "components.controls.image.dropFileText": "", "components.controls.inline.bold": "", "components.controls.inline.italic": "", "components.controls.inline.underline": "", "components.controls.inline.strikethrough": "", "components.controls.inline.monospace": "", "components.controls.inline.superscript": "", "components.controls.inline.subscript": "", "components.controls.link.linkTitle": "", "components.controls.link.linkTarget": "", "components.controls.link.linkTargetOption": "", "components.controls.link.link": "", "components.controls.link.unlink": "", "components.controls.list.list": "", "components.controls.list.unordered": "", "components.controls.list.ordered": "", "components.controls.list.indent": "", "components.controls.list.outdent": "", "components.controls.remove.remove": "", "components.controls.textalign.textalign": "", "components.controls.textalign.left": "", "components.controls.textalign.center": "", "components.controls.textalign.right": "", "components.controls.textalign.justify": "" }, ru: { "generic.add": "", "generic.cancel": "", "components.controls.blocktype.h1": " 1", "components.controls.blocktype.h2": " 2", "components.controls.blocktype.h3": " 3", "components.controls.blocktype.h4": " 4", "components.controls.blocktype.h5": " 5", "components.controls.blocktype.h6": " 6", "components.controls.blocktype.blockquote": "", "components.controls.blocktype.code": "", "components.controls.blocktype.blocktype": "", "components.controls.blocktype.normal": "", "components.controls.colorpicker.colorpicker": " ", "components.controls.colorpicker.text": "", "components.controls.colorpicker.background": "", "components.controls.embedded.embedded": "", "components.controls.embedded.embeddedlink": "  iFrame", "components.controls.embedded.enterlink": " ", "components.controls.emoji.emoji": "", "components.controls.fontfamily.fontfamily": "", "components.controls.fontsize.fontsize": " ", "components.controls.history.history": "", "components.controls.history.undo": "", "components.controls.history.redo": "", "components.controls.image.image": "", "components.controls.image.fileUpload": "", "components.controls.image.byURL": "URL", "components.controls.image.dropFileText": "        ", "components.controls.inline.bold": "", "components.controls.inline.italic": "", "components.controls.inline.underline": "", "components.controls.inline.strikethrough": "", "components.controls.inline.monospace": "Monospace", "components.controls.inline.superscript": " ", "components.controls.inline.subscript": " ", "components.controls.link.linkTitle": "", "components.controls.link.linkTarget": " ", "components.controls.link.linkTargetOption": "   ", "components.controls.link.link": "", "components.controls.link.unlink": " ", "components.controls.list.list": "", "components.controls.list.unordered": "", "components.controls.list.ordered": "", "components.controls.list.indent": "", "components.controls.list.outdent": "", "components.controls.remove.remove": "", "components.controls.textalign.textalign": " ", "components.controls.textalign.left": "", "components.controls.textalign.center": " ", "components.controls.textalign.right": "", "components.controls.textalign.justify": "" }, pt: { "generic.add": "Ok", "generic.cancel": "Cancelar", "components.controls.blocktype.h1": "Ttulo 1", "components.controls.blocktype.h2": "Ttulo 2", "components.controls.blocktype.h3": "Ttulo 3", "components.controls.blocktype.h4": "Ttulo 4", "components.controls.blocktype.h5": "Ttulo 5", "components.controls.blocktype.h6": "Ttulo 6", "components.controls.blocktype.blockquote": "Citao", "components.controls.blocktype.code": "Code", "components.controls.blocktype.blocktype": "Estilo", "components.controls.blocktype.normal": "Normal", "components.controls.colorpicker.colorpicker": "Paleta de cores", "components.controls.colorpicker.text": "Texto", "components.controls.colorpicker.background": "Fundo", "components.controls.embedded.embedded": "Embarcado", "components.controls.embedded.embeddedlink": "Link embarcado", "components.controls.embedded.enterlink": "Coloque o link", "components.controls.emoji.emoji": "Emoji", "components.controls.fontfamily.fontfamily": "Fonte", "components.controls.fontsize.fontsize": "Tamanho da Fonte", "components.controls.history.history": "Histrico", "components.controls.history.undo": "Desfazer", "components.controls.history.redo": "Refazer", "components.controls.image.image": "Imagem", "components.controls.image.fileUpload": "Carregar arquivo", "components.controls.image.byURL": "URL", "components.controls.image.dropFileText": "Arraste uma imagem aqui ou clique para carregar", "components.controls.inline.bold": "Negrito", "components.controls.inline.italic": "Itlico", "components.controls.inline.underline": "Sublinhado", "components.controls.inline.strikethrough": "Strikethrough", "components.controls.inline.monospace": "Monospace", "components.controls.inline.superscript": "Sobrescrito", "components.controls.inline.subscript": "Subscrito", "components.controls.link.linkTitle": "Ttulo do link", "components.controls.link.linkTarget": "Alvo do link", "components.controls.link.linkTargetOption": "Abrir link em outra janela", "components.controls.link.link": "Adicionar Link", "components.controls.link.unlink": "Remover link", "components.controls.list.list": "Lista", "components.controls.list.unordered": "Sem ordeno", "components.controls.list.ordered": "Ordenada", "components.controls.list.indent": "Aumentar recuo", "components.controls.list.outdent": "Diminuir recuo", "components.controls.remove.remove": "Remover", "components.controls.textalign.textalign": "Alinhamento do texto", "components.controls.textalign.left": " Esquerda", "components.controls.textalign.center": "Centralizado", "components.controls.textalign.right": " Direita", "components.controls.textalign.justify": "Justificado" }, ko: { "generic.add": "", "generic.cancel": "", "components.controls.blocktype.h1": "1", "components.controls.blocktype.h2": "2", "components.controls.blocktype.h3": "3", "components.controls.blocktype.h4": "4", "components.controls.blocktype.h5": "5", "components.controls.blocktype.h6": "6", "components.controls.blocktype.blockquote": "", "components.controls.blocktype.code": "Code", "components.controls.blocktype.blocktype": "", "components.controls.blocktype.normal": "", "components.controls.colorpicker.colorpicker": " ", "components.controls.colorpicker.text": "", "components.controls.colorpicker.background": "", "components.controls.embedded.embedded": "", "components.controls.embedded.embeddedlink": " ", "components.controls.embedded.enterlink": " ", "components.controls.emoji.emoji": "", "components.controls.fontfamily.fontfamily": "", "components.controls.fontsize.fontsize": " ", "components.controls.history.history": "", "components.controls.history.undo": " ", "components.controls.history.redo": " ", "components.controls.image.image": "", "components.controls.image.fileUpload": " ", "components.controls.image.byURL": "", "components.controls.image.dropFileText": "   ", "components.controls.inline.bold": "", "components.controls.inline.italic": "", "components.controls.inline.underline": "", "components.controls.inline.strikethrough": "", "components.controls.inline.monospace": " ", "components.controls.inline.superscript": " ", "components.controls.inline.subscript": " ", "components.controls.link.linkTitle": " ", "components.controls.link.linkTarget": " ", "components.controls.link.linkTargetOption": " ", "components.controls.link.link": "", "components.controls.link.unlink": " ", "components.controls.list.list": "", "components.controls.list.unordered": " ", "components.controls.list.ordered": " ", "components.controls.list.indent": "", "components.controls.list.outdent": "", "components.controls.remove.remove": "", "components.controls.textalign.textalign": " ", "components.controls.textalign.left": "", "components.controls.textalign.center": "", "components.controls.textalign.right": "", "components.controls.textalign.justify": "" }, it: { "generic.add": "Aggiungi", "generic.cancel": "Annulla", "components.controls.blocktype.h1": "H1", "components.controls.blocktype.h2": "H2", "components.controls.blocktype.h3": "H3", "components.controls.blocktype.h4": "H4", "components.controls.blocktype.h5": "H5", "components.controls.blocktype.h6": "H6", "components.controls.blocktype.blockquote": "Citazione", "components.controls.blocktype.code": "Codice", "components.controls.blocktype.blocktype": "Stili", "components.controls.blocktype.normal": "Normale", "components.controls.colorpicker.colorpicker": "Colore testo", "components.controls.colorpicker.text": "Testo", "components.controls.colorpicker.background": "Evidenziazione", "components.controls.embedded.embedded": "Incorpora", "components.controls.embedded.embeddedlink": "Incorpora link", "components.controls.embedded.enterlink": "Inserisci link", "components.controls.emoji.emoji": "Emoji", "components.controls.fontfamily.fontfamily": "Carattere", "components.controls.fontsize.fontsize": "Dimensione carattere", "components.controls.history.history": "Modifiche", "components.controls.history.undo": "Annulla", "components.controls.history.redo": "Ripristina", "components.controls.image.image": "Immagine", "components.controls.image.fileUpload": "Carica immagine", "components.controls.image.byURL": "URL", "components.controls.image.dropFileText": "Trascina il file o clicca per caricare", "components.controls.inline.bold": "Grassetto", "components.controls.inline.italic": "Corsivo", "components.controls.inline.underline": "Sottolineato", "components.controls.inline.strikethrough": "Barrato", "components.controls.inline.monospace": "Monospace", "components.controls.inline.superscript": "Apice", "components.controls.inline.subscript": "Pedice", "components.controls.link.linkTitle": "Testo", "components.controls.link.linkTarget": "Link", "components.controls.link.linkTargetOption": "Apri link in una nuova finestra", "components.controls.link.link": "Inserisci link", "components.controls.link.unlink": "Rimuovi link", "components.controls.list.list": "Lista", "components.controls.list.unordered": "Elenco puntato", "components.controls.list.ordered": "Elenco numerato", "components.controls.list.indent": "Indent", "components.controls.list.outdent": "Outdent", "components.controls.remove.remove": "Rimuovi formattazione", "components.controls.textalign.textalign": "Allineamento del testo", "components.controls.textalign.left": "Allinea a sinistra", "components.controls.textalign.center": "Allinea al centro", "components.controls.textalign.right": "Allinea a destra", "components.controls.textalign.justify": "Giustifica" }, nl: { "generic.add": "Toevoegen", "generic.cancel": "Annuleren", "components.controls.blocktype.h1": "H1", "components.controls.blocktype.h2": "H2", "components.controls.blocktype.h3": "H3", "components.controls.blocktype.h4": "H4", "components.controls.blocktype.h5": "H5", "components.controls.blocktype.h6": "H6", "components.controls.blocktype.blockquote": "Blockquote", "components.controls.blocktype.code": "Code", "components.controls.blocktype.blocktype": "Blocktype", "components.controls.blocktype.normal": "Normaal", "components.controls.colorpicker.colorpicker": "Kleurkiezer", "components.controls.colorpicker.text": "Tekst", "components.controls.colorpicker.background": "Achtergrond", "components.controls.embedded.embedded": "Ingevoegd", "components.controls.embedded.embeddedlink": "Ingevoegde link", "components.controls.embedded.enterlink": "Voeg link toe", "components.controls.emoji.emoji": "Emoji", "components.controls.fontfamily.fontfamily": "Lettertype", "components.controls.fontsize.fontsize": "Lettergrootte", "components.controls.history.history": "Geschiedenis", "components.controls.history.undo": "Ongedaan maken", "components.controls.history.redo": "Opnieuw", "components.controls.image.image": "Afbeelding", "components.controls.image.fileUpload": "Bestand uploaden", "components.controls.image.byURL": "URL", "components.controls.image.dropFileText": "Drop het bestand hier of klik om te uploaden", "components.controls.inline.bold": "Dikgedrukt", "components.controls.inline.italic": "Schuingedrukt", "components.controls.inline.underline": "Onderstrepen", "components.controls.inline.strikethrough": "Doorstrepen", "components.controls.inline.monospace": "Monospace", "components.controls.inline.superscript": "Superscript", "components.controls.inline.subscript": "Subscript", "components.controls.link.linkTitle": "Linktitel", "components.controls.link.linkTarget": "Link bestemming", "components.controls.link.linkTargetOption": "Open link in een nieuw venster", "components.controls.link.link": "Link", "components.controls.link.unlink": "Unlink", "components.controls.list.list": "Lijst", "components.controls.list.unordered": "Ongeordend", "components.controls.list.ordered": "Geordend", "components.controls.list.indent": "Inspringen", "components.controls.list.outdent": "Inspringen verkleinen", "components.controls.remove.remove": "Verwijderen", "components.controls.textalign.textalign": "Tekst uitlijnen", "components.controls.textalign.left": "Links", "components.controls.textalign.center": "Gecentreerd", "components.controls.textalign.right": "Rechts", "components.controls.textalign.justify": "Uitgelijnd" }, de: { "generic.add": "Hinzufgen", "generic.cancel": "Abbrechen", "components.controls.blocktype.h1": "berschrift 1", "components.controls.blocktype.h2": "berschrift 2", "components.controls.blocktype.h3": "berschrift 3", "components.controls.blocktype.h4": "berschrift 4", "components.controls.blocktype.h5": "berschrift 5", "components.controls.blocktype.h6": "berschrift 6", "components.controls.blocktype.blockquote": "Zitat", "components.controls.blocktype.code": "Quellcode", "components.controls.blocktype.blocktype": "Blocktyp", "components.controls.blocktype.normal": "Normal", "components.controls.colorpicker.colorpicker": "Farbauswahl", "components.controls.colorpicker.text": "Text", "components.controls.colorpicker.background": "Hintergrund", "components.controls.embedded.embedded": "Eingebettet", "components.controls.embedded.embeddedlink": "Eingebetteter Link", "components.controls.embedded.enterlink": "Link eingeben", "components.controls.emoji.emoji": "Emoji", "components.controls.fontfamily.fontfamily": "Schriftart", "components.controls.fontsize.fontsize": "Schriftgre", "components.controls.history.history": "Historie", "components.controls.history.undo": "Zurcknehmen", "components.controls.history.redo": "Wiederholen", "components.controls.image.image": "Bild", "components.controls.image.fileUpload": "Datei-Upload", "components.controls.image.byURL": "URL", "components.controls.image.dropFileText": "Dateien ziehen und ablegen, oder klicken zum Hochladen", "components.controls.inline.bold": "Fett", "components.controls.inline.italic": "Kursiv", "components.controls.inline.underline": "Unterstreichen", "components.controls.inline.strikethrough": "Durchstreichen", "components.controls.inline.monospace": "Monospace", "components.controls.inline.superscript": "Hochgestellt", "components.controls.inline.subscript": "Tiefgestellt", "components.controls.link.linkTitle": "Link-Titel", "components.controls.link.linkTarget": "Link-Ziel", "components.controls.link.linkTargetOption": "Link in neuem Fenster ffnen", "components.controls.link.link": "Link", "components.controls.link.unlink": "Aufheben", "components.controls.list.list": "Liste", "components.controls.list.unordered": "Aufzhlung", "components.controls.list.ordered": "Nummerierte Liste", "components.controls.list.indent": "Einzug vergrern", "components.controls.list.outdent": "Einzug reduzieren", "components.controls.remove.remove": "Entfernen", "components.controls.textalign.textalign": "Textausrichtung", "components.controls.textalign.left": "Linksbndig", "components.controls.textalign.center": "Zentrieren", "components.controls.textalign.right": "Rechtsbndig", "components.controls.textalign.justify": "Blocksatz" }, da: { "generic.add": "Tilfj", "generic.cancel": "Annuller", "components.controls.blocktype.h1": "Overskrift 1", "components.controls.blocktype.h2": "Overskrift 2", "components.controls.blocktype.h3": "Overskrift 3", "components.controls.blocktype.h4": "Overskrift 4", "components.controls.blocktype.h5": "Overskrift 5", "components.controls.blocktype.h6": "Overskrift 6", "components.controls.blocktype.blockquote": "Blokcitat", "components.controls.blocktype.code": "Kode", "components.controls.blocktype.blocktype": "Blok Type", "components.controls.blocktype.normal": "Normal", "components.controls.colorpicker.colorpicker": "Farver", "components.controls.colorpicker.text": "Tekst", "components.controls.colorpicker.background": "Baggrund", "components.controls.embedded.embedded": "Indlejre", "components.controls.embedded.embeddedlink": "Indlejre Link", "components.controls.embedded.enterlink": "Indtast link", "components.controls.emoji.emoji": "Emoji", "components.controls.fontfamily.fontfamily": "Fonttype", "components.controls.fontsize.fontsize": "Fontstrrelser", "components.controls.history.history": "Historie", "components.controls.history.undo": "Fortryd", "components.controls.history.redo": "Gendan", "components.controls.image.image": "Billede", "components.controls.image.fileUpload": "Filoverfrsel", "components.controls.image.byURL": "URL", "components.controls.image.dropFileText": "Drop filen eller klik for at uploade", "components.controls.inline.bold": "Fed", "components.controls.inline.italic": "Kursiv", "components.controls.inline.underline": "Understrege", "components.controls.inline.strikethrough": "Gennemstreget", "components.controls.inline.monospace": "Monospace", "components.controls.inline.superscript": "Hvet", "components.controls.inline.subscript": "Snket", "components.controls.link.linkTitle": "Link Titel", "components.controls.link.linkTarget": "Link Ml", "components.controls.link.linkTargetOption": "bn link i nyt vindue", "components.controls.link.link": "Link", "components.controls.link.unlink": "Fjern link", "components.controls.list.list": "Liste", "components.controls.list.unordered": "Uordnet", "components.controls.list.ordered": "Ordnet", "components.controls.list.indent": "Indrykning", "components.controls.list.outdent": "Udrykning", "components.controls.remove.remove": "Fjern", "components.controls.textalign.textalign": "Tekstjustering", "components.controls.textalign.left": "Venstre", "components.controls.textalign.center": "Center", "components.controls.textalign.right": "Hjre", "components.controls.textalign.justify": "Margener" }, zh_tw: { "generic.add": "", "generic.cancel": "", "components.controls.blocktype.h1": "1", "components.controls.blocktype.h2": "2", "components.controls.blocktype.h3": "3", "components.controls.blocktype.h4": "4", "components.controls.blocktype.h5": "5", "components.controls.blocktype.h6": "6", "components.controls.blocktype.blockquote": "", "components.controls.blocktype.code": "", "components.controls.blocktype.blocktype": "", "components.controls.blocktype.normal": "", "components.controls.colorpicker.colorpicker": "", "components.controls.colorpicker.text": "", "components.controls.colorpicker.background": "", "components.controls.embedded.embedded": "", "components.controls.embedded.embeddedlink": "", "components.controls.embedded.enterlink": "", "components.controls.emoji.emoji": "", "components.controls.fontfamily.fontfamily": "", "components.controls.fontsize.fontsize": "", "components.controls.history.history": "", "components.controls.history.undo": "", "components.controls.history.redo": "", "components.controls.image.image": "", "components.controls.image.fileUpload": "", "components.controls.image.byURL": "", "components.controls.image.dropFileText": "", "components.controls.inline.bold": "", "components.controls.inline.italic": "", "components.controls.inline.underline": "", "components.controls.inline.strikethrough": "", "components.controls.inline.monospace": "", "components.controls.inline.superscript": "", "components.controls.inline.subscript": "", "components.controls.link.linkTitle": "", "components.controls.link.linkTarget": "", "components.controls.link.linkTargetOption": "", "components.controls.link.link": "", "components.controls.link.unlink": "", "components.controls.list.list": "", "components.controls.list.unordered": "", "components.controls.list.ordered": "", "components.controls.list.indent": "", "components.controls.list.outdent": "", "components.controls.remove.remove": "", "components.controls.textalign.textalign": "", "components.controls.textalign.left": "", "components.controls.textalign.center": "", "components.controls.textalign.right": "", "components.controls.textalign.justify": "" }, pl: { "generic.add": "Dodaj", "generic.cancel": "Anuluj", "components.controls.blocktype.h1": "Nagwek 1", "components.controls.blocktype.h2": "Nagwek 2", "components.controls.blocktype.h3": "Nagwek 3", "components.controls.blocktype.h4": "Nagwek 4", "components.controls.blocktype.h5": "Nagwek 5", "components.controls.blocktype.h6": "Nagwek 6", "components.controls.blocktype.blockquote": "Cytat", "components.controls.blocktype.code": "Kod", "components.controls.blocktype.blocktype": "Format", "components.controls.blocktype.normal": "Normalny", "components.controls.colorpicker.colorpicker": "Kolor", "components.controls.colorpicker.text": "Tekst", "components.controls.colorpicker.background": "To", "components.controls.embedded.embedded": "Osad", "components.controls.embedded.embeddedlink": "Osad odnonik", "components.controls.embedded.enterlink": "Wprowad odnonik", "components.controls.emoji.emoji": "Emoji", "components.controls.fontfamily.fontfamily": "Krj czcionki", "components.controls.fontsize.fontsize": "Rozmiar czcionki", "components.controls.history.history": "Historia", "components.controls.history.undo": "Cofnij", "components.controls.history.redo": "Ponw", "components.controls.image.image": "Obrazek", "components.controls.image.fileUpload": "Przelij plik", "components.controls.image.byURL": "URL", "components.controls.image.dropFileText": "Upu plik lub kliknij, aby przesa", "components.controls.inline.bold": "Pogrubienie", "components.controls.inline.italic": "Kursywa", "components.controls.inline.underline": "Podkrelenie", "components.controls.inline.strikethrough": "Przekrelenie", "components.controls.inline.monospace": "Monospace", "components.controls.inline.superscript": "Indeks grny", "components.controls.inline.subscript": "Indeks dolny", "components.controls.link.linkTitle": "Tytu odnonika", "components.controls.link.linkTarget": "Adres odnonika", "components.controls.link.linkTargetOption": "Otwrz odnonik w nowej karcie", "components.controls.link.link": "Wstaw odnonik", "components.controls.link.unlink": "Usu odnonik", "components.controls.list.list": "Lista", "components.controls.list.unordered": "Lista nieuporzdkowana", "components.controls.list.ordered": "Lista uporzdkowana", "components.controls.list.indent": "Zwiksz wcicie", "components.controls.list.outdent": "Zmniejsz wcicie", "components.controls.remove.remove": "Usu", "components.controls.textalign.textalign": "Wyrwnaj tekst", "components.controls.textalign.left": "Do lewej", "components.controls.textalign.center": "Do rodka", "components.controls.textalign.right": "Do prawej", "components.controls.textalign.justify": "Wyjustuj" }, es: { "generic.add": "Aadir", "generic.cancel": "Cancelar", "components.controls.blocktype.h1": "H1", "components.controls.blocktype.h2": "H2", "components.controls.blocktype.h3": "H3", "components.controls.blocktype.h4": "H4", "components.controls.blocktype.h5": "H5", "components.controls.blocktype.h6": "H6", "components.controls.blocktype.blockquote": "Blockquote", "components.controls.blocktype.code": "Cdigo", "components.controls.blocktype.blocktype": "Tipo de bloque", "components.controls.blocktype.normal": "Normal", "components.controls.colorpicker.colorpicker": "Seleccionar color", "components.controls.colorpicker.text": "Texto", "components.controls.colorpicker.background": "Subrayado", "components.controls.embedded.embedded": "Adjuntar", "components.controls.embedded.embeddedlink": "Adjuntar Link", "components.controls.embedded.enterlink": "Introducir link", "components.controls.emoji.emoji": "Emoji", "components.controls.fontfamily.fontfamily": "Fuente", "components.controls.fontsize.fontsize": "Tamao de fuente", "components.controls.history.history": "Histrico", "components.controls.history.undo": "Deshacer", "components.controls.history.redo": "Rehacer", "components.controls.image.image": "Imagen", "components.controls.image.fileUpload": "Subir archivo", "components.controls.image.byURL": "URL", "components.controls.image.dropFileText": "Arrastra el archivo o haz click para subirlo", "components.controls.inline.bold": "Negrita", "components.controls.inline.italic": "Cursiva", "components.controls.inline.underline": "Subrayado", "components.controls.inline.strikethrough": "Tachado", "components.controls.inline.monospace": "Monospace", "components.controls.inline.superscript": "Sobrendice", "components.controls.inline.subscript": "Subndice", "components.controls.link.linkTitle": "Ttulo del enlace", "components.controls.link.linkTarget": "Objetivo del enlace", "components.controls.link.linkTargetOption": "Abrir en nueva ventana", "components.controls.link.link": "Enlazar", "components.controls.link.unlink": "Desenlazar", "components.controls.list.list": "Lista", "components.controls.list.unordered": "Desordenada", "components.controls.list.ordered": "Ordenada", "components.controls.list.indent": "Indentada", "components.controls.list.outdent": "Dentada", "components.controls.remove.remove": "Eliminar", "components.controls.textalign.textalign": "Alineacin del texto", "components.controls.textalign.left": "Izquierda", "components.controls.textalign.center": "Centrado", "components.controls.textalign.right": "Derecha", "components.controls.textalign.justify": "Justificado" }, ja: { "generic.add": "", "generic.cancel": "", "components.controls.blocktype.h1": "1", "components.controls.blocktype.h2": "2", "components.controls.blocktype.h3": "3", "components.controls.blocktype.h4": "4", "components.controls.blocktype.h5": "5", "components.controls.blocktype.h6": "6", "components.controls.blocktype.blockquote": "", "components.controls.blocktype.code": "", "components.controls.blocktype.blocktype": "", "components.controls.blocktype.normal": "", "components.controls.colorpicker.colorpicker": "", "components.controls.colorpicker.text": "", "components.controls.colorpicker.background": "", "components.controls.embedded.embedded": "", "components.controls.embedded.embeddedlink": "", "components.controls.embedded.enterlink": "", "components.controls.emoji.emoji": "", "components.controls.fontfamily.fontfamily": "", "components.controls.fontsize.fontsize": "", "components.controls.history.history": "", "components.controls.history.undo": "", "components.controls.history.redo": "", "components.controls.image.image": "", "components.controls.image.fileUpload": "", "components.controls.image.byURL": "URL", "components.controls.image.dropFileText": "", "components.controls.inline.bold": "", "components.controls.inline.italic": "", "components.controls.inline.underline": "", "components.controls.inline.strikethrough": "", "components.controls.inline.monospace": "", "components.controls.inline.superscript": "", "components.controls.inline.subscript": "", "components.controls.link.linkTitle": "", "components.controls.link.linkTarget": "", "components.controls.link.linkTargetOption": "", "components.controls.link.link": "", "components.controls.link.unlink": "", "components.controls.list.list": "", "components.controls.list.unordered": "", "components.controls.list.ordered": "", "components.controls.list.indent": "", "components.controls.list.outdent": "", "components.controls.remove.remove": "", "components.controls.textalign.textalign": "", "components.controls.textalign.left": "", "components.controls.textalign.center": "", "components.controls.textalign.right": "", "components.controls.textalign.justify": "" } };
        n3(38), n3(39);
        function Vo2(t3) {
          return (Vo2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function qo2() {
          return (qo2 = Object.assign ? Object.assign.bind() : function(t3) {
            for (var e3 = 1; e3 < arguments.length; e3++) {
              var n4 = arguments[e3];
              for (var o4 in n4) Object.prototype.hasOwnProperty.call(n4, o4) && (t3[o4] = n4[o4]);
            }
            return t3;
          }).apply(this, arguments);
        }
        function Ko2(e3, t3) {
          var n4 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var o4 = Object.getOwnPropertySymbols(e3);
            t3 && (o4 = o4.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n4.push.apply(n4, o4);
          }
          return n4;
        }
        function Xo2(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n4 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Ko2(Object(n4), true).forEach(function(t4) {
              $o2(e3, t4, n4[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n4)) : Ko2(Object(n4)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n4, t4));
            });
          }
          return e3;
        }
        function $o2(t3, e3, n4) {
          return e3 in t3 ? Object.defineProperty(t3, e3, { value: n4, enumerable: true, configurable: true, writable: true }) : t3[e3] = n4, t3;
        }
        function tr2(t3) {
          return (function(t4) {
            if (Array.isArray(t4)) return er2(t4);
          })(t3) || (function(t4) {
            if ("undefined" != typeof Symbol && null != t4[Symbol.iterator] || null != t4["@@iterator"]) return Array.from(t4);
          })(t3) || (function(t4, e3) {
            if (!t4) return;
            if ("string" == typeof t4) return er2(t4, e3);
            var n4 = Object.prototype.toString.call(t4).slice(8, -1);
            "Object" === n4 && t4.constructor && (n4 = t4.constructor.name);
            if ("Map" === n4 || "Set" === n4) return Array.from(t4);
            if ("Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4)) return er2(t4, e3);
          })(t3) || (function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          })();
        }
        function er2(t3, e3) {
          (null == e3 || e3 > t3.length) && (e3 = t3.length);
          for (var n4 = 0, o4 = new Array(e3); n4 < e3; n4++) o4[n4] = t3[n4];
          return o4;
        }
        function nr2(t3, e3) {
          for (var n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3[n4];
            o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(t3, o4.key, o4);
          }
        }
        function or2(t3, e3) {
          return (or2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
            return t4.__proto__ = e4, t4;
          })(t3, e3);
        }
        function rr2(o4) {
          var r4 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          })();
          return function() {
            var t3, e3 = ir2(o4);
            if (r4) {
              var n4 = ir2(this).constructor;
              t3 = Reflect.construct(e3, arguments, n4);
            } else t3 = e3.apply(this, arguments);
            return (function(t4, e4) {
              {
                if (e4 && ("object" === Vo2(e4) || "function" == typeof e4)) return e4;
                if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
              }
              return (function(t5) {
                if (void 0 !== t5) return t5;
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              })(t4);
            })(this, t3);
          };
        }
        function ir2(t3) {
          return (ir2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          })(t3);
        }
        var cr2 = (function() {
          !(function(t4, e4) {
            if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && or2(t4, e4);
          })(i3, f2["Component"]);
          var t3, e3, r4 = rr2(i3);
          function i3(t4) {
            var c4;
            !(function(t5, e5) {
              if (!(t5 instanceof e5)) throw new TypeError("Cannot call a class as a function");
            })(this, i3), (c4 = r4.call(this, t4)).onEditorBlur = function() {
              c4.setState({ editorFocused: false });
            }, c4.onEditorFocus = function(t5) {
              var e5 = c4.props.onFocus;
              c4.setState({ editorFocused: true });
              var n5 = c4.focusHandler.isEditorFocused();
              e5 && n5 && e5(t5);
            }, c4.onEditorMouseDown = function() {
              c4.focusHandler.onEditorMouseDown();
            }, c4.keyBindingFn = function(t5) {
              if ("Tab" !== t5.key) return "ArrowUp" !== t5.key && "ArrowDown" !== t5.key || b2() && t5.preventDefault(), Object(E2.getDefaultKeyBinding)(t5);
              var e5 = c4.props.onTab;
              if (!e5 || !e5(t5)) {
                var n5 = Object(S2.changeDepth)(c4.state.editorState, t5.shiftKey ? -1 : 1, 4);
                n5 && n5 !== c4.state.editorState && (c4.onChange(n5), t5.preventDefault());
              }
              return null;
            }, c4.onToolbarFocus = function(t5) {
              var e5 = c4.props.onFocus;
              e5 && c4.focusHandler.isToolbarFocused() && e5(t5);
            }, c4.onWrapperBlur = function(t5) {
              var e5 = c4.props.onBlur;
              e5 && c4.focusHandler.isEditorBlur(t5) && e5(t5, c4.getEditorState());
            }, c4.onChange = function(t5) {
              var e5 = c4.props, n5 = e5.readOnly, o5 = e5.onEditorStateChange;
              n5 || "atomic" === Object(S2.getSelectedBlocksType)(t5) && t5.getSelection().isCollapsed || (o5 && o5(t5, c4.props.wrapperId), M2(c4.props, "editorState") ? c4.afterChange(t5) : c4.setState({ editorState: t5 }, c4.afterChange(t5)));
            }, c4.setWrapperReference = function(t5) {
              c4.wrapper = t5;
            }, c4.setEditorReference = function(t5) {
              c4.props.editorRef && c4.props.editorRef(t5), c4.editor = t5;
            }, c4.getCompositeDecorator = function(t5) {
              var e5 = [].concat(tr2(c4.props.customDecorators), [{ strategy: Mo2, component: jo2({ showOpenOptionOnHover: t5.link.showOpenOptionOnHover }) }]);
              return c4.props.mention && e5.push.apply(e5, tr2(To2(Xo2(Xo2({}, c4.props.mention), {}, { onChange: c4.onChange, getEditorState: c4.getEditorState, getSuggestions: c4.getSuggestions, getWrapperRef: c4.getWrapperRef, modalHandler: c4.modalHandler })))), c4.props.hashtag && e5.push(Ro2(c4.props.hashtag)), new E2.CompositeDecorator(e5);
            }, c4.getWrapperRef = function() {
              return c4.wrapper;
            }, c4.getEditorState = function() {
              return c4.state ? c4.state.editorState : null;
            }, c4.getSuggestions = function() {
              return c4.props.mention && c4.props.mention.suggestions;
            }, c4.afterChange = function(o5) {
              setTimeout(function() {
                var t5 = c4.props, e5 = t5.onChange, n5 = t5.onContentStateChange;
                e5 && e5(Object(E2.convertToRaw)(o5.getCurrentContent())), n5 && n5(Object(E2.convertToRaw)(o5.getCurrentContent()));
              });
            }, c4.isReadOnly = function() {
              return c4.props.readOnly;
            }, c4.isImageAlignmentEnabled = function() {
              return c4.state.toolbar.image.alignmentEnabled;
            }, c4.createEditorState = function(t5) {
              var e5;
              if (M2(c4.props, "editorState")) c4.props.editorState && (e5 = E2.EditorState.set(c4.props.editorState, { decorator: t5 }));
              else if (M2(c4.props, "defaultEditorState")) c4.props.defaultEditorState && (e5 = E2.EditorState.set(c4.props.defaultEditorState, { decorator: t5 }));
              else if (M2(c4.props, "contentState")) {
                if (c4.props.contentState) {
                  var n5 = Object(E2.convertFromRaw)(c4.props.contentState);
                  e5 = E2.EditorState.createWithContent(n5, t5), e5 = E2.EditorState.moveSelectionToEnd(e5);
                }
              } else if (M2(c4.props, "defaultContentState") || M2(c4.props, "initialContentState")) {
                var o5 = c4.props.defaultContentState || c4.props.initialContentState;
                o5 && (o5 = Object(E2.convertFromRaw)(o5), e5 = E2.EditorState.createWithContent(o5, t5), e5 = E2.EditorState.moveSelectionToEnd(e5));
              }
              return e5 = e5 || E2.EditorState.createEmpty(t5);
            }, c4.filterEditorProps = function(t5) {
              return e5 = t5, n5 = ["onChange", "onEditorStateChange", "onContentStateChange", "initialContentState", "defaultContentState", "contentState", "editorState", "defaultEditorState", "locale", "localization", "toolbarOnFocus", "toolbar", "toolbarCustomButtons", "toolbarClassName", "editorClassName", "toolbarHidden", "wrapperClassName", "toolbarStyle", "editorStyle", "wrapperStyle", "uploadCallback", "onFocus", "onBlur", "onTab", "mention", "hashtag", "ariaLabel", "customBlockRenderFunc", "customDecorators", "handlePastedText", "customStyleMap"], o5 = Object.keys(e5).filter(function(t6) {
                return n5.indexOf(t6) < 0;
              }), r5 = {}, o5 && 0 < o5.length && o5.forEach(function(t6) {
                r5[t6] = e5[t6];
              }), r5;
              var e5, n5, o5, r5;
            }, c4.getStyleMap = function(t5) {
              return Xo2(Xo2({}, Object(S2.getCustomStyleMap)()), t5.customStyleMap);
            }, c4.changeEditorState = function(t5) {
              var e5 = Object(E2.convertFromRaw)(t5), n5 = c4.state.editorState;
              return n5 = E2.EditorState.push(n5, e5, "insert-characters"), n5 = E2.EditorState.moveSelectionToEnd(n5);
            }, c4.focusEditor = function() {
              setTimeout(function() {
                c4.editor.focus();
              });
            }, c4.handleKeyCommand = function(t5) {
              var e5 = c4.state, n5 = e5.editorState, o5 = e5.toolbar.inline;
              if (o5 && 0 <= o5.options.indexOf(t5)) {
                var r5 = E2.RichUtils.handleKeyCommand(n5, t5);
                if (r5) return c4.onChange(r5), true;
              }
              return false;
            }, c4.handleReturn = function(t5) {
              if (b2()) return true;
              var e5 = c4.state.editorState, n5 = Object(S2.handleNewLine)(e5, t5);
              return !!n5 && (c4.onChange(n5), true);
            }, c4.handlePastedTextFn = function(t5, e5) {
              var n5 = c4.state.editorState, o5 = c4.props, r5 = o5.handlePastedText, i4 = o5.stripPastedStyles;
              return r5 ? r5(t5, e5, n5, c4.onChange) : !i4 && (function(t6, e6, n6, o6) {
                var r6 = Object(S2.getSelectedBlock)(n6);
                if (r6 && "code" === r6.type) {
                  var i5 = E2.Modifier.replaceText(n6.getCurrentContent(), n6.getSelection(), t6, n6.getCurrentInlineStyle());
                  return o6(E2.EditorState.push(n6, i5, "insert-characters")), true;
                }
                if (e6) {
                  var c5 = O2()(e6), a4 = n6.getCurrentContent();
                  return c5.entityMap.forEach(function(t7, e7) {
                    a4 = a4.mergeEntityData(e7, t7);
                  }), a4 = E2.Modifier.replaceWithFragment(a4, n6.getSelection(), new x2.List(c5.contentBlocks)), o6(E2.EditorState.push(n6, a4, "insert-characters")), true;
                }
                return false;
              })(t5, e5, n5, c4.onChange);
            }, c4.preventDefault = function(t5) {
              "INPUT" === t5.target.tagName || "LABEL" === t5.target.tagName || "TEXTAREA" === t5.target.tagName ? c4.focusHandler.onInputMouseDown() : t5.preventDefault();
            };
            var e4 = D2(Go2, t4.toolbar), n4 = t4.wrapperId ? t4.wrapperId : Math.floor(1e4 * Math.random());
            c4.wrapperId = "rdw-wrapper-".concat(n4), c4.modalHandler = new a3(), c4.focusHandler = new p2(), c4.blockRendererFn = Wo2({ isReadOnly: c4.isReadOnly, isImageAlignmentEnabled: c4.isImageAlignmentEnabled, getEditorState: c4.getEditorState, onChange: c4.onChange }, t4.customBlockRenderFunc), c4.editorProps = c4.filterEditorProps(t4), c4.customStyleMap = c4.getStyleMap(t4), c4.compositeDecorator = c4.getCompositeDecorator(e4);
            var o4 = c4.createEditorState(c4.compositeDecorator);
            return Object(S2.extractInlineStyle)(o4), c4.state = { editorState: o4, editorFocused: false, toolbar: e4 }, c4;
          }
          return t3 = i3, (e3 = [{ key: "componentDidMount", value: function() {
            this.modalHandler.init(this.wrapperId);
          } }, { key: "componentDidUpdate", value: function(t4) {
            if (t4 !== this.props) {
              var e4 = {}, n4 = this.props, o4 = n4.editorState, r5 = n4.contentState;
              if (!this.state.toolbar) {
                var i4 = D2(Go2, i4);
                e4.toolbar = i4;
              }
              if (M2(this.props, "editorState") && o4 !== t4.editorState) e4.editorState = o4 ? E2.EditorState.set(o4, { decorator: this.compositeDecorator }) : E2.EditorState.createEmpty(this.compositeDecorator);
              else if (M2(this.props, "contentState") && r5 !== t4.contentState) if (r5) {
                var c4 = this.changeEditorState(r5);
                c4 && (e4.editorState = c4);
              } else e4.editorState = E2.EditorState.createEmpty(this.compositeDecorator);
              t4.editorState === o4 && t4.contentState === r5 || Object(S2.extractInlineStyle)(e4.editorState), Object.keys(e4).length && this.setState(e4), this.editorProps = this.filterEditorProps(this.props), this.customStyleMap = this.getStyleMap(this.props);
            }
          } }, { key: "render", value: function() {
            var t4 = this.state, e4 = t4.editorState, n4 = t4.editorFocused, r5 = t4.toolbar, o4 = this.props, i4 = o4.locale, c4 = o4.localization, a4 = c4.locale, l2 = c4.translations, s3 = o4.toolbarCustomButtons, u3 = o4.toolbarOnFocus, p3 = o4.toolbarClassName, d3 = o4.toolbarHidden, f3 = o4.editorClassName, y3 = o4.wrapperClassName, m3 = o4.toolbarStyle, g3 = o4.editorStyle, b3 = o4.wrapperStyle, h3 = o4.uploadCallback, M3 = o4.ariaLabel, j3 = { modalHandler: this.modalHandler, editorState: e4, onChange: this.onChange, translations: Xo2(Xo2({}, Jo2[i4 || a4]), l2) }, v3 = n4 || this.focusHandler.isInputFocused() || !u3;
            return N2.a.createElement("div", { id: this.wrapperId, className: w2()(y3, "rdw-editor-wrapper"), style: b3, onClick: this.modalHandler.onEditorClick, onBlur: this.onWrapperBlur, "aria-label": "rdw-wrapper" }, !d3 && N2.a.createElement("div", { className: w2()("rdw-editor-toolbar", p3), style: Xo2({ visibility: v3 ? "visible" : "hidden" }, m3), onMouseDown: this.preventDefault, "aria-label": "rdw-toolbar", "aria-hidden": (!n4 && u3).toString(), onFocus: this.onToolbarFocus }, r5.options.map(function(t5, e5) {
              var n5 = so2[t5], o5 = r5[t5];
              return "image" === t5 && h3 && (o5.uploadCallback = h3), N2.a.createElement(n5, qo2({ key: e5 }, j3, { config: o5 }));
            }), s3 && s3.map(function(t5, e5) {
              return N2.a.cloneElement(t5, Xo2({ key: e5 }, j3));
            })), N2.a.createElement("div", { ref: this.setWrapperReference, className: w2()(f3, "rdw-editor-main"), style: g3, onClick: this.focusEditor, onFocus: this.onEditorFocus, onBlur: this.onEditorBlur, onKeyDown: C.onKeyDown, onMouseDown: this.onEditorMouseDown }, N2.a.createElement(E2.Editor, qo2({ ref: this.setEditorReference, keyBindingFn: this.keyBindingFn, editorState: e4, onChange: this.onChange, blockStyleFn: L, customStyleMap: this.getStyleMap(this.props), handleReturn: this.handleReturn, handlePastedText: this.handlePastedTextFn, blockRendererFn: this.blockRendererFn, handleKeyCommand: this.handleKeyCommand, ariaLabel: M3 || "rdw-editor", blockRenderMap: S2.blockRenderMap }, this.editorProps))));
          } }]) && nr2(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), i3;
        })();
        cr2.propTypes = { onChange: y2.a.func, onEditorStateChange: y2.a.func, onContentStateChange: y2.a.func, initialContentState: y2.a.object, defaultContentState: y2.a.object, contentState: y2.a.object, editorState: y2.a.object, defaultEditorState: y2.a.object, toolbarOnFocus: y2.a.bool, spellCheck: y2.a.bool, stripPastedStyles: y2.a.bool, toolbar: y2.a.object, toolbarCustomButtons: y2.a.array, toolbarClassName: y2.a.string, toolbarHidden: y2.a.bool, locale: y2.a.string, localization: y2.a.object, editorClassName: y2.a.string, wrapperClassName: y2.a.string, toolbarStyle: y2.a.object, editorStyle: y2.a.object, wrapperStyle: y2.a.object, uploadCallback: y2.a.func, onFocus: y2.a.func, onBlur: y2.a.func, onTab: y2.a.func, mention: y2.a.object, hashtag: y2.a.object, textAlignment: y2.a.string, readOnly: y2.a.bool, tabIndex: y2.a.number, placeholder: y2.a.string, ariaLabel: y2.a.string, ariaOwneeID: y2.a.string, ariaActiveDescendantID: y2.a.string, ariaAutoComplete: y2.a.string, ariaDescribedBy: y2.a.string, ariaExpanded: y2.a.string, ariaHasPopup: y2.a.string, customBlockRenderFunc: y2.a.func, wrapperId: y2.a.number, customDecorators: y2.a.array, editorRef: y2.a.func, handlePastedText: y2.a.func }, cr2.defaultProps = { toolbarOnFocus: false, toolbarHidden: false, stripPastedStyles: false, localization: { locale: "en", translations: {} }, customDecorators: [] };
        var ar2 = cr2;
      }], i2.c = a2, i2.d = function(t2, e2, n3) {
        i2.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n3 });
      }, i2.r = function(t2) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      }, i2.t = function(e2, t2) {
        if (1 & t2 && (e2 = i2(e2)), 8 & t2) return e2;
        if (4 & t2 && "object" == typeof e2 && e2 && e2.__esModule) return e2;
        var n3 = /* @__PURE__ */ Object.create(null);
        if (i2.r(n3), Object.defineProperty(n3, "default", { enumerable: true, value: e2 }), 2 & t2 && "string" != typeof e2) for (var o3 in e2) i2.d(n3, o3, (function(t3) {
          return e2[t3];
        }).bind(null, o3));
        return n3;
      }, i2.n = function(t2) {
        var e2 = t2 && t2.__esModule ? function() {
          return t2.default;
        } : function() {
          return t2;
        };
        return i2.d(e2, "a", e2), e2;
      }, i2.o = function(t2, e2) {
        return Object.prototype.hasOwnProperty.call(t2, e2);
      }, i2.p = "", i2(i2.s = 8);
      function i2(t2) {
        if (a2[t2]) return a2[t2].exports;
        var e2 = a2[t2] = { i: t2, l: false, exports: {} };
        return c2[t2].call(e2.exports, e2, e2.exports, i2), e2.l = true, e2.exports;
      }
      var c2, a2;
    });
  })(reactDraftWysiwyg);
  return reactDraftWysiwyg.exports;
}
var reactDraftWysiwygExports = requireReactDraftWysiwyg();
var draftjsToHtml$1 = { exports: {} };
var draftjsToHtml = draftjsToHtml$1.exports;
var hasRequiredDraftjsToHtml;
function requireDraftjsToHtml() {
  if (hasRequiredDraftjsToHtml) return draftjsToHtml$1.exports;
  hasRequiredDraftjsToHtml = 1;
  (function(module, exports) {
    (function(global, factory) {
      module.exports = factory();
    })(draftjsToHtml, (function() {
      function forEach3(obj, callback) {
        if (obj) {
          for (var key in obj) {
            if ({}.hasOwnProperty.call(obj, key)) {
              callback(key, obj[key]);
            }
          }
        }
      }
      function isEmptyString(str) {
        if (str === void 0 || str === null || str.length === 0 || str.trim().length === 0) {
          return true;
        }
        return false;
      }
      var blockTypesMapping = {
        unstyled: "p",
        "header-one": "h1",
        "header-two": "h2",
        "header-three": "h3",
        "header-four": "h4",
        "header-five": "h5",
        "header-six": "h6",
        "unordered-list-item": "ul",
        "ordered-list-item": "ol",
        blockquote: "blockquote",
        code: "pre"
      };
      function getBlockTag(type) {
        return type && blockTypesMapping[type];
      }
      function getBlockStyle(data) {
        var styles2 = "";
        forEach3(data, function(key, value) {
          if (value) {
            styles2 += "".concat(key, ":").concat(value, ";");
          }
        });
        return styles2;
      }
      function getHashtagRanges(blockText, hashtagConfig) {
        var sections = [];
        if (hashtagConfig) {
          var counter = 0;
          var startIndex = 0;
          var text = blockText;
          var trigger = hashtagConfig.trigger || "#";
          var separator = hashtagConfig.separator || " ";
          for (; text.length > 0 && startIndex >= 0; ) {
            if (text[0] === trigger) {
              startIndex = 0;
              counter = 0;
              text = text.substr(trigger.length);
            } else {
              startIndex = text.indexOf(separator + trigger);
              if (startIndex >= 0) {
                text = text.substr(startIndex + (separator + trigger).length);
                counter += startIndex + separator.length;
              }
            }
            if (startIndex >= 0) {
              var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;
              var hashtag = text.substr(0, endIndex);
              if (hashtag && hashtag.length > 0) {
                sections.push({
                  offset: counter,
                  length: hashtag.length + trigger.length,
                  type: "HASHTAG"
                });
              }
              counter += trigger.length;
            }
          }
        }
        return sections;
      }
      function getSections(block, hashtagConfig) {
        var sections = [];
        var lastOffset = 0;
        var sectionRanges = block.entityRanges.map(function(range) {
          var offset = range.offset, length = range.length, key = range.key;
          return {
            offset,
            length,
            key,
            type: "ENTITY"
          };
        });
        sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));
        sectionRanges = sectionRanges.sort(function(s1, s2) {
          return s1.offset - s2.offset;
        });
        sectionRanges.forEach(function(r2) {
          if (r2.offset > lastOffset) {
            sections.push({
              start: lastOffset,
              end: r2.offset
            });
          }
          sections.push({
            start: r2.offset,
            end: r2.offset + r2.length,
            entityKey: r2.key,
            type: r2.type
          });
          lastOffset = r2.offset + r2.length;
        });
        if (lastOffset < block.text.length) {
          sections.push({
            start: lastOffset,
            end: block.text.length
          });
        }
        return sections;
      }
      function isAtomicEntityBlock(block) {
        if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === "atomic")) {
          return true;
        }
        return false;
      }
      function getStyleArrayForBlock(block) {
        var text = block.text, inlineStyleRanges = block.inlineStyleRanges;
        var inlineStyles = {
          BOLD: new Array(text.length),
          ITALIC: new Array(text.length),
          UNDERLINE: new Array(text.length),
          STRIKETHROUGH: new Array(text.length),
          CODE: new Array(text.length),
          SUPERSCRIPT: new Array(text.length),
          SUBSCRIPT: new Array(text.length),
          COLOR: new Array(text.length),
          BGCOLOR: new Array(text.length),
          FONTSIZE: new Array(text.length),
          FONTFAMILY: new Array(text.length),
          length: text.length
        };
        if (inlineStyleRanges && inlineStyleRanges.length > 0) {
          inlineStyleRanges.forEach(function(range) {
            var offset = range.offset;
            var length = offset + range.length;
            for (var i2 = offset; i2 < length; i2 += 1) {
              if (range.style.indexOf("color-") === 0) {
                inlineStyles.COLOR[i2] = range.style.substring(6);
              } else if (range.style.indexOf("bgcolor-") === 0) {
                inlineStyles.BGCOLOR[i2] = range.style.substring(8);
              } else if (range.style.indexOf("fontsize-") === 0) {
                inlineStyles.FONTSIZE[i2] = range.style.substring(9);
              } else if (range.style.indexOf("fontfamily-") === 0) {
                inlineStyles.FONTFAMILY[i2] = range.style.substring(11);
              } else if (inlineStyles[range.style]) {
                inlineStyles[range.style][i2] = true;
              }
            }
          });
        }
        return inlineStyles;
      }
      function getStylesAtOffset(inlineStyles, offset) {
        var styles2 = {};
        if (inlineStyles.COLOR[offset]) {
          styles2.COLOR = inlineStyles.COLOR[offset];
        }
        if (inlineStyles.BGCOLOR[offset]) {
          styles2.BGCOLOR = inlineStyles.BGCOLOR[offset];
        }
        if (inlineStyles.FONTSIZE[offset]) {
          styles2.FONTSIZE = inlineStyles.FONTSIZE[offset];
        }
        if (inlineStyles.FONTFAMILY[offset]) {
          styles2.FONTFAMILY = inlineStyles.FONTFAMILY[offset];
        }
        if (inlineStyles.UNDERLINE[offset]) {
          styles2.UNDERLINE = true;
        }
        if (inlineStyles.ITALIC[offset]) {
          styles2.ITALIC = true;
        }
        if (inlineStyles.BOLD[offset]) {
          styles2.BOLD = true;
        }
        if (inlineStyles.STRIKETHROUGH[offset]) {
          styles2.STRIKETHROUGH = true;
        }
        if (inlineStyles.CODE[offset]) {
          styles2.CODE = true;
        }
        if (inlineStyles.SUBSCRIPT[offset]) {
          styles2.SUBSCRIPT = true;
        }
        if (inlineStyles.SUPERSCRIPT[offset]) {
          styles2.SUPERSCRIPT = true;
        }
        return styles2;
      }
      function sameStyleAsPrevious(inlineStyles, styles2, index) {
        var sameStyled = true;
        if (index > 0 && index < inlineStyles.length) {
          styles2.forEach(function(style) {
            sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];
          });
        } else {
          sameStyled = false;
        }
        return sameStyled;
      }
      function addInlineStyleMarkup(style, content) {
        if (style === "BOLD") {
          return "<strong>".concat(content, "</strong>");
        }
        if (style === "ITALIC") {
          return "<em>".concat(content, "</em>");
        }
        if (style === "UNDERLINE") {
          return "<ins>".concat(content, "</ins>");
        }
        if (style === "STRIKETHROUGH") {
          return "<del>".concat(content, "</del>");
        }
        if (style === "CODE") {
          return "<code>".concat(content, "</code>");
        }
        if (style === "SUPERSCRIPT") {
          return "<sup>".concat(content, "</sup>");
        }
        if (style === "SUBSCRIPT") {
          return "<sub>".concat(content, "</sub>");
        }
        return content;
      }
      function getSectionText(text) {
        if (text && text.length > 0) {
          var chars2 = text.map(function(ch) {
            switch (ch) {
              case "\n":
                return "<br>";
              case "&":
                return "&amp;";
              case "<":
                return "&lt;";
              case ">":
                return "&gt;";
              default:
                return ch;
            }
          });
          return chars2.join("");
        }
        return "";
      }
      function addStylePropertyMarkup(styles2, text) {
        if (styles2 && (styles2.COLOR || styles2.BGCOLOR || styles2.FONTSIZE || styles2.FONTFAMILY)) {
          var styleString = 'style="';
          if (styles2.COLOR) {
            styleString += "color: ".concat(styles2.COLOR, ";");
          }
          if (styles2.BGCOLOR) {
            styleString += "background-color: ".concat(styles2.BGCOLOR, ";");
          }
          if (styles2.FONTSIZE) {
            styleString += "font-size: ".concat(styles2.FONTSIZE).concat(/^\d+$/.test(styles2.FONTSIZE) ? "px" : "", ";");
          }
          if (styles2.FONTFAMILY) {
            styleString += "font-family: ".concat(styles2.FONTFAMILY, ";");
          }
          styleString += '"';
          return "<span ".concat(styleString, ">").concat(text, "</span>");
        }
        return text;
      }
      function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {
        var entity = entityMap[entityKey];
        if (typeof customEntityTransform === "function") {
          var html = customEntityTransform(entity, text);
          if (html) {
            return html;
          }
        }
        if (entity.type === "MENTION") {
          return '<a href="'.concat(entity.data.url, '" class="wysiwyg-mention" data-mention data-value="').concat(entity.data.value, '">').concat(text, "</a>");
        }
        if (entity.type === "LINK") {
          var targetOption = entity.data.targetOption || "_self";
          return '<a href="'.concat(entity.data.url, '" target="').concat(targetOption, '">').concat(text, "</a>");
        }
        if (entity.type === "IMAGE") {
          var alignment = entity.data.alignment;
          if (alignment && alignment.length) {
            return '<div style="text-align:'.concat(alignment, ';"><img src="').concat(entity.data.src, '" alt="').concat(entity.data.alt, '" style="height: ').concat(entity.data.height, ";width: ").concat(entity.data.width, '"/></div>');
          }
          return '<img src="'.concat(entity.data.src, '" alt="').concat(entity.data.alt, '" style="height: ').concat(entity.data.height, ";width: ").concat(entity.data.width, '"/>');
        }
        if (entity.type === "EMBEDDED_LINK") {
          return '<iframe width="'.concat(entity.data.width, '" height="').concat(entity.data.height, '" src="').concat(entity.data.src, '" frameBorder="0"></iframe>');
        }
        return text;
      }
      function getInlineStyleSections(block, styles2, start, end) {
        var styleSections = [];
        var text = Array.from(block.text);
        if (text.length > 0) {
          var inlineStyles = getStyleArrayForBlock(block);
          var section;
          for (var i2 = start; i2 < end; i2 += 1) {
            if (i2 !== start && sameStyleAsPrevious(inlineStyles, styles2, i2)) {
              section.text.push(text[i2]);
              section.end = i2 + 1;
            } else {
              section = {
                styles: getStylesAtOffset(inlineStyles, i2),
                text: [text[i2]],
                start: i2,
                end: i2 + 1
              };
              styleSections.push(section);
            }
          }
        }
        return styleSections;
      }
      function trimLeadingZeros(sectionText) {
        if (sectionText) {
          var replacedText = sectionText;
          for (var i2 = 0; i2 < replacedText.length; i2 += 1) {
            if (sectionText[i2] === " ") {
              replacedText = replacedText.replace(" ", "&nbsp;");
            } else {
              break;
            }
          }
          return replacedText;
        }
        return sectionText;
      }
      function trimTrailingZeros(sectionText) {
        if (sectionText) {
          var replacedText = sectionText;
          for (var i2 = replacedText.length - 1; i2 >= 0; i2 -= 1) {
            if (replacedText[i2] === " ") {
              replacedText = "".concat(replacedText.substring(0, i2), "&nbsp;").concat(replacedText.substring(i2 + 1));
            } else {
              break;
            }
          }
          return replacedText;
        }
        return sectionText;
      }
      function getStyleTagSectionMarkup(styleSection) {
        var styles2 = styleSection.styles, text = styleSection.text;
        var content = getSectionText(text);
        forEach3(styles2, function(style, value) {
          content = addInlineStyleMarkup(style, content);
        });
        return content;
      }
      function getInlineStyleSectionMarkup(block, styleSection) {
        var styleTagSections = getInlineStyleSections(block, ["BOLD", "ITALIC", "UNDERLINE", "STRIKETHROUGH", "CODE", "SUPERSCRIPT", "SUBSCRIPT"], styleSection.start, styleSection.end);
        var styleSectionText = "";
        styleTagSections.forEach(function(stylePropertySection) {
          styleSectionText += getStyleTagSectionMarkup(stylePropertySection);
        });
        styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);
        return styleSectionText;
      }
      function getSectionMarkup(block, entityMap, section, customEntityTransform) {
        var entityInlineMarkup = [];
        var inlineStyleSections = getInlineStyleSections(block, ["COLOR", "BGCOLOR", "FONTSIZE", "FONTFAMILY"], section.start, section.end);
        inlineStyleSections.forEach(function(styleSection) {
          entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));
        });
        var sectionText = entityInlineMarkup.join("");
        if (section.type === "ENTITY") {
          if (section.entityKey !== void 0 && section.entityKey !== null) {
            sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform);
          }
        } else if (section.type === "HASHTAG") {
          sectionText = '<a href="'.concat(sectionText, '" class="wysiwyg-hashtag">').concat(sectionText, "</a>");
        }
        return sectionText;
      }
      function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {
        var blockMarkup = [];
        var sections = getSections(block, hashtagConfig);
        sections.forEach(function(section, index) {
          var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);
          if (index === 0) {
            sectionText = trimLeadingZeros(sectionText);
          }
          if (index === sections.length - 1) {
            sectionText = trimTrailingZeros(sectionText);
          }
          blockMarkup.push(sectionText);
        });
        return blockMarkup.join("");
      }
      function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {
        var blockHtml = [];
        if (isAtomicEntityBlock(block)) {
          blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, void 0, customEntityTransform));
        } else {
          var blockTag = getBlockTag(block.type);
          if (blockTag) {
            blockHtml.push("<".concat(blockTag));
            var blockStyle = getBlockStyle(block.data);
            if (blockStyle) {
              blockHtml.push(' style="'.concat(blockStyle, '"'));
            }
            if (directional) {
              blockHtml.push(' dir = "auto"');
            }
            blockHtml.push(">");
            blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));
            blockHtml.push("</".concat(blockTag, ">"));
          }
        }
        blockHtml.push("\n");
        return blockHtml.join("");
      }
      function isList2(blockType) {
        return blockType === "unordered-list-item" || blockType === "ordered-list-item";
      }
      function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {
        var listHtml = [];
        var nestedListBlock = [];
        var previousBlock;
        listBlocks.forEach(function(block) {
          var nestedBlock = false;
          if (!previousBlock) {
            listHtml.push("<".concat(getBlockTag(block.type), ">\n"));
          } else if (previousBlock.type !== block.type) {
            listHtml.push("</".concat(getBlockTag(previousBlock.type), ">\n"));
            listHtml.push("<".concat(getBlockTag(block.type), ">\n"));
          } else if (previousBlock.depth === block.depth) {
            if (nestedListBlock && nestedListBlock.length > 0) {
              listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));
              nestedListBlock = [];
            }
          } else {
            nestedBlock = true;
            nestedListBlock.push(block);
          }
          if (!nestedBlock) {
            listHtml.push("<li");
            var blockStyle = getBlockStyle(block.data);
            if (blockStyle) {
              listHtml.push(' style="'.concat(blockStyle, '"'));
            }
            if (directional) {
              listHtml.push(' dir = "auto"');
            }
            listHtml.push(">");
            listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));
            listHtml.push("</li>\n");
            previousBlock = block;
          }
        });
        if (nestedListBlock && nestedListBlock.length > 0) {
          listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));
        }
        listHtml.push("</".concat(getBlockTag(previousBlock.type), ">\n"));
        return listHtml.join("");
      }
      function draftToHtml2(editorContent, hashtagConfig, directional, customEntityTransform) {
        var html = [];
        if (editorContent) {
          var blocks = editorContent.blocks, entityMap = editorContent.entityMap;
          if (blocks && blocks.length > 0) {
            var listBlocks = [];
            blocks.forEach(function(block) {
              if (isList2(block.type)) {
                listBlocks.push(block);
              } else {
                if (listBlocks.length > 0) {
                  var listHtml2 = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform);
                  html.push(listHtml2);
                  listBlocks = [];
                }
                var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);
                html.push(blockHtml);
              }
            });
            if (listBlocks.length > 0) {
              var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform);
              html.push(listHtml);
              listBlocks = [];
            }
          }
        }
        return html.join("");
      }
      return draftToHtml2;
    }));
  })(draftjsToHtml$1);
  return draftjsToHtml$1.exports;
}
var draftjsToHtmlExports = requireDraftjsToHtml();
const draftToHtml = /* @__PURE__ */ getDefaultExportFromCjs(draftjsToHtmlExports);
const we = 0, zt = 1, qt = 2, kn = 4;
function un(t2) {
  return () => t2;
}
function fo(t2) {
  t2();
}
function ne(t2, e2) {
  return (n2) => t2(e2(n2));
}
function an(t2, e2) {
  return () => t2(e2);
}
function mo(t2, e2) {
  return (n2) => t2(e2, n2);
}
function We(t2) {
  return t2 !== void 0;
}
function po(...t2) {
  return () => {
    t2.map(fo);
  };
}
function Yt() {
}
function ve(t2, e2) {
  return e2(t2), t2;
}
function ho(t2, e2) {
  return e2(t2);
}
function X(...t2) {
  return t2;
}
function K$1(t2, e2) {
  return t2(zt, e2);
}
function G$1(t2, e2) {
  t2(we, e2);
}
function Ge(t2) {
  t2(qt);
}
function ot(t2) {
  return t2(kn);
}
function O$1(t2, e2) {
  return K$1(t2, mo(e2, we));
}
function Tt(t2, e2) {
  const n2 = t2(zt, (o2) => {
    n2(), e2(o2);
  });
  return n2;
}
function dn(t2) {
  let e2, n2;
  return (o2) => (r2) => {
    e2 = r2, n2 && clearTimeout(n2), n2 = setTimeout(() => {
      o2(e2);
    }, t2);
  };
}
function Fn(t2, e2) {
  return t2 === e2;
}
function Y(t2 = Fn) {
  let e2;
  return (n2) => (o2) => {
    t2(e2, o2) || (e2 = o2, n2(o2));
  };
}
function A$1(t2) {
  return (e2) => (n2) => {
    t2(n2) && e2(n2);
  };
}
function E$1(t2) {
  return (e2) => ne(e2, t2);
}
function Rt(t2) {
  return (e2) => () => {
    e2(t2);
  };
}
function S(t2, ...e2) {
  const n2 = go(...e2);
  return (o2, r2) => {
    switch (o2) {
      case qt:
        Ge(t2);
        return;
      case zt:
        return K$1(t2, n2(r2));
    }
  };
}
function bt(t2, e2) {
  return (n2) => (o2) => {
    n2(e2 = t2(e2, o2));
  };
}
function Dt(t2) {
  return (e2) => (n2) => {
    t2 > 0 ? t2-- : e2(n2);
  };
}
function kt(t2) {
  let e2 = null, n2;
  return (o2) => (r2) => {
    e2 = r2, !n2 && (n2 = setTimeout(() => {
      n2 = void 0, o2(e2);
    }, t2));
  };
}
function N$1(...t2) {
  const e2 = new Array(t2.length);
  let n2 = 0, o2 = null;
  const r2 = Math.pow(2, t2.length) - 1;
  return t2.forEach((s2, i2) => {
    const l2 = Math.pow(2, i2);
    K$1(s2, (c2) => {
      const a2 = n2;
      n2 = n2 | l2, e2[i2] = c2, a2 !== r2 && n2 === r2 && o2 && (o2(), o2 = null);
    });
  }), (s2) => (i2) => {
    const l2 = () => {
      s2([i2].concat(e2));
    };
    n2 === r2 ? l2() : o2 = l2;
  };
}
function go(...t2) {
  return (e2) => t2.reduceRight(ho, e2);
}
function Io(t2) {
  let e2, n2;
  const o2 = () => e2 == null ? void 0 : e2();
  return function(r2, s2) {
    switch (r2) {
      case zt:
        return s2 ? n2 === s2 ? void 0 : (o2(), n2 = s2, e2 = K$1(t2, s2), e2) : (o2(), Yt);
      case qt:
        o2(), n2 = null;
        return;
    }
  };
}
function w$1(t2) {
  let e2 = t2;
  const n2 = $();
  return (o2, r2) => {
    switch (o2) {
      case we:
        e2 = r2;
        break;
      case zt: {
        r2(e2);
        break;
      }
      case kn:
        return e2;
    }
    return n2(o2, r2);
  };
}
function ct(t2, e2) {
  return ve(w$1(e2), (n2) => O$1(t2, n2));
}
function $() {
  const t2 = [];
  return (e2, n2) => {
    switch (e2) {
      case we:
        t2.slice().forEach((o2) => {
          o2(n2);
        });
        return;
      case qt:
        t2.splice(0, t2.length);
        return;
      case zt:
        return t2.push(n2), () => {
          const o2 = t2.indexOf(n2);
          o2 > -1 && t2.splice(o2, 1);
        };
    }
  };
}
function ht(t2) {
  return ve($(), (e2) => O$1(t2, e2));
}
function U$1(t2, e2 = [], { singleton: n2 } = { singleton: true }) {
  return {
    constructor: t2,
    dependencies: e2,
    id: So(),
    singleton: n2
  };
}
const So = () => Symbol();
function xo(t2) {
  const e2 = /* @__PURE__ */ new Map(), n2 = ({ constructor: o2, dependencies: r2, id: s2, singleton: i2 }) => {
    if (i2 && e2.has(s2))
      return e2.get(s2);
    const l2 = o2(r2.map((c2) => n2(c2)));
    return i2 && e2.set(s2, l2), l2;
  };
  return n2(t2);
}
function rt(...t2) {
  const e2 = $(), n2 = new Array(t2.length);
  let o2 = 0;
  const r2 = Math.pow(2, t2.length) - 1;
  return t2.forEach((s2, i2) => {
    const l2 = Math.pow(2, i2);
    K$1(s2, (c2) => {
      n2[i2] = c2, o2 = o2 | l2, o2 === r2 && G$1(e2, n2);
    });
  }), function(s2, i2) {
    switch (s2) {
      case qt: {
        Ge(e2);
        return;
      }
      case zt:
        return o2 === r2 && i2(n2), K$1(e2, i2);
    }
  };
}
function V$1(t2, e2 = Fn) {
  return S(t2, Y(e2));
}
function Le(...t2) {
  return function(e2, n2) {
    switch (e2) {
      case qt:
        return;
      case zt:
        return po(...t2.map((o2) => K$1(o2, n2)));
    }
  };
}
var mt = /* @__PURE__ */ ((t2) => (t2[t2.DEBUG = 0] = "DEBUG", t2[t2.INFO = 1] = "INFO", t2[t2.WARN = 2] = "WARN", t2[t2.ERROR = 3] = "ERROR", t2))(mt || {});
const To = {
  0: "debug",
  3: "error",
  1: "log",
  2: "warn"
}, Co = () => typeof globalThis > "u" ? window : globalThis, Vt = U$1(
  () => {
    const t2 = w$1(
      3
      /* ERROR */
    );
    return {
      log: w$1((n2, o2, r2 = 1) => {
        var i2;
        const s2 = (i2 = Co().VIRTUOSO_LOG_LEVEL) != null ? i2 : ot(t2);
        r2 >= s2 && console[To[r2]](
          "%creact-virtuoso: %c%s %o",
          "color: #0253b3; font-weight: bold",
          "color: initial",
          n2,
          o2
        );
      }),
      logLevel: t2
    };
  },
  [],
  { singleton: true }
);
function Ht(t2, e2, n2) {
  return _e(t2, e2, n2).callbackRef;
}
function _e(t2, e2, n2) {
  const o2 = React.useRef(null);
  let r2 = (i2) => {
  };
  const s2 = React.useMemo(() => typeof ResizeObserver < "u" ? new ResizeObserver((i2) => {
    const l2 = () => {
      const c2 = i2[0].target;
      c2.offsetParent !== null && t2(c2);
    };
    n2 ? l2() : requestAnimationFrame(l2);
  }) : null, [t2, n2]);
  return r2 = (i2) => {
    i2 && e2 ? (s2 == null || s2.observe(i2), o2.current = i2) : (o2.current && (s2 == null || s2.unobserve(o2.current)), o2.current = null);
  }, { callbackRef: r2, ref: o2 };
}
function On(t2, e2, n2, o2, r2, s2, i2, l2, c2) {
  const a2 = React.useCallback(
    (m2) => {
      const x2 = wo(m2.children, e2, l2 ? "offsetWidth" : "offsetHeight", r2);
      let h2 = m2.parentElement;
      for (; !h2.dataset.virtuosoScroller; )
        h2 = h2.parentElement;
      const I = h2.lastElementChild.dataset.viewportType === "window";
      let C;
      I && (C = h2.ownerDocument.defaultView);
      const v2 = i2 ? l2 ? i2.scrollLeft : i2.scrollTop : I ? l2 ? C.scrollX || C.document.documentElement.scrollLeft : C.scrollY || C.document.documentElement.scrollTop : l2 ? h2.scrollLeft : h2.scrollTop, g2 = i2 ? l2 ? i2.scrollWidth : i2.scrollHeight : I ? l2 ? C.document.documentElement.scrollWidth : C.document.documentElement.scrollHeight : l2 ? h2.scrollWidth : h2.scrollHeight, p2 = i2 ? l2 ? i2.offsetWidth : i2.offsetHeight : I ? l2 ? C.innerWidth : C.innerHeight : l2 ? h2.offsetWidth : h2.offsetHeight;
      o2({
        scrollHeight: g2,
        scrollTop: Math.max(v2, 0),
        viewportHeight: p2
      }), s2 == null || s2(
        l2 ? fn("column-gap", getComputedStyle(m2).columnGap, r2) : fn("row-gap", getComputedStyle(m2).rowGap, r2)
      ), x2 !== null && t2(x2);
    },
    [t2, e2, r2, s2, i2, o2, l2]
  );
  return _e(a2, n2, c2);
}
function wo(t2, e2, n2, o2) {
  const r2 = t2.length;
  if (r2 === 0)
    return null;
  const s2 = [];
  for (let i2 = 0; i2 < r2; i2++) {
    const l2 = t2.item(i2);
    if (l2.dataset.index === void 0)
      continue;
    const c2 = parseInt(l2.dataset.index), a2 = parseFloat(l2.dataset.knownSize), m2 = e2(l2, n2);
    if (m2 === 0 && o2("Zero-sized element, this should not happen", { child: l2 }, mt.ERROR), m2 === a2)
      continue;
    const x2 = s2[s2.length - 1];
    s2.length === 0 || x2.size !== m2 || x2.endIndex !== c2 - 1 ? s2.push({ endIndex: c2, size: m2, startIndex: c2 }) : s2[s2.length - 1].endIndex++;
  }
  return s2;
}
function fn(t2, e2, n2) {
  return e2 !== "normal" && !(e2 != null && e2.endsWith("px")) && n2("".concat(t2, " was not resolved to pixel value correctly"), e2, mt.WARN), e2 === "normal" ? 0 : parseInt(e2 != null ? e2 : "0", 10);
}
function Ne(t2, e2, n2) {
  const o2 = React.useRef(null), r2 = React.useCallback(
    (c2) => {
      if (!(c2 != null && c2.offsetParent))
        return;
      const a2 = c2.getBoundingClientRect(), m2 = a2.width;
      let x2, h2;
      if (e2) {
        const I = e2.getBoundingClientRect(), C = a2.top - I.top;
        h2 = I.height - Math.max(0, C), x2 = C + e2.scrollTop;
      } else {
        const I = i2.current.ownerDocument.defaultView;
        h2 = I.innerHeight - Math.max(0, a2.top), x2 = a2.top + I.scrollY;
      }
      o2.current = {
        offsetTop: x2,
        visibleHeight: h2,
        visibleWidth: m2
      }, t2(o2.current);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [t2, e2]
  ), { callbackRef: s2, ref: i2 } = _e(r2, true, n2), l2 = React.useCallback(() => {
    r2(i2.current);
  }, [r2, i2]);
  return React.useEffect(() => {
    var c2;
    if (e2) {
      e2.addEventListener("scroll", l2);
      const a2 = new ResizeObserver(() => {
        requestAnimationFrame(l2);
      });
      return a2.observe(e2), () => {
        e2.removeEventListener("scroll", l2), a2.unobserve(e2);
      };
    } else {
      const a2 = (c2 = i2.current) == null ? void 0 : c2.ownerDocument.defaultView;
      return a2 == null || a2.addEventListener("scroll", l2), a2 == null || a2.addEventListener("resize", l2), () => {
        a2 == null || a2.removeEventListener("scroll", l2), a2 == null || a2.removeEventListener("resize", l2);
      };
    }
  }, [l2, e2, i2]), s2;
}
const at = U$1(
  () => {
    const t2 = $(), e2 = $(), n2 = w$1(0), o2 = $(), r2 = w$1(0), s2 = $(), i2 = $(), l2 = w$1(0), c2 = w$1(0), a2 = w$1(0), m2 = w$1(0), x2 = $(), h2 = $(), I = w$1(false), C = w$1(false), v2 = w$1(false);
    return O$1(
      S(
        t2,
        E$1(({ scrollTop: g2 }) => g2)
      ),
      e2
    ), O$1(
      S(
        t2,
        E$1(({ scrollHeight: g2 }) => g2)
      ),
      i2
    ), O$1(e2, r2), {
      deviation: n2,
      fixedFooterHeight: a2,
      fixedHeaderHeight: c2,
      footerHeight: m2,
      headerHeight: l2,
      horizontalDirection: C,
      scrollBy: h2,
      // input
      scrollContainerState: t2,
      scrollHeight: i2,
      scrollingInProgress: I,
      // signals
      scrollTo: x2,
      scrollTop: e2,
      skipAnimationFrameInResizeObserver: v2,
      smoothScrollTargetReached: o2,
      // state
      statefulScrollTop: r2,
      viewportHeight: s2
    };
  },
  [],
  { singleton: true }
), oe = { lvl: 0 };
function Ln(t2, e2) {
  const n2 = t2.length;
  if (n2 === 0)
    return [];
  let { index: o2, value: r2 } = e2(t2[0]);
  const s2 = [];
  for (let i2 = 1; i2 < n2; i2++) {
    const { index: l2, value: c2 } = e2(t2[i2]);
    s2.push({ end: l2 - 1, start: o2, value: r2 }), o2 = l2, r2 = c2;
  }
  return s2.push({ end: 1 / 0, start: o2, value: r2 }), s2;
}
function j(t2) {
  return t2 === oe;
}
function re(t2, e2) {
  if (!j(t2))
    return e2 === t2.k ? t2.v : e2 < t2.k ? re(t2.l, e2) : re(t2.r, e2);
}
function wt(t2, e2, n2 = "k") {
  if (j(t2))
    return [-1 / 0, void 0];
  if (Number(t2[n2]) === e2)
    return [t2.k, t2.v];
  if (Number(t2[n2]) < e2) {
    const o2 = wt(t2.r, e2, n2);
    return o2[0] === -1 / 0 ? [t2.k, t2.v] : o2;
  }
  return wt(t2.l, e2, n2);
}
function pt(t2, e2, n2) {
  return j(t2) ? Pn(e2, n2, 1) : e2 === t2.k ? st(t2, { k: e2, v: n2 }) : e2 < t2.k ? mn(st(t2, { l: pt(t2.l, e2, n2) })) : mn(st(t2, { r: pt(t2.r, e2, n2) }));
}
function jt() {
  return oe;
}
function ye(t2, e2, n2) {
  if (j(t2))
    return [];
  const o2 = wt(t2, e2)[0];
  return vo(Ve(t2, o2, n2));
}
function ze(t2, e2) {
  if (j(t2)) return oe;
  const { k: n2, l: o2, r: r2 } = t2;
  if (e2 === n2) {
    if (j(o2))
      return r2;
    if (j(r2))
      return o2;
    {
      const [s2, i2] = Vn(o2);
      return ge(st(t2, { k: s2, l: zn(o2), v: i2 }));
    }
  } else return e2 < n2 ? ge(st(t2, { l: ze(o2, e2) })) : ge(st(t2, { r: ze(r2, e2) }));
}
function Gt(t2) {
  return j(t2) ? [] : [...Gt(t2.l), { k: t2.k, v: t2.v }, ...Gt(t2.r)];
}
function Ve(t2, e2, n2) {
  if (j(t2))
    return [];
  const { k: o2, l: r2, r: s2, v: i2 } = t2;
  let l2 = [];
  return o2 > e2 && (l2 = l2.concat(Ve(r2, e2, n2))), o2 >= e2 && o2 <= n2 && l2.push({ k: o2, v: i2 }), o2 <= n2 && (l2 = l2.concat(Ve(s2, e2, n2))), l2;
}
function ge(t2) {
  const { l: e2, lvl: n2, r: o2 } = t2;
  if (o2.lvl >= n2 - 1 && e2.lvl >= n2 - 1)
    return t2;
  if (n2 > o2.lvl + 1) {
    if (Ee(e2))
      return An(st(t2, { lvl: n2 - 1 }));
    if (!j(e2) && !j(e2.r))
      return st(e2.r, {
        l: st(e2, { r: e2.r.l }),
        lvl: n2,
        r: st(t2, {
          l: e2.r.r,
          lvl: n2 - 1
        })
      });
    throw new Error("Unexpected empty nodes");
  } else {
    if (Ee(t2))
      return Pe(st(t2, { lvl: n2 - 1 }));
    if (!j(o2) && !j(o2.l)) {
      const r2 = o2.l, s2 = Ee(r2) ? o2.lvl - 1 : o2.lvl;
      return st(r2, {
        l: st(t2, {
          lvl: n2 - 1,
          r: r2.l
        }),
        lvl: r2.lvl + 1,
        r: Pe(st(o2, { l: r2.r, lvl: s2 }))
      });
    } else
      throw new Error("Unexpected empty nodes");
  }
}
function st(t2, e2) {
  return Pn(
    e2.k !== void 0 ? e2.k : t2.k,
    e2.v !== void 0 ? e2.v : t2.v,
    e2.lvl !== void 0 ? e2.lvl : t2.lvl,
    e2.l !== void 0 ? e2.l : t2.l,
    e2.r !== void 0 ? e2.r : t2.r
  );
}
function zn(t2) {
  return j(t2.r) ? t2.l : ge(st(t2, { r: zn(t2.r) }));
}
function Ee(t2) {
  return j(t2) || t2.lvl > t2.r.lvl;
}
function Vn(t2) {
  return j(t2.r) ? [t2.k, t2.v] : Vn(t2.r);
}
function Pn(t2, e2, n2, o2 = oe, r2 = oe) {
  return { k: t2, l: o2, lvl: n2, r: r2, v: e2 };
}
function mn(t2) {
  return Pe(An(t2));
}
function An(t2) {
  const { l: e2 } = t2;
  return !j(e2) && e2.lvl === t2.lvl ? st(e2, { r: st(t2, { l: e2.r }) }) : t2;
}
function Pe(t2) {
  const { lvl: e2, r: n2 } = t2;
  return !j(n2) && !j(n2.r) && n2.lvl === e2 && n2.r.lvl === e2 ? st(n2, { l: st(t2, { r: n2.l }), lvl: e2 + 1 }) : t2;
}
function vo(t2) {
  return Ln(t2, ({ k: e2, v: n2 }) => ({ index: e2, value: n2 }));
}
function Mn(t2, e2) {
  return !!(t2 && t2.startIndex === e2.startIndex && t2.endIndex === e2.endIndex);
}
function se(t2, e2) {
  return !!(t2 && t2[0] === e2[0] && t2[1] === e2[1]);
}
const De = U$1(
  () => ({ recalcInProgress: w$1(false) }),
  [],
  { singleton: true }
);
function Wn(t2, e2, n2) {
  return t2[Se(t2, e2, n2)];
}
function Se(t2, e2, n2, o2 = 0) {
  let r2 = t2.length - 1;
  for (; o2 <= r2; ) {
    const s2 = Math.floor((o2 + r2) / 2), i2 = t2[s2], l2 = n2(i2, e2);
    if (l2 === 0)
      return s2;
    if (l2 === -1) {
      if (r2 - o2 < 2)
        return s2 - 1;
      r2 = s2 - 1;
    } else {
      if (r2 === o2)
        return s2;
      o2 = s2 + 1;
    }
  }
  throw new Error("Failed binary finding record in array - ".concat(t2.join(","), ", searched for ").concat(e2));
}
function yo(t2, e2, n2, o2) {
  const r2 = Se(t2, e2, o2), s2 = Se(t2, n2, o2, r2);
  return t2.slice(r2, s2 + 1);
}
function vt(t2, e2) {
  return Math.round(t2.getBoundingClientRect()[e2]);
}
function Re(t2) {
  return !j(t2.groupOffsetTree);
}
function $e({ index: t2 }, e2) {
  return e2 === t2 ? 0 : e2 < t2 ? -1 : 1;
}
function Ro() {
  return {
    groupIndices: [],
    groupOffsetTree: jt(),
    lastIndex: 0,
    lastOffset: 0,
    lastSize: 0,
    offsetTree: [],
    sizeTree: jt()
  };
}
function bo(t2, e2) {
  let n2 = j(t2) ? 0 : 1 / 0;
  for (const o2 of e2) {
    const { endIndex: r2, size: s2, startIndex: i2 } = o2;
    if (n2 = Math.min(n2, i2), j(t2)) {
      t2 = pt(t2, 0, s2);
      continue;
    }
    const l2 = ye(t2, i2 - 1, r2 + 1);
    if (l2.some(Lo(o2)))
      continue;
    let c2 = false, a2 = false;
    for (const { end: m2, start: x2, value: h2 } of l2)
      c2 ? (r2 >= x2 || s2 === h2) && (t2 = ze(t2, x2)) : (a2 = h2 !== s2, c2 = true), m2 > r2 && r2 >= x2 && h2 !== s2 && (t2 = pt(t2, r2 + 1, h2));
    a2 && (t2 = pt(t2, i2, s2));
  }
  return [t2, n2];
}
function Ho(t2) {
  return typeof t2.groupIndex < "u";
}
function Eo({ offset: t2 }, e2) {
  return e2 === t2 ? 0 : e2 < t2 ? -1 : 1;
}
function ie(t2, e2, n2) {
  if (e2.length === 0)
    return 0;
  const { index: o2, offset: r2, size: s2 } = Wn(e2, t2, $e), i2 = t2 - o2, l2 = s2 * i2 + (i2 - 1) * n2 + r2;
  return l2 > 0 ? l2 + n2 : l2;
}
function Gn(t2, e2) {
  if (!Re(e2))
    return t2;
  let n2 = 0;
  for (; e2.groupIndices[n2] <= t2 + n2; )
    n2++;
  return t2 + n2;
}
function _n(t2, e2, n2) {
  if (Ho(t2))
    return e2.groupIndices[t2.groupIndex] + 1;
  {
    const o2 = t2.index === "LAST" ? n2 : t2.index;
    let r2 = Gn(o2, e2);
    return r2 = Math.max(0, r2, Math.min(n2, r2)), r2;
  }
}
function Bo(t2, e2, n2, o2 = 0) {
  return o2 > 0 && (e2 = Math.max(e2, Wn(t2, o2, $e).offset)), Ln(yo(t2, e2, n2, Eo), Oo);
}
function ko(t2, [e2, n2, o2, r2]) {
  e2.length > 0 && o2("received item sizes", e2, mt.DEBUG);
  const s2 = t2.sizeTree;
  let i2 = s2, l2 = 0;
  if (n2.length > 0 && j(s2) && e2.length === 2) {
    const h2 = e2[0].size, I = e2[1].size;
    i2 = n2.reduce((C, v2) => pt(pt(C, v2, h2), v2 + 1, I), i2);
  } else
    [i2, l2] = bo(i2, e2);
  if (i2 === s2)
    return t2;
  const { lastIndex: c2, lastOffset: a2, lastSize: m2, offsetTree: x2 } = Ae(t2.offsetTree, l2, i2, r2);
  return {
    groupIndices: n2,
    groupOffsetTree: n2.reduce((h2, I) => pt(h2, I, ie(I, x2, r2)), jt()),
    lastIndex: c2,
    lastOffset: a2,
    lastSize: m2,
    offsetTree: x2,
    sizeTree: i2
  };
}
function Fo(t2) {
  return Gt(t2).map(({ k: e2, v: n2 }, o2, r2) => {
    const s2 = r2[o2 + 1];
    return { endIndex: s2 ? s2.k - 1 : 1 / 0, size: n2, startIndex: e2 };
  });
}
function pn(t2, e2) {
  let n2 = 0, o2 = 0;
  for (; n2 < t2; )
    n2 += e2[o2 + 1] - e2[o2] - 1, o2++;
  return o2 - (n2 === t2 ? 0 : 1);
}
function Ae(t2, e2, n2, o2) {
  let r2 = t2, s2 = 0, i2 = 0, l2 = 0, c2 = 0;
  if (e2 !== 0) {
    c2 = Se(r2, e2 - 1, $e), l2 = r2[c2].offset;
    const m2 = wt(n2, e2 - 1);
    s2 = m2[0], i2 = m2[1], r2.length && r2[c2].size === wt(n2, e2)[1] && (c2 -= 1), r2 = r2.slice(0, c2 + 1);
  } else
    r2 = [];
  for (const { start: a2, value: m2 } of ye(n2, e2, 1 / 0)) {
    const x2 = a2 - s2, h2 = x2 * i2 + l2 + x2 * o2;
    r2.push({
      index: a2,
      offset: h2,
      size: m2
    }), s2 = a2, l2 = h2, i2 = m2;
  }
  return {
    lastIndex: s2,
    lastOffset: l2,
    lastSize: i2,
    offsetTree: r2
  };
}
function Oo(t2) {
  return { index: t2.index, value: t2 };
}
function Lo(t2) {
  const { endIndex: e2, size: n2, startIndex: o2 } = t2;
  return (r2) => r2.start === o2 && (r2.end === e2 || r2.end === 1 / 0) && r2.value === n2;
}
const zo = {
  offsetHeight: "height",
  offsetWidth: "width"
}, Et = U$1(
  ([{ log: t2 }, { recalcInProgress: e2 }]) => {
    const n2 = $(), o2 = $(), r2 = ct(o2, 0), s2 = $(), i2 = $(), l2 = w$1(0), c2 = w$1([]), a2 = w$1(void 0), m2 = w$1(void 0), x2 = w$1((f2, d2) => vt(f2, zo[d2])), h2 = w$1(void 0), I = w$1(0), C = Ro(), v2 = ct(
      S(n2, N$1(c2, t2, I), bt(ko, C), Y()),
      C
    ), g2 = ct(
      S(
        c2,
        Y(),
        bt((f2, d2) => ({ current: d2, prev: f2.current }), {
          current: [],
          prev: []
        }),
        E$1(({ prev: f2 }) => f2)
      ),
      []
    );
    O$1(
      S(
        c2,
        A$1((f2) => f2.length > 0),
        N$1(v2, I),
        E$1(([f2, d2, y2]) => {
          const B = f2.reduce((k2, L, z2) => pt(k2, L, ie(L, d2.offsetTree, y2) || z2), jt());
          return {
            ...d2,
            groupIndices: f2,
            groupOffsetTree: B
          };
        })
      ),
      v2
    ), O$1(
      S(
        o2,
        N$1(v2),
        A$1(([f2, { lastIndex: d2 }]) => f2 < d2),
        E$1(([f2, { lastIndex: d2, lastSize: y2 }]) => [
          {
            endIndex: d2,
            size: y2,
            startIndex: f2
          }
        ])
      ),
      n2
    ), O$1(a2, m2);
    const p2 = ct(
      S(
        a2,
        E$1((f2) => f2 === void 0)
      ),
      true
    );
    O$1(
      S(
        m2,
        A$1((f2) => f2 !== void 0 && j(ot(v2).sizeTree)),
        E$1((f2) => [{ endIndex: 0, size: f2, startIndex: 0 }])
      ),
      n2
    );
    const u2 = ht(
      S(
        n2,
        N$1(v2),
        bt(
          ({ sizes: f2 }, [d2, y2]) => ({
            changed: y2 !== f2,
            sizes: y2
          }),
          { changed: false, sizes: C }
        ),
        E$1((f2) => f2.changed)
      )
    );
    K$1(
      S(
        l2,
        bt(
          (f2, d2) => ({ diff: f2.prev - d2, prev: d2 }),
          { diff: 0, prev: 0 }
        ),
        E$1((f2) => f2.diff)
      ),
      (f2) => {
        const { groupIndices: d2 } = ot(v2);
        if (f2 > 0)
          G$1(e2, true), G$1(s2, f2 + pn(f2, d2));
        else if (f2 < 0) {
          const y2 = ot(g2);
          y2.length > 0 && (f2 -= pn(-f2, y2)), G$1(i2, f2);
        }
      }
    ), K$1(S(l2, N$1(t2)), ([f2, d2]) => {
      f2 < 0 && d2(
        "`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value",
        { firstItemIndex: l2 },
        mt.ERROR
      );
    });
    const T = ht(s2);
    O$1(
      S(
        s2,
        N$1(v2),
        E$1(([f2, d2]) => {
          const y2 = d2.groupIndices.length > 0, B = [], k2 = d2.lastSize;
          if (y2) {
            const L = re(d2.sizeTree, 0);
            let z2 = 0, _23 = 0;
            for (; z2 < f2; ) {
              const F = d2.groupIndices[_23], q2 = d2.groupIndices.length === _23 + 1 ? 1 / 0 : d2.groupIndices[_23 + 1] - F - 1;
              B.push({
                endIndex: F,
                size: L,
                startIndex: F
              }), B.push({
                endIndex: F + 1 + q2 - 1,
                size: k2,
                startIndex: F + 1
              }), _23++, z2 += q2 + 1;
            }
            const J2 = Gt(d2.sizeTree);
            return z2 !== f2 && J2.shift(), J2.reduce(
              (F, { k: q2, v: it }) => {
                let dt = F.ranges;
                return F.prevSize !== 0 && (dt = [
                  ...F.ranges,
                  {
                    endIndex: q2 + f2 - 1,
                    size: F.prevSize,
                    startIndex: F.prevIndex
                  }
                ]), {
                  prevIndex: q2 + f2,
                  prevSize: it,
                  ranges: dt
                };
              },
              {
                prevIndex: f2,
                prevSize: 0,
                ranges: B
              }
            ).ranges;
          }
          return Gt(d2.sizeTree).reduce(
            (L, { k: z2, v: _23 }) => ({
              prevIndex: z2 + f2,
              prevSize: _23,
              ranges: [...L.ranges, { endIndex: z2 + f2 - 1, size: L.prevSize, startIndex: L.prevIndex }]
            }),
            {
              prevIndex: 0,
              prevSize: k2,
              ranges: []
            }
          ).ranges;
        })
      ),
      n2
    );
    const b2 = ht(
      S(
        i2,
        N$1(v2, I),
        E$1(([f2, { offsetTree: d2 }, y2]) => {
          const B = -f2;
          return ie(B, d2, y2);
        })
      )
    );
    return O$1(
      S(
        i2,
        N$1(v2, I),
        E$1(([f2, d2, y2]) => {
          if (d2.groupIndices.length > 0) {
            if (j(d2.sizeTree))
              return d2;
            let k2 = jt();
            const L = ot(g2);
            let z2 = 0, _23 = 0, J2 = 0;
            for (; z2 < -f2; ) {
              J2 = L[_23];
              const F = L[_23 + 1] - J2 - 1;
              _23++, z2 += F + 1;
            }
            if (k2 = Gt(d2.sizeTree).reduce((F, { k: q2, v: it }) => pt(F, Math.max(0, q2 + f2), it), k2), z2 !== -f2) {
              const F = re(d2.sizeTree, J2);
              k2 = pt(k2, 0, F);
              const q2 = wt(d2.sizeTree, -f2 + 1)[1];
              k2 = pt(k2, 1, q2);
            }
            return {
              ...d2,
              sizeTree: k2,
              ...Ae(d2.offsetTree, 0, k2, y2)
            };
          } else {
            const k2 = Gt(d2.sizeTree).reduce((L, { k: z2, v: _23 }) => pt(L, Math.max(0, z2 + f2), _23), jt());
            return {
              ...d2,
              sizeTree: k2,
              ...Ae(d2.offsetTree, 0, k2, y2)
            };
          }
        })
      ),
      v2
    ), {
      beforeUnshiftWith: T,
      // input
      data: h2,
      defaultItemSize: m2,
      firstItemIndex: l2,
      fixedItemSize: a2,
      gap: I,
      groupIndices: c2,
      itemSize: x2,
      listRefresh: u2,
      shiftWith: i2,
      shiftWithOffset: b2,
      sizeRanges: n2,
      // output
      sizes: v2,
      statefulTotalCount: r2,
      totalCount: o2,
      trackItemSizes: p2,
      unshiftWith: s2
    };
  },
  X(Vt, De),
  { singleton: true }
);
function Vo(t2) {
  return t2.reduce(
    (e2, n2) => (e2.groupIndices.push(e2.totalCount), e2.totalCount += n2 + 1, e2),
    {
      groupIndices: [],
      totalCount: 0
    }
  );
}
const Nn = U$1(
  ([{ groupIndices: t2, sizes: e2, totalCount: n2 }, { headerHeight: o2, scrollTop: r2 }]) => {
    const s2 = $(), i2 = $(), l2 = ht(S(s2, E$1(Vo)));
    return O$1(
      S(
        l2,
        E$1((c2) => c2.totalCount)
      ),
      n2
    ), O$1(
      S(
        l2,
        E$1((c2) => c2.groupIndices)
      ),
      t2
    ), O$1(
      S(
        rt(r2, e2, o2),
        A$1(([c2, a2]) => Re(a2)),
        E$1(([c2, a2, m2]) => wt(a2.groupOffsetTree, Math.max(c2 - m2, 0), "v")[0]),
        Y(),
        E$1((c2) => [c2])
      ),
      i2
    ), { groupCounts: s2, topItemsIndexes: i2 };
  },
  X(Et, at)
), Pt = U$1(
  ([{ log: t2 }]) => {
    const e2 = w$1(false), n2 = ht(
      S(
        e2,
        A$1((o2) => o2),
        Y()
      )
    );
    return K$1(e2, (o2) => {
      o2 && ot(t2)("props updated", {}, mt.DEBUG);
    }), { didMount: n2, propsReady: e2 };
  },
  X(Vt),
  { singleton: true }
), Po = typeof document < "u" && "scrollBehavior" in document.documentElement.style;
function Dn(t2) {
  const e2 = typeof t2 == "number" ? { index: t2 } : t2;
  return e2.align || (e2.align = "start"), (!e2.behavior || !Po) && (e2.behavior = "auto"), e2.offset || (e2.offset = 0), e2;
}
const ce = U$1(
  ([
    { gap: t2, listRefresh: e2, sizes: n2, totalCount: o2 },
    {
      fixedFooterHeight: r2,
      fixedHeaderHeight: s2,
      footerHeight: i2,
      headerHeight: l2,
      scrollingInProgress: c2,
      scrollTo: a2,
      smoothScrollTargetReached: m2,
      viewportHeight: x2
    },
    { log: h2 }
  ]) => {
    const I = $(), C = $(), v2 = w$1(0);
    let g2 = null, p2 = null, u2 = null;
    function T() {
      g2 && (g2(), g2 = null), u2 && (u2(), u2 = null), p2 && (clearTimeout(p2), p2 = null), G$1(c2, false);
    }
    return O$1(
      S(
        I,
        N$1(n2, x2, o2, v2, l2, i2, h2),
        N$1(t2, s2, r2),
        E$1(
          ([
            [b2, f2, d2, y2, B, k2, L, z2],
            _23,
            J2,
            nt
          ]) => {
            const F = Dn(b2), { align: q2, behavior: it, offset: dt } = F, St = y2 - 1, ft = _n(F, f2, St);
            let ut = ie(ft, f2.offsetTree, _23) + k2;
            q2 === "end" ? (ut += J2 + wt(f2.sizeTree, ft)[1] - d2 + nt, ft === St && (ut += L)) : q2 === "center" ? ut += (J2 + wt(f2.sizeTree, ft)[1] - d2 + nt) / 2 : ut -= B, dt && (ut += dt);
            const At = (xt) => {
              T(), xt ? (z2("retrying to scroll to", { location: b2 }, mt.DEBUG), G$1(I, b2)) : (G$1(C, true), z2("list did not change, scroll successful", {}, mt.DEBUG));
            };
            if (T(), it === "smooth") {
              let xt = false;
              u2 = K$1(e2, (Xt) => {
                xt = xt || Xt;
              }), g2 = Tt(m2, () => {
                At(xt);
              });
            } else
              g2 = Tt(S(e2, Ao(150)), At);
            return p2 = setTimeout(() => {
              T();
            }, 1200), G$1(c2, true), z2("scrolling from index to", { behavior: it, index: ft, top: ut }, mt.DEBUG), { behavior: it, top: ut };
          }
        )
      ),
      a2
    ), {
      scrollTargetReached: C,
      scrollToIndex: I,
      topListHeight: v2
    };
  },
  X(Et, at, Vt),
  { singleton: true }
);
function Ao(t2) {
  return (e2) => {
    const n2 = setTimeout(() => {
      e2(false);
    }, t2);
    return (o2) => {
      o2 && (e2(true), clearTimeout(n2));
    };
  };
}
function Ue(t2, e2) {
  t2 == 0 ? e2() : requestAnimationFrame(() => {
    Ue(t2 - 1, e2);
  });
}
function Ke(t2, e2) {
  const n2 = e2 - 1;
  return typeof t2 == "number" ? t2 : t2.index === "LAST" ? n2 : t2.index;
}
const ue = U$1(
  ([{ defaultItemSize: t2, listRefresh: e2, sizes: n2 }, { scrollTop: o2 }, { scrollTargetReached: r2, scrollToIndex: s2 }, { didMount: i2 }]) => {
    const l2 = w$1(true), c2 = w$1(0), a2 = w$1(true);
    return O$1(
      S(
        i2,
        N$1(c2),
        A$1(([m2, x2]) => !!x2),
        Rt(false)
      ),
      l2
    ), O$1(
      S(
        i2,
        N$1(c2),
        A$1(([m2, x2]) => !!x2),
        Rt(false)
      ),
      a2
    ), K$1(
      S(
        rt(e2, i2),
        N$1(l2, n2, t2, a2),
        A$1(([[, m2], x2, { sizeTree: h2 }, I, C]) => m2 && (!j(h2) || We(I)) && !x2 && !C),
        N$1(c2)
      ),
      ([, m2]) => {
        Tt(r2, () => {
          G$1(a2, true);
        }), Ue(4, () => {
          Tt(o2, () => {
            G$1(l2, true);
          }), G$1(s2, m2);
        });
      }
    ), {
      initialItemFinalLocationReached: a2,
      initialTopMostItemIndex: c2,
      scrolledToInitialItem: l2
    };
  },
  X(Et, at, ce, Pt),
  { singleton: true }
);
function $n(t2, e2) {
  return Math.abs(t2 - e2) < 1.01;
}
const le = "up", te = "down", Mo = "none", Wo = {
  atBottom: false,
  notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
  state: {
    offsetBottom: 0,
    scrollHeight: 0,
    scrollTop: 0,
    viewportHeight: 0
  }
}, Go = 0, ae = U$1(([{ footerHeight: t2, headerHeight: e2, scrollBy: n2, scrollContainerState: o2, scrollTop: r2, viewportHeight: s2 }]) => {
  const i2 = w$1(false), l2 = w$1(true), c2 = $(), a2 = $(), m2 = w$1(4), x2 = w$1(Go), h2 = ct(
    S(
      Le(S(V$1(r2), Dt(1), Rt(true)), S(V$1(r2), Dt(1), Rt(false), dn(100))),
      Y()
    ),
    false
  ), I = ct(
    S(Le(S(n2, Rt(true)), S(n2, Rt(false), dn(200))), Y()),
    false
  );
  O$1(
    S(
      rt(V$1(r2), V$1(x2)),
      E$1(([u2, T]) => u2 <= T),
      Y()
    ),
    l2
  ), O$1(S(l2, kt(50)), a2);
  const C = ht(
    S(
      rt(o2, V$1(s2), V$1(e2), V$1(t2), V$1(m2)),
      bt((u2, [{ scrollHeight: T, scrollTop: b2 }, f2, d2, y2, B]) => {
        const k2 = b2 + f2 - T > -B, L = {
          scrollHeight: T,
          scrollTop: b2,
          viewportHeight: f2
        };
        if (k2) {
          let _23, J2;
          return b2 > u2.state.scrollTop ? (_23 = "SCROLLED_DOWN", J2 = u2.state.scrollTop - b2) : (_23 = "SIZE_DECREASED", J2 = u2.state.scrollTop - b2 || u2.scrollTopDelta), {
            atBottom: true,
            atBottomBecause: _23,
            scrollTopDelta: J2,
            state: L
          };
        }
        let z2;
        return L.scrollHeight > u2.state.scrollHeight ? z2 = "SIZE_INCREASED" : f2 < u2.state.viewportHeight ? z2 = "VIEWPORT_HEIGHT_DECREASING" : b2 < u2.state.scrollTop ? z2 = "SCROLLING_UPWARDS" : z2 = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM", {
          atBottom: false,
          notAtBottomBecause: z2,
          state: L
        };
      }, Wo),
      Y((u2, T) => u2 && u2.atBottom === T.atBottom)
    )
  ), v2 = ct(
    S(
      o2,
      bt(
        (u2, { scrollHeight: T, scrollTop: b2, viewportHeight: f2 }) => {
          if ($n(u2.scrollHeight, T))
            return {
              changed: false,
              jump: 0,
              scrollHeight: T,
              scrollTop: b2
            };
          {
            const d2 = T - (b2 + f2) < 1;
            return u2.scrollTop !== b2 && d2 ? {
              changed: true,
              jump: u2.scrollTop - b2,
              scrollHeight: T,
              scrollTop: b2
            } : {
              changed: true,
              jump: 0,
              scrollHeight: T,
              scrollTop: b2
            };
          }
        },
        { changed: false, jump: 0, scrollHeight: 0, scrollTop: 0 }
      ),
      A$1((u2) => u2.changed),
      E$1((u2) => u2.jump)
    ),
    0
  );
  O$1(
    S(
      C,
      E$1((u2) => u2.atBottom)
    ),
    i2
  ), O$1(S(i2, kt(50)), c2);
  const g2 = w$1(te);
  O$1(
    S(
      o2,
      E$1(({ scrollTop: u2 }) => u2),
      Y(),
      bt(
        (u2, T) => ot(I) ? { direction: u2.direction, prevScrollTop: T } : { direction: T < u2.prevScrollTop ? le : te, prevScrollTop: T },
        { direction: te, prevScrollTop: 0 }
      ),
      E$1((u2) => u2.direction)
    ),
    g2
  ), O$1(S(o2, kt(50), Rt(Mo)), g2);
  const p2 = w$1(0);
  return O$1(
    S(
      h2,
      A$1((u2) => !u2),
      Rt(0)
    ),
    p2
  ), O$1(
    S(
      r2,
      kt(100),
      N$1(h2),
      A$1(([u2, T]) => !!T),
      bt(([u2, T], [b2]) => [T, b2], [0, 0]),
      E$1(([u2, T]) => T - u2)
    ),
    p2
  ), {
    atBottomState: C,
    atBottomStateChange: c2,
    atBottomThreshold: m2,
    atTopStateChange: a2,
    atTopThreshold: x2,
    isAtBottom: i2,
    isAtTop: l2,
    isScrolling: h2,
    lastJumpDueToItemResize: v2,
    scrollDirection: g2,
    scrollVelocity: p2
  };
}, X(at)), xe = "top", Te = "bottom", hn = "none";
function gn(t2, e2, n2) {
  return typeof t2 == "number" ? n2 === le && e2 === xe || n2 === te && e2 === Te ? t2 : 0 : n2 === le ? e2 === xe ? t2.main : t2.reverse : e2 === Te ? t2.main : t2.reverse;
}
function In(t2, e2) {
  var n2;
  return typeof t2 == "number" ? t2 : (n2 = t2[e2]) != null ? n2 : 0;
}
const je = U$1(
  ([{ deviation: t2, fixedHeaderHeight: e2, headerHeight: n2, scrollTop: o2, viewportHeight: r2 }]) => {
    const s2 = $(), i2 = w$1(0), l2 = w$1(0), c2 = w$1(0), a2 = ct(
      S(
        rt(
          V$1(o2),
          V$1(r2),
          V$1(n2),
          V$1(s2, se),
          V$1(c2),
          V$1(i2),
          V$1(e2),
          V$1(t2),
          V$1(l2)
        ),
        E$1(
          ([
            m2,
            x2,
            h2,
            [I, C],
            v2,
            g2,
            p2,
            u2,
            T
          ]) => {
            const b2 = m2 - u2, f2 = g2 + p2, d2 = Math.max(h2 - b2, 0);
            let y2 = hn;
            const B = In(T, xe), k2 = In(T, Te);
            return I -= u2, I += h2 + p2, C += h2 + p2, C -= u2, I > m2 + f2 - B && (y2 = le), C < m2 - d2 + x2 + k2 && (y2 = te), y2 !== hn ? [
              Math.max(b2 - h2 - gn(v2, xe, y2) - B, 0),
              b2 - d2 - p2 + x2 + gn(v2, Te, y2) + k2
            ] : null;
          }
        ),
        A$1((m2) => m2 != null),
        Y(se)
      ),
      [0, 0]
    );
    return {
      increaseViewportBy: l2,
      // input
      listBoundary: s2,
      overscan: c2,
      topListHeight: i2,
      // output
      visibleRange: a2
    };
  },
  X(at),
  { singleton: true }
);
function _o(t2, e2, n2) {
  if (Re(e2)) {
    const o2 = Gn(t2, e2);
    return [
      { index: wt(e2.groupOffsetTree, o2)[0], offset: 0, size: 0 },
      { data: n2 == null ? void 0 : n2[0], index: o2, offset: 0, size: 0 }
    ];
  }
  return [{ data: n2 == null ? void 0 : n2[0], index: t2, offset: 0, size: 0 }];
}
const Be = {
  bottom: 0,
  firstItemIndex: 0,
  items: [],
  offsetBottom: 0,
  offsetTop: 0,
  top: 0,
  topItems: [],
  topListHeight: 0,
  totalCount: 0
};
function Ie(t2, e2, n2, o2, r2, s2) {
  const { lastIndex: i2, lastOffset: l2, lastSize: c2 } = r2;
  let a2 = 0, m2 = 0;
  if (t2.length > 0) {
    a2 = t2[0].offset;
    const v2 = t2[t2.length - 1];
    m2 = v2.offset + v2.size;
  }
  const x2 = n2 - i2, h2 = l2 + x2 * c2 + (x2 - 1) * o2, I = a2, C = h2 - m2;
  return {
    bottom: m2,
    firstItemIndex: s2,
    items: Sn(t2, r2, s2),
    offsetBottom: C,
    offsetTop: a2,
    top: I,
    topItems: Sn(e2, r2, s2),
    topListHeight: e2.reduce((v2, g2) => g2.size + v2, 0),
    totalCount: n2
  };
}
function Un(t2, e2, n2, o2, r2, s2) {
  let i2 = 0;
  if (n2.groupIndices.length > 0)
    for (const m2 of n2.groupIndices) {
      if (m2 - i2 >= t2)
        break;
      i2++;
    }
  const l2 = t2 + i2, c2 = Ke(e2, l2), a2 = Array.from({ length: l2 }).map((m2, x2) => ({
    data: s2[x2 + c2],
    index: x2 + c2,
    offset: 0,
    size: 0
  }));
  return Ie(a2, [], l2, r2, n2, o2);
}
function Sn(t2, e2, n2) {
  if (t2.length === 0)
    return [];
  if (!Re(e2))
    return t2.map((a2) => ({ ...a2, index: a2.index + n2, originalIndex: a2.index }));
  const o2 = t2[0].index, r2 = t2[t2.length - 1].index, s2 = [], i2 = ye(e2.groupOffsetTree, o2, r2);
  let l2, c2 = 0;
  for (const a2 of t2) {
    (!l2 || l2.end < a2.index) && (l2 = i2.shift(), c2 = e2.groupIndices.indexOf(l2.start));
    let m2;
    a2.index === l2.start ? m2 = {
      index: c2,
      type: "group"
    } : m2 = {
      groupIndex: c2,
      index: a2.index - (c2 + 1) + n2
    }, s2.push({
      ...m2,
      data: a2.data,
      offset: a2.offset,
      originalIndex: a2.index,
      size: a2.size
    });
  }
  return s2;
}
const $t = U$1(
  ([
    { data: t2, firstItemIndex: e2, gap: n2, sizes: o2, totalCount: r2 },
    s2,
    { listBoundary: i2, topListHeight: l2, visibleRange: c2 },
    { initialTopMostItemIndex: a2, scrolledToInitialItem: m2 },
    { topListHeight: x2 },
    h2,
    { didMount: I },
    { recalcInProgress: C }
  ]) => {
    const v2 = w$1([]), g2 = w$1(0), p2 = $();
    O$1(s2.topItemsIndexes, v2);
    const u2 = ct(
      S(
        rt(
          I,
          C,
          V$1(c2, se),
          V$1(r2),
          V$1(o2),
          V$1(a2),
          m2,
          V$1(v2),
          V$1(e2),
          V$1(n2),
          t2
        ),
        A$1(([d2, y2, , B, , , , , , , k2]) => {
          const L = k2 && k2.length !== B;
          return d2 && !y2 && !L;
        }),
        E$1(
          ([
            ,
            ,
            [d2, y2],
            B,
            k2,
            L,
            z2,
            _23,
            J2,
            nt,
            F
          ]) => {
            const q2 = k2, { offsetTree: it, sizeTree: dt } = q2, St = ot(g2);
            if (B === 0)
              return { ...Be, totalCount: B };
            if (d2 === 0 && y2 === 0)
              return St === 0 ? { ...Be, totalCount: B } : Un(St, L, k2, J2, nt, F || []);
            if (j(dt))
              return St > 0 ? null : Ie(
                _o(Ke(L, B), q2, F),
                [],
                B,
                nt,
                q2,
                J2
              );
            const ft = [];
            if (_23.length > 0) {
              const Mt = _23[0], yt = _23[_23.length - 1];
              let Bt = 0;
              for (const R of ye(dt, Mt, yt)) {
                const D2 = R.value, Q = Math.max(R.start, Mt), lt = Math.min(R.end, yt);
                for (let tt = Q; tt <= lt; tt++)
                  ft.push({ data: F == null ? void 0 : F[tt], index: tt, offset: Bt, size: D2 }), Bt += D2;
              }
            }
            if (!z2)
              return Ie([], ft, B, nt, q2, J2);
            const ut = _23.length > 0 ? _23[_23.length - 1] + 1 : 0, At = Bo(it, d2, y2, ut);
            if (At.length === 0)
              return null;
            const xt = B - 1, Xt = ve([], (Mt) => {
              for (const yt of At) {
                const Bt = yt.value;
                let R = Bt.offset, D2 = yt.start;
                const Q = Bt.size;
                if (Bt.offset < d2) {
                  D2 += Math.floor((d2 - Bt.offset + nt) / (Q + nt));
                  const tt = D2 - yt.start;
                  R += tt * Q + tt * nt;
                }
                D2 < ut && (R += (ut - D2) * Q, D2 = ut);
                const lt = Math.min(yt.end, xt);
                for (let tt = D2; tt <= lt && !(R >= y2); tt++)
                  Mt.push({ data: F == null ? void 0 : F[tt], index: tt, offset: R, size: Q }), R += Q + nt;
              }
            });
            return Ie(Xt, ft, B, nt, q2, J2);
          }
        ),
        //@ts-expect-error filter needs to be fixed
        A$1((d2) => d2 !== null),
        Y()
      ),
      Be
    );
    O$1(
      S(
        t2,
        A$1(We),
        E$1((d2) => d2 == null ? void 0 : d2.length)
      ),
      r2
    ), O$1(
      S(
        u2,
        E$1((d2) => d2.topListHeight)
      ),
      x2
    ), O$1(x2, l2), O$1(
      S(
        u2,
        E$1((d2) => [d2.top, d2.bottom])
      ),
      i2
    ), O$1(
      S(
        u2,
        E$1((d2) => d2.items)
      ),
      p2
    );
    const T = ht(
      S(
        u2,
        A$1(({ items: d2 }) => d2.length > 0),
        N$1(r2, t2),
        A$1(([{ items: d2 }, y2]) => d2[d2.length - 1].originalIndex === y2 - 1),
        E$1(([, d2, y2]) => [d2 - 1, y2]),
        Y(se),
        E$1(([d2]) => d2)
      )
    ), b2 = ht(
      S(
        u2,
        kt(200),
        A$1(({ items: d2, topItems: y2 }) => d2.length > 0 && d2[0].originalIndex === y2.length),
        E$1(({ items: d2 }) => d2[0].index),
        Y()
      )
    ), f2 = ht(
      S(
        u2,
        A$1(({ items: d2 }) => d2.length > 0),
        E$1(({ items: d2 }) => {
          let y2 = 0, B = d2.length - 1;
          for (; d2[y2].type === "group" && y2 < B; )
            y2++;
          for (; d2[B].type === "group" && B > y2; )
            B--;
          return {
            endIndex: d2[B].index,
            startIndex: d2[y2].index
          };
        }),
        Y(Mn)
      )
    );
    return { endReached: T, initialItemCount: g2, itemsRendered: p2, listState: u2, rangeChanged: f2, startReached: b2, topItemsIndexes: v2, ...h2 };
  },
  X(
    Et,
    Nn,
    je,
    ue,
    ce,
    ae,
    Pt,
    De
  ),
  { singleton: true }
), Kn = U$1(
  ([{ fixedFooterHeight: t2, fixedHeaderHeight: e2, footerHeight: n2, headerHeight: o2 }, { listState: r2 }]) => {
    const s2 = $(), i2 = ct(
      S(
        rt(n2, t2, o2, e2, r2),
        E$1(([l2, c2, a2, m2, x2]) => l2 + c2 + a2 + m2 + x2.offsetBottom + x2.bottom)
      ),
      0
    );
    return O$1(V$1(i2), s2), { totalListHeight: i2, totalListHeightChanged: s2 };
  },
  X(at, $t),
  { singleton: true }
), No = U$1(
  ([{ viewportHeight: t2 }, { totalListHeight: e2 }]) => {
    const n2 = w$1(false), o2 = ct(
      S(
        rt(n2, t2, e2),
        A$1(([r2]) => r2),
        E$1(([, r2, s2]) => Math.max(0, r2 - s2)),
        kt(0),
        Y()
      ),
      0
    );
    return { alignToBottom: n2, paddingTopAddition: o2 };
  },
  X(at, Kn),
  { singleton: true }
), jn = U$1(() => ({
  context: w$1(null)
})), Do = ({
  itemBottom: t2,
  itemTop: e2,
  locationParams: { align: n2, behavior: o2, ...r2 },
  viewportBottom: s2,
  viewportTop: i2
}) => e2 < i2 ? { ...r2, align: n2 != null ? n2 : "start", behavior: o2 } : t2 > s2 ? { ...r2, align: n2 != null ? n2 : "end", behavior: o2 } : null, qn = U$1(
  ([
    { gap: t2, sizes: e2, totalCount: n2 },
    { fixedFooterHeight: o2, fixedHeaderHeight: r2, headerHeight: s2, scrollingInProgress: i2, scrollTop: l2, viewportHeight: c2 },
    { scrollToIndex: a2 }
  ]) => {
    const m2 = $();
    return O$1(
      S(
        m2,
        N$1(e2, c2, n2, s2, r2, o2, l2),
        N$1(t2),
        E$1(([[x2, h2, I, C, v2, g2, p2, u2], T]) => {
          const { align: b2, behavior: f2, calculateViewLocation: d2 = Do, done: y2, ...B } = x2, k2 = _n(x2, h2, C - 1), L = ie(k2, h2.offsetTree, T) + v2 + g2, z2 = L + wt(h2.sizeTree, k2)[1], _23 = u2 + g2, J2 = u2 + I - p2, nt = d2({
            itemBottom: z2,
            itemTop: L,
            locationParams: { align: b2, behavior: f2, ...B },
            viewportBottom: J2,
            viewportTop: _23
          });
          return nt ? y2 && Tt(
            S(
              i2,
              A$1((F) => !F),
              // skips the initial publish of false, and the cleanup call.
              // but if scrollingInProgress is true, we skip the initial publish.
              Dt(ot(i2) ? 1 : 2)
            ),
            y2
          ) : y2 && y2(), nt;
        }),
        A$1((x2) => x2 !== null)
      ),
      a2
    ), {
      scrollIntoView: m2
    };
  },
  X(Et, at, ce, $t, Vt),
  { singleton: true }
);
function xn(t2) {
  return t2 ? t2 === "smooth" ? "smooth" : "auto" : false;
}
const $o = (t2, e2) => typeof t2 == "function" ? xn(t2(e2)) : e2 && xn(t2), Uo = U$1(
  ([
    { listRefresh: t2, totalCount: e2, fixedItemSize: n2, data: o2 },
    { atBottomState: r2, isAtBottom: s2 },
    { scrollToIndex: i2 },
    { scrolledToInitialItem: l2 },
    { didMount: c2, propsReady: a2 },
    { log: m2 },
    { scrollingInProgress: x2 },
    { context: h2 },
    { scrollIntoView: I }
  ]) => {
    const C = w$1(false), v2 = $();
    let g2 = null;
    function p2(f2) {
      G$1(i2, {
        align: "end",
        behavior: f2,
        index: "LAST"
      });
    }
    K$1(
      S(
        rt(S(V$1(e2), Dt(1)), c2),
        N$1(V$1(C), s2, l2, x2),
        E$1(([[f2, d2], y2, B, k2, L]) => {
          let z2 = d2 && k2, _23 = "auto";
          return z2 && (_23 = $o(y2, B || L), z2 = z2 && !!_23), { followOutputBehavior: _23, shouldFollow: z2, totalCount: f2 };
        }),
        A$1(({ shouldFollow: f2 }) => f2)
      ),
      ({ followOutputBehavior: f2, totalCount: d2 }) => {
        g2 && (g2(), g2 = null), ot(n2) ? requestAnimationFrame(() => {
          ot(m2)("following output to ", { totalCount: d2 }, mt.DEBUG), p2(f2);
        }) : g2 = Tt(t2, () => {
          ot(m2)("following output to ", { totalCount: d2 }, mt.DEBUG), p2(f2), g2 = null;
        });
      }
    );
    function u2(f2) {
      const d2 = Tt(r2, (y2) => {
        f2 && !y2.atBottom && y2.notAtBottomBecause === "SIZE_INCREASED" && !g2 && (ot(m2)("scrolling to bottom due to increased size", {}, mt.DEBUG), p2("auto"));
      });
      setTimeout(d2, 100);
    }
    K$1(
      S(
        rt(V$1(C), e2, a2),
        A$1(([f2, , d2]) => f2 && d2),
        bt(
          ({ value: f2 }, [, d2]) => ({ refreshed: f2 === d2, value: d2 }),
          { refreshed: false, value: 0 }
        ),
        A$1(({ refreshed: f2 }) => f2),
        N$1(C, e2)
      ),
      ([, f2]) => {
        ot(l2) && u2(f2 !== false);
      }
    ), K$1(v2, () => {
      u2(ot(C) !== false);
    }), K$1(rt(V$1(C), r2), ([f2, d2]) => {
      f2 && !d2.atBottom && d2.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && p2("auto");
    });
    const T = w$1(null), b2 = $();
    return O$1(
      Le(
        S(
          V$1(o2),
          E$1((f2) => {
            var d2;
            return (d2 = f2 == null ? void 0 : f2.length) != null ? d2 : 0;
          })
        ),
        S(V$1(e2))
      ),
      b2
    ), K$1(
      S(
        rt(S(b2, Dt(1)), c2),
        N$1(V$1(T), l2, x2, h2),
        E$1(([[f2, d2], y2, B, k2, L]) => d2 && B && (y2 == null ? void 0 : y2({ context: L, totalCount: f2, scrollingInProgress: k2 }))),
        A$1((f2) => !!f2),
        kt(0)
      ),
      (f2) => {
        g2 && (g2(), g2 = null), ot(n2) ? requestAnimationFrame(() => {
          ot(m2)("scrolling into view", {}), G$1(I, f2);
        }) : g2 = Tt(t2, () => {
          ot(m2)("scrolling into view", {}), G$1(I, f2), g2 = null;
        });
      }
    ), { autoscrollToBottom: v2, followOutput: C, scrollIntoViewOnChange: T };
  },
  X(
    Et,
    ae,
    ce,
    ue,
    Pt,
    Vt,
    at,
    jn,
    qn
  )
), Ko = U$1(
  ([{ data: t2, firstItemIndex: e2, gap: n2, sizes: o2 }, { initialTopMostItemIndex: r2 }, { initialItemCount: s2, listState: i2 }, { didMount: l2 }]) => (O$1(
    S(
      l2,
      N$1(s2),
      A$1(([, c2]) => c2 !== 0),
      N$1(r2, o2, e2, n2, t2),
      E$1(([[, c2], a2, m2, x2, h2, I = []]) => Un(c2, a2, m2, x2, h2, I))
    ),
    i2
  ), {}),
  X(Et, ue, $t, Pt),
  { singleton: true }
), jo = U$1(
  ([{ didMount: t2 }, { scrollTo: e2 }, { listState: n2 }]) => {
    const o2 = w$1(0);
    return K$1(
      S(
        t2,
        N$1(o2),
        A$1(([, r2]) => r2 !== 0),
        E$1(([, r2]) => ({ top: r2 }))
      ),
      (r2) => {
        Tt(
          S(
            n2,
            Dt(1),
            A$1((s2) => s2.items.length > 1)
          ),
          () => {
            requestAnimationFrame(() => {
              G$1(e2, r2);
            });
          }
        );
      }
    ), {
      initialScrollTop: o2
    };
  },
  X(Pt, at, $t),
  { singleton: true }
), Yn = U$1(
  ([{ scrollVelocity: t2 }]) => {
    const e2 = w$1(false), n2 = $(), o2 = w$1(false);
    return O$1(
      S(
        t2,
        N$1(o2, e2, n2),
        A$1(([r2, s2]) => !!s2),
        E$1(([r2, s2, i2, l2]) => {
          const { enter: c2, exit: a2 } = s2;
          if (i2) {
            if (a2(r2, l2))
              return false;
          } else if (c2(r2, l2))
            return true;
          return i2;
        }),
        Y()
      ),
      e2
    ), K$1(
      S(rt(e2, t2, n2), N$1(o2)),
      ([[r2, s2, i2], l2]) => {
        r2 && l2 && l2.change && l2.change(s2, i2);
      }
    ), { isSeeking: e2, scrollSeekConfiguration: o2, scrollSeekRangeChanged: n2, scrollVelocity: t2 };
  },
  X(ae),
  { singleton: true }
), qe = U$1(([{ scrollContainerState: t2, scrollTo: e2 }]) => {
  const n2 = $(), o2 = $(), r2 = $(), s2 = w$1(false), i2 = w$1(void 0);
  return O$1(
    S(
      rt(n2, o2),
      E$1(([{ scrollHeight: l2, scrollTop: c2, viewportHeight: a2 }, { offsetTop: m2 }]) => ({
        scrollHeight: l2,
        scrollTop: Math.max(0, c2 - m2),
        viewportHeight: a2
      }))
    ),
    t2
  ), O$1(
    S(
      e2,
      N$1(o2),
      E$1(([l2, { offsetTop: c2 }]) => ({
        ...l2,
        top: l2.top + c2
      }))
    ),
    r2
  ), {
    customScrollParent: i2,
    // config
    useWindowScroll: s2,
    // input
    windowScrollContainerState: n2,
    // signals
    windowScrollTo: r2,
    windowViewportRect: o2
  };
}, X(at)), qo = U$1(
  ([
    { sizeRanges: t2, sizes: e2 },
    { headerHeight: n2, scrollTop: o2 },
    { initialTopMostItemIndex: r2 },
    { didMount: s2 },
    { useWindowScroll: i2, windowScrollContainerState: l2, windowViewportRect: c2 }
  ]) => {
    const a2 = $(), m2 = w$1(void 0), x2 = w$1(null), h2 = w$1(null);
    return O$1(l2, x2), O$1(c2, h2), K$1(
      S(
        a2,
        N$1(e2, o2, i2, x2, h2, n2)
      ),
      ([I, C, v2, g2, p2, u2, T]) => {
        const b2 = Fo(C.sizeTree);
        g2 && p2 !== null && u2 !== null && (v2 = p2.scrollTop - u2.offsetTop), v2 -= T, I({ ranges: b2, scrollTop: v2 });
      }
    ), O$1(S(m2, A$1(We), E$1(Yo)), r2), O$1(
      S(
        s2,
        N$1(m2),
        A$1(([, I]) => I !== void 0),
        Y(),
        E$1(([, I]) => I.ranges)
      ),
      t2
    ), {
      getState: a2,
      restoreStateFrom: m2
    };
  },
  X(Et, at, ue, Pt, qe)
);
function Yo(t2) {
  return { align: "start", index: 0, offset: t2.scrollTop };
}
const Zo = U$1(([{ topItemsIndexes: t2 }]) => {
  const e2 = w$1(0);
  return O$1(
    S(
      e2,
      A$1((n2) => n2 >= 0),
      E$1((n2) => Array.from({ length: n2 }).map((o2, r2) => r2))
    ),
    t2
  ), { topItemCount: e2 };
}, X($t));
function Zn(t2) {
  let e2 = false, n2;
  return () => (e2 || (e2 = true, n2 = t2()), n2);
}
const Xo = Zn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent)), Jo = U$1(
  ([
    { deviation: t2, scrollBy: e2, scrollingInProgress: n2, scrollTop: o2 },
    { isAtBottom: r2, isScrolling: s2, lastJumpDueToItemResize: i2, scrollDirection: l2 },
    { listState: c2 },
    { beforeUnshiftWith: a2, gap: m2, shiftWithOffset: x2, sizes: h2 },
    { log: I },
    { recalcInProgress: C }
  ]) => {
    const v2 = ht(
      S(
        c2,
        N$1(i2),
        bt(
          ([, p2, u2, T], [{ bottom: b2, items: f2, offsetBottom: d2, totalCount: y2 }, B]) => {
            const k2 = b2 + d2;
            let L = 0;
            return u2 === y2 && p2.length > 0 && f2.length > 0 && (f2[0].originalIndex === 0 && p2[0].originalIndex === 0 || (L = k2 - T, L !== 0 && (L += B))), [L, f2, y2, k2];
          },
          [0, [], 0, 0]
        ),
        A$1(([p2]) => p2 !== 0),
        N$1(o2, l2, n2, r2, I, C),
        A$1(([, p2, u2, T, , , b2]) => !b2 && !T && p2 !== 0 && u2 === le),
        E$1(([[p2], , , , , u2]) => (u2("Upward scrolling compensation", { amount: p2 }, mt.DEBUG), p2))
      )
    );
    function g2(p2) {
      p2 > 0 ? (G$1(e2, { behavior: "auto", top: -p2 }), G$1(t2, 0)) : (G$1(t2, 0), G$1(e2, { behavior: "auto", top: -p2 }));
    }
    return K$1(S(v2, N$1(t2, s2)), ([p2, u2, T]) => {
      T && Xo() ? G$1(t2, u2 - p2) : g2(-p2);
    }), K$1(
      S(
        rt(ct(s2, false), t2, C),
        A$1(([p2, u2, T]) => !p2 && !T && u2 !== 0),
        E$1(([p2, u2]) => u2),
        kt(1)
      ),
      g2
    ), O$1(
      S(
        x2,
        E$1((p2) => ({ top: -p2 }))
      ),
      e2
    ), K$1(
      S(
        a2,
        N$1(h2, m2),
        E$1(([p2, { groupIndices: u2, lastSize: T, sizeTree: b2 }, f2]) => {
          function d2(y2) {
            return y2 * (T + f2);
          }
          if (u2.length === 0)
            return d2(p2);
          {
            let y2 = 0;
            const B = re(b2, 0);
            let k2 = 0, L = 0;
            for (; k2 < p2; ) {
              k2++, y2 += B;
              let z2 = u2.length === L + 1 ? 1 / 0 : u2[L + 1] - u2[L] - 1;
              k2 + z2 > p2 && (y2 -= B, z2 = p2 - k2 + 1), k2 += z2, y2 += d2(z2), L++;
            }
            return y2;
          }
        })
      ),
      (p2) => {
        G$1(t2, p2), requestAnimationFrame(() => {
          G$1(e2, { top: p2 }), requestAnimationFrame(() => {
            G$1(t2, 0), G$1(C, false);
          });
        });
      }
    ), { deviation: t2 };
  },
  X(at, ae, $t, Et, Vt, De)
), Qo = U$1(
  ([
    t2,
    e2,
    n2,
    o2,
    r2,
    s2,
    i2,
    l2,
    c2,
    a2,
    m2
  ]) => ({
    ...t2,
    ...e2,
    ...n2,
    ...o2,
    ...r2,
    ...s2,
    ...i2,
    ...l2,
    ...c2,
    ...a2,
    ...m2
  }),
  X(
    je,
    Ko,
    Pt,
    Yn,
    Kn,
    jo,
    No,
    qe,
    qn,
    Vt,
    jn
  )
), Xn = U$1(
  ([
    {
      data: t2,
      defaultItemSize: e2,
      firstItemIndex: n2,
      fixedItemSize: o2,
      gap: r2,
      groupIndices: s2,
      itemSize: i2,
      sizeRanges: l2,
      sizes: c2,
      statefulTotalCount: a2,
      totalCount: m2,
      trackItemSizes: x2
    },
    { initialItemFinalLocationReached: h2, initialTopMostItemIndex: I, scrolledToInitialItem: C },
    v2,
    g2,
    p2,
    { listState: u2, topItemsIndexes: T, ...b2 },
    { scrollToIndex: f2 },
    d2,
    { topItemCount: y2 },
    { groupCounts: B },
    k2
  ]) => (O$1(b2.rangeChanged, k2.scrollSeekRangeChanged), O$1(
    S(
      k2.windowViewportRect,
      E$1((L) => L.visibleHeight)
    ),
    v2.viewportHeight
  ), {
    data: t2,
    defaultItemHeight: e2,
    firstItemIndex: n2,
    fixedItemHeight: o2,
    gap: r2,
    groupCounts: B,
    initialItemFinalLocationReached: h2,
    initialTopMostItemIndex: I,
    scrolledToInitialItem: C,
    sizeRanges: l2,
    topItemCount: y2,
    topItemsIndexes: T,
    // input
    totalCount: m2,
    ...p2,
    groupIndices: s2,
    itemSize: i2,
    listState: u2,
    scrollToIndex: f2,
    // output
    statefulTotalCount: a2,
    trackItemSizes: x2,
    // exported from stateFlagsSystem
    ...b2,
    // the bag of IO from featureGroup1System
    ...k2,
    ...v2,
    sizes: c2,
    ...g2
  }),
  X(
    Et,
    ue,
    at,
    qo,
    Uo,
    $t,
    ce,
    Jo,
    Zo,
    Nn,
    Qo
  )
);
function tr(t2, e2) {
  const n2 = {}, o2 = {};
  let r2 = 0;
  const s2 = t2.length;
  for (; r2 < s2; )
    o2[t2[r2]] = 1, r2 += 1;
  for (const i2 in e2)
    Object.hasOwn(o2, i2) || (n2[i2] = e2[i2]);
  return n2;
}
const pe = typeof document < "u" ? React.useLayoutEffect : React.useEffect;
function Ye(t2, e2, n2) {
  const o2 = Object.keys(e2.required || {}), r2 = Object.keys(e2.optional || {}), s2 = Object.keys(e2.methods || {}), i2 = Object.keys(e2.events || {}), l2 = React.createContext({});
  function c2(p2, u2) {
    p2.propsReady && G$1(p2.propsReady, false);
    for (const T of o2) {
      const b2 = p2[e2.required[T]];
      G$1(b2, u2[T]);
    }
    for (const T of r2)
      if (T in u2) {
        const b2 = p2[e2.optional[T]];
        G$1(b2, u2[T]);
      }
    p2.propsReady && G$1(p2.propsReady, true);
  }
  function a2(p2) {
    return s2.reduce((u2, T) => (u2[T] = (b2) => {
      const f2 = p2[e2.methods[T]];
      G$1(f2, b2);
    }, u2), {});
  }
  function m2(p2) {
    return i2.reduce((u2, T) => (u2[T] = Io(p2[e2.events[T]]), u2), {});
  }
  const x2 = React.forwardRef((p2, u2) => {
    const { children: T, ...b2 } = p2, [f2] = React.useState(() => ve(xo(t2), (B) => {
      c2(B, b2);
    })), [d2] = React.useState(an(m2, f2));
    pe(() => {
      for (const B of i2)
        B in b2 && K$1(d2[B], b2[B]);
      return () => {
        Object.values(d2).map(Ge);
      };
    }, [b2, d2, f2]), pe(() => {
      c2(f2, b2);
    }), React.useImperativeHandle(u2, un(a2(f2)));
    const y2 = n2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(l2.Provider, { value: f2, children: n2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(y2, { ...tr([...o2, ...r2, ...i2], b2), children: T }) : T });
  }), h2 = (p2) => {
    const u2 = React.useContext(l2);
    return React.useCallback(
      (T) => {
        G$1(u2[p2], T);
      },
      [u2, p2]
    );
  }, I = (p2) => {
    const T = React.useContext(l2)[p2], b2 = React.useCallback(
      (f2) => K$1(T, f2),
      [T]
    );
    return React.useSyncExternalStore(
      b2,
      () => ot(T),
      () => ot(T)
    );
  }, C = (p2) => {
    const T = React.useContext(l2)[p2], [b2, f2] = React.useState(an(ot, T));
    return pe(
      () => K$1(T, (d2) => {
        d2 !== b2 && f2(un(d2));
      }),
      [T, b2]
    ), b2;
  }, v2 = React.version.startsWith("18") ? I : C;
  return {
    Component: x2,
    useEmitter: (p2, u2) => {
      const b2 = React.useContext(l2)[p2];
      pe(() => K$1(b2, u2), [u2, b2]);
    },
    useEmitterValue: v2,
    usePublisher: h2
  };
}
const be = React.createContext(void 0), Jn = React.createContext(void 0), Qn = typeof document < "u" ? React.useLayoutEffect : React.useEffect;
function ke(t2) {
  return "self" in t2;
}
function er(t2) {
  return "body" in t2;
}
function to(t2, e2, n2, o2 = Yt, r2, s2) {
  const i2 = React.useRef(null), l2 = React.useRef(null), c2 = React.useRef(null), a2 = React.useCallback(
    (h2) => {
      let I, C, v2;
      const g2 = h2.target;
      if (er(g2) || ke(g2)) {
        const u2 = ke(g2) ? g2 : g2.defaultView;
        v2 = s2 ? u2.scrollX : u2.scrollY, I = s2 ? u2.document.documentElement.scrollWidth : u2.document.documentElement.scrollHeight, C = s2 ? u2.innerWidth : u2.innerHeight;
      } else
        v2 = s2 ? g2.scrollLeft : g2.scrollTop, I = s2 ? g2.scrollWidth : g2.scrollHeight, C = s2 ? g2.offsetWidth : g2.offsetHeight;
      const p2 = () => {
        t2({
          scrollHeight: I,
          scrollTop: Math.max(v2, 0),
          viewportHeight: C
        });
      };
      h2.suppressFlushSync ? p2() : ao.flushSync(p2), l2.current !== null && (v2 === l2.current || v2 <= 0 || v2 === I - C) && (l2.current = null, e2(true), c2.current && (clearTimeout(c2.current), c2.current = null));
    },
    [t2, e2, s2]
  );
  React.useEffect(() => {
    const h2 = r2 || i2.current;
    return o2(r2 || i2.current), a2({ suppressFlushSync: true, target: h2 }), h2.addEventListener("scroll", a2, { passive: true }), () => {
      o2(null), h2.removeEventListener("scroll", a2);
    };
  }, [i2, a2, n2, o2, r2]);
  function m2(h2) {
    const I = i2.current;
    if (!I || (s2 ? "offsetWidth" in I && I.offsetWidth === 0 : "offsetHeight" in I && I.offsetHeight === 0))
      return;
    const C = h2.behavior === "smooth";
    let v2, g2, p2;
    ke(I) ? (g2 = Math.max(
      vt(I.document.documentElement, s2 ? "width" : "height"),
      s2 ? I.document.documentElement.scrollWidth : I.document.documentElement.scrollHeight
    ), v2 = s2 ? I.innerWidth : I.innerHeight, p2 = s2 ? window.scrollX : window.scrollY) : (g2 = I[s2 ? "scrollWidth" : "scrollHeight"], v2 = vt(I, s2 ? "width" : "height"), p2 = I[s2 ? "scrollLeft" : "scrollTop"]);
    const u2 = g2 - v2;
    if (h2.top = Math.ceil(Math.max(Math.min(u2, h2.top), 0)), $n(v2, g2) || h2.top === p2) {
      t2({ scrollHeight: g2, scrollTop: p2, viewportHeight: v2 }), C && e2(true);
      return;
    }
    C ? (l2.current = h2.top, c2.current && clearTimeout(c2.current), c2.current = setTimeout(() => {
      c2.current = null, l2.current = null, e2(true);
    }, 1e3)) : l2.current = null, s2 && (h2 = { behavior: h2.behavior, left: h2.top }), I.scrollTo(h2);
  }
  function x2(h2) {
    s2 && (h2 = { behavior: h2.behavior, left: h2.top }), i2.current.scrollBy(h2);
  }
  return { scrollByCallback: x2, scrollerRef: i2, scrollToCallback: m2 };
}
const Fe = "-webkit-sticky", Tn = "sticky", Ze = Zn(() => {
  if (typeof document > "u")
    return Tn;
  const t2 = document.createElement("div");
  return t2.style.position = Fe, t2.style.position === Fe ? Fe : Tn;
});
function Xe(t2) {
  return t2;
}
const nr = /* @__PURE__ */ U$1(() => {
  const t2 = w$1((l2) => "Item ".concat(l2)), e2 = w$1((l2) => "Group ".concat(l2)), n2 = w$1({}), o2 = w$1(Xe), r2 = w$1("div"), s2 = w$1(Yt), i2 = (l2, c2 = null) => ct(
    S(
      n2,
      E$1((a2) => a2[l2]),
      Y()
    ),
    c2
  );
  return {
    components: n2,
    computeItemKey: o2,
    EmptyPlaceholder: i2("EmptyPlaceholder"),
    FooterComponent: i2("Footer"),
    GroupComponent: i2("Group", "div"),
    groupContent: e2,
    HeaderComponent: i2("Header"),
    HeaderFooterTag: r2,
    ItemComponent: i2("Item", "div"),
    itemContent: t2,
    ListComponent: i2("List", "div"),
    ScrollerComponent: i2("Scroller", "div"),
    scrollerRef: s2,
    ScrollSeekPlaceholder: i2("ScrollSeekPlaceholder"),
    TopItemListComponent: i2("TopItemList")
  };
}), or = /* @__PURE__ */ U$1(
  ([t2, e2]) => ({ ...t2, ...e2 }),
  X(Xn, nr)
), rr = ({ height: t2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: t2 } }), sr = { overflowAnchor: "none", position: Ze(), zIndex: 1 }, eo = { overflowAnchor: "none" }, ir = { ...eo, display: "inline-block", height: "100%" }, Cn = /* @__PURE__ */ React.memo(function({ showTopList: e2 = false }) {
  const n2 = M("listState"), o2 = gt("sizeRanges"), r2 = M("useWindowScroll"), s2 = M("customScrollParent"), i2 = gt("windowScrollContainerState"), l2 = gt("scrollContainerState"), c2 = s2 || r2 ? i2 : l2, a2 = M("itemContent"), m2 = M("context"), x2 = M("groupContent"), h2 = M("trackItemSizes"), I = M("itemSize"), C = M("log"), v2 = gt("gap"), g2 = M("horizontalDirection"), { callbackRef: p2 } = On(
    o2,
    I,
    h2,
    e2 ? Yt : c2,
    C,
    v2,
    s2,
    g2,
    M("skipAnimationFrameInResizeObserver")
  ), [u2, T] = React.useState(0);
  tn("deviation", (F) => {
    u2 !== F && T(F);
  });
  const b2 = M("EmptyPlaceholder"), f2 = M("ScrollSeekPlaceholder") || rr, d2 = M("ListComponent"), y2 = M("ItemComponent"), B = M("GroupComponent"), k2 = M("computeItemKey"), L = M("isSeeking"), z2 = M("groupIndices").length > 0, _23 = M("alignToBottom"), J2 = M("initialItemFinalLocationReached"), nt = e2 ? {} : {
    boxSizing: "border-box",
    ...g2 ? {
      display: "inline-block",
      height: "100%",
      marginLeft: u2 !== 0 ? u2 : _23 ? "auto" : 0,
      paddingLeft: n2.offsetTop,
      paddingRight: n2.offsetBottom,
      whiteSpace: "nowrap"
    } : {
      marginTop: u2 !== 0 ? u2 : _23 ? "auto" : 0,
      paddingBottom: n2.offsetBottom,
      paddingTop: n2.offsetTop
    },
    ...J2 ? {} : { visibility: "hidden" }
  };
  return !e2 && n2.totalCount === 0 && b2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(b2, { ...Z(b2, m2) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    d2,
    {
      ...Z(d2, m2),
      "data-testid": e2 ? "virtuoso-top-item-list" : "virtuoso-item-list",
      ref: p2,
      style: nt,
      children: (e2 ? n2.topItems : n2.items).map((F) => {
        const q2 = F.originalIndex, it = k2(q2 + n2.firstItemIndex, F.data, m2);
        return L ? /* @__PURE__ */ reactExports.createElement(
          f2,
          {
            ...Z(f2, m2),
            height: F.size,
            index: F.index,
            key: it,
            type: F.type || "item",
            ...F.type === "group" ? {} : { groupIndex: F.groupIndex }
          }
        ) : F.type === "group" ? /* @__PURE__ */ reactExports.createElement(
          B,
          {
            ...Z(B, m2),
            "data-index": q2,
            "data-item-index": F.index,
            "data-known-size": F.size,
            key: it,
            style: sr
          },
          x2(F.index, m2)
        ) : /* @__PURE__ */ reactExports.createElement(
          y2,
          {
            ...Z(y2, m2),
            ...no(y2, F.data),
            "data-index": q2,
            "data-item-group-index": F.groupIndex,
            "data-item-index": F.index,
            "data-known-size": F.size,
            key: it,
            style: g2 ? ir : eo
          },
          z2 ? a2(F.index, F.groupIndex, F.data, m2) : a2(F.index, F.data, m2)
        );
      })
    }
  );
}), lr = {
  height: "100%",
  outline: "none",
  overflowY: "auto",
  position: "relative",
  WebkitOverflowScrolling: "touch"
}, cr = {
  outline: "none",
  overflowX: "auto",
  position: "relative"
}, Zt = (t2) => ({
  height: "100%",
  position: "absolute",
  top: 0,
  width: "100%",
  ...t2 ? { display: "flex", flexDirection: "column" } : {}
}), ur = {
  position: Ze(),
  top: 0,
  width: "100%",
  zIndex: 1
};
function Z(t2, e2) {
  if (typeof t2 != "string")
    return { context: e2 };
}
function no(t2, e2) {
  return { item: typeof t2 == "string" ? void 0 : e2 };
}
const ar = /* @__PURE__ */ React.memo(function() {
  const e2 = M("HeaderComponent"), n2 = gt("headerHeight"), o2 = M("HeaderFooterTag"), r2 = Ht(
    React.useMemo(
      () => (i2) => {
        n2(vt(i2, "height"));
      },
      [n2]
    ),
    true,
    M("skipAnimationFrameInResizeObserver")
  ), s2 = M("context");
  return e2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(o2, { ref: r2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(e2, { ...Z(e2, s2) }) }) : null;
}), dr = /* @__PURE__ */ React.memo(function() {
  const e2 = M("FooterComponent"), n2 = gt("footerHeight"), o2 = M("HeaderFooterTag"), r2 = Ht(
    React.useMemo(
      () => (i2) => {
        n2(vt(i2, "height"));
      },
      [n2]
    ),
    true,
    M("skipAnimationFrameInResizeObserver")
  ), s2 = M("context");
  return e2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(o2, { ref: r2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(e2, { ...Z(e2, s2) }) }) : null;
});
function Je({ useEmitter: t2, useEmitterValue: e2, usePublisher: n2 }) {
  return React.memo(function({ children: s2, style: i2, context: l2, ...c2 }) {
    const a2 = n2("scrollContainerState"), m2 = e2("ScrollerComponent"), x2 = n2("smoothScrollTargetReached"), h2 = e2("scrollerRef"), I = e2("horizontalDirection") || false, { scrollByCallback: C, scrollerRef: v2, scrollToCallback: g2 } = to(
      a2,
      x2,
      m2,
      h2,
      void 0,
      I
    );
    return t2("scrollTo", g2), t2("scrollBy", C), /* @__PURE__ */ jsxRuntimeExports.jsx(
      m2,
      {
        "data-testid": "virtuoso-scroller",
        "data-virtuoso-scroller": true,
        ref: v2,
        style: { ...I ? cr : lr, ...i2 },
        tabIndex: 0,
        ...c2,
        ...Z(m2, l2),
        children: s2
      }
    );
  });
}
function Qe({ useEmitter: t2, useEmitterValue: e2, usePublisher: n2 }) {
  return React.memo(function({ children: s2, style: i2, context: l2, ...c2 }) {
    const a2 = n2("windowScrollContainerState"), m2 = e2("ScrollerComponent"), x2 = n2("smoothScrollTargetReached"), h2 = e2("totalListHeight"), I = e2("deviation"), C = e2("customScrollParent"), v2 = React.useRef(null), g2 = e2("scrollerRef"), { scrollByCallback: p2, scrollerRef: u2, scrollToCallback: T } = to(
      a2,
      x2,
      m2,
      g2,
      C
    );
    return Qn(() => {
      var b2;
      return u2.current = C || ((b2 = v2.current) == null ? void 0 : b2.ownerDocument.defaultView), () => {
        u2.current = null;
      };
    }, [u2, C]), t2("windowScrollTo", T), t2("scrollBy", p2), /* @__PURE__ */ jsxRuntimeExports.jsx(
      m2,
      {
        ref: v2,
        "data-virtuoso-scroller": true,
        style: { position: "relative", ...i2, ...h2 !== 0 ? { height: h2 + I } : {} },
        ...c2,
        ...Z(m2, l2),
        children: s2
      }
    );
  });
}
const fr = ({ children: t2 }) => {
  const e2 = React.useContext(be), n2 = gt("viewportHeight"), o2 = gt("fixedItemHeight"), r2 = M("alignToBottom"), s2 = M("horizontalDirection"), i2 = React.useMemo(
    () => ne(n2, (c2) => vt(c2, s2 ? "width" : "height")),
    [n2, s2]
  ), l2 = Ht(i2, true, M("skipAnimationFrameInResizeObserver"));
  return React.useEffect(() => {
    e2 && (n2(e2.viewportHeight), o2(e2.itemHeight));
  }, [e2, n2, o2]), /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-viewport-type": "element", ref: l2, style: Zt(r2), children: t2 });
}, mr = ({ children: t2 }) => {
  const e2 = React.useContext(be), n2 = gt("windowViewportRect"), o2 = gt("fixedItemHeight"), r2 = M("customScrollParent"), s2 = Ne(
    n2,
    r2,
    M("skipAnimationFrameInResizeObserver")
  ), i2 = M("alignToBottom");
  return React.useEffect(() => {
    e2 && (o2(e2.itemHeight), n2({ offsetTop: 0, visibleHeight: e2.viewportHeight, visibleWidth: 100 }));
  }, [e2, n2, o2]), /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-viewport-type": "window", ref: s2, style: Zt(i2), children: t2 });
}, pr = ({ children: t2 }) => {
  const e2 = M("TopItemListComponent") || "div", n2 = M("headerHeight"), o2 = { ...ur, marginTop: "".concat(n2, "px") }, r2 = M("context");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(e2, { style: o2, ...Z(e2, r2), children: t2 });
}, hr = /* @__PURE__ */ React.memo(function(e2) {
  const n2 = M("useWindowScroll"), o2 = M("topItemsIndexes").length > 0, r2 = M("customScrollParent"), s2 = M("context");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(r2 || n2 ? Ir : gr, { ...e2, context: s2, children: [
    o2 && /* @__PURE__ */ jsxRuntimeExports.jsx(pr, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Cn, { showTopList: true }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(r2 || n2 ? mr : fr, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ar, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Cn, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(dr, {})
    ] })
  ] });
}), {
  Component: oo,
  useEmitter: tn,
  useEmitterValue: M,
  usePublisher: gt
} = /* @__PURE__ */ Ye(
  or,
  {
    required: {},
    optional: {
      restoreStateFrom: "restoreStateFrom",
      context: "context",
      followOutput: "followOutput",
      scrollIntoViewOnChange: "scrollIntoViewOnChange",
      itemContent: "itemContent",
      groupContent: "groupContent",
      overscan: "overscan",
      increaseViewportBy: "increaseViewportBy",
      totalCount: "totalCount",
      groupCounts: "groupCounts",
      topItemCount: "topItemCount",
      firstItemIndex: "firstItemIndex",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      components: "components",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      computeItemKey: "computeItemKey",
      defaultItemHeight: "defaultItemHeight",
      fixedItemHeight: "fixedItemHeight",
      itemSize: "itemSize",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "HeaderFooterTag",
      data: "data",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      alignToBottom: "alignToBottom",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel",
      horizontalDirection: "horizontalDirection",
      skipAnimationFrameInResizeObserver: "skipAnimationFrameInResizeObserver"
    },
    methods: {
      scrollToIndex: "scrollToIndex",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      autoscrollToBottom: "autoscrollToBottom",
      getState: "getState"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      totalListHeightChanged: "totalListHeightChanged",
      itemsRendered: "itemsRendered",
      groupIndices: "groupIndices"
    }
  },
  hr
), gr = /* @__PURE__ */ Je({ useEmitter: tn, useEmitterValue: M, usePublisher: gt }), Ir = /* @__PURE__ */ Qe({ useEmitter: tn, useEmitterValue: M, usePublisher: gt }), qr = oo, Sr = /* @__PURE__ */ U$1(() => {
  const t2 = w$1((a2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
    "Item $",
    a2
  ] })), e2 = w$1(null), n2 = w$1((a2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { colSpan: 1e3, children: [
    "Group ",
    a2
  ] })), o2 = w$1(null), r2 = w$1(null), s2 = w$1({}), i2 = w$1(Xe), l2 = w$1(Yt), c2 = (a2, m2 = null) => ct(
    S(
      s2,
      E$1((x2) => x2[a2]),
      Y()
    ),
    m2
  );
  return {
    components: s2,
    computeItemKey: i2,
    context: e2,
    EmptyPlaceholder: c2("EmptyPlaceholder"),
    FillerRow: c2("FillerRow"),
    fixedFooterContent: r2,
    fixedHeaderContent: o2,
    itemContent: t2,
    groupContent: n2,
    ScrollerComponent: c2("Scroller", "div"),
    scrollerRef: l2,
    ScrollSeekPlaceholder: c2("ScrollSeekPlaceholder"),
    TableBodyComponent: c2("TableBody", "tbody"),
    TableComponent: c2("Table", "table"),
    TableFooterComponent: c2("TableFoot", "tfoot"),
    TableHeadComponent: c2("TableHead", "thead"),
    TableRowComponent: c2("TableRow", "tr"),
    GroupComponent: c2("Group", "tr")
  };
});
/* @__PURE__ */ U$1(
  ([t2, e2]) => ({ ...t2, ...e2 }),
  X(Xn, Sr)
);
({ position: Ze() });
const yn = {
  bottom: 0,
  itemHeight: 0,
  items: [],
  itemWidth: 0,
  offsetBottom: 0,
  offsetTop: 0,
  top: 0
}, Br = {
  bottom: 0,
  itemHeight: 0,
  items: [{ index: 0 }],
  itemWidth: 0,
  offsetBottom: 0,
  offsetTop: 0,
  top: 0
}, { ceil: Rn, floor: Ce, max: ee, min: Oe, round: bn } = Math;
function Hn(t2, e2, n2) {
  return Array.from({ length: e2 - t2 + 1 }).map((o2, r2) => ({ data: n2 === null ? null : n2[r2 + t2], index: r2 + t2 }));
}
function kr(t2) {
  return {
    ...Br,
    items: t2
  };
}
function he(t2, e2) {
  return t2 && t2.width === e2.width && t2.height === e2.height;
}
function Fr(t2, e2) {
  return t2 && t2.column === e2.column && t2.row === e2.row;
}
const Or = /* @__PURE__ */ U$1(
  ([
    { increaseViewportBy: t2, listBoundary: e2, overscan: n2, visibleRange: o2 },
    { footerHeight: r2, headerHeight: s2, scrollBy: i2, scrollContainerState: l2, scrollTo: c2, scrollTop: a2, smoothScrollTargetReached: m2, viewportHeight: x2 },
    h2,
    I,
    { didMount: C, propsReady: v2 },
    { customScrollParent: g2, useWindowScroll: p2, windowScrollContainerState: u2, windowScrollTo: T, windowViewportRect: b2 },
    f2
  ]) => {
    const d2 = w$1(0), y2 = w$1(0), B = w$1(yn), k2 = w$1({ height: 0, width: 0 }), L = w$1({ height: 0, width: 0 }), z2 = $(), _23 = $(), J2 = w$1(0), nt = w$1(null), F = w$1({ column: 0, row: 0 }), q2 = $(), it = $(), dt = w$1(false), St = w$1(0), ft = w$1(true), ut = w$1(false), At = w$1(false);
    K$1(
      S(
        C,
        N$1(St),
        A$1(([R, D2]) => !!D2)
      ),
      () => {
        G$1(ft, false);
      }
    ), K$1(
      S(
        rt(C, ft, L, k2, St, ut),
        A$1(([R, D2, Q, lt, , tt]) => R && !D2 && Q.height !== 0 && lt.height !== 0 && !tt)
      ),
      ([, , , , R]) => {
        G$1(ut, true), Ue(1, () => {
          G$1(z2, R);
        }), Tt(S(a2), () => {
          G$1(e2, [0, 0]), G$1(ft, true);
        });
      }
    ), O$1(
      S(
        it,
        A$1((R) => R != null && R.scrollTop > 0),
        Rt(0)
      ),
      y2
    ), K$1(
      S(
        C,
        N$1(it),
        A$1(([, R]) => R != null)
      ),
      ([, R]) => {
        R && (G$1(k2, R.viewport), G$1(L, R.item), G$1(F, R.gap), R.scrollTop > 0 && (G$1(dt, true), Tt(S(a2, Dt(1)), (D2) => {
          G$1(dt, false);
        }), G$1(c2, { top: R.scrollTop })));
      }
    ), O$1(
      S(
        k2,
        E$1(({ height: R }) => R)
      ),
      x2
    ), O$1(
      S(
        rt(
          V$1(k2, he),
          V$1(L, he),
          V$1(F, (R, D2) => R && R.column === D2.column && R.row === D2.row),
          V$1(a2)
        ),
        E$1(([R, D2, Q, lt]) => ({
          gap: Q,
          item: D2,
          scrollTop: lt,
          viewport: R
        }))
      ),
      q2
    ), O$1(
      S(
        rt(
          V$1(d2),
          o2,
          V$1(F, Fr),
          V$1(L, he),
          V$1(k2, he),
          V$1(nt),
          V$1(y2),
          V$1(dt),
          V$1(ft),
          V$1(St)
        ),
        A$1(([, , , , , , , R]) => !R),
        E$1(
          ([
            R,
            [D2, Q],
            lt,
            tt,
            Ft,
            Jt,
            Ut,
            ,
            de,
            Ot
          ]) => {
            const { column: Lt, row: Qt } = lt, { height: fe, width: He } = tt, { width: nn } = Ft;
            if (Ut === 0 && (R === 0 || nn === 0))
              return yn;
            if (He === 0) {
              const cn = Ke(Ot, R), co = cn + Math.max(Ut - 1, 0);
              return kr(Hn(cn, co, Jt));
            }
            const me = so(nn, He, Lt);
            let Kt, Wt;
            de ? D2 === 0 && Q === 0 && Ut > 0 ? (Kt = 0, Wt = Ut - 1) : (Kt = me * Ce((D2 + Qt) / (fe + Qt)), Wt = me * Rn((Q + Qt) / (fe + Qt)) - 1, Wt = Oe(R - 1, ee(Wt, me - 1)), Kt = Oe(Wt, ee(0, Kt))) : (Kt = 0, Wt = -1);
            const on = Hn(Kt, Wt, Jt), { bottom: rn, top: sn } = En(Ft, lt, tt, on), ln = Rn(R / me), lo = ln * fe + (ln - 1) * Qt - rn;
            return { bottom: rn, itemHeight: fe, items: on, itemWidth: He, offsetBottom: lo, offsetTop: sn, top: sn };
          }
        )
      ),
      B
    ), O$1(
      S(
        nt,
        A$1((R) => R !== null),
        E$1((R) => R.length)
      ),
      d2
    ), O$1(
      S(
        rt(k2, L, B, F),
        A$1(([R, D2, { items: Q }]) => Q.length > 0 && D2.height !== 0 && R.height !== 0),
        E$1(([R, D2, { items: Q }, lt]) => {
          const { bottom: tt, top: Ft } = En(R, lt, D2, Q);
          return [Ft, tt];
        }),
        Y(se)
      ),
      e2
    );
    const xt = w$1(false);
    O$1(
      S(
        a2,
        N$1(xt),
        E$1(([R, D2]) => D2 || R !== 0)
      ),
      xt
    );
    const Xt = ht(
      S(
        rt(B, d2),
        A$1(([{ items: R }]) => R.length > 0),
        N$1(xt),
        A$1(([[R, D2], Q]) => {
          const tt = R.items[R.items.length - 1].index === D2 - 1;
          return (Q || R.bottom > 0 && R.itemHeight > 0 && R.offsetBottom === 0 && R.items.length === D2) && tt;
        }),
        E$1(([[, R]]) => R - 1),
        Y()
      )
    ), Mt = ht(
      S(
        V$1(B),
        A$1(({ items: R }) => R.length > 0 && R[0].index === 0),
        Rt(0),
        Y()
      )
    ), yt = ht(
      S(
        V$1(B),
        N$1(dt),
        A$1(([{ items: R }, D2]) => R.length > 0 && !D2),
        E$1(([{ items: R }]) => ({
          endIndex: R[R.length - 1].index,
          startIndex: R[0].index
        })),
        Y(Mn),
        kt(0)
      )
    );
    O$1(yt, I.scrollSeekRangeChanged), O$1(
      S(
        z2,
        N$1(k2, L, d2, F),
        E$1(([R, D2, Q, lt, tt]) => {
          const Ft = Dn(R), { align: Jt, behavior: Ut, offset: de } = Ft;
          let Ot = Ft.index;
          Ot === "LAST" && (Ot = lt - 1), Ot = ee(0, Ot, Oe(lt - 1, Ot));
          let Lt = Me(D2, tt, Q, Ot);
          return Jt === "end" ? Lt = bn(Lt - D2.height + Q.height) : Jt === "center" && (Lt = bn(Lt - D2.height / 2 + Q.height / 2)), de && (Lt += de), { behavior: Ut, top: Lt };
        })
      ),
      c2
    );
    const Bt = ct(
      S(
        B,
        E$1((R) => R.offsetBottom + R.bottom)
      ),
      0
    );
    return O$1(
      S(
        b2,
        E$1((R) => ({ height: R.visibleHeight, width: R.visibleWidth }))
      ),
      k2
    ), {
      customScrollParent: g2,
      // input
      data: nt,
      deviation: J2,
      footerHeight: r2,
      gap: F,
      headerHeight: s2,
      increaseViewportBy: t2,
      initialItemCount: y2,
      itemDimensions: L,
      overscan: n2,
      restoreStateFrom: it,
      scrollBy: i2,
      scrollContainerState: l2,
      scrollHeight: _23,
      scrollTo: c2,
      scrollToIndex: z2,
      scrollTop: a2,
      smoothScrollTargetReached: m2,
      totalCount: d2,
      useWindowScroll: p2,
      viewportDimensions: k2,
      windowScrollContainerState: u2,
      windowScrollTo: T,
      windowViewportRect: b2,
      ...I,
      // output
      gridState: B,
      horizontalDirection: At,
      initialTopMostItemIndex: St,
      totalListHeight: Bt,
      ...h2,
      endReached: Xt,
      propsReady: v2,
      rangeChanged: yt,
      startReached: Mt,
      stateChanged: q2,
      stateRestoreInProgress: dt,
      ...f2
    };
  },
  X(je, at, ae, Yn, Pt, qe, Vt)
);
function so(t2, e2, n2) {
  return ee(1, Ce((t2 + n2) / (Ce(e2) + n2)));
}
function En(t2, e2, n2, o2) {
  const { height: r2 } = n2;
  if (r2 === void 0 || o2.length === 0)
    return { bottom: 0, top: 0 };
  const s2 = Me(t2, e2, n2, o2[0].index);
  return { bottom: Me(t2, e2, n2, o2[o2.length - 1].index) + r2, top: s2 };
}
function Me(t2, e2, n2, o2) {
  const r2 = so(t2.width, n2.width, e2.column), s2 = Ce(o2 / r2), i2 = s2 * n2.height + ee(0, s2 - 1) * e2.row;
  return i2 > 0 ? i2 + e2.row : i2;
}
const Lr = /* @__PURE__ */ U$1(() => {
  const t2 = w$1((x2) => "Item ".concat(x2)), e2 = w$1({}), n2 = w$1(null), o2 = w$1("virtuoso-grid-item"), r2 = w$1("virtuoso-grid-list"), s2 = w$1(Xe), i2 = w$1("div"), l2 = w$1(Yt), c2 = (x2, h2 = null) => ct(
    S(
      e2,
      E$1((I) => I[x2]),
      Y()
    ),
    h2
  ), a2 = w$1(false), m2 = w$1(false);
  return O$1(V$1(m2), a2), {
    components: e2,
    computeItemKey: s2,
    context: n2,
    FooterComponent: c2("Footer"),
    HeaderComponent: c2("Header"),
    headerFooterTag: i2,
    itemClassName: o2,
    ItemComponent: c2("Item", "div"),
    itemContent: t2,
    listClassName: r2,
    ListComponent: c2("List", "div"),
    readyStateChanged: a2,
    reportReadyState: m2,
    ScrollerComponent: c2("Scroller", "div"),
    scrollerRef: l2,
    ScrollSeekPlaceholder: c2("ScrollSeekPlaceholder", "div")
  };
}), zr = /* @__PURE__ */ U$1(
  ([t2, e2]) => ({ ...t2, ...e2 }),
  X(Or, Lr)
), Vr = /* @__PURE__ */ React.memo(function() {
  const e2 = et("gridState"), n2 = et("listClassName"), o2 = et("itemClassName"), r2 = et("itemContent"), s2 = et("computeItemKey"), i2 = et("isSeeking"), l2 = It("scrollHeight"), c2 = et("ItemComponent"), a2 = et("ListComponent"), m2 = et("ScrollSeekPlaceholder"), x2 = et("context"), h2 = It("itemDimensions"), I = It("gap"), C = et("log"), v2 = et("stateRestoreInProgress"), g2 = It("reportReadyState"), p2 = Ht(
    React.useMemo(
      () => (u2) => {
        const T = u2.parentElement.parentElement.scrollHeight;
        l2(T);
        const b2 = u2.firstChild;
        if (b2) {
          const { height: f2, width: d2 } = b2.getBoundingClientRect();
          h2({ height: f2, width: d2 });
        }
        I({
          column: Bn("column-gap", getComputedStyle(u2).columnGap, C),
          row: Bn("row-gap", getComputedStyle(u2).rowGap, C)
        });
      },
      [l2, h2, I, C]
    ),
    true,
    false
  );
  return Qn(() => {
    e2.itemHeight > 0 && e2.itemWidth > 0 && g2(true);
  }, [e2]), v2 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
    a2,
    {
      className: n2,
      ref: p2,
      ...Z(a2, x2),
      "data-testid": "virtuoso-item-list",
      style: { paddingBottom: e2.offsetBottom, paddingTop: e2.offsetTop },
      children: e2.items.map((u2) => {
        const T = s2(u2.index, u2.data, x2);
        return i2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          m2,
          {
            ...Z(m2, x2),
            height: e2.itemHeight,
            index: u2.index,
            width: e2.itemWidth
          },
          T
        ) : /* @__PURE__ */ reactExports.createElement(
          c2,
          {
            ...Z(c2, x2),
            className: o2,
            "data-index": u2.index,
            key: T
          },
          r2(u2.index, u2.data, x2)
        );
      })
    }
  );
}), Pr = React.memo(function() {
  const e2 = et("HeaderComponent"), n2 = It("headerHeight"), o2 = et("headerFooterTag"), r2 = Ht(
    React.useMemo(
      () => (i2) => {
        n2(vt(i2, "height"));
      },
      [n2]
    ),
    true,
    false
  ), s2 = et("context");
  return e2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(o2, { ref: r2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(e2, { ...Z(e2, s2) }) }) : null;
}), Ar = React.memo(function() {
  const e2 = et("FooterComponent"), n2 = It("footerHeight"), o2 = et("headerFooterTag"), r2 = Ht(
    React.useMemo(
      () => (i2) => {
        n2(vt(i2, "height"));
      },
      [n2]
    ),
    true,
    false
  ), s2 = et("context");
  return e2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(o2, { ref: r2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(e2, { ...Z(e2, s2) }) }) : null;
}), Mr = ({ children: t2 }) => {
  const e2 = React.useContext(Jn), n2 = It("itemDimensions"), o2 = It("viewportDimensions"), r2 = Ht(
    React.useMemo(
      () => (s2) => {
        o2(s2.getBoundingClientRect());
      },
      [o2]
    ),
    true,
    false
  );
  return React.useEffect(() => {
    e2 && (o2({ height: e2.viewportHeight, width: e2.viewportWidth }), n2({ height: e2.itemHeight, width: e2.itemWidth }));
  }, [e2, o2, n2]), /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: r2, style: Zt(false), children: t2 });
}, Wr = ({ children: t2 }) => {
  const e2 = React.useContext(Jn), n2 = It("windowViewportRect"), o2 = It("itemDimensions"), r2 = et("customScrollParent"), s2 = Ne(n2, r2, false);
  return React.useEffect(() => {
    e2 && (o2({ height: e2.itemHeight, width: e2.itemWidth }), n2({ offsetTop: 0, visibleHeight: e2.viewportHeight, visibleWidth: e2.viewportWidth }));
  }, [e2, n2, o2]), /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: s2, style: Zt(false), children: t2 });
}, Gr = /* @__PURE__ */ React.memo(function({ ...e2 }) {
  const n2 = et("useWindowScroll"), o2 = et("customScrollParent"), r2 = o2 || n2 ? Dr : Nr, s2 = o2 || n2 ? Wr : Mr, i2 = et("context");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(r2, { ...e2, ...Z(r2, i2), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(s2, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Pr, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Vr, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Ar, {})
  ] }) });
}), {
  useEmitter: io,
  useEmitterValue: et,
  usePublisher: It
} = /* @__PURE__ */ Ye(
  zr,
  {
    optional: {
      context: "context",
      totalCount: "totalCount",
      overscan: "overscan",
      itemContent: "itemContent",
      components: "components",
      computeItemKey: "computeItemKey",
      data: "data",
      initialItemCount: "initialItemCount",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "headerFooterTag",
      listClassName: "listClassName",
      itemClassName: "itemClassName",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel",
      restoreStateFrom: "restoreStateFrom",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      increaseViewportBy: "increaseViewportBy"
    },
    methods: {
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      scrollToIndex: "scrollToIndex"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      stateChanged: "stateChanged",
      readyStateChanged: "readyStateChanged"
    }
  },
  Gr
), Nr = /* @__PURE__ */ Je({ useEmitter: io, useEmitterValue: et, usePublisher: It }), Dr = /* @__PURE__ */ Qe({ useEmitter: io, useEmitterValue: et, usePublisher: It });
function Bn(t2, e2, n2) {
  return e2 !== "normal" && !(e2 != null && e2.endsWith("px")) && n2("".concat(t2, " was not resolved to pixel value correctly"), e2, mt.WARN), e2 === "normal" ? 0 : parseInt(e2 != null ? e2 : "0", 10);
}
function isObject$3(obj) {
  return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend$2(target = {}, src = {}) {
  const noExtend = ["__proto__", "constructor", "prototype"];
  Object.keys(src).filter((key) => noExtend.indexOf(key) < 0).forEach((key) => {
    if (typeof target[key] === "undefined") target[key] = src[key];
    else if (isObject$3(src[key]) && isObject$3(target[key]) && Object.keys(src[key]).length > 0) {
      extend$2(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      }
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  const doc = typeof document !== "undefined" ? document : {};
  extend$2(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    }
  },
  CustomEvent: function CustomEvent2() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === "undefined") {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id) {
    if (typeof setTimeout === "undefined") {
      return;
    }
    clearTimeout(id);
  }
};
function getWindow$1() {
  const win2 = typeof window !== "undefined" ? window : {};
  extend$2(win2, ssrWindow);
  return win2;
}
function classesToTokens(classes2 = "") {
  return classes2.trim().split(" ").filter((c2) => !!c2.trim());
}
function deleteProps(obj) {
  const object2 = obj;
  Object.keys(object2).forEach((key) => {
    try {
      object2[key] = null;
    } catch (e2) {
    }
    try {
      delete object2[key];
    } catch (e2) {
    }
  });
}
function nextTick(callback, delay = 0) {
  return setTimeout(callback, delay);
}
function now() {
  return Date.now();
}
function getComputedStyle$1(el) {
  const window2 = getWindow$1();
  let style;
  if (window2.getComputedStyle) {
    style = window2.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate(el, axis = "x") {
  const window2 = getWindow$1();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle$1(el);
  if (window2.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(",").length > 6) {
      curTransform = curTransform.split(", ").map((a2) => a2.replace(",", ".")).join(", ");
    }
    transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
    matrix = transformMatrix.toString().split(",");
  }
  if (axis === "x") {
    if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m41;
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
    else curTransform = parseFloat(matrix[4]);
  }
  if (axis === "y") {
    if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m42;
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
    else curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject$2(o2) {
  return typeof o2 === "object" && o2 !== null && o2.constructor && Object.prototype.toString.call(o2).slice(8, -1) === "Object";
}
function isNode$1(node) {
  if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend$1(...args) {
  const to2 = Object(args[0]);
  const noExtend = ["__proto__", "constructor", "prototype"];
  for (let i2 = 1; i2 < args.length; i2 += 1) {
    const nextSource = args[i2];
    if (nextSource !== void 0 && nextSource !== null && !isNode$1(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (isObject$2(to2[nextKey]) && isObject$2(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to2[nextKey] = nextSource[nextKey];
            } else {
              extend$1(to2[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject$2(to2[nextKey]) && isObject$2(nextSource[nextKey])) {
            to2[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to2[nextKey] = nextSource[nextKey];
            } else {
              extend$1(to2[nextKey], nextSource[nextKey]);
            }
          } else {
            to2[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to2;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll({
  swiper,
  targetPosition,
  side
}) {
  const window2 = getWindow$1();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = "none";
  window2.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? "next" : "prev";
  const isOutOfBound = (current2, target) => {
    return dir === "next" && current2 >= target || dir === "prev" && current2 <= target;
  };
  const animate = () => {
    time = (/* @__PURE__ */ new Date()).getTime();
    if (startTime === null) {
      startTime = time;
    }
    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = "hidden";
      swiper.wrapperEl.style.scrollSnapType = "";
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = "";
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window2.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
  };
  animate();
}
function getSlideTransformEl(slideEl) {
  return slideEl.querySelector(".swiper-slide-transform") || slideEl.shadowRoot && slideEl.shadowRoot.querySelector(".swiper-slide-transform") || slideEl;
}
function elementChildren(element, selector = "") {
  const window2 = getWindow$1();
  const children = [...element.children];
  if (window2.HTMLSlotElement && element instanceof HTMLSlotElement) {
    children.push(...element.assignedElements());
  }
  if (!selector) {
    return children;
  }
  return children.filter((el) => el.matches(selector));
}
function elementIsChildOfSlot(el, slot) {
  const elementsQueue = [slot];
  while (elementsQueue.length > 0) {
    const elementToCheck = elementsQueue.shift();
    if (el === elementToCheck) {
      return true;
    }
    elementsQueue.push(...elementToCheck.children, ...elementToCheck.shadowRoot ? elementToCheck.shadowRoot.children : [], ...elementToCheck.assignedElements ? elementToCheck.assignedElements() : []);
  }
}
function elementIsChildOf(el, parent) {
  const window2 = getWindow$1();
  let isChild = parent.contains(el);
  if (!isChild && window2.HTMLSlotElement && parent instanceof HTMLSlotElement) {
    const children = [...parent.assignedElements()];
    isChild = children.includes(el);
    if (!isChild) {
      isChild = elementIsChildOfSlot(el, parent);
    }
  }
  return isChild;
}
function showWarning(text) {
  try {
    console.warn(text);
    return;
  } catch (err2) {
  }
}
function createElement(tag, classes2 = []) {
  const el = document.createElement(tag);
  el.classList.add(...Array.isArray(classes2) ? classes2 : classesToTokens(classes2));
  return el;
}
function elementOffset(el) {
  const window2 = getWindow$1();
  const document2 = getDocument();
  const box = el.getBoundingClientRect();
  const body = document2.body;
  const clientTop = el.clientTop || body.clientTop || 0;
  const clientLeft = el.clientLeft || body.clientLeft || 0;
  const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
  const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
  return {
    top: box.top + scrollTop - clientTop,
    left: box.left + scrollLeft - clientLeft
  };
}
function elementPrevAll(el, selector) {
  const prevEls = [];
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling;
    if (selector) {
      if (prev.matches(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return prevEls;
}
function elementNextAll(el, selector) {
  const nextEls = [];
  while (el.nextElementSibling) {
    const next = el.nextElementSibling;
    if (selector) {
      if (next.matches(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return nextEls;
}
function elementStyle(el, prop) {
  const window2 = getWindow$1();
  return window2.getComputedStyle(el, null).getPropertyValue(prop);
}
function elementIndex(el) {
  let child = el;
  let i2;
  if (child) {
    i2 = 0;
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i2 += 1;
    }
    return i2;
  }
  return void 0;
}
function elementParents(el, selector) {
  const parents = [];
  let parent = el.parentElement;
  while (parent) {
    if (selector) {
      if (parent.matches(selector)) parents.push(parent);
    } else {
      parents.push(parent);
    }
    parent = parent.parentElement;
  }
  return parents;
}
function elementTransitionEnd(el, callback) {
  function fireCallBack(e2) {
    if (e2.target !== el) return;
    callback.call(el, e2);
    el.removeEventListener("transitionend", fireCallBack);
  }
  if (callback) {
    el.addEventListener("transitionend", fireCallBack);
  }
}
function elementOuterSize(el, size, includeMargins) {
  const window2 = getWindow$1();
  {
    return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
  }
}
function makeElementsArray(el) {
  return (Array.isArray(el) ? el : [el]).filter((e2) => !!e2);
}
function getRotateFix(swiper) {
  return (v2) => {
    if (Math.abs(v2) > 0 && swiper.browser && swiper.browser.need3dFix && Math.abs(v2) % 90 === 0) {
      return v2 + 1e-3;
    }
    return v2;
  };
}
function setInnerHTML(el, html = "") {
  if (typeof trustedTypes !== "undefined") {
    el.innerHTML = trustedTypes.createPolicy("html", {
      createHTML: (s2) => s2
    }).createHTML(html);
  } else {
    el.innerHTML = html;
  }
}
let support;
function calcSupport() {
  const window2 = getWindow$1();
  const document2 = getDocument();
  return {
    smoothScroll: document2.documentElement && document2.documentElement.style && "scrollBehavior" in document2.documentElement.style,
    touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}
let deviceCached;
function calcDevice({
  userAgent
} = {}) {
  const support2 = getSupport();
  const window2 = getWindow$1();
  const platform = window2.navigator.platform;
  const ua = userAgent || window2.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window2.screen.width;
  const screenHeight = window2.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  let ipad = ua.match(/(iPad)(?!\1).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === "Win32";
  let macos = platform === "MacIntel";
  const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  if (!ipad && macos && support2.touch && iPadScreens.indexOf("".concat(screenWidth, "x").concat(screenHeight)) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, "13_0_0"];
    macos = false;
  }
  if (android && !windows) {
    device.os = "android";
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = "ios";
    device.ios = true;
  }
  return device;
}
function getDevice(overrides = {}) {
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}
let browser;
function calcBrowser() {
  const window2 = getWindow$1();
  const device = getDevice();
  let needPerspectiveFix = false;
  function isSafari() {
    const ua = window2.navigator.userAgent.toLowerCase();
    return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
  }
  if (isSafari()) {
    const ua = String(window2.navigator.userAgent);
    if (ua.includes("Version/")) {
      const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num) => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent);
  const isSafariBrowser = isSafari();
  const need3dFix = isSafariBrowser || isWebView && device.ios;
  return {
    isSafari: needPerspectiveFix || isSafariBrowser,
    needPerspectiveFix,
    need3dFix,
    isWebView
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}
function Resize({
  swiper,
  on,
  emit
}) {
  const window2 = getWindow$1();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit("beforeResize");
    emit("resize");
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    observer = new ResizeObserver((entries3) => {
      animationFrame = window2.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries3.forEach(({
          contentBoxSize,
          contentRect,
          target
        }) => {
          if (target && target !== swiper.el) return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window2.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit("orientationchange");
  };
  on("init", () => {
    if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
      createObserver();
      return;
    }
    window2.addEventListener("resize", resizeHandler);
    window2.addEventListener("orientationchange", orientationChangeHandler);
  });
  on("destroy", () => {
    removeObserver();
    window2.removeEventListener("resize", resizeHandler);
    window2.removeEventListener("orientationchange", orientationChangeHandler);
  });
}
function Observer({
  swiper,
  extendParams,
  on,
  emit
}) {
  const observers = [];
  const window2 = getWindow$1();
  const attach = (target, options = {}) => {
    const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
    const observer = new ObserverFunc((mutations) => {
      if (swiper.__preventObserver__) return;
      if (mutations.length === 1) {
        emit("observerUpdate", mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate2() {
        emit("observerUpdate", mutations[0]);
      };
      if (window2.requestAnimationFrame) {
        window2.requestAnimationFrame(observerUpdate);
      } else {
        window2.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === "undefined" ? true : options.attributes,
      childList: swiper.isElement || (typeof options.childList === "undefined" ? true : options).childList,
      characterData: typeof options.characterData === "undefined" ? true : options.characterData
    });
    observers.push(observer);
  };
  const init2 = () => {
    if (!swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = elementParents(swiper.hostEl);
      for (let i2 = 0; i2 < containerParents.length; i2 += 1) {
        attach(containerParents[i2]);
      }
    }
    attach(swiper.hostEl, {
      childList: swiper.params.observeSlideChildren
    });
    attach(swiper.wrapperEl, {
      attributes: false
    });
  };
  const destroy2 = () => {
    observers.forEach((observer) => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on("init", init2);
  on("destroy", destroy2);
}
var eventsEmitter = {
  on(events2, handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed) return self2;
    if (typeof handler !== "function") return self2;
    const method = priority ? "unshift" : "push";
    events2.split(" ").forEach((event2) => {
      if (!self2.eventsListeners[event2]) self2.eventsListeners[event2] = [];
      self2.eventsListeners[event2][method](handler);
    });
    return self2;
  },
  once(events2, handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed) return self2;
    if (typeof handler !== "function") return self2;
    function onceHandler(...args) {
      self2.off(events2, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      handler.apply(self2, args);
    }
    onceHandler.__emitterProxy = handler;
    return self2.on(events2, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed) return self2;
    if (typeof handler !== "function") return self2;
    const method = priority ? "unshift" : "push";
    if (self2.eventsAnyListeners.indexOf(handler) < 0) {
      self2.eventsAnyListeners[method](handler);
    }
    return self2;
  },
  offAny(handler) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed) return self2;
    if (!self2.eventsAnyListeners) return self2;
    const index = self2.eventsAnyListeners.indexOf(handler);
    if (index >= 0) {
      self2.eventsAnyListeners.splice(index, 1);
    }
    return self2;
  },
  off(events2, handler) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed) return self2;
    if (!self2.eventsListeners) return self2;
    events2.split(" ").forEach((event2) => {
      if (typeof handler === "undefined") {
        self2.eventsListeners[event2] = [];
      } else if (self2.eventsListeners[event2]) {
        self2.eventsListeners[event2].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self2.eventsListeners[event2].splice(index, 1);
          }
        });
      }
    });
    return self2;
  },
  emit(...args) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed) return self2;
    if (!self2.eventsListeners) return self2;
    let events2;
    let data;
    let context2;
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      events2 = args[0];
      data = args.slice(1, args.length);
      context2 = self2;
    } else {
      events2 = args[0].events;
      data = args[0].data;
      context2 = args[0].context || self2;
    }
    data.unshift(context2);
    const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
    eventsArray.forEach((event2) => {
      if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
        self2.eventsAnyListeners.forEach((eventHandler) => {
          eventHandler.apply(context2, [event2, ...data]);
        });
      }
      if (self2.eventsListeners && self2.eventsListeners[event2]) {
        self2.eventsListeners[event2].forEach((eventHandler) => {
          eventHandler.apply(context2, data);
        });
      }
    });
    return self2;
  }
};
function updateSize() {
  const swiper = this;
  let width;
  let height;
  const el = swiper.el;
  if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = el.clientWidth;
  }
  if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = el.clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }
  width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
  height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}
function updateSlides() {
  const swiper = this;
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    wrapperEl,
    slidesEl,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = elementChildren(slidesEl, ".".concat(swiper.params.slideClass, ", swiper-slide"));
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === "function") {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === "function") {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  const swiperSize = swiper.size - offsetBefore - offsetAfter;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === "undefined") {
    return;
  }
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
  } else if (typeof spaceBetween === "string") {
    spaceBetween = parseFloat(spaceBetween);
  }
  swiper.virtualSize = -spaceBetween - offsetBefore - offsetAfter;
  slides.forEach((slideEl) => {
    if (rtl) {
      slideEl.style.marginLeft = "";
    } else {
      slideEl.style.marginRight = "";
    }
    slideEl.style.marginBottom = "";
    slideEl.style.marginTop = "";
  });
  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
    setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slides);
  } else if (swiper.grid) {
    swiper.grid.unsetSlides();
  }
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
    return typeof params.breakpoints[key].slidesPerView !== "undefined";
  }).length > 0;
  for (let i2 = 0; i2 < slidesLength; i2 += 1) {
    slideSize = 0;
    const slide2 = slides[i2];
    if (slide2) {
      if (gridEnabled) {
        swiper.grid.updateSlide(i2, slide2, slides);
      }
      if (elementStyle(slide2, "display") === "none") continue;
    }
    if (isVirtual && params.slidesPerView === "auto") {
      if (params.virtual.slidesPerViewAutoSlideSize) {
        slideSize = params.virtual.slidesPerViewAutoSlideSize;
      }
      if (slideSize && slide2) {
        if (params.roundLengths) slideSize = Math.floor(slideSize);
        slide2.style[swiper.getDirectionLabel("width")] = "".concat(slideSize, "px");
      }
    } else if (params.slidesPerView === "auto") {
      if (shouldResetSlideSize) {
        slide2.style[swiper.getDirectionLabel("width")] = "";
      }
      const slideStyles = getComputedStyle(slide2);
      const currentTransform = slide2.style.transform;
      const currentWebKitTransform = slide2.style.webkitTransform;
      if (currentTransform) {
        slide2.style.transform = "none";
      }
      if (currentWebKitTransform) {
        slide2.style.webkitTransform = "none";
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, "width") : elementOuterSize(slide2, "height");
      } else {
        const width = getDirectionPropertyValue(slideStyles, "width");
        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
        const boxSizing = slideStyles.getPropertyValue("box-sizing");
        if (boxSizing && boxSizing === "border-box") {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide2;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide2.style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide2.style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);
      if (slide2) {
        slide2.style[swiper.getDirectionLabel("width")] = "".concat(slideSize, "px");
      }
    }
    if (slide2) {
      slide2.swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i2 !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i2 === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
    wrapperEl.style.width = "".concat(swiper.virtualSize + spaceBetween, "px");
  }
  if (params.setWrapperSize) {
    wrapperEl.style[swiper.getDirectionLabel("width")] = "".concat(swiper.virtualSize + spaceBetween, "px");
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid);
  }
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i2 = 0; i2 < snapGrid.length; i2 += 1) {
      let slidesGridItem = snapGrid[i2];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i2] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (isVirtual && params.loop) {
    const size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
      const groupSize = size * params.slidesPerGroup;
      for (let i2 = 0; i2 < groups; i2 += 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
      }
    }
    for (let i2 = 0; i2 < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i2 += 1) {
      if (params.slidesPerGroup === 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
      }
      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
      swiper.virtualSize += size;
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];
  if (spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
    slides.filter((_23, slideIndex) => {
      if (!params.cssMode || params.loop) return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).forEach((slideEl) => {
      slideEl.style[key] = "".concat(spaceBetween, "px");
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
    snapGrid = snapGrid.map((snap) => {
      if (snap <= 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const offsetSize = (offsetBefore || 0) + (offsetAfter || 0);
    if (allSlidesSize + offsetSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "".concat(-snapGrid[0], "px"));
    setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "".concat(swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2, "px"));
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map((v2) => v2 + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map((v2) => v2 + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit("slidesLengthChange");
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit("snapGridLengthChange");
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit("slidesGridLengthChange");
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  swiper.emit("slidesUpdated");
  if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
    const backFaceHiddenClass = "".concat(params.containerModifierClass, "backface-hidden");
    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.el.classList.remove(backFaceHiddenClass);
    }
  }
}
function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i2;
  if (typeof speed === "number") {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = (index) => {
    if (isVirtual) {
      return swiper.slides[swiper.getSlideIndexByData(index)];
    }
    return swiper.slides[index];
  };
  if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      (swiper.visibleSlides || []).forEach((slide2) => {
        activeSlides.push(slide2);
      });
    } else {
      for (i2 = 0; i2 < Math.ceil(swiper.params.slidesPerView); i2 += 1) {
        const index = swiper.activeIndex + i2;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }
  for (i2 = 0; i2 < activeSlides.length; i2 += 1) {
    if (typeof activeSlides[i2] !== "undefined") {
      const height = activeSlides[i2].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }
  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = "".concat(newHeight, "px");
}
function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
  for (let i2 = 0; i2 < slides.length; i2 += 1) {
    slides[i2].swiperSlideOffset = (swiper.isHorizontal() ? slides[i2].offsetLeft : slides[i2].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
  }
}
const toggleSlideClasses$1 = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesProgress(translate2 = this && this.translate || 0) {
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
  let offsetCenter = -translate2;
  if (rtl) offsetCenter = translate2;
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  let spaceBetween = params.spaceBetween;
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size;
  } else if (typeof spaceBetween === "string") {
    spaceBetween = parseFloat(spaceBetween);
  }
  for (let i2 = 0; i2 < slides.length; i2 += 1) {
    const slide2 = slides[i2];
    let slideOffset = slide2.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i2];
    const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i2];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide2);
      swiper.visibleSlidesIndexes.push(i2);
    }
    toggleSlideClasses$1(slide2, isVisible, params.slideVisibleClass);
    toggleSlideClasses$1(slide2, isFullyVisible, params.slideFullyVisibleClass);
    slide2.progress = rtl ? -slideProgress : slideProgress;
    slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}
function updateProgress(translate2) {
  const swiper = this;
  if (typeof translate2 === "undefined") {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd,
    progressLoop
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate2 - swiper.minTranslate()) / translatesDiff;
    const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;
    const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress <= 0;
    isEnd = isEndRounded || progress >= 1;
    if (isBeginningRounded) progress = 0;
    if (isEndRounded) progress = 1;
  }
  if (params.loop) {
    const firstSlideIndex = swiper.getSlideIndexByData(0);
    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
    const translateAbs = Math.abs(translate2);
    if (translateAbs >= firstSlideTranslate) {
      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
    } else {
      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
    }
    if (progressLoop > 1) progressLoop -= 1;
  }
  Object.assign(swiper, {
    progress,
    progressLoop,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate2);
  if (isBeginning && !wasBeginning) {
    swiper.emit("reachBeginning toEdge");
  }
  if (isEnd && !wasEnd) {
    swiper.emit("reachEnd toEdge");
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit("fromEdge");
  }
  swiper.emit("progress", progress);
}
const toggleSlideClasses = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    slidesEl,
    activeIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const getFilteredSlide = (selector) => {
    return elementChildren(slidesEl, ".".concat(params.slideClass).concat(selector, ", swiper-slide").concat(selector))[0];
  };
  let activeSlide;
  let prevSlide;
  let nextSlide;
  if (isVirtual) {
    if (params.loop) {
      let slideIndex = activeIndex - swiper.virtual.slidesBefore;
      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
      activeSlide = getFilteredSlide('[data-swiper-slide-index="'.concat(slideIndex, '"]'));
    } else {
      activeSlide = getFilteredSlide('[data-swiper-slide-index="'.concat(activeIndex, '"]'));
    }
  } else {
    if (gridEnabled) {
      activeSlide = slides.find((slideEl) => slideEl.column === activeIndex);
      nextSlide = slides.find((slideEl) => slideEl.column === activeIndex + 1);
      prevSlide = slides.find((slideEl) => slideEl.column === activeIndex - 1);
    } else {
      activeSlide = slides[activeIndex];
    }
  }
  if (activeSlide) {
    if (!gridEnabled) {
      nextSlide = elementNextAll(activeSlide, ".".concat(params.slideClass, ", swiper-slide"))[0];
      if (params.loop && !nextSlide) {
        nextSlide = slides[0];
      }
      prevSlide = elementPrevAll(activeSlide, ".".concat(params.slideClass, ", swiper-slide"))[0];
      if (params.loop && !prevSlide === 0) {
        prevSlide = slides[slides.length - 1];
      }
    }
  }
  slides.forEach((slideEl) => {
    toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
    toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
    toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
  });
  swiper.emitSlidesClasses();
}
const processLazyPreloader = (swiper, imageEl) => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  const slideSelector = () => swiper.isElement ? "swiper-slide" : ".".concat(swiper.params.slideClass);
  const slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    let lazyEl = slideEl.querySelector(".".concat(swiper.params.lazyPreloaderClass));
    if (!lazyEl && swiper.isElement) {
      if (slideEl.shadowRoot) {
        lazyEl = slideEl.shadowRoot.querySelector(".".concat(swiper.params.lazyPreloaderClass));
      } else {
        requestAnimationFrame(() => {
          if (slideEl.shadowRoot) {
            lazyEl = slideEl.shadowRoot.querySelector(".".concat(swiper.params.lazyPreloaderClass));
            if (lazyEl) lazyEl.remove();
          }
        });
      }
    }
    if (lazyEl) lazyEl.remove();
  }
};
const unlazy = (swiper, index) => {
  if (!swiper.slides[index]) return;
  const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
  if (imageEl) imageEl.removeAttribute("loading");
};
const preload = (swiper) => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  let amount = swiper.params.lazyPreloadPrevNext;
  const len = swiper.slides.length;
  if (!len || !amount || amount < 0) return;
  amount = Math.min(amount, len);
  const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
  const activeIndex = swiper.activeIndex;
  if (swiper.params.grid && swiper.params.grid.rows > 1) {
    const activeColumn = activeIndex;
    const preloadColumns = [activeColumn - amount];
    preloadColumns.push(...Array.from({
      length: amount
    }).map((_23, i2) => {
      return activeColumn + slidesPerView + i2;
    }));
    swiper.slides.forEach((slideEl, i2) => {
      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i2);
    });
    return;
  }
  const slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper.params.rewind || swiper.params.loop) {
    for (let i2 = activeIndex - amount; i2 <= slideIndexLastInView + amount; i2 += 1) {
      const realIndex = (i2 % len + len) % len;
      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
    }
  } else {
    for (let i2 = Math.max(activeIndex - amount, 0); i2 <= Math.min(slideIndexLastInView + amount, len - 1); i2 += 1) {
      if (i2 !== activeIndex && (i2 > slideIndexLastInView || i2 < activeIndex)) {
        unlazy(swiper, i2);
      }
    }
  }
};
function getActiveIndexByTranslate(swiper) {
  const {
    slidesGrid,
    params
  } = swiper;
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  let activeIndex;
  for (let i2 = 0; i2 < slidesGrid.length; i2 += 1) {
    if (typeof slidesGrid[i2 + 1] !== "undefined") {
      if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1] - (slidesGrid[i2 + 1] - slidesGrid[i2]) / 2) {
        activeIndex = i2;
      } else if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1]) {
        activeIndex = i2 + 1;
      }
    } else if (translate2 >= slidesGrid[i2]) {
      activeIndex = i2;
    }
  }
  if (params.normalizeSlideIndex) {
    if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
  }
  return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  const getVirtualRealIndex = (aIndex) => {
    let realIndex2 = aIndex - swiper.virtual.slidesBefore;
    if (realIndex2 < 0) {
      realIndex2 = swiper.virtual.slides.length + realIndex2;
    }
    if (realIndex2 >= swiper.virtual.slides.length) {
      realIndex2 -= swiper.virtual.slides.length;
    }
    return realIndex2;
  };
  if (typeof activeIndex === "undefined") {
    activeIndex = getActiveIndexByTranslate(swiper);
  }
  if (snapGrid.indexOf(translate2) >= 0) {
    snapIndex = snapGrid.indexOf(translate2);
  } else {
    const skip2 = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip2 + Math.floor((activeIndex - skip2) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex && !swiper.params.loop) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit("snapIndexChange");
    }
    return;
  }
  if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
    swiper.realIndex = getVirtualRealIndex(activeIndex);
    return;
  }
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  let realIndex;
  if (swiper.virtual && params.virtual.enabled && params.loop) {
    realIndex = getVirtualRealIndex(activeIndex);
  } else if (gridEnabled) {
    const firstSlideInColumn = swiper.slides.find((slideEl) => slideEl.column === activeIndex);
    let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
    if (Number.isNaN(activeSlideIndex)) {
      activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
    }
    realIndex = Math.floor(activeSlideIndex / params.grid.rows);
  } else if (swiper.slides[activeIndex]) {
    const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
    if (slideIndex) {
      realIndex = parseInt(slideIndex, 10);
    } else {
      realIndex = activeIndex;
    }
  } else {
    realIndex = activeIndex;
  }
  Object.assign(swiper, {
    previousSnapIndex,
    snapIndex,
    previousRealIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  if (swiper.initialized) {
    preload(swiper);
  }
  swiper.emit("activeIndexChange");
  swiper.emit("snapIndexChange");
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    if (previousRealIndex !== realIndex) {
      swiper.emit("realIndexChange");
    }
    swiper.emit("slideChange");
  }
}
function updateClickedSlide(el, path2) {
  const swiper = this;
  const params = swiper.params;
  let slide2 = el.closest(".".concat(params.slideClass, ", swiper-slide"));
  if (!slide2 && swiper.isElement && path2 && path2.length > 1 && path2.includes(el)) {
    [...path2.slice(path2.indexOf(el) + 1, path2.length)].forEach((pathEl) => {
      if (!slide2 && pathEl.matches && pathEl.matches(".".concat(params.slideClass, ", swiper-slide"))) {
        slide2 = pathEl;
      }
    });
  }
  let slideFound = false;
  let slideIndex;
  if (slide2) {
    for (let i2 = 0; i2 < swiper.slides.length; i2 += 1) {
      if (swiper.slides[i2] === slide2) {
        slideFound = true;
        slideIndex = i2;
        break;
      }
    }
  }
  if (slide2 && slideFound) {
    swiper.clickedSlide = slide2;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(slide2.getAttribute("data-swiper-slide-index"), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = void 0;
    swiper.clickedIndex = void 0;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}
var update7 = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};
function getSwiperTranslate(axis = this.isHorizontal() ? "x" : "y") {
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate: translate2,
    wrapperEl
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate2 : translate2;
  }
  if (params.cssMode) {
    return translate2;
  }
  let currentTranslate = getTranslate(wrapperEl, axis);
  currentTranslate += swiper.cssOverflowAdjustment();
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}
function setTranslate(translate2, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress
  } = swiper;
  let x2 = 0;
  let y2 = 0;
  const z2 = 0;
  if (swiper.isHorizontal()) {
    x2 = rtl ? -translate2 : translate2;
  } else {
    y2 = translate2;
  }
  if (params.roundLengths) {
    x2 = Math.floor(x2);
    y2 = Math.floor(y2);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x2 : y2;
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x2 : -y2;
  } else if (!params.virtualTranslate) {
    if (swiper.isHorizontal()) {
      x2 -= swiper.cssOverflowAdjustment();
    } else {
      y2 -= swiper.cssOverflowAdjustment();
    }
    wrapperEl.style.transform = "translate3d(".concat(x2, "px, ").concat(y2, "px, ").concat(z2, "px)");
  }
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate2);
  }
  swiper.emit("setTranslate", swiper.translate, byController);
}
function minTranslate() {
  return -this.snapGrid[0];
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(translate2 = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate2 = swiper.minTranslate();
  const maxTranslate2 = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate2 > minTranslate2) newTranslate = minTranslate2;
  else if (translateBounds && translate2 < maxTranslate2) newTranslate = maxTranslate2;
  else newTranslate = translate2;
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: -newTranslate,
        behavior: "smooth"
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionEnd");
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionStart");
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e2) {
          if (!swiper || swiper.destroyed) return;
          if (e2.target !== this) return;
          swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          swiper.animating = false;
          if (runCallbacks) {
            swiper.emit("transitionEnd");
          }
        };
      }
      swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}
var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};
function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.wrapperEl.style.transitionDuration = "".concat(duration, "ms");
    swiper.wrapperEl.style.transitionDelay = duration === 0 ? "0ms" : "";
  }
  swiper.emit("setTransition", duration, byController);
}
function transitionEmit({
  swiper,
  runCallbacks,
  direction,
  step
}) {
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = "next";
    else if (activeIndex < previousIndex) dir = "prev";
    else dir = "reset";
  }
  swiper.emit("transition".concat(step));
  if (runCallbacks && dir === "reset") {
    swiper.emit("slideResetTransition".concat(step));
  } else if (runCallbacks && activeIndex !== previousIndex) {
    swiper.emit("slideChangeTransition".concat(step));
    if (dir === "next") {
      swiper.emit("slideNextTransition".concat(step));
    } else {
      swiper.emit("slidePrevTransition".concat(step));
    }
  }
}
function transitionStart(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode) return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "Start"
  });
}
function transitionEnd(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "End"
  });
}
var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};
function slideTo(index = 0, speed, runCallbacks = true, internal, initial) {
  if (typeof index === "string") {
    index = parseInt(index, 10);
  }
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  if (typeof speed === "undefined") {
    speed = swiper.params.speed;
  }
  const skip2 = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip2 + Math.floor((slideIndex - skip2) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  const translate2 = -snapGrid[snapIndex];
  if (params.normalizeSlideIndex) {
    for (let i2 = 0; i2 < slidesGrid.length; i2 += 1) {
      const normalizedTranslate = -Math.floor(translate2 * 100);
      const normalizedGrid = Math.floor(slidesGrid[i2] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i2 + 1] * 100);
      if (typeof slidesGrid[i2 + 1] !== "undefined") {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i2;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i2 + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i2;
      }
    }
  }
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && (rtl ? translate2 > swiper.translate && translate2 > swiper.minTranslate() : translate2 < swiper.translate && translate2 < swiper.minTranslate())) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) {
        return false;
      }
    }
  }
  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper.emit("beforeSlideChangeStart");
  }
  swiper.updateProgress(translate2);
  let direction;
  if (slideIndex > activeIndex) direction = "next";
  else if (slideIndex < activeIndex) direction = "prev";
  else direction = "reset";
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  const isInitialVirtual = isVirtual && initial;
  if (!isInitialVirtual && (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate)) {
    swiper.updateActiveIndex(slideIndex);
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== "slide") {
      swiper.setTranslate(translate2);
    }
    if (direction !== "reset") {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t2 = rtl ? translate2 : -translate2;
    if (speed === 0) {
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = "none";
        swiper._immediateVirtual = true;
      }
      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
        swiper._cssModeVirtualInitialSet = true;
        requestAnimationFrame(() => {
          wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t2;
        });
      } else {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t2;
      }
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = "";
          swiper._immediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: t2,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: t2,
        behavior: "smooth"
      });
    }
    return true;
  }
  const browser2 = getBrowser();
  const isSafari = browser2.isSafari;
  if (isVirtual && !initial && isSafari && swiper.isElement) {
    swiper.virtual.update(false, false, slideIndex);
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate2);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit("beforeTransitionStart", speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e2) {
        if (!swiper || swiper.destroyed) return;
        if (e2.target !== this) return;
        swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}
function slideToLoop(index = 0, speed, runCallbacks = true, internal) {
  if (typeof index === "string") {
    const indexAsNumber = parseInt(index, 10);
    index = indexAsNumber;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === "undefined") {
    speed = swiper.params.speed;
  }
  const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
  let newIndex = index;
  if (swiper.params.loop) {
    if (swiper.virtual && swiper.params.virtual.enabled) {
      newIndex = newIndex + swiper.virtual.slidesBefore;
    } else {
      let targetSlideIndex;
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        targetSlideIndex = swiper.slides.find((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex).column;
      } else {
        targetSlideIndex = swiper.getSlideIndexByData(newIndex);
      }
      const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
      const {
        centeredSlides,
        slidesOffsetBefore,
        slidesOffsetAfter
      } = swiper.params;
      const bothDirections = centeredSlides || !!slidesOffsetBefore || !!slidesOffsetAfter;
      let slidesPerView = swiper.params.slidesPerView;
      if (slidesPerView === "auto") {
        slidesPerView = swiper.slidesPerViewDynamic();
      } else {
        slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
        if (bothDirections && slidesPerView % 2 === 0) {
          slidesPerView = slidesPerView + 1;
        }
      }
      let needLoopFix = cols - targetSlideIndex < slidesPerView;
      if (bothDirections) {
        needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
      }
      if (internal && bothDirections && swiper.params.slidesPerView !== "auto" && !gridEnabled) {
        needLoopFix = false;
      }
      if (needLoopFix) {
        const direction = bothDirections ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
        swiper.loopFix({
          direction,
          slideTo: true,
          activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
          slideRealIndex: direction === "next" ? swiper.realIndex : void 0
        });
      }
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        newIndex = swiper.slides.find((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex).column;
      } else {
        newIndex = swiper.getSlideIndexByData(newIndex);
      }
    }
  }
  requestAnimationFrame(() => {
    swiper.slideTo(newIndex, speed, runCallbacks, internal);
  });
  return swiper;
}
function slideNext(speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    enabled,
    params,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === "undefined") {
    speed = swiper.params.speed;
  }
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: "next"
    });
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
    if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
      });
      return true;
    }
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
function slidePrev(speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === "undefined") {
    speed = swiper.params.speed;
  }
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: "prev"
    });
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate2);
  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
  const isFreeMode = params.freeMode && params.freeMode.enabled;
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === "undefined" && (params.cssMode || isFreeMode)) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== "undefined") {
      prevSnap = isFreeMode ? snapGrid[prevSnapIndex] : snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== "undefined") {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
    requestAnimationFrame(() => {
      swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    });
    return true;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
function slideReset(speed, runCallbacks = true, internal) {
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === "undefined") {
    speed = swiper.params.speed;
  }
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
function slideToClosest(speed, runCallbacks = true, internal, threshold = 0.5) {
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === "undefined") {
    speed = swiper.params.speed;
  }
  let index = swiper.activeIndex;
  const skip2 = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip2 + Math.floor((index - skip2) / swiper.params.slidesPerGroup);
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate2 >= swiper.snapGrid[snapIndex]) {
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}
function slideToClickedSlide() {
  const swiper = this;
  if (swiper.destroyed) return;
  const {
    params,
    slidesEl
  } = swiper;
  const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.getSlideIndexWhenGrid(swiper.clickedIndex);
  let realIndex;
  const slideSelector = swiper.isElement ? "swiper-slide" : ".".concat(params.slideClass);
  const isGrid = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
    if (params.centeredSlides) {
      swiper.slideToLoop(realIndex);
    } else if (slideToIndex > (isGrid ? (swiper.slides.length - slidesPerView) / 2 - (swiper.params.grid.rows - 1) : swiper.slides.length - slidesPerView)) {
      swiper.loopFix();
      slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, "".concat(slideSelector, '[data-swiper-slide-index="').concat(realIndex, '"]'))[0]);
      nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}
var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};
function loopCreate(slideRealIndex, initial) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  const initSlides = () => {
    const slides = elementChildren(slidesEl, ".".concat(params.slideClass, ", swiper-slide"));
    slides.forEach((el, index) => {
      el.setAttribute("data-swiper-slide-index", index);
    });
  };
  const clearBlankSlides = () => {
    const slides = elementChildren(slidesEl, ".".concat(params.slideBlankClass));
    slides.forEach((el) => {
      el.remove();
    });
    if (slides.length > 0) {
      swiper.recalcSlides();
      swiper.updateSlides();
    }
  };
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  if (params.loopAddBlankSlides && (params.slidesPerGroup > 1 || gridEnabled)) {
    clearBlankSlides();
  }
  const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
  const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
  const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
  const addBlankSlides = (amountOfSlides) => {
    for (let i2 = 0; i2 < amountOfSlides; i2 += 1) {
      const slideEl = swiper.isElement ? createElement("swiper-slide", [params.slideBlankClass]) : createElement("div", [params.slideClass, params.slideBlankClass]);
      swiper.slidesEl.append(slideEl);
    }
  };
  if (shouldFillGroup) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
    }
    initSlides();
  } else if (shouldFillGrid) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
    }
    initSlides();
  } else {
    initSlides();
  }
  const bothDirections = params.centeredSlides || !!params.slidesOffsetBefore || !!params.slidesOffsetAfter;
  swiper.loopFix({
    slideRealIndex,
    direction: bothDirections ? void 0 : "next",
    initial
  });
}
function loopFix({
  slideRealIndex,
  slideTo: slideTo2 = true,
  direction,
  setTranslate: setTranslate2,
  activeSlideIndex,
  initial,
  byController,
  byMousewheel
} = {}) {
  const swiper = this;
  if (!swiper.params.loop) return;
  swiper.emit("beforeLoopFix");
  const {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params
  } = swiper;
  const {
    centeredSlides,
    slidesOffsetBefore,
    slidesOffsetAfter,
    initialSlide
  } = params;
  const bothDirections = centeredSlides || !!slidesOffsetBefore || !!slidesOffsetAfter;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  if (swiper.virtual && params.virtual.enabled) {
    if (slideTo2) {
      if (!bothDirections && swiper.snapIndex === 0) {
        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
      } else if (bothDirections && swiper.snapIndex < params.slidesPerView) {
        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit("loopFix");
    return;
  }
  let slidesPerView = params.slidesPerView;
  if (slidesPerView === "auto") {
    slidesPerView = swiper.slidesPerViewDynamic();
  } else {
    slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
    if (bothDirections && slidesPerView % 2 === 0) {
      slidesPerView = slidesPerView + 1;
    }
  }
  const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
  let loopedSlides = bothDirections ? Math.max(slidesPerGroup, Math.ceil(slidesPerView / 2)) : slidesPerGroup;
  if (loopedSlides % slidesPerGroup !== 0) {
    loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
  }
  loopedSlides += params.loopAdditionalSlides;
  swiper.loopedSlides = loopedSlides;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  if (slides.length < slidesPerView + loopedSlides || swiper.params.effect === "cards" && slides.length < slidesPerView + loopedSlides * 2) {
    showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters");
  } else if (gridEnabled && params.grid.fill === "row") {
    showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
  }
  const prependSlidesIndexes = [];
  const appendSlidesIndexes = [];
  const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
  const isInitialOverflow = initial && cols - initialSlide < slidesPerView && !bothDirections;
  let activeIndex = isInitialOverflow ? initialSlide : swiper.activeIndex;
  if (typeof activeSlideIndex === "undefined") {
    activeSlideIndex = swiper.getSlideIndex(slides.find((el) => el.classList.contains(params.slideActiveClass)));
  } else {
    activeIndex = activeSlideIndex;
  }
  const isNext = direction === "next" || !direction;
  const isPrev = direction === "prev" || !direction;
  let slidesPrepended = 0;
  let slidesAppended = 0;
  const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
  const activeColIndexWithShift = activeColIndex + (bothDirections && typeof setTranslate2 === "undefined" ? -slidesPerView / 2 + 0.5 : 0);
  if (activeColIndexWithShift < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
    for (let i2 = 0; i2 < loopedSlides - activeColIndexWithShift; i2 += 1) {
      const index = i2 - Math.floor(i2 / cols) * cols;
      if (gridEnabled) {
        const colIndexToPrepend = cols - index - 1;
        for (let i3 = slides.length - 1; i3 >= 0; i3 -= 1) {
          if (slides[i3].column === colIndexToPrepend) prependSlidesIndexes.push(i3);
        }
      } else {
        prependSlidesIndexes.push(cols - index - 1);
      }
    }
  } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
    slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
    if (isInitialOverflow) {
      slidesAppended = Math.max(slidesAppended, slidesPerView - cols + initialSlide + 1);
    }
    for (let i2 = 0; i2 < slidesAppended; i2 += 1) {
      const index = i2 - Math.floor(i2 / cols) * cols;
      if (gridEnabled) {
        slides.forEach((slide2, slideIndex) => {
          if (slide2.column === index) appendSlidesIndexes.push(slideIndex);
        });
      } else {
        appendSlidesIndexes.push(index);
      }
    }
  }
  swiper.__preventObserver__ = true;
  requestAnimationFrame(() => {
    swiper.__preventObserver__ = false;
  });
  if (swiper.params.effect === "cards" && slides.length < slidesPerView + loopedSlides * 2) {
    if (appendSlidesIndexes.includes(activeSlideIndex)) {
      appendSlidesIndexes.splice(appendSlidesIndexes.indexOf(activeSlideIndex), 1);
    }
    if (prependSlidesIndexes.includes(activeSlideIndex)) {
      prependSlidesIndexes.splice(prependSlidesIndexes.indexOf(activeSlideIndex), 1);
    }
  }
  if (isPrev) {
    prependSlidesIndexes.forEach((index) => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.prepend(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  if (isNext) {
    appendSlidesIndexes.forEach((index) => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.append(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  swiper.recalcSlides();
  if (params.slidesPerView === "auto") {
    swiper.updateSlides();
  } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
    swiper.slides.forEach((slide2, slideIndex) => {
      swiper.grid.updateSlide(slideIndex, slide2, swiper.slides);
    });
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (slideTo2) {
    if (prependSlidesIndexes.length > 0 && isPrev) {
      if (typeof slideRealIndex === "undefined") {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
          if (setTranslate2) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        if (setTranslate2) {
          const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
          swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
          swiper.touchEventsData.currentTranslate = swiper.translate;
        }
      }
    } else if (appendSlidesIndexes.length > 0 && isNext) {
      if (typeof slideRealIndex === "undefined") {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
          if (setTranslate2) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
        swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
      }
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.controller && swiper.controller.control && !byController) {
    const loopParams = {
      slideRealIndex,
      direction,
      setTranslate: setTranslate2,
      activeSlideIndex,
      byController: true
    };
    if (Array.isArray(swiper.controller.control)) {
      swiper.controller.control.forEach((c2) => {
        if (!c2.destroyed && c2.params.loop) c2.loopFix({
          ...loopParams,
          slideTo: c2.params.slidesPerView === params.slidesPerView ? slideTo2 : false
        });
      });
    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
      swiper.controller.control.loopFix({
        ...loopParams,
        slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false
      });
    }
  }
  swiper.emit("loopFix");
}
function loopDestroy() {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || !slidesEl || swiper.virtual && swiper.params.virtual.enabled) return;
  swiper.recalcSlides();
  const newSlidesOrder = [];
  swiper.slides.forEach((slideEl) => {
    const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index] = slideEl;
  });
  swiper.slides.forEach((slideEl) => {
    slideEl.removeAttribute("data-swiper-slide-index");
  });
  newSlidesOrder.forEach((slideEl) => {
    slidesEl.append(slideEl);
  });
  swiper.recalcSlides();
  swiper.slideTo(swiper.realIndex, 0);
}
var loop = {
  loopCreate,
  loopFix,
  loopDestroy
};
function setGrabCursor(moving) {
  const swiper = this;
  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  el.style.cursor = "move";
  el.style.cursor = moving ? "grabbing" : "grab";
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}
function unsetGrabCursor() {
  const swiper = this;
  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}
var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};
function closestElement(selector, base = this) {
  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow$1()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    const found = el.closest(selector);
    if (!found && !el.getRootNode) {
      return null;
    }
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function preventEdgeSwipe(swiper, event2, startX) {
  const window2 = getWindow$1();
  const {
    params
  } = swiper;
  const edgeSwipeDetection = params.edgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === "prevent") {
      event2.preventDefault();
      return true;
    }
    return false;
  }
  return true;
}
function onTouchStart(event2) {
  const swiper = this;
  const document2 = getDocument();
  let e2 = event2;
  if (e2.originalEvent) e2 = e2.originalEvent;
  const data = swiper.touchEventsData;
  if (e2.type === "pointerdown") {
    if (data.pointerId !== null && data.pointerId !== e2.pointerId) {
      return;
    }
    data.pointerId = e2.pointerId;
  } else if (e2.type === "touchstart" && e2.targetTouches.length === 1) {
    data.touchId = e2.targetTouches[0].identifier;
  }
  if (e2.type === "touchstart") {
    preventEdgeSwipe(swiper, e2, e2.targetTouches[0].pageX);
    return;
  }
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e2.pointerType === "mouse") return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let targetEl = e2.target;
  if (params.touchEventsTarget === "wrapper") {
    if (!elementIsChildOf(targetEl, swiper.wrapperEl)) return;
  }
  if ("which" in e2 && e2.which === 3) return;
  if ("button" in e2 && e2.button > 0) return;
  if (data.isTouched && data.isMoved) return;
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
  const eventPath = e2.composedPath ? e2.composedPath() : e2.path;
  if (swipingClassHasValue && e2.target && e2.target.shadowRoot && eventPath) {
    targetEl = eventPath[0];
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : ".".concat(params.noSwipingClass);
  const isTargetShadow = !!(e2.target && e2.target.shadowRoot);
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!targetEl.closest(params.swipeHandler)) return;
  }
  touches.currentX = e2.pageX;
  touches.currentY = e2.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;
  if (!preventEdgeSwipe(swiper, e2, startX)) {
    return;
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: void 0,
    startMoving: void 0
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = void 0;
  if (params.threshold > 0) data.allowThresholdMove = false;
  let preventDefault2 = true;
  if (targetEl.matches(data.focusableElements)) {
    preventDefault2 = false;
    if (targetEl.nodeName === "SELECT") {
      data.isTouched = false;
    }
  }
  if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl && (e2.pointerType === "mouse" || e2.pointerType !== "mouse" && !targetEl.matches(data.focusableElements))) {
    document2.activeElement.blur();
  }
  const shouldPreventDefault = preventDefault2 && swiper.allowTouchMove && params.touchStartPreventDefault;
  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
    e2.preventDefault();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }
  swiper.emit("touchStart", e2);
}
function onTouchMove(event2) {
  const document2 = getDocument();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && event2.pointerType === "mouse") return;
  let e2 = event2;
  if (e2.originalEvent) e2 = e2.originalEvent;
  if (e2.type === "pointermove") {
    if (data.touchId !== null) return;
    const id = e2.pointerId;
    if (id !== data.pointerId) return;
  }
  let targetTouch;
  if (e2.type === "touchmove") {
    targetTouch = [...e2.changedTouches].find((t2) => t2.identifier === data.touchId);
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  } else {
    targetTouch = e2;
  }
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit("touchMoveOpposite", e2);
    }
    return;
  }
  const pageX = targetTouch.pageX;
  const pageY = targetTouch.pageY;
  if (e2.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    if (!e2.target.matches(data.focusableElements)) {
      swiper.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now();
    }
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (rtl && (pageX > touches.startX && -swiper.translate <= swiper.maxTranslate() || pageX < touches.startX && -swiper.translate >= swiper.minTranslate())) {
      return;
    } else if (!rtl && (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate())) {
      return;
    }
  }
  if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== e2.target && e2.pointerType !== "mouse") {
    document2.activeElement.blur();
  }
  if (document2.activeElement) {
    if (e2.target === document2.activeElement && e2.target.matches(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit("touchMove", e2);
  }
  touches.previousX = touches.currentX;
  touches.previousY = touches.currentY;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
  if (typeof data.isScrolling === "undefined") {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit("touchMoveOpposite", e2);
  }
  if (typeof data.startMoving === "undefined") {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling || e2.type === "touchmove" && data.preventTouchMoveFromPointerMove) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e2.cancelable) {
    e2.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e2.stopPropagation();
  }
  let diff = swiper.isHorizontal() ? diffX : diffY;
  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  if (params.oneWayMovement) {
    diff = Math.abs(diff) * (rtl ? 1 : -1);
    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
  }
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) {
    diff = -diff;
    touchesDiff = -touchesDiff;
  }
  const prevTouchesDirection = swiper.touchesDirection;
  swiper.swipeDirection = diff > 0 ? "prev" : "next";
  swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
  const isLoop = swiper.params.loop && !params.cssMode;
  const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
  if (!data.isMoved) {
    if (isLoop && allowLoopFix) {
      swiper.loopFix({
        direction: swiper.swipeDirection
      });
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      const evt = new window.CustomEvent("transitionend", {
        bubbles: true,
        cancelable: true,
        detail: {
          bySwiperTouchMove: true
        }
      });
      swiper.wrapperEl.dispatchEvent(evt);
    }
    data.allowMomentumBounce = false;
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit("sliderFirstMove", e2);
  }
  (/* @__PURE__ */ new Date()).getTime();
  if (params._loopSwapReset !== false && data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
    Object.assign(touches, {
      startX: pageX,
      startY: pageY,
      currentX: pageX,
      currentY: pageY,
      startTranslate: data.currentTranslate
    });
    data.loopSwapReset = true;
    data.startTranslate = data.currentTranslate;
    return;
  }
  swiper.emit("sliderMove", e2);
  data.isMoved = true;
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0) {
    if (isLoop && allowLoopFix && true && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {
      swiper.loopFix({
        direction: "prev",
        setTranslate: true,
        activeSlideIndex: 0
      });
    }
    if (data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      }
    }
  } else if (diff < 0) {
    if (isLoop && allowLoopFix && true && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {
      swiper.loopFix({
        direction: "next",
        setTranslate: true,
        activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
      });
    }
    if (data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }
    }
  }
  if (disableParentSwiper) {
    e2.preventedByNestedSwiper = true;
  }
  if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode) return;
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  swiper.updateProgress(data.currentTranslate);
  swiper.setTranslate(data.currentTranslate);
}
function onTouchEnd(event2) {
  const swiper = this;
  const data = swiper.touchEventsData;
  let e2 = event2;
  if (e2.originalEvent) e2 = e2.originalEvent;
  let targetTouch;
  const isTouchEvent2 = e2.type === "touchend" || e2.type === "touchcancel";
  if (!isTouchEvent2) {
    if (data.touchId !== null) return;
    if (e2.pointerId !== data.pointerId) return;
    targetTouch = e2;
  } else {
    targetTouch = [...e2.changedTouches].find((t2) => t2.identifier === data.touchId);
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  }
  if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(e2.type)) {
    const proceed = ["pointercancel", "contextmenu"].includes(e2.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
    if (!proceed) {
      return;
    }
  }
  data.pointerId = null;
  data.touchId = null;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e2.pointerType === "mouse") return;
  if (data.allowTouchCallbacks) {
    swiper.emit("touchEnd", e2);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }
  const touchEndTime = now();
  const timeDiff = touchEndTime - data.touchStartTime;
  if (swiper.allowClick) {
    const pathTree = e2.path || e2.composedPath && e2.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e2.target, pathTree);
    swiper.emit("tap click", e2);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit("doubleTap doubleClick", e2);
    }
  }
  data.lastClickTime = now();
  nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }
  const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i2 = 0; i2 < slidesGrid.length; i2 += i2 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment2 = i2 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i2 + increment2] !== "undefined") {
      if (swipeToLast || currentPos >= slidesGrid[i2] && currentPos < slidesGrid[i2 + increment2]) {
        stopIndex = i2;
        groupSize = slidesGrid[i2 + increment2] - slidesGrid[i2];
      }
    } else if (swipeToLast || currentPos >= slidesGrid[i2]) {
      stopIndex = i2;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === "next") {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
      else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === "prev") {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e2.target === swiper.navigation.nextEl || e2.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === "next") {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper.swipeDirection === "prev") {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e2.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}
function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0) return;
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper;
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  const isVirtualLoop = isVirtual && params.loop;
  if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    if (swiper.params.loop && !isVirtual) {
      swiper.slideToLoop(swiper.realIndex, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    clearTimeout(swiper.autoplay.resizeTimeout);
    swiper.autoplay.resizeTimeout = setTimeout(() => {
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.resume();
      }
    }, 500);
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}
function onClick(e2) {
  const swiper = this;
  if (!swiper.enabled) return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e2.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e2.stopPropagation();
      e2.stopImmediatePropagation();
    }
  }
}
function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  if (swiper.translate === 0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit("setTranslate", swiper.translate, false);
}
function onLoad(e2) {
  const swiper = this;
  processLazyPreloader(swiper, e2.target);
  if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) {
    return;
  }
  swiper.update();
}
function onDocumentTouchStart() {
  const swiper = this;
  if (swiper.documentTouchHandlerProceeded) return;
  swiper.documentTouchHandlerProceeded = true;
  if (swiper.params.touchReleaseOnEdges) {
    swiper.el.style.touchAction = "auto";
  }
}
const events$4 = (swiper, method) => {
  const document2 = getDocument();
  const {
    params,
    el,
    wrapperEl,
    device
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
  const swiperMethod = method;
  if (!el || typeof el === "string") return;
  document2[domMethod]("touchstart", swiper.onDocumentTouchStart, {
    passive: false,
    capture
  });
  el[domMethod]("touchstart", swiper.onTouchStart, {
    passive: false
  });
  el[domMethod]("pointerdown", swiper.onTouchStart, {
    passive: false
  });
  document2[domMethod]("touchmove", swiper.onTouchMove, {
    passive: false,
    capture
  });
  document2[domMethod]("pointermove", swiper.onTouchMove, {
    passive: false,
    capture
  });
  document2[domMethod]("touchend", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerup", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointercancel", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("touchcancel", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerout", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerleave", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("contextmenu", swiper.onTouchEnd, {
    passive: true
  });
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]("click", swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]("scroll", swiper.onScroll);
  }
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
  } else {
    swiper[swiperMethod]("observerUpdate", onResize, true);
  }
  el[domMethod]("load", swiper.onLoad, {
    capture: true
  });
};
function attachEvents() {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  swiper.onLoad = onLoad.bind(swiper);
  events$4(swiper, "on");
}
function detachEvents() {
  const swiper = this;
  events$4(swiper, "off");
}
var events$1$1 = {
  attachEvents,
  detachEvents
};
const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    realIndex,
    initialized,
    params,
    el
  } = swiper;
  const breakpoints2 = params.breakpoints;
  if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0) return;
  const document2 = getDocument();
  const breakpointsBase = params.breakpointsBase === "window" || !params.breakpointsBase ? params.breakpointsBase : "container";
  const breakpointContainer = ["window", "container"].includes(params.breakpointsBase) || !params.breakpointsBase ? swiper.el : document2.querySelector(params.breakpointsBase);
  const breakpoint = swiper.getBreakpoint(breakpoints2, breakpointsBase, breakpointContainer);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasGrabCursor = swiper.params.grabCursor;
  const isGrabCursor = breakpointParams.grabCursor;
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    el.classList.remove("".concat(params.containerModifierClass, "grid"), "".concat(params.containerModifierClass, "grid-column"));
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    el.classList.add("".concat(params.containerModifierClass, "grid"));
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
      el.classList.add("".concat(params.containerModifierClass, "grid-column"));
    }
    swiper.emitContainerClasses();
  }
  if (wasGrabCursor && !isGrabCursor) {
    swiper.unsetGrabCursor();
  } else if (!wasGrabCursor && isGrabCursor) {
    swiper.setGrabCursor();
  }
  ["navigation", "pagination", "scrollbar"].forEach((prop) => {
    if (typeof breakpointParams[prop] === "undefined") return;
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper[prop].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  const wasLoop = params.loop;
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  extend$1(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  const hasLoop = swiper.params.loop;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit("_beforeBreakpoint", breakpointParams);
  if (initialized) {
    if (needsReLoop) {
      swiper.loopDestroy();
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (!wasLoop && hasLoop) {
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (wasLoop && !hasLoop) {
      swiper.loopDestroy();
    }
  }
  swiper.emit("breakpoint", breakpointParams);
}
function getBreakpoint(breakpoints2, base = "window", containerEl) {
  if (!breakpoints2 || base === "container" && !containerEl) return void 0;
  let breakpoint = false;
  const window2 = getWindow$1();
  const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints2).map((point) => {
    if (typeof point === "string" && point.indexOf("@") === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a2, b2) => parseInt(a2.value, 10) - parseInt(b2.value, 10));
  for (let i2 = 0; i2 < points.length; i2 += 1) {
    const {
      point,
      value
    } = points[i2];
    if (base === "window") {
      if (window2.matchMedia("(min-width: ".concat(value, "px)")).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || "max";
}
var breakpoints = {
  setBreakpoint,
  getBreakpoint
};
function prepareClasses(entries3, prefix2) {
  const resultClasses = [];
  entries3.forEach((item) => {
    if (typeof item === "object") {
      Object.keys(item).forEach((classNames) => {
        if (item[classNames]) {
          resultClasses.push(prefix2 + classNames);
        }
      });
    } else if (typeof item === "string") {
      resultClasses.push(prefix2 + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    el,
    device
  } = swiper;
  const suffixes = prepareClasses(["initialized", params.direction, {
    "free-mode": swiper.params.freeMode && params.freeMode.enabled
  }, {
    "autoheight": params.autoHeight
  }, {
    "rtl": rtl
  }, {
    "grid": params.grid && params.grid.rows > 1
  }, {
    "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
  }, {
    "android": device.android
  }, {
    "ios": device.ios
  }, {
    "css-mode": params.cssMode
  }, {
    "centered": params.cssMode && params.centeredSlides
  }, {
    "watch-progress": params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  el.classList.add(...classNames);
  swiper.emitContainerClasses();
}
function removeClasses() {
  const swiper = this;
  const {
    el,
    classNames
  } = swiper;
  if (!el || typeof el === "string") return;
  el.classList.remove(...classNames);
  swiper.emitContainerClasses();
}
var classes = {
  addClasses,
  removeClasses
};
function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? "lock" : "unlock");
  }
}
var checkOverflow$1 = {
  checkOverflow
};
var defaults = {
  init: true,
  direction: "horizontal",
  oneWayMovement: false,
  swiperElementNodeName: "SWIPER-CONTAINER",
  touchEventsTarget: "wrapper",
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  eventsPrefix: "swiper",
  enabled: true,
  focusableElements: "input, select, option, textarea, button, video, label",
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: "slide",
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: void 0,
  breakpointsBase: "window",
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 5,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // loop
  loop: false,
  loopAddBlankSlides: true,
  loopAdditionalSlides: 0,
  loopPreventsSliding: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: "swiper-",
  // NEW
  slideClass: "swiper-slide",
  slideBlankClass: "swiper-slide-blank",
  slideActiveClass: "swiper-slide-active",
  slideVisibleClass: "swiper-slide-visible",
  slideFullyVisibleClass: "swiper-slide-fully-visible",
  slideNextClass: "swiper-slide-next",
  slidePrevClass: "swiper-slide-prev",
  wrapperClass: "swiper-wrapper",
  lazyPreloaderClass: "swiper-lazy-preloader",
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};
function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj = {}) {
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== "object" || moduleParams === null) {
      extend$1(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
      params[moduleParamName].auto = true;
    }
    if (["pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
      params[moduleParamName].auto = true;
    }
    if (!(moduleParamName in params && "enabled" in moduleParams)) {
      extend$1(allModulesParams, obj);
      return;
    }
    if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName]) params[moduleParamName] = {
      enabled: false
    };
    extend$1(allModulesParams, obj);
  };
}
const prototypes = {
  eventsEmitter,
  update: update7,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes
};
const extendedDefaults = {};
let Swiper$1 = class Swiper {
  constructor(...args) {
    let el;
    let params;
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};
    params = extend$1({}, params);
    if (el && !params.el) params.el = el;
    const document2 = getDocument();
    if (params.el && typeof params.el === "string" && document2.querySelectorAll(params.el).length > 1) {
      const swipers = [];
      document2.querySelectorAll(params.el).forEach((containerEl) => {
        const newParams = extend$1({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach((mod) => {
      mod({
        params,
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });
    const swiperParams = extend$1({}, defaults, allModulesParams);
    swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend$1({}, swiper.params);
    swiper.passedParams = extend$1({}, params);
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach((eventName) => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return swiper.params.direction === "horizontal";
      },
      isVertical() {
        return swiper.params.direction === "vertical";
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      cssOverflowAdjustment() {
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: void 0,
        // Velocities
        velocities: [],
        allowMomentumBounce: void 0,
        startMoving: void 0,
        pointerId: null,
        touchId: null
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit("_swiper");
    if (swiper.params.init) {
      swiper.init();
    }
    return swiper;
  }
  getDirectionLabel(property) {
    if (this.isHorizontal()) {
      return property;
    }
    return {
      "width": "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      "marginRight": "marginBottom"
    }[property];
  }
  getSlideIndex(slideEl) {
    const {
      slidesEl,
      params
    } = this;
    const slides = elementChildren(slidesEl, ".".concat(params.slideClass, ", swiper-slide"));
    const firstSlideIndex = elementIndex(slides[0]);
    return elementIndex(slideEl) - firstSlideIndex;
  }
  getSlideIndexByData(index) {
    return this.getSlideIndex(this.slides.find((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === index));
  }
  getSlideIndexWhenGrid(index) {
    if (this.grid && this.params.grid && this.params.grid.rows > 1) {
      if (this.params.grid.fill === "column") {
        index = Math.floor(index / this.params.grid.rows);
      } else if (this.params.grid.fill === "row") {
        index = index % Math.ceil(this.slides.length / this.params.grid.rows);
      }
    }
    return index;
  }
  recalcSlides() {
    const swiper = this;
    const {
      slidesEl,
      params
    } = swiper;
    swiper.slides = elementChildren(slidesEl, ".".concat(params.slideClass, ", swiper-slide"));
  }
  enable() {
    const swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit("enable");
  }
  disable() {
    const swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit("disable");
  }
  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min2 = swiper.minTranslate();
    const max2 = swiper.maxTranslate();
    const current2 = (max2 - min2) * progress + min2;
    swiper.translateTo(current2, typeof speed === "undefined" ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const cls = swiper.el.className.split(" ").filter((className) => {
      return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit("_containerClasses", cls.join(" "));
  }
  getSlideClasses(slideEl) {
    const swiper = this;
    if (swiper.destroyed) return "";
    return slideEl.className.split(" ").filter((className) => {
      return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(" ");
  }
  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const updates = [];
    swiper.slides.forEach((slideEl) => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit("_slideClass", slideEl, classNames);
    });
    swiper.emit("_slideClasses", updates);
  }
  slidesPerViewDynamic(view = "current", exact = false) {
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;
    if (typeof params.slidesPerView === "number") return params.slidesPerView;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
      let breakLoop;
      for (let i2 = activeIndex + 1; i2 < slides.length; i2 += 1) {
        if (slides[i2] && !breakLoop) {
          slideSize += Math.ceil(slides[i2].swiperSlideSize);
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i2 = activeIndex - 1; i2 >= 0; i2 -= 1) {
        if (slides[i2] && !breakLoop) {
          slideSize += slides[i2].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      if (view === "current") {
        for (let i2 = activeIndex + 1; i2 < slides.length; i2 += 1) {
          const slideInView = exact ? slidesGrid[i2] + slidesSizesGrid[i2] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i2] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        for (let i2 = activeIndex - 1; i2 >= 0; i2 -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i2] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const {
      snapGrid,
      params
    } = swiper;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      }
    });
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate2() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
      setTranslate2();
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
        translated = swiper.slideTo(slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate2();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit("update");
  }
  changeDirection(newDirection, needUpdate = true) {
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
    }
    if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
      return swiper;
    }
    swiper.el.classList.remove("".concat(swiper.params.containerModifierClass).concat(currentDirection));
    swiper.el.classList.add("".concat(swiper.params.containerModifierClass).concat(newDirection));
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.forEach((slideEl) => {
      if (newDirection === "vertical") {
        slideEl.style.width = "";
      } else {
        slideEl.style.height = "";
      }
    });
    swiper.emit("changeDirection");
    if (needUpdate) swiper.update();
    return swiper;
  }
  changeLanguageDirection(direction) {
    const swiper = this;
    if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
    swiper.rtl = direction === "rtl";
    swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
    if (swiper.rtl) {
      swiper.el.classList.add("".concat(swiper.params.containerModifierClass, "rtl"));
      swiper.el.dir = "rtl";
    } else {
      swiper.el.classList.remove("".concat(swiper.params.containerModifierClass, "rtl"));
      swiper.el.dir = "ltr";
    }
    swiper.update();
  }
  mount(element) {
    const swiper = this;
    if (swiper.mounted) return true;
    let el = element || swiper.params.el;
    if (typeof el === "string") {
      el = document.querySelector(el);
    }
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
      swiper.isElement = true;
    }
    const getWrapperSelector = () => {
      return ".".concat((swiper.params.wrapperClass || "").trim().split(" ").join("."));
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = el.shadowRoot.querySelector(getWrapperSelector());
        return res;
      }
      return elementChildren(el, getWrapperSelector())[0];
    };
    let wrapperEl = getWrapper();
    if (!wrapperEl && swiper.params.createElements) {
      wrapperEl = createElement("div", swiper.params.wrapperClass);
      el.append(wrapperEl);
      elementChildren(el, ".".concat(swiper.params.slideClass)).forEach((slideEl) => {
        wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      el,
      wrapperEl,
      slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
      hostEl: swiper.isElement ? el.parentNode.host : el,
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
      rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
      wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
    });
    return true;
  }
  init(el) {
    const swiper = this;
    if (swiper.initialized) return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit("beforeInit");
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.addClasses();
    swiper.updateSize();
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }
    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }
    if (swiper.params.loop) {
      swiper.loopCreate(void 0, true);
    }
    swiper.attachEvents();
    const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
    if (swiper.isElement) {
      lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
    }
    lazyElements.forEach((imageEl) => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      } else {
        imageEl.addEventListener("load", (e2) => {
          processLazyPreloader(swiper, e2.target);
        });
      }
    });
    preload(swiper);
    swiper.initialized = true;
    preload(swiper);
    swiper.emit("init");
    swiper.emit("afterInit");
    return swiper;
  }
  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params,
      el,
      wrapperEl,
      slides
    } = swiper;
    if (typeof swiper.params === "undefined" || swiper.destroyed) {
      return null;
    }
    swiper.emit("beforeDestroy");
    swiper.initialized = false;
    swiper.detachEvents();
    if (params.loop) {
      swiper.loopDestroy();
    }
    if (cleanStyles) {
      swiper.removeClasses();
      if (el && typeof el !== "string") {
        el.removeAttribute("style");
      }
      if (wrapperEl) {
        wrapperEl.removeAttribute("style");
      }
      if (slides && slides.length) {
        slides.forEach((slideEl) => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
          slideEl.removeAttribute("style");
          slideEl.removeAttribute("data-swiper-slide-index");
        });
      }
    }
    swiper.emit("destroy");
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      if (swiper.el && typeof swiper.el !== "string") {
        swiper.el.swiper = null;
      }
      deleteProps(swiper);
    }
    swiper.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    extend$1(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(mod) {
    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
    const modules2 = Swiper.prototype.__modules__;
    if (typeof mod === "function" && modules2.indexOf(mod) < 0) {
      modules2.push(mod);
    }
  }
  static use(module) {
    if (Array.isArray(module)) {
      module.forEach((m2) => Swiper.installModule(m2));
      return Swiper;
    }
    Swiper.installModule(module);
    return Swiper;
  }
};
Object.keys(prototypes).forEach((prototypeGroup) => {
  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
    Swiper$1.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper$1.use([Resize, Observer]);
const paramsList = [
  "eventsPrefix",
  "injectStyles",
  "injectStylesUrls",
  "modules",
  "init",
  "_direction",
  "oneWayMovement",
  "swiperElementNodeName",
  "touchEventsTarget",
  "initialSlide",
  "_speed",
  "cssMode",
  "updateOnWindowResize",
  "resizeObserver",
  "nested",
  "focusableElements",
  "_enabled",
  "_width",
  "_height",
  "preventInteractionOnTransition",
  "userAgent",
  "url",
  "_edgeSwipeDetection",
  "_edgeSwipeThreshold",
  "_freeMode",
  "_autoHeight",
  "setWrapperSize",
  "virtualTranslate",
  "_effect",
  "breakpoints",
  "breakpointsBase",
  "_spaceBetween",
  "_slidesPerView",
  "maxBackfaceHiddenSlides",
  "_grid",
  "_slidesPerGroup",
  "_slidesPerGroupSkip",
  "_slidesPerGroupAuto",
  "_centeredSlides",
  "_centeredSlidesBounds",
  "_slidesOffsetBefore",
  "_slidesOffsetAfter",
  "normalizeSlideIndex",
  "_centerInsufficientSlides",
  "_watchOverflow",
  "roundLengths",
  "touchRatio",
  "touchAngle",
  "simulateTouch",
  "_shortSwipes",
  "_longSwipes",
  "longSwipesRatio",
  "longSwipesMs",
  "_followFinger",
  "allowTouchMove",
  "_threshold",
  "touchMoveStopPropagation",
  "touchStartPreventDefault",
  "touchStartForcePreventDefault",
  "touchReleaseOnEdges",
  "uniqueNavElements",
  "_resistance",
  "_resistanceRatio",
  "_watchSlidesProgress",
  "_grabCursor",
  "preventClicks",
  "preventClicksPropagation",
  "_slideToClickedSlide",
  "_loop",
  "loopAdditionalSlides",
  "loopAddBlankSlides",
  "loopPreventsSliding",
  "_rewind",
  "_allowSlidePrev",
  "_allowSlideNext",
  "_swipeHandler",
  "_noSwiping",
  "noSwipingClass",
  "noSwipingSelector",
  "passiveListeners",
  "containerModifierClass",
  "slideClass",
  "slideActiveClass",
  "slideVisibleClass",
  "slideFullyVisibleClass",
  "slideNextClass",
  "slidePrevClass",
  "slideBlankClass",
  "wrapperClass",
  "lazyPreloaderClass",
  "lazyPreloadPrevNext",
  "runCallbacksOnInit",
  "observer",
  "observeParents",
  "observeSlideChildren",
  // modules
  "a11y",
  "_autoplay",
  "_controller",
  "coverflowEffect",
  "cubeEffect",
  "fadeEffect",
  "flipEffect",
  "creativeEffect",
  "cardsEffect",
  "hashNavigation",
  "history",
  "keyboard",
  "mousewheel",
  "_navigation",
  "_pagination",
  "parallax",
  "_scrollbar",
  "_thumbs",
  "virtual",
  "zoom",
  "control"
];
function isObject$1(o2) {
  return typeof o2 === "object" && o2 !== null && o2.constructor && Object.prototype.toString.call(o2).slice(8, -1) === "Object" && !o2.__swiper__;
}
function extend(target, src) {
  const noExtend = ["__proto__", "constructor", "prototype"];
  Object.keys(src).filter((key) => noExtend.indexOf(key) < 0).forEach((key) => {
    if (typeof target[key] === "undefined") target[key] = src[key];
    else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
      if (src[key].__swiper__) target[key] = src[key];
      else extend(target[key], src[key]);
    } else {
      target[key] = src[key];
    }
  });
}
function needsNavigation(params = {}) {
  return params.navigation && typeof params.navigation.nextEl === "undefined" && typeof params.navigation.prevEl === "undefined";
}
function needsPagination(params = {}) {
  return params.pagination && typeof params.pagination.el === "undefined";
}
function needsScrollbar(params = {}) {
  return params.scrollbar && typeof params.scrollbar.el === "undefined";
}
function uniqueClasses(classNames = "") {
  const classes2 = classNames.split(" ").map((c2) => c2.trim()).filter((c2) => !!c2);
  const unique = [];
  classes2.forEach((c2) => {
    if (unique.indexOf(c2) < 0) unique.push(c2);
  });
  return unique.join(" ");
}
function attrToProp(attrName = "") {
  return attrName.replace(/-[a-z]/g, (l2) => l2.toUpperCase().replace("-", ""));
}
function wrapperClass(className = "") {
  if (!className) return "swiper-wrapper";
  if (!className.includes("swiper-wrapper")) return "swiper-wrapper ".concat(className);
  return className;
}
function updateSwiper({
  swiper,
  slides,
  passedParams,
  changedParams,
  nextEl,
  prevEl,
  scrollbarEl,
  paginationEl
}) {
  const updateParams = changedParams.filter((key) => key !== "children" && key !== "direction" && key !== "wrapperClass");
  const {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper;
  let needThumbsInit;
  let needControllerInit;
  let needPaginationInit;
  let needScrollbarInit;
  let needNavigationInit;
  let loopNeedDestroy;
  let loopNeedEnable;
  let loopNeedReloop;
  if (changedParams.includes("thumbs") && passedParams.thumbs && passedParams.thumbs.swiper && !passedParams.thumbs.swiper.destroyed && currentParams.thumbs && (!currentParams.thumbs.swiper || currentParams.thumbs.swiper.destroyed)) {
    needThumbsInit = true;
  }
  if (changedParams.includes("controller") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
    needControllerInit = true;
  }
  if (changedParams.includes("pagination") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
    needPaginationInit = true;
  }
  if (changedParams.includes("scrollbar") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
    needScrollbarInit = true;
  }
  if (changedParams.includes("navigation") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
    needNavigationInit = true;
  }
  const destroyModule = (mod) => {
    if (!swiper[mod]) return;
    swiper[mod].destroy();
    if (mod === "navigation") {
      if (swiper.isElement) {
        swiper[mod].prevEl.remove();
        swiper[mod].nextEl.remove();
      }
      currentParams[mod].prevEl = void 0;
      currentParams[mod].nextEl = void 0;
      swiper[mod].prevEl = void 0;
      swiper[mod].nextEl = void 0;
    } else {
      if (swiper.isElement) {
        swiper[mod].el.remove();
      }
      currentParams[mod].el = void 0;
      swiper[mod].el = void 0;
    }
  };
  if (changedParams.includes("loop") && swiper.isElement) {
    if (currentParams.loop && !passedParams.loop) {
      loopNeedDestroy = true;
    } else if (!currentParams.loop && passedParams.loop) {
      loopNeedEnable = true;
    } else {
      loopNeedReloop = true;
    }
  }
  updateParams.forEach((key) => {
    if (isObject$1(currentParams[key]) && isObject$1(passedParams[key])) {
      Object.assign(currentParams[key], passedParams[key]);
      if ((key === "navigation" || key === "pagination" || key === "scrollbar") && "enabled" in passedParams[key] && !passedParams[key].enabled) {
        destroyModule(key);
      }
    } else {
      const newValue = passedParams[key];
      if ((newValue === true || newValue === false) && (key === "navigation" || key === "pagination" || key === "scrollbar")) {
        if (newValue === false) {
          destroyModule(key);
        }
      } else {
        currentParams[key] = passedParams[key];
      }
    }
  });
  if (updateParams.includes("controller") && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (changedParams.includes("children") && slides && virtual && currentParams.virtual.enabled) {
    virtual.slides = slides;
    virtual.update(true);
  } else if (changedParams.includes("virtual") && virtual && currentParams.virtual.enabled) {
    if (slides) virtual.slides = slides;
    virtual.update(true);
  }
  if (changedParams.includes("children") && slides && currentParams.loop) {
    loopNeedReloop = true;
  }
  if (needThumbsInit) {
    const initialized = thumbs.init();
    if (initialized) thumbs.update(true);
  }
  if (needControllerInit) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (needPaginationInit) {
    if (swiper.isElement && (!paginationEl || typeof paginationEl === "string")) {
      paginationEl = document.createElement("div");
      paginationEl.classList.add("swiper-pagination");
      paginationEl.part.add("pagination");
      swiper.el.appendChild(paginationEl);
    }
    if (paginationEl) currentParams.pagination.el = paginationEl;
    pagination.init();
    pagination.render();
    pagination.update();
  }
  if (needScrollbarInit) {
    if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === "string")) {
      scrollbarEl = document.createElement("div");
      scrollbarEl.classList.add("swiper-scrollbar");
      scrollbarEl.part.add("scrollbar");
      swiper.el.appendChild(scrollbarEl);
    }
    if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;
    scrollbar.init();
    scrollbar.updateSize();
    scrollbar.setTranslate();
  }
  if (needNavigationInit) {
    if (swiper.isElement) {
      if (!nextEl || typeof nextEl === "string") {
        nextEl = document.createElement("div");
        nextEl.classList.add("swiper-button-next");
        setInnerHTML(nextEl, swiper.hostEl.constructor.nextButtonSvg);
        nextEl.part.add("button-next");
        swiper.el.appendChild(nextEl);
      }
      if (!prevEl || typeof prevEl === "string") {
        prevEl = document.createElement("div");
        prevEl.classList.add("swiper-button-prev");
        setInnerHTML(prevEl, swiper.hostEl.constructor.prevButtonSvg);
        prevEl.part.add("button-prev");
        swiper.el.appendChild(prevEl);
      }
    }
    if (nextEl) currentParams.navigation.nextEl = nextEl;
    if (prevEl) currentParams.navigation.prevEl = prevEl;
    navigation.init();
    navigation.update();
  }
  if (changedParams.includes("allowSlideNext")) {
    swiper.allowSlideNext = passedParams.allowSlideNext;
  }
  if (changedParams.includes("allowSlidePrev")) {
    swiper.allowSlidePrev = passedParams.allowSlidePrev;
  }
  if (changedParams.includes("direction")) {
    swiper.changeDirection(passedParams.direction, false);
  }
  if (loopNeedDestroy || loopNeedReloop) {
    swiper.loopDestroy();
  }
  if (loopNeedEnable || loopNeedReloop) {
    swiper.loopCreate();
  }
  swiper.update();
}
function getParams$1(obj = {}, splitEvents = true) {
  const params = {
    on: {}
  };
  const events2 = {};
  const passedParams = {};
  extend(params, defaults);
  params._emitClasses = true;
  params.init = false;
  const rest2 = {};
  const allowedParams = paramsList.map((key) => key.replace(/_/, ""));
  const plainObj = Object.assign({}, obj);
  Object.keys(plainObj).forEach((key) => {
    if (typeof obj[key] === "undefined") return;
    if (allowedParams.indexOf(key) >= 0) {
      if (isObject$1(obj[key])) {
        params[key] = {};
        passedParams[key] = {};
        extend(params[key], obj[key]);
        extend(passedParams[key], obj[key]);
      } else {
        params[key] = obj[key];
        passedParams[key] = obj[key];
      }
    } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === "function") {
      if (splitEvents) {
        events2["".concat(key[2].toLowerCase()).concat(key.substr(3))] = obj[key];
      } else {
        params.on["".concat(key[2].toLowerCase()).concat(key.substr(3))] = obj[key];
      }
    } else {
      rest2[key] = obj[key];
    }
  });
  ["navigation", "pagination", "scrollbar"].forEach((key) => {
    if (params[key] === true) params[key] = {};
    if (params[key] === false) delete params[key];
  });
  return {
    params,
    passedParams,
    rest: rest2,
    events: events2
  };
}
function mountSwiper({
  el,
  nextEl,
  prevEl,
  paginationEl,
  scrollbarEl,
  swiper
}, swiperParams) {
  if (needsNavigation(swiperParams) && nextEl && prevEl) {
    swiper.params.navigation.nextEl = nextEl;
    swiper.originalParams.navigation.nextEl = nextEl;
    swiper.params.navigation.prevEl = prevEl;
    swiper.originalParams.navigation.prevEl = prevEl;
  }
  if (needsPagination(swiperParams) && paginationEl) {
    swiper.params.pagination.el = paginationEl;
    swiper.originalParams.pagination.el = paginationEl;
  }
  if (needsScrollbar(swiperParams) && scrollbarEl) {
    swiper.params.scrollbar.el = scrollbarEl;
    swiper.originalParams.scrollbar.el = scrollbarEl;
  }
  swiper.init(el);
}
function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
  const keys2 = [];
  if (!oldParams) return keys2;
  const addKey = (key) => {
    if (keys2.indexOf(key) < 0) keys2.push(key);
  };
  if (children && oldChildren) {
    const oldChildrenKeys = oldChildren.map(getKey);
    const childrenKeys = children.map(getKey);
    if (oldChildrenKeys.join("") !== childrenKeys.join("")) addKey("children");
    if (oldChildren.length !== children.length) addKey("children");
  }
  const watchParams = paramsList.filter((key) => key[0] === "_").map((key) => key.replace(/_/, ""));
  watchParams.forEach((key) => {
    if (key in swiperParams && key in oldParams) {
      if (isObject$1(swiperParams[key]) && isObject$1(oldParams[key])) {
        const newKeys = Object.keys(swiperParams[key]);
        const oldKeys = Object.keys(oldParams[key]);
        if (newKeys.length !== oldKeys.length) {
          addKey(key);
        } else {
          newKeys.forEach((newKey) => {
            if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
              addKey(key);
            }
          });
          oldKeys.forEach((oldKey) => {
            if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);
          });
        }
      } else if (swiperParams[key] !== oldParams[key]) {
        addKey(key);
      }
    }
  });
  return keys2;
}
const updateOnVirtualData = (swiper) => {
  if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;
  swiper.updateSlides();
  swiper.updateProgress();
  swiper.updateSlidesClasses();
  swiper.emit("_virtualUpdated");
  if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {
    swiper.parallax.setTranslate();
  }
};
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function isChildSwiperSlide(child) {
  return child.type && child.type.displayName && child.type.displayName.includes("SwiperSlide");
}
function processChildren(c2) {
  const slides = [];
  React.Children.toArray(c2).forEach((child) => {
    if (isChildSwiperSlide(child)) {
      slides.push(child);
    } else if (child.props && child.props.children) {
      processChildren(child.props.children).forEach((slide2) => slides.push(slide2));
    }
  });
  return slides;
}
function getChildren(c2) {
  const slides = [];
  const slots = {
    "container-start": [],
    "container-end": [],
    "wrapper-start": [],
    "wrapper-end": []
  };
  React.Children.toArray(c2).forEach((child) => {
    if (isChildSwiperSlide(child)) {
      slides.push(child);
    } else if (child.props && child.props.slot && slots[child.props.slot]) {
      slots[child.props.slot].push(child);
    } else if (child.props && child.props.children) {
      const foundSlides = processChildren(child.props.children);
      if (foundSlides.length > 0) {
        foundSlides.forEach((slide2) => slides.push(slide2));
      } else {
        slots["container-end"].push(child);
      }
    } else {
      slots["container-end"].push(child);
    }
  });
  return {
    slides,
    slots
  };
}
function renderVirtual(swiper, slides, virtualData) {
  if (!virtualData) return null;
  const getSlideIndex = (index) => {
    let slideIndex = index;
    if (index < 0) {
      slideIndex = slides.length + index;
    } else if (slideIndex >= slides.length) {
      slideIndex = slideIndex - slides.length;
    }
    return slideIndex;
  };
  const style = swiper.isHorizontal() ? {
    [swiper.rtlTranslate ? "right" : "left"]: "".concat(virtualData.offset, "px")
  } : {
    top: "".concat(virtualData.offset, "px")
  };
  const {
    from,
    to: to2
  } = virtualData;
  const loopFrom = swiper.params.loop ? -slides.length : 0;
  const loopTo = swiper.params.loop ? slides.length * 2 : slides.length;
  const slidesToRender = [];
  for (let i2 = loopFrom; i2 < loopTo; i2 += 1) {
    if (i2 >= from && i2 <= to2) {
      slidesToRender.push(slides[getSlideIndex(i2)]);
    }
  }
  return slidesToRender.map((child, index) => {
    return /* @__PURE__ */ React.cloneElement(child, {
      swiper,
      style,
      key: child.props.virtualIndex || child.key || "slide-".concat(index)
    });
  });
}
function useIsomorphicLayoutEffect$1(callback, deps) {
  if (typeof window === "undefined") return reactExports.useEffect(callback, deps);
  return reactExports.useLayoutEffect(callback, deps);
}
const SwiperSlideContext = /* @__PURE__ */ reactExports.createContext(null);
const SwiperContext = /* @__PURE__ */ reactExports.createContext(null);
const Swiper2 = /* @__PURE__ */ reactExports.forwardRef(({
  className,
  tag: Tag = "div",
  wrapperTag: WrapperTag = "div",
  children,
  onSwiper,
  ...rest2
} = {}, externalElRef) => {
  let eventsAssigned = false;
  const [containerClasses, setContainerClasses] = reactExports.useState("swiper");
  const [virtualData, setVirtualData] = reactExports.useState(null);
  const [breakpointChanged, setBreakpointChanged] = reactExports.useState(false);
  const initializedRef = reactExports.useRef(false);
  const swiperElRef = reactExports.useRef(null);
  const swiperRef = reactExports.useRef(null);
  const oldPassedParamsRef = reactExports.useRef(null);
  const oldSlides = reactExports.useRef(null);
  const nextElRef = reactExports.useRef(null);
  const prevElRef = reactExports.useRef(null);
  const paginationElRef = reactExports.useRef(null);
  const scrollbarElRef = reactExports.useRef(null);
  const {
    params: swiperParams,
    passedParams,
    rest: restProps,
    events: events2
  } = getParams$1(rest2);
  const {
    slides,
    slots
  } = getChildren(children);
  const onBeforeBreakpoint = () => {
    setBreakpointChanged(!breakpointChanged);
  };
  Object.assign(swiperParams.on, {
    _containerClasses(swiper, classes2) {
      setContainerClasses(classes2);
    }
  });
  const initSwiper = () => {
    Object.assign(swiperParams.on, events2);
    eventsAssigned = true;
    const passParams = {
      ...swiperParams
    };
    delete passParams.wrapperClass;
    swiperRef.current = new Swiper$1(passParams);
    if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {
      swiperRef.current.virtual.slides = slides;
      const extendWith = {
        cache: false,
        slides,
        renderExternal: setVirtualData,
        renderExternalUpdate: false
      };
      extend(swiperRef.current.params.virtual, extendWith);
      extend(swiperRef.current.originalParams.virtual, extendWith);
    }
  };
  if (!swiperElRef.current) {
    initSwiper();
  }
  if (swiperRef.current) {
    swiperRef.current.on("_beforeBreakpoint", onBeforeBreakpoint);
  }
  const attachEvents2 = () => {
    if (eventsAssigned || !events2 || !swiperRef.current) return;
    Object.keys(events2).forEach((eventName) => {
      swiperRef.current.on(eventName, events2[eventName]);
    });
  };
  const detachEvents2 = () => {
    if (!events2 || !swiperRef.current) return;
    Object.keys(events2).forEach((eventName) => {
      swiperRef.current.off(eventName, events2[eventName]);
    });
  };
  reactExports.useEffect(() => {
    return () => {
      if (swiperRef.current) swiperRef.current.off("_beforeBreakpoint", onBeforeBreakpoint);
    };
  });
  reactExports.useEffect(() => {
    if (!initializedRef.current && swiperRef.current) {
      swiperRef.current.emitSlidesClasses();
      initializedRef.current = true;
    }
  });
  useIsomorphicLayoutEffect$1(() => {
    if (externalElRef) {
      externalElRef.current = swiperElRef.current;
    }
    if (!swiperElRef.current) return;
    if (swiperRef.current.destroyed) {
      initSwiper();
    }
    mountSwiper({
      el: swiperElRef.current,
      nextEl: nextElRef.current,
      prevEl: prevElRef.current,
      paginationEl: paginationElRef.current,
      scrollbarEl: scrollbarElRef.current,
      swiper: swiperRef.current
    }, swiperParams);
    if (onSwiper && !swiperRef.current.destroyed) onSwiper(swiperRef.current);
    return () => {
      if (swiperRef.current && !swiperRef.current.destroyed) {
        swiperRef.current.destroy(true, false);
      }
    };
  }, []);
  useIsomorphicLayoutEffect$1(() => {
    attachEvents2();
    const changedParams = getChangedParams(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, (c2) => c2.key);
    oldPassedParamsRef.current = passedParams;
    oldSlides.current = slides;
    if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {
      updateSwiper({
        swiper: swiperRef.current,
        slides,
        passedParams,
        changedParams,
        nextEl: nextElRef.current,
        prevEl: prevElRef.current,
        scrollbarEl: scrollbarElRef.current,
        paginationEl: paginationElRef.current
      });
    }
    return () => {
      detachEvents2();
    };
  });
  useIsomorphicLayoutEffect$1(() => {
    updateOnVirtualData(swiperRef.current);
  }, [virtualData]);
  function renderSlides() {
    if (swiperParams.virtual) {
      return renderVirtual(swiperRef.current, slides, virtualData);
    }
    return slides.map((child, index) => {
      return /* @__PURE__ */ React.cloneElement(child, {
        swiper: swiperRef.current,
        swiperSlideIndex: index
      });
    });
  }
  return /* @__PURE__ */ React.createElement(Tag, _extends$1({
    ref: swiperElRef,
    className: uniqueClasses("".concat(containerClasses).concat(className ? " ".concat(className) : ""))
  }, restProps), /* @__PURE__ */ React.createElement(SwiperContext.Provider, {
    value: swiperRef.current
  }, slots["container-start"], /* @__PURE__ */ React.createElement(WrapperTag, {
    className: wrapperClass(swiperParams.wrapperClass)
  }, slots["wrapper-start"], renderSlides(), slots["wrapper-end"]), needsNavigation(swiperParams) && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    ref: prevElRef,
    className: "swiper-button-prev"
  }), /* @__PURE__ */ React.createElement("div", {
    ref: nextElRef,
    className: "swiper-button-next"
  })), needsScrollbar(swiperParams) && /* @__PURE__ */ React.createElement("div", {
    ref: scrollbarElRef,
    className: "swiper-scrollbar"
  }), needsPagination(swiperParams) && /* @__PURE__ */ React.createElement("div", {
    ref: paginationElRef,
    className: "swiper-pagination"
  }), slots["container-end"]));
});
Swiper2.displayName = "Swiper";
const SwiperSlide$1 = /* @__PURE__ */ reactExports.forwardRef(({
  tag: Tag = "div",
  children,
  className = "",
  swiper,
  zoom: zoom2,
  lazy,
  virtualIndex,
  swiperSlideIndex,
  ...rest2
} = {}, externalRef) => {
  const slideElRef = reactExports.useRef(null);
  const [slideClasses, setSlideClasses] = reactExports.useState("swiper-slide");
  const [lazyLoaded, setLazyLoaded] = reactExports.useState(false);
  function updateClasses(_s, el, classNames) {
    if (el === slideElRef.current) {
      setSlideClasses(classNames);
    }
  }
  useIsomorphicLayoutEffect$1(() => {
    if (typeof swiperSlideIndex !== "undefined") {
      slideElRef.current.swiperSlideIndex = swiperSlideIndex;
    }
    if (externalRef) {
      externalRef.current = slideElRef.current;
    }
    if (!slideElRef.current || !swiper) {
      return;
    }
    if (swiper.destroyed) {
      if (slideClasses !== "swiper-slide") {
        setSlideClasses("swiper-slide");
      }
      return;
    }
    swiper.on("_slideClass", updateClasses);
    return () => {
      if (!swiper) return;
      swiper.off("_slideClass", updateClasses);
    };
  });
  useIsomorphicLayoutEffect$1(() => {
    if (swiper && slideElRef.current && !swiper.destroyed) {
      setSlideClasses(swiper.getSlideClasses(slideElRef.current));
    }
  }, [swiper]);
  const slideData = {
    isActive: slideClasses.indexOf("swiper-slide-active") >= 0,
    isVisible: slideClasses.indexOf("swiper-slide-visible") >= 0,
    isPrev: slideClasses.indexOf("swiper-slide-prev") >= 0,
    isNext: slideClasses.indexOf("swiper-slide-next") >= 0
  };
  const renderChildren = () => {
    return typeof children === "function" ? children(slideData) : children;
  };
  const onLoad2 = () => {
    setLazyLoaded(true);
  };
  return /* @__PURE__ */ React.createElement(Tag, _extends$1({
    ref: slideElRef,
    className: uniqueClasses("".concat(slideClasses).concat(className ? " ".concat(className) : "")),
    "data-swiper-slide-index": virtualIndex,
    onLoad: onLoad2
  }, rest2), zoom2 && /* @__PURE__ */ React.createElement(SwiperSlideContext.Provider, {
    value: slideData
  }, /* @__PURE__ */ React.createElement("div", {
    className: "swiper-zoom-container",
    "data-swiper-zoom": typeof zoom2 === "number" ? zoom2 : void 0
  }, renderChildren(), lazy && !lazyLoaded && /* @__PURE__ */ React.createElement("div", {
    className: "swiper-lazy-preloader"
  }))), !zoom2 && /* @__PURE__ */ React.createElement(SwiperSlideContext.Provider, {
    value: slideData
  }, renderChildren(), lazy && !lazyLoaded && /* @__PURE__ */ React.createElement("div", {
    className: "swiper-lazy-preloader"
  })));
});
SwiperSlide$1.displayName = "SwiperSlide";
function Virtual({
  swiper,
  extendParams,
  on,
  emit
}) {
  extendParams({
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      slidesPerViewAutoSlideSize: 320,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: true,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  });
  let cssModeTimeout;
  const document2 = getDocument();
  swiper.virtual = {
    cache: {},
    from: void 0,
    to: void 0,
    slides: [],
    offset: 0,
    slidesGrid: []
  };
  const tempDOM = document2.createElement("div");
  function renderSlide(slide2, index) {
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }
    let slideEl;
    if (params.renderSlide) {
      slideEl = params.renderSlide.call(swiper, slide2, index);
      if (typeof slideEl === "string") {
        setInnerHTML(tempDOM, slideEl);
        slideEl = tempDOM.children[0];
      }
    } else if (swiper.isElement) {
      slideEl = createElement("swiper-slide");
    } else {
      slideEl = createElement("div", swiper.params.slideClass);
    }
    slideEl.setAttribute("data-swiper-slide-index", index);
    if (!params.renderSlide) {
      setInnerHTML(slideEl, slide2);
    }
    if (params.cache) {
      swiper.virtual.cache[index] = slideEl;
    }
    return slideEl;
  }
  function update8(force, beforeInit, forceActiveIndex) {
    const {
      slidesPerGroup,
      centeredSlides,
      slidesPerView,
      loop: isLoop,
      initialSlide
    } = swiper.params;
    if (beforeInit && !isLoop && initialSlide > 0) {
      return;
    }
    const {
      addSlidesBefore,
      addSlidesAfter,
      slidesPerViewAutoSlideSize
    } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      offset: previousOffset
    } = swiper.virtual;
    if (!swiper.params.cssMode) {
      swiper.updateActiveIndex();
    }
    const activeIndex = typeof forceActiveIndex === "undefined" ? swiper.activeIndex || 0 : forceActiveIndex;
    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = "right";
    else offsetProp = swiper.isHorizontal() ? "left" : "top";
    let slidesPerViewNumeric;
    if (slidesPerView === "auto") {
      if (slidesPerViewAutoSlideSize) {
        let swiperSize = swiper.size;
        if (!swiperSize) {
          swiperSize = swiper.isHorizontal() ? swiper.el.getBoundingClientRect().width : swiper.el.getBoundingClientRect().height;
        }
        slidesPerViewNumeric = Math.max(1, Math.ceil(swiperSize / slidesPerViewAutoSlideSize));
      } else {
        slidesPerViewNumeric = 1;
      }
    } else {
      slidesPerViewNumeric = slidesPerView;
    }
    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerViewNumeric / 2) + slidesPerGroup + addSlidesAfter;
      slidesBefore = Math.floor(slidesPerViewNumeric / 2) + slidesPerGroup + addSlidesBefore;
    } else {
      slidesAfter = slidesPerViewNumeric + (slidesPerGroup - 1) + addSlidesAfter;
      slidesBefore = (isLoop ? slidesPerViewNumeric : slidesPerGroup) + addSlidesBefore;
    }
    let from = activeIndex - slidesBefore;
    let to2 = activeIndex + slidesAfter;
    if (!isLoop) {
      from = Math.max(from, 0);
      to2 = Math.min(to2, slides.length - 1);
    }
    let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
    if (isLoop && activeIndex >= slidesBefore) {
      from -= slidesBefore;
      if (!centeredSlides) offset += swiper.slidesGrid[0];
    } else if (isLoop && activeIndex < slidesBefore) {
      from = -slidesBefore;
      if (centeredSlides) offset += swiper.slidesGrid[0];
    }
    Object.assign(swiper.virtual, {
      from,
      to: to2,
      offset,
      slidesGrid: swiper.slidesGrid,
      slidesBefore,
      slidesAfter
    });
    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      emit("virtualUpdate");
    }
    if (previousFrom === from && previousTo === to2 && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.forEach((slideEl) => {
          slideEl.style[offsetProp] = "".concat(offset - Math.abs(swiper.cssOverflowAdjustment()), "px");
        });
      }
      swiper.updateProgress();
      emit("virtualUpdate");
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to: to2,
        slides: (function getSlides() {
          const slidesToRender = [];
          for (let i2 = from; i2 <= to2; i2 += 1) {
            slidesToRender.push(slides[i2]);
          }
          return slidesToRender;
        })()
      });
      if (swiper.params.virtual.renderExternalUpdate) {
        onRendered();
      } else {
        emit("virtualUpdate");
      }
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    const getSlideIndex = (index) => {
      let slideIndex = index;
      if (index < 0) {
        slideIndex = slides.length + index;
      } else if (slideIndex >= slides.length) {
        slideIndex = slideIndex - slides.length;
      }
      return slideIndex;
    };
    if (force) {
      swiper.slides.filter((el) => el.matches(".".concat(swiper.params.slideClass, ", swiper-slide"))).forEach((slideEl) => {
        slideEl.remove();
      });
    } else {
      for (let i2 = previousFrom; i2 <= previousTo; i2 += 1) {
        if (i2 < from || i2 > to2) {
          const slideIndex = getSlideIndex(i2);
          swiper.slides.filter((el) => el.matches(".".concat(swiper.params.slideClass, '[data-swiper-slide-index="').concat(slideIndex, '"], swiper-slide[data-swiper-slide-index="').concat(slideIndex, '"]'))).forEach((slideEl) => {
            slideEl.remove();
          });
        }
      }
    }
    const loopFrom = isLoop ? -slides.length : 0;
    const loopTo = isLoop ? slides.length * 2 : slides.length;
    for (let i2 = loopFrom; i2 < loopTo; i2 += 1) {
      if (i2 >= from && i2 <= to2) {
        const slideIndex = getSlideIndex(i2);
        if (typeof previousTo === "undefined" || force) {
          appendIndexes.push(slideIndex);
        } else {
          if (i2 > previousTo) appendIndexes.push(slideIndex);
          if (i2 < previousFrom) prependIndexes.push(slideIndex);
        }
      }
    }
    appendIndexes.forEach((index) => {
      swiper.slidesEl.append(renderSlide(slides[index], index));
    });
    if (isLoop) {
      for (let i2 = prependIndexes.length - 1; i2 >= 0; i2 -= 1) {
        const index = prependIndexes[i2];
        swiper.slidesEl.prepend(renderSlide(slides[index], index));
      }
    } else {
      prependIndexes.sort((a2, b2) => b2 - a2);
      prependIndexes.forEach((index) => {
        swiper.slidesEl.prepend(renderSlide(slides[index], index));
      });
    }
    elementChildren(swiper.slidesEl, ".swiper-slide, swiper-slide").forEach((slideEl) => {
      slideEl.style[offsetProp] = "".concat(offset - Math.abs(swiper.cssOverflowAdjustment()), "px");
    });
    onRendered();
  }
  function appendSlide2(slides) {
    if (typeof slides === "object" && "length" in slides) {
      for (let i2 = 0; i2 < slides.length; i2 += 1) {
        if (slides[i2]) swiper.virtual.slides.push(slides[i2]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }
    update8(true);
  }
  function prependSlide2(slides) {
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;
    if (Array.isArray(slides)) {
      for (let i2 = 0; i2 < slides.length; i2 += 1) {
        if (slides[i2]) swiper.virtual.slides.unshift(slides[i2]);
      }
      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }
    if (swiper.params.virtual.cache) {
      const cache2 = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache2).forEach((cachedIndex) => {
        const cachedEl = cache2[cachedIndex];
        const cachedElIndex = cachedEl.getAttribute("data-swiper-slide-index");
        if (cachedElIndex) {
          cachedEl.setAttribute("data-swiper-slide-index", parseInt(cachedElIndex, 10) + numberOfNewSlides);
        }
        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;
      });
      swiper.virtual.cache = newCache;
    }
    update8(true);
    swiper.slideTo(newActiveIndex, 0);
  }
  function removeSlide2(slidesIndexes) {
    if (typeof slidesIndexes === "undefined" || slidesIndexes === null) return;
    let activeIndex = swiper.activeIndex;
    if (Array.isArray(slidesIndexes)) {
      for (let i2 = slidesIndexes.length - 1; i2 >= 0; i2 -= 1) {
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i2]];
          Object.keys(swiper.virtual.cache).forEach((key) => {
            if (key > slidesIndexes) {
              swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
              swiper.virtual.cache[key - 1].setAttribute("data-swiper-slide-index", key - 1);
              delete swiper.virtual.cache[key];
            }
          });
        }
        swiper.virtual.slides.splice(slidesIndexes[i2], 1);
        if (slidesIndexes[i2] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
        Object.keys(swiper.virtual.cache).forEach((key) => {
          if (key > slidesIndexes) {
            swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
            swiper.virtual.cache[key - 1].setAttribute("data-swiper-slide-index", key - 1);
            delete swiper.virtual.cache[key];
          }
        });
      }
      swiper.virtual.slides.splice(slidesIndexes, 1);
      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }
    update8(true);
    swiper.slideTo(activeIndex, 0);
  }
  function removeAllSlides2() {
    swiper.virtual.slides = [];
    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }
    update8(true);
    swiper.slideTo(0, 0);
  }
  on("beforeInit", () => {
    if (!swiper.params.virtual.enabled) return;
    let domSlidesAssigned;
    if (typeof swiper.passedParams.virtual.slides === "undefined") {
      const slides = [...swiper.slidesEl.children].filter((el) => el.matches(".".concat(swiper.params.slideClass, ", swiper-slide")));
      if (slides && slides.length) {
        swiper.virtual.slides = [...slides];
        domSlidesAssigned = true;
        slides.forEach((slideEl, slideIndex) => {
          slideEl.setAttribute("data-swiper-slide-index", slideIndex);
          swiper.virtual.cache[slideIndex] = slideEl;
          slideEl.remove();
        });
      }
    }
    if (!domSlidesAssigned) {
      swiper.virtual.slides = swiper.params.virtual.slides;
    }
    swiper.classNames.push("".concat(swiper.params.containerModifierClass, "virtual"));
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
    update8(false, true);
  });
  on("setTranslate", () => {
    if (!swiper.params.virtual.enabled) return;
    if (swiper.params.cssMode && !swiper._immediateVirtual) {
      clearTimeout(cssModeTimeout);
      cssModeTimeout = setTimeout(() => {
        update8();
      }, 100);
    } else {
      update8();
    }
  });
  on("init update resize", () => {
    if (!swiper.params.virtual.enabled) return;
    if (swiper.params.cssMode) {
      setCSSProperty(swiper.wrapperEl, "--swiper-virtual-size", "".concat(swiper.virtualSize, "px"));
    }
  });
  Object.assign(swiper.virtual, {
    appendSlide: appendSlide2,
    prependSlide: prependSlide2,
    removeSlide: removeSlide2,
    removeAllSlides: removeAllSlides2,
    update: update8
  });
}
function Keyboard({
  swiper,
  extendParams,
  on,
  emit
}) {
  const document2 = getDocument();
  const window2 = getWindow$1();
  swiper.keyboard = {
    enabled: false
  };
  extendParams({
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true
    }
  });
  function handle2(event2) {
    if (!swiper.enabled) return;
    const {
      rtlTranslate: rtl
    } = swiper;
    let e2 = event2;
    if (e2.originalEvent) e2 = e2.originalEvent;
    const kc = e2.keyCode || e2.charCode;
    const pageUpDown = swiper.params.keyboard.pageUpDown;
    const isPageUp = pageUpDown && kc === 33;
    const isPageDown = pageUpDown && kc === 34;
    const isArrowLeft = kc === 37;
    const isArrowRight = kc === 39;
    const isArrowUp = kc === 38;
    const isArrowDown = kc === 40;
    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
      return false;
    }
    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
      return false;
    }
    if (e2.shiftKey || e2.altKey || e2.ctrlKey || e2.metaKey) {
      return void 0;
    }
    if (document2.activeElement && (document2.activeElement.isContentEditable || document2.activeElement.nodeName && (document2.activeElement.nodeName.toLowerCase() === "input" || document2.activeElement.nodeName.toLowerCase() === "textarea"))) {
      return void 0;
    }
    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      let inView = false;
      if (elementParents(swiper.el, ".".concat(swiper.params.slideClass, ", swiper-slide")).length > 0 && elementParents(swiper.el, ".".concat(swiper.params.slideActiveClass)).length === 0) {
        return void 0;
      }
      const el = swiper.el;
      const swiperWidth = el.clientWidth;
      const swiperHeight = el.clientHeight;
      const windowWidth = window2.innerWidth;
      const windowHeight = window2.innerHeight;
      const swiperOffset = elementOffset(el);
      if (rtl) swiperOffset.left -= el.scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
      for (let i2 = 0; i2 < swiperCoord.length; i2 += 1) {
        const point = swiperCoord[i2];
        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
          if (point[0] === 0 && point[1] === 0) continue;
          inView = true;
        }
      }
      if (!inView) return void 0;
    }
    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e2.preventDefault) e2.preventDefault();
        else e2.returnValue = false;
      }
      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e2.preventDefault) e2.preventDefault();
        else e2.returnValue = false;
      }
      if (isPageDown || isArrowDown) swiper.slideNext();
      if (isPageUp || isArrowUp) swiper.slidePrev();
    }
    emit("keyPress", kc);
    return void 0;
  }
  function enable2() {
    if (swiper.keyboard.enabled) return;
    document2.addEventListener("keydown", handle2);
    swiper.keyboard.enabled = true;
  }
  function disable2() {
    if (!swiper.keyboard.enabled) return;
    document2.removeEventListener("keydown", handle2);
    swiper.keyboard.enabled = false;
  }
  on("init", () => {
    if (swiper.params.keyboard.enabled) {
      enable2();
    }
  });
  on("destroy", () => {
    if (swiper.keyboard.enabled) {
      disable2();
    }
  });
  Object.assign(swiper.keyboard, {
    enable: enable2,
    disable: disable2
  });
}
function Mousewheel({
  swiper,
  extendParams,
  on,
  emit
}) {
  const window2 = getWindow$1();
  extendParams({
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarget: "container",
      thresholdDelta: null,
      thresholdTime: null,
      noMousewheelClass: "swiper-no-mousewheel"
    }
  });
  swiper.mousewheel = {
    enabled: false
  };
  let timeout;
  let lastScrollTime = now();
  let lastEventBeforeSnap;
  const recentWheelEvents = [];
  function normalize(e2) {
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;
    let sX = 0;
    let sY = 0;
    let pX = 0;
    let pY = 0;
    if ("detail" in e2) {
      sY = e2.detail;
    }
    if ("wheelDelta" in e2) {
      sY = -e2.wheelDelta / 120;
    }
    if ("wheelDeltaY" in e2) {
      sY = -e2.wheelDeltaY / 120;
    }
    if ("wheelDeltaX" in e2) {
      sX = -e2.wheelDeltaX / 120;
    }
    if ("axis" in e2 && e2.axis === e2.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ("deltaY" in e2) {
      pY = e2.deltaY;
    }
    if ("deltaX" in e2) {
      pX = e2.deltaX;
    }
    if (e2.shiftKey && !pX) {
      pX = pY;
      pY = 0;
    }
    if ((pX || pY) && e2.deltaMode) {
      if (e2.deltaMode === 1) {
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }
    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  }
  function handleMouseEnter() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = true;
  }
  function handleMouseLeave() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = false;
  }
  function animateSlider(newEvent) {
    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
      return false;
    }
    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
      return false;
    }
    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
      return true;
    }
    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        emit("scroll", newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      emit("scroll", newEvent.raw);
    }
    lastScrollTime = new window2.Date().getTime();
    return false;
  }
  function releaseScroll(newEvent) {
    const params = swiper.params.mousewheel;
    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      return true;
    }
    return false;
  }
  function handle2(event2) {
    let e2 = event2;
    let disableParentSwiper = true;
    if (!swiper.enabled) return;
    if (event2.target.closest(".".concat(swiper.params.mousewheel.noMousewheelClass))) return;
    const params = swiper.params.mousewheel;
    if (swiper.params.cssMode) {
      e2.preventDefault();
    }
    let targetEl = swiper.el;
    if (swiper.params.mousewheel.eventsTarget !== "container") {
      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
    }
    const targetElContainsTarget = targetEl && targetEl.contains(e2.target);
    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;
    if (e2.originalEvent) e2 = e2.originalEvent;
    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;
    const data = normalize(e2);
    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;
        else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;
      else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }
    if (delta === 0) return true;
    if (params.invert) delta = -delta;
    let positions = swiper.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();
    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    if (disableParentSwiper && swiper.params.nested) e2.stopPropagation();
    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
      const newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event2
      };
      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift();
      }
      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
      recentWheelEvents.push(newEvent);
      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          animateSlider(newEvent);
        }
      } else {
        animateSlider(newEvent);
      }
      if (releaseScroll(newEvent)) {
        return true;
      }
    } else {
      const newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta)
      };
      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
      if (!ignoreWheelEvents) {
        lastEventBeforeSnap = void 0;
        let position = swiper.getTranslate() + delta * params.sensitivity;
        const wasBeginning = swiper.isBeginning;
        const wasEnd = swiper.isEnd;
        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }
        if (swiper.params.loop) {
          swiper.loopFix({
            direction: newEvent.direction < 0 ? "next" : "prev",
            byMousewheel: true
          });
        }
        if (swiper.params.freeMode.sticky) {
          clearTimeout(timeout);
          timeout = void 0;
          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift();
          }
          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);
          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            timeout = nextTick(() => {
              if (swiper.destroyed || !swiper.params) return;
              swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
            }, 0);
          }
          if (!timeout) {
            timeout = nextTick(() => {
              if (swiper.destroyed || !swiper.params) return;
              const snapToThreshold = 0.5;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
            }, 500);
          }
        }
        if (!ignoreWheelEvents) emit("scroll", e2);
        if (swiper.params.autoplay && swiper.params.autoplay.disableOnInteraction) swiper.autoplay.stop();
        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {
          return true;
        }
      }
    }
    if (e2.preventDefault) e2.preventDefault();
    else e2.returnValue = false;
    return false;
  }
  function events2(method) {
    let targetEl = swiper.el;
    if (swiper.params.mousewheel.eventsTarget !== "container") {
      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
    }
    targetEl[method]("mouseenter", handleMouseEnter);
    targetEl[method]("mouseleave", handleMouseLeave);
    targetEl[method]("wheel", handle2);
  }
  function enable2() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener("wheel", handle2);
      return true;
    }
    if (swiper.mousewheel.enabled) return false;
    events2("addEventListener");
    swiper.mousewheel.enabled = true;
    return true;
  }
  function disable2() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, handle2);
      return true;
    }
    if (!swiper.mousewheel.enabled) return false;
    events2("removeEventListener");
    swiper.mousewheel.enabled = false;
    return true;
  }
  on("init", () => {
    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
      disable2();
    }
    if (swiper.params.mousewheel.enabled) enable2();
  });
  on("destroy", () => {
    if (swiper.params.cssMode) {
      enable2();
    }
    if (swiper.mousewheel.enabled) disable2();
  });
  Object.assign(swiper.mousewheel, {
    enable: enable2,
    disable: disable2
  });
}
function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach((key) => {
      if (!params[key] && params.auto === true) {
        let element = elementChildren(swiper.el, ".".concat(checkProps[key]))[0];
        if (!element) {
          element = createElement("div", checkProps[key]);
          element.className = checkProps[key];
          swiper.el.append(element);
        }
        params[key] = element;
        originalParams[key] = element;
      }
    });
  }
  return params;
}
const arrowSvg$1 = '<svg class="swiper-navigation-icon" width="11" height="20" viewBox="0 0 11 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.38296 20.0762C0.111788 19.805 0.111788 19.3654 0.38296 19.0942L9.19758 10.2796L0.38296 1.46497C0.111788 1.19379 0.111788 0.754138 0.38296 0.482966C0.654131 0.211794 1.09379 0.211794 1.36496 0.482966L10.4341 9.55214C10.8359 9.9539 10.8359 10.6053 10.4341 11.007L1.36496 20.0762C1.09379 20.3474 0.654131 20.3474 0.38296 20.0762Z" fill="currentColor"/></svg>';
function Navigation({
  swiper,
  extendParams,
  on,
  emit
}) {
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      addIcons: true,
      hideOnClick: false,
      disabledClass: "swiper-button-disabled",
      hiddenClass: "swiper-button-hidden",
      lockClass: "swiper-button-lock",
      navigationDisabledClass: "swiper-navigation-disabled"
    }
  });
  swiper.navigation = {
    nextEl: null,
    prevEl: null
  };
  function getEl(el) {
    let res;
    if (el && typeof el === "string" && swiper.isElement) {
      res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);
      if (res) return res;
    }
    if (el) {
      if (typeof el === "string") res = [...document.querySelectorAll(el)];
      if (swiper.params.uniqueNavElements && typeof el === "string" && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
        res = swiper.el.querySelector(el);
      } else if (res && res.length === 1) {
        res = res[0];
      }
    }
    if (el && !res) return el;
    return res;
  }
  function toggleEl(el, disabled) {
    const params = swiper.params.navigation;
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      if (subEl) {
        subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
        if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
        if (swiper.params.watchOverflow && swiper.enabled) {
          subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
        }
      }
    });
  }
  function update8() {
    const {
      nextEl,
      prevEl
    } = swiper.navigation;
    if (swiper.params.loop) {
      toggleEl(prevEl, false);
      toggleEl(nextEl, false);
      return;
    }
    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
  }
  function onPrevClick(e2) {
    e2.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slidePrev();
    emit("navigationPrev");
  }
  function onNextClick(e2) {
    e2.preventDefault();
    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slideNext();
    emit("navigationNext");
  }
  function init2() {
    const params = swiper.params.navigation;
    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: "swiper-button-next",
      prevEl: "swiper-button-prev"
    });
    if (!(params.nextEl || params.prevEl)) return;
    let nextEl = getEl(params.nextEl);
    let prevEl = getEl(params.prevEl);
    Object.assign(swiper.navigation, {
      nextEl,
      prevEl
    });
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const initButton = (el, dir) => {
      if (el) {
        if (params.addIcons && el.matches(".swiper-button-next,.swiper-button-prev") && !el.querySelector("svg")) {
          const tempEl = document.createElement("div");
          setInnerHTML(tempEl, arrowSvg$1);
          el.appendChild(tempEl.querySelector("svg"));
          tempEl.remove();
        }
        el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
      }
      if (!swiper.enabled && el) {
        el.classList.add(...params.lockClass.split(" "));
      }
    };
    nextEl.forEach((el) => initButton(el, "next"));
    prevEl.forEach((el) => initButton(el, "prev"));
  }
  function destroy2() {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const destroyButton = (el, dir) => {
      el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
      el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
    };
    nextEl.forEach((el) => destroyButton(el, "next"));
    prevEl.forEach((el) => destroyButton(el, "prev"));
  }
  on("init", () => {
    if (swiper.params.navigation.enabled === false) {
      disable2();
    } else {
      init2();
      update8();
    }
  });
  on("toEdge fromEdge lock unlock", () => {
    update8();
  });
  on("destroy", () => {
    destroy2();
  });
  on("enable disable", () => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    if (swiper.enabled) {
      update8();
      return;
    }
    [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.add(swiper.params.navigation.lockClass));
  });
  on("click", (_s, e2) => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const targetEl = e2.target;
    let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
    if (swiper.isElement && !targetIsButton) {
      const path2 = e2.path || e2.composedPath && e2.composedPath();
      if (path2) {
        targetIsButton = path2.find((pathEl) => nextEl.includes(pathEl) || prevEl.includes(pathEl));
      }
    }
    if (swiper.params.navigation.hideOnClick && !targetIsButton) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
      let isHidden;
      if (nextEl.length) {
        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      } else if (prevEl.length) {
        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      }
      if (isHidden === true) {
        emit("navigationShow");
      } else {
        emit("navigationHide");
      }
      [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.toggle(swiper.params.navigation.hiddenClass));
    }
  });
  const enable2 = () => {
    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
    init2();
    update8();
  };
  const disable2 = () => {
    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
    destroy2();
  };
  Object.assign(swiper.navigation, {
    enable: enable2,
    disable: disable2,
    update: update8,
    init: init2,
    destroy: destroy2
  });
}
function classesToSelector(classes2 = "") {
  return ".".concat(classes2.trim().replace(/([\.:!+\/()[\]])/g, "\\$1").replace(/ /g, "."));
}
function Pagination({
  swiper,
  extendParams,
  on,
  emit
}) {
  const pfx = "swiper-pagination";
  extendParams({
    pagination: {
      el: null,
      bulletElement: "span",
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: "bullets",
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: (number2) => number2,
      formatFractionTotal: (number2) => number2,
      bulletClass: "".concat(pfx, "-bullet"),
      bulletActiveClass: "".concat(pfx, "-bullet-active"),
      modifierClass: "".concat(pfx, "-"),
      currentClass: "".concat(pfx, "-current"),
      totalClass: "".concat(pfx, "-total"),
      hiddenClass: "".concat(pfx, "-hidden"),
      progressbarFillClass: "".concat(pfx, "-progressbar-fill"),
      progressbarOppositeClass: "".concat(pfx, "-progressbar-opposite"),
      clickableClass: "".concat(pfx, "-clickable"),
      lockClass: "".concat(pfx, "-lock"),
      horizontalClass: "".concat(pfx, "-horizontal"),
      verticalClass: "".concat(pfx, "-vertical"),
      paginationDisabledClass: "".concat(pfx, "-disabled")
    }
  });
  swiper.pagination = {
    el: null,
    bullets: []
  };
  let bulletSize;
  let dynamicBulletIndex = 0;
  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
  }
  function setSideBullets(bulletEl, position) {
    const {
      bulletActiveClass
    } = swiper.params.pagination;
    if (!bulletEl) return;
    bulletEl = bulletEl["".concat(position === "prev" ? "previous" : "next", "ElementSibling")];
    if (bulletEl) {
      bulletEl.classList.add("".concat(bulletActiveClass, "-").concat(position));
      bulletEl = bulletEl["".concat(position === "prev" ? "previous" : "next", "ElementSibling")];
      if (bulletEl) {
        bulletEl.classList.add("".concat(bulletActiveClass, "-").concat(position, "-").concat(position));
      }
    }
  }
  function getMoveDirection(prevIndex, nextIndex, length) {
    prevIndex = prevIndex % length;
    nextIndex = nextIndex % length;
    if (nextIndex === prevIndex + 1) {
      return "next";
    } else if (nextIndex === prevIndex - 1) {
      return "previous";
    }
    return;
  }
  function onBulletClick(e2) {
    const bulletEl = e2.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
    if (!bulletEl) {
      return;
    }
    e2.preventDefault();
    const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
    if (swiper.params.loop) {
      if (swiper.realIndex === index) return;
      const moveDirection = getMoveDirection(swiper.realIndex, index, swiper.slides.length);
      if (moveDirection === "next") {
        swiper.slideNext();
      } else if (moveDirection === "previous") {
        swiper.slidePrev();
      } else {
        swiper.slideToLoop(index);
      }
    } else {
      swiper.slideTo(index);
    }
  }
  function update8() {
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    let current2;
    let previousIndex;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      previousIndex = swiper.previousRealIndex || 0;
      current2 = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
    } else if (typeof swiper.snapIndex !== "undefined") {
      current2 = swiper.snapIndex;
      previousIndex = swiper.previousSnapIndex;
    } else {
      previousIndex = swiper.previousIndex || 0;
      current2 = swiper.activeIndex || 0;
    }
    if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? "width" : "height");
        el.forEach((subEl) => {
          subEl.style[swiper.isHorizontal() ? "width" : "height"] = "".concat(bulletSize * (params.dynamicMainBullets + 4), "px");
        });
        if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {
          dynamicBulletIndex += current2 - (previousIndex || 0);
          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }
        firstIndex = Math.max(current2 - dynamicBulletIndex, 0);
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.forEach((bulletEl) => {
        const classesToRemove = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((suffix) => "".concat(params.bulletActiveClass).concat(suffix))].map((s2) => typeof s2 === "string" && s2.includes(" ") ? s2.split(" ") : s2).flat();
        bulletEl.classList.remove(...classesToRemove);
      });
      if (el.length > 1) {
        bullets.forEach((bullet) => {
          const bulletIndex = elementIndex(bullet);
          if (bulletIndex === current2) {
            bullet.classList.add(...params.bulletActiveClass.split(" "));
          } else if (swiper.isElement) {
            bullet.setAttribute("part", "bullet");
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              bullet.classList.add(..."".concat(params.bulletActiveClass, "-main").split(" "));
            }
            if (bulletIndex === firstIndex) {
              setSideBullets(bullet, "prev");
            }
            if (bulletIndex === lastIndex) {
              setSideBullets(bullet, "next");
            }
          }
        });
      } else {
        const bullet = bullets[current2];
        if (bullet) {
          bullet.classList.add(...params.bulletActiveClass.split(" "));
        }
        if (swiper.isElement) {
          bullets.forEach((bulletEl, bulletIndex) => {
            bulletEl.setAttribute("part", bulletIndex === current2 ? "bullet-active" : "bullet");
          });
        }
        if (params.dynamicBullets) {
          const firstDisplayedBullet = bullets[firstIndex];
          const lastDisplayedBullet = bullets[lastIndex];
          for (let i2 = firstIndex; i2 <= lastIndex; i2 += 1) {
            if (bullets[i2]) {
              bullets[i2].classList.add(..."".concat(params.bulletActiveClass, "-main").split(" "));
            }
          }
          setSideBullets(firstDisplayedBullet, "prev");
          setSideBullets(lastDisplayedBullet, "next");
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? "right" : "left";
        bullets.forEach((bullet) => {
          bullet.style[swiper.isHorizontal() ? offsetProp : "top"] = "".concat(bulletsOffset, "px");
        });
      }
    }
    el.forEach((subEl, subElIndex) => {
      if (params.type === "fraction") {
        subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl) => {
          fractionEl.textContent = params.formatFractionCurrent(current2 + 1);
        });
        subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl) => {
          totalEl.textContent = params.formatFractionTotal(total);
        });
      }
      if (params.type === "progressbar") {
        let progressbarDirection;
        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal";
        } else {
          progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
        }
        const scale2 = (current2 + 1) / total;
        let scaleX2 = 1;
        let scaleY2 = 1;
        if (progressbarDirection === "horizontal") {
          scaleX2 = scale2;
        } else {
          scaleY2 = scale2;
        }
        subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl) => {
          progressEl.style.transform = "translate3d(0,0,0) scaleX(".concat(scaleX2, ") scaleY(").concat(scaleY2, ")");
          progressEl.style.transitionDuration = "".concat(swiper.params.speed, "ms");
        });
      }
      if (params.type === "custom" && params.renderCustom) {
        setInnerHTML(subEl, params.renderCustom(swiper, current2 + 1, total));
        if (subElIndex === 0) emit("paginationRender", subEl);
      } else {
        if (subElIndex === 0) emit("paginationRender", subEl);
        emit("paginationUpdate", subEl);
      }
      if (swiper.params.watchOverflow && swiper.enabled) {
        subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
      }
    });
  }
  function render3() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    let paginationHTML = "";
    if (params.type === "bullets") {
      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }
      for (let i2 = 0; i2 < numberOfBullets; i2 += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i2, params.bulletClass);
        } else {
          paginationHTML += "<".concat(params.bulletElement, " ").concat(swiper.isElement ? 'part="bullet"' : "", ' class="').concat(params.bulletClass, '"></').concat(params.bulletElement, ">");
        }
      }
    }
    if (params.type === "fraction") {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = '<span class="'.concat(params.currentClass, '"></span>') + " / " + '<span class="'.concat(params.totalClass, '"></span>');
      }
    }
    if (params.type === "progressbar") {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = '<span class="'.concat(params.progressbarFillClass, '"></span>');
      }
    }
    swiper.pagination.bullets = [];
    el.forEach((subEl) => {
      if (params.type !== "custom") {
        setInnerHTML(subEl, paginationHTML || "");
      }
      if (params.type === "bullets") {
        swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
      }
    });
    if (params.type !== "custom") {
      emit("paginationRender", el[0]);
    }
  }
  function init2() {
    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: "swiper-pagination"
    });
    const params = swiper.params.pagination;
    if (!params.el) return;
    let el;
    if (typeof params.el === "string" && swiper.isElement) {
      el = swiper.el.querySelector(params.el);
    }
    if (!el && typeof params.el === "string") {
      el = [...document.querySelectorAll(params.el)];
    }
    if (!el) {
      el = params.el;
    }
    if (!el || el.length === 0) return;
    if (swiper.params.uniqueNavElements && typeof params.el === "string" && Array.isArray(el) && el.length > 1) {
      el = [...swiper.el.querySelectorAll(params.el)];
      if (el.length > 1) {
        el = el.find((subEl) => {
          if (elementParents(subEl, ".swiper")[0] !== swiper.el) return false;
          return true;
        });
      }
    }
    if (Array.isArray(el) && el.length === 1) el = el[0];
    Object.assign(swiper.pagination, {
      el
    });
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      if (params.type === "bullets" && params.clickable) {
        subEl.classList.add(...(params.clickableClass || "").split(" "));
      }
      subEl.classList.add(params.modifierClass + params.type);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (params.type === "bullets" && params.dynamicBullets) {
        subEl.classList.add("".concat(params.modifierClass).concat(params.type, "-dynamic"));
        dynamicBulletIndex = 0;
        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }
      if (params.type === "progressbar" && params.progressbarOpposite) {
        subEl.classList.add(params.progressbarOppositeClass);
      }
      if (params.clickable) {
        subEl.addEventListener("click", onBulletClick);
      }
      if (!swiper.enabled) {
        subEl.classList.add(params.lockClass);
      }
    });
  }
  function destroy2() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    if (el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.classList.remove(params.hiddenClass);
        subEl.classList.remove(params.modifierClass + params.type);
        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (params.clickable) {
          subEl.classList.remove(...(params.clickableClass || "").split(" "));
          subEl.removeEventListener("click", onBulletClick);
        }
      });
    }
    if (swiper.pagination.bullets) swiper.pagination.bullets.forEach((subEl) => subEl.classList.remove(...params.bulletActiveClass.split(" ")));
  }
  on("changeDirection", () => {
    if (!swiper.pagination || !swiper.pagination.el) return;
    const params = swiper.params.pagination;
    let {
      el
    } = swiper.pagination;
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on("init", () => {
    if (swiper.params.pagination.enabled === false) {
      disable2();
    } else {
      init2();
      render3();
      update8();
    }
  });
  on("activeIndexChange", () => {
    if (typeof swiper.snapIndex === "undefined") {
      update8();
    }
  });
  on("snapIndexChange", () => {
    update8();
  });
  on("snapGridLengthChange", () => {
    render3();
    update8();
  });
  on("destroy", () => {
    destroy2();
  });
  on("enable disable", () => {
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => subEl.classList[swiper.enabled ? "remove" : "add"](swiper.params.pagination.lockClass));
    }
  });
  on("lock unlock", () => {
    update8();
  });
  on("click", (_s, e2) => {
    const targetEl = e2.target;
    const el = makeElementsArray(swiper.pagination.el);
    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
      if (isHidden === true) {
        emit("paginationShow");
      } else {
        emit("paginationHide");
      }
      el.forEach((subEl) => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
    }
  });
  const enable2 = () => {
    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
    }
    init2();
    render3();
    update8();
  };
  const disable2 = () => {
    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
    }
    destroy2();
  };
  Object.assign(swiper.pagination, {
    enable: enable2,
    disable: disable2,
    render: render3,
    update: update8,
    init: init2,
    destroy: destroy2
  });
}
function Scrollbar({
  swiper,
  extendParams,
  on,
  emit
}) {
  const document2 = getDocument();
  let isTouched = false;
  let timeout = null;
  let dragTimeout = null;
  let dragStartPos;
  let dragSize;
  let trackSize;
  let divider;
  extendParams({
    scrollbar: {
      el: null,
      dragSize: "auto",
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: "swiper-scrollbar-lock",
      dragClass: "swiper-scrollbar-drag",
      scrollbarDisabledClass: "swiper-scrollbar-disabled",
      horizontalClass: "swiper-scrollbar-horizontal",
      verticalClass: "swiper-scrollbar-vertical"
    }
  });
  swiper.scrollbar = {
    el: null,
    dragEl: null
  };
  function setTranslate2() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      dragEl,
      el
    } = scrollbar;
    const params = swiper.params.scrollbar;
    const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      dragEl.style.transform = "translate3d(".concat(newPos, "px, 0, 0)");
      dragEl.style.width = "".concat(newSize, "px");
    } else {
      dragEl.style.transform = "translate3d(0px, ".concat(newPos, "px, 0)");
      dragEl.style.height = "".concat(newSize, "px");
    }
    if (params.hide) {
      clearTimeout(timeout);
      el.style.opacity = 1;
      timeout = setTimeout(() => {
        el.style.opacity = 0;
        el.style.transitionDuration = "400ms";
      }, 1e3);
    }
  }
  function setTransition2(duration) {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.dragEl.style.transitionDuration = "".concat(duration, "ms");
  }
  function updateSize2() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar
    } = swiper;
    const {
      dragEl,
      el
    } = scrollbar;
    dragEl.style.width = "";
    dragEl.style.height = "";
    trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
    if (swiper.params.scrollbar.dragSize === "auto") {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }
    if (swiper.isHorizontal()) {
      dragEl.style.width = "".concat(dragSize, "px");
    } else {
      dragEl.style.height = "".concat(dragSize, "px");
    }
    if (divider >= 1) {
      el.style.display = "none";
    } else {
      el.style.display = "";
    }
    if (swiper.params.scrollbar.hide) {
      el.style.opacity = 0;
    }
    if (swiper.params.watchOverflow && swiper.enabled) {
      scrollbar.el.classList[swiper.isLocked ? "add" : "remove"](swiper.params.scrollbar.lockClass);
    }
  }
  function getPointerPosition(e2) {
    return swiper.isHorizontal() ? e2.clientX : e2.clientY;
  }
  function setDragPosition(e2) {
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      el
    } = scrollbar;
    let positionRatio;
    positionRatio = (getPointerPosition(e2) - elementOffset(el)[swiper.isHorizontal() ? "left" : "top"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }
    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  function onDragStart(e2) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el,
      dragEl
    } = scrollbar;
    isTouched = true;
    dragStartPos = e2.target === dragEl ? getPointerPosition(e2) - e2.target.getBoundingClientRect()[swiper.isHorizontal() ? "left" : "top"] : null;
    e2.preventDefault();
    e2.stopPropagation();
    wrapperEl.style.transitionDuration = "100ms";
    dragEl.style.transitionDuration = "100ms";
    setDragPosition(e2);
    clearTimeout(dragTimeout);
    el.style.transitionDuration = "0ms";
    if (params.hide) {
      el.style.opacity = 1;
    }
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style["scroll-snap-type"] = "none";
    }
    emit("scrollbarDragStart", e2);
  }
  function onDragMove(e2) {
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el,
      dragEl
    } = scrollbar;
    if (!isTouched) return;
    if (e2.preventDefault && e2.cancelable) e2.preventDefault();
    else e2.returnValue = false;
    setDragPosition(e2);
    wrapperEl.style.transitionDuration = "0ms";
    el.style.transitionDuration = "0ms";
    dragEl.style.transitionDuration = "0ms";
    emit("scrollbarDragMove", e2);
  }
  function onDragEnd(e2) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el
    } = scrollbar;
    if (!isTouched) return;
    isTouched = false;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style["scroll-snap-type"] = "";
      wrapperEl.style.transitionDuration = "";
    }
    if (params.hide) {
      clearTimeout(dragTimeout);
      dragTimeout = nextTick(() => {
        el.style.opacity = 0;
        el.style.transitionDuration = "400ms";
      }, 1e3);
    }
    emit("scrollbarDragEnd", e2);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  }
  function events2(method) {
    const {
      scrollbar,
      params
    } = swiper;
    const el = scrollbar.el;
    if (!el) return;
    const target = el;
    const activeListener = params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    const passiveListener = params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target) return;
    const eventMethod = method === "on" ? "addEventListener" : "removeEventListener";
    target[eventMethod]("pointerdown", onDragStart, activeListener);
    document2[eventMethod]("pointermove", onDragMove, activeListener);
    document2[eventMethod]("pointerup", onDragEnd, passiveListener);
  }
  function enableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    events2("on");
  }
  function disableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    events2("off");
  }
  function init2() {
    const {
      scrollbar,
      el: swiperEl
    } = swiper;
    swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
      el: "swiper-scrollbar"
    });
    const params = swiper.params.scrollbar;
    if (!params.el) return;
    let el;
    if (typeof params.el === "string" && swiper.isElement) {
      el = swiper.el.querySelector(params.el);
    }
    if (!el && typeof params.el === "string") {
      el = document2.querySelectorAll(params.el);
      if (!el.length) return;
    } else if (!el) {
      el = params.el;
    }
    if (swiper.params.uniqueNavElements && typeof params.el === "string" && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
      el = swiperEl.querySelector(params.el);
    }
    if (el.length > 0) el = el[0];
    el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    let dragEl;
    if (el) {
      dragEl = el.querySelector(classesToSelector(swiper.params.scrollbar.dragClass));
      if (!dragEl) {
        dragEl = createElement("div", swiper.params.scrollbar.dragClass);
        el.append(dragEl);
      }
    }
    Object.assign(scrollbar, {
      el,
      dragEl
    });
    if (params.draggable) {
      enableDraggable();
    }
    if (el) {
      el.classList[swiper.enabled ? "remove" : "add"](...classesToTokens(swiper.params.scrollbar.lockClass));
    }
  }
  function destroy2() {
    const params = swiper.params.scrollbar;
    const el = swiper.scrollbar.el;
    if (el) {
      el.classList.remove(...classesToTokens(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));
    }
    disableDraggable();
  }
  on("changeDirection", () => {
    if (!swiper.scrollbar || !swiper.scrollbar.el) return;
    const params = swiper.params.scrollbar;
    let {
      el
    } = swiper.scrollbar;
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on("init", () => {
    if (swiper.params.scrollbar.enabled === false) {
      disable2();
    } else {
      init2();
      updateSize2();
      setTranslate2();
    }
  });
  on("update resize observerUpdate lock unlock changeDirection", () => {
    updateSize2();
  });
  on("setTranslate", () => {
    setTranslate2();
  });
  on("setTransition", (_s, duration) => {
    setTransition2(duration);
  });
  on("enable disable", () => {
    const {
      el
    } = swiper.scrollbar;
    if (el) {
      el.classList[swiper.enabled ? "remove" : "add"](...classesToTokens(swiper.params.scrollbar.lockClass));
    }
  });
  on("destroy", () => {
    destroy2();
  });
  const enable2 = () => {
    swiper.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
    if (swiper.scrollbar.el) {
      swiper.scrollbar.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
    }
    init2();
    updateSize2();
    setTranslate2();
  };
  const disable2 = () => {
    swiper.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
    if (swiper.scrollbar.el) {
      swiper.scrollbar.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
    }
    destroy2();
  };
  Object.assign(swiper.scrollbar, {
    enable: enable2,
    disable: disable2,
    updateSize: updateSize2,
    setTranslate: setTranslate2,
    init: init2,
    destroy: destroy2
  });
}
function Parallax({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    parallax: {
      enabled: false
    }
  });
  const elementsSelector = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]";
  const setTransform = (el, progress) => {
    const {
      rtl
    } = swiper;
    const rtlFactor = rtl ? -1 : 1;
    const p2 = el.getAttribute("data-swiper-parallax") || "0";
    let x2 = el.getAttribute("data-swiper-parallax-x");
    let y2 = el.getAttribute("data-swiper-parallax-y");
    const scale2 = el.getAttribute("data-swiper-parallax-scale");
    const opacity = el.getAttribute("data-swiper-parallax-opacity");
    const rotate2 = el.getAttribute("data-swiper-parallax-rotate");
    if (x2 || y2) {
      x2 = x2 || "0";
      y2 = y2 || "0";
    } else if (swiper.isHorizontal()) {
      x2 = p2;
      y2 = "0";
    } else {
      y2 = p2;
      x2 = "0";
    }
    if (x2.indexOf("%") >= 0) {
      x2 = "".concat(parseInt(x2, 10) * progress * rtlFactor, "%");
    } else {
      x2 = "".concat(x2 * progress * rtlFactor, "px");
    }
    if (y2.indexOf("%") >= 0) {
      y2 = "".concat(parseInt(y2, 10) * progress, "%");
    } else {
      y2 = "".concat(y2 * progress, "px");
    }
    if (typeof opacity !== "undefined" && opacity !== null) {
      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
      el.style.opacity = currentOpacity;
    }
    let transform = "translate3d(".concat(x2, ", ").concat(y2, ", 0px)");
    if (typeof scale2 !== "undefined" && scale2 !== null) {
      const currentScale = scale2 - (scale2 - 1) * (1 - Math.abs(progress));
      transform += " scale(".concat(currentScale, ")");
    }
    if (rotate2 && typeof rotate2 !== "undefined" && rotate2 !== null) {
      const currentRotate = rotate2 * progress * -1;
      transform += " rotate(".concat(currentRotate, "deg)");
    }
    el.style.transform = transform;
  };
  const setTranslate2 = () => {
    const {
      el,
      slides,
      progress,
      snapGrid,
      isElement
    } = swiper;
    const elements = elementChildren(el, elementsSelector);
    if (swiper.isElement) {
      elements.push(...elementChildren(swiper.hostEl, elementsSelector));
    }
    elements.forEach((subEl) => {
      setTransform(subEl, progress);
    });
    slides.forEach((slideEl, slideIndex) => {
      let slideProgress = slideEl.progress;
      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== "auto") {
        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
      }
      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      slideEl.querySelectorAll("".concat(elementsSelector, ", [data-swiper-parallax-rotate]")).forEach((subEl) => {
        setTransform(subEl, slideProgress);
      });
    });
  };
  const setTransition2 = (duration = swiper.params.speed) => {
    const {
      el,
      hostEl
    } = swiper;
    const elements = [...el.querySelectorAll(elementsSelector)];
    if (swiper.isElement) {
      elements.push(...hostEl.querySelectorAll(elementsSelector));
    }
    elements.forEach((parallaxEl) => {
      let parallaxDuration = parseInt(parallaxEl.getAttribute("data-swiper-parallax-duration"), 10) || duration;
      if (duration === 0) parallaxDuration = 0;
      parallaxEl.style.transitionDuration = "".concat(parallaxDuration, "ms");
    });
  };
  on("beforeInit", () => {
    if (!swiper.params.parallax.enabled) return;
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
  });
  on("init", () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate2();
  });
  on("setTranslate", () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate2();
  });
  on("setTransition", (_swiper, duration) => {
    if (!swiper.params.parallax.enabled) return;
    setTransition2(duration);
  });
}
function Zoom({
  swiper,
  extendParams,
  on,
  emit
}) {
  const window2 = getWindow$1();
  extendParams({
    zoom: {
      enabled: false,
      limitToOriginalSize: false,
      maxRatio: 3,
      minRatio: 1,
      panOnMouseMove: false,
      toggle: true,
      containerClass: "swiper-zoom-container",
      zoomedSlideClass: "swiper-slide-zoomed"
    }
  });
  swiper.zoom = {
    enabled: false
  };
  let currentScale = 1;
  let isScaling = false;
  let isPanningWithMouse = false;
  let mousePanStart = {
    x: 0,
    y: 0
  };
  const mousePanSensitivity = -3;
  let fakeGestureTouched;
  let fakeGestureMoved;
  const evCache = [];
  const gesture = {
    originX: 0,
    originY: 0,
    slideEl: void 0,
    slideWidth: void 0,
    slideHeight: void 0,
    imageEl: void 0,
    imageWrapEl: void 0,
    maxRatio: 3
  };
  const image = {
    isTouched: void 0,
    isMoved: void 0,
    currentX: void 0,
    currentY: void 0,
    minX: void 0,
    minY: void 0,
    maxX: void 0,
    maxY: void 0,
    width: void 0,
    height: void 0,
    startX: void 0,
    startY: void 0,
    touchesStart: {},
    touchesCurrent: {}
  };
  const velocity = {
    x: void 0,
    y: void 0,
    prevPositionX: void 0,
    prevPositionY: void 0,
    prevTime: void 0
  };
  let scale2 = 1;
  Object.defineProperty(swiper.zoom, "scale", {
    get() {
      return scale2;
    },
    set(value) {
      if (scale2 !== value) {
        const imageEl = gesture.imageEl;
        const slideEl = gesture.slideEl;
        emit("zoomChange", value, imageEl, slideEl);
      }
      scale2 = value;
    }
  });
  function getDistanceBetweenTouches() {
    if (evCache.length < 2) return 1;
    const x1 = evCache[0].pageX;
    const y1 = evCache[0].pageY;
    const x2 = evCache[1].pageX;
    const y2 = evCache[1].pageY;
    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    return distance;
  }
  function getMaxRatio() {
    const params = swiper.params.zoom;
    const maxRatio = gesture.imageWrapEl.getAttribute("data-swiper-zoom") || params.maxRatio;
    if (params.limitToOriginalSize && gesture.imageEl && gesture.imageEl.naturalWidth) {
      const imageMaxRatio = gesture.imageEl.naturalWidth / gesture.imageEl.offsetWidth;
      return Math.min(imageMaxRatio, maxRatio);
    }
    return maxRatio;
  }
  function getScaleOrigin() {
    if (evCache.length < 2) return {
      x: null,
      y: null
    };
    const box = gesture.imageEl.getBoundingClientRect();
    return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window2.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window2.scrollY) / currentScale];
  }
  function getSlideSelector() {
    return swiper.isElement ? "swiper-slide" : ".".concat(swiper.params.slideClass);
  }
  function eventWithinSlide(e2) {
    const slideSelector = getSlideSelector();
    if (e2.target.matches(slideSelector)) return true;
    if (swiper.slides.filter((slideEl) => slideEl.contains(e2.target)).length > 0) return true;
    return false;
  }
  function eventWithinZoomContainer(e2) {
    const selector = ".".concat(swiper.params.zoom.containerClass);
    if (e2.target.matches(selector)) return true;
    if ([...swiper.hostEl.querySelectorAll(selector)].filter((containerEl) => containerEl.contains(e2.target)).length > 0) return true;
    return false;
  }
  function onGestureStart(e2) {
    if (e2.pointerType === "mouse") {
      evCache.splice(0, evCache.length);
    }
    if (!eventWithinSlide(e2)) return;
    const params = swiper.params.zoom;
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    evCache.push(e2);
    if (evCache.length < 2) {
      return;
    }
    fakeGestureTouched = true;
    gesture.scaleStart = getDistanceBetweenTouches();
    if (!gesture.slideEl) {
      gesture.slideEl = e2.target.closest(".".concat(swiper.params.slideClass, ", swiper-slide"));
      if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];
      let imageEl = gesture.slideEl.querySelector(".".concat(params.containerClass));
      if (imageEl) {
        imageEl = imageEl.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = elementParents(gesture.imageEl, ".".concat(params.containerClass))[0];
      } else {
        gesture.imageWrapEl = void 0;
      }
      if (!gesture.imageWrapEl) {
        gesture.imageEl = void 0;
        return;
      }
      gesture.maxRatio = getMaxRatio();
    }
    if (gesture.imageEl) {
      const [originX, originY] = getScaleOrigin();
      gesture.originX = originX;
      gesture.originY = originY;
      gesture.imageEl.style.transitionDuration = "0ms";
    }
    isScaling = true;
  }
  function onGestureChange(e2) {
    if (!eventWithinSlide(e2)) return;
    const params = swiper.params.zoom;
    const zoom2 = swiper.zoom;
    const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e2.pointerId);
    if (pointerIndex >= 0) evCache[pointerIndex] = e2;
    if (evCache.length < 2) {
      return;
    }
    fakeGestureMoved = true;
    gesture.scaleMove = getDistanceBetweenTouches();
    if (!gesture.imageEl) {
      return;
    }
    zoom2.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
    if (zoom2.scale > gesture.maxRatio) {
      zoom2.scale = gesture.maxRatio - 1 + (zoom2.scale - gesture.maxRatio + 1) ** 0.5;
    }
    if (zoom2.scale < params.minRatio) {
      zoom2.scale = params.minRatio + 1 - (params.minRatio - zoom2.scale + 1) ** 0.5;
    }
    gesture.imageEl.style.transform = "translate3d(0,0,0) scale(".concat(zoom2.scale, ")");
  }
  function onGestureEnd(e2) {
    if (!eventWithinSlide(e2)) return;
    if (e2.pointerType === "mouse" && e2.type === "pointerout") return;
    const params = swiper.params.zoom;
    const zoom2 = swiper.zoom;
    const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e2.pointerId);
    if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);
    if (!fakeGestureTouched || !fakeGestureMoved) {
      return;
    }
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    if (!gesture.imageEl) return;
    zoom2.scale = Math.max(Math.min(zoom2.scale, gesture.maxRatio), params.minRatio);
    gesture.imageEl.style.transitionDuration = "".concat(swiper.params.speed, "ms");
    gesture.imageEl.style.transform = "translate3d(0,0,0) scale(".concat(zoom2.scale, ")");
    currentScale = zoom2.scale;
    isScaling = false;
    if (zoom2.scale > 1 && gesture.slideEl) {
      gesture.slideEl.classList.add("".concat(params.zoomedSlideClass));
    } else if (zoom2.scale <= 1 && gesture.slideEl) {
      gesture.slideEl.classList.remove("".concat(params.zoomedSlideClass));
    }
    if (zoom2.scale === 1) {
      gesture.originX = 0;
      gesture.originY = 0;
      gesture.slideEl = void 0;
    }
  }
  let allowTouchMoveTimeout;
  function allowTouchMove() {
    swiper.touchEventsData.preventTouchMoveFromPointerMove = false;
  }
  function preventTouchMove() {
    clearTimeout(allowTouchMoveTimeout);
    swiper.touchEventsData.preventTouchMoveFromPointerMove = true;
    allowTouchMoveTimeout = setTimeout(() => {
      if (swiper.destroyed) return;
      allowTouchMove();
    });
  }
  function onTouchStart2(e2) {
    const device = swiper.device;
    if (!gesture.imageEl) return;
    if (image.isTouched) return;
    if (device.android && e2.cancelable) e2.preventDefault();
    image.isTouched = true;
    const event2 = evCache.length > 0 ? evCache[0] : e2;
    image.touchesStart.x = event2.pageX;
    image.touchesStart.y = event2.pageY;
  }
  function onTouchMove2(e2) {
    const isMouseEvent = e2.pointerType === "mouse";
    const isMousePan = isMouseEvent && swiper.params.zoom.panOnMouseMove;
    if (!eventWithinSlide(e2) || !eventWithinZoomContainer(e2)) {
      return;
    }
    const zoom2 = swiper.zoom;
    if (!gesture.imageEl) {
      return;
    }
    if (!image.isTouched || !gesture.slideEl) {
      if (isMousePan) onMouseMove(e2);
      return;
    }
    if (isMousePan) {
      onMouseMove(e2);
      return;
    }
    if (!image.isMoved) {
      image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
      image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
      image.startX = getTranslate(gesture.imageWrapEl, "x") || 0;
      image.startY = getTranslate(gesture.imageWrapEl, "y") || 0;
      gesture.slideWidth = gesture.slideEl.offsetWidth;
      gesture.slideHeight = gesture.slideEl.offsetHeight;
      gesture.imageWrapEl.style.transitionDuration = "0ms";
    }
    const scaledWidth = image.width * zoom2.scale;
    const scaledHeight = image.height * zoom2.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e2.pageX;
    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e2.pageY;
    const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));
    if (touchesDiff > 5) {
      swiper.allowClick = false;
    }
    if (!image.isMoved && !isScaling) {
      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
        image.isTouched = false;
        allowTouchMove();
        return;
      }
      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
        image.isTouched = false;
        allowTouchMove();
        return;
      }
    }
    if (e2.cancelable) {
      e2.preventDefault();
    }
    e2.stopPropagation();
    preventTouchMove();
    image.isMoved = true;
    const scaleRatio = (zoom2.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);
    const {
      originX,
      originY
    } = gesture;
    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);
    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);
    if (image.currentX < image.minX) {
      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
    }
    if (image.currentX > image.maxX) {
      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
    }
    if (image.currentY < image.minY) {
      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
    }
    if (image.currentY > image.maxY) {
      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
    }
    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();
    gesture.imageWrapEl.style.transform = "translate3d(".concat(image.currentX, "px, ").concat(image.currentY, "px,0)");
  }
  function onTouchEnd2() {
    const zoom2 = swiper.zoom;
    evCache.length = 0;
    if (!gesture.imageEl) return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;
    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    image.currentX = newPositionX;
    image.currentY = newPositionY;
    const scaledWidth = image.width * zoom2.scale;
    const scaledHeight = image.height * zoom2.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    gesture.imageWrapEl.style.transitionDuration = "".concat(momentumDuration, "ms");
    gesture.imageWrapEl.style.transform = "translate3d(".concat(image.currentX, "px, ").concat(image.currentY, "px,0)");
  }
  function onTransitionEnd() {
    const zoom2 = swiper.zoom;
    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {
      if (gesture.imageEl) {
        gesture.imageEl.style.transform = "translate3d(0,0,0) scale(1)";
      }
      if (gesture.imageWrapEl) {
        gesture.imageWrapEl.style.transform = "translate3d(0,0,0)";
      }
      gesture.slideEl.classList.remove("".concat(swiper.params.zoom.zoomedSlideClass));
      zoom2.scale = 1;
      currentScale = 1;
      gesture.slideEl = void 0;
      gesture.imageEl = void 0;
      gesture.imageWrapEl = void 0;
      gesture.originX = 0;
      gesture.originY = 0;
    }
  }
  function onMouseMove(e2) {
    if (currentScale <= 1 || !gesture.imageWrapEl) return;
    if (!eventWithinSlide(e2) || !eventWithinZoomContainer(e2)) return;
    const currentTransform = window2.getComputedStyle(gesture.imageWrapEl).transform;
    const matrix = new window2.DOMMatrix(currentTransform);
    if (!isPanningWithMouse) {
      isPanningWithMouse = true;
      mousePanStart.x = e2.clientX;
      mousePanStart.y = e2.clientY;
      image.startX = matrix.e;
      image.startY = matrix.f;
      image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
      image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
      gesture.slideWidth = gesture.slideEl.offsetWidth;
      gesture.slideHeight = gesture.slideEl.offsetHeight;
      return;
    }
    const deltaX = (e2.clientX - mousePanStart.x) * mousePanSensitivity;
    const deltaY = (e2.clientY - mousePanStart.y) * mousePanSensitivity;
    const scaledWidth = image.width * currentScale;
    const scaledHeight = image.height * currentScale;
    const slideWidth = gesture.slideWidth;
    const slideHeight = gesture.slideHeight;
    const minX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
    const maxX = -minX;
    const minY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
    const maxY = -minY;
    const newX = Math.max(Math.min(image.startX + deltaX, maxX), minX);
    const newY = Math.max(Math.min(image.startY + deltaY, maxY), minY);
    gesture.imageWrapEl.style.transitionDuration = "0ms";
    gesture.imageWrapEl.style.transform = "translate3d(".concat(newX, "px, ").concat(newY, "px, 0)");
    mousePanStart.x = e2.clientX;
    mousePanStart.y = e2.clientY;
    image.startX = newX;
    image.startY = newY;
    image.currentX = newX;
    image.currentY = newY;
  }
  function zoomIn(e2) {
    const zoom2 = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.slideEl) {
      if (e2 && e2.target) {
        gesture.slideEl = e2.target.closest(".".concat(swiper.params.slideClass, ", swiper-slide"));
      }
      if (!gesture.slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.slideEl = elementChildren(swiper.slidesEl, ".".concat(swiper.params.slideActiveClass))[0];
        } else {
          gesture.slideEl = swiper.slides[swiper.activeIndex];
        }
      }
      let imageEl = gesture.slideEl.querySelector(".".concat(params.containerClass));
      if (imageEl) {
        imageEl = imageEl.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = elementParents(gesture.imageEl, ".".concat(params.containerClass))[0];
      } else {
        gesture.imageWrapEl = void 0;
      }
    }
    if (!gesture.imageEl || !gesture.imageWrapEl) return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = "hidden";
      swiper.wrapperEl.style.touchAction = "none";
    }
    gesture.slideEl.classList.add("".concat(params.zoomedSlideClass));
    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;
    if (typeof image.touchesStart.x === "undefined" && e2) {
      touchX = e2.pageX;
      touchY = e2.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }
    const prevScale = currentScale;
    const forceZoomRatio = typeof e2 === "number" ? e2 : null;
    if (currentScale === 1 && forceZoomRatio) {
      touchX = void 0;
      touchY = void 0;
      image.touchesStart.x = void 0;
      image.touchesStart.y = void 0;
    }
    const maxRatio = getMaxRatio();
    zoom2.scale = forceZoomRatio || maxRatio;
    currentScale = forceZoomRatio || maxRatio;
    if (e2 && !(currentScale === 1 && forceZoomRatio)) {
      slideWidth = gesture.slideEl.offsetWidth;
      slideHeight = gesture.slideEl.offsetHeight;
      offsetX = elementOffset(gesture.slideEl).left + window2.scrollX;
      offsetY = elementOffset(gesture.slideEl).top + window2.scrollY;
      diffX = offsetX + slideWidth / 2 - touchX;
      diffY = offsetY + slideHeight / 2 - touchY;
      imageWidth = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
      imageHeight = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
      scaledWidth = imageWidth * zoom2.scale;
      scaledHeight = imageHeight * zoom2.scale;
      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;
      if (prevScale > 0 && forceZoomRatio && typeof image.currentX === "number" && typeof image.currentY === "number") {
        translateX = image.currentX * zoom2.scale / prevScale;
        translateY = image.currentY * zoom2.scale / prevScale;
      } else {
        translateX = diffX * zoom2.scale;
        translateY = diffY * zoom2.scale;
      }
      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }
      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    if (forceZoomRatio && zoom2.scale === 1) {
      gesture.originX = 0;
      gesture.originY = 0;
    }
    image.currentX = translateX;
    image.currentY = translateY;
    gesture.imageWrapEl.style.transitionDuration = "300ms";
    gesture.imageWrapEl.style.transform = "translate3d(".concat(translateX, "px, ").concat(translateY, "px,0)");
    gesture.imageEl.style.transitionDuration = "300ms";
    gesture.imageEl.style.transform = "translate3d(0,0,0) scale(".concat(zoom2.scale, ")");
  }
  function zoomOut() {
    const zoom2 = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.slideEl = elementChildren(swiper.slidesEl, ".".concat(swiper.params.slideActiveClass))[0];
      } else {
        gesture.slideEl = swiper.slides[swiper.activeIndex];
      }
      let imageEl = gesture.slideEl.querySelector(".".concat(params.containerClass));
      if (imageEl) {
        imageEl = imageEl.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = elementParents(gesture.imageEl, ".".concat(params.containerClass))[0];
      } else {
        gesture.imageWrapEl = void 0;
      }
    }
    if (!gesture.imageEl || !gesture.imageWrapEl) return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = "";
      swiper.wrapperEl.style.touchAction = "";
    }
    zoom2.scale = 1;
    currentScale = 1;
    image.currentX = void 0;
    image.currentY = void 0;
    image.touchesStart.x = void 0;
    image.touchesStart.y = void 0;
    gesture.imageWrapEl.style.transitionDuration = "300ms";
    gesture.imageWrapEl.style.transform = "translate3d(0,0,0)";
    gesture.imageEl.style.transitionDuration = "300ms";
    gesture.imageEl.style.transform = "translate3d(0,0,0) scale(1)";
    gesture.slideEl.classList.remove("".concat(params.zoomedSlideClass));
    gesture.slideEl = void 0;
    gesture.originX = 0;
    gesture.originY = 0;
    if (swiper.params.zoom.panOnMouseMove) {
      mousePanStart = {
        x: 0,
        y: 0
      };
      if (isPanningWithMouse) {
        isPanningWithMouse = false;
        image.startX = 0;
        image.startY = 0;
      }
    }
  }
  function zoomToggle(e2) {
    const zoom2 = swiper.zoom;
    if (zoom2.scale && zoom2.scale !== 1) {
      zoomOut();
    } else {
      zoomIn(e2);
    }
  }
  function getListeners() {
    const passiveListener = swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    const activeListenerWithCapture = swiper.params.passiveListeners ? {
      passive: false,
      capture: true
    } : true;
    return {
      passiveListener,
      activeListenerWithCapture
    };
  }
  function enable2() {
    const zoom2 = swiper.zoom;
    if (zoom2.enabled) return;
    zoom2.enabled = true;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();
    swiper.wrapperEl.addEventListener("pointerdown", onGestureStart, passiveListener);
    swiper.wrapperEl.addEventListener("pointermove", onGestureChange, activeListenerWithCapture);
    ["pointerup", "pointercancel", "pointerout"].forEach((eventName) => {
      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);
    });
    swiper.wrapperEl.addEventListener("pointermove", onTouchMove2, activeListenerWithCapture);
  }
  function disable2() {
    const zoom2 = swiper.zoom;
    if (!zoom2.enabled) return;
    zoom2.enabled = false;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();
    swiper.wrapperEl.removeEventListener("pointerdown", onGestureStart, passiveListener);
    swiper.wrapperEl.removeEventListener("pointermove", onGestureChange, activeListenerWithCapture);
    ["pointerup", "pointercancel", "pointerout"].forEach((eventName) => {
      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);
    });
    swiper.wrapperEl.removeEventListener("pointermove", onTouchMove2, activeListenerWithCapture);
  }
  on("init", () => {
    if (swiper.params.zoom.enabled) {
      enable2();
    }
  });
  on("destroy", () => {
    disable2();
  });
  on("touchStart", (_s, e2) => {
    if (!swiper.zoom.enabled) return;
    onTouchStart2(e2);
  });
  on("touchEnd", (_s, e2) => {
    if (!swiper.zoom.enabled) return;
    onTouchEnd2();
  });
  on("doubleTap", (_s, e2) => {
    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
      zoomToggle(e2);
    }
  });
  on("transitionEnd", () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
      onTransitionEnd();
    }
  });
  on("slideChange", () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
      onTransitionEnd();
    }
  });
  Object.assign(swiper.zoom, {
    enable: enable2,
    disable: disable2,
    in: zoomIn,
    out: zoomOut,
    toggle: zoomToggle
  });
}
function Controller({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    controller: {
      control: void 0,
      inverse: false,
      by: "slide"
      // or 'container'
    }
  });
  swiper.controller = {
    control: void 0
  };
  function LinearSpline(x2, y2) {
    const binarySearch = /* @__PURE__ */ (function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array2, val) => {
        minIndex = -1;
        maxIndex = array2.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array2[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    })();
    this.x = x2;
    this.y = y2;
    this.lastIndex = x2.length - 1;
    let i1;
    let i3;
    this.interpolate = function interpolate(x22) {
      if (!x22) return 0;
      i3 = binarySearch(this.x, x22);
      i1 = i3 - 1;
      return (x22 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
    };
    return this;
  }
  function getInterpolateFunction(c2) {
    swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c2.slidesGrid) : new LinearSpline(swiper.snapGrid, c2.snapGrid);
  }
  function setTranslate2(_t, byController) {
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    const Swiper3 = swiper.constructor;
    function setControlledTranslate(c2) {
      if (c2.destroyed) return;
      const translate2 = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === "slide") {
        getInterpolateFunction(c2);
        controlledTranslate = -swiper.controller.spline.interpolate(-translate2);
      }
      if (!controlledTranslate || swiper.params.controller.by === "container") {
        multiplier = (c2.maxTranslate() - c2.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {
          multiplier = 1;
        }
        controlledTranslate = (translate2 - swiper.minTranslate()) * multiplier + c2.minTranslate();
      }
      if (swiper.params.controller.inverse) {
        controlledTranslate = c2.maxTranslate() - controlledTranslate;
      }
      c2.updateProgress(controlledTranslate);
      c2.setTranslate(controlledTranslate, swiper);
      c2.updateActiveIndex();
      c2.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i2 = 0; i2 < controlled.length; i2 += 1) {
        if (controlled[i2] !== byController && controlled[i2] instanceof Swiper3) {
          setControlledTranslate(controlled[i2]);
        }
      }
    } else if (controlled instanceof Swiper3 && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  }
  function setTransition2(duration, byController) {
    const Swiper3 = swiper.constructor;
    const controlled = swiper.controller.control;
    let i2;
    function setControlledTransition(c2) {
      if (c2.destroyed) return;
      c2.setTransition(duration, swiper);
      if (duration !== 0) {
        c2.transitionStart();
        if (c2.params.autoHeight) {
          nextTick(() => {
            c2.updateAutoHeight();
          });
        }
        elementTransitionEnd(c2.wrapperEl, () => {
          if (!controlled) return;
          c2.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i2 = 0; i2 < controlled.length; i2 += 1) {
        if (controlled[i2] !== byController && controlled[i2] instanceof Swiper3) {
          setControlledTransition(controlled[i2]);
        }
      }
    } else if (controlled instanceof Swiper3 && byController !== controlled) {
      setControlledTransition(controlled);
    }
  }
  function removeSpline() {
    if (!swiper.controller.control) return;
    if (swiper.controller.spline) {
      swiper.controller.spline = void 0;
      delete swiper.controller.spline;
    }
  }
  on("beforeInit", () => {
    if (typeof window !== "undefined" && // eslint-disable-line
    (typeof swiper.params.controller.control === "string" || swiper.params.controller.control instanceof HTMLElement)) {
      const controlElements = typeof swiper.params.controller.control === "string" ? [...document.querySelectorAll(swiper.params.controller.control)] : [swiper.params.controller.control];
      controlElements.forEach((controlElement) => {
        if (!swiper.controller.control) swiper.controller.control = [];
        if (controlElement && controlElement.swiper) {
          swiper.controller.control.push(controlElement.swiper);
        } else if (controlElement) {
          const eventName = "".concat(swiper.params.eventsPrefix, "init");
          const onControllerSwiper = (e2) => {
            swiper.controller.control.push(e2.detail[0]);
            swiper.update();
            controlElement.removeEventListener(eventName, onControllerSwiper);
          };
          controlElement.addEventListener(eventName, onControllerSwiper);
        }
      });
      return;
    }
    swiper.controller.control = swiper.params.controller.control;
  });
  on("update", () => {
    removeSpline();
  });
  on("resize", () => {
    removeSpline();
  });
  on("observerUpdate", () => {
    removeSpline();
  });
  on("setTranslate", (_s, translate2, byController) => {
    if (!swiper.controller.control || swiper.controller.control.destroyed) return;
    swiper.controller.setTranslate(translate2, byController);
  });
  on("setTransition", (_s, duration, byController) => {
    if (!swiper.controller.control || swiper.controller.control.destroyed) return;
    swiper.controller.setTransition(duration, byController);
  });
  Object.assign(swiper.controller, {
    setTranslate: setTranslate2,
    setTransition: setTransition2
  });
}
function A11y({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    a11y: {
      enabled: true,
      notificationClass: "swiper-notification",
      prevSlideMessage: "Previous slide",
      nextSlideMessage: "Next slide",
      firstSlideMessage: "This is the first slide",
      lastSlideMessage: "This is the last slide",
      paginationBulletMessage: "Go to slide {{index}}",
      slideLabelMessage: "{{index}} / {{slidesLength}}",
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      containerRole: null,
      itemRoleDescriptionMessage: null,
      slideRole: "group",
      id: null,
      scrollOnFocus: true,
      wrapperLiveRegion: true
    }
  });
  swiper.a11y = {
    clicked: false
  };
  let liveRegion = null;
  let preventFocusHandler;
  let focusTargetSlideEl;
  let visibilityChangedTimestamp = (/* @__PURE__ */ new Date()).getTime();
  function notify(message2) {
    const notification = liveRegion;
    if (notification.length === 0) return;
    setInnerHTML(notification, message2);
  }
  function getRandomNumber(size = 16) {
    const randomChar = () => Math.round(16 * Math.random()).toString(16);
    return "x".repeat(size).replace(/x/g, randomChar);
  }
  function makeElFocusable(el) {
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.setAttribute("tabIndex", "0");
    });
  }
  function makeElNotFocusable(el) {
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.setAttribute("tabIndex", "-1");
    });
  }
  function addElRole(el, role) {
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.setAttribute("role", role);
    });
  }
  function addElRoleDescription(el, description) {
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.setAttribute("aria-roledescription", description);
    });
  }
  function addElControls(el, controls) {
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.setAttribute("aria-controls", controls);
    });
  }
  function addElLabel(el, label) {
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.setAttribute("aria-label", label);
    });
  }
  function addElId(el, id) {
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.setAttribute("id", id);
    });
  }
  function addElLive(el, live2) {
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.setAttribute("aria-live", live2);
    });
  }
  function disableEl(el) {
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.setAttribute("aria-disabled", true);
    });
  }
  function enableEl(el) {
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.setAttribute("aria-disabled", false);
    });
  }
  function onEnterOrSpaceKey(e2) {
    if (e2.keyCode !== 13 && e2.keyCode !== 32) return;
    const params = swiper.params.a11y;
    const targetEl = e2.target;
    if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e2.target))) {
      if (!e2.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;
    }
    if (swiper.navigation && swiper.navigation.prevEl && swiper.navigation.nextEl) {
      const prevEls = makeElementsArray(swiper.navigation.prevEl);
      const nextEls = makeElementsArray(swiper.navigation.nextEl);
      if (nextEls.includes(targetEl)) {
        if (!(swiper.isEnd && !swiper.params.loop)) {
          swiper.slideNext();
        }
        if (swiper.isEnd) {
          notify(params.lastSlideMessage);
        } else {
          notify(params.nextSlideMessage);
        }
      }
      if (prevEls.includes(targetEl)) {
        if (!(swiper.isBeginning && !swiper.params.loop)) {
          swiper.slidePrev();
        }
        if (swiper.isBeginning) {
          notify(params.firstSlideMessage);
        } else {
          notify(params.prevSlideMessage);
        }
      }
    }
    if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {
      targetEl.click();
    }
  }
  function updateNavigation() {
    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
    const {
      nextEl,
      prevEl
    } = swiper.navigation;
    if (prevEl) {
      if (swiper.isBeginning) {
        disableEl(prevEl);
        makeElNotFocusable(prevEl);
      } else {
        enableEl(prevEl);
        makeElFocusable(prevEl);
      }
    }
    if (nextEl) {
      if (swiper.isEnd) {
        disableEl(nextEl);
        makeElNotFocusable(nextEl);
      } else {
        enableEl(nextEl);
        makeElFocusable(nextEl);
      }
    }
  }
  function hasPagination() {
    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
  }
  function hasClickablePagination() {
    return hasPagination() && swiper.params.pagination.clickable;
  }
  function updatePagination() {
    const params = swiper.params.a11y;
    if (!hasPagination()) return;
    swiper.pagination.bullets.forEach((bulletEl) => {
      if (swiper.params.pagination.clickable) {
        makeElFocusable(bulletEl);
        if (!swiper.params.pagination.renderBullet) {
          addElRole(bulletEl, "button");
          addElLabel(bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, elementIndex(bulletEl) + 1));
        }
      }
      if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {
        bulletEl.setAttribute("aria-current", "true");
      } else {
        bulletEl.removeAttribute("aria-current");
      }
    });
  }
  const initNavEl = (el, wrapperId, message2) => {
    makeElFocusable(el);
    if (el.tagName !== "BUTTON") {
      addElRole(el, "button");
      el.addEventListener("keydown", onEnterOrSpaceKey);
    }
    addElLabel(el, message2);
    addElControls(el, wrapperId);
  };
  const handlePointerDown = (e2) => {
    if (focusTargetSlideEl && focusTargetSlideEl !== e2.target && !focusTargetSlideEl.contains(e2.target)) {
      preventFocusHandler = true;
    }
    swiper.a11y.clicked = true;
  };
  const handlePointerUp = () => {
    preventFocusHandler = false;
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        if (!swiper.destroyed) {
          swiper.a11y.clicked = false;
        }
      });
    });
  };
  const onVisibilityChange = (e2) => {
    visibilityChangedTimestamp = (/* @__PURE__ */ new Date()).getTime();
  };
  const handleFocus = (e2) => {
    if (swiper.a11y.clicked || !swiper.params.a11y.scrollOnFocus) return;
    if ((/* @__PURE__ */ new Date()).getTime() - visibilityChangedTimestamp < 100) return;
    const slideEl = e2.target.closest(".".concat(swiper.params.slideClass, ", swiper-slide"));
    if (!slideEl || !swiper.slides.includes(slideEl)) return;
    focusTargetSlideEl = slideEl;
    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
    const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
    if (isActive || isVisible) return;
    if (e2.sourceCapabilities && e2.sourceCapabilities.firesTouchEvents) return;
    if (swiper.isHorizontal()) {
      swiper.el.scrollLeft = 0;
    } else {
      swiper.el.scrollTop = 0;
    }
    requestAnimationFrame(() => {
      if (preventFocusHandler) return;
      if (swiper.params.loop) {
        swiper.slideToLoop(swiper.getSlideIndexWhenGrid(parseInt(slideEl.getAttribute("data-swiper-slide-index"))), 0);
      } else {
        swiper.slideTo(swiper.getSlideIndexWhenGrid(swiper.slides.indexOf(slideEl)), 0);
      }
      preventFocusHandler = false;
    });
  };
  const initSlides = () => {
    const params = swiper.params.a11y;
    if (params.itemRoleDescriptionMessage) {
      addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);
    }
    if (params.slideRole) {
      addElRole(swiper.slides, params.slideRole);
    }
    const slidesLength = swiper.slides.length;
    if (params.slideLabelMessage) {
      swiper.slides.forEach((slideEl, index) => {
        const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute("data-swiper-slide-index"), 10) : index;
        const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
        addElLabel(slideEl, ariaLabelMessage);
      });
    }
  };
  const init2 = () => {
    const params = swiper.params.a11y;
    swiper.el.append(liveRegion);
    const containerEl = swiper.el;
    if (params.containerRoleDescriptionMessage) {
      addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);
    }
    if (params.containerMessage) {
      addElLabel(containerEl, params.containerMessage);
    }
    if (params.containerRole) {
      addElRole(containerEl, params.containerRole);
    }
    const wrapperEl = swiper.wrapperEl;
    const wrapperId = params.id || wrapperEl.getAttribute("id") || "swiper-wrapper-".concat(getRandomNumber(16));
    addElId(wrapperEl, wrapperId);
    if (params.wrapperLiveRegion) {
      const live2 = swiper.params.autoplay && swiper.params.autoplay.enabled ? "off" : "polite";
      addElLive(wrapperEl, live2);
    }
    initSlides();
    let {
      nextEl,
      prevEl
    } = swiper.navigation ? swiper.navigation : {};
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    if (nextEl) {
      nextEl.forEach((el) => initNavEl(el, wrapperId, params.nextSlideMessage));
    }
    if (prevEl) {
      prevEl.forEach((el) => initNavEl(el, wrapperId, params.prevSlideMessage));
    }
    if (hasClickablePagination()) {
      const paginationEl = makeElementsArray(swiper.pagination.el);
      paginationEl.forEach((el) => {
        el.addEventListener("keydown", onEnterOrSpaceKey);
      });
    }
    const document2 = getDocument();
    document2.addEventListener("visibilitychange", onVisibilityChange);
    swiper.el.addEventListener("focus", handleFocus, true);
    swiper.el.addEventListener("focus", handleFocus, true);
    swiper.el.addEventListener("pointerdown", handlePointerDown, true);
    swiper.el.addEventListener("pointerup", handlePointerUp, true);
  };
  function destroy2() {
    if (liveRegion) liveRegion.remove();
    let {
      nextEl,
      prevEl
    } = swiper.navigation ? swiper.navigation : {};
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    if (nextEl) {
      nextEl.forEach((el) => el.removeEventListener("keydown", onEnterOrSpaceKey));
    }
    if (prevEl) {
      prevEl.forEach((el) => el.removeEventListener("keydown", onEnterOrSpaceKey));
    }
    if (hasClickablePagination()) {
      const paginationEl = makeElementsArray(swiper.pagination.el);
      paginationEl.forEach((el) => {
        el.removeEventListener("keydown", onEnterOrSpaceKey);
      });
    }
    const document2 = getDocument();
    document2.removeEventListener("visibilitychange", onVisibilityChange);
    if (swiper.el && typeof swiper.el !== "string") {
      swiper.el.removeEventListener("focus", handleFocus, true);
      swiper.el.removeEventListener("pointerdown", handlePointerDown, true);
      swiper.el.removeEventListener("pointerup", handlePointerUp, true);
    }
  }
  on("beforeInit", () => {
    liveRegion = createElement("span", swiper.params.a11y.notificationClass);
    liveRegion.setAttribute("aria-live", "assertive");
    liveRegion.setAttribute("aria-atomic", "true");
  });
  on("afterInit", () => {
    if (!swiper.params.a11y.enabled) return;
    init2();
  });
  on("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => {
    if (!swiper.params.a11y.enabled) return;
    initSlides();
  });
  on("fromEdge toEdge afterInit lock unlock", () => {
    if (!swiper.params.a11y.enabled) return;
    updateNavigation();
  });
  on("paginationUpdate", () => {
    if (!swiper.params.a11y.enabled) return;
    updatePagination();
  });
  on("destroy", () => {
    if (!swiper.params.a11y.enabled) return;
    destroy2();
  });
}
function History({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    history: {
      enabled: false,
      root: "",
      replaceState: false,
      key: "slides",
      keepQuery: false
    }
  });
  let initialized = false;
  let paths = {};
  const slugify = (text) => {
    return text.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
  };
  const getPathValues = (urlOverride) => {
    const window2 = getWindow$1();
    let location2;
    if (urlOverride) {
      location2 = new URL(urlOverride);
    } else {
      location2 = window2.location;
    }
    const pathArray = location2.pathname.slice(1).split("/").filter((part) => part !== "");
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return {
      key,
      value
    };
  };
  const setHistory = (key, index) => {
    const window2 = getWindow$1();
    if (!initialized || !swiper.params.history.enabled) return;
    let location2;
    if (swiper.params.url) {
      location2 = new URL(swiper.params.url);
    } else {
      location2 = window2.location;
    }
    const slide2 = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector('[data-swiper-slide-index="'.concat(index, '"]')) : swiper.slides[index];
    let value = slugify(slide2.getAttribute("data-history"));
    if (swiper.params.history.root.length > 0) {
      let root = swiper.params.history.root;
      if (root[root.length - 1] === "/") root = root.slice(0, root.length - 1);
      value = "".concat(root, "/").concat(key ? "".concat(key, "/") : "").concat(value);
    } else if (!location2.pathname.includes(key)) {
      value = "".concat(key ? "".concat(key, "/") : "").concat(value);
    }
    if (swiper.params.history.keepQuery) {
      value += location2.search;
    }
    const currentState = window2.history.state;
    if (currentState && currentState.value === value) {
      return;
    }
    if (swiper.params.history.replaceState) {
      window2.history.replaceState({
        value
      }, null, value);
    } else {
      window2.history.pushState({
        value
      }, null, value);
    }
  };
  const scrollToSlide = (speed, value, runCallbacks) => {
    if (value) {
      for (let i2 = 0, length = swiper.slides.length; i2 < length; i2 += 1) {
        const slide2 = swiper.slides[i2];
        const slideHistory = slugify(slide2.getAttribute("data-history"));
        if (slideHistory === value) {
          const index = swiper.getSlideIndex(slide2);
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  };
  const setHistoryPopState = () => {
    paths = getPathValues(swiper.params.url);
    scrollToSlide(swiper.params.speed, paths.value, false);
  };
  const init2 = () => {
    const window2 = getWindow$1();
    if (!swiper.params.history) return;
    if (!window2.history || !window2.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }
    initialized = true;
    paths = getPathValues(swiper.params.url);
    if (!paths.key && !paths.value) {
      if (!swiper.params.history.replaceState) {
        window2.addEventListener("popstate", setHistoryPopState);
      }
      return;
    }
    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
    if (!swiper.params.history.replaceState) {
      window2.addEventListener("popstate", setHistoryPopState);
    }
  };
  const destroy2 = () => {
    const window2 = getWindow$1();
    if (!swiper.params.history.replaceState) {
      window2.removeEventListener("popstate", setHistoryPopState);
    }
  };
  on("init", () => {
    if (swiper.params.history.enabled) {
      init2();
    }
  });
  on("destroy", () => {
    if (swiper.params.history.enabled) {
      destroy2();
    }
  });
  on("transitionEnd _freeModeNoMomentumRelease", () => {
    if (initialized) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
  on("slideChange", () => {
    if (initialized && swiper.params.cssMode) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
}
function HashNavigation({
  swiper,
  extendParams,
  emit,
  on
}) {
  let initialized = false;
  const document2 = getDocument();
  const window2 = getWindow$1();
  extendParams({
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false,
      getSlideIndex(_s, hash2) {
        if (swiper.virtual && swiper.params.virtual.enabled) {
          const slideWithHash = swiper.slides.find((slideEl) => slideEl.getAttribute("data-hash") === hash2);
          if (!slideWithHash) return 0;
          const index = parseInt(slideWithHash.getAttribute("data-swiper-slide-index"), 10);
          return index;
        }
        return swiper.getSlideIndex(elementChildren(swiper.slidesEl, ".".concat(swiper.params.slideClass, '[data-hash="').concat(hash2, '"], swiper-slide[data-hash="').concat(hash2, '"]'))[0]);
      }
    }
  });
  const onHashChange = () => {
    emit("hashChange");
    const newHash = document2.location.hash.replace("#", "");
    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector('[data-swiper-slide-index="'.concat(swiper.activeIndex, '"]')) : swiper.slides[swiper.activeIndex];
    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute("data-hash") : "";
    if (newHash !== activeSlideHash) {
      const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);
      if (typeof newIndex === "undefined" || Number.isNaN(newIndex)) return;
      swiper.slideTo(newIndex);
    }
  };
  const setHash = () => {
    if (!initialized || !swiper.params.hashNavigation.enabled) return;
    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector('[data-swiper-slide-index="'.concat(swiper.activeIndex, '"]')) : swiper.slides[swiper.activeIndex];
    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute("data-hash") || activeSlideEl.getAttribute("data-history") : "";
    if (swiper.params.hashNavigation.replaceState && window2.history && window2.history.replaceState) {
      window2.history.replaceState(null, null, "#".concat(activeSlideHash) || "");
      emit("hashSet");
    } else {
      document2.location.hash = activeSlideHash || "";
      emit("hashSet");
    }
  };
  const init2 = () => {
    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
    initialized = true;
    const hash2 = document2.location.hash.replace("#", "");
    if (hash2) {
      const speed = 0;
      const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash2);
      swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);
    }
    if (swiper.params.hashNavigation.watchState) {
      window2.addEventListener("hashchange", onHashChange);
    }
  };
  const destroy2 = () => {
    if (swiper.params.hashNavigation.watchState) {
      window2.removeEventListener("hashchange", onHashChange);
    }
  };
  on("init", () => {
    if (swiper.params.hashNavigation.enabled) {
      init2();
    }
  });
  on("destroy", () => {
    if (swiper.params.hashNavigation.enabled) {
      destroy2();
    }
  });
  on("transitionEnd _freeModeNoMomentumRelease", () => {
    if (initialized) {
      setHash();
    }
  });
  on("slideChange", () => {
    if (initialized && swiper.params.cssMode) {
      setHash();
    }
  });
}
function Autoplay({
  swiper,
  extendParams,
  on,
  emit,
  params
}) {
  swiper.autoplay = {
    running: false,
    paused: false,
    timeLeft: 0
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3e3,
      waitForTransition: true,
      disableOnInteraction: false,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  });
  let timeout;
  let raf;
  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;
  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;
  let autoplayTimeLeft;
  let autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
  let wasPaused;
  let isTouched;
  let pausedByTouch;
  let touchStartTimeout;
  let slideChanged;
  let pausedByInteraction;
  let pausedByPointerEnter;
  function onTransitionEnd(e2) {
    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
    if (e2.target !== swiper.wrapperEl) return;
    swiper.wrapperEl.removeEventListener("transitionend", onTransitionEnd);
    if (pausedByPointerEnter || e2.detail && e2.detail.bySwiperTouchMove) {
      return;
    }
    resume();
  }
  const calcTimeLeft = () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (swiper.autoplay.paused) {
      wasPaused = true;
    } else if (wasPaused) {
      autoplayDelayCurrent = autoplayTimeLeft;
      wasPaused = false;
    }
    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (/* @__PURE__ */ new Date()).getTime();
    swiper.autoplay.timeLeft = timeLeft;
    emit("autoplayTimeLeft", timeLeft, timeLeft / autoplayDelayTotal);
    raf = requestAnimationFrame(() => {
      calcTimeLeft();
    });
  };
  const getSlideDelay = () => {
    let activeSlideEl;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      activeSlideEl = swiper.slides.find((slideEl) => slideEl.classList.contains("swiper-slide-active"));
    } else {
      activeSlideEl = swiper.slides[swiper.activeIndex];
    }
    if (!activeSlideEl) return void 0;
    const currentSlideDelay = parseInt(activeSlideEl.getAttribute("data-swiper-autoplay"), 10);
    return currentSlideDelay;
  };
  const run = (delayForce) => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    cancelAnimationFrame(raf);
    calcTimeLeft();
    let delay = typeof delayForce === "undefined" ? swiper.params.autoplay.delay : delayForce;
    autoplayDelayTotal = swiper.params.autoplay.delay;
    autoplayDelayCurrent = swiper.params.autoplay.delay;
    const currentSlideDelay = getSlideDelay();
    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === "undefined") {
      delay = currentSlideDelay;
      autoplayDelayTotal = currentSlideDelay;
      autoplayDelayCurrent = currentSlideDelay;
    }
    autoplayTimeLeft = delay;
    const speed = swiper.params.speed;
    const proceed = () => {
      if (!swiper || swiper.destroyed) return;
      if (swiper.params.autoplay.reverseDirection) {
        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
          swiper.slidePrev(speed, true, true);
          emit("autoplay");
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(swiper.slides.length - 1, speed, true, true);
          emit("autoplay");
        }
      } else {
        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
          swiper.slideNext(speed, true, true);
          emit("autoplay");
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(0, speed, true, true);
          emit("autoplay");
        }
      }
      if (swiper.params.cssMode) {
        autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
        requestAnimationFrame(() => {
          run();
        });
      }
    };
    if (delay > 0) {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        proceed();
      }, delay);
    } else {
      requestAnimationFrame(() => {
        proceed();
      });
    }
    return delay;
  };
  const start = () => {
    autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
    swiper.autoplay.running = true;
    run();
    emit("autoplayStart");
  };
  const stop = () => {
    swiper.autoplay.running = false;
    clearTimeout(timeout);
    cancelAnimationFrame(raf);
    emit("autoplayStop");
  };
  const pause = (internal, reset2) => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    clearTimeout(timeout);
    if (!internal) {
      pausedByInteraction = true;
    }
    const proceed = () => {
      emit("autoplayPause");
      if (swiper.params.autoplay.waitForTransition) {
        swiper.wrapperEl.addEventListener("transitionend", onTransitionEnd);
      } else {
        resume();
      }
    };
    swiper.autoplay.paused = true;
    if (reset2) {
      if (slideChanged) {
        autoplayTimeLeft = swiper.params.autoplay.delay;
      }
      slideChanged = false;
      proceed();
      return;
    }
    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
    autoplayTimeLeft = delay - ((/* @__PURE__ */ new Date()).getTime() - autoplayStartTime);
    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
    proceed();
  };
  const resume = () => {
    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
    autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
    if (pausedByInteraction) {
      pausedByInteraction = false;
      run(autoplayTimeLeft);
    } else {
      run();
    }
    swiper.autoplay.paused = false;
    emit("autoplayResume");
  };
  const onVisibilityChange = () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    const document2 = getDocument();
    if (document2.visibilityState === "hidden") {
      pausedByInteraction = true;
      pause(true);
    }
    if (document2.visibilityState === "visible") {
      resume();
    }
  };
  const onPointerEnter = (e2) => {
    if (e2.pointerType !== "mouse") return;
    pausedByInteraction = true;
    pausedByPointerEnter = true;
    if (swiper.animating || swiper.autoplay.paused) return;
    pause(true);
  };
  const onPointerLeave = (e2) => {
    if (e2.pointerType !== "mouse") return;
    pausedByPointerEnter = false;
    if (swiper.autoplay.paused) {
      resume();
    }
  };
  const attachMouseEvents = () => {
    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.el.addEventListener("pointerenter", onPointerEnter);
      swiper.el.addEventListener("pointerleave", onPointerLeave);
    }
  };
  const detachMouseEvents = () => {
    if (swiper.el && typeof swiper.el !== "string") {
      swiper.el.removeEventListener("pointerenter", onPointerEnter);
      swiper.el.removeEventListener("pointerleave", onPointerLeave);
    }
  };
  const attachDocumentEvents = () => {
    const document2 = getDocument();
    document2.addEventListener("visibilitychange", onVisibilityChange);
  };
  const detachDocumentEvents = () => {
    const document2 = getDocument();
    document2.removeEventListener("visibilitychange", onVisibilityChange);
  };
  on("init", () => {
    if (swiper.params.autoplay.enabled) {
      attachMouseEvents();
      attachDocumentEvents();
      start();
    }
  });
  on("destroy", () => {
    detachMouseEvents();
    detachDocumentEvents();
    if (swiper.autoplay.running) {
      stop();
    }
  });
  on("_freeModeStaticRelease", () => {
    if (pausedByTouch || pausedByInteraction) {
      resume();
    }
  });
  on("_freeModeNoMomentumRelease", () => {
    if (!swiper.params.autoplay.disableOnInteraction) {
      pause(true, true);
    } else {
      stop();
    }
  });
  on("beforeTransitionStart", (_s, speed, internal) => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (internal || !swiper.params.autoplay.disableOnInteraction) {
      pause(true, true);
    } else {
      stop();
    }
  });
  on("sliderFirstMove", () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (swiper.params.autoplay.disableOnInteraction) {
      stop();
      return;
    }
    isTouched = true;
    pausedByTouch = false;
    pausedByInteraction = false;
    touchStartTimeout = setTimeout(() => {
      pausedByInteraction = true;
      pausedByTouch = true;
      pause(true);
    }, 200);
  });
  on("touchEnd", () => {
    if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
    clearTimeout(touchStartTimeout);
    clearTimeout(timeout);
    if (swiper.params.autoplay.disableOnInteraction) {
      pausedByTouch = false;
      isTouched = false;
      return;
    }
    if (pausedByTouch && swiper.params.cssMode) resume();
    pausedByTouch = false;
    isTouched = false;
  });
  on("slideChange", () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    slideChanged = true;
  });
  Object.assign(swiper.autoplay, {
    start,
    stop,
    pause,
    resume
  });
}
function Thumb({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: "swiper-slide-thumb-active",
      thumbsContainerClass: "swiper-thumbs"
    }
  });
  let initialized = false;
  let swiperCreated = false;
  swiper.thumbs = {
    swiper: null
  };
  function onThumbClick() {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === "undefined" || clickedIndex === null) return;
    let slideToIndex;
    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
    } else {
      slideToIndex = clickedIndex;
    }
    if (swiper.params.loop) {
      swiper.slideToLoop(slideToIndex);
    } else {
      swiper.slideTo(slideToIndex);
    }
  }
  function init2() {
    const {
      thumbs: thumbsParams
    } = swiper.params;
    if (initialized) return false;
    initialized = true;
    const SwiperClass = swiper.constructor;
    if (thumbsParams.swiper instanceof SwiperClass) {
      if (thumbsParams.swiper.destroyed) {
        initialized = false;
        return false;
      }
      swiper.thumbs.swiper = thumbsParams.swiper;
      Object.assign(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      Object.assign(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper.update();
    } else if (isObject$2(thumbsParams.swiper)) {
      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
      Object.assign(thumbsSwiperParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
      swiperCreated = true;
    }
    swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on("tap", onThumbClick);
    return true;
  }
  function update8(initial) {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    const slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }
    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }
    thumbsToActivate = Math.floor(thumbsToActivate);
    thumbsSwiper.slides.forEach((slideEl) => slideEl.classList.remove(thumbActiveClass));
    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
      for (let i2 = 0; i2 < thumbsToActivate; i2 += 1) {
        elementChildren(thumbsSwiper.slidesEl, '[data-swiper-slide-index="'.concat(swiper.realIndex + i2, '"]')).forEach((slideEl) => {
          slideEl.classList.add(thumbActiveClass);
        });
      }
    } else {
      for (let i2 = 0; i2 < thumbsToActivate; i2 += 1) {
        if (thumbsSwiper.slides[swiper.realIndex + i2]) {
          thumbsSwiper.slides[swiper.realIndex + i2].classList.add(thumbActiveClass);
        }
      }
    }
    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      const currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      let direction;
      if (thumbsSwiper.params.loop) {
        const newThumbsSlide = thumbsSwiper.slides.find((slideEl) => slideEl.getAttribute("data-swiper-slide-index") === "".concat(swiper.realIndex));
        newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
        direction = swiper.activeIndex > swiper.previousIndex ? "next" : "prev";
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? "next" : "prev";
      }
      if (useOffset) {
        newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
      }
      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;
        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);
      }
    }
  }
  on("beforeInit", () => {
    const {
      thumbs
    } = swiper.params;
    if (!thumbs || !thumbs.swiper) return;
    if (typeof thumbs.swiper === "string" || thumbs.swiper instanceof HTMLElement) {
      const document2 = getDocument();
      const getThumbsElementAndInit = () => {
        const thumbsElement = typeof thumbs.swiper === "string" ? document2.querySelector(thumbs.swiper) : thumbs.swiper;
        if (thumbsElement && thumbsElement.swiper) {
          thumbs.swiper = thumbsElement.swiper;
          init2();
          update8(true);
        } else if (thumbsElement) {
          const eventName = "".concat(swiper.params.eventsPrefix, "init");
          const onThumbsSwiper = (e2) => {
            thumbs.swiper = e2.detail[0];
            thumbsElement.removeEventListener(eventName, onThumbsSwiper);
            init2();
            update8(true);
            thumbs.swiper.update();
            swiper.update();
          };
          thumbsElement.addEventListener(eventName, onThumbsSwiper);
        }
        return thumbsElement;
      };
      const watchForThumbsToAppear = () => {
        if (swiper.destroyed) return;
        const thumbsElement = getThumbsElementAndInit();
        if (!thumbsElement) {
          requestAnimationFrame(watchForThumbsToAppear);
        }
      };
      requestAnimationFrame(watchForThumbsToAppear);
    } else {
      init2();
      update8(true);
    }
  });
  on("slideChange update resize observerUpdate", () => {
    update8();
  });
  on("setTransition", (_s, duration) => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    thumbsSwiper.setTransition(duration);
  });
  on("beforeDestroy", () => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    if (swiperCreated) {
      thumbsSwiper.destroy();
    }
  });
  Object.assign(swiper.thumbs, {
    init: init2,
    update: update8
  });
}
function freeMode({
  swiper,
  extendParams,
  emit,
  once
}) {
  extendParams({
    freeMode: {
      enabled: false,
      momentum: true,
      momentumRatio: 1,
      momentumBounce: true,
      momentumBounceRatio: 1,
      momentumVelocityRatio: 1,
      sticky: false,
      minimumVelocity: 0.02
    }
  });
  function onTouchStart2() {
    if (swiper.params.cssMode) return;
    const translate2 = swiper.getTranslate();
    swiper.setTranslate(translate2);
    swiper.setTransition(0);
    swiper.touchEventsData.velocities.length = 0;
    swiper.freeMode.onTouchEnd({
      currentPos: swiper.rtl ? swiper.translate : -swiper.translate
    });
  }
  function onTouchMove2() {
    if (swiper.params.cssMode) return;
    const {
      touchEventsData: data,
      touches
    } = swiper;
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? "startX" : "startY"],
        time: data.touchStartTime
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
      time: now()
    });
  }
  function onTouchEnd2({
    currentPos
  }) {
    if (swiper.params.cssMode) return;
    const {
      params,
      wrapperEl,
      rtlTranslate: rtl,
      snapGrid,
      touchEventsData: data
    } = swiper;
    const touchEndTime = now();
    const timeDiff = touchEndTime - data.touchStartTime;
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }
    if (params.freeMode.momentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();
        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
          swiper.velocity = 0;
        }
        if (time > 150 || now() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeMode.momentumVelocityRatio;
      data.velocities.length = 0;
      let momentumDuration = 1e3 * params.freeMode.momentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;
      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
      let needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeMode.sticky) {
        let nextSlide;
        for (let j2 = 0; j2 < snapGrid.length; j2 += 1) {
          if (snapGrid[j2] > -newPosition) {
            nextSlide = j2;
            break;
          }
        }
        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === "next") {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        once("transitionEnd", () => {
          swiper.loopFix();
        });
      }
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
        if (params.freeMode.sticky) {
          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeMode.sticky) {
        swiper.slideToClosest();
        return;
      }
      if (params.freeMode.momentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        elementTransitionEnd(wrapperEl, () => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          emit("momentumBounce");
          swiper.setTransition(params.speed);
          setTimeout(() => {
            swiper.setTranslate(afterBouncePosition);
            elementTransitionEnd(wrapperEl, () => {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        emit("_freeModeNoMomentumRelease");
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          elementTransitionEnd(wrapperEl, () => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeMode.sticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      emit("_freeModeNoMomentumRelease");
    }
    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
      emit("_freeModeStaticRelease");
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
  }
  Object.assign(swiper, {
    freeMode: {
      onTouchStart: onTouchStart2,
      onTouchMove: onTouchMove2,
      onTouchEnd: onTouchEnd2
    }
  });
}
function Grid({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    grid: {
      rows: 1,
      fill: "column"
    }
  });
  let slidesNumberEvenToRows;
  let slidesPerRow;
  let numFullColumns;
  let wasMultiRow;
  const getSpaceBetween = () => {
    let spaceBetween = swiper.params.spaceBetween;
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size;
    } else if (typeof spaceBetween === "string") {
      spaceBetween = parseFloat(spaceBetween);
    }
    return spaceBetween;
  };
  const initSlides = (slides) => {
    const {
      slidesPerView
    } = swiper.params;
    const {
      rows,
      fill
    } = swiper.params.grid;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
    numFullColumns = Math.floor(slidesLength / rows);
    if (Math.floor(slidesLength / rows) === slidesLength / rows) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
    }
    if (slidesPerView !== "auto" && fill === "row") {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
    }
    slidesPerRow = slidesNumberEvenToRows / rows;
  };
  const unsetSlides = () => {
    if (swiper.slides) {
      swiper.slides.forEach((slide2) => {
        if (slide2.swiperSlideGridSet) {
          slide2.style.height = "";
          slide2.style[swiper.getDirectionLabel("margin-top")] = "";
        }
      });
    }
  };
  const updateSlide = (i2, slide2, slides) => {
    const {
      slidesPerGroup
    } = swiper.params;
    const spaceBetween = getSpaceBetween();
    const {
      rows,
      fill
    } = swiper.params.grid;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
    let newSlideOrderIndex;
    let column;
    let row;
    if (fill === "row" && slidesPerGroup > 1) {
      const groupIndex = Math.floor(i2 / (slidesPerGroup * rows));
      const slideIndexInGroup = i2 - rows * slidesPerGroup * groupIndex;
      const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
      row = Math.floor(slideIndexInGroup / columnsInGroup);
      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
      newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
      slide2.style.order = newSlideOrderIndex;
    } else if (fill === "column") {
      column = Math.floor(i2 / rows);
      row = i2 - column * rows;
      if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
        row += 1;
        if (row >= rows) {
          row = 0;
          column += 1;
        }
      }
    } else {
      row = Math.floor(i2 / slidesPerRow);
      column = i2 - row * slidesPerRow;
    }
    slide2.row = row;
    slide2.column = column;
    slide2.style.height = "calc((100% - ".concat((rows - 1) * spaceBetween, "px) / ").concat(rows, ")");
    slide2.style[swiper.getDirectionLabel("margin-top")] = row !== 0 ? spaceBetween && "".concat(spaceBetween, "px") : "";
    slide2.swiperSlideGridSet = true;
  };
  const updateWrapperSize = (slideSize, snapGrid) => {
    const {
      centeredSlides,
      roundLengths
    } = swiper.params;
    const spaceBetween = getSpaceBetween();
    const {
      rows
    } = swiper.params.grid;
    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
    if (!swiper.params.cssMode) {
      swiper.wrapperEl.style[swiper.getDirectionLabel("width")] = "".concat(swiper.virtualSize + spaceBetween, "px");
    }
    if (centeredSlides) {
      const newSlidesGrid = [];
      for (let i2 = 0; i2 < snapGrid.length; i2 += 1) {
        let slidesGridItem = snapGrid[i2];
        if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i2] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }
      snapGrid.splice(0, snapGrid.length);
      snapGrid.push(...newSlidesGrid);
    }
  };
  const onInit = () => {
    wasMultiRow = swiper.params.grid && swiper.params.grid.rows > 1;
  };
  const onUpdate = () => {
    const {
      params,
      el
    } = swiper;
    const isMultiRow = params.grid && params.grid.rows > 1;
    if (wasMultiRow && !isMultiRow) {
      el.classList.remove("".concat(params.containerModifierClass, "grid"), "".concat(params.containerModifierClass, "grid-column"));
      numFullColumns = 1;
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      el.classList.add("".concat(params.containerModifierClass, "grid"));
      if (params.grid.fill === "column") {
        el.classList.add("".concat(params.containerModifierClass, "grid-column"));
      }
      swiper.emitContainerClasses();
    }
    wasMultiRow = isMultiRow;
  };
  on("init", onInit);
  on("update", onUpdate);
  swiper.grid = {
    initSlides,
    unsetSlides,
    updateSlide,
    updateWrapperSize
  };
}
function appendSlide(slides) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  const appendElement = (slideEl) => {
    if (typeof slideEl === "string") {
      const tempDOM = document.createElement("div");
      setInnerHTML(tempDOM, slideEl);
      slidesEl.append(tempDOM.children[0]);
      setInnerHTML(tempDOM, "");
    } else {
      slidesEl.append(slideEl);
    }
  };
  if (typeof slides === "object" && "length" in slides) {
    for (let i2 = 0; i2 < slides.length; i2 += 1) {
      if (slides[i2]) appendElement(slides[i2]);
    }
  } else {
    appendElement(slides);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
}
function prependSlide(slides) {
  const swiper = this;
  const {
    params,
    activeIndex,
    slidesEl
  } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  const prependElement = (slideEl) => {
    if (typeof slideEl === "string") {
      const tempDOM = document.createElement("div");
      setInnerHTML(tempDOM, slideEl);
      slidesEl.prepend(tempDOM.children[0]);
      setInnerHTML(tempDOM, "");
    } else {
      slidesEl.prepend(slideEl);
    }
  };
  if (typeof slides === "object" && "length" in slides) {
    for (let i2 = 0; i2 < slides.length; i2 += 1) {
      if (slides[i2]) prependElement(slides[i2]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    prependElement(slides);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}
function addSlide(index, slides) {
  const swiper = this;
  const {
    params,
    activeIndex,
    slidesEl
  } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.recalcSlides();
  }
  const baseLength = swiper.slides.length;
  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }
  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }
  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
  const slidesBuffer = [];
  for (let i2 = baseLength - 1; i2 >= index; i2 -= 1) {
    const currentSlide = swiper.slides[i2];
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }
  if (typeof slides === "object" && "length" in slides) {
    for (let i2 = 0; i2 < slides.length; i2 += 1) {
      if (slides[i2]) slidesEl.append(slides[i2]);
    }
    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    slidesEl.append(slides);
  }
  for (let i2 = 0; i2 < slidesBuffer.length; i2 += 1) {
    slidesEl.append(slidesBuffer[i2]);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}
function removeSlide(slidesIndexes) {
  const swiper = this;
  const {
    params,
    activeIndex
  } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;
  if (typeof slidesIndexes === "object" && "length" in slidesIndexes) {
    for (let i2 = 0; i2 < slidesIndexes.length; i2 += 1) {
      indexToRemove = slidesIndexes[i2];
      if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}
function removeAllSlides() {
  const swiper = this;
  const slidesIndexes = [];
  for (let i2 = 0; i2 < swiper.slides.length; i2 += 1) {
    slidesIndexes.push(i2);
  }
  swiper.removeSlide(slidesIndexes);
}
function Manipulation({
  swiper
}) {
  Object.assign(swiper, {
    appendSlide: appendSlide.bind(swiper),
    prependSlide: prependSlide.bind(swiper),
    addSlide: addSlide.bind(swiper),
    removeSlide: removeSlide.bind(swiper),
    removeAllSlides: removeAllSlides.bind(swiper)
  });
}
function effectInit(params) {
  const {
    effect,
    swiper,
    on,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    overwriteParams,
    perspective,
    recreateShadows,
    getEffectParams
  } = params;
  on("beforeInit", () => {
    if (swiper.params.effect !== effect) return;
    swiper.classNames.push("".concat(swiper.params.containerModifierClass).concat(effect));
    if (perspective && perspective()) {
      swiper.classNames.push("".concat(swiper.params.containerModifierClass, "3d"));
    }
    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
    Object.assign(swiper.params, overwriteParamsResult);
    Object.assign(swiper.originalParams, overwriteParamsResult);
  });
  on("setTranslate _virtualUpdated", () => {
    if (swiper.params.effect !== effect) return;
    setTranslate2();
  });
  on("setTransition", (_s, duration) => {
    if (swiper.params.effect !== effect) return;
    setTransition2(duration);
  });
  on("transitionEnd", () => {
    if (swiper.params.effect !== effect) return;
    if (recreateShadows) {
      if (!getEffectParams || !getEffectParams().slideShadows) return;
      swiper.slides.forEach((slideEl) => {
        slideEl.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((shadowEl) => shadowEl.remove());
      });
      recreateShadows();
    }
  });
  let requireUpdateOnVirtual;
  on("virtualUpdate", () => {
    if (swiper.params.effect !== effect) return;
    if (!swiper.slides.length) {
      requireUpdateOnVirtual = true;
    }
    requestAnimationFrame(() => {
      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
        setTranslate2();
        requireUpdateOnVirtual = false;
      }
    });
  });
}
function effectTarget(effectParams, slideEl) {
  const transformEl = getSlideTransformEl(slideEl);
  if (transformEl !== slideEl) {
    transformEl.style.backfaceVisibility = "hidden";
    transformEl.style["-webkit-backface-visibility"] = "hidden";
  }
  return transformEl;
}
function effectVirtualTransitionEnd({
  swiper,
  duration,
  transformElements,
  allSlides
}) {
  const {
    activeIndex
  } = swiper;
  const getSlide = (el) => {
    if (!el.parentElement) {
      const slide2 = swiper.slides.find((slideEl) => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode);
      return slide2;
    }
    return el.parentElement;
  };
  if (swiper.params.virtualTranslate && duration !== 0) {
    let eventTriggered = false;
    let transitionEndTarget;
    if (allSlides) {
      transitionEndTarget = transformElements;
    } else {
      transitionEndTarget = transformElements.filter((transformEl) => {
        const el = transformEl.classList.contains("swiper-slide-transform") ? getSlide(transformEl) : transformEl;
        return swiper.getSlideIndex(el) === activeIndex;
      });
    }
    transitionEndTarget.forEach((el) => {
      elementTransitionEnd(el, () => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const evt = new window.CustomEvent("transitionend", {
          bubbles: true,
          cancelable: true
        });
        swiper.wrapperEl.dispatchEvent(evt);
      });
    });
  }
}
function EffectFade({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    fadeEffect: {
      crossFade: false
    }
  });
  const setTranslate2 = () => {
    const {
      slides
    } = swiper;
    const params = swiper.params.fadeEffect;
    for (let i2 = 0; i2 < slides.length; i2 += 1) {
      const slideEl = swiper.slides[i2];
      const offset = slideEl.swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
      const targetEl = effectTarget(params, slideEl);
      targetEl.style.opacity = slideOpacity;
      targetEl.style.transform = "translate3d(".concat(tx, "px, ").concat(ty, "px, 0px)");
    }
  };
  const setTransition2 = (duration) => {
    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));
    transformElements.forEach((el) => {
      el.style.transitionDuration = "".concat(duration, "ms");
    });
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformElements,
      allSlides: true
    });
  };
  effectInit({
    effect: "fade",
    swiper,
    on,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}
function EffectCube({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94
    }
  });
  const createSlideShadows = (slideEl, progress, isHorizontal) => {
    let shadowBefore = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-left") : slideEl.querySelector(".swiper-slide-shadow-top");
    let shadowAfter = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-right") : slideEl.querySelector(".swiper-slide-shadow-bottom");
    if (!shadowBefore) {
      shadowBefore = createElement("div", "swiper-slide-shadow-cube swiper-slide-shadow-".concat(isHorizontal ? "left" : "top").split(" "));
      slideEl.append(shadowBefore);
    }
    if (!shadowAfter) {
      shadowAfter = createElement("div", "swiper-slide-shadow-cube swiper-slide-shadow-".concat(isHorizontal ? "right" : "bottom").split(" "));
      slideEl.append(shadowAfter);
    }
    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    const isHorizontal = swiper.isHorizontal();
    swiper.slides.forEach((slideEl) => {
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      createSlideShadows(slideEl, progress, isHorizontal);
    });
  };
  const setTranslate2 = () => {
    const {
      el,
      wrapperEl,
      slides,
      width: swiperWidth,
      height: swiperHeight,
      rtlTranslate: rtl,
      size: swiperSize,
      browser: browser2
    } = swiper;
    const r2 = getRotateFix(swiper);
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        cubeShadowEl = swiper.wrapperEl.querySelector(".swiper-cube-shadow");
        if (!cubeShadowEl) {
          cubeShadowEl = createElement("div", "swiper-cube-shadow");
          swiper.wrapperEl.append(cubeShadowEl);
        }
        cubeShadowEl.style.height = "".concat(swiperWidth, "px");
      } else {
        cubeShadowEl = el.querySelector(".swiper-cube-shadow");
        if (!cubeShadowEl) {
          cubeShadowEl = createElement("div", "swiper-cube-shadow");
          el.append(cubeShadowEl);
        }
      }
    }
    for (let i2 = 0; i2 < slides.length; i2 += 1) {
      const slideEl = slides[i2];
      let slideIndex = i2;
      if (isVirtual) {
        slideIndex = parseInt(slideEl.getAttribute("data-swiper-slide-index"), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + round * 4 * swiperSize;
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = 3 * swiperSize + swiperSize * 4 * round;
      }
      if (rtl) {
        tx = -tx;
      }
      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }
      const transform = "rotateX(".concat(r2(isHorizontal ? 0 : -slideAngle), "deg) rotateY(").concat(r2(isHorizontal ? slideAngle : 0), "deg) translate3d(").concat(tx, "px, ").concat(ty, "px, ").concat(tz, "px)");
      if (progress <= 1 && progress > -1) {
        wrapperRotate = slideIndex * 90 + progress * 90;
        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
      }
      slideEl.style.transform = transform;
      if (params.slideShadows) {
        createSlideShadows(slideEl, progress, isHorizontal);
      }
    }
    wrapperEl.style.transformOrigin = "50% 50% -".concat(swiperSize / 2, "px");
    wrapperEl.style["-webkit-transform-origin"] = "50% 50% -".concat(swiperSize / 2, "px");
    if (params.shadow) {
      if (isHorizontal) {
        cubeShadowEl.style.transform = "translate3d(0px, ".concat(swiperWidth / 2 + params.shadowOffset, "px, ").concat(-swiperWidth / 2, "px) rotateX(89.99deg) rotateZ(0deg) scale(").concat(params.shadowScale, ")");
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        cubeShadowEl.style.transform = "scale3d(".concat(scale1, ", 1, ").concat(scale2, ") translate3d(0px, ").concat(swiperHeight / 2 + offset, "px, ").concat(-swiperHeight / 2 / scale2, "px) rotateX(-89.99deg)");
      }
    }
    const zFactor = (browser2.isSafari || browser2.isWebView) && browser2.needPerspectiveFix ? -swiperSize / 2 : 0;
    wrapperEl.style.transform = "translate3d(0px,0,".concat(zFactor, "px) rotateX(").concat(r2(swiper.isHorizontal() ? 0 : wrapperRotate), "deg) rotateY(").concat(r2(swiper.isHorizontal() ? -wrapperRotate : 0), "deg)");
    wrapperEl.style.setProperty("--swiper-cube-translate-z", "".concat(zFactor, "px"));
  };
  const setTransition2 = (duration) => {
    const {
      el,
      slides
    } = swiper;
    slides.forEach((slideEl) => {
      slideEl.style.transitionDuration = "".concat(duration, "ms");
      slideEl.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((subEl) => {
        subEl.style.transitionDuration = "".concat(duration, "ms");
      });
    });
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      const shadowEl = el.querySelector(".swiper-cube-shadow");
      if (shadowEl) shadowEl.style.transitionDuration = "".concat(duration, "ms");
    }
  };
  effectInit({
    effect: "cube",
    swiper,
    on,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    recreateShadows,
    getEffectParams: () => swiper.params.cubeEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      resistanceRatio: 0,
      spaceBetween: 0,
      centeredSlides: false,
      virtualTranslate: true
    })
  });
}
function createShadow(suffix, slideEl, side) {
  const shadowClass = "swiper-slide-shadow".concat(side ? "-".concat(side) : "").concat(suffix ? " swiper-slide-shadow-".concat(suffix) : "");
  const shadowContainer = getSlideTransformEl(slideEl);
  let shadowEl = shadowContainer.querySelector(".".concat(shadowClass.split(" ").join(".")));
  if (!shadowEl) {
    shadowEl = createElement("div", shadowClass.split(" "));
    shadowContainer.append(shadowEl);
  }
  return shadowEl;
}
function EffectFlip({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    flipEffect: {
      slideShadows: true,
      limitRotation: true
    }
  });
  const createSlideShadows = (slideEl, progress) => {
    let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector(".swiper-slide-shadow-left") : slideEl.querySelector(".swiper-slide-shadow-top");
    let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector(".swiper-slide-shadow-right") : slideEl.querySelector(".swiper-slide-shadow-bottom");
    if (!shadowBefore) {
      shadowBefore = createShadow("flip", slideEl, swiper.isHorizontal() ? "left" : "top");
    }
    if (!shadowAfter) {
      shadowAfter = createShadow("flip", slideEl, swiper.isHorizontal() ? "right" : "bottom");
    }
    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    swiper.params.flipEffect;
    swiper.slides.forEach((slideEl) => {
      let progress = slideEl.progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min(slideEl.progress, 1), -1);
      }
      createSlideShadows(slideEl, progress);
    });
  };
  const setTranslate2 = () => {
    const {
      slides,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.flipEffect;
    const rotateFix = getRotateFix(swiper);
    for (let i2 = 0; i2 < slides.length; i2 += 1) {
      const slideEl = slides[i2];
      let progress = slideEl.progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min(slideEl.progress, 1), -1);
      }
      const offset = slideEl.swiperSlideOffset;
      const rotate2 = -180 * progress;
      let rotateY = rotate2;
      let rotateX = 0;
      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }
      slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
      if (params.slideShadows) {
        createSlideShadows(slideEl, progress);
      }
      const transform = "translate3d(".concat(tx, "px, ").concat(ty, "px, 0px) rotateX(").concat(rotateFix(rotateX), "deg) rotateY(").concat(rotateFix(rotateY), "deg)");
      const targetEl = effectTarget(params, slideEl);
      targetEl.style.transform = transform;
    }
  };
  const setTransition2 = (duration) => {
    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));
    transformElements.forEach((el) => {
      el.style.transitionDuration = "".concat(duration, "ms");
      el.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((shadowEl) => {
        shadowEl.style.transitionDuration = "".concat(duration, "ms");
      });
    });
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformElements
    });
  };
  effectInit({
    effect: "flip",
    swiper,
    on,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    recreateShadows,
    getEffectParams: () => swiper.params.flipEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}
function EffectCoverflow({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: true
    }
  });
  const setTranslate2 = () => {
    const {
      width: swiperWidth,
      height: swiperHeight,
      slides,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
    const rotate2 = isHorizontal ? params.rotate : -params.rotate;
    const translate2 = params.depth;
    const r2 = getRotateFix(swiper);
    for (let i2 = 0, length = slides.length; i2 < length; i2 += 1) {
      const slideEl = slides[i2];
      const slideSize = slidesSizesGrid[i2];
      const slideOffset = slideEl.swiperSlideOffset;
      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
      const offsetMultiplier = typeof params.modifier === "function" ? params.modifier(centerOffset) : centerOffset * params.modifier;
      let rotateY = isHorizontal ? rotate2 * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate2 * offsetMultiplier;
      let translateZ = -translate2 * Math.abs(offsetMultiplier);
      let stretch = params.stretch;
      if (typeof stretch === "string" && stretch.indexOf("%") !== -1) {
        stretch = parseFloat(params.stretch) / 100 * slideSize;
      }
      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
      let scale2 = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);
      if (Math.abs(translateX) < 1e-3) translateX = 0;
      if (Math.abs(translateY) < 1e-3) translateY = 0;
      if (Math.abs(translateZ) < 1e-3) translateZ = 0;
      if (Math.abs(rotateY) < 1e-3) rotateY = 0;
      if (Math.abs(rotateX) < 1e-3) rotateX = 0;
      if (Math.abs(scale2) < 1e-3) scale2 = 0;
      const slideTransform = "translate3d(".concat(translateX, "px,").concat(translateY, "px,").concat(translateZ, "px)  rotateX(").concat(r2(rotateX), "deg) rotateY(").concat(r2(rotateY), "deg) scale(").concat(scale2, ")");
      const targetEl = effectTarget(params, slideEl);
      targetEl.style.transform = slideTransform;
      slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        let shadowBeforeEl = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-left") : slideEl.querySelector(".swiper-slide-shadow-top");
        let shadowAfterEl = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-right") : slideEl.querySelector(".swiper-slide-shadow-bottom");
        if (!shadowBeforeEl) {
          shadowBeforeEl = createShadow("coverflow", slideEl, isHorizontal ? "left" : "top");
        }
        if (!shadowAfterEl) {
          shadowAfterEl = createShadow("coverflow", slideEl, isHorizontal ? "right" : "bottom");
        }
        if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
      }
    }
  };
  const setTransition2 = (duration) => {
    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));
    transformElements.forEach((el) => {
      el.style.transitionDuration = "".concat(duration, "ms");
      el.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((shadowEl) => {
        shadowEl.style.transitionDuration = "".concat(duration, "ms");
      });
    });
  };
  effectInit({
    effect: "coverflow",
    swiper,
    on,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true
    })
  });
}
function EffectCreative({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    creativeEffect: {
      limitProgress: 1,
      shadowPerProgress: false,
      progressMultiplier: 1,
      perspective: true,
      prev: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      },
      next: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      }
    }
  });
  const getTranslateValue = (value) => {
    if (typeof value === "string") return value;
    return "".concat(value, "px");
  };
  const setTranslate2 = () => {
    const {
      slides,
      wrapperEl,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.creativeEffect;
    const {
      progressMultiplier: multiplier
    } = params;
    const isCenteredSlides = swiper.params.centeredSlides;
    const rotateFix = getRotateFix(swiper);
    if (isCenteredSlides) {
      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
      wrapperEl.style.transform = "translateX(calc(50% - ".concat(margin, "px))");
    }
    for (let i2 = 0; i2 < slides.length; i2 += 1) {
      const slideEl = slides[i2];
      const slideProgress = slideEl.progress;
      const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);
      let originalProgress = progress;
      if (!isCenteredSlides) {
        originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);
      }
      const offset = slideEl.swiperSlideOffset;
      const t2 = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
      const r2 = [0, 0, 0];
      let custom = false;
      if (!swiper.isHorizontal()) {
        t2[1] = t2[0];
        t2[0] = 0;
      }
      let data = {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        scale: 1,
        opacity: 1
      };
      if (progress < 0) {
        data = params.next;
        custom = true;
      } else if (progress > 0) {
        data = params.prev;
        custom = true;
      }
      t2.forEach((value, index) => {
        t2[index] = "calc(".concat(value, "px + (").concat(getTranslateValue(data.translate[index]), " * ").concat(Math.abs(progress * multiplier), "))");
      });
      r2.forEach((value, index) => {
        let val = data.rotate[index] * Math.abs(progress * multiplier);
        r2[index] = val;
      });
      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const translateString = t2.join(", ");
      const rotateString = "rotateX(".concat(rotateFix(r2[0]), "deg) rotateY(").concat(rotateFix(r2[1]), "deg) rotateZ(").concat(rotateFix(r2[2]), "deg)");
      const scaleString = originalProgress < 0 ? "scale(".concat(1 + (1 - data.scale) * originalProgress * multiplier, ")") : "scale(".concat(1 - (1 - data.scale) * originalProgress * multiplier, ")");
      const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
      const transform = "translate3d(".concat(translateString, ") ").concat(rotateString, " ").concat(scaleString);
      if (custom && data.shadow || !custom) {
        let shadowEl = slideEl.querySelector(".swiper-slide-shadow");
        if (!shadowEl && data.shadow) {
          shadowEl = createShadow("creative", slideEl);
        }
        if (shadowEl) {
          const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
          shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
        }
      }
      const targetEl = effectTarget(params, slideEl);
      targetEl.style.transform = transform;
      targetEl.style.opacity = opacityString;
      if (data.origin) {
        targetEl.style.transformOrigin = data.origin;
      }
    }
  };
  const setTransition2 = (duration) => {
    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));
    transformElements.forEach((el) => {
      el.style.transitionDuration = "".concat(duration, "ms");
      el.querySelectorAll(".swiper-slide-shadow").forEach((shadowEl) => {
        shadowEl.style.transitionDuration = "".concat(duration, "ms");
      });
    });
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformElements,
      allSlides: true
    });
  };
  effectInit({
    effect: "creative",
    swiper,
    on,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    perspective: () => swiper.params.creativeEffect.perspective,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}
function EffectCards({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    cardsEffect: {
      slideShadows: true,
      rotate: true,
      perSlideRotate: 2,
      perSlideOffset: 8
    }
  });
  const setTranslate2 = () => {
    const {
      slides,
      activeIndex,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.cardsEffect;
    const {
      startTranslate,
      isTouched
    } = swiper.touchEventsData;
    const currentTranslate = rtl ? -swiper.translate : swiper.translate;
    for (let i2 = 0; i2 < slides.length; i2 += 1) {
      const slideEl = slides[i2];
      const slideProgress = slideEl.progress;
      const progress = Math.min(Math.max(slideProgress, -4), 4);
      let offset = slideEl.swiperSlideOffset;
      if (swiper.params.centeredSlides && !swiper.params.cssMode) {
        swiper.wrapperEl.style.transform = "translateX(".concat(swiper.minTranslate(), "px)");
      }
      if (swiper.params.centeredSlides && swiper.params.cssMode) {
        offset -= slides[0].swiperSlideOffset;
      }
      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let tY = 0;
      const tZ = -100 * Math.abs(progress);
      let scale2 = 1;
      let rotate2 = -params.perSlideRotate * progress;
      let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
      const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i2 : i2;
      const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
      const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
      if (isSwipeToNext || isSwipeToPrev) {
        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
        rotate2 += -28 * progress * subProgress;
        scale2 += -0.5 * subProgress;
        tXAdd += 96 * subProgress;
        tY = "".concat((params.rotate || swiper.isHorizontal() ? -25 : 0) * subProgress * Math.abs(progress), "%");
      }
      if (progress < 0) {
        tX = "calc(".concat(tX, "px ").concat(rtl ? "-" : "+", " (").concat(tXAdd * Math.abs(progress), "%))");
      } else if (progress > 0) {
        tX = "calc(".concat(tX, "px ").concat(rtl ? "-" : "+", " (-").concat(tXAdd * Math.abs(progress), "%))");
      } else {
        tX = "".concat(tX, "px");
      }
      if (!swiper.isHorizontal()) {
        const prevY = tY;
        tY = tX;
        tX = prevY;
      }
      const scaleString = progress < 0 ? "".concat(1 + (1 - scale2) * progress) : "".concat(1 - (1 - scale2) * progress);
      const transform = "\n        translate3d(".concat(tX, ", ").concat(tY, ", ").concat(tZ, "px)\n        rotateZ(").concat(params.rotate ? rtl ? -rotate2 : rotate2 : 0, "deg)\n        scale(").concat(scaleString, ")\n      ");
      if (params.slideShadows) {
        let shadowEl = slideEl.querySelector(".swiper-slide-shadow");
        if (!shadowEl) {
          shadowEl = createShadow("cards", slideEl);
        }
        if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
      }
      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const targetEl = effectTarget(params, slideEl);
      targetEl.style.transform = transform;
    }
  };
  const setTransition2 = (duration) => {
    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));
    transformElements.forEach((el) => {
      el.style.transitionDuration = "".concat(duration, "ms");
      el.querySelectorAll(".swiper-slide-shadow").forEach((shadowEl) => {
        shadowEl.style.transitionDuration = "".concat(duration, "ms");
      });
    });
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformElements
    });
  };
  effectInit({
    effect: "cards",
    swiper,
    on,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    perspective: () => true,
    overwriteParams: () => ({
      _loopSwapReset: false,
      watchSlidesProgress: true,
      loopAdditionalSlides: swiper.params.cardsEffect.rotate ? 3 : 2,
      centeredSlides: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}
const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
Swiper$1.use(modules);
const formatValue = (val) => {
  if (parseFloat(val) === Number(val)) return Number(val);
  if (val === "true") return true;
  if (val === "") return true;
  if (val === "false") return false;
  if (val === "null") return null;
  if (val === "undefined") return void 0;
  if (typeof val === "string" && val.includes("{") && val.includes("}") && val.includes('"')) {
    let v2;
    try {
      v2 = JSON.parse(val);
    } catch (err2) {
      v2 = val;
    }
    return v2;
  }
  return val;
};
const modulesParamsList = ["a11y", "autoplay", "controller", "cards-effect", "coverflow-effect", "creative-effect", "cube-effect", "fade-effect", "flip-effect", "free-mode", "grid", "hash-navigation", "history", "keyboard", "mousewheel", "navigation", "pagination", "parallax", "scrollbar", "thumbs", "virtual", "zoom"];
function getParams(element, propName, propValue) {
  const params = {};
  const passedParams = {};
  extend(params, defaults);
  const localParamsList = [...paramsList, "on"];
  const allowedParams = localParamsList.map((key) => key.replace(/_/, ""));
  localParamsList.forEach((paramName) => {
    paramName = paramName.replace("_", "");
    if (typeof element[paramName] !== "undefined") {
      passedParams[paramName] = element[paramName];
    }
  });
  const attrsList = [...element.attributes];
  if (typeof propName === "string" && typeof propValue !== "undefined") {
    attrsList.push({
      name: propName,
      value: isObject$1(propValue) ? {
        ...propValue
      } : propValue
    });
  }
  attrsList.forEach((attr) => {
    const moduleParam = modulesParamsList.find((mParam) => attr.name.startsWith("".concat(mParam, "-")));
    if (moduleParam) {
      const parentObjName = attrToProp(moduleParam);
      const subObjName = attrToProp(attr.name.split("".concat(moduleParam, "-"))[1]);
      if (typeof passedParams[parentObjName] === "undefined") {
        passedParams[parentObjName] = {};
      }
      if (passedParams[parentObjName] === true) {
        passedParams[parentObjName] = {
          enabled: true
        };
      }
      if (passedParams[parentObjName] === false) {
        passedParams[parentObjName] = {
          enabled: false
        };
      }
      passedParams[parentObjName][subObjName] = formatValue(attr.value);
    } else {
      const name = attrToProp(attr.name);
      if (!allowedParams.includes(name)) return;
      const value = formatValue(attr.value);
      if (passedParams[name] && modulesParamsList.includes(attr.name) && !isObject$1(value)) {
        if (passedParams[name].constructor !== Object) {
          passedParams[name] = {};
        }
        passedParams[name].enabled = !!value;
      } else {
        passedParams[name] = value;
      }
    }
  });
  extend(params, passedParams);
  if (params.navigation) {
    params.navigation = {
      prevEl: ".swiper-button-prev",
      nextEl: ".swiper-button-next",
      ...params.navigation !== true ? params.navigation : {}
    };
  } else if (params.navigation === false) {
    delete params.navigation;
  }
  if (params.scrollbar) {
    params.scrollbar = {
      el: ".swiper-scrollbar",
      ...params.scrollbar !== true ? params.scrollbar : {}
    };
  } else if (params.scrollbar === false) {
    delete params.scrollbar;
  }
  if (params.pagination) {
    params.pagination = {
      el: ".swiper-pagination",
      ...params.pagination !== true ? params.pagination : {}
    };
  } else if (params.pagination === false) {
    delete params.pagination;
  }
  return {
    params,
    passedParams
  };
}
const SwiperCSS = ':host{--swiper-theme-color:#007aff}:host{display:block;margin-left:auto;margin-right:auto;position:relative;z-index:1}.swiper{display:block;height:100%;list-style:none;margin-left:auto;margin-right:auto;overflow:hidden;padding:0;position:relative;width:100%;z-index:1}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{box-sizing:initial;display:flex;height:100%;position:relative;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);width:100%;z-index:1}.swiper-android ::slotted(swiper-slide),.swiper-ios ::slotted(swiper-slide),.swiper-wrapper{transform:translateZ(0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}::slotted(swiper-slide){display:block;flex-shrink:0;height:100%;position:relative;transition-property:transform;width:100%}::slotted(.swiper-slide-invisible-blank){visibility:hidden}.swiper-autoheight,.swiper-autoheight ::slotted(swiper-slide){height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden ::slotted(swiper-slide){backface-visibility:hidden;transform:translateZ(0)}.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d ::slotted(swiper-slide){transform-style:preserve-3d}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode ::slotted(swiper-slide){scroll-snap-align:start start}.swiper-css-mode.swiper-horizontal>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-css-mode.swiper-vertical>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-css-mode.swiper-free-mode>.swiper-wrapper{scroll-snap-type:none}.swiper-css-mode.swiper-free-mode ::slotted(swiper-slide){scroll-snap-align:none}.swiper-css-mode.swiper-centered>.swiper-wrapper:before{content:"";flex-shrink:0;order:9999}.swiper-css-mode.swiper-centered ::slotted(swiper-slide){scroll-snap-align:center center;scroll-snap-stop:always}.swiper-css-mode.swiper-centered.swiper-horizontal ::slotted(swiper-slide):first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper:before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-css-mode.swiper-centered.swiper-vertical ::slotted(swiper-slide):first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper:before{height:var(--swiper-centered-offset-after);min-width:1px;width:100%}.swiper-virtual ::slotted(swiper-slide){-webkit-backface-visibility:hidden;transform:translateZ(0)}.swiper-virtual.swiper-css-mode .swiper-wrapper:after{content:"";left:0;pointer-events:none;position:absolute;top:0}.swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper:after{height:1px;width:var(--swiper-virtual-size)}.swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper:after{height:var(--swiper-virtual-size);width:1px}:host{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{align-items:center;color:var(--swiper-navigation-color,var(--swiper-theme-color));cursor:pointer;display:flex;height:var(--swiper-navigation-size);justify-content:center;position:absolute;width:var(--swiper-navigation-size);z-index:10}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{cursor:auto;opacity:.35;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{cursor:auto;opacity:0;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next svg,.swiper-button-prev svg{height:100%;object-fit:contain;transform-origin:center;width:100%;fill:currentColor;pointer-events:none}.swiper-button-lock{display:none}.swiper-button-next,.swiper-button-prev{margin-top:calc(0px - var(--swiper-navigation-size)/2);top:var(--swiper-navigation-top-offset,50%)}.swiper-button-prev{left:var(--swiper-navigation-sides-offset,4px);right:auto}.swiper-button-prev .swiper-navigation-icon{transform:rotate(180deg)}.swiper-button-next{left:auto;right:var(--swiper-navigation-sides-offset,4px)}.swiper-horizontal .swiper-button-next,.swiper-horizontal .swiper-button-prev,.swiper-horizontal~.swiper-button-next,.swiper-horizontal~.swiper-button-prev{margin-left:0;margin-top:calc(0px - var(--swiper-navigation-size)/2);top:var(--swiper-navigation-top-offset,50%)}.swiper-horizontal .swiper-button-prev,.swiper-horizontal.swiper-rtl .swiper-button-next,.swiper-horizontal.swiper-rtl~.swiper-button-next,.swiper-horizontal~.swiper-button-prev{left:var(--swiper-navigation-sides-offset,4px);right:auto}.swiper-horizontal .swiper-button-next,.swiper-horizontal.swiper-rtl .swiper-button-prev,.swiper-horizontal.swiper-rtl~.swiper-button-prev,.swiper-horizontal~.swiper-button-next{left:auto;right:var(--swiper-navigation-sides-offset,4px)}.swiper-horizontal .swiper-button-prev .swiper-navigation-icon,.swiper-horizontal.swiper-rtl .swiper-button-next .swiper-navigation-icon,.swiper-horizontal.swiper-rtl~.swiper-button-next .swiper-navigation-icon,.swiper-horizontal~.swiper-button-prev .swiper-navigation-icon{transform:rotate(180deg)}.swiper-horizontal.swiper-rtl .swiper-button-prev .swiper-navigation-icon,.swiper-horizontal.swiper-rtl~.swiper-button-prev .swiper-navigation-icon{transform:rotate(0deg)}.swiper-vertical .swiper-button-next,.swiper-vertical .swiper-button-prev,.swiper-vertical~.swiper-button-next,.swiper-vertical~.swiper-button-prev{left:var(--swiper-navigation-top-offset,50%);margin-left:calc(0px - var(--swiper-navigation-size)/2);margin-top:0;right:auto}.swiper-vertical .swiper-button-prev,.swiper-vertical~.swiper-button-prev{bottom:auto;top:var(--swiper-navigation-sides-offset,4px)}.swiper-vertical .swiper-button-prev .swiper-navigation-icon,.swiper-vertical~.swiper-button-prev .swiper-navigation-icon{transform:rotate(-90deg)}.swiper-vertical .swiper-button-next,.swiper-vertical~.swiper-button-next{bottom:var(--swiper-navigation-sides-offset,4px);top:auto}.swiper-vertical .swiper-button-next .swiper-navigation-icon,.swiper-vertical~.swiper-button-next .swiper-navigation-icon{transform:rotate(90deg)}.swiper-pagination{position:absolute;text-align:center;transform:translateZ(0);transition:opacity .3s;z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:var(--swiper-pagination-bottom,8px);left:0;top:var(--swiper-pagination-top,auto);width:100%}.swiper-pagination-bullets-dynamic{font-size:0;overflow:hidden}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{position:relative;transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active,.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{background:var(--swiper-pagination-bullet-inactive-color,#000);border-radius:var(--swiper-pagination-bullet-border-radius,50%);display:inline-block;height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));opacity:var(--swiper-pagination-bullet-inactive-opacity,.2);width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px))}button.swiper-pagination-bullet{appearance:none;border:none;box-shadow:none;margin:0;padding:0}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{background:var(--swiper-pagination-color,var(--swiper-theme-color));opacity:var(--swiper-pagination-bullet-opacity,1)}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{left:var(--swiper-pagination-left,auto);right:var(--swiper-pagination-right,8px);top:50%;transform:translate3d(0,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{display:block;margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:transform .2s,top .2s}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:transform .2s,left .2s}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:transform .2s,right .2s}.swiper-pagination-fraction{color:var(--swiper-pagination-fraction-color,inherit)}.swiper-pagination-progressbar{background:var(--swiper-pagination-progressbar-bg-color,#00000040);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));height:100%;left:0;position:absolute;top:0;transform:scale(0);transform-origin:left top;width:100%}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{height:var(--swiper-pagination-progressbar-size,4px);left:0;top:0;width:100%}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{height:100%;left:0;top:0;width:var(--swiper-pagination-progressbar-size,4px)}.swiper-pagination-lock{display:none}.swiper-scrollbar{background:var(--swiper-scrollbar-bg-color,#0000001a);border-radius:var(--swiper-scrollbar-border-radius,10px);position:relative;touch-action:none}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{bottom:var(--swiper-scrollbar-bottom,4px);height:var(--swiper-scrollbar-size,4px);left:var(--swiper-scrollbar-sides-offset,1%);position:absolute;top:var(--swiper-scrollbar-top,auto);width:calc(100% - var(--swiper-scrollbar-sides-offset, 1%)*2);z-index:50}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{height:calc(100% - var(--swiper-scrollbar-sides-offset, 1%)*2);left:var(--swiper-scrollbar-left,auto);position:absolute;right:var(--swiper-scrollbar-right,4px);top:var(--swiper-scrollbar-sides-offset,1%);width:var(--swiper-scrollbar-size,4px);z-index:50}.swiper-scrollbar-drag{background:var(--swiper-scrollbar-drag-bg-color,#00000080);border-radius:var(--swiper-scrollbar-border-radius,10px);height:100%;left:0;position:relative;top:0;width:100%}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}::slotted(.swiper-slide-zoomed){cursor:move;touch-action:none}.swiper .swiper-notification{left:0;opacity:0;pointer-events:none;position:absolute;top:0;z-index:-1000}.swiper-free-mode>.swiper-wrapper{margin:0 auto;transition-timing-function:ease-out}.swiper-grid>.swiper-wrapper{flex-wrap:wrap}.swiper-grid-column>.swiper-wrapper{flex-direction:column;flex-wrap:wrap}.swiper-fade.swiper-free-mode ::slotted(swiper-slide){transition-timing-function:ease-out}.swiper-fade ::slotted(swiper-slide){pointer-events:none;transition-property:opacity}.swiper-fade ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-fade ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-fade ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper.swiper-cube{overflow:visible}.swiper-cube ::slotted(swiper-slide){backface-visibility:hidden;height:100%;pointer-events:none;transform-origin:0 0;visibility:hidden;width:100%;z-index:1}.swiper-cube ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-cube.swiper-rtl ::slotted(swiper-slide){transform-origin:100% 0}.swiper-cube ::slotted(.swiper-slide-active),.swiper-cube ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-cube ::slotted(.swiper-slide-active),.swiper-cube ::slotted(.swiper-slide-next),.swiper-cube ::slotted(.swiper-slide-prev){pointer-events:auto;visibility:visible}.swiper-cube .swiper-cube-shadow{bottom:0;height:100%;left:0;opacity:.6;position:absolute;width:100%;z-index:0}.swiper-cube .swiper-cube-shadow:before{background:#000;bottom:0;content:"";filter:blur(50px);left:0;position:absolute;right:0;top:0}.swiper-cube ::slotted(.swiper-slide-next)+::slotted(swiper-slide){pointer-events:auto;visibility:visible}.swiper.swiper-flip{overflow:visible}.swiper-flip ::slotted(swiper-slide){backface-visibility:hidden;pointer-events:none;z-index:1}.swiper-flip ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-flip ::slotted(.swiper-slide-active),.swiper-flip ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-creative ::slotted(swiper-slide){backface-visibility:hidden;overflow:hidden;transition-property:transform,opacity,height}.swiper.swiper-cards{overflow:visible}.swiper-cards ::slotted(swiper-slide){backface-visibility:hidden;overflow:hidden;transform-origin:center bottom}';
const SwiperSlideCSS = "::slotted(.swiper-slide-shadow),::slotted(.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-top){height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%;z-index:10}::slotted(.swiper-slide-shadow){background:#00000026}::slotted(.swiper-slide-shadow-left){background-image:linear-gradient(270deg,#00000080,#0000)}::slotted(.swiper-slide-shadow-right){background-image:linear-gradient(90deg,#00000080,#0000)}::slotted(.swiper-slide-shadow-top){background-image:linear-gradient(0deg,#00000080,#0000)}::slotted(.swiper-slide-shadow-bottom){background-image:linear-gradient(180deg,#00000080,#0000)}.swiper-lazy-preloader{animation:swiper-preloader-spin 1s linear infinite;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top:4px solid #0000;box-sizing:border-box;height:42px;left:50%;margin-left:-21px;margin-top:-21px;position:absolute;top:50%;transform-origin:50%;width:42px;z-index:10}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-top){backface-visibility:hidden;z-index:0}::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-top){backface-visibility:hidden;z-index:0}::slotted(.swiper-zoom-container){align-items:center;display:flex;height:100%;justify-content:center;text-align:center;width:100%}::slotted(.swiper-zoom-container)>canvas,::slotted(.swiper-zoom-container)>img,::slotted(.swiper-zoom-container)>svg{max-height:100%;max-width:100%;object-fit:contain}";
class DummyHTMLElement {
}
const ClassToExtend = typeof window === "undefined" || typeof HTMLElement === "undefined" ? DummyHTMLElement : HTMLElement;
const addStyle = (shadowRoot, styles2) => {
  if (typeof CSSStyleSheet !== "undefined" && shadowRoot.adoptedStyleSheets) {
    const styleSheet = new CSSStyleSheet();
    styleSheet.replaceSync(styles2);
    shadowRoot.adoptedStyleSheets = [styleSheet];
  } else {
    const style = document.createElement("style");
    style.rel = "stylesheet";
    style.textContent = styles2;
    shadowRoot.appendChild(style);
  }
};
class SwiperContainer extends ClassToExtend {
  constructor() {
    super();
    this.attachShadow({
      mode: "open"
    });
  }
  static get nextButtonSvg() {
    return arrowSvg;
  }
  static get prevButtonSvg() {
    return arrowSvg.replace("/></svg>", ' transform-origin="center" transform="rotate(180)"/></svg>');
  }
  cssStyles() {
    return [
      SwiperCSS,
      // eslint-disable-line
      ...this.injectStyles && Array.isArray(this.injectStyles) ? this.injectStyles : []
    ].join("\n");
  }
  cssLinks() {
    return this.injectStylesUrls || [];
  }
  calcSlideSlots() {
    const currentSideSlots = this.slideSlots || 0;
    const slideSlotChildren = [...this.querySelectorAll("[slot^=slide-]")].map((child) => {
      return parseInt(child.getAttribute("slot").split("slide-")[1], 10);
    });
    this.slideSlots = slideSlotChildren.length ? Math.max(...slideSlotChildren) + 1 : 0;
    if (!this.rendered) return;
    if (this.slideSlots > currentSideSlots) {
      for (let i2 = currentSideSlots; i2 < this.slideSlots; i2 += 1) {
        const slideEl = document.createElement("swiper-slide");
        slideEl.setAttribute("part", "slide slide-".concat(i2 + 1));
        const slotEl = document.createElement("slot");
        slotEl.setAttribute("name", "slide-".concat(i2 + 1));
        slideEl.appendChild(slotEl);
        this.shadowRoot.querySelector(".swiper-wrapper").appendChild(slideEl);
      }
    } else if (this.slideSlots < currentSideSlots) {
      const slides = this.swiper.slides;
      for (let i2 = slides.length - 1; i2 >= 0; i2 -= 1) {
        if (i2 > this.slideSlots) {
          slides[i2].remove();
        }
      }
    }
  }
  render() {
    if (this.rendered) return;
    this.calcSlideSlots();
    let localStyles = this.cssStyles();
    if (this.slideSlots > 0) {
      localStyles = localStyles.replace(/::slotted\(([a-z-0-9.]*)\)/g, "$1");
    }
    if (localStyles.length) {
      addStyle(this.shadowRoot, localStyles);
    }
    this.cssLinks().forEach((url) => {
      const linkExists = this.shadowRoot.querySelector('link[href="'.concat(url, '"]'));
      if (linkExists) return;
      const linkEl = document.createElement("link");
      linkEl.rel = "stylesheet";
      linkEl.href = url;
      this.shadowRoot.appendChild(linkEl);
    });
    const el = document.createElement("div");
    el.classList.add("swiper");
    el.part = "container";
    setInnerHTML(el, '\n      <slot name="container-start"></slot>\n      <div class="swiper-wrapper" part="wrapper">\n        <slot></slot>\n        '.concat(Array.from({
      length: this.slideSlots
    }).map((_23, index) => '\n        <swiper-slide part="slide slide-'.concat(index, '">\n          <slot name="slide-').concat(index, '"></slot>\n        </swiper-slide>\n        ')).join(""), '\n      </div>\n      <slot name="container-end"></slot>\n      ').concat(needsNavigation(this.passedParams) ? '\n        <div part="button-prev" class="swiper-button-prev"></div>\n        <div part="button-next" class="swiper-button-next"></div>\n      ' : "", "\n      ").concat(needsPagination(this.passedParams) ? '\n        <div part="pagination" class="swiper-pagination"></div>\n      ' : "", "\n      ").concat(needsScrollbar(this.passedParams) ? '\n        <div part="scrollbar" class="swiper-scrollbar"></div>\n      ' : "", "\n    "));
    this.shadowRoot.appendChild(el);
    this.rendered = true;
  }
  initialize() {
    if (this.swiper && this.swiper.initialized) return;
    const {
      params: swiperParams,
      passedParams
    } = getParams(this);
    this.swiperParams = swiperParams;
    this.passedParams = passedParams;
    delete this.swiperParams.init;
    this.render();
    this.swiper = new Swiper$1(this.shadowRoot.querySelector(".swiper"), {
      ...swiperParams.virtual ? {} : {
        observer: true
      },
      ...swiperParams,
      touchEventsTarget: "container",
      onAny: (name, ...args) => {
        if (name === "observerUpdate") {
          this.calcSlideSlots();
        }
        const eventName = swiperParams.eventsPrefix ? "".concat(swiperParams.eventsPrefix).concat(name.toLowerCase()) : name.toLowerCase();
        const event2 = new CustomEvent(eventName, {
          detail: args,
          bubbles: name !== "hashChange",
          cancelable: true
        });
        this.dispatchEvent(event2);
      }
    });
  }
  connectedCallback() {
    if (this.swiper && this.swiper.initialized && this.nested && this.closest("swiper-slide") && this.closest("swiper-slide").swiperLoopMoveDOM) {
      return;
    }
    if (this.init === false || this.getAttribute("init") === "false") {
      return;
    }
    this.initialize();
  }
  disconnectedCallback() {
    if (this.nested && this.closest("swiper-slide") && this.closest("swiper-slide").swiperLoopMoveDOM) {
      return;
    }
    if (this.swiper && this.swiper.destroy) {
      this.swiper.destroy();
    }
  }
  updateSwiperOnPropChange(propName, propValue) {
    const {
      params: swiperParams,
      passedParams
    } = getParams(this, propName, propValue);
    this.passedParams = passedParams;
    this.swiperParams = swiperParams;
    if (this.swiper && this.swiper.params[propName] === propValue) {
      return;
    }
    updateSwiper({
      swiper: this.swiper,
      passedParams: this.passedParams,
      changedParams: [attrToProp(propName)],
      ...propName === "navigation" && passedParams[propName] ? {
        prevEl: ".swiper-button-prev",
        nextEl: ".swiper-button-next"
      } : {},
      ...propName === "pagination" && passedParams[propName] ? {
        paginationEl: ".swiper-pagination"
      } : {},
      ...propName === "scrollbar" && passedParams[propName] ? {
        scrollbarEl: ".swiper-scrollbar"
      } : {}
    });
  }
  attributeChangedCallback(attr, prevValue, newValue) {
    if (!(this.swiper && this.swiper.initialized)) return;
    if (prevValue === "true" && newValue === null) {
      newValue = false;
    }
    this.updateSwiperOnPropChange(attr, newValue);
  }
  static get observedAttributes() {
    const attrs = paramsList.filter((param) => param.includes("_")).map((param) => param.replace(/[A-Z]/g, (v2) => "-".concat(v2)).replace("_", "").toLowerCase());
    return attrs;
  }
}
paramsList.forEach((paramName) => {
  if (paramName === "init") return;
  paramName = paramName.replace("_", "");
  Object.defineProperty(SwiperContainer.prototype, paramName, {
    configurable: true,
    get() {
      return (this.passedParams || {})[paramName];
    },
    set(value) {
      if (!this.passedParams) this.passedParams = {};
      this.passedParams[paramName] = value;
      if (!(this.swiper && this.swiper.initialized)) return;
      this.updateSwiperOnPropChange(paramName, value);
    }
  });
});
class SwiperSlide extends ClassToExtend {
  constructor() {
    super();
    this.attachShadow({
      mode: "open"
    });
  }
  render() {
    const lazy = this.lazy || this.getAttribute("lazy") === "" || this.getAttribute("lazy") === "true";
    addStyle(this.shadowRoot, SwiperSlideCSS);
    this.shadowRoot.appendChild(document.createElement("slot"));
    if (lazy) {
      const lazyDiv = document.createElement("div");
      lazyDiv.classList.add("swiper-lazy-preloader");
      lazyDiv.part.add("preloader");
      this.shadowRoot.appendChild(lazyDiv);
    }
  }
  initialize() {
    this.render();
  }
  connectedCallback() {
    if (this.swiperLoopMoveDOM) {
      return;
    }
    this.initialize();
  }
}
const register = () => {
  if (typeof window === "undefined") return;
  if (!window.customElements.get("swiper-container")) window.customElements.define("swiper-container", SwiperContainer);
  if (!window.customElements.get("swiper-slide")) window.customElements.define("swiper-slide", SwiperSlide);
};
if (typeof window !== "undefined") {
  window.SwiperElementRegisterParams = (params) => {
    paramsList.push(...params);
  };
}
/*!
 * Cropper.js v1.6.2
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2024-04-21T07:43:05.335Z
 */
function ownKeys$3(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r22) {
      return Object.getOwnPropertyDescriptor(e2, r22).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$3(Object(t2), true).forEach(function(r22) {
      _defineProperty$4(e2, r22, t2[r22]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$3(Object(t2)).forEach(function(r22) {
      Object.defineProperty(e2, r22, Object.getOwnPropertyDescriptor(t2, r22));
    });
  }
  return e2;
}
function _toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t2);
}
function _toPropertyKey(t2) {
  var i2 = _toPrimitive(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _typeof$2(o2) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$2(o2);
}
function _classCallCheck$1(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty$4(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toConsumableArray$1(arr2) {
  return _arrayWithoutHoles$1(arr2) || _iterableToArray$1(arr2) || _unsupportedIterableToArray(arr2) || _nonIterableSpread$1();
}
function _arrayWithoutHoles$1(arr2) {
  if (Array.isArray(arr2)) return _arrayLikeToArray(arr2);
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr2, len) {
  if (len == null || len > arr2.length) len = arr2.length;
  for (var i2 = 0, arr22 = new Array(len); i2 < len; i2++) arr22[i2] = arr2[i2];
  return arr22;
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined";
var WINDOW = IS_BROWSER ? window : {};
var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? "ontouchstart" in WINDOW.document.documentElement : false;
var HAS_POINTER_EVENT = IS_BROWSER ? "PointerEvent" in WINDOW : false;
var NAMESPACE = "cropper";
var ACTION_ALL = "all";
var ACTION_CROP = "crop";
var ACTION_MOVE = "move";
var ACTION_ZOOM = "zoom";
var ACTION_EAST = "e";
var ACTION_WEST = "w";
var ACTION_SOUTH = "s";
var ACTION_NORTH = "n";
var ACTION_NORTH_EAST = "ne";
var ACTION_NORTH_WEST = "nw";
var ACTION_SOUTH_EAST = "se";
var ACTION_SOUTH_WEST = "sw";
var CLASS_CROP = "".concat(NAMESPACE, "-crop");
var CLASS_DISABLED = "".concat(NAMESPACE, "-disabled");
var CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden");
var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
var CLASS_MODAL = "".concat(NAMESPACE, "-modal");
var CLASS_MOVE = "".concat(NAMESPACE, "-move");
var DATA_ACTION = "".concat(NAMESPACE, "Action");
var DATA_PREVIEW = "".concat(NAMESPACE, "Preview");
var DRAG_MODE_CROP = "crop";
var DRAG_MODE_MOVE = "move";
var DRAG_MODE_NONE = "none";
var EVENT_CROP = "crop";
var EVENT_CROP_END = "cropend";
var EVENT_CROP_MOVE = "cropmove";
var EVENT_CROP_START = "cropstart";
var EVENT_DBLCLICK = "dblclick";
var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? "touchstart" : "mousedown";
var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? "touchmove" : "mousemove";
var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? "touchend touchcancel" : "mouseup";
var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? "pointerdown" : EVENT_TOUCH_START;
var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? "pointermove" : EVENT_TOUCH_MOVE;
var EVENT_POINTER_UP = HAS_POINTER_EVENT ? "pointerup pointercancel" : EVENT_TOUCH_END;
var EVENT_READY = "ready";
var EVENT_RESIZE = "resize";
var EVENT_WHEEL = "wheel";
var EVENT_ZOOM = "zoom";
var MIME_TYPE_JPEG = "image/jpeg";
var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;
var REGEXP_DATA_URL = /^data:/;
var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
var REGEXP_TAG_NAME = /^img|canvas$/i;
var MIN_CONTAINER_WIDTH = 200;
var MIN_CONTAINER_HEIGHT = 100;
var DEFAULTS = {
  // Define the view mode of the cropper
  viewMode: 0,
  // 0, 1, 2, 3
  // Define the dragging mode of the cropper
  dragMode: DRAG_MODE_CROP,
  // 'crop', 'move' or 'none'
  // Define the initial aspect ratio of the crop box
  initialAspectRatio: NaN,
  // Define the aspect ratio of the crop box
  aspectRatio: NaN,
  // An object with the previous cropping result data
  data: null,
  // A selector for adding extra containers to preview
  preview: "",
  // Re-render the cropper when resize the window
  responsive: true,
  // Restore the cropped area after resize the window
  restore: true,
  // Check if the current image is a cross-origin image
  checkCrossOrigin: true,
  // Check the current image's Exif Orientation information
  checkOrientation: true,
  // Show the black modal
  modal: true,
  // Show the dashed lines for guiding
  guides: true,
  // Show the center indicator for guiding
  center: true,
  // Show the white modal to highlight the crop box
  highlight: true,
  // Show the grid background
  background: true,
  // Enable to crop the image automatically when initialize
  autoCrop: true,
  // Define the percentage of automatic cropping area when initializes
  autoCropArea: 0.8,
  // Enable to move the image
  movable: true,
  // Enable to rotate the image
  rotatable: true,
  // Enable to scale the image
  scalable: true,
  // Enable to zoom the image
  zoomable: true,
  // Enable to zoom the image by dragging touch
  zoomOnTouch: true,
  // Enable to zoom the image by wheeling mouse
  zoomOnWheel: true,
  // Define zoom ratio when zoom the image by wheeling mouse
  wheelZoomRatio: 0.1,
  // Enable to move the crop box
  cropBoxMovable: true,
  // Enable to resize the crop box
  cropBoxResizable: true,
  // Toggle drag mode between "crop" and "move" when click twice on the cropper
  toggleDragModeOnDblclick: true,
  // Size limitation
  minCanvasWidth: 0,
  minCanvasHeight: 0,
  minCropBoxWidth: 0,
  minCropBoxHeight: 0,
  minContainerWidth: MIN_CONTAINER_WIDTH,
  minContainerHeight: MIN_CONTAINER_HEIGHT,
  // Shortcuts of events
  ready: null,
  cropstart: null,
  cropmove: null,
  cropend: null,
  crop: null,
  zoom: null
};
var TEMPLATE = '<div class="cropper-container" touch-action="none"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-cropper-action="e"></span><span class="cropper-line line-n" data-cropper-action="n"></span><span class="cropper-line line-w" data-cropper-action="w"></span><span class="cropper-line line-s" data-cropper-action="s"></span><span class="cropper-point point-e" data-cropper-action="e"></span><span class="cropper-point point-n" data-cropper-action="n"></span><span class="cropper-point point-w" data-cropper-action="w"></span><span class="cropper-point point-s" data-cropper-action="s"></span><span class="cropper-point point-ne" data-cropper-action="ne"></span><span class="cropper-point point-nw" data-cropper-action="nw"></span><span class="cropper-point point-sw" data-cropper-action="sw"></span><span class="cropper-point point-se" data-cropper-action="se"></span></div></div>';
var isNaN$1 = Number.isNaN || WINDOW.isNaN;
function isNumber(value) {
  return typeof value === "number" && !isNaN$1(value);
}
var isPositiveNumber = function isPositiveNumber2(value) {
  return value > 0 && value < Infinity;
};
function isUndefined(value) {
  return typeof value === "undefined";
}
function isObject(value) {
  return _typeof$2(value) === "object" && value !== null;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isPlainObject(value) {
  if (!isObject(value)) {
    return false;
  }
  try {
    var _constructor = value.constructor;
    var prototype = _constructor.prototype;
    return _constructor && prototype && hasOwnProperty.call(prototype, "isPrototypeOf");
  } catch (error2) {
    return false;
  }
}
function isFunction(value) {
  return typeof value === "function";
}
var slice3 = Array.prototype.slice;
function toArray2(value) {
  return Array.from ? Array.from(value) : slice3.call(value);
}
function forEach2(data, callback) {
  if (data && isFunction(callback)) {
    if (Array.isArray(data) || isNumber(data.length)) {
      toArray2(data).forEach(function(value, key) {
        callback.call(data, value, key, data);
      });
    } else if (isObject(data)) {
      Object.keys(data).forEach(function(key) {
        callback.call(data, data[key], key, data);
      });
    }
  }
  return data;
}
var assign = Object.assign || function assign2(target) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (isObject(target) && args.length > 0) {
    args.forEach(function(arg) {
      if (isObject(arg)) {
        Object.keys(arg).forEach(function(key) {
          target[key] = arg[key];
        });
      }
    });
  }
  return target;
};
var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
function normalizeDecimalNumber(value) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11;
  return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
}
var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;
function setStyle(element, styles2) {
  var style = element.style;
  forEach2(styles2, function(value, property) {
    if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
      value = "".concat(value, "px");
    }
    style[property] = value;
  });
}
function hasClass(element, value) {
  return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
}
function addClass(element, value) {
  if (!value) {
    return;
  }
  if (isNumber(element.length)) {
    forEach2(element, function(elem) {
      addClass(elem, value);
    });
    return;
  }
  if (element.classList) {
    element.classList.add(value);
    return;
  }
  var className = element.className.trim();
  if (!className) {
    element.className = value;
  } else if (className.indexOf(value) < 0) {
    element.className = "".concat(className, " ").concat(value);
  }
}
function removeClass(element, value) {
  if (!value) {
    return;
  }
  if (isNumber(element.length)) {
    forEach2(element, function(elem) {
      removeClass(elem, value);
    });
    return;
  }
  if (element.classList) {
    element.classList.remove(value);
    return;
  }
  if (element.className.indexOf(value) >= 0) {
    element.className = element.className.replace(value, "");
  }
}
function toggleClass(element, value, added) {
  if (!value) {
    return;
  }
  if (isNumber(element.length)) {
    forEach2(element, function(elem) {
      toggleClass(elem, value, added);
    });
    return;
  }
  if (added) {
    addClass(element, value);
  } else {
    removeClass(element, value);
  }
}
var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g;
function toParamCase(value) {
  return value.replace(REGEXP_CAMEL_CASE, "$1-$2").toLowerCase();
}
function getData(element, name) {
  if (isObject(element[name])) {
    return element[name];
  }
  if (element.dataset) {
    return element.dataset[name];
  }
  return element.getAttribute("data-".concat(toParamCase(name)));
}
function setData(element, name, data) {
  if (isObject(data)) {
    element[name] = data;
  } else if (element.dataset) {
    element.dataset[name] = data;
  } else {
    element.setAttribute("data-".concat(toParamCase(name)), data);
  }
}
function removeData(element, name) {
  if (isObject(element[name])) {
    try {
      delete element[name];
    } catch (error2) {
      element[name] = void 0;
    }
  } else if (element.dataset) {
    try {
      delete element.dataset[name];
    } catch (error2) {
      element.dataset[name] = void 0;
    }
  } else {
    element.removeAttribute("data-".concat(toParamCase(name)));
  }
}
var REGEXP_SPACES = /\s\s*/;
var onceSupported = (function() {
  var supported = false;
  if (IS_BROWSER) {
    var once = false;
    var listener = function listener2() {
    };
    var options = Object.defineProperty({}, "once", {
      get: function get11() {
        supported = true;
        return once;
      },
      /**
       * This setter can fix a `TypeError` in strict mode
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
       * @param {boolean} value - The value to set
       */
      set: function set3(value) {
        once = value;
      }
    });
    WINDOW.addEventListener("test", listener, options);
    WINDOW.removeEventListener("test", listener, options);
  }
  return supported;
})();
function removeListener(element, type, listener) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var handler = listener;
  type.trim().split(REGEXP_SPACES).forEach(function(event2) {
    if (!onceSupported) {
      var listeners = element.listeners;
      if (listeners && listeners[event2] && listeners[event2][listener]) {
        handler = listeners[event2][listener];
        delete listeners[event2][listener];
        if (Object.keys(listeners[event2]).length === 0) {
          delete listeners[event2];
        }
        if (Object.keys(listeners).length === 0) {
          delete element.listeners;
        }
      }
    }
    element.removeEventListener(event2, handler, options);
  });
}
function addListener(element, type, listener) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var _handler = listener;
  type.trim().split(REGEXP_SPACES).forEach(function(event2) {
    if (options.once && !onceSupported) {
      var _element$listeners = element.listeners, listeners = _element$listeners === void 0 ? {} : _element$listeners;
      _handler = function handler() {
        delete listeners[event2][listener];
        element.removeEventListener(event2, _handler, options);
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        listener.apply(element, args);
      };
      if (!listeners[event2]) {
        listeners[event2] = {};
      }
      if (listeners[event2][listener]) {
        element.removeEventListener(event2, listeners[event2][listener], options);
      }
      listeners[event2][listener] = _handler;
      element.listeners = listeners;
    }
    element.addEventListener(event2, _handler, options);
  });
}
function dispatchEvent(element, type, data) {
  var event2;
  if (isFunction(Event) && isFunction(CustomEvent)) {
    event2 = new CustomEvent(type, {
      detail: data,
      bubbles: true,
      cancelable: true
    });
  } else {
    event2 = document.createEvent("CustomEvent");
    event2.initCustomEvent(type, true, true, data);
  }
  return element.dispatchEvent(event2);
}
function getOffset(element) {
  var box = element.getBoundingClientRect();
  return {
    left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
    top: box.top + (window.pageYOffset - document.documentElement.clientTop)
  };
}
var location = WINDOW.location;
var REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
function isCrossOriginURL(url) {
  var parts = url.match(REGEXP_ORIGINS);
  return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
}
function addTimestamp(url) {
  var timestamp = "timestamp=".concat((/* @__PURE__ */ new Date()).getTime());
  return url + (url.indexOf("?") === -1 ? "?" : "&") + timestamp;
}
function getTransforms(_ref) {
  var rotate2 = _ref.rotate, scaleX2 = _ref.scaleX, scaleY2 = _ref.scaleY, translateX = _ref.translateX, translateY = _ref.translateY;
  var values2 = [];
  if (isNumber(translateX) && translateX !== 0) {
    values2.push("translateX(".concat(translateX, "px)"));
  }
  if (isNumber(translateY) && translateY !== 0) {
    values2.push("translateY(".concat(translateY, "px)"));
  }
  if (isNumber(rotate2) && rotate2 !== 0) {
    values2.push("rotate(".concat(rotate2, "deg)"));
  }
  if (isNumber(scaleX2) && scaleX2 !== 1) {
    values2.push("scaleX(".concat(scaleX2, ")"));
  }
  if (isNumber(scaleY2) && scaleY2 !== 1) {
    values2.push("scaleY(".concat(scaleY2, ")"));
  }
  var transform = values2.length ? values2.join(" ") : "none";
  return {
    WebkitTransform: transform,
    msTransform: transform,
    transform
  };
}
function getMaxZoomRatio(pointers) {
  var pointers2 = _objectSpread2({}, pointers);
  var maxRatio = 0;
  forEach2(pointers, function(pointer, pointerId) {
    delete pointers2[pointerId];
    forEach2(pointers2, function(pointer2) {
      var x1 = Math.abs(pointer.startX - pointer2.startX);
      var y1 = Math.abs(pointer.startY - pointer2.startY);
      var x2 = Math.abs(pointer.endX - pointer2.endX);
      var y2 = Math.abs(pointer.endY - pointer2.endY);
      var z1 = Math.sqrt(x1 * x1 + y1 * y1);
      var z2 = Math.sqrt(x2 * x2 + y2 * y2);
      var ratio = (z2 - z1) / z1;
      if (Math.abs(ratio) > Math.abs(maxRatio)) {
        maxRatio = ratio;
      }
    });
  });
  return maxRatio;
}
function getPointer(_ref2, endOnly) {
  var pageX = _ref2.pageX, pageY = _ref2.pageY;
  var end = {
    endX: pageX,
    endY: pageY
  };
  return endOnly ? end : _objectSpread2({
    startX: pageX,
    startY: pageY
  }, end);
}
function getPointersCenter(pointers) {
  var pageX = 0;
  var pageY = 0;
  var count2 = 0;
  forEach2(pointers, function(_ref3) {
    var startX = _ref3.startX, startY = _ref3.startY;
    pageX += startX;
    pageY += startY;
    count2 += 1;
  });
  pageX /= count2;
  pageY /= count2;
  return {
    pageX,
    pageY
  };
}
function getAdjustedSizes(_ref4) {
  var aspectRatio = _ref4.aspectRatio, height = _ref4.height, width = _ref4.width;
  var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "contain";
  var isValidWidth = isPositiveNumber(width);
  var isValidHeight = isPositiveNumber(height);
  if (isValidWidth && isValidHeight) {
    var adjustedWidth = height * aspectRatio;
    if (type === "contain" && adjustedWidth > width || type === "cover" && adjustedWidth < width) {
      height = width / aspectRatio;
    } else {
      width = height * aspectRatio;
    }
  } else if (isValidWidth) {
    height = width / aspectRatio;
  } else if (isValidHeight) {
    width = height * aspectRatio;
  }
  return {
    width,
    height
  };
}
function getRotatedSizes(_ref5) {
  var width = _ref5.width, height = _ref5.height, degree = _ref5.degree;
  degree = Math.abs(degree) % 180;
  if (degree === 90) {
    return {
      width: height,
      height: width
    };
  }
  var arc = degree % 90 * Math.PI / 180;
  var sinArc = Math.sin(arc);
  var cosArc = Math.cos(arc);
  var newWidth = width * cosArc + height * sinArc;
  var newHeight = width * sinArc + height * cosArc;
  return degree > 90 ? {
    width: newHeight,
    height: newWidth
  } : {
    width: newWidth,
    height: newHeight
  };
}
function getSourceCanvas(image, _ref6, _ref7, _ref8) {
  var imageAspectRatio = _ref6.aspectRatio, imageNaturalWidth = _ref6.naturalWidth, imageNaturalHeight = _ref6.naturalHeight, _ref6$rotate = _ref6.rotate, rotate2 = _ref6$rotate === void 0 ? 0 : _ref6$rotate, _ref6$scaleX = _ref6.scaleX, scaleX2 = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX, _ref6$scaleY = _ref6.scaleY, scaleY2 = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;
  var aspectRatio = _ref7.aspectRatio, naturalWidth = _ref7.naturalWidth, naturalHeight = _ref7.naturalHeight;
  var _ref8$fillColor = _ref8.fillColor, fillColor = _ref8$fillColor === void 0 ? "transparent" : _ref8$fillColor, _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled, imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE, _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality, imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? "low" : _ref8$imageSmoothingQ, _ref8$maxWidth = _ref8.maxWidth, maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth, _ref8$maxHeight = _ref8.maxHeight, maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight, _ref8$minWidth = _ref8.minWidth, minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth, _ref8$minHeight = _ref8.minHeight, minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;
  var canvas = document.createElement("canvas");
  var context2 = canvas.getContext("2d");
  var maxSizes = getAdjustedSizes({
    aspectRatio,
    width: maxWidth,
    height: maxHeight
  });
  var minSizes = getAdjustedSizes({
    aspectRatio,
    width: minWidth,
    height: minHeight
  }, "cover");
  var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
  var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight));
  var destMaxSizes = getAdjustedSizes({
    aspectRatio: imageAspectRatio,
    width: maxWidth,
    height: maxHeight
  });
  var destMinSizes = getAdjustedSizes({
    aspectRatio: imageAspectRatio,
    width: minWidth,
    height: minHeight
  }, "cover");
  var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));
  var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));
  var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];
  canvas.width = normalizeDecimalNumber(width);
  canvas.height = normalizeDecimalNumber(height);
  context2.fillStyle = fillColor;
  context2.fillRect(0, 0, width, height);
  context2.save();
  context2.translate(width / 2, height / 2);
  context2.rotate(rotate2 * Math.PI / 180);
  context2.scale(scaleX2, scaleY2);
  context2.imageSmoothingEnabled = imageSmoothingEnabled;
  context2.imageSmoothingQuality = imageSmoothingQuality;
  context2.drawImage.apply(context2, [image].concat(_toConsumableArray$1(params.map(function(param) {
    return Math.floor(normalizeDecimalNumber(param));
  }))));
  context2.restore();
  return canvas;
}
var fromCharCode = String.fromCharCode;
function getStringFromCharCode(dataView, start, length) {
  var str = "";
  length += start;
  for (var i2 = start; i2 < length; i2 += 1) {
    str += fromCharCode(dataView.getUint8(i2));
  }
  return str;
}
var REGEXP_DATA_URL_HEAD = /^data:.*,/;
function dataURLToArrayBuffer(dataURL) {
  var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, "");
  var binary = atob(base64);
  var arrayBuffer = new ArrayBuffer(binary.length);
  var uint8 = new Uint8Array(arrayBuffer);
  forEach2(uint8, function(value, i2) {
    uint8[i2] = binary.charCodeAt(i2);
  });
  return arrayBuffer;
}
function arrayBufferToDataURL(arrayBuffer, mimeType) {
  var chunks = [];
  var chunkSize = 8192;
  var uint8 = new Uint8Array(arrayBuffer);
  while (uint8.length > 0) {
    chunks.push(fromCharCode.apply(null, toArray2(uint8.subarray(0, chunkSize))));
    uint8 = uint8.subarray(chunkSize);
  }
  return "data:".concat(mimeType, ";base64,").concat(btoa(chunks.join("")));
}
function resetAndGetOrientation(arrayBuffer) {
  var dataView = new DataView(arrayBuffer);
  var orientation;
  try {
    var littleEndian;
    var app1Start;
    var ifdStart;
    if (dataView.getUint8(0) === 255 && dataView.getUint8(1) === 216) {
      var length = dataView.byteLength;
      var offset = 2;
      while (offset + 1 < length) {
        if (dataView.getUint8(offset) === 255 && dataView.getUint8(offset + 1) === 225) {
          app1Start = offset;
          break;
        }
        offset += 1;
      }
    }
    if (app1Start) {
      var exifIDCode = app1Start + 4;
      var tiffOffset = app1Start + 10;
      if (getStringFromCharCode(dataView, exifIDCode, 4) === "Exif") {
        var endianness = dataView.getUint16(tiffOffset);
        littleEndian = endianness === 18761;
        if (littleEndian || endianness === 19789) {
          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 42) {
            var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
            if (firstIFDOffset >= 8) {
              ifdStart = tiffOffset + firstIFDOffset;
            }
          }
        }
      }
    }
    if (ifdStart) {
      var _length = dataView.getUint16(ifdStart, littleEndian);
      var _offset;
      var i2;
      for (i2 = 0; i2 < _length; i2 += 1) {
        _offset = ifdStart + i2 * 12 + 2;
        if (dataView.getUint16(_offset, littleEndian) === 274) {
          _offset += 8;
          orientation = dataView.getUint16(_offset, littleEndian);
          dataView.setUint16(_offset, 1, littleEndian);
          break;
        }
      }
    }
  } catch (error2) {
    orientation = 1;
  }
  return orientation;
}
function parseOrientation(orientation) {
  var rotate2 = 0;
  var scaleX2 = 1;
  var scaleY2 = 1;
  switch (orientation) {
    // Flip horizontal
    case 2:
      scaleX2 = -1;
      break;
    // Rotate left 180
    case 3:
      rotate2 = -180;
      break;
    // Flip vertical
    case 4:
      scaleY2 = -1;
      break;
    // Flip vertical and rotate right 90
    case 5:
      rotate2 = 90;
      scaleY2 = -1;
      break;
    // Rotate right 90
    case 6:
      rotate2 = 90;
      break;
    // Flip horizontal and rotate right 90
    case 7:
      rotate2 = 90;
      scaleX2 = -1;
      break;
    // Rotate left 90
    case 8:
      rotate2 = -90;
      break;
  }
  return {
    rotate: rotate2,
    scaleX: scaleX2,
    scaleY: scaleY2
  };
}
var render = {
  render: function render2() {
    this.initContainer();
    this.initCanvas();
    this.initCropBox();
    this.renderCanvas();
    if (this.cropped) {
      this.renderCropBox();
    }
  },
  initContainer: function initContainer() {
    var element = this.element, options = this.options, container = this.container, cropper = this.cropper;
    var minWidth = Number(options.minContainerWidth);
    var minHeight = Number(options.minContainerHeight);
    addClass(cropper, CLASS_HIDDEN);
    removeClass(element, CLASS_HIDDEN);
    var containerData = {
      width: Math.max(container.offsetWidth, minWidth >= 0 ? minWidth : MIN_CONTAINER_WIDTH),
      height: Math.max(container.offsetHeight, minHeight >= 0 ? minHeight : MIN_CONTAINER_HEIGHT)
    };
    this.containerData = containerData;
    setStyle(cropper, {
      width: containerData.width,
      height: containerData.height
    });
    addClass(element, CLASS_HIDDEN);
    removeClass(cropper, CLASS_HIDDEN);
  },
  // Canvas (image wrapper)
  initCanvas: function initCanvas() {
    var containerData = this.containerData, imageData = this.imageData;
    var viewMode = this.options.viewMode;
    var rotated = Math.abs(imageData.rotate) % 180 === 90;
    var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
    var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
    var aspectRatio = naturalWidth / naturalHeight;
    var canvasWidth = containerData.width;
    var canvasHeight = containerData.height;
    if (containerData.height * aspectRatio > containerData.width) {
      if (viewMode === 3) {
        canvasWidth = containerData.height * aspectRatio;
      } else {
        canvasHeight = containerData.width / aspectRatio;
      }
    } else if (viewMode === 3) {
      canvasHeight = containerData.width / aspectRatio;
    } else {
      canvasWidth = containerData.height * aspectRatio;
    }
    var canvasData = {
      aspectRatio,
      naturalWidth,
      naturalHeight,
      width: canvasWidth,
      height: canvasHeight
    };
    this.canvasData = canvasData;
    this.limited = viewMode === 1 || viewMode === 2;
    this.limitCanvas(true, true);
    canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
    canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
    canvasData.left = (containerData.width - canvasData.width) / 2;
    canvasData.top = (containerData.height - canvasData.height) / 2;
    canvasData.oldLeft = canvasData.left;
    canvasData.oldTop = canvasData.top;
    this.initialCanvasData = assign({}, canvasData);
  },
  limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
    var options = this.options, containerData = this.containerData, canvasData = this.canvasData, cropBoxData = this.cropBoxData;
    var viewMode = options.viewMode;
    var aspectRatio = canvasData.aspectRatio;
    var cropped = this.cropped && cropBoxData;
    if (sizeLimited) {
      var minCanvasWidth = Number(options.minCanvasWidth) || 0;
      var minCanvasHeight = Number(options.minCanvasHeight) || 0;
      if (viewMode > 1) {
        minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
        minCanvasHeight = Math.max(minCanvasHeight, containerData.height);
        if (viewMode === 3) {
          if (minCanvasHeight * aspectRatio > minCanvasWidth) {
            minCanvasWidth = minCanvasHeight * aspectRatio;
          } else {
            minCanvasHeight = minCanvasWidth / aspectRatio;
          }
        }
      } else if (viewMode > 0) {
        if (minCanvasWidth) {
          minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
        } else if (minCanvasHeight) {
          minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
        } else if (cropped) {
          minCanvasWidth = cropBoxData.width;
          minCanvasHeight = cropBoxData.height;
          if (minCanvasHeight * aspectRatio > minCanvasWidth) {
            minCanvasWidth = minCanvasHeight * aspectRatio;
          } else {
            minCanvasHeight = minCanvasWidth / aspectRatio;
          }
        }
      }
      var _getAdjustedSizes = getAdjustedSizes({
        aspectRatio,
        width: minCanvasWidth,
        height: minCanvasHeight
      });
      minCanvasWidth = _getAdjustedSizes.width;
      minCanvasHeight = _getAdjustedSizes.height;
      canvasData.minWidth = minCanvasWidth;
      canvasData.minHeight = minCanvasHeight;
      canvasData.maxWidth = Infinity;
      canvasData.maxHeight = Infinity;
    }
    if (positionLimited) {
      if (viewMode > (cropped ? 0 : 1)) {
        var newCanvasLeft = containerData.width - canvasData.width;
        var newCanvasTop = containerData.height - canvasData.height;
        canvasData.minLeft = Math.min(0, newCanvasLeft);
        canvasData.minTop = Math.min(0, newCanvasTop);
        canvasData.maxLeft = Math.max(0, newCanvasLeft);
        canvasData.maxTop = Math.max(0, newCanvasTop);
        if (cropped && this.limited) {
          canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
          canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
          canvasData.maxLeft = cropBoxData.left;
          canvasData.maxTop = cropBoxData.top;
          if (viewMode === 2) {
            if (canvasData.width >= containerData.width) {
              canvasData.minLeft = Math.min(0, newCanvasLeft);
              canvasData.maxLeft = Math.max(0, newCanvasLeft);
            }
            if (canvasData.height >= containerData.height) {
              canvasData.minTop = Math.min(0, newCanvasTop);
              canvasData.maxTop = Math.max(0, newCanvasTop);
            }
          }
        }
      } else {
        canvasData.minLeft = -canvasData.width;
        canvasData.minTop = -canvasData.height;
        canvasData.maxLeft = containerData.width;
        canvasData.maxTop = containerData.height;
      }
    }
  },
  renderCanvas: function renderCanvas(changed, transformed) {
    var canvasData = this.canvasData, imageData = this.imageData;
    if (transformed) {
      var _getRotatedSizes = getRotatedSizes({
        width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),
        height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),
        degree: imageData.rotate || 0
      }), naturalWidth = _getRotatedSizes.width, naturalHeight = _getRotatedSizes.height;
      var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);
      var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);
      canvasData.left -= (width - canvasData.width) / 2;
      canvasData.top -= (height - canvasData.height) / 2;
      canvasData.width = width;
      canvasData.height = height;
      canvasData.aspectRatio = naturalWidth / naturalHeight;
      canvasData.naturalWidth = naturalWidth;
      canvasData.naturalHeight = naturalHeight;
      this.limitCanvas(true, false);
    }
    if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
      canvasData.left = canvasData.oldLeft;
    }
    if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
      canvasData.top = canvasData.oldTop;
    }
    canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
    canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
    this.limitCanvas(false, true);
    canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
    canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
    canvasData.oldLeft = canvasData.left;
    canvasData.oldTop = canvasData.top;
    setStyle(this.canvas, assign({
      width: canvasData.width,
      height: canvasData.height
    }, getTransforms({
      translateX: canvasData.left,
      translateY: canvasData.top
    })));
    this.renderImage(changed);
    if (this.cropped && this.limited) {
      this.limitCropBox(true, true);
    }
  },
  renderImage: function renderImage(changed) {
    var canvasData = this.canvasData, imageData = this.imageData;
    var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);
    var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);
    assign(imageData, {
      width,
      height,
      left: (canvasData.width - width) / 2,
      top: (canvasData.height - height) / 2
    });
    setStyle(this.image, assign({
      width: imageData.width,
      height: imageData.height
    }, getTransforms(assign({
      translateX: imageData.left,
      translateY: imageData.top
    }, imageData))));
    if (changed) {
      this.output();
    }
  },
  initCropBox: function initCropBox() {
    var options = this.options, canvasData = this.canvasData;
    var aspectRatio = options.aspectRatio || options.initialAspectRatio;
    var autoCropArea = Number(options.autoCropArea) || 0.8;
    var cropBoxData = {
      width: canvasData.width,
      height: canvasData.height
    };
    if (aspectRatio) {
      if (canvasData.height * aspectRatio > canvasData.width) {
        cropBoxData.height = cropBoxData.width / aspectRatio;
      } else {
        cropBoxData.width = cropBoxData.height * aspectRatio;
      }
    }
    this.cropBoxData = cropBoxData;
    this.limitCropBox(true, true);
    cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
    cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
    cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
    cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
    cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
    cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
    cropBoxData.oldLeft = cropBoxData.left;
    cropBoxData.oldTop = cropBoxData.top;
    this.initialCropBoxData = assign({}, cropBoxData);
  },
  limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
    var options = this.options, containerData = this.containerData, canvasData = this.canvasData, cropBoxData = this.cropBoxData, limited = this.limited;
    var aspectRatio = options.aspectRatio;
    if (sizeLimited) {
      var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
      var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
      var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;
      var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height;
      minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
      minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);
      if (aspectRatio) {
        if (minCropBoxWidth && minCropBoxHeight) {
          if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
            minCropBoxHeight = minCropBoxWidth / aspectRatio;
          } else {
            minCropBoxWidth = minCropBoxHeight * aspectRatio;
          }
        } else if (minCropBoxWidth) {
          minCropBoxHeight = minCropBoxWidth / aspectRatio;
        } else if (minCropBoxHeight) {
          minCropBoxWidth = minCropBoxHeight * aspectRatio;
        }
        if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
          maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
        } else {
          maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
        }
      }
      cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
      cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
      cropBoxData.maxWidth = maxCropBoxWidth;
      cropBoxData.maxHeight = maxCropBoxHeight;
    }
    if (positionLimited) {
      if (limited) {
        cropBoxData.minLeft = Math.max(0, canvasData.left);
        cropBoxData.minTop = Math.max(0, canvasData.top);
        cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
        cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
      } else {
        cropBoxData.minLeft = 0;
        cropBoxData.minTop = 0;
        cropBoxData.maxLeft = containerData.width - cropBoxData.width;
        cropBoxData.maxTop = containerData.height - cropBoxData.height;
      }
    }
  },
  renderCropBox: function renderCropBox() {
    var options = this.options, containerData = this.containerData, cropBoxData = this.cropBoxData;
    if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
      cropBoxData.left = cropBoxData.oldLeft;
    }
    if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
      cropBoxData.top = cropBoxData.oldTop;
    }
    cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
    cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
    this.limitCropBox(false, true);
    cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
    cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
    cropBoxData.oldLeft = cropBoxData.left;
    cropBoxData.oldTop = cropBoxData.top;
    if (options.movable && options.cropBoxMovable) {
      setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);
    }
    setStyle(this.cropBox, assign({
      width: cropBoxData.width,
      height: cropBoxData.height
    }, getTransforms({
      translateX: cropBoxData.left,
      translateY: cropBoxData.top
    })));
    if (this.cropped && this.limited) {
      this.limitCanvas(true, true);
    }
    if (!this.disabled) {
      this.output();
    }
  },
  output: function output2() {
    this.preview();
    dispatchEvent(this.element, EVENT_CROP, this.getData());
  }
};
var preview = {
  initPreview: function initPreview() {
    var element = this.element, crossOrigin = this.crossOrigin;
    var preview3 = this.options.preview;
    var url = crossOrigin ? this.crossOriginUrl : this.url;
    var alt = element.alt || "The image to preview";
    var image = document.createElement("img");
    if (crossOrigin) {
      image.crossOrigin = crossOrigin;
    }
    image.src = url;
    image.alt = alt;
    this.viewBox.appendChild(image);
    this.viewBoxImage = image;
    if (!preview3) {
      return;
    }
    var previews = preview3;
    if (typeof preview3 === "string") {
      previews = element.ownerDocument.querySelectorAll(preview3);
    } else if (preview3.querySelector) {
      previews = [preview3];
    }
    this.previews = previews;
    forEach2(previews, function(el) {
      var img = document.createElement("img");
      setData(el, DATA_PREVIEW, {
        width: el.offsetWidth,
        height: el.offsetHeight,
        html: el.innerHTML
      });
      if (crossOrigin) {
        img.crossOrigin = crossOrigin;
      }
      img.src = url;
      img.alt = alt;
      img.style.cssText = 'display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;"';
      el.innerHTML = "";
      el.appendChild(img);
    });
  },
  resetPreview: function resetPreview() {
    forEach2(this.previews, function(element) {
      var data = getData(element, DATA_PREVIEW);
      setStyle(element, {
        width: data.width,
        height: data.height
      });
      element.innerHTML = data.html;
      removeData(element, DATA_PREVIEW);
    });
  },
  preview: function preview2() {
    var imageData = this.imageData, canvasData = this.canvasData, cropBoxData = this.cropBoxData;
    var cropBoxWidth = cropBoxData.width, cropBoxHeight = cropBoxData.height;
    var width = imageData.width, height = imageData.height;
    var left = cropBoxData.left - canvasData.left - imageData.left;
    var top = cropBoxData.top - canvasData.top - imageData.top;
    if (!this.cropped || this.disabled) {
      return;
    }
    setStyle(this.viewBoxImage, assign({
      width,
      height
    }, getTransforms(assign({
      translateX: -left,
      translateY: -top
    }, imageData))));
    forEach2(this.previews, function(element) {
      var data = getData(element, DATA_PREVIEW);
      var originalWidth = data.width;
      var originalHeight = data.height;
      var newWidth = originalWidth;
      var newHeight = originalHeight;
      var ratio = 1;
      if (cropBoxWidth) {
        ratio = originalWidth / cropBoxWidth;
        newHeight = cropBoxHeight * ratio;
      }
      if (cropBoxHeight && newHeight > originalHeight) {
        ratio = originalHeight / cropBoxHeight;
        newWidth = cropBoxWidth * ratio;
        newHeight = originalHeight;
      }
      setStyle(element, {
        width: newWidth,
        height: newHeight
      });
      setStyle(element.getElementsByTagName("img")[0], assign({
        width: width * ratio,
        height: height * ratio
      }, getTransforms(assign({
        translateX: -left * ratio,
        translateY: -top * ratio
      }, imageData))));
    });
  }
};
var events$3 = {
  bind: function bind() {
    var element = this.element, options = this.options, cropper = this.cropper;
    if (isFunction(options.cropstart)) {
      addListener(element, EVENT_CROP_START, options.cropstart);
    }
    if (isFunction(options.cropmove)) {
      addListener(element, EVENT_CROP_MOVE, options.cropmove);
    }
    if (isFunction(options.cropend)) {
      addListener(element, EVENT_CROP_END, options.cropend);
    }
    if (isFunction(options.crop)) {
      addListener(element, EVENT_CROP, options.crop);
    }
    if (isFunction(options.zoom)) {
      addListener(element, EVENT_ZOOM, options.zoom);
    }
    addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));
    if (options.zoomable && options.zoomOnWheel) {
      addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
        passive: false,
        capture: true
      });
    }
    if (options.toggleDragModeOnDblclick) {
      addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
    }
    addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));
    addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));
    if (options.responsive) {
      addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
    }
  },
  unbind: function unbind() {
    var element = this.element, options = this.options, cropper = this.cropper;
    if (isFunction(options.cropstart)) {
      removeListener(element, EVENT_CROP_START, options.cropstart);
    }
    if (isFunction(options.cropmove)) {
      removeListener(element, EVENT_CROP_MOVE, options.cropmove);
    }
    if (isFunction(options.cropend)) {
      removeListener(element, EVENT_CROP_END, options.cropend);
    }
    if (isFunction(options.crop)) {
      removeListener(element, EVENT_CROP, options.crop);
    }
    if (isFunction(options.zoom)) {
      removeListener(element, EVENT_ZOOM, options.zoom);
    }
    removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);
    if (options.zoomable && options.zoomOnWheel) {
      removeListener(cropper, EVENT_WHEEL, this.onWheel, {
        passive: false,
        capture: true
      });
    }
    if (options.toggleDragModeOnDblclick) {
      removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);
    }
    removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);
    removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);
    if (options.responsive) {
      removeListener(window, EVENT_RESIZE, this.onResize);
    }
  }
};
var handlers = {
  resize: function resize() {
    if (this.disabled) {
      return;
    }
    var options = this.options, container = this.container, containerData = this.containerData;
    var ratioX = container.offsetWidth / containerData.width;
    var ratioY = container.offsetHeight / containerData.height;
    var ratio = Math.abs(ratioX - 1) > Math.abs(ratioY - 1) ? ratioX : ratioY;
    if (ratio !== 1) {
      var canvasData;
      var cropBoxData;
      if (options.restore) {
        canvasData = this.getCanvasData();
        cropBoxData = this.getCropBoxData();
      }
      this.render();
      if (options.restore) {
        this.setCanvasData(forEach2(canvasData, function(n2, i2) {
          canvasData[i2] = n2 * ratio;
        }));
        this.setCropBoxData(forEach2(cropBoxData, function(n2, i2) {
          cropBoxData[i2] = n2 * ratio;
        }));
      }
    }
  },
  dblclick: function dblclick() {
    if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
      return;
    }
    this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
  },
  wheel: function wheel(event2) {
    var _this = this;
    var ratio = Number(this.options.wheelZoomRatio) || 0.1;
    var delta = 1;
    if (this.disabled) {
      return;
    }
    event2.preventDefault();
    if (this.wheeling) {
      return;
    }
    this.wheeling = true;
    setTimeout(function() {
      _this.wheeling = false;
    }, 50);
    if (event2.deltaY) {
      delta = event2.deltaY > 0 ? 1 : -1;
    } else if (event2.wheelDelta) {
      delta = -event2.wheelDelta / 120;
    } else if (event2.detail) {
      delta = event2.detail > 0 ? 1 : -1;
    }
    this.zoom(-delta * ratio, event2);
  },
  cropStart: function cropStart(event2) {
    var buttons = event2.buttons, button = event2.button;
    if (this.disabled || (event2.type === "mousedown" || event2.type === "pointerdown" && event2.pointerType === "mouse") && // No primary button (Usually the left button)
    (isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 || event2.ctrlKey)) {
      return;
    }
    var options = this.options, pointers = this.pointers;
    var action;
    if (event2.changedTouches) {
      forEach2(event2.changedTouches, function(touch) {
        pointers[touch.identifier] = getPointer(touch);
      });
    } else {
      pointers[event2.pointerId || 0] = getPointer(event2);
    }
    if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
      action = ACTION_ZOOM;
    } else {
      action = getData(event2.target, DATA_ACTION);
    }
    if (!REGEXP_ACTIONS.test(action)) {
      return;
    }
    if (dispatchEvent(this.element, EVENT_CROP_START, {
      originalEvent: event2,
      action
    }) === false) {
      return;
    }
    event2.preventDefault();
    this.action = action;
    this.cropping = false;
    if (action === ACTION_CROP) {
      this.cropping = true;
      addClass(this.dragBox, CLASS_MODAL);
    }
  },
  cropMove: function cropMove(event2) {
    var action = this.action;
    if (this.disabled || !action) {
      return;
    }
    var pointers = this.pointers;
    event2.preventDefault();
    if (dispatchEvent(this.element, EVENT_CROP_MOVE, {
      originalEvent: event2,
      action
    }) === false) {
      return;
    }
    if (event2.changedTouches) {
      forEach2(event2.changedTouches, function(touch) {
        assign(pointers[touch.identifier] || {}, getPointer(touch, true));
      });
    } else {
      assign(pointers[event2.pointerId || 0] || {}, getPointer(event2, true));
    }
    this.change(event2);
  },
  cropEnd: function cropEnd(event2) {
    if (this.disabled) {
      return;
    }
    var action = this.action, pointers = this.pointers;
    if (event2.changedTouches) {
      forEach2(event2.changedTouches, function(touch) {
        delete pointers[touch.identifier];
      });
    } else {
      delete pointers[event2.pointerId || 0];
    }
    if (!action) {
      return;
    }
    event2.preventDefault();
    if (!Object.keys(pointers).length) {
      this.action = "";
    }
    if (this.cropping) {
      this.cropping = false;
      toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);
    }
    dispatchEvent(this.element, EVENT_CROP_END, {
      originalEvent: event2,
      action
    });
  }
};
var change = {
  change: function change2(event2) {
    var options = this.options, canvasData = this.canvasData, containerData = this.containerData, cropBoxData = this.cropBoxData, pointers = this.pointers;
    var action = this.action;
    var aspectRatio = options.aspectRatio;
    var left = cropBoxData.left, top = cropBoxData.top, width = cropBoxData.width, height = cropBoxData.height;
    var right = left + width;
    var bottom = top + height;
    var minLeft = 0;
    var minTop = 0;
    var maxWidth = containerData.width;
    var maxHeight = containerData.height;
    var renderable = true;
    var offset;
    if (!aspectRatio && event2.shiftKey) {
      aspectRatio = width && height ? width / height : 1;
    }
    if (this.limited) {
      minLeft = cropBoxData.minLeft;
      minTop = cropBoxData.minTop;
      maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
      maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
    }
    var pointer = pointers[Object.keys(pointers)[0]];
    var range = {
      x: pointer.endX - pointer.startX,
      y: pointer.endY - pointer.startY
    };
    var check = function check2(side) {
      switch (side) {
        case ACTION_EAST:
          if (right + range.x > maxWidth) {
            range.x = maxWidth - right;
          }
          break;
        case ACTION_WEST:
          if (left + range.x < minLeft) {
            range.x = minLeft - left;
          }
          break;
        case ACTION_NORTH:
          if (top + range.y < minTop) {
            range.y = minTop - top;
          }
          break;
        case ACTION_SOUTH:
          if (bottom + range.y > maxHeight) {
            range.y = maxHeight - bottom;
          }
          break;
      }
    };
    switch (action) {
      // Move crop box
      case ACTION_ALL:
        left += range.x;
        top += range.y;
        break;
      // Resize crop box
      case ACTION_EAST:
        if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
          renderable = false;
          break;
        }
        check(ACTION_EAST);
        width += range.x;
        if (width < 0) {
          action = ACTION_WEST;
          width = -width;
          left -= width;
        }
        if (aspectRatio) {
          height = width / aspectRatio;
          top += (cropBoxData.height - height) / 2;
        }
        break;
      case ACTION_NORTH:
        if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
          renderable = false;
          break;
        }
        check(ACTION_NORTH);
        height -= range.y;
        top += range.y;
        if (height < 0) {
          action = ACTION_SOUTH;
          height = -height;
          top -= height;
        }
        if (aspectRatio) {
          width = height * aspectRatio;
          left += (cropBoxData.width - width) / 2;
        }
        break;
      case ACTION_WEST:
        if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
          renderable = false;
          break;
        }
        check(ACTION_WEST);
        width -= range.x;
        left += range.x;
        if (width < 0) {
          action = ACTION_EAST;
          width = -width;
          left -= width;
        }
        if (aspectRatio) {
          height = width / aspectRatio;
          top += (cropBoxData.height - height) / 2;
        }
        break;
      case ACTION_SOUTH:
        if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
          renderable = false;
          break;
        }
        check(ACTION_SOUTH);
        height += range.y;
        if (height < 0) {
          action = ACTION_NORTH;
          height = -height;
          top -= height;
        }
        if (aspectRatio) {
          width = height * aspectRatio;
          left += (cropBoxData.width - width) / 2;
        }
        break;
      case ACTION_NORTH_EAST:
        if (aspectRatio) {
          if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
            renderable = false;
            break;
          }
          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;
          width = height * aspectRatio;
        } else {
          check(ACTION_NORTH);
          check(ACTION_EAST);
          if (range.x >= 0) {
            if (right < maxWidth) {
              width += range.x;
            } else if (range.y <= 0 && top <= minTop) {
              renderable = false;
            }
          } else {
            width += range.x;
          }
          if (range.y <= 0) {
            if (top > minTop) {
              height -= range.y;
              top += range.y;
            }
          } else {
            height -= range.y;
            top += range.y;
          }
        }
        if (width < 0 && height < 0) {
          action = ACTION_SOUTH_WEST;
          height = -height;
          width = -width;
          top -= height;
          left -= width;
        } else if (width < 0) {
          action = ACTION_NORTH_WEST;
          width = -width;
          left -= width;
        } else if (height < 0) {
          action = ACTION_SOUTH_EAST;
          height = -height;
          top -= height;
        }
        break;
      case ACTION_NORTH_WEST:
        if (aspectRatio) {
          if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
            renderable = false;
            break;
          }
          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;
          width = height * aspectRatio;
          left += cropBoxData.width - width;
        } else {
          check(ACTION_NORTH);
          check(ACTION_WEST);
          if (range.x <= 0) {
            if (left > minLeft) {
              width -= range.x;
              left += range.x;
            } else if (range.y <= 0 && top <= minTop) {
              renderable = false;
            }
          } else {
            width -= range.x;
            left += range.x;
          }
          if (range.y <= 0) {
            if (top > minTop) {
              height -= range.y;
              top += range.y;
            }
          } else {
            height -= range.y;
            top += range.y;
          }
        }
        if (width < 0 && height < 0) {
          action = ACTION_SOUTH_EAST;
          height = -height;
          width = -width;
          top -= height;
          left -= width;
        } else if (width < 0) {
          action = ACTION_NORTH_EAST;
          width = -width;
          left -= width;
        } else if (height < 0) {
          action = ACTION_SOUTH_WEST;
          height = -height;
          top -= height;
        }
        break;
      case ACTION_SOUTH_WEST:
        if (aspectRatio) {
          if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
            renderable = false;
            break;
          }
          check(ACTION_WEST);
          width -= range.x;
          left += range.x;
          height = width / aspectRatio;
        } else {
          check(ACTION_SOUTH);
          check(ACTION_WEST);
          if (range.x <= 0) {
            if (left > minLeft) {
              width -= range.x;
              left += range.x;
            } else if (range.y >= 0 && bottom >= maxHeight) {
              renderable = false;
            }
          } else {
            width -= range.x;
            left += range.x;
          }
          if (range.y >= 0) {
            if (bottom < maxHeight) {
              height += range.y;
            }
          } else {
            height += range.y;
          }
        }
        if (width < 0 && height < 0) {
          action = ACTION_NORTH_EAST;
          height = -height;
          width = -width;
          top -= height;
          left -= width;
        } else if (width < 0) {
          action = ACTION_SOUTH_EAST;
          width = -width;
          left -= width;
        } else if (height < 0) {
          action = ACTION_NORTH_WEST;
          height = -height;
          top -= height;
        }
        break;
      case ACTION_SOUTH_EAST:
        if (aspectRatio) {
          if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
            renderable = false;
            break;
          }
          check(ACTION_EAST);
          width += range.x;
          height = width / aspectRatio;
        } else {
          check(ACTION_SOUTH);
          check(ACTION_EAST);
          if (range.x >= 0) {
            if (right < maxWidth) {
              width += range.x;
            } else if (range.y >= 0 && bottom >= maxHeight) {
              renderable = false;
            }
          } else {
            width += range.x;
          }
          if (range.y >= 0) {
            if (bottom < maxHeight) {
              height += range.y;
            }
          } else {
            height += range.y;
          }
        }
        if (width < 0 && height < 0) {
          action = ACTION_NORTH_WEST;
          height = -height;
          width = -width;
          top -= height;
          left -= width;
        } else if (width < 0) {
          action = ACTION_SOUTH_WEST;
          width = -width;
          left -= width;
        } else if (height < 0) {
          action = ACTION_NORTH_EAST;
          height = -height;
          top -= height;
        }
        break;
      // Move canvas
      case ACTION_MOVE:
        this.move(range.x, range.y);
        renderable = false;
        break;
      // Zoom canvas
      case ACTION_ZOOM:
        this.zoom(getMaxZoomRatio(pointers), event2);
        renderable = false;
        break;
      // Create crop box
      case ACTION_CROP:
        if (!range.x || !range.y) {
          renderable = false;
          break;
        }
        offset = getOffset(this.cropper);
        left = pointer.startX - offset.left;
        top = pointer.startY - offset.top;
        width = cropBoxData.minWidth;
        height = cropBoxData.minHeight;
        if (range.x > 0) {
          action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
        } else if (range.x < 0) {
          left -= width;
          action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
        }
        if (range.y < 0) {
          top -= height;
        }
        if (!this.cropped) {
          removeClass(this.cropBox, CLASS_HIDDEN);
          this.cropped = true;
          if (this.limited) {
            this.limitCropBox(true, true);
          }
        }
        break;
    }
    if (renderable) {
      cropBoxData.width = width;
      cropBoxData.height = height;
      cropBoxData.left = left;
      cropBoxData.top = top;
      this.action = action;
      this.renderCropBox();
    }
    forEach2(pointers, function(p2) {
      p2.startX = p2.endX;
      p2.startY = p2.endY;
    });
  }
};
var methods = {
  // Show the crop box manually
  crop: function crop() {
    if (this.ready && !this.cropped && !this.disabled) {
      this.cropped = true;
      this.limitCropBox(true, true);
      if (this.options.modal) {
        addClass(this.dragBox, CLASS_MODAL);
      }
      removeClass(this.cropBox, CLASS_HIDDEN);
      this.setCropBoxData(this.initialCropBoxData);
    }
    return this;
  },
  // Reset the image and crop box to their initial states
  reset: function reset() {
    if (this.ready && !this.disabled) {
      this.imageData = assign({}, this.initialImageData);
      this.canvasData = assign({}, this.initialCanvasData);
      this.cropBoxData = assign({}, this.initialCropBoxData);
      this.renderCanvas();
      if (this.cropped) {
        this.renderCropBox();
      }
    }
    return this;
  },
  // Clear the crop box
  clear: function clear2() {
    if (this.cropped && !this.disabled) {
      assign(this.cropBoxData, {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      });
      this.cropped = false;
      this.renderCropBox();
      this.limitCanvas(true, true);
      this.renderCanvas();
      removeClass(this.dragBox, CLASS_MODAL);
      addClass(this.cropBox, CLASS_HIDDEN);
    }
    return this;
  },
  /**
   * Replace the image's src and rebuild the cropper
   * @param {string} url - The new URL.
   * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
   * @returns {Cropper} this
   */
  replace: function replace(url) {
    var hasSameSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!this.disabled && url) {
      if (this.isImg) {
        this.element.src = url;
      }
      if (hasSameSize) {
        this.url = url;
        this.image.src = url;
        if (this.ready) {
          this.viewBoxImage.src = url;
          forEach2(this.previews, function(element) {
            element.getElementsByTagName("img")[0].src = url;
          });
        }
      } else {
        if (this.isImg) {
          this.replaced = true;
        }
        this.options.data = null;
        this.uncreate();
        this.load(url);
      }
    }
    return this;
  },
  // Enable (unfreeze) the cropper
  enable: function enable() {
    if (this.ready && this.disabled) {
      this.disabled = false;
      removeClass(this.cropper, CLASS_DISABLED);
    }
    return this;
  },
  // Disable (freeze) the cropper
  disable: function disable() {
    if (this.ready && !this.disabled) {
      this.disabled = true;
      addClass(this.cropper, CLASS_DISABLED);
    }
    return this;
  },
  /**
   * Destroy the cropper and remove the instance from the image
   * @returns {Cropper} this
   */
  destroy: function destroy() {
    var element = this.element;
    if (!element[NAMESPACE]) {
      return this;
    }
    element[NAMESPACE] = void 0;
    if (this.isImg && this.replaced) {
      element.src = this.originalUrl;
    }
    this.uncreate();
    return this;
  },
  /**
   * Move the canvas with relative offsets
   * @param {number} offsetX - The relative offset distance on the x-axis.
   * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
   * @returns {Cropper} this
   */
  move: function move(offsetX) {
    var offsetY = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : offsetX;
    var _this$canvasData = this.canvasData, left = _this$canvasData.left, top = _this$canvasData.top;
    return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));
  },
  /**
   * Move the canvas to an absolute point
   * @param {number} x - The x-axis coordinate.
   * @param {number} [y=x] - The y-axis coordinate.
   * @returns {Cropper} this
   */
  moveTo: function moveTo(x2) {
    var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : x2;
    var canvasData = this.canvasData;
    var changed = false;
    x2 = Number(x2);
    y2 = Number(y2);
    if (this.ready && !this.disabled && this.options.movable) {
      if (isNumber(x2)) {
        canvasData.left = x2;
        changed = true;
      }
      if (isNumber(y2)) {
        canvasData.top = y2;
        changed = true;
      }
      if (changed) {
        this.renderCanvas(true);
      }
    }
    return this;
  },
  /**
   * Zoom the canvas with a relative ratio
   * @param {number} ratio - The target ratio.
   * @param {Event} _originalEvent - The original event if any.
   * @returns {Cropper} this
   */
  zoom: function zoom(ratio, _originalEvent) {
    var canvasData = this.canvasData;
    ratio = Number(ratio);
    if (ratio < 0) {
      ratio = 1 / (1 - ratio);
    } else {
      ratio = 1 + ratio;
    }
    return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);
  },
  /**
   * Zoom the canvas to an absolute ratio
   * @param {number} ratio - The target ratio.
   * @param {Object} pivot - The zoom pivot point coordinate.
   * @param {Event} _originalEvent - The original event if any.
   * @returns {Cropper} this
   */
  zoomTo: function zoomTo(ratio, pivot, _originalEvent) {
    var options = this.options, canvasData = this.canvasData;
    var width = canvasData.width, height = canvasData.height, naturalWidth = canvasData.naturalWidth, naturalHeight = canvasData.naturalHeight;
    ratio = Number(ratio);
    if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
      var newWidth = naturalWidth * ratio;
      var newHeight = naturalHeight * ratio;
      if (dispatchEvent(this.element, EVENT_ZOOM, {
        ratio,
        oldRatio: width / naturalWidth,
        originalEvent: _originalEvent
      }) === false) {
        return this;
      }
      if (_originalEvent) {
        var pointers = this.pointers;
        var offset = getOffset(this.cropper);
        var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
          pageX: _originalEvent.pageX,
          pageY: _originalEvent.pageY
        };
        canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);
        canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);
      } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {
        canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);
        canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);
      } else {
        canvasData.left -= (newWidth - width) / 2;
        canvasData.top -= (newHeight - height) / 2;
      }
      canvasData.width = newWidth;
      canvasData.height = newHeight;
      this.renderCanvas(true);
    }
    return this;
  },
  /**
   * Rotate the canvas with a relative degree
   * @param {number} degree - The rotate degree.
   * @returns {Cropper} this
   */
  rotate: function rotate(degree) {
    return this.rotateTo((this.imageData.rotate || 0) + Number(degree));
  },
  /**
   * Rotate the canvas to an absolute degree
   * @param {number} degree - The rotate degree.
   * @returns {Cropper} this
   */
  rotateTo: function rotateTo(degree) {
    degree = Number(degree);
    if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {
      this.imageData.rotate = degree % 360;
      this.renderCanvas(true, true);
    }
    return this;
  },
  /**
   * Scale the image on the x-axis.
   * @param {number} scaleX - The scale ratio on the x-axis.
   * @returns {Cropper} this
   */
  scaleX: function scaleX(_scaleX) {
    var scaleY2 = this.imageData.scaleY;
    return this.scale(_scaleX, isNumber(scaleY2) ? scaleY2 : 1);
  },
  /**
   * Scale the image on the y-axis.
   * @param {number} scaleY - The scale ratio on the y-axis.
   * @returns {Cropper} this
   */
  scaleY: function scaleY(_scaleY) {
    var scaleX2 = this.imageData.scaleX;
    return this.scale(isNumber(scaleX2) ? scaleX2 : 1, _scaleY);
  },
  /**
   * Scale the image
   * @param {number} scaleX - The scale ratio on the x-axis.
   * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
   * @returns {Cropper} this
   */
  scale: function scale(scaleX2) {
    var scaleY2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : scaleX2;
    var imageData = this.imageData;
    var transformed = false;
    scaleX2 = Number(scaleX2);
    scaleY2 = Number(scaleY2);
    if (this.ready && !this.disabled && this.options.scalable) {
      if (isNumber(scaleX2)) {
        imageData.scaleX = scaleX2;
        transformed = true;
      }
      if (isNumber(scaleY2)) {
        imageData.scaleY = scaleY2;
        transformed = true;
      }
      if (transformed) {
        this.renderCanvas(true, true);
      }
    }
    return this;
  },
  /**
   * Get the cropped area position and size data (base on the original image)
   * @param {boolean} [rounded=false] - Indicate if round the data values or not.
   * @returns {Object} The result cropped data.
   */
  getData: function getData2() {
    var rounded = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var options = this.options, imageData = this.imageData, canvasData = this.canvasData, cropBoxData = this.cropBoxData;
    var data;
    if (this.ready && this.cropped) {
      data = {
        x: cropBoxData.left - canvasData.left,
        y: cropBoxData.top - canvasData.top,
        width: cropBoxData.width,
        height: cropBoxData.height
      };
      var ratio = imageData.width / imageData.naturalWidth;
      forEach2(data, function(n2, i2) {
        data[i2] = n2 / ratio;
      });
      if (rounded) {
        var bottom = Math.round(data.y + data.height);
        var right = Math.round(data.x + data.width);
        data.x = Math.round(data.x);
        data.y = Math.round(data.y);
        data.width = right - data.x;
        data.height = bottom - data.y;
      }
    } else {
      data = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
    if (options.rotatable) {
      data.rotate = imageData.rotate || 0;
    }
    if (options.scalable) {
      data.scaleX = imageData.scaleX || 1;
      data.scaleY = imageData.scaleY || 1;
    }
    return data;
  },
  /**
   * Set the cropped area position and size with new data
   * @param {Object} data - The new data.
   * @returns {Cropper} this
   */
  setData: function setData2(data) {
    var options = this.options, imageData = this.imageData, canvasData = this.canvasData;
    var cropBoxData = {};
    if (this.ready && !this.disabled && isPlainObject(data)) {
      var transformed = false;
      if (options.rotatable) {
        if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
          imageData.rotate = data.rotate;
          transformed = true;
        }
      }
      if (options.scalable) {
        if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
          imageData.scaleX = data.scaleX;
          transformed = true;
        }
        if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
          imageData.scaleY = data.scaleY;
          transformed = true;
        }
      }
      if (transformed) {
        this.renderCanvas(true, true);
      }
      var ratio = imageData.width / imageData.naturalWidth;
      if (isNumber(data.x)) {
        cropBoxData.left = data.x * ratio + canvasData.left;
      }
      if (isNumber(data.y)) {
        cropBoxData.top = data.y * ratio + canvasData.top;
      }
      if (isNumber(data.width)) {
        cropBoxData.width = data.width * ratio;
      }
      if (isNumber(data.height)) {
        cropBoxData.height = data.height * ratio;
      }
      this.setCropBoxData(cropBoxData);
    }
    return this;
  },
  /**
   * Get the container size data.
   * @returns {Object} The result container data.
   */
  getContainerData: function getContainerData() {
    return this.ready ? assign({}, this.containerData) : {};
  },
  /**
   * Get the image position and size data.
   * @returns {Object} The result image data.
   */
  getImageData: function getImageData() {
    return this.sized ? assign({}, this.imageData) : {};
  },
  /**
   * Get the canvas position and size data.
   * @returns {Object} The result canvas data.
   */
  getCanvasData: function getCanvasData() {
    var canvasData = this.canvasData;
    var data = {};
    if (this.ready) {
      forEach2(["left", "top", "width", "height", "naturalWidth", "naturalHeight"], function(n2) {
        data[n2] = canvasData[n2];
      });
    }
    return data;
  },
  /**
   * Set the canvas position and size with new data.
   * @param {Object} data - The new canvas data.
   * @returns {Cropper} this
   */
  setCanvasData: function setCanvasData(data) {
    var canvasData = this.canvasData;
    var aspectRatio = canvasData.aspectRatio;
    if (this.ready && !this.disabled && isPlainObject(data)) {
      if (isNumber(data.left)) {
        canvasData.left = data.left;
      }
      if (isNumber(data.top)) {
        canvasData.top = data.top;
      }
      if (isNumber(data.width)) {
        canvasData.width = data.width;
        canvasData.height = data.width / aspectRatio;
      } else if (isNumber(data.height)) {
        canvasData.height = data.height;
        canvasData.width = data.height * aspectRatio;
      }
      this.renderCanvas(true);
    }
    return this;
  },
  /**
   * Get the crop box position and size data.
   * @returns {Object} The result crop box data.
   */
  getCropBoxData: function getCropBoxData() {
    var cropBoxData = this.cropBoxData;
    var data;
    if (this.ready && this.cropped) {
      data = {
        left: cropBoxData.left,
        top: cropBoxData.top,
        width: cropBoxData.width,
        height: cropBoxData.height
      };
    }
    return data || {};
  },
  /**
   * Set the crop box position and size with new data.
   * @param {Object} data - The new crop box data.
   * @returns {Cropper} this
   */
  setCropBoxData: function setCropBoxData(data) {
    var cropBoxData = this.cropBoxData;
    var aspectRatio = this.options.aspectRatio;
    var widthChanged;
    var heightChanged;
    if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {
      if (isNumber(data.left)) {
        cropBoxData.left = data.left;
      }
      if (isNumber(data.top)) {
        cropBoxData.top = data.top;
      }
      if (isNumber(data.width) && data.width !== cropBoxData.width) {
        widthChanged = true;
        cropBoxData.width = data.width;
      }
      if (isNumber(data.height) && data.height !== cropBoxData.height) {
        heightChanged = true;
        cropBoxData.height = data.height;
      }
      if (aspectRatio) {
        if (widthChanged) {
          cropBoxData.height = cropBoxData.width / aspectRatio;
        } else if (heightChanged) {
          cropBoxData.width = cropBoxData.height * aspectRatio;
        }
      }
      this.renderCropBox();
    }
    return this;
  },
  /**
   * Get a canvas drawn the cropped image.
   * @param {Object} [options={}] - The config options.
   * @returns {HTMLCanvasElement} - The result canvas.
   */
  getCroppedCanvas: function getCroppedCanvas() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!this.ready || !window.HTMLCanvasElement) {
      return null;
    }
    var canvasData = this.canvasData;
    var source = getSourceCanvas(this.image, this.imageData, canvasData, options);
    if (!this.cropped) {
      return source;
    }
    var _this$getData = this.getData(options.rounded), initialX = _this$getData.x, initialY = _this$getData.y, initialWidth = _this$getData.width, initialHeight = _this$getData.height;
    var ratio = source.width / Math.floor(canvasData.naturalWidth);
    if (ratio !== 1) {
      initialX *= ratio;
      initialY *= ratio;
      initialWidth *= ratio;
      initialHeight *= ratio;
    }
    var aspectRatio = initialWidth / initialHeight;
    var maxSizes = getAdjustedSizes({
      aspectRatio,
      width: options.maxWidth || Infinity,
      height: options.maxHeight || Infinity
    });
    var minSizes = getAdjustedSizes({
      aspectRatio,
      width: options.minWidth || 0,
      height: options.minHeight || 0
    }, "cover");
    var _getAdjustedSizes = getAdjustedSizes({
      aspectRatio,
      width: options.width || (ratio !== 1 ? source.width : initialWidth),
      height: options.height || (ratio !== 1 ? source.height : initialHeight)
    }), width = _getAdjustedSizes.width, height = _getAdjustedSizes.height;
    width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
    height = Math.min(maxSizes.height, Math.max(minSizes.height, height));
    var canvas = document.createElement("canvas");
    var context2 = canvas.getContext("2d");
    canvas.width = normalizeDecimalNumber(width);
    canvas.height = normalizeDecimalNumber(height);
    context2.fillStyle = options.fillColor || "transparent";
    context2.fillRect(0, 0, width, height);
    var _options$imageSmoothi = options.imageSmoothingEnabled, imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi, imageSmoothingQuality = options.imageSmoothingQuality;
    context2.imageSmoothingEnabled = imageSmoothingEnabled;
    if (imageSmoothingQuality) {
      context2.imageSmoothingQuality = imageSmoothingQuality;
    }
    var sourceWidth = source.width;
    var sourceHeight = source.height;
    var srcX = initialX;
    var srcY = initialY;
    var srcWidth;
    var srcHeight;
    var dstX;
    var dstY;
    var dstWidth;
    var dstHeight;
    if (srcX <= -initialWidth || srcX > sourceWidth) {
      srcX = 0;
      srcWidth = 0;
      dstX = 0;
      dstWidth = 0;
    } else if (srcX <= 0) {
      dstX = -srcX;
      srcX = 0;
      srcWidth = Math.min(sourceWidth, initialWidth + srcX);
      dstWidth = srcWidth;
    } else if (srcX <= sourceWidth) {
      dstX = 0;
      srcWidth = Math.min(initialWidth, sourceWidth - srcX);
      dstWidth = srcWidth;
    }
    if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
      srcY = 0;
      srcHeight = 0;
      dstY = 0;
      dstHeight = 0;
    } else if (srcY <= 0) {
      dstY = -srcY;
      srcY = 0;
      srcHeight = Math.min(sourceHeight, initialHeight + srcY);
      dstHeight = srcHeight;
    } else if (srcY <= sourceHeight) {
      dstY = 0;
      srcHeight = Math.min(initialHeight, sourceHeight - srcY);
      dstHeight = srcHeight;
    }
    var params = [srcX, srcY, srcWidth, srcHeight];
    if (dstWidth > 0 && dstHeight > 0) {
      var scale2 = width / initialWidth;
      params.push(dstX * scale2, dstY * scale2, dstWidth * scale2, dstHeight * scale2);
    }
    context2.drawImage.apply(context2, [source].concat(_toConsumableArray$1(params.map(function(param) {
      return Math.floor(normalizeDecimalNumber(param));
    }))));
    return canvas;
  },
  /**
   * Change the aspect ratio of the crop box.
   * @param {number} aspectRatio - The new aspect ratio.
   * @returns {Cropper} this
   */
  setAspectRatio: function setAspectRatio(aspectRatio) {
    var options = this.options;
    if (!this.disabled && !isUndefined(aspectRatio)) {
      options.aspectRatio = Math.max(0, aspectRatio) || NaN;
      if (this.ready) {
        this.initCropBox();
        if (this.cropped) {
          this.renderCropBox();
        }
      }
    }
    return this;
  },
  /**
   * Change the drag mode.
   * @param {string} mode - The new drag mode.
   * @returns {Cropper} this
   */
  setDragMode: function setDragMode(mode) {
    var options = this.options, dragBox = this.dragBox, face = this.face;
    if (this.ready && !this.disabled) {
      var croppable = mode === DRAG_MODE_CROP;
      var movable = options.movable && mode === DRAG_MODE_MOVE;
      mode = croppable || movable ? mode : DRAG_MODE_NONE;
      options.dragMode = mode;
      setData(dragBox, DATA_ACTION, mode);
      toggleClass(dragBox, CLASS_CROP, croppable);
      toggleClass(dragBox, CLASS_MOVE, movable);
      if (!options.cropBoxMovable) {
        setData(face, DATA_ACTION, mode);
        toggleClass(face, CLASS_CROP, croppable);
        toggleClass(face, CLASS_MOVE, movable);
      }
    }
    return this;
  }
};
var AnotherCropper = WINDOW.Cropper;
var Cropper = /* @__PURE__ */ (function() {
  function Cropper2(element) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$1(this, Cropper2);
    if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
      throw new Error("The first argument is required and must be an <img> or <canvas> element.");
    }
    this.element = element;
    this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
    this.cropped = false;
    this.disabled = false;
    this.pointers = {};
    this.ready = false;
    this.reloading = false;
    this.replaced = false;
    this.sized = false;
    this.sizing = false;
    this.init();
  }
  return _createClass$1(Cropper2, [{
    key: "init",
    value: function init2() {
      var element = this.element;
      var tagName = element.tagName.toLowerCase();
      var url;
      if (element[NAMESPACE]) {
        return;
      }
      element[NAMESPACE] = this;
      if (tagName === "img") {
        this.isImg = true;
        url = element.getAttribute("src") || "";
        this.originalUrl = url;
        if (!url) {
          return;
        }
        url = element.src;
      } else if (tagName === "canvas" && window.HTMLCanvasElement) {
        url = element.toDataURL();
      }
      this.load(url);
    }
  }, {
    key: "load",
    value: function load(url) {
      var _this = this;
      if (!url) {
        return;
      }
      this.url = url;
      this.imageData = {};
      var element = this.element, options = this.options;
      if (!options.rotatable && !options.scalable) {
        options.checkOrientation = false;
      }
      if (!options.checkOrientation || !window.ArrayBuffer) {
        this.clone();
        return;
      }
      if (REGEXP_DATA_URL.test(url)) {
        if (REGEXP_DATA_URL_JPEG.test(url)) {
          this.read(dataURLToArrayBuffer(url));
        } else {
          this.clone();
        }
        return;
      }
      var xhr = new XMLHttpRequest();
      var clone2 = this.clone.bind(this);
      this.reloading = true;
      this.xhr = xhr;
      xhr.onabort = clone2;
      xhr.onerror = clone2;
      xhr.ontimeout = clone2;
      xhr.onprogress = function() {
        if (xhr.getResponseHeader("content-type") !== MIME_TYPE_JPEG) {
          xhr.abort();
        }
      };
      xhr.onload = function() {
        _this.read(xhr.response);
      };
      xhr.onloadend = function() {
        _this.reloading = false;
        _this.xhr = null;
      };
      if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
        url = addTimestamp(url);
      }
      xhr.open("GET", url, true);
      xhr.responseType = "arraybuffer";
      xhr.withCredentials = element.crossOrigin === "use-credentials";
      xhr.send();
    }
  }, {
    key: "read",
    value: function read2(arrayBuffer) {
      var options = this.options, imageData = this.imageData;
      var orientation = resetAndGetOrientation(arrayBuffer);
      var rotate2 = 0;
      var scaleX2 = 1;
      var scaleY2 = 1;
      if (orientation > 1) {
        this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);
        var _parseOrientation = parseOrientation(orientation);
        rotate2 = _parseOrientation.rotate;
        scaleX2 = _parseOrientation.scaleX;
        scaleY2 = _parseOrientation.scaleY;
      }
      if (options.rotatable) {
        imageData.rotate = rotate2;
      }
      if (options.scalable) {
        imageData.scaleX = scaleX2;
        imageData.scaleY = scaleY2;
      }
      this.clone();
    }
  }, {
    key: "clone",
    value: function clone2() {
      var element = this.element, url = this.url;
      var crossOrigin = element.crossOrigin;
      var crossOriginUrl = url;
      if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {
        if (!crossOrigin) {
          crossOrigin = "anonymous";
        }
        crossOriginUrl = addTimestamp(url);
      }
      this.crossOrigin = crossOrigin;
      this.crossOriginUrl = crossOriginUrl;
      var image = document.createElement("img");
      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }
      image.src = crossOriginUrl || url;
      image.alt = element.alt || "The image to crop";
      this.image = image;
      image.onload = this.start.bind(this);
      image.onerror = this.stop.bind(this);
      addClass(image, CLASS_HIDE);
      element.parentNode.insertBefore(image, element.nextSibling);
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;
      var image = this.image;
      image.onload = null;
      image.onerror = null;
      this.sizing = true;
      var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);
      var done = function done2(naturalWidth, naturalHeight) {
        assign(_this2.imageData, {
          naturalWidth,
          naturalHeight,
          aspectRatio: naturalWidth / naturalHeight
        });
        _this2.initialImageData = assign({}, _this2.imageData);
        _this2.sizing = false;
        _this2.sized = true;
        _this2.build();
      };
      if (image.naturalWidth && !isIOSWebKit) {
        done(image.naturalWidth, image.naturalHeight);
        return;
      }
      var sizingImage = document.createElement("img");
      var body = document.body || document.documentElement;
      this.sizingImage = sizingImage;
      sizingImage.onload = function() {
        done(sizingImage.width, sizingImage.height);
        if (!isIOSWebKit) {
          body.removeChild(sizingImage);
        }
      };
      sizingImage.src = image.src;
      if (!isIOSWebKit) {
        sizingImage.style.cssText = "left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;";
        body.appendChild(sizingImage);
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var image = this.image;
      image.onload = null;
      image.onerror = null;
      image.parentNode.removeChild(image);
      this.image = null;
    }
  }, {
    key: "build",
    value: function build2() {
      if (!this.sized || this.ready) {
        return;
      }
      var element = this.element, options = this.options, image = this.image;
      var container = element.parentNode;
      var template = document.createElement("div");
      template.innerHTML = TEMPLATE;
      var cropper = template.querySelector(".".concat(NAMESPACE, "-container"));
      var canvas = cropper.querySelector(".".concat(NAMESPACE, "-canvas"));
      var dragBox = cropper.querySelector(".".concat(NAMESPACE, "-drag-box"));
      var cropBox = cropper.querySelector(".".concat(NAMESPACE, "-crop-box"));
      var face = cropBox.querySelector(".".concat(NAMESPACE, "-face"));
      this.container = container;
      this.cropper = cropper;
      this.canvas = canvas;
      this.dragBox = dragBox;
      this.cropBox = cropBox;
      this.viewBox = cropper.querySelector(".".concat(NAMESPACE, "-view-box"));
      this.face = face;
      canvas.appendChild(image);
      addClass(element, CLASS_HIDDEN);
      container.insertBefore(cropper, element.nextSibling);
      removeClass(image, CLASS_HIDE);
      this.initPreview();
      this.bind();
      options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;
      options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
      options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
      addClass(cropBox, CLASS_HIDDEN);
      if (!options.guides) {
        addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN);
      }
      if (!options.center) {
        addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN);
      }
      if (options.background) {
        addClass(cropper, "".concat(NAMESPACE, "-bg"));
      }
      if (!options.highlight) {
        addClass(face, CLASS_INVISIBLE);
      }
      if (options.cropBoxMovable) {
        addClass(face, CLASS_MOVE);
        setData(face, DATA_ACTION, ACTION_ALL);
      }
      if (!options.cropBoxResizable) {
        addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN);
        addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN);
      }
      this.render();
      this.ready = true;
      this.setDragMode(options.dragMode);
      if (options.autoCrop) {
        this.crop();
      }
      this.setData(options.data);
      if (isFunction(options.ready)) {
        addListener(element, EVENT_READY, options.ready, {
          once: true
        });
      }
      dispatchEvent(element, EVENT_READY);
    }
  }, {
    key: "unbuild",
    value: function unbuild() {
      if (!this.ready) {
        return;
      }
      this.ready = false;
      this.unbind();
      this.resetPreview();
      var parentNode = this.cropper.parentNode;
      if (parentNode) {
        parentNode.removeChild(this.cropper);
      }
      removeClass(this.element, CLASS_HIDDEN);
    }
  }, {
    key: "uncreate",
    value: function uncreate() {
      if (this.ready) {
        this.unbuild();
        this.ready = false;
        this.cropped = false;
      } else if (this.sizing) {
        this.sizingImage.onload = null;
        this.sizing = false;
        this.sized = false;
      } else if (this.reloading) {
        this.xhr.onabort = null;
        this.xhr.abort();
      } else if (this.image) {
        this.stop();
      }
    }
    /**
     * Get the no conflict cropper class.
     * @returns {Cropper} The cropper class.
     */
  }], [{
    key: "noConflict",
    value: function noConflict() {
      window.Cropper = AnotherCropper;
      return Cropper2;
    }
    /**
     * Change the default options.
     * @param {Object} options - The new default options.
     */
  }, {
    key: "setDefaults",
    value: function setDefaults2(options) {
      assign(DEFAULTS, isPlainObject(options) && options);
    }
  }]);
})();
assign(Cropper.prototype, render, preview, events$3, handlers, change, methods);
var n$1 = function() {
  return n$1 = Object.assign || function(e2) {
    for (var r2, o2 = 1, t2 = arguments.length; o2 < t2; o2++) for (var n2 in r2 = arguments[o2]) Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
    return e2;
  }, n$1.apply(this, arguments);
};
function a$1(e2, r2) {
  var o2 = {};
  for (var t2 in e2) Object.prototype.hasOwnProperty.call(e2, t2) && r2.indexOf(t2) < 0 && (o2[t2] = e2[t2]);
  if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
    var n2 = 0;
    for (t2 = Object.getOwnPropertySymbols(e2); n2 < t2.length; n2++) r2.indexOf(t2[n2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, t2[n2]) && (o2[t2[n2]] = e2[t2[n2]]);
  }
  return o2;
}
var c$2 = ["aspectRatio", "autoCrop", "autoCropArea", "background", "center", "checkCrossOrigin", "checkOrientation", "cropBoxMovable", "cropBoxResizable", "data", "dragMode", "guides", "highlight", "initialAspectRatio", "minCanvasHeight", "minCanvasWidth", "minContainerHeight", "minContainerWidth", "minCropBoxHeight", "minCropBoxWidth", "modal", "movable", "preview", "responsive", "restore", "rotatable", "scalable", "toggleDragModeOnDblclick", "viewMode", "wheelZoomRatio", "zoomOnTouch", "zoomOnWheel", "zoomable", "cropstart", "cropmove", "cropend", "crop", "zoom", "ready"], i$1 = { opacity: 0, maxWidth: "100%" }, l$2 = React.forwardRef((function(l2, s2) {
  var u2 = a$1(l2, []), p2 = u2.dragMode, d2 = void 0 === p2 ? "crop" : p2, v2 = u2.src, f2 = u2.style, m2 = u2.className, g2 = u2.crossOrigin, y2 = u2.scaleX, b2 = u2.scaleY, h2 = u2.enable, O2 = u2.zoomTo, T = u2.rotateTo, z2 = u2.alt, C = void 0 === z2 ? "picture" : z2, w2 = u2.ready, x2 = u2.onInitialized, j2 = a$1(u2, ["dragMode", "src", "style", "className", "crossOrigin", "scaleX", "scaleY", "enable", "zoomTo", "rotateTo", "alt", "ready", "onInitialized"]), M2 = { scaleY: b2, scaleX: y2, enable: h2, zoomTo: O2, rotateTo: T }, E2 = (function() {
    for (var o2 = [], t2 = 0; t2 < arguments.length; t2++) o2[t2] = arguments[t2];
    var n2 = reactExports.useRef(null);
    return React.useEffect((function() {
      o2.forEach((function(e2) {
        e2 && ("function" == typeof e2 ? e2(n2.current) : e2.current = n2.current);
      }));
    }), [o2]), n2;
  })(s2, reactExports.useRef(null));
  reactExports.useEffect((function() {
    var e2;
    (null === (e2 = E2.current) || void 0 === e2 ? void 0 : e2.cropper) && "number" == typeof O2 && E2.current.cropper.zoomTo(O2);
  }), [u2.zoomTo]), reactExports.useEffect((function() {
    var e2;
    (null === (e2 = E2.current) || void 0 === e2 ? void 0 : e2.cropper) && void 0 !== v2 && E2.current.cropper.reset().clear().replace(v2);
  }), [v2]), reactExports.useEffect((function() {
    if (null !== E2.current) {
      var e2 = new Cropper(E2.current, n$1(n$1({ dragMode: d2 }, j2), { ready: function(e3) {
        null !== e3.currentTarget && (function(e4, r2) {
          void 0 === r2 && (r2 = {});
          var o2 = r2.enable, t2 = void 0 === o2 || o2, n2 = r2.scaleX, a2 = void 0 === n2 ? 1 : n2, c2 = r2.scaleY, i2 = void 0 === c2 ? 1 : c2, l3 = r2.zoomTo, s3 = void 0 === l3 ? 0 : l3, u3 = r2.rotateTo;
          t2 ? e4.enable() : e4.disable(), e4.scaleX(a2), e4.scaleY(i2), void 0 !== u3 && e4.rotateTo(u3), s3 > 0 && e4.zoomTo(s3);
        })(e3.currentTarget.cropper, M2), w2 && w2(e3);
      } }));
      x2 && x2(e2);
    }
    return function() {
      var e3, r2;
      null === (r2 = null === (e3 = E2.current) || void 0 === e3 ? void 0 : e3.cropper) || void 0 === r2 || r2.destroy();
    };
  }), [E2]);
  var R = (function(e2) {
    return c$2.reduce((function(e3, r2) {
      var o2 = e3, t2 = r2;
      return o2[t2], a$1(o2, ["symbol" == typeof t2 ? t2 : t2 + ""]);
    }), e2);
  })(n$1(n$1({}, j2), { crossOrigin: g2, src: v2, alt: C }));
  return React.createElement("div", { style: f2, className: m2 }, React.createElement("img", n$1({}, R, { style: i$1, ref: E2 })));
}));
function c$1(n2, u2 = 300, r2 = {}) {
  const e2 = reactExports.useRef(null), i2 = reactExports.useCallback(
    (t2) => {
      e2.current ? (clearTimeout(e2.current), e2.current = null, n2 && n2(t2)) : e2.current = setTimeout(() => {
        r2.onSingleTap && r2.onSingleTap(t2), e2.current = null;
      }, u2);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [n2, u2, r2.onSingleTap]
  );
  return n2 ? {
    onClick: i2
  } : {};
}
function useCombinedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  return reactExports.useMemo(
    () => (node) => {
      refs.forEach((ref) => ref(node));
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    refs
  );
}
const canUseDOM$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
function isWindow(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === "[object Window]" || // In Electron context the Window object serializes to [object global]
  elementString === "[object global]";
}
function isNode(node) {
  return "nodeType" in node;
}
function getWindow(target) {
  var _target$ownerDocument, _target$ownerDocument2;
  if (!target) {
    return window;
  }
  if (isWindow(target)) {
    return target;
  }
  if (!isNode(target)) {
    return window;
  }
  return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
}
function isDocument(node) {
  const {
    Document
  } = getWindow(node);
  return node instanceof Document;
}
function isHTMLElement(node) {
  if (isWindow(node)) {
    return false;
  }
  return node instanceof getWindow(node).HTMLElement;
}
function isSVGElement(node) {
  return node instanceof getWindow(node).SVGElement;
}
function getOwnerDocument(target) {
  if (!target) {
    return document;
  }
  if (isWindow(target)) {
    return target.document;
  }
  if (!isNode(target)) {
    return document;
  }
  if (isDocument(target)) {
    return target;
  }
  if (isHTMLElement(target) || isSVGElement(target)) {
    return target.ownerDocument;
  }
  return document;
}
const useIsomorphicLayoutEffect = canUseDOM$1 ? reactExports.useLayoutEffect : reactExports.useEffect;
function useEvent(handler) {
  const handlerRef = reactExports.useRef(handler);
  useIsomorphicLayoutEffect(() => {
    handlerRef.current = handler;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return handlerRef.current == null ? void 0 : handlerRef.current(...args);
  }, []);
}
function useInterval() {
  const intervalRef = reactExports.useRef(null);
  const set3 = reactExports.useCallback((listener, duration) => {
    intervalRef.current = setInterval(listener, duration);
  }, []);
  const clear3 = reactExports.useCallback(() => {
    if (intervalRef.current !== null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);
  return [set3, clear3];
}
function useLatestValue(value, dependencies) {
  if (dependencies === void 0) {
    dependencies = [value];
  }
  const valueRef = reactExports.useRef(value);
  useIsomorphicLayoutEffect(() => {
    if (valueRef.current !== value) {
      valueRef.current = value;
    }
  }, dependencies);
  return valueRef;
}
function useLazyMemo(callback, dependencies) {
  const valueRef = reactExports.useRef();
  return reactExports.useMemo(
    () => {
      const newValue = callback(valueRef.current);
      valueRef.current = newValue;
      return newValue;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...dependencies]
  );
}
function useNodeRef(onChange) {
  const onChangeHandler = useEvent(onChange);
  const node = reactExports.useRef(null);
  const setNodeRef = reactExports.useCallback(
    (element) => {
      if (element !== node.current) {
        onChangeHandler == null ? void 0 : onChangeHandler(element, node.current);
      }
      node.current = element;
    },
    //eslint-disable-next-line
    []
  );
  return [node, setNodeRef];
}
function usePrevious2(value) {
  const ref = reactExports.useRef();
  reactExports.useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
let ids = {};
function useUniqueId(prefix2, value) {
  return reactExports.useMemo(() => {
    if (value) {
      return value;
    }
    const id = ids[prefix2] == null ? 0 : ids[prefix2] + 1;
    ids[prefix2] = id;
    return prefix2 + "-" + id;
  }, [prefix2, value]);
}
function createAdjustmentFn(modifier) {
  return function(object2) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }
    return adjustments.reduce((accumulator, adjustment) => {
      const entries3 = Object.entries(adjustment);
      for (const [key, valueAdjustment] of entries3) {
        const value = accumulator[key];
        if (value != null) {
          accumulator[key] = value + modifier * valueAdjustment;
        }
      }
      return accumulator;
    }, {
      ...object2
    });
  };
}
const add = /* @__PURE__ */ createAdjustmentFn(1);
const subtract = /* @__PURE__ */ createAdjustmentFn(-1);
function hasViewportRelativeCoordinates(event2) {
  return "clientX" in event2 && "clientY" in event2;
}
function isKeyboardEvent(event2) {
  if (!event2) {
    return false;
  }
  const {
    KeyboardEvent
  } = getWindow(event2.target);
  return KeyboardEvent && event2 instanceof KeyboardEvent;
}
function isTouchEvent(event2) {
  if (!event2) {
    return false;
  }
  const {
    TouchEvent
  } = getWindow(event2.target);
  return TouchEvent && event2 instanceof TouchEvent;
}
function getEventCoordinates(event2) {
  if (isTouchEvent(event2)) {
    if (event2.touches && event2.touches.length) {
      const {
        clientX: x2,
        clientY: y2
      } = event2.touches[0];
      return {
        x: x2,
        y: y2
      };
    } else if (event2.changedTouches && event2.changedTouches.length) {
      const {
        clientX: x2,
        clientY: y2
      } = event2.changedTouches[0];
      return {
        x: x2,
        y: y2
      };
    }
  }
  if (hasViewportRelativeCoordinates(event2)) {
    return {
      x: event2.clientX,
      y: event2.clientY
    };
  }
  return null;
}
const CSS = /* @__PURE__ */ Object.freeze({
  Translate: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        x: x2,
        y: y2
      } = transform;
      return "translate3d(" + (x2 ? Math.round(x2) : 0) + "px, " + (y2 ? Math.round(y2) : 0) + "px, 0)";
    }
  },
  Scale: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        scaleX: scaleX2,
        scaleY: scaleY2
      } = transform;
      return "scaleX(" + scaleX2 + ") scaleY(" + scaleY2 + ")";
    }
  },
  Transform: {
    toString(transform) {
      if (!transform) {
        return;
      }
      return [CSS.Translate.toString(transform), CSS.Scale.toString(transform)].join(" ");
    }
  },
  Transition: {
    toString(_ref) {
      let {
        property,
        duration,
        easing
      } = _ref;
      return property + " " + duration + "ms " + easing;
    }
  }
});
const SELECTOR = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
function findFirstFocusableNode(element) {
  if (element.matches(SELECTOR)) {
    return element;
  }
  return element.querySelector(SELECTOR);
}
const hiddenStyles = {
  display: "none"
};
function HiddenText(_ref) {
  let {
    id,
    value
  } = _ref;
  return React.createElement("div", {
    id,
    style: hiddenStyles
  }, value);
}
function LiveRegion(_ref) {
  let {
    id,
    announcement,
    ariaLiveType = "assertive"
  } = _ref;
  const visuallyHidden = {
    position: "fixed",
    top: 0,
    left: 0,
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: "hidden",
    clip: "rect(0 0 0 0)",
    clipPath: "inset(100%)",
    whiteSpace: "nowrap"
  };
  return React.createElement("div", {
    id,
    style: visuallyHidden,
    role: "status",
    "aria-live": ariaLiveType,
    "aria-atomic": true
  }, announcement);
}
function useAnnouncement() {
  const [announcement, setAnnouncement] = reactExports.useState("");
  const announce = reactExports.useCallback((value) => {
    if (value != null) {
      setAnnouncement(value);
    }
  }, []);
  return {
    announce,
    announcement
  };
}
const DndMonitorContext = /* @__PURE__ */ reactExports.createContext(null);
function useDndMonitor(listener) {
  const registerListener = reactExports.useContext(DndMonitorContext);
  reactExports.useEffect(() => {
    if (!registerListener) {
      throw new Error("useDndMonitor must be used within a children of <DndContext>");
    }
    const unsubscribe = registerListener(listener);
    return unsubscribe;
  }, [listener, registerListener]);
}
function useDndMonitorProvider() {
  const [listeners] = reactExports.useState(() => /* @__PURE__ */ new Set());
  const registerListener = reactExports.useCallback((listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  }, [listeners]);
  const dispatch = reactExports.useCallback((_ref) => {
    let {
      type,
      event: event2
    } = _ref;
    listeners.forEach((listener) => {
      var _listener$type;
      return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event2);
    });
  }, [listeners]);
  return [dispatch, registerListener];
}
const defaultScreenReaderInstructions = {
  draggable: "\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  "
};
const defaultAnnouncements = {
  onDragStart(_ref) {
    let {
      active
    } = _ref;
    return "Picked up draggable item " + active.id + ".";
  },
  onDragOver(_ref2) {
    let {
      active,
      over
    } = _ref2;
    if (over) {
      return "Draggable item " + active.id + " was moved over droppable area " + over.id + ".";
    }
    return "Draggable item " + active.id + " is no longer over a droppable area.";
  },
  onDragEnd(_ref3) {
    let {
      active,
      over
    } = _ref3;
    if (over) {
      return "Draggable item " + active.id + " was dropped over droppable area " + over.id;
    }
    return "Draggable item " + active.id + " was dropped.";
  },
  onDragCancel(_ref4) {
    let {
      active
    } = _ref4;
    return "Dragging was cancelled. Draggable item " + active.id + " was dropped.";
  }
};
function Accessibility(_ref) {
  let {
    announcements = defaultAnnouncements,
    container,
    hiddenTextDescribedById,
    screenReaderInstructions = defaultScreenReaderInstructions
  } = _ref;
  const {
    announce,
    announcement
  } = useAnnouncement();
  const liveRegionId = useUniqueId("DndLiveRegion");
  const [mounted, setMounted] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setMounted(true);
  }, []);
  useDndMonitor(reactExports.useMemo(() => ({
    onDragStart(_ref2) {
      let {
        active
      } = _ref2;
      announce(announcements.onDragStart({
        active
      }));
    },
    onDragMove(_ref3) {
      let {
        active,
        over
      } = _ref3;
      if (announcements.onDragMove) {
        announce(announcements.onDragMove({
          active,
          over
        }));
      }
    },
    onDragOver(_ref4) {
      let {
        active,
        over
      } = _ref4;
      announce(announcements.onDragOver({
        active,
        over
      }));
    },
    onDragEnd(_ref5) {
      let {
        active,
        over
      } = _ref5;
      announce(announcements.onDragEnd({
        active,
        over
      }));
    },
    onDragCancel(_ref6) {
      let {
        active,
        over
      } = _ref6;
      announce(announcements.onDragCancel({
        active,
        over
      }));
    }
  }), [announce, announcements]));
  if (!mounted) {
    return null;
  }
  const markup = React.createElement(React.Fragment, null, React.createElement(HiddenText, {
    id: hiddenTextDescribedById,
    value: screenReaderInstructions.draggable
  }), React.createElement(LiveRegion, {
    id: liveRegionId,
    announcement
  }));
  return container ? reactDomExports.createPortal(markup, container) : markup;
}
var Action;
(function(Action2) {
  Action2["DragStart"] = "dragStart";
  Action2["DragMove"] = "dragMove";
  Action2["DragEnd"] = "dragEnd";
  Action2["DragCancel"] = "dragCancel";
  Action2["DragOver"] = "dragOver";
  Action2["RegisterDroppable"] = "registerDroppable";
  Action2["SetDroppableDisabled"] = "setDroppableDisabled";
  Action2["UnregisterDroppable"] = "unregisterDroppable";
})(Action || (Action = {}));
function noop$1() {
}
function useSensor(sensor, options) {
  return reactExports.useMemo(
    () => ({
      sensor,
      options: options != null ? options : {}
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [sensor, options]
  );
}
function useSensors() {
  for (var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++) {
    sensors[_key] = arguments[_key];
  }
  return reactExports.useMemo(
    () => [...sensors].filter((sensor) => sensor != null),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...sensors]
  );
}
const defaultCoordinates = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
function distanceBetween(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function sortCollisionsAsc(_ref, _ref2) {
  let {
    data: {
      value: a2
    }
  } = _ref;
  let {
    data: {
      value: b2
    }
  } = _ref2;
  return a2 - b2;
}
function sortCollisionsDesc(_ref3, _ref4) {
  let {
    data: {
      value: a2
    }
  } = _ref3;
  let {
    data: {
      value: b2
    }
  } = _ref4;
  return b2 - a2;
}
function cornersOfRectangle(_ref5) {
  let {
    left,
    top,
    height,
    width
  } = _ref5;
  return [{
    x: left,
    y: top
  }, {
    x: left + width,
    y: top
  }, {
    x: left,
    y: top + height
  }, {
    x: left + width,
    y: top + height
  }];
}
function getFirstCollision(collisions, property) {
  if (!collisions || collisions.length === 0) {
    return null;
  }
  const [firstCollision] = collisions;
  return firstCollision[property];
}
function centerOfRectangle(rect, left, top) {
  if (left === void 0) {
    left = rect.left;
  }
  if (top === void 0) {
    top = rect.top;
  }
  return {
    x: left + rect.width * 0.5,
    y: top + rect.height * 0.5
  };
}
const closestCenter = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);
    if (rect) {
      const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);
      collisions.push({
        id,
        data: {
          droppableContainer,
          value: distBetween
        }
      });
    }
  }
  return collisions.sort(sortCollisionsAsc);
};
const closestCorners = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const corners = cornersOfRectangle(collisionRect);
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);
    if (rect) {
      const rectCorners = cornersOfRectangle(rect);
      const distances = corners.reduce((accumulator, corner, index) => {
        return accumulator + distanceBetween(rectCorners[index], corner);
      }, 0);
      const effectiveDistance = Number((distances / 4).toFixed(4));
      collisions.push({
        id,
        data: {
          droppableContainer,
          value: effectiveDistance
        }
      });
    }
  }
  return collisions.sort(sortCollisionsAsc);
};
function getIntersectionRatio(entry, target) {
  const top = Math.max(target.top, entry.top);
  const left = Math.max(target.left, entry.left);
  const right = Math.min(target.left + target.width, entry.left + entry.width);
  const bottom = Math.min(target.top + target.height, entry.top + entry.height);
  const width = right - left;
  const height = bottom - top;
  if (left < right && top < bottom) {
    const targetArea = target.width * target.height;
    const entryArea = entry.width * entry.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
}
const rectIntersection = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);
    if (rect) {
      const intersectionRatio = getIntersectionRatio(rect, collisionRect);
      if (intersectionRatio > 0) {
        collisions.push({
          id,
          data: {
            droppableContainer,
            value: intersectionRatio
          }
        });
      }
    }
  }
  return collisions.sort(sortCollisionsDesc);
};
function adjustScale(transform, rect1, rect2) {
  return {
    ...transform,
    scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
    scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
  };
}
function getRectDelta(rect1, rect2) {
  return rect1 && rect2 ? {
    x: rect1.left - rect2.left,
    y: rect1.top - rect2.top
  } : defaultCoordinates;
}
function createRectAdjustmentFn(modifier) {
  return function adjustClientRect(rect) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }
    return adjustments.reduce((acc, adjustment) => ({
      ...acc,
      top: acc.top + modifier * adjustment.y,
      bottom: acc.bottom + modifier * adjustment.y,
      left: acc.left + modifier * adjustment.x,
      right: acc.right + modifier * adjustment.x
    }), {
      ...rect
    });
  };
}
const getAdjustedRect = /* @__PURE__ */ createRectAdjustmentFn(1);
function parseTransform(transform) {
  if (transform.startsWith("matrix3d(")) {
    const transformArray = transform.slice(9, -1).split(/, /);
    return {
      x: +transformArray[12],
      y: +transformArray[13],
      scaleX: +transformArray[0],
      scaleY: +transformArray[5]
    };
  } else if (transform.startsWith("matrix(")) {
    const transformArray = transform.slice(7, -1).split(/, /);
    return {
      x: +transformArray[4],
      y: +transformArray[5],
      scaleX: +transformArray[0],
      scaleY: +transformArray[3]
    };
  }
  return null;
}
function inverseTransform(rect, transform, transformOrigin) {
  const parsedTransform = parseTransform(transform);
  if (!parsedTransform) {
    return rect;
  }
  const {
    scaleX: scaleX2,
    scaleY: scaleY2,
    x: translateX,
    y: translateY
  } = parsedTransform;
  const x2 = rect.left - translateX - (1 - scaleX2) * parseFloat(transformOrigin);
  const y2 = rect.top - translateY - (1 - scaleY2) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
  const w2 = scaleX2 ? rect.width / scaleX2 : rect.width;
  const h2 = scaleY2 ? rect.height / scaleY2 : rect.height;
  return {
    width: w2,
    height: h2,
    top: y2,
    right: x2 + w2,
    bottom: y2 + h2,
    left: x2
  };
}
const defaultOptions$1 = {
  ignoreTransform: false
};
function getClientRect(element, options) {
  if (options === void 0) {
    options = defaultOptions$1;
  }
  let rect = element.getBoundingClientRect();
  if (options.ignoreTransform) {
    const {
      transform,
      transformOrigin
    } = getWindow(element).getComputedStyle(element);
    if (transform) {
      rect = inverseTransform(rect, transform, transformOrigin);
    }
  }
  const {
    top,
    left,
    width,
    height,
    bottom,
    right
  } = rect;
  return {
    top,
    left,
    width,
    height,
    bottom,
    right
  };
}
function getTransformAgnosticClientRect(element) {
  return getClientRect(element, {
    ignoreTransform: true
  });
}
function getWindowClientRect(element) {
  const width = element.innerWidth;
  const height = element.innerHeight;
  return {
    top: 0,
    left: 0,
    right: width,
    bottom: height,
    width,
    height
  };
}
function isFixed(node, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = getWindow(node).getComputedStyle(node);
  }
  return computedStyle.position === "fixed";
}
function isScrollable(element, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = getWindow(element).getComputedStyle(element);
  }
  const overflowRegex = /(auto|scroll|overlay)/;
  const properties2 = ["overflow", "overflowX", "overflowY"];
  return properties2.some((property) => {
    const value = computedStyle[property];
    return typeof value === "string" ? overflowRegex.test(value) : false;
  });
}
function getScrollableAncestors(element, limit) {
  const scrollParents = [];
  function findScrollableAncestors(node) {
    if (limit != null && scrollParents.length >= limit) {
      return scrollParents;
    }
    if (!node) {
      return scrollParents;
    }
    if (isDocument(node) && node.scrollingElement != null && !scrollParents.includes(node.scrollingElement)) {
      scrollParents.push(node.scrollingElement);
      return scrollParents;
    }
    if (!isHTMLElement(node) || isSVGElement(node)) {
      return scrollParents;
    }
    if (scrollParents.includes(node)) {
      return scrollParents;
    }
    const computedStyle = getWindow(element).getComputedStyle(node);
    if (node !== element) {
      if (isScrollable(node, computedStyle)) {
        scrollParents.push(node);
      }
    }
    if (isFixed(node, computedStyle)) {
      return scrollParents;
    }
    return findScrollableAncestors(node.parentNode);
  }
  if (!element) {
    return scrollParents;
  }
  return findScrollableAncestors(element);
}
function getFirstScrollableAncestor(node) {
  const [firstScrollableAncestor] = getScrollableAncestors(node, 1);
  return firstScrollableAncestor != null ? firstScrollableAncestor : null;
}
function getScrollableElement(element) {
  if (!canUseDOM$1 || !element) {
    return null;
  }
  if (isWindow(element)) {
    return element;
  }
  if (!isNode(element)) {
    return null;
  }
  if (isDocument(element) || element === getOwnerDocument(element).scrollingElement) {
    return window;
  }
  if (isHTMLElement(element)) {
    return element;
  }
  return null;
}
function getScrollXCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollX;
  }
  return element.scrollLeft;
}
function getScrollYCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollY;
  }
  return element.scrollTop;
}
function getScrollCoordinates(element) {
  return {
    x: getScrollXCoordinate(element),
    y: getScrollYCoordinate(element)
  };
}
var Direction;
(function(Direction2) {
  Direction2[Direction2["Forward"] = 1] = "Forward";
  Direction2[Direction2["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));
function isDocumentScrollingElement(element) {
  if (!canUseDOM$1 || !element) {
    return false;
  }
  return element === document.scrollingElement;
}
function getScrollPosition(scrollingContainer) {
  const minScroll = {
    x: 0,
    y: 0
  };
  const dimensions = isDocumentScrollingElement(scrollingContainer) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: scrollingContainer.clientHeight,
    width: scrollingContainer.clientWidth
  };
  const maxScroll = {
    x: scrollingContainer.scrollWidth - dimensions.width,
    y: scrollingContainer.scrollHeight - dimensions.height
  };
  const isTop = scrollingContainer.scrollTop <= minScroll.y;
  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
  return {
    isTop,
    isLeft,
    isBottom,
    isRight,
    maxScroll,
    minScroll
  };
}
const defaultThreshold = {
  x: 0.2,
  y: 0.2
};
function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref, acceleration, thresholdPercentage) {
  let {
    top,
    left,
    right,
    bottom
  } = _ref;
  if (acceleration === void 0) {
    acceleration = 10;
  }
  if (thresholdPercentage === void 0) {
    thresholdPercentage = defaultThreshold;
  }
  const {
    isTop,
    isBottom,
    isLeft,
    isRight
  } = getScrollPosition(scrollContainer);
  const direction = {
    x: 0,
    y: 0
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold = {
    height: scrollContainerRect.height * thresholdPercentage.y,
    width: scrollContainerRect.width * thresholdPercentage.x
  };
  if (!isTop && top <= scrollContainerRect.top + threshold.height) {
    direction.y = Direction.Backward;
    speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);
  } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {
    direction.y = Direction.Forward;
    speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);
  }
  if (!isRight && right >= scrollContainerRect.right - threshold.width) {
    direction.x = Direction.Forward;
    speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);
  } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {
    direction.x = Direction.Backward;
    speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);
  }
  return {
    direction,
    speed
  };
}
function getScrollElementRect(element) {
  if (element === document.scrollingElement) {
    const {
      innerWidth,
      innerHeight
    } = window;
    return {
      top: 0,
      left: 0,
      right: innerWidth,
      bottom: innerHeight,
      width: innerWidth,
      height: innerHeight
    };
  }
  const {
    top,
    left,
    right,
    bottom
  } = element.getBoundingClientRect();
  return {
    top,
    left,
    right,
    bottom,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getScrollOffsets(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return add(acc, getScrollCoordinates(node));
  }, defaultCoordinates);
}
function getScrollXOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return acc + getScrollXCoordinate(node);
  }, 0);
}
function getScrollYOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return acc + getScrollYCoordinate(node);
  }, 0);
}
function scrollIntoViewIfNeeded(element, measure) {
  if (measure === void 0) {
    measure = getClientRect;
  }
  if (!element) {
    return;
  }
  const {
    top,
    left,
    bottom,
    right
  } = measure(element);
  const firstScrollableAncestor = getFirstScrollableAncestor(element);
  if (!firstScrollableAncestor) {
    return;
  }
  if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {
    element.scrollIntoView({
      block: "center",
      inline: "center"
    });
  }
}
const properties = [["x", ["left", "right"], getScrollXOffset], ["y", ["top", "bottom"], getScrollYOffset]];
class Rect {
  constructor(rect, element) {
    this.rect = void 0;
    this.width = void 0;
    this.height = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.right = void 0;
    this.left = void 0;
    const scrollableAncestors = getScrollableAncestors(element);
    const scrollOffsets = getScrollOffsets(scrollableAncestors);
    this.rect = {
      ...rect
    };
    this.width = rect.width;
    this.height = rect.height;
    for (const [axis, keys2, getScrollOffset] of properties) {
      for (const key of keys2) {
        Object.defineProperty(this, key, {
          get: () => {
            const currentOffsets = getScrollOffset(scrollableAncestors);
            const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;
            return this.rect[key] + scrollOffsetsDeltla;
          },
          enumerable: true
        });
      }
    }
    Object.defineProperty(this, "rect", {
      enumerable: false
    });
  }
}
class Listeners {
  constructor(target) {
    this.target = void 0;
    this.listeners = [];
    this.removeAll = () => {
      this.listeners.forEach((listener) => {
        var _this$target;
        return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
      });
    };
    this.target = target;
  }
  add(eventName, handler, options) {
    var _this$target2;
    (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
    this.listeners.push([eventName, handler, options]);
  }
}
function getEventListenerTarget(target) {
  const {
    EventTarget
  } = getWindow(target);
  return target instanceof EventTarget ? target : getOwnerDocument(target);
}
function hasExceededDistance(delta, measurement) {
  const dx = Math.abs(delta.x);
  const dy = Math.abs(delta.y);
  if (typeof measurement === "number") {
    return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
  }
  if ("x" in measurement && "y" in measurement) {
    return dx > measurement.x && dy > measurement.y;
  }
  if ("x" in measurement) {
    return dx > measurement.x;
  }
  if ("y" in measurement) {
    return dy > measurement.y;
  }
  return false;
}
var EventName;
(function(EventName2) {
  EventName2["Click"] = "click";
  EventName2["DragStart"] = "dragstart";
  EventName2["Keydown"] = "keydown";
  EventName2["ContextMenu"] = "contextmenu";
  EventName2["Resize"] = "resize";
  EventName2["SelectionChange"] = "selectionchange";
  EventName2["VisibilityChange"] = "visibilitychange";
})(EventName || (EventName = {}));
function preventDefault(event2) {
  event2.preventDefault();
}
function stopPropagation(event2) {
  event2.stopPropagation();
}
var KeyboardCode;
(function(KeyboardCode2) {
  KeyboardCode2["Space"] = "Space";
  KeyboardCode2["Down"] = "ArrowDown";
  KeyboardCode2["Right"] = "ArrowRight";
  KeyboardCode2["Left"] = "ArrowLeft";
  KeyboardCode2["Up"] = "ArrowUp";
  KeyboardCode2["Esc"] = "Escape";
  KeyboardCode2["Enter"] = "Enter";
  KeyboardCode2["Tab"] = "Tab";
})(KeyboardCode || (KeyboardCode = {}));
const defaultKeyboardCodes = {
  start: [KeyboardCode.Space, KeyboardCode.Enter],
  cancel: [KeyboardCode.Esc],
  end: [KeyboardCode.Space, KeyboardCode.Enter, KeyboardCode.Tab]
};
const defaultKeyboardCoordinateGetter = (event2, _ref) => {
  let {
    currentCoordinates
  } = _ref;
  switch (event2.code) {
    case KeyboardCode.Right:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x + 25
      };
    case KeyboardCode.Left:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x - 25
      };
    case KeyboardCode.Down:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y + 25
      };
    case KeyboardCode.Up:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y - 25
      };
  }
  return void 0;
};
class KeyboardSensor {
  constructor(props) {
    this.props = void 0;
    this.autoScrollEnabled = false;
    this.referenceCoordinates = void 0;
    this.listeners = void 0;
    this.windowListeners = void 0;
    this.props = props;
    const {
      event: {
        target
      }
    } = props;
    this.props = props;
    this.listeners = new Listeners(getOwnerDocument(target));
    this.windowListeners = new Listeners(getWindow(target));
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.attach();
  }
  attach() {
    this.handleStart();
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const {
      activeNode,
      onStart
    } = this.props;
    const node = activeNode.node.current;
    if (node) {
      scrollIntoViewIfNeeded(node);
    }
    onStart(defaultCoordinates);
  }
  handleKeyDown(event2) {
    if (isKeyboardEvent(event2)) {
      const {
        active,
        context: context2,
        options
      } = this.props;
      const {
        keyboardCodes = defaultKeyboardCodes,
        coordinateGetter = defaultKeyboardCoordinateGetter,
        scrollBehavior = "smooth"
      } = options;
      const {
        code
      } = event2;
      if (keyboardCodes.end.includes(code)) {
        this.handleEnd(event2);
        return;
      }
      if (keyboardCodes.cancel.includes(code)) {
        this.handleCancel(event2);
        return;
      }
      const {
        collisionRect
      } = context2.current;
      const currentCoordinates = collisionRect ? {
        x: collisionRect.left,
        y: collisionRect.top
      } : defaultCoordinates;
      if (!this.referenceCoordinates) {
        this.referenceCoordinates = currentCoordinates;
      }
      const newCoordinates = coordinateGetter(event2, {
        active,
        context: context2.current,
        currentCoordinates
      });
      if (newCoordinates) {
        const coordinatesDelta = subtract(newCoordinates, currentCoordinates);
        const scrollDelta = {
          x: 0,
          y: 0
        };
        const {
          scrollableAncestors
        } = context2.current;
        for (const scrollContainer of scrollableAncestors) {
          const direction = event2.code;
          const {
            isTop,
            isRight,
            isLeft,
            isBottom,
            maxScroll,
            minScroll
          } = getScrollPosition(scrollContainer);
          const scrollElementRect = getScrollElementRect(scrollContainer);
          const clampedCoordinates = {
            x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
            y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
          };
          const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
          const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
          if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
            const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;
            const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;
            if (canScrollToNewCoordinates && !coordinatesDelta.y) {
              scrollContainer.scrollTo({
                left: newScrollCoordinates,
                behavior: scrollBehavior
              });
              return;
            }
            if (canScrollToNewCoordinates) {
              scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;
            } else {
              scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
            }
            if (scrollDelta.x) {
              scrollContainer.scrollBy({
                left: -scrollDelta.x,
                behavior: scrollBehavior
              });
            }
            break;
          } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
            const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
            const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;
            if (canScrollToNewCoordinates && !coordinatesDelta.x) {
              scrollContainer.scrollTo({
                top: newScrollCoordinates,
                behavior: scrollBehavior
              });
              return;
            }
            if (canScrollToNewCoordinates) {
              scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;
            } else {
              scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
            }
            if (scrollDelta.y) {
              scrollContainer.scrollBy({
                top: -scrollDelta.y,
                behavior: scrollBehavior
              });
            }
            break;
          }
        }
        this.handleMove(event2, add(subtract(newCoordinates, this.referenceCoordinates), scrollDelta));
      }
    }
  }
  handleMove(event2, coordinates) {
    const {
      onMove
    } = this.props;
    event2.preventDefault();
    onMove(coordinates);
  }
  handleEnd(event2) {
    const {
      onEnd
    } = this.props;
    event2.preventDefault();
    this.detach();
    onEnd();
  }
  handleCancel(event2) {
    const {
      onCancel
    } = this.props;
    event2.preventDefault();
    this.detach();
    onCancel();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
  }
}
KeyboardSensor.activators = [{
  eventName: "onKeyDown",
  handler: (event2, _ref, _ref2) => {
    let {
      keyboardCodes = defaultKeyboardCodes,
      onActivation
    } = _ref;
    let {
      active
    } = _ref2;
    const {
      code
    } = event2.nativeEvent;
    if (keyboardCodes.start.includes(code)) {
      const activator = active.activatorNode.current;
      if (activator && event2.target !== activator) {
        return false;
      }
      event2.preventDefault();
      onActivation == null ? void 0 : onActivation({
        event: event2.nativeEvent
      });
      return true;
    }
    return false;
  }
}];
function isDistanceConstraint(constraint) {
  return Boolean(constraint && "distance" in constraint);
}
function isDelayConstraint(constraint) {
  return Boolean(constraint && "delay" in constraint);
}
class AbstractPointerSensor {
  constructor(props, events2, listenerTarget) {
    var _getEventCoordinates;
    if (listenerTarget === void 0) {
      listenerTarget = getEventListenerTarget(props.event.target);
    }
    this.props = void 0;
    this.events = void 0;
    this.autoScrollEnabled = true;
    this.document = void 0;
    this.activated = false;
    this.initialCoordinates = void 0;
    this.timeoutId = null;
    this.listeners = void 0;
    this.documentListeners = void 0;
    this.windowListeners = void 0;
    this.props = props;
    this.events = events2;
    const {
      event: event2
    } = props;
    const {
      target
    } = event2;
    this.props = props;
    this.events = events2;
    this.document = getOwnerDocument(target);
    this.documentListeners = new Listeners(this.document);
    this.listeners = new Listeners(listenerTarget);
    this.windowListeners = new Listeners(getWindow(target));
    this.initialCoordinates = (_getEventCoordinates = getEventCoordinates(event2)) != null ? _getEventCoordinates : defaultCoordinates;
    this.handleStart = this.handleStart.bind(this);
    this.handleMove = this.handleMove.bind(this);
    this.handleEnd = this.handleEnd.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.handleKeydown = this.handleKeydown.bind(this);
    this.removeTextSelection = this.removeTextSelection.bind(this);
    this.attach();
  }
  attach() {
    const {
      events: events2,
      props: {
        options: {
          activationConstraint,
          bypassActivationConstraint
        }
      }
    } = this;
    this.listeners.add(events2.move.name, this.handleMove, {
      passive: false
    });
    this.listeners.add(events2.end.name, this.handleEnd);
    if (events2.cancel) {
      this.listeners.add(events2.cancel.name, this.handleCancel);
    }
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.DragStart, preventDefault);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    this.windowListeners.add(EventName.ContextMenu, preventDefault);
    this.documentListeners.add(EventName.Keydown, this.handleKeydown);
    if (activationConstraint) {
      if (bypassActivationConstraint != null && bypassActivationConstraint({
        event: this.props.event,
        activeNode: this.props.activeNode,
        options: this.props.options
      })) {
        return this.handleStart();
      }
      if (isDelayConstraint(activationConstraint)) {
        this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
        this.handlePending(activationConstraint);
        return;
      }
      if (isDistanceConstraint(activationConstraint)) {
        this.handlePending(activationConstraint);
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
    setTimeout(this.documentListeners.removeAll, 50);
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  handlePending(constraint, offset) {
    const {
      active,
      onPending
    } = this.props;
    onPending(active, constraint, this.initialCoordinates, offset);
  }
  handleStart() {
    const {
      initialCoordinates
    } = this;
    const {
      onStart
    } = this.props;
    if (initialCoordinates) {
      this.activated = true;
      this.documentListeners.add(EventName.Click, stopPropagation, {
        capture: true
      });
      this.removeTextSelection();
      this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
      onStart(initialCoordinates);
    }
  }
  handleMove(event2) {
    var _getEventCoordinates2;
    const {
      activated,
      initialCoordinates,
      props
    } = this;
    const {
      onMove,
      options: {
        activationConstraint
      }
    } = props;
    if (!initialCoordinates) {
      return;
    }
    const coordinates = (_getEventCoordinates2 = getEventCoordinates(event2)) != null ? _getEventCoordinates2 : defaultCoordinates;
    const delta = subtract(initialCoordinates, coordinates);
    if (!activated && activationConstraint) {
      if (isDistanceConstraint(activationConstraint)) {
        if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
        if (hasExceededDistance(delta, activationConstraint.distance)) {
          return this.handleStart();
        }
      }
      if (isDelayConstraint(activationConstraint)) {
        if (hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
      }
      this.handlePending(activationConstraint, delta);
      return;
    }
    if (event2.cancelable) {
      event2.preventDefault();
    }
    onMove(coordinates);
  }
  handleEnd() {
    const {
      onAbort,
      onEnd
    } = this.props;
    this.detach();
    if (!this.activated) {
      onAbort(this.props.active);
    }
    onEnd();
  }
  handleCancel() {
    const {
      onAbort,
      onCancel
    } = this.props;
    this.detach();
    if (!this.activated) {
      onAbort(this.props.active);
    }
    onCancel();
  }
  handleKeydown(event2) {
    if (event2.code === KeyboardCode.Esc) {
      this.handleCancel();
    }
  }
  removeTextSelection() {
    var _this$document$getSel;
    (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
  }
}
const events = {
  cancel: {
    name: "pointercancel"
  },
  move: {
    name: "pointermove"
  },
  end: {
    name: "pointerup"
  }
};
class PointerSensor extends AbstractPointerSensor {
  constructor(props) {
    const {
      event: event2
    } = props;
    const listenerTarget = getOwnerDocument(event2.target);
    super(props, events, listenerTarget);
  }
}
PointerSensor.activators = [{
  eventName: "onPointerDown",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event2
    } = _ref;
    let {
      onActivation
    } = _ref2;
    if (!event2.isPrimary || event2.button !== 0) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event: event2
    });
    return true;
  }
}];
const events$1 = {
  move: {
    name: "mousemove"
  },
  end: {
    name: "mouseup"
  }
};
var MouseButton;
(function(MouseButton2) {
  MouseButton2[MouseButton2["RightClick"] = 2] = "RightClick";
})(MouseButton || (MouseButton = {}));
class MouseSensor extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$1, getOwnerDocument(props.event.target));
  }
}
MouseSensor.activators = [{
  eventName: "onMouseDown",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event2
    } = _ref;
    let {
      onActivation
    } = _ref2;
    if (event2.button === MouseButton.RightClick) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event: event2
    });
    return true;
  }
}];
const events$2 = {
  cancel: {
    name: "touchcancel"
  },
  move: {
    name: "touchmove"
  },
  end: {
    name: "touchend"
  }
};
class TouchSensor extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$2);
  }
  static setup() {
    window.addEventListener(events$2.move.name, noop2, {
      capture: false,
      passive: false
    });
    return function teardown() {
      window.removeEventListener(events$2.move.name, noop2);
    };
    function noop2() {
    }
  }
}
TouchSensor.activators = [{
  eventName: "onTouchStart",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event2
    } = _ref;
    let {
      onActivation
    } = _ref2;
    const {
      touches
    } = event2;
    if (touches.length > 1) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event: event2
    });
    return true;
  }
}];
var AutoScrollActivator;
(function(AutoScrollActivator2) {
  AutoScrollActivator2[AutoScrollActivator2["Pointer"] = 0] = "Pointer";
  AutoScrollActivator2[AutoScrollActivator2["DraggableRect"] = 1] = "DraggableRect";
})(AutoScrollActivator || (AutoScrollActivator = {}));
var TraversalOrder;
(function(TraversalOrder2) {
  TraversalOrder2[TraversalOrder2["TreeOrder"] = 0] = "TreeOrder";
  TraversalOrder2[TraversalOrder2["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
})(TraversalOrder || (TraversalOrder = {}));
function useAutoScroller(_ref) {
  let {
    acceleration,
    activator = AutoScrollActivator.Pointer,
    canScroll,
    draggingRect,
    enabled,
    interval = 5,
    order = TraversalOrder.TreeOrder,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects,
    delta,
    threshold
  } = _ref;
  const scrollIntent = useScrollIntent({
    delta,
    disabled: !enabled
  });
  const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
  const scrollSpeed = reactExports.useRef({
    x: 0,
    y: 0
  });
  const scrollDirection = reactExports.useRef({
    x: 0,
    y: 0
  });
  const rect = reactExports.useMemo(() => {
    switch (activator) {
      case AutoScrollActivator.Pointer:
        return pointerCoordinates ? {
          top: pointerCoordinates.y,
          bottom: pointerCoordinates.y,
          left: pointerCoordinates.x,
          right: pointerCoordinates.x
        } : null;
      case AutoScrollActivator.DraggableRect:
        return draggingRect;
    }
  }, [activator, draggingRect, pointerCoordinates]);
  const scrollContainerRef = reactExports.useRef(null);
  const autoScroll = reactExports.useCallback(() => {
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer) {
      return;
    }
    const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
    const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
    scrollContainer.scrollBy(scrollLeft, scrollTop);
  }, []);
  const sortedScrollableAncestors = reactExports.useMemo(() => order === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order, scrollableAncestors]);
  reactExports.useEffect(
    () => {
      if (!enabled || !scrollableAncestors.length || !rect) {
        clearAutoScrollInterval();
        return;
      }
      for (const scrollContainer of sortedScrollableAncestors) {
        if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
          continue;
        }
        const index = scrollableAncestors.indexOf(scrollContainer);
        const scrollContainerRect = scrollableAncestorRects[index];
        if (!scrollContainerRect) {
          continue;
        }
        const {
          direction,
          speed
        } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);
        for (const axis of ["x", "y"]) {
          if (!scrollIntent[axis][direction[axis]]) {
            speed[axis] = 0;
            direction[axis] = 0;
          }
        }
        if (speed.x > 0 || speed.y > 0) {
          clearAutoScrollInterval();
          scrollContainerRef.current = scrollContainer;
          setAutoScrollInterval(autoScroll, interval);
          scrollSpeed.current = speed;
          scrollDirection.current = direction;
          return;
        }
      }
      scrollSpeed.current = {
        x: 0,
        y: 0
      };
      scrollDirection.current = {
        x: 0,
        y: 0
      };
      clearAutoScrollInterval();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      acceleration,
      autoScroll,
      canScroll,
      clearAutoScrollInterval,
      enabled,
      interval,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(rect),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(scrollIntent),
      setAutoScrollInterval,
      scrollableAncestors,
      sortedScrollableAncestors,
      scrollableAncestorRects,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(threshold)
    ]
  );
}
const defaultScrollIntent = {
  x: {
    [Direction.Backward]: false,
    [Direction.Forward]: false
  },
  y: {
    [Direction.Backward]: false,
    [Direction.Forward]: false
  }
};
function useScrollIntent(_ref2) {
  let {
    delta,
    disabled
  } = _ref2;
  const previousDelta = usePrevious2(delta);
  return useLazyMemo((previousIntent) => {
    if (disabled || !previousDelta || !previousIntent) {
      return defaultScrollIntent;
    }
    const direction = {
      x: Math.sign(delta.x - previousDelta.x),
      y: Math.sign(delta.y - previousDelta.y)
    };
    return {
      x: {
        [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,
        [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1
      },
      y: {
        [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,
        [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1
      }
    };
  }, [disabled, delta, previousDelta]);
}
function useCachedNode(draggableNodes, id) {
  const draggableNode = id != null ? draggableNodes.get(id) : void 0;
  const node = draggableNode ? draggableNode.node.current : null;
  return useLazyMemo((cachedNode) => {
    var _ref;
    if (id == null) {
      return null;
    }
    return (_ref = node != null ? node : cachedNode) != null ? _ref : null;
  }, [node, id]);
}
function useCombineActivators(sensors, getSyntheticHandler) {
  return reactExports.useMemo(() => sensors.reduce((accumulator, sensor) => {
    const {
      sensor: Sensor
    } = sensor;
    const sensorActivators = Sensor.activators.map((activator) => ({
      eventName: activator.eventName,
      handler: getSyntheticHandler(activator.handler, sensor)
    }));
    return [...accumulator, ...sensorActivators];
  }, []), [sensors, getSyntheticHandler]);
}
var MeasuringStrategy;
(function(MeasuringStrategy2) {
  MeasuringStrategy2[MeasuringStrategy2["Always"] = 0] = "Always";
  MeasuringStrategy2[MeasuringStrategy2["BeforeDragging"] = 1] = "BeforeDragging";
  MeasuringStrategy2[MeasuringStrategy2["WhileDragging"] = 2] = "WhileDragging";
})(MeasuringStrategy || (MeasuringStrategy = {}));
var MeasuringFrequency;
(function(MeasuringFrequency2) {
  MeasuringFrequency2["Optimized"] = "optimized";
})(MeasuringFrequency || (MeasuringFrequency = {}));
const defaultValue = /* @__PURE__ */ new Map();
function useDroppableMeasuring(containers, _ref) {
  let {
    dragging,
    dependencies,
    config
  } = _ref;
  const [queue, setQueue] = reactExports.useState(null);
  const {
    frequency,
    measure,
    strategy
  } = config;
  const containersRef = reactExports.useRef(containers);
  const disabled = isDisabled();
  const disabledRef = useLatestValue(disabled);
  const measureDroppableContainers = reactExports.useCallback(function(ids2) {
    if (ids2 === void 0) {
      ids2 = [];
    }
    if (disabledRef.current) {
      return;
    }
    setQueue((value) => {
      if (value === null) {
        return ids2;
      }
      return value.concat(ids2.filter((id) => !value.includes(id)));
    });
  }, [disabledRef]);
  const timeoutId = reactExports.useRef(null);
  const droppableRects = useLazyMemo((previousValue) => {
    if (disabled && !dragging) {
      return defaultValue;
    }
    if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {
      const map3 = /* @__PURE__ */ new Map();
      for (let container of containers) {
        if (!container) {
          continue;
        }
        if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {
          map3.set(container.id, container.rect.current);
          continue;
        }
        const node = container.node.current;
        const rect = node ? new Rect(measure(node), node) : null;
        container.rect.current = rect;
        if (rect) {
          map3.set(container.id, rect);
        }
      }
      return map3;
    }
    return previousValue;
  }, [containers, queue, dragging, disabled, measure]);
  reactExports.useEffect(() => {
    containersRef.current = containers;
  }, [containers]);
  reactExports.useEffect(
    () => {
      if (disabled) {
        return;
      }
      measureDroppableContainers();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [dragging, disabled]
  );
  reactExports.useEffect(
    () => {
      if (queue && queue.length > 0) {
        setQueue(null);
      }
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [JSON.stringify(queue)]
  );
  reactExports.useEffect(
    () => {
      if (disabled || typeof frequency !== "number" || timeoutId.current !== null) {
        return;
      }
      timeoutId.current = setTimeout(() => {
        measureDroppableContainers();
        timeoutId.current = null;
      }, frequency);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [frequency, disabled, measureDroppableContainers, ...dependencies]
  );
  return {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled: queue != null
  };
  function isDisabled() {
    switch (strategy) {
      case MeasuringStrategy.Always:
        return false;
      case MeasuringStrategy.BeforeDragging:
        return dragging;
      default:
        return !dragging;
    }
  }
}
function useInitialValue(value, computeFn) {
  return useLazyMemo((previousValue) => {
    if (!value) {
      return null;
    }
    if (previousValue) {
      return previousValue;
    }
    return typeof computeFn === "function" ? computeFn(value) : value;
  }, [computeFn, value]);
}
function useInitialRect(node, measure) {
  return useInitialValue(node, measure);
}
function useMutationObserver(_ref) {
  let {
    callback,
    disabled
  } = _ref;
  const handleMutations = useEvent(callback);
  const mutationObserver = reactExports.useMemo(() => {
    if (disabled || typeof window === "undefined" || typeof window.MutationObserver === "undefined") {
      return void 0;
    }
    const {
      MutationObserver
    } = window;
    return new MutationObserver(handleMutations);
  }, [handleMutations, disabled]);
  reactExports.useEffect(() => {
    return () => mutationObserver == null ? void 0 : mutationObserver.disconnect();
  }, [mutationObserver]);
  return mutationObserver;
}
function useResizeObserver(_ref) {
  let {
    callback,
    disabled
  } = _ref;
  const handleResize = useEvent(callback);
  const resizeObserver = reactExports.useMemo(
    () => {
      if (disabled || typeof window === "undefined" || typeof window.ResizeObserver === "undefined") {
        return void 0;
      }
      const {
        ResizeObserver: ResizeObserver2
      } = window;
      return new ResizeObserver2(handleResize);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [disabled]
  );
  reactExports.useEffect(() => {
    return () => resizeObserver == null ? void 0 : resizeObserver.disconnect();
  }, [resizeObserver]);
  return resizeObserver;
}
function defaultMeasure(element) {
  return new Rect(getClientRect(element), element);
}
function useRect(element, measure, fallbackRect) {
  if (measure === void 0) {
    measure = defaultMeasure;
  }
  const [rect, setRect] = reactExports.useState(null);
  function measureRect() {
    setRect((currentRect) => {
      if (!element) {
        return null;
      }
      if (element.isConnected === false) {
        var _ref;
        return (_ref = currentRect != null ? currentRect : fallbackRect) != null ? _ref : null;
      }
      const newRect = measure(element);
      if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {
        return currentRect;
      }
      return newRect;
    });
  }
  const mutationObserver = useMutationObserver({
    callback(records) {
      if (!element) {
        return;
      }
      for (const record of records) {
        const {
          type,
          target
        } = record;
        if (type === "childList" && target instanceof HTMLElement && target.contains(element)) {
          measureRect();
          break;
        }
      }
    }
  });
  const resizeObserver = useResizeObserver({
    callback: measureRect
  });
  useIsomorphicLayoutEffect(() => {
    measureRect();
    if (element) {
      resizeObserver == null ? void 0 : resizeObserver.observe(element);
      mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    } else {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      mutationObserver == null ? void 0 : mutationObserver.disconnect();
    }
  }, [element]);
  return rect;
}
function useRectDelta(rect) {
  const initialRect = useInitialValue(rect);
  return getRectDelta(rect, initialRect);
}
const defaultValue$1 = [];
function useScrollableAncestors(node) {
  const previousNode = reactExports.useRef(node);
  const ancestors = useLazyMemo((previousValue) => {
    if (!node) {
      return defaultValue$1;
    }
    if (previousValue && previousValue !== defaultValue$1 && node && previousNode.current && node.parentNode === previousNode.current.parentNode) {
      return previousValue;
    }
    return getScrollableAncestors(node);
  }, [node]);
  reactExports.useEffect(() => {
    previousNode.current = node;
  }, [node]);
  return ancestors;
}
function useScrollOffsets(elements) {
  const [scrollCoordinates, setScrollCoordinates] = reactExports.useState(null);
  const prevElements = reactExports.useRef(elements);
  const handleScroll = reactExports.useCallback((event2) => {
    const scrollingElement = getScrollableElement(event2.target);
    if (!scrollingElement) {
      return;
    }
    setScrollCoordinates((scrollCoordinates2) => {
      if (!scrollCoordinates2) {
        return null;
      }
      scrollCoordinates2.set(scrollingElement, getScrollCoordinates(scrollingElement));
      return new Map(scrollCoordinates2);
    });
  }, []);
  reactExports.useEffect(() => {
    const previousElements = prevElements.current;
    if (elements !== previousElements) {
      cleanup(previousElements);
      const entries3 = elements.map((element) => {
        const scrollableElement = getScrollableElement(element);
        if (scrollableElement) {
          scrollableElement.addEventListener("scroll", handleScroll, {
            passive: true
          });
          return [scrollableElement, getScrollCoordinates(scrollableElement)];
        }
        return null;
      }).filter((entry) => entry != null);
      setScrollCoordinates(entries3.length ? new Map(entries3) : null);
      prevElements.current = elements;
    }
    return () => {
      cleanup(elements);
      cleanup(previousElements);
    };
    function cleanup(elements2) {
      elements2.forEach((element) => {
        const scrollableElement = getScrollableElement(element);
        scrollableElement == null ? void 0 : scrollableElement.removeEventListener("scroll", handleScroll);
      });
    }
  }, [handleScroll, elements]);
  return reactExports.useMemo(() => {
    if (elements.length) {
      return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
    }
    return defaultCoordinates;
  }, [elements, scrollCoordinates]);
}
function useScrollOffsetsDelta(scrollOffsets, dependencies) {
  if (dependencies === void 0) {
    dependencies = [];
  }
  const initialScrollOffsets = reactExports.useRef(null);
  reactExports.useEffect(
    () => {
      initialScrollOffsets.current = null;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    dependencies
  );
  reactExports.useEffect(() => {
    const hasScrollOffsets = scrollOffsets !== defaultCoordinates;
    if (hasScrollOffsets && !initialScrollOffsets.current) {
      initialScrollOffsets.current = scrollOffsets;
    }
    if (!hasScrollOffsets && initialScrollOffsets.current) {
      initialScrollOffsets.current = null;
    }
  }, [scrollOffsets]);
  return initialScrollOffsets.current ? subtract(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;
}
function useSensorSetup(sensors) {
  reactExports.useEffect(
    () => {
      if (!canUseDOM$1) {
        return;
      }
      const teardownFns = sensors.map((_ref) => {
        let {
          sensor
        } = _ref;
        return sensor.setup == null ? void 0 : sensor.setup();
      });
      return () => {
        for (const teardown of teardownFns) {
          teardown == null ? void 0 : teardown();
        }
      };
    },
    // TO-DO: Sensors length could theoretically change which would not be a valid dependency
    // eslint-disable-next-line react-hooks/exhaustive-deps
    sensors.map((_ref2) => {
      let {
        sensor
      } = _ref2;
      return sensor;
    })
  );
}
function useSyntheticListeners(listeners, id) {
  return reactExports.useMemo(() => {
    return listeners.reduce((acc, _ref) => {
      let {
        eventName,
        handler
      } = _ref;
      acc[eventName] = (event2) => {
        handler(event2, id);
      };
      return acc;
    }, {});
  }, [listeners, id]);
}
function useWindowRect(element) {
  return reactExports.useMemo(() => element ? getWindowClientRect(element) : null, [element]);
}
const defaultValue$2 = [];
function useRects(elements, measure) {
  if (measure === void 0) {
    measure = getClientRect;
  }
  const [firstElement] = elements;
  const windowRect = useWindowRect(firstElement ? getWindow(firstElement) : null);
  const [rects, setRects] = reactExports.useState(defaultValue$2);
  function measureRects() {
    setRects(() => {
      if (!elements.length) {
        return defaultValue$2;
      }
      return elements.map((element) => isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));
    });
  }
  const resizeObserver = useResizeObserver({
    callback: measureRects
  });
  useIsomorphicLayoutEffect(() => {
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    measureRects();
    elements.forEach((element) => resizeObserver == null ? void 0 : resizeObserver.observe(element));
  }, [elements]);
  return rects;
}
function getMeasurableNode(node) {
  if (!node) {
    return null;
  }
  if (node.children.length > 1) {
    return node;
  }
  const firstChild = node.children[0];
  return isHTMLElement(firstChild) ? firstChild : node;
}
function useDragOverlayMeasuring(_ref) {
  let {
    measure
  } = _ref;
  const [rect, setRect] = reactExports.useState(null);
  const handleResize = reactExports.useCallback((entries3) => {
    for (const {
      target
    } of entries3) {
      if (isHTMLElement(target)) {
        setRect((rect2) => {
          const newRect = measure(target);
          return rect2 ? {
            ...rect2,
            width: newRect.width,
            height: newRect.height
          } : newRect;
        });
        break;
      }
    }
  }, [measure]);
  const resizeObserver = useResizeObserver({
    callback: handleResize
  });
  const handleNodeChange = reactExports.useCallback((element) => {
    const node = getMeasurableNode(element);
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    if (node) {
      resizeObserver == null ? void 0 : resizeObserver.observe(node);
    }
    setRect(node ? measure(node) : null);
  }, [measure, resizeObserver]);
  const [nodeRef, setRef] = useNodeRef(handleNodeChange);
  return reactExports.useMemo(() => ({
    nodeRef,
    rect,
    setRef
  }), [rect, nodeRef, setRef]);
}
const defaultSensors = [{
  sensor: PointerSensor,
  options: {}
}, {
  sensor: KeyboardSensor,
  options: {}
}];
const defaultData = {
  current: {}
};
const defaultMeasuringConfiguration = {
  draggable: {
    measure: getTransformAgnosticClientRect
  },
  droppable: {
    measure: getTransformAgnosticClientRect,
    strategy: MeasuringStrategy.WhileDragging,
    frequency: MeasuringFrequency.Optimized
  },
  dragOverlay: {
    measure: getClientRect
  }
};
class DroppableContainersMap extends Map {
  get(id) {
    var _super$get;
    return id != null ? (_super$get = super.get(id)) != null ? _super$get : void 0 : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter((_ref) => {
      let {
        disabled
      } = _ref;
      return !disabled;
    });
  }
  getNodeFor(id) {
    var _this$get$node$curren, _this$get;
    return (_this$get$node$curren = (_this$get = this.get(id)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : void 0;
  }
}
const defaultPublicContext = {
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  collisions: null,
  containerNodeRect: null,
  draggableNodes: /* @__PURE__ */ new Map(),
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: /* @__PURE__ */ new DroppableContainersMap(),
  over: null,
  dragOverlay: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: noop$1
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  measuringConfiguration: defaultMeasuringConfiguration,
  measureDroppableContainers: noop$1,
  windowRect: null,
  measuringScheduled: false
};
const defaultInternalContext = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: noop$1,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: noop$1
};
const InternalContext = /* @__PURE__ */ reactExports.createContext(defaultInternalContext);
const PublicContext = /* @__PURE__ */ reactExports.createContext(defaultPublicContext);
function getInitialState() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: /* @__PURE__ */ new Map(),
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new DroppableContainersMap()
    }
  };
}
function reducer(state, action) {
  switch (action.type) {
    case Action.DragStart:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          initialCoordinates: action.initialCoordinates,
          active: action.active
        }
      };
    case Action.DragMove:
      if (state.draggable.active == null) {
        return state;
      }
      return {
        ...state,
        draggable: {
          ...state.draggable,
          translate: {
            x: action.coordinates.x - state.draggable.initialCoordinates.x,
            y: action.coordinates.y - state.draggable.initialCoordinates.y
          }
        }
      };
    case Action.DragEnd:
    case Action.DragCancel:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };
    case Action.RegisterDroppable: {
      const {
        element
      } = action;
      const {
        id
      } = element;
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id, element);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action.SetDroppableDisabled: {
      const {
        id,
        key,
        disabled
      } = action;
      const element = state.droppable.containers.get(id);
      if (!element || key !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id, {
        ...element,
        disabled
      });
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action.UnregisterDroppable: {
      const {
        id,
        key
      } = action;
      const element = state.droppable.containers.get(id);
      if (!element || key !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.delete(id);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    default: {
      return state;
    }
  }
}
function RestoreFocus(_ref) {
  let {
    disabled
  } = _ref;
  const {
    active,
    activatorEvent,
    draggableNodes
  } = reactExports.useContext(InternalContext);
  const previousActivatorEvent = usePrevious2(activatorEvent);
  const previousActiveId = usePrevious2(active == null ? void 0 : active.id);
  reactExports.useEffect(() => {
    if (disabled) {
      return;
    }
    if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {
      if (!isKeyboardEvent(previousActivatorEvent)) {
        return;
      }
      if (document.activeElement === previousActivatorEvent.target) {
        return;
      }
      const draggableNode = draggableNodes.get(previousActiveId);
      if (!draggableNode) {
        return;
      }
      const {
        activatorNode,
        node
      } = draggableNode;
      if (!activatorNode.current && !node.current) {
        return;
      }
      requestAnimationFrame(() => {
        for (const element of [activatorNode.current, node.current]) {
          if (!element) {
            continue;
          }
          const focusableNode = findFirstFocusableNode(element);
          if (focusableNode) {
            focusableNode.focus();
            break;
          }
        }
      });
    }
  }, [activatorEvent, disabled, draggableNodes, previousActiveId, previousActivatorEvent]);
  return null;
}
function applyModifiers(modifiers, _ref) {
  let {
    transform,
    ...args
  } = _ref;
  return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier) => {
    return modifier({
      transform: accumulator,
      ...args
    });
  }, transform) : transform;
}
function useMeasuringConfiguration(config) {
  return reactExports.useMemo(
    () => ({
      draggable: {
        ...defaultMeasuringConfiguration.draggable,
        ...config == null ? void 0 : config.draggable
      },
      droppable: {
        ...defaultMeasuringConfiguration.droppable,
        ...config == null ? void 0 : config.droppable
      },
      dragOverlay: {
        ...defaultMeasuringConfiguration.dragOverlay,
        ...config == null ? void 0 : config.dragOverlay
      }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [config == null ? void 0 : config.draggable, config == null ? void 0 : config.droppable, config == null ? void 0 : config.dragOverlay]
  );
}
function useLayoutShiftScrollCompensation(_ref) {
  let {
    activeNode,
    measure,
    initialRect,
    config = true
  } = _ref;
  const initialized = reactExports.useRef(false);
  const {
    x: x2,
    y: y2
  } = typeof config === "boolean" ? {
    x: config,
    y: config
  } : config;
  useIsomorphicLayoutEffect(() => {
    const disabled = !x2 && !y2;
    if (disabled || !activeNode) {
      initialized.current = false;
      return;
    }
    if (initialized.current || !initialRect) {
      return;
    }
    const node = activeNode == null ? void 0 : activeNode.node.current;
    if (!node || node.isConnected === false) {
      return;
    }
    const rect = measure(node);
    const rectDelta = getRectDelta(rect, initialRect);
    if (!x2) {
      rectDelta.x = 0;
    }
    if (!y2) {
      rectDelta.y = 0;
    }
    initialized.current = true;
    if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {
      const firstScrollableAncestor = getFirstScrollableAncestor(node);
      if (firstScrollableAncestor) {
        firstScrollableAncestor.scrollBy({
          top: rectDelta.y,
          left: rectDelta.x
        });
      }
    }
  }, [activeNode, x2, y2, initialRect, measure]);
}
const ActiveDraggableContext = /* @__PURE__ */ reactExports.createContext({
  ...defaultCoordinates,
  scaleX: 1,
  scaleY: 1
});
var Status;
(function(Status2) {
  Status2[Status2["Uninitialized"] = 0] = "Uninitialized";
  Status2[Status2["Initializing"] = 1] = "Initializing";
  Status2[Status2["Initialized"] = 2] = "Initialized";
})(Status || (Status = {}));
const DndContext = /* @__PURE__ */ reactExports.memo(function DndContext2(_ref) {
  var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;
  let {
    id,
    accessibility,
    autoScroll = true,
    children,
    sensors = defaultSensors,
    collisionDetection = rectIntersection,
    measuring,
    modifiers,
    ...props
  } = _ref;
  const store = reactExports.useReducer(reducer, void 0, getInitialState);
  const [state, dispatch] = store;
  const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
  const [status, setStatus] = reactExports.useState(Status.Uninitialized);
  const isInitialized = status === Status.Initialized;
  const {
    draggable: {
      active: activeId,
      nodes: draggableNodes,
      translate: translate2
    },
    droppable: {
      containers: droppableContainers
    }
  } = state;
  const node = activeId != null ? draggableNodes.get(activeId) : null;
  const activeRects = reactExports.useRef({
    initial: null,
    translated: null
  });
  const active = reactExports.useMemo(() => {
    var _node$data;
    return activeId != null ? {
      id: activeId,
      // It's possible for the active node to unmount while dragging
      data: (_node$data = node == null ? void 0 : node.data) != null ? _node$data : defaultData,
      rect: activeRects
    } : null;
  }, [activeId, node]);
  const activeRef = reactExports.useRef(null);
  const [activeSensor, setActiveSensor] = reactExports.useState(null);
  const [activatorEvent, setActivatorEvent] = reactExports.useState(null);
  const latestProps = useLatestValue(props, Object.values(props));
  const draggableDescribedById = useUniqueId("DndDescribedBy", id);
  const enabledDroppableContainers = reactExports.useMemo(() => droppableContainers.getEnabled(), [droppableContainers]);
  const measuringConfiguration = useMeasuringConfiguration(measuring);
  const {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled
  } = useDroppableMeasuring(enabledDroppableContainers, {
    dragging: isInitialized,
    dependencies: [translate2.x, translate2.y],
    config: measuringConfiguration.droppable
  });
  const activeNode = useCachedNode(draggableNodes, activeId);
  const activationCoordinates = reactExports.useMemo(() => activatorEvent ? getEventCoordinates(activatorEvent) : null, [activatorEvent]);
  const autoScrollOptions = getAutoScrollerOptions();
  const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);
  useLayoutShiftScrollCompensation({
    activeNode: activeId != null ? draggableNodes.get(activeId) : null,
    config: autoScrollOptions.layoutShiftCompensation,
    initialRect: initialActiveNodeRect,
    measure: measuringConfiguration.draggable.measure
  });
  const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);
  const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);
  const sensorContext = reactExports.useRef({
    activatorEvent: null,
    active: null,
    activeNode,
    collisionRect: null,
    collisions: null,
    droppableRects,
    draggableNodes,
    draggingNode: null,
    draggingNodeRect: null,
    droppableContainers,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null
  });
  const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
  const dragOverlay = useDragOverlayMeasuring({
    measure: measuringConfiguration.dragOverlay.measure
  });
  const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;
  const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;
  const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect);
  const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect);
  const windowRect = useWindowRect(draggingNode ? getWindow(draggingNode) : null);
  const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);
  const scrollableAncestorRects = useRects(scrollableAncestors);
  const modifiedTranslate = applyModifiers(modifiers, {
    transform: {
      x: translate2.x - nodeRectDelta.x,
      y: translate2.y - nodeRectDelta.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggingNodeRect,
    over: sensorContext.current.over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect
  });
  const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate2) : null;
  const scrollOffsets = useScrollOffsets(scrollableAncestors);
  const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets);
  const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [activeNodeRect]);
  const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
  const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
  const collisions = active && collisionRect ? collisionDetection({
    active,
    collisionRect,
    droppableRects,
    droppableContainers: enabledDroppableContainers,
    pointerCoordinates
  }) : null;
  const overId = getFirstCollision(collisions, "id");
  const [over, setOver] = reactExports.useState(null);
  const appliedTranslate = usesDragOverlay ? modifiedTranslate : add(modifiedTranslate, activeNodeScrollDelta);
  const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
  const activeSensorRef = reactExports.useRef(null);
  const instantiateSensor = reactExports.useCallback(
    (event2, _ref2) => {
      let {
        sensor: Sensor,
        options
      } = _ref2;
      if (activeRef.current == null) {
        return;
      }
      const activeNode2 = draggableNodes.get(activeRef.current);
      if (!activeNode2) {
        return;
      }
      const activatorEvent2 = event2.nativeEvent;
      const sensorInstance = new Sensor({
        active: activeRef.current,
        activeNode: activeNode2,
        event: activatorEvent2,
        options,
        // Sensors need to be instantiated with refs for arguments that change over time
        // otherwise they are frozen in time with the stale arguments
        context: sensorContext,
        onAbort(id2) {
          const draggableNode = draggableNodes.get(id2);
          if (!draggableNode) {
            return;
          }
          const {
            onDragAbort
          } = latestProps.current;
          const event3 = {
            id: id2
          };
          onDragAbort == null ? void 0 : onDragAbort(event3);
          dispatchMonitorEvent({
            type: "onDragAbort",
            event: event3
          });
        },
        onPending(id2, constraint, initialCoordinates, offset) {
          const draggableNode = draggableNodes.get(id2);
          if (!draggableNode) {
            return;
          }
          const {
            onDragPending
          } = latestProps.current;
          const event3 = {
            id: id2,
            constraint,
            initialCoordinates,
            offset
          };
          onDragPending == null ? void 0 : onDragPending(event3);
          dispatchMonitorEvent({
            type: "onDragPending",
            event: event3
          });
        },
        onStart(initialCoordinates) {
          const id2 = activeRef.current;
          if (id2 == null) {
            return;
          }
          const draggableNode = draggableNodes.get(id2);
          if (!draggableNode) {
            return;
          }
          const {
            onDragStart
          } = latestProps.current;
          const event3 = {
            activatorEvent: activatorEvent2,
            active: {
              id: id2,
              data: draggableNode.data,
              rect: activeRects
            }
          };
          reactDomExports.unstable_batchedUpdates(() => {
            onDragStart == null ? void 0 : onDragStart(event3);
            setStatus(Status.Initializing);
            dispatch({
              type: Action.DragStart,
              initialCoordinates,
              active: id2
            });
            dispatchMonitorEvent({
              type: "onDragStart",
              event: event3
            });
            setActiveSensor(activeSensorRef.current);
            setActivatorEvent(activatorEvent2);
          });
        },
        onMove(coordinates) {
          dispatch({
            type: Action.DragMove,
            coordinates
          });
        },
        onEnd: createHandler(Action.DragEnd),
        onCancel: createHandler(Action.DragCancel)
      });
      activeSensorRef.current = sensorInstance;
      function createHandler(type) {
        return async function handler() {
          const {
            active: active2,
            collisions: collisions2,
            over: over2,
            scrollAdjustedTranslate: scrollAdjustedTranslate2
          } = sensorContext.current;
          let event3 = null;
          if (active2 && scrollAdjustedTranslate2) {
            const {
              cancelDrop
            } = latestProps.current;
            event3 = {
              activatorEvent: activatorEvent2,
              active: active2,
              collisions: collisions2,
              delta: scrollAdjustedTranslate2,
              over: over2
            };
            if (type === Action.DragEnd && typeof cancelDrop === "function") {
              const shouldCancel = await Promise.resolve(cancelDrop(event3));
              if (shouldCancel) {
                type = Action.DragCancel;
              }
            }
          }
          activeRef.current = null;
          reactDomExports.unstable_batchedUpdates(() => {
            dispatch({
              type
            });
            setStatus(Status.Uninitialized);
            setOver(null);
            setActiveSensor(null);
            setActivatorEvent(null);
            activeSensorRef.current = null;
            const eventName = type === Action.DragEnd ? "onDragEnd" : "onDragCancel";
            if (event3) {
              const handler2 = latestProps.current[eventName];
              handler2 == null ? void 0 : handler2(event3);
              dispatchMonitorEvent({
                type: eventName,
                event: event3
              });
            }
          });
        };
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [draggableNodes]
  );
  const bindActivatorToSensorInstantiator = reactExports.useCallback((handler, sensor) => {
    return (event2, active2) => {
      const nativeEvent = event2.nativeEvent;
      const activeDraggableNode = draggableNodes.get(active2);
      if (
        // Another sensor is already instantiating
        activeRef.current !== null || // No active draggable
        !activeDraggableNode || // Event has already been captured
        nativeEvent.dndKit || nativeEvent.defaultPrevented
      ) {
        return;
      }
      const activationContext = {
        active: activeDraggableNode
      };
      const shouldActivate = handler(event2, sensor.options, activationContext);
      if (shouldActivate === true) {
        nativeEvent.dndKit = {
          capturedBy: sensor.sensor
        };
        activeRef.current = active2;
        instantiateSensor(event2, sensor);
      }
    };
  }, [draggableNodes, instantiateSensor]);
  const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
  useSensorSetup(sensors);
  useIsomorphicLayoutEffect(() => {
    if (activeNodeRect && status === Status.Initializing) {
      setStatus(Status.Initialized);
    }
  }, [activeNodeRect, status]);
  reactExports.useEffect(
    () => {
      const {
        onDragMove
      } = latestProps.current;
      const {
        active: active2,
        activatorEvent: activatorEvent2,
        collisions: collisions2,
        over: over2
      } = sensorContext.current;
      if (!active2 || !activatorEvent2) {
        return;
      }
      const event2 = {
        active: active2,
        activatorEvent: activatorEvent2,
        collisions: collisions2,
        delta: {
          x: scrollAdjustedTranslate.x,
          y: scrollAdjustedTranslate.y
        },
        over: over2
      };
      reactDomExports.unstable_batchedUpdates(() => {
        onDragMove == null ? void 0 : onDragMove(event2);
        dispatchMonitorEvent({
          type: "onDragMove",
          event: event2
        });
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]
  );
  reactExports.useEffect(
    () => {
      const {
        active: active2,
        activatorEvent: activatorEvent2,
        collisions: collisions2,
        droppableContainers: droppableContainers2,
        scrollAdjustedTranslate: scrollAdjustedTranslate2
      } = sensorContext.current;
      if (!active2 || activeRef.current == null || !activatorEvent2 || !scrollAdjustedTranslate2) {
        return;
      }
      const {
        onDragOver
      } = latestProps.current;
      const overContainer = droppableContainers2.get(overId);
      const over2 = overContainer && overContainer.rect.current ? {
        id: overContainer.id,
        rect: overContainer.rect.current,
        data: overContainer.data,
        disabled: overContainer.disabled
      } : null;
      const event2 = {
        active: active2,
        activatorEvent: activatorEvent2,
        collisions: collisions2,
        delta: {
          x: scrollAdjustedTranslate2.x,
          y: scrollAdjustedTranslate2.y
        },
        over: over2
      };
      reactDomExports.unstable_batchedUpdates(() => {
        setOver(over2);
        onDragOver == null ? void 0 : onDragOver(event2);
        dispatchMonitorEvent({
          type: "onDragOver",
          event: event2
        });
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [overId]
  );
  useIsomorphicLayoutEffect(() => {
    sensorContext.current = {
      activatorEvent,
      active,
      activeNode,
      collisionRect,
      collisions,
      droppableRects,
      draggableNodes,
      draggingNode,
      draggingNodeRect,
      droppableContainers,
      over,
      scrollableAncestors,
      scrollAdjustedTranslate
    };
    activeRects.current = {
      initial: draggingNodeRect,
      translated: collisionRect
    };
  }, [active, activeNode, collisions, collisionRect, draggableNodes, draggingNode, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate]);
  useAutoScroller({
    ...autoScrollOptions,
    delta: translate2,
    draggingRect: collisionRect,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects
  });
  const publicContext = reactExports.useMemo(() => {
    const context2 = {
      active,
      activeNode,
      activeNodeRect,
      activatorEvent,
      collisions,
      containerNodeRect,
      dragOverlay,
      draggableNodes,
      droppableContainers,
      droppableRects,
      over,
      measureDroppableContainers,
      scrollableAncestors,
      scrollableAncestorRects,
      measuringConfiguration,
      measuringScheduled,
      windowRect
    };
    return context2;
  }, [active, activeNode, activeNodeRect, activatorEvent, collisions, containerNodeRect, dragOverlay, draggableNodes, droppableContainers, droppableRects, over, measureDroppableContainers, scrollableAncestors, scrollableAncestorRects, measuringConfiguration, measuringScheduled, windowRect]);
  const internalContext = reactExports.useMemo(() => {
    const context2 = {
      activatorEvent,
      activators,
      active,
      activeNodeRect,
      ariaDescribedById: {
        draggable: draggableDescribedById
      },
      dispatch,
      draggableNodes,
      over,
      measureDroppableContainers
    };
    return context2;
  }, [activatorEvent, activators, active, activeNodeRect, dispatch, draggableDescribedById, draggableNodes, over, measureDroppableContainers]);
  return React.createElement(DndMonitorContext.Provider, {
    value: registerMonitorListener
  }, React.createElement(InternalContext.Provider, {
    value: internalContext
  }, React.createElement(PublicContext.Provider, {
    value: publicContext
  }, React.createElement(ActiveDraggableContext.Provider, {
    value: transform
  }, children)), React.createElement(RestoreFocus, {
    disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false
  })), React.createElement(Accessibility, {
    ...accessibility,
    hiddenTextDescribedById: draggableDescribedById
  }));
  function getAutoScrollerOptions() {
    const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
    const autoScrollGloballyDisabled = typeof autoScroll === "object" ? autoScroll.enabled === false : autoScroll === false;
    const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
    if (typeof autoScroll === "object") {
      return {
        ...autoScroll,
        enabled
      };
    }
    return {
      enabled
    };
  }
});
const NullContext = /* @__PURE__ */ reactExports.createContext(null);
const defaultRole = "button";
const ID_PREFIX$1 = "Draggable";
function useDraggable(_ref) {
  let {
    id,
    data,
    disabled = false,
    attributes
  } = _ref;
  const key = useUniqueId(ID_PREFIX$1);
  const {
    activators,
    activatorEvent,
    active,
    activeNodeRect,
    ariaDescribedById,
    draggableNodes,
    over
  } = reactExports.useContext(InternalContext);
  const {
    role = defaultRole,
    roleDescription = "draggable",
    tabIndex = 0
  } = attributes != null ? attributes : {};
  const isDragging = (active == null ? void 0 : active.id) === id;
  const transform = reactExports.useContext(isDragging ? ActiveDraggableContext : NullContext);
  const [node, setNodeRef] = useNodeRef();
  const [activatorNode, setActivatorNodeRef] = useNodeRef();
  const listeners = useSyntheticListeners(activators, id);
  const dataRef = useLatestValue(data);
  useIsomorphicLayoutEffect(
    () => {
      draggableNodes.set(id, {
        id,
        key,
        node,
        activatorNode,
        data: dataRef
      });
      return () => {
        const node2 = draggableNodes.get(id);
        if (node2 && node2.key === key) {
          draggableNodes.delete(id);
        }
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [draggableNodes, id]
  );
  const memoizedAttributes = reactExports.useMemo(() => ({
    role,
    tabIndex,
    "aria-disabled": disabled,
    "aria-pressed": isDragging && role === defaultRole ? true : void 0,
    "aria-roledescription": roleDescription,
    "aria-describedby": ariaDescribedById.draggable
  }), [disabled, role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
  return {
    active,
    activatorEvent,
    activeNodeRect,
    attributes: memoizedAttributes,
    isDragging,
    listeners: disabled ? void 0 : listeners,
    node,
    over,
    setNodeRef,
    setActivatorNodeRef,
    transform
  };
}
function useDndContext() {
  return reactExports.useContext(PublicContext);
}
const ID_PREFIX$1$1 = "Droppable";
const defaultResizeObserverConfig = {
  timeout: 25
};
function useDroppable(_ref) {
  let {
    data,
    disabled = false,
    id,
    resizeObserverConfig
  } = _ref;
  const key = useUniqueId(ID_PREFIX$1$1);
  const {
    active,
    dispatch,
    over,
    measureDroppableContainers
  } = reactExports.useContext(InternalContext);
  const previous = reactExports.useRef({
    disabled
  });
  const resizeObserverConnected = reactExports.useRef(false);
  const rect = reactExports.useRef(null);
  const callbackId = reactExports.useRef(null);
  const {
    disabled: resizeObserverDisabled,
    updateMeasurementsFor,
    timeout: resizeObserverTimeout
  } = {
    ...defaultResizeObserverConfig,
    ...resizeObserverConfig
  };
  const ids2 = useLatestValue(updateMeasurementsFor != null ? updateMeasurementsFor : id);
  const handleResize = reactExports.useCallback(
    () => {
      if (!resizeObserverConnected.current) {
        resizeObserverConnected.current = true;
        return;
      }
      if (callbackId.current != null) {
        clearTimeout(callbackId.current);
      }
      callbackId.current = setTimeout(() => {
        measureDroppableContainers(Array.isArray(ids2.current) ? ids2.current : [ids2.current]);
        callbackId.current = null;
      }, resizeObserverTimeout);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [resizeObserverTimeout]
  );
  const resizeObserver = useResizeObserver({
    callback: handleResize,
    disabled: resizeObserverDisabled || !active
  });
  const handleNodeChange = reactExports.useCallback((newElement, previousElement) => {
    if (!resizeObserver) {
      return;
    }
    if (previousElement) {
      resizeObserver.unobserve(previousElement);
      resizeObserverConnected.current = false;
    }
    if (newElement) {
      resizeObserver.observe(newElement);
    }
  }, [resizeObserver]);
  const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
  const dataRef = useLatestValue(data);
  reactExports.useEffect(() => {
    if (!resizeObserver || !nodeRef.current) {
      return;
    }
    resizeObserver.disconnect();
    resizeObserverConnected.current = false;
    resizeObserver.observe(nodeRef.current);
  }, [nodeRef, resizeObserver]);
  reactExports.useEffect(
    () => {
      dispatch({
        type: Action.RegisterDroppable,
        element: {
          id,
          key,
          disabled,
          node: nodeRef,
          rect,
          data: dataRef
        }
      });
      return () => dispatch({
        type: Action.UnregisterDroppable,
        key,
        id
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [id]
  );
  reactExports.useEffect(() => {
    if (disabled !== previous.current.disabled) {
      dispatch({
        type: Action.SetDroppableDisabled,
        id,
        key,
        disabled
      });
      previous.current.disabled = disabled;
    }
  }, [id, key, disabled, dispatch]);
  return {
    active,
    rect,
    isOver: (over == null ? void 0 : over.id) === id,
    node: nodeRef,
    over,
    setNodeRef
  };
}
function arrayMove(array2, from, to2) {
  const newArray = array2.slice();
  newArray.splice(to2 < 0 ? newArray.length + to2 : to2, 0, newArray.splice(from, 1)[0]);
  return newArray;
}
function getSortedRects(items, rects) {
  return items.reduce((accumulator, id, index) => {
    const rect = rects.get(id);
    if (rect) {
      accumulator[index] = rect;
    }
    return accumulator;
  }, Array(items.length));
}
function isValidIndex(index) {
  return index !== null && index >= 0;
}
function itemsEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (a2.length !== b2.length) {
    return false;
  }
  for (let i2 = 0; i2 < a2.length; i2++) {
    if (a2[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
function normalizeDisabled(disabled) {
  if (typeof disabled === "boolean") {
    return {
      draggable: disabled,
      droppable: disabled
    };
  }
  return disabled;
}
const rectSortingStrategy = (_ref) => {
  let {
    rects,
    activeIndex,
    overIndex,
    index
  } = _ref;
  const newRects = arrayMove(rects, overIndex, activeIndex);
  const oldRect = rects[index];
  const newRect = newRects[index];
  if (!newRect || !oldRect) {
    return null;
  }
  return {
    x: newRect.left - oldRect.left,
    y: newRect.top - oldRect.top,
    scaleX: newRect.width / oldRect.width,
    scaleY: newRect.height / oldRect.height
  };
};
const defaultScale$1 = {
  scaleX: 1,
  scaleY: 1
};
const verticalListSortingStrategy = (_ref) => {
  var _rects$activeIndex;
  let {
    activeIndex,
    activeNodeRect: fallbackActiveRect,
    index,
    rects,
    overIndex
  } = _ref;
  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
  if (!activeNodeRect) {
    return null;
  }
  if (index === activeIndex) {
    const overIndexRect = rects[overIndex];
    if (!overIndexRect) {
      return null;
    }
    return {
      x: 0,
      y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,
      ...defaultScale$1
    };
  }
  const itemGap = getItemGap$1(rects, index, activeIndex);
  if (index > activeIndex && index <= overIndex) {
    return {
      x: 0,
      y: -activeNodeRect.height - itemGap,
      ...defaultScale$1
    };
  }
  if (index < activeIndex && index >= overIndex) {
    return {
      x: 0,
      y: activeNodeRect.height + itemGap,
      ...defaultScale$1
    };
  }
  return {
    x: 0,
    y: 0,
    ...defaultScale$1
  };
};
function getItemGap$1(clientRects, index, activeIndex) {
  const currentRect = clientRects[index];
  const previousRect = clientRects[index - 1];
  const nextRect = clientRects[index + 1];
  if (!currentRect) {
    return 0;
  }
  if (activeIndex < index) {
    return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;
  }
  return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;
}
const ID_PREFIX = "Sortable";
const Context = /* @__PURE__ */ React.createContext({
  activeIndex: -1,
  containerId: ID_PREFIX,
  disableTransforms: false,
  items: [],
  overIndex: -1,
  useDragOverlay: false,
  sortedRects: [],
  strategy: rectSortingStrategy,
  disabled: {
    draggable: false,
    droppable: false
  }
});
function SortableContext(_ref) {
  let {
    children,
    id,
    items: userDefinedItems,
    strategy = rectSortingStrategy,
    disabled: disabledProp = false
  } = _ref;
  const {
    active,
    dragOverlay,
    droppableRects,
    over,
    measureDroppableContainers
  } = useDndContext();
  const containerId = useUniqueId(ID_PREFIX, id);
  const useDragOverlay = Boolean(dragOverlay.rect !== null);
  const items = reactExports.useMemo(() => userDefinedItems.map((item) => typeof item === "object" && "id" in item ? item.id : item), [userDefinedItems]);
  const isDragging = active != null;
  const activeIndex = active ? items.indexOf(active.id) : -1;
  const overIndex = over ? items.indexOf(over.id) : -1;
  const previousItemsRef = reactExports.useRef(items);
  const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);
  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
  const disabled = normalizeDisabled(disabledProp);
  useIsomorphicLayoutEffect(() => {
    if (itemsHaveChanged && isDragging) {
      measureDroppableContainers(items);
    }
  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);
  reactExports.useEffect(() => {
    previousItemsRef.current = items;
  }, [items]);
  const contextValue = reactExports.useMemo(
    () => ({
      activeIndex,
      containerId,
      disabled,
      disableTransforms,
      items,
      overIndex,
      useDragOverlay,
      sortedRects: getSortedRects(items, droppableRects),
      strategy
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]
  );
  return React.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
const defaultNewIndexGetter = (_ref) => {
  let {
    id,
    items,
    activeIndex,
    overIndex
  } = _ref;
  return arrayMove(items, activeIndex, overIndex).indexOf(id);
};
const defaultAnimateLayoutChanges = (_ref2) => {
  let {
    containerId,
    isSorting,
    wasDragging,
    index,
    items,
    newIndex,
    previousItems,
    previousContainerId,
    transition: transition2
  } = _ref2;
  if (!transition2 || !wasDragging) {
    return false;
  }
  if (previousItems !== items && index === newIndex) {
    return false;
  }
  if (isSorting) {
    return true;
  }
  return newIndex !== index && containerId === previousContainerId;
};
const defaultTransition = {
  duration: 200,
  easing: "ease"
};
const transitionProperty = "transform";
const disabledTransition = /* @__PURE__ */ CSS.Transition.toString({
  property: transitionProperty,
  duration: 0,
  easing: "linear"
});
const defaultAttributes = {
  roleDescription: "sortable"
};
function useDerivedTransform(_ref) {
  let {
    disabled,
    index,
    node,
    rect
  } = _ref;
  const [derivedTransform, setDerivedtransform] = reactExports.useState(null);
  const previousIndex = reactExports.useRef(index);
  useIsomorphicLayoutEffect(() => {
    if (!disabled && index !== previousIndex.current && node.current) {
      const initial = rect.current;
      if (initial) {
        const current2 = getClientRect(node.current, {
          ignoreTransform: true
        });
        const delta = {
          x: initial.left - current2.left,
          y: initial.top - current2.top,
          scaleX: initial.width / current2.width,
          scaleY: initial.height / current2.height
        };
        if (delta.x || delta.y) {
          setDerivedtransform(delta);
        }
      }
    }
    if (index !== previousIndex.current) {
      previousIndex.current = index;
    }
  }, [disabled, index, node, rect]);
  reactExports.useEffect(() => {
    if (derivedTransform) {
      setDerivedtransform(null);
    }
  }, [derivedTransform]);
  return derivedTransform;
}
function useSortable(_ref) {
  let {
    animateLayoutChanges = defaultAnimateLayoutChanges,
    attributes: userDefinedAttributes,
    disabled: localDisabled,
    data: customData,
    getNewIndex = defaultNewIndexGetter,
    id,
    strategy: localStrategy,
    resizeObserverConfig,
    transition: transition2 = defaultTransition
  } = _ref;
  const {
    items,
    containerId,
    activeIndex,
    disabled: globalDisabled,
    disableTransforms,
    sortedRects,
    overIndex,
    useDragOverlay,
    strategy: globalStrategy
  } = reactExports.useContext(Context);
  const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);
  const index = items.indexOf(id);
  const data = reactExports.useMemo(() => ({
    sortable: {
      containerId,
      index,
      items
    },
    ...customData
  }), [containerId, customData, index, items]);
  const itemsAfterCurrentSortable = reactExports.useMemo(() => items.slice(items.indexOf(id)), [items, id]);
  const {
    rect,
    node,
    isOver,
    setNodeRef: setDroppableNodeRef
  } = useDroppable({
    id,
    data,
    disabled: disabled.droppable,
    resizeObserverConfig: {
      updateMeasurementsFor: itemsAfterCurrentSortable,
      ...resizeObserverConfig
    }
  });
  const {
    active,
    activatorEvent,
    activeNodeRect,
    attributes,
    setNodeRef: setDraggableNodeRef,
    listeners,
    isDragging,
    over,
    setActivatorNodeRef,
    transform
  } = useDraggable({
    id,
    data,
    attributes: {
      ...defaultAttributes,
      ...userDefinedAttributes
    },
    disabled: disabled.draggable
  });
  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
  const isSorting = Boolean(active);
  const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
  const shouldDisplaceDragSource = !useDragOverlay && isDragging;
  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
  const strategy = localStrategy != null ? localStrategy : globalStrategy;
  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
    rects: sortedRects,
    activeNodeRect,
    activeIndex,
    overIndex,
    index
  }) : null;
  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
    id,
    items,
    activeIndex,
    overIndex
  }) : index;
  const activeId = active == null ? void 0 : active.id;
  const previous = reactExports.useRef({
    activeId,
    items,
    newIndex,
    containerId
  });
  const itemsHaveChanged = items !== previous.current.items;
  const shouldAnimateLayoutChanges = animateLayoutChanges({
    active,
    containerId,
    isDragging,
    isSorting,
    id,
    index,
    items,
    newIndex: previous.current.newIndex,
    previousItems: previous.current.items,
    previousContainerId: previous.current.containerId,
    transition: transition2,
    wasDragging: previous.current.activeId != null
  });
  const derivedTransform = useDerivedTransform({
    disabled: !shouldAnimateLayoutChanges,
    index,
    node,
    rect
  });
  reactExports.useEffect(() => {
    if (isSorting && previous.current.newIndex !== newIndex) {
      previous.current.newIndex = newIndex;
    }
    if (containerId !== previous.current.containerId) {
      previous.current.containerId = containerId;
    }
    if (items !== previous.current.items) {
      previous.current.items = items;
    }
  }, [isSorting, newIndex, containerId, items]);
  reactExports.useEffect(() => {
    if (activeId === previous.current.activeId) {
      return;
    }
    if (activeId && !previous.current.activeId) {
      previous.current.activeId = activeId;
      return;
    }
    const timeoutId = setTimeout(() => {
      previous.current.activeId = activeId;
    }, 50);
    return () => clearTimeout(timeoutId);
  }, [activeId]);
  return {
    active,
    activeIndex,
    attributes,
    data,
    rect,
    index,
    newIndex,
    items,
    isOver,
    isSorting,
    isDragging,
    listeners,
    node,
    overIndex,
    over,
    setNodeRef,
    setActivatorNodeRef,
    setDroppableNodeRef,
    setDraggableNodeRef,
    transform: derivedTransform != null ? derivedTransform : finalTransform,
    transition: getTransition()
  };
  function getTransition() {
    if (
      // Temporarily disable transitions for a single frame to set up derived transforms
      derivedTransform || // Or to prevent items jumping to back to their "new" position when items change
      itemsHaveChanged && previous.current.newIndex === index
    ) {
      return disabledTransition;
    }
    if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition2) {
      return void 0;
    }
    if (isSorting || shouldAnimateLayoutChanges) {
      return CSS.Transition.toString({
        ...transition2,
        property: transitionProperty
      });
    }
    return void 0;
  }
}
function normalizeLocalDisabled(localDisabled, globalDisabled) {
  var _localDisabled$dragga, _localDisabled$droppa;
  if (typeof localDisabled === "boolean") {
    return {
      draggable: localDisabled,
      // Backwards compatibility
      droppable: false
    };
  }
  return {
    draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,
    droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable
  };
}
function hasSortableData(entry) {
  if (!entry) {
    return false;
  }
  const data = entry.data.current;
  if (data && "sortable" in data && typeof data.sortable === "object" && "containerId" in data.sortable && "items" in data.sortable && "index" in data.sortable) {
    return true;
  }
  return false;
}
const directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
const sortableKeyboardCoordinates = (event2, _ref) => {
  let {
    context: {
      active,
      collisionRect,
      droppableRects,
      droppableContainers,
      over,
      scrollableAncestors
    }
  } = _ref;
  if (directions.includes(event2.code)) {
    event2.preventDefault();
    if (!active || !collisionRect) {
      return;
    }
    const filteredContainers = [];
    droppableContainers.getEnabled().forEach((entry) => {
      if (!entry || entry != null && entry.disabled) {
        return;
      }
      const rect = droppableRects.get(entry.id);
      if (!rect) {
        return;
      }
      switch (event2.code) {
        case KeyboardCode.Down:
          if (collisionRect.top < rect.top) {
            filteredContainers.push(entry);
          }
          break;
        case KeyboardCode.Up:
          if (collisionRect.top > rect.top) {
            filteredContainers.push(entry);
          }
          break;
        case KeyboardCode.Left:
          if (collisionRect.left > rect.left) {
            filteredContainers.push(entry);
          }
          break;
        case KeyboardCode.Right:
          if (collisionRect.left < rect.left) {
            filteredContainers.push(entry);
          }
          break;
      }
    });
    const collisions = closestCorners({
      collisionRect,
      droppableRects,
      droppableContainers: filteredContainers
    });
    let closestId = getFirstCollision(collisions, "id");
    if (closestId === (over == null ? void 0 : over.id) && collisions.length > 1) {
      closestId = collisions[1].id;
    }
    if (closestId != null) {
      const activeDroppable = droppableContainers.get(active.id);
      const newDroppable = droppableContainers.get(closestId);
      const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;
      const newNode = newDroppable == null ? void 0 : newDroppable.node.current;
      if (newNode && newRect && activeDroppable && newDroppable) {
        const newScrollAncestors = getScrollableAncestors(newNode);
        const hasDifferentScrollAncestors = newScrollAncestors.some((element, index) => scrollableAncestors[index] !== element);
        const hasSameContainer = isSameContainer(activeDroppable, newDroppable);
        const isAfterActive = isAfter(activeDroppable, newDroppable);
        const offset = hasDifferentScrollAncestors || !hasSameContainer ? {
          x: 0,
          y: 0
        } : {
          x: isAfterActive ? collisionRect.width - newRect.width : 0,
          y: isAfterActive ? collisionRect.height - newRect.height : 0
        };
        const rectCoordinates = {
          x: newRect.left,
          y: newRect.top
        };
        const newCoordinates = offset.x && offset.y ? rectCoordinates : subtract(rectCoordinates, offset);
        return newCoordinates;
      }
    }
  }
  return void 0;
};
function isSameContainer(a2, b2) {
  if (!hasSortableData(a2) || !hasSortableData(b2)) {
    return false;
  }
  return a2.data.current.sortable.containerId === b2.data.current.sortable.containerId;
}
function isAfter(a2, b2) {
  if (!hasSortableData(a2) || !hasSortableData(b2)) {
    return false;
  }
  if (!isSameContainer(a2, b2)) {
    return false;
  }
  return a2.data.current.sortable.index < b2.data.current.sortable.index;
}
var f$1 = /* @__PURE__ */ ((e2) => (e2.Mouse = "mouse", e2.Touch = "touch", e2.Pointer = "pointer", e2))(f$1 || {}), l$1 = /* @__PURE__ */ ((e2) => (e2.CancelledByMovement = "cancelled-by-movement", e2.CancelledByRelease = "cancelled-by-release", e2.CancelledOutsideElement = "cancelled-outside-element", e2))(l$1 || {});
const b$1 = [
  "mousedown",
  "mousemove",
  "mouseup",
  "mouseleave",
  "mouseout"
], q = [
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel"
], z = [
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointerout"
];
function G(e2) {
  return typeof e2 == "object" && e2 !== null && "pageX" in e2 && typeof e2.pageX == "number" && "pageY" in e2 && typeof e2.pageY == "number";
}
function J(e2) {
  var u2;
  return b$1.includes((u2 = e2 == null ? void 0 : e2.nativeEvent) == null ? void 0 : u2.type);
}
function U(e2) {
  var u2;
  return q.includes((u2 = e2 == null ? void 0 : e2.nativeEvent) == null ? void 0 : u2.type) || "touches" in e2;
}
function K(e2) {
  const { nativeEvent: u2 } = e2;
  return u2 ? z.includes(u2 == null ? void 0 : u2.type) || "pointerId" in u2 : false;
}
function D(e2) {
  return J(e2) || U(e2) || K(e2);
}
function A(e2) {
  var s2;
  const u2 = U(e2) ? (s2 = e2 == null ? void 0 : e2.touches) == null ? void 0 : s2[0] : e2;
  return G(u2) ? {
    x: u2.pageX,
    y: u2.pageY
  } : null;
}
function N(e2) {
  return {
    target: e2.target,
    currentTarget: e2.currentTarget,
    nativeEvent: e2,
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    persist: () => {
    }
  };
}
function V(e2, {
  threshold: u2 = 400,
  captureEvent: s2 = false,
  detect: R = f$1.Pointer,
  cancelOnMovement: p2 = false,
  cancelOutsideElement: T = true,
  filterEvents: M2,
  onStart: m2,
  onMove: w2,
  onFinish: g2,
  onCancel: h2
} = {}) {
  const L = reactExports.useRef(false), c2 = reactExports.useRef(false), H2 = reactExports.useRef(), d2 = reactExports.useRef(), B = reactExports.useRef(e2), a2 = reactExports.useRef(null), y2 = reactExports.useCallback(
    (r2) => (t2) => {
      c2.current || D(t2) && (M2 !== void 0 && !M2(t2) || (s2 && t2.persist(), m2 == null || m2(t2, { context: r2 }), a2.current = A(t2), c2.current = true, H2.current = t2.currentTarget, d2.current = setTimeout(() => {
        B.current && (B.current(t2, { context: r2 }), L.current = true);
      }, u2)));
    },
    [s2, M2, m2, u2]
  ), o2 = reactExports.useCallback(
    (r2) => (t2, n2) => {
      D(t2) && c2.current && (a2.current = null, s2 && t2.persist(), L.current ? g2 == null || g2(t2, { context: r2 }) : c2.current && (h2 == null || h2(t2, { context: r2, reason: n2 != null ? n2 : l$1.CancelledByRelease })), L.current = false, c2.current = false, d2.current !== void 0 && clearTimeout(d2.current));
    },
    [s2, g2, h2]
  ), E2 = reactExports.useCallback(
    (r2) => (t2) => {
      if (D(t2) && (w2 == null || w2(t2, { context: r2 }), p2 !== false && a2.current)) {
        const n2 = A(t2);
        if (n2) {
          const X2 = p2 === true ? 25 : p2, Y2 = {
            x: Math.abs(n2.x - a2.current.x),
            y: Math.abs(n2.y - a2.current.y)
          };
          (Y2.x > X2 || Y2.y > X2) && o2(r2)(t2, l$1.CancelledByMovement);
        }
      }
    },
    [o2, p2, w2]
  ), I = reactExports.useCallback(
    (r2) => {
      if (e2 === null)
        return {};
      switch (R) {
        case f$1.Mouse: {
          const t2 = {
            onMouseDown: y2(r2),
            onMouseMove: E2(r2),
            onMouseUp: o2(r2)
          };
          return T && (t2.onMouseLeave = (n2) => {
            o2(r2)(n2, l$1.CancelledOutsideElement);
          }), t2;
        }
        case f$1.Touch:
          return {
            onTouchStart: y2(r2),
            onTouchMove: E2(r2),
            onTouchEnd: o2(r2)
          };
        case f$1.Pointer: {
          const t2 = {
            onPointerDown: y2(r2),
            onPointerMove: E2(r2),
            onPointerUp: o2(r2)
          };
          return T && (t2.onPointerLeave = (n2) => o2(r2)(n2, l$1.CancelledOutsideElement)), t2;
        }
      }
    },
    [e2, o2, T, R, E2, y2]
  );
  return reactExports.useEffect(() => {
    function r2(t2) {
      const n2 = N(t2);
      o2()(n2);
    }
    return window.addEventListener("mouseup", r2), window.addEventListener("touchend", r2), window.addEventListener("pointerup", r2), () => {
      window.removeEventListener("mouseup", r2), window.removeEventListener("touchend", r2), window.removeEventListener("pointerup", r2);
    };
  }, [o2]), reactExports.useEffect(
    () => () => {
      d2.current !== void 0 && clearTimeout(d2.current);
    },
    []
  ), reactExports.useEffect(() => {
    B.current = e2;
  }, [e2]), I;
}
const millisecondsInWeek = 6048e5;
const millisecondsInDay = 864e5;
const millisecondsInMinute = 6e4;
const millisecondsInHour = 36e5;
const millisecondsInSecond = 1e3;
const constructFromSymbol = Symbol.for("constructDateFrom");
function constructFrom(date2, value) {
  if (typeof date2 === "function") return date2(value);
  if (date2 && typeof date2 === "object" && constructFromSymbol in date2)
    return date2[constructFromSymbol](value);
  if (date2 instanceof Date) return new date2.constructor(value);
  return new Date(value);
}
function toDate$1(argument, context2) {
  return constructFrom(context2 || argument, argument);
}
function addDays(date2, amount, options) {
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  if (isNaN(amount)) return constructFrom((options == null ? void 0 : options.in) || date2, NaN);
  if (!amount) return _date;
  _date.setDate(_date.getDate() + amount);
  return _date;
}
function addMonths(date2, amount, options) {
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  if (isNaN(amount)) return constructFrom(date2, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom(date2, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}
let defaultOptions = {};
function getDefaultOptions$1() {
  return defaultOptions;
}
function startOfWeek(date2, options) {
  var _a, _b, _c, _d, _e2, _f, _g, _h;
  const defaultOptions2 = getDefaultOptions$1();
  const weekStartsOn = (_h = (_g = (_d = (_c = options == null ? void 0 : options.weekStartsOn) != null ? _c : (_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) != null ? _d : defaultOptions2.weekStartsOn) != null ? _g : (_f = (_e2 = defaultOptions2.locale) == null ? void 0 : _e2.options) == null ? void 0 : _f.weekStartsOn) != null ? _h : 0;
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfISOWeek(date2, options) {
  return startOfWeek(date2, { ...options, weekStartsOn: 1 });
}
function getISOWeekYear(date2, options) {
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function getTimezoneOffsetInMilliseconds$1(date2) {
  const _date = toDate$1(date2);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date2 - +utcDate;
}
function normalizeDates(context2, ...dates) {
  const normalize = constructFrom.bind(
    null,
    context2 || dates.find((date2) => typeof date2 === "object")
  );
  return dates.map(normalize);
}
function startOfDay(date2, options) {
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function differenceInCalendarDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);
  const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds$1(laterStartOfDay);
  const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds$1(earlierStartOfDay);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}
function startOfISOWeekYear(date2, options) {
  const year = getISOWeekYear(date2, options);
  const fourthOfJanuary = constructFrom(date2, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}
function addMinutes(date2, amount, options) {
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  _date.setTime(_date.getTime() + amount * millisecondsInMinute);
  return _date;
}
function constructNow(date2) {
  return constructFrom(date2, Date.now());
}
function isSameDay(laterDate, earlierDate, options) {
  const [dateLeft_, dateRight_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  return +startOfDay(dateLeft_) === +startOfDay(dateRight_);
}
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(date2) {
  return !(!isDate(date2) && typeof date2 !== "number" || isNaN(+toDate$1(date2)));
}
function differenceInCalendarMonths(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
  const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
  return yearsDiff * 12 + monthsDiff;
}
function getRoundingMethod(method) {
  return (number2) => {
    const round = method ? Math[method] : Math.trunc;
    const result = round(number2);
    return result === 0 ? 0 : result;
  };
}
function differenceInMilliseconds(laterDate, earlierDate) {
  return +toDate$1(laterDate) - +toDate$1(earlierDate);
}
function differenceInMinutes(dateLeft, dateRight, options) {
  const diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
  return getRoundingMethod(options == null ? void 0 : options.roundingMethod)(diff);
}
function endOfMonth(date2, options) {
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function normalizeInterval(context2, interval) {
  const [start, end] = normalizeDates(context2, interval.start, interval.end);
  return { start, end };
}
function eachDayOfInterval(interval, options) {
  const { start, end } = normalizeInterval(options == null ? void 0 : options.in, interval);
  let reversed = +start > +end;
  const endTime = reversed ? +start : +end;
  const date2 = reversed ? end : start;
  date2.setHours(0, 0, 0, 0);
  let step = 1;
  const dates = [];
  while (+date2 <= endTime) {
    dates.push(constructFrom(start, date2));
    date2.setDate(date2.getDate() + step);
    date2.setHours(0, 0, 0, 0);
  }
  return reversed ? dates.reverse() : dates;
}
function startOfMonth(date2, options) {
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfYear(date2, options) {
  const date_ = toDate$1(date2, options == null ? void 0 : options.in);
  date_.setFullYear(date_.getFullYear(), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
const formatDistance = (token, count2, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count2.toString());
  }
  if (options == null ? void 0 : options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
const dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
function buildLocalizeFn(args) {
  return (value, options) => {
    const context2 = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
    let valuesArray;
    if (context2 === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index];
  };
}
const eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
const monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
const dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
const dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
const formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
const ordinalNumber = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "st";
      case 2:
        return number2 + "nd";
      case 3:
        return number2 + "rd";
    }
  }
  return number2 + "th";
};
const localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return (string2, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string2.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex2(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey2(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest2 = string2.slice(matchedString.length);
    return { value, rest: rest2 };
  };
}
function findKey2(object2, predicate) {
  for (const key in object2) {
    if (Object.prototype.hasOwnProperty.call(object2, key) && predicate(object2[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex2(array2, predicate) {
  for (let key = 0; key < array2.length; key++) {
    if (predicate(array2[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return (string2, options = {}) => {
    const matchResult = string2.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string2.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest2 = string2.slice(matchedString.length);
    return { value, rest: rest2 };
  };
}
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function getDayOfYear(date2, options) {
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}
function getISOWeek(date2, options) {
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function getWeekYear(date2, options) {
  var _a, _b, _c, _d, _e2, _f, _g, _h;
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions$1();
  const firstWeekContainsDate = (_h = (_g = (_d = (_c = options == null ? void 0 : options.firstWeekContainsDate) != null ? _c : (_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) != null ? _d : defaultOptions2.firstWeekContainsDate) != null ? _g : (_f = (_e2 = defaultOptions2.locale) == null ? void 0 : _e2.options) == null ? void 0 : _f.firstWeekContainsDate) != null ? _h : 1;
  const firstWeekOfNextYear = constructFrom((options == null ? void 0 : options.in) || date2, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom((options == null ? void 0 : options.in) || date2, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfWeekYear(date2, options) {
  var _a, _b, _c, _d, _e2, _f, _g, _h;
  const defaultOptions2 = getDefaultOptions$1();
  const firstWeekContainsDate = (_h = (_g = (_d = (_c = options == null ? void 0 : options.firstWeekContainsDate) != null ? _c : (_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) != null ? _d : defaultOptions2.firstWeekContainsDate) != null ? _g : (_f = (_e2 = defaultOptions2.locale) == null ? void 0 : _e2.options) == null ? void 0 : _f.firstWeekContainsDate) != null ? _h : 1;
  const year = getWeekYear(date2, options);
  const firstWeek = constructFrom((options == null ? void 0 : options.in) || date2, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}
function getWeek(date2, options) {
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function addLeadingZeros$1(number2, targetLength) {
  const sign = number2 < 0 ? "-" : "";
  const output3 = Math.abs(number2).toString().padStart(targetLength, "0");
  return sign + output3;
}
const lightFormatters = {
  // Year
  y(date2, token) {
    const signedYear = date2.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros$1(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date2, token) {
    const month = date2.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros$1(month + 1, 2);
  },
  // Day of the month
  d(date2, token) {
    return addLeadingZeros$1(date2.getDate(), token.length);
  },
  // AM or PM
  a(date2, token) {
    const dayPeriodEnumValue = date2.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date2, token) {
    return addLeadingZeros$1(date2.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date2, token) {
    return addLeadingZeros$1(date2.getHours(), token.length);
  },
  // Minute
  m(date2, token) {
    return addLeadingZeros$1(date2.getMinutes(), token.length);
  },
  // Second
  s(date2, token) {
    return addLeadingZeros$1(date2.getSeconds(), token.length);
  },
  // Fraction of second
  S(date2, token) {
    const numberOfDigits = token.length;
    const milliseconds = date2.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros$1(fractionalSeconds, token.length);
  }
};
const dayPeriodEnum = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
const formatters$1 = {
  // Era
  G: function(date2, token, localize2) {
    const era = date2.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date2, token, localize2) {
    if (token === "yo") {
      const signedYear = date2.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date2, token);
  },
  // Local week-numbering year
  Y: function(date2, token, localize2, options) {
    const signedWeekYear = getWeekYear(date2, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros$1(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros$1(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date2, token) {
    const isoWeekYear = getISOWeekYear(date2);
    return addLeadingZeros$1(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date2, token) {
    const year = date2.getFullYear();
    return addLeadingZeros$1(year, token.length);
  },
  // Quarter
  Q: function(date2, token, localize2) {
    const quarter = Math.ceil((date2.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros$1(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date2, token, localize2) {
    const quarter = Math.ceil((date2.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros$1(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date2, token, localize2) {
    const month = date2.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date2, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date2, token, localize2) {
    const month = date2.getMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros$1(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date2, token, localize2, options) {
    const week = getWeek(date2, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros$1(week, token.length);
  },
  // ISO week of year
  I: function(date2, token, localize2) {
    const isoWeek = getISOWeek(date2);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros$1(isoWeek, token.length);
  },
  // Day of the month
  d: function(date2, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date2.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date2, token);
  },
  // Day of year
  D: function(date2, token, localize2) {
    const dayOfYear = getDayOfYear(date2);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros$1(dayOfYear, token.length);
  },
  // Day of week
  E: function(date2, token, localize2) {
    const dayOfWeek = date2.getDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date2, token, localize2, options) {
    const dayOfWeek = date2.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros$1(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date2, token, localize2, options) {
    const dayOfWeek = date2.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros$1(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date2, token, localize2) {
    const dayOfWeek = date2.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros$1(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date2, token, localize2) {
    const hours = date2.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date2, token, localize2) {
    const hours = date2.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date2, token, localize2) {
    const hours = date2.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date2, token, localize2) {
    if (token === "ho") {
      let hours = date2.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date2, token);
  },
  // Hour [0-23]
  H: function(date2, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date2.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date2, token);
  },
  // Hour [0-11]
  K: function(date2, token, localize2) {
    const hours = date2.getHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros$1(hours, token.length);
  },
  // Hour [1-24]
  k: function(date2, token, localize2) {
    let hours = date2.getHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros$1(hours, token.length);
  },
  // Minute
  m: function(date2, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date2.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date2, token);
  },
  // Second
  s: function(date2, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date2.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date2, token);
  },
  // Fraction of second
  S: function(date2, token) {
    return lightFormatters.S(date2, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date2, token, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes$1(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone$1(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone$1(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date2, token, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes$1(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone$1(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone$1(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date2, token, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort$1(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone$1(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date2, token, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort$1(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone$1(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date2, token, _localize) {
    const timestamp = Math.trunc(+date2 / 1e3);
    return addLeadingZeros$1(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date2, token, _localize) {
    return addLeadingZeros$1(+date2, token.length);
  }
};
function formatTimezoneShort$1(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros$1(minutes, 2);
}
function formatTimezoneWithOptionalMinutes$1(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros$1(Math.abs(offset) / 60, 2);
  }
  return formatTimezone$1(offset, delimiter);
}
function formatTimezone$1(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = addLeadingZeros$1(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros$1(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
const dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
const timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
const dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
const longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;
const throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return "Use `".concat(token.toLowerCase(), "` instead of `").concat(token, "` (in `").concat(format2, "`) for formatting ").concat(subject, " to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md");
}
const formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp$1 = /^'([^]*?)'?$/;
const doubleQuoteRegExp$1 = /''/g;
const unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format$1(date2, formatStr, options) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n2, _o2, _p, _q, _r;
  const defaultOptions2 = getDefaultOptions$1();
  const locale2 = (_b = (_a = options == null ? void 0 : options.locale) != null ? _a : defaultOptions2.locale) != null ? _b : enUS;
  const firstWeekContainsDate = (_j = (_i = (_f = (_e2 = options == null ? void 0 : options.firstWeekContainsDate) != null ? _e2 : (_d = (_c = options == null ? void 0 : options.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) != null ? _f : defaultOptions2.firstWeekContainsDate) != null ? _i : (_h = (_g = defaultOptions2.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.firstWeekContainsDate) != null ? _j : 1;
  const weekStartsOn = (_r = (_q = (_n2 = (_m = options == null ? void 0 : options.weekStartsOn) != null ? _m : (_l = (_k = options == null ? void 0 : options.locale) == null ? void 0 : _k.options) == null ? void 0 : _l.weekStartsOn) != null ? _n2 : defaultOptions2.weekStartsOn) != null ? _q : (_p = (_o2 = defaultOptions2.locale) == null ? void 0 : _o2.options) == null ? void 0 : _p.weekStartsOn) != null ? _r : 0;
  const originalDate = toDate$1(date2, options == null ? void 0 : options.in);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp$1).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp$1).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString$1(substring) };
    }
    if (formatters$1[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale2.localize.preprocessor) {
    parts = locale2.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token = part.value;
    if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token) || !(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date2));
    }
    const formatter = formatters$1[token[0]];
    return formatter(originalDate, token, locale2.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString$1(input) {
  const matched = input.match(escapedStringRegExp$1);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp$1, "'");
}
function getDefaultOptions() {
  return Object.assign({}, getDefaultOptions$1());
}
function getISODay(date2, options) {
  const day = toDate$1(date2, options == null ? void 0 : options.in).getDay();
  return day === 0 ? 7 : day;
}
function getMonth(date2, options) {
  return toDate$1(date2, options == null ? void 0 : options.in).getMonth();
}
function transpose(date2, constructor) {
  const date_ = isConstructor(constructor) ? new constructor(0) : constructFrom(constructor, 0);
  date_.setFullYear(date2.getFullYear(), date2.getMonth(), date2.getDate());
  date_.setHours(
    date2.getHours(),
    date2.getMinutes(),
    date2.getSeconds(),
    date2.getMilliseconds()
  );
  return date_;
}
function isConstructor(constructor) {
  var _a;
  return typeof constructor === "function" && ((_a = constructor.prototype) == null ? void 0 : _a.constructor) === constructor;
}
const TIMEZONE_UNIT_PRIORITY = 10;
class Setter {
  constructor() {
    __publicField(this, "subPriority", 0);
  }
  validate(_utcDate, _options) {
    return true;
  }
}
class ValueSetter extends Setter {
  constructor(value, validateValue, setValue2, priority, subPriority) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue2;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }
  validate(date2, options) {
    return this.validateValue(date2, this.value, options);
  }
  set(date2, flags, options) {
    return this.setValue(date2, flags, this.value, options);
  }
}
class DateTimezoneSetter extends Setter {
  constructor(context2, reference) {
    super();
    __publicField(this, "priority", TIMEZONE_UNIT_PRIORITY);
    __publicField(this, "subPriority", -1);
    this.context = context2 || ((date2) => constructFrom(reference, date2));
  }
  set(date2, flags) {
    if (flags.timestampIsSet) return date2;
    return constructFrom(date2, transpose(date2, this.context));
  }
}
class Parser {
  run(dateString, token, match2, options) {
    const result = this.parse(dateString, token, match2, options);
    if (!result) {
      return null;
    }
    return {
      setter: new ValueSetter(
        result.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: result.rest
    };
  }
  validate(_utcDate, _value, _options) {
    return true;
  }
}
class EraParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 140);
    __publicField(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
      // A, B
      case "GGGGG":
        return match2.era(dateString, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return match2.era(dateString, { width: "wide" }) || match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
    }
  }
  set(date2, flags, value) {
    flags.era = value;
    date2.setFullYear(value, 0, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
const numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
const timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n2 + "}"), dateString);
  }
}
function parseNDigitsSigned(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n2 + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex$2(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
class YearParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy"
    });
    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date2, flags, value) {
    const currentYear = date2.getFullYear();
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date2.setFullYear(normalizedTwoDigitYear, 0, 1);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date2.setFullYear(year, 0, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class LocalWeekYearParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "YY"
    });
    switch (token) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date2, flags, value, options) {
    const currentYear = getWeekYear(date2, options);
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date2.setFullYear(
        normalizedTwoDigitYear,
        0,
        options.firstWeekContainsDate
      );
      date2.setHours(0, 0, 0, 0);
      return startOfWeek(date2, options);
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date2.setFullYear(year, 0, options.firstWeekContainsDate);
    date2.setHours(0, 0, 0, 0);
    return startOfWeek(date2, options);
  }
}
class ISOWeekYearParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token) {
    if (token === "R") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date2, _flags, value) {
    const firstWeekOfYear = constructFrom(date2, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return startOfISOWeek(firstWeekOfYear);
  }
}
class ExtendedYearParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token) {
    if (token === "u") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date2, _flags, value) {
    date2.setFullYear(value, 0, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class QuarterParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
      case "QQ":
        return parseNDigits(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date2, _flags, value) {
    date2.setMonth((value - 1) * 3, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class StandAloneQuarterParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      // 1, 2, 3, 4
      case "q":
      case "qq":
        return parseNDigits(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date2, _flags, value) {
    date2.setMonth((value - 1) * 3, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class MonthParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    __publicField(this, "priority", 110);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      // 1, 2, ..., 12
      case "M":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      // 01, 02, ..., 12
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      // Jan, Feb, ..., Dec
      case "MMM":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
      // J, F, ..., D
      case "MMMMM":
        return match2.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return match2.month(dateString, { width: "wide", context: "formatting" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date2, _flags, value) {
    date2.setMonth(value, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class StandAloneMonthParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 110);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      // 01, 02, ..., 12
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      // Jan, Feb, ..., Dec
      case "LLL":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
      // J, F, ..., D
      case "LLLLL":
        return match2.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return match2.month(dateString, { width: "wide", context: "standalone" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date2, _flags, value) {
    date2.setMonth(value, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
function setWeek(date2, week, options) {
  const date_ = toDate$1(date2, options == null ? void 0 : options.in);
  const diff = getWeek(date_, options) - week;
  date_.setDate(date_.getDate() - diff * 7);
  return toDate$1(date_, options == null ? void 0 : options.in);
}
class LocalWeekParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "w":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "wo":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date2, _flags, value, options) {
    return startOfWeek(setWeek(date2, value, options), options);
  }
}
function setISOWeek(date2, week, options) {
  const _date = toDate$1(date2, options == null ? void 0 : options.in);
  const diff = getISOWeek(_date, options) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}
class ISOWeekParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "I":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "Io":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date2, _flags, value) {
    return startOfISOWeek(setISOWeek(date2, value));
  }
}
const DAYS_IN_MONTH$1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const DAYS_IN_MONTH_LEAP_YEAR$1 = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class DateParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subPriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "d":
        return parseNumericPattern(numericPatterns.date, dateString);
      case "do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date2, value) {
    const year = date2.getFullYear();
    const isLeapYear = isLeapYearIndex$2(year);
    const month = date2.getMonth();
    if (isLeapYear) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR$1[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH$1[month];
    }
  }
  set(date2, _flags, value) {
    date2.setDate(value);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class DayOfYearParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subpriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
      case "Do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date2, value) {
    const year = date2.getFullYear();
    const isLeapYear = isLeapYearIndex$2(year);
    if (isLeapYear) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }
  set(date2, _flags, value) {
    date2.setMonth(0, value);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
function setDay(date2, day, options) {
  var _a, _b, _c, _d, _e2, _f, _g, _h;
  const defaultOptions2 = getDefaultOptions$1();
  const weekStartsOn = (_h = (_g = (_d = (_c = options == null ? void 0 : options.weekStartsOn) != null ? _c : (_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) != null ? _d : defaultOptions2.weekStartsOn) != null ? _g : (_f = (_e2 = defaultOptions2.locale) == null ? void 0 : _e2.options) == null ? void 0 : _f.weekStartsOn) != null ? _h : 0;
  const date_ = toDate$1(date2, options == null ? void 0 : options.in);
  const currentDay = date_.getDay();
  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;
  const delta = 7 - weekStartsOn;
  const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(date_, diff, options);
}
class DayParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      // T
      case "EEEEE":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      // Tuesday
      case "EEEE":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date2, _flags, value, options) {
    date2 = setDay(date2, value, options);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class LocalDayParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      // 3
      case "e":
      case "ee":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      // 3rd
      case "eo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      // Tue
      case "eee":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      // T
      case "eeeee":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      // Tuesday
      case "eeee":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date2, _flags, value, options) {
    date2 = setDay(date2, value, options);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class StandAloneLocalDayParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      // 3
      case "c":
      case "cc":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      // 3rd
      case "co":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      // Tue
      case "ccc":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      // T
      case "ccccc":
        return match2.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      // Tuesday
      case "cccc":
      default:
        return match2.day(dateString, { width: "wide", context: "standalone" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date2, _flags, value, options) {
    date2 = setDay(date2, value, options);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
function setISODay(date2, day, options) {
  const date_ = toDate$1(date2, options == null ? void 0 : options.in);
  const currentDay = getISODay(date_, options);
  const diff = day - currentDay;
  return addDays(date_, diff, options);
}
class ISODayParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };
    switch (token) {
      // 2
      case "i":
      case "ii":
        return parseNDigits(token.length, dateString);
      // 2nd
      case "io":
        return match2.ordinalNumber(dateString, { unit: "day" });
      // Tue
      case "iii":
        return mapValue(
          match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      // T
      case "iiiii":
        return mapValue(
          match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      // Tu
      case "iiiiii":
        return mapValue(
          match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      // Tuesday
      case "iiii":
      default:
        return mapValue(
          match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 7;
  }
  set(date2, _flags, value) {
    date2 = setISODay(date2, value);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class AMPMParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date2, _flags, value) {
    date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date2;
  }
}
class AMPMMidnightParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date2, _flags, value) {
    date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date2;
  }
}
class DayPeriodParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date2, _flags, value) {
    date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date2;
  }
}
class Hour1to12Parser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, dateString);
      case "ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 12;
  }
  set(date2, _flags, value) {
    const isPM = date2.getHours() >= 12;
    if (isPM && value < 12) {
      date2.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date2.setHours(0, 0, 0, 0);
    } else {
      date2.setHours(value, 0, 0, 0);
    }
    return date2;
  }
}
class Hour0to23Parser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, dateString);
      case "Ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 23;
  }
  set(date2, _flags, value) {
    date2.setHours(value, 0, 0, 0);
    return date2;
  }
}
class Hour0To11Parser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, dateString);
      case "Ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date2, _flags, value) {
    const isPM = date2.getHours() >= 12;
    if (isPM && value < 12) {
      date2.setHours(value + 12, 0, 0, 0);
    } else {
      date2.setHours(value, 0, 0, 0);
    }
    return date2;
  }
}
class Hour1To24Parser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, dateString);
      case "ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 24;
  }
  set(date2, _flags, value) {
    const hours = value <= 24 ? value % 24 : value;
    date2.setHours(hours, 0, 0, 0);
    return date2;
  }
}
class MinuteParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 60);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, dateString);
      case "mo":
        return match2.ordinalNumber(dateString, { unit: "minute" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date2, _flags, value) {
    date2.setMinutes(value, 0, 0);
    return date2;
  }
}
class SecondParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 50);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "s":
        return parseNumericPattern(numericPatterns.second, dateString);
      case "so":
        return match2.ordinalNumber(dateString, { unit: "second" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date2, _flags, value) {
    date2.setSeconds(value, 0);
    return date2;
  }
}
class FractionOfSecondParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 30);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token) {
    const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
    return mapValue(parseNDigits(token.length, dateString), valueCallback);
  }
  set(date2, _flags, value) {
    date2.setMilliseconds(value);
    return date2;
  }
}
class ISOTimezoneWithZParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "X":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "XXXX":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "XXXXX":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date2, flags, value) {
    if (flags.timestampIsSet) return date2;
    return constructFrom(
      date2,
      date2.getTime() - getTimezoneOffsetInMilliseconds$1(date2) - value
    );
  }
}
class ISOTimezoneParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "x":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "xxxx":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "xxxxx":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date2, flags, value) {
    if (flags.timestampIsSet) return date2;
    return constructFrom(
      date2,
      date2.getTime() - getTimezoneOffsetInMilliseconds$1(date2) - value
    );
  }
}
class TimestampSecondsParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 40);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date2, _flags, value) {
    return [constructFrom(date2, value * 1e3), { timestampIsSet: true }];
  }
}
class TimestampMillisecondsParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 20);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date2, _flags, value) {
    return [constructFrom(date2, value), { timestampIsSet: true }];
  }
}
const parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const notWhitespaceRegExp = /\S/;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dateStr, formatStr, referenceDate, options) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i;
  const invalidDate2 = () => constructFrom(referenceDate, NaN);
  const defaultOptions2 = getDefaultOptions();
  const locale2 = (_a = defaultOptions2.locale) != null ? _a : enUS;
  const firstWeekContainsDate = (_e2 = (_d = defaultOptions2.firstWeekContainsDate) != null ? _d : (_c = (_b = defaultOptions2.locale) == null ? void 0 : _b.options) == null ? void 0 : _c.firstWeekContainsDate) != null ? _e2 : 1;
  const weekStartsOn = (_i = (_h = defaultOptions2.weekStartsOn) != null ? _h : (_g = (_f = defaultOptions2.locale) == null ? void 0 : _f.options) == null ? void 0 : _g.weekStartsOn) != null ? _i : 0;
  if (!formatStr)
    return dateStr ? invalidDate2() : toDate$1(referenceDate, options == null ? void 0 : options.in);
  const subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  const setters = [new DateTimezoneSetter(options == null ? void 0 : options.in, referenceDate)];
  const tokens = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter in longFormatters) {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  const usedTokens = [];
  for (let token of tokens) {
    if (isProtectedWeekYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, dateStr);
    }
    if (isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, dateStr);
    }
    const firstCharacter = token[0];
    const parser = parsers[firstCharacter];
    if (parser) {
      const { incompatibleTokens } = parser;
      if (Array.isArray(incompatibleTokens)) {
        const incompatibleToken = usedTokens.find(
          (usedToken) => incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter
        );
        if (incompatibleToken) {
          throw new RangeError(
            "The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time")
          );
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
        throw new RangeError(
          "The format string mustn't contain `".concat(token, "` and any other token at the same time")
        );
      }
      usedTokens.push({ token: firstCharacter, fullToken: token });
      const parseResult = parser.run(
        dateStr,
        token,
        locale2.match,
        subFnOptions
      );
      if (!parseResult) {
        return invalidDate2();
      }
      setters.push(parseResult.setter);
      dateStr = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
        );
      }
      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString(token);
      }
      if (dateStr.indexOf(token) === 0) {
        dateStr = dateStr.slice(token.length);
      } else {
        return invalidDate2();
      }
    }
  }
  if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
    return invalidDate2();
  }
  const uniquePrioritySetters = setters.map((setter) => setter.priority).sort((a2, b2) => b2 - a2).filter((priority, index, array2) => array2.indexOf(priority) === index).map(
    (priority) => setters.filter((setter) => setter.priority === priority).sort((a2, b2) => b2.subPriority - a2.subPriority)
  ).map((setterArray) => setterArray[0]);
  let date2 = toDate$1(referenceDate, options == null ? void 0 : options.in);
  if (isNaN(+date2)) return invalidDate2();
  const flags = {};
  for (const setter of uniquePrioritySetters) {
    if (!setter.validate(date2, subFnOptions)) {
      return invalidDate2();
    }
    const result = setter.set(date2, flags, subFnOptions);
    if (Array.isArray(result)) {
      date2 = result[0];
      Object.assign(flags, result[1]);
    } else {
      date2 = result;
    }
  }
  return date2;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function isPast(date2) {
  return +toDate$1(date2) < Date.now();
}
function isSameWeek(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  return +startOfWeek(laterDate_, options) === +startOfWeek(earlierDate_, options);
}
function isSameMonth(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() === earlierDate_.getFullYear() && laterDate_.getMonth() === earlierDate_.getMonth();
}
function isToday(date2, options) {
  return isSameDay(
    constructFrom(date2, date2),
    constructNow(date2)
  );
}
function isWithinInterval(date2, interval, options) {
  const time = +toDate$1(date2, options == null ? void 0 : options.in);
  const [startTime, endTime] = [
    +toDate$1(interval.start, options == null ? void 0 : options.in),
    +toDate$1(interval.end, options == null ? void 0 : options.in)
  ].sort((a2, b2) => a2 - b2);
  return time >= startTime && time <= endTime;
}
function parseISO(argument, options) {
  const invalidDate2 = () => constructFrom(options == null ? void 0 : options.in, NaN);
  const additionalDigits = 2;
  const dateStrings = splitDateString$1(argument);
  let date2;
  if (dateStrings.date) {
    const parseYearResult = parseYear$1(dateStrings.date, additionalDigits);
    date2 = parseDate$1(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date2 || isNaN(+date2)) return invalidDate2();
  const timestamp = +date2;
  let time = 0;
  let offset;
  if (dateStrings.time) {
    time = parseTime$1(dateStrings.time);
    if (isNaN(time)) return invalidDate2();
  }
  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) return invalidDate2();
  } else {
    const tmpDate = new Date(timestamp + time);
    const result = toDate$1(0, options == null ? void 0 : options.in);
    result.setFullYear(
      tmpDate.getUTCFullYear(),
      tmpDate.getUTCMonth(),
      tmpDate.getUTCDate()
    );
    result.setHours(
      tmpDate.getUTCHours(),
      tmpDate.getUTCMinutes(),
      tmpDate.getUTCSeconds(),
      tmpDate.getUTCMilliseconds()
    );
    return result;
  }
  return toDate$1(timestamp + time + offset, options == null ? void 0 : options.in);
}
const patterns$2 = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
const dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
const timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString$1(dateString) {
  const dateStrings = {};
  const array2 = dateString.split(patterns$2.dateTimeDelimiter);
  let timeString;
  if (array2.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array2[0])) {
    timeString = array2[0];
  } else {
    dateStrings.date = array2[0];
    timeString = array2[1];
    if (patterns$2.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns$2.timeZoneDelimiter)[0];
      timeString = dateString.substr(
        dateStrings.date.length,
        dateString.length
      );
    }
  }
  if (timeString) {
    const token = patterns$2.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear$1(dateString, additionalDigits) {
  const regex = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)"
  );
  const captures = dateString.match(regex);
  if (!captures) return { year: NaN, restDateString: "" };
  const year = captures[1] ? parseInt(captures[1]) : null;
  const century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate$1(dateString, year) {
  if (year === null) return /* @__PURE__ */ new Date(NaN);
  const captures = dateString.match(dateRegex);
  if (!captures) return /* @__PURE__ */ new Date(NaN);
  const isWeekDate = !!captures[4];
  const dayOfYear = parseDateUnit(captures[1]);
  const month = parseDateUnit(captures[2]) - 1;
  const day = parseDateUnit(captures[3]);
  const week = parseDateUnit(captures[4]);
  const dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate$1(year, week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear$1(year, week, dayOfWeek);
  } else {
    const date2 = /* @__PURE__ */ new Date(0);
    if (!validateDate$1(year, month, day) || !validateDayOfYearDate$1(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date2.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date2;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime$1(timeString) {
  const captures = timeString.match(timeRegex);
  if (!captures) return NaN;
  const hours = parseTimeUnit(captures[1]);
  const minutes = parseTimeUnit(captures[2]);
  const seconds = parseTimeUnit(captures[3]);
  if (!validateTime$1(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z") return 0;
  const captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;
  const sign = captures[1] === "+" ? -1 : 1;
  const hours = parseInt(captures[2]);
  const minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone$1(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear$1(isoWeekYear, week, day) {
  const date2 = /* @__PURE__ */ new Date(0);
  date2.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date2.getUTCDay() || 7;
  const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date2.setUTCDate(date2.getUTCDate() + diff);
  return date2;
}
const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex$1(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate$1(year, month, date2) {
  return month >= 0 && month <= 11 && date2 >= 1 && date2 <= (daysInMonths[month] || (isLeapYearIndex$1(year) ? 29 : 28));
}
function validateDayOfYearDate$1(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex$1(year) ? 366 : 365);
}
function validateWeekDate$1(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime$1(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone$1(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}
function subMonths(date2, amount, options) {
  return addMonths(date2, -1, options);
}
function tzIntlTimeZoneName(length, date2, options) {
  var _a;
  const defaultOptions2 = getDefaultOptions();
  const dtf = getDTF(length, options.timeZone, (_a = options.locale) != null ? _a : defaultOptions2.locale);
  return "formatToParts" in dtf ? partsTimeZone(dtf, date2) : hackyTimeZone(dtf, date2);
}
function partsTimeZone(dtf, date2) {
  const formatted = dtf.formatToParts(date2);
  for (let i2 = formatted.length - 1; i2 >= 0; --i2) {
    if (formatted[i2].type === "timeZoneName") {
      return formatted[i2].value;
    }
  }
  return void 0;
}
function hackyTimeZone(dtf, date2) {
  const formatted = dtf.format(date2).replace(/\u200E/g, "");
  const tzNameMatch = / [\w-+ ]+$/.exec(formatted);
  return tzNameMatch ? tzNameMatch[0].substr(1) : "";
}
function getDTF(length, timeZone, locale2) {
  return new Intl.DateTimeFormat(locale2 ? [locale2.code, "en-US"] : void 0, {
    timeZone,
    timeZoneName: length
  });
}
function tzTokenizeDate(date2, timeZone) {
  const dtf = getDateTimeFormat(timeZone);
  return "formatToParts" in dtf ? partsOffset(dtf, date2) : hackyOffset(dtf, date2);
}
const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function partsOffset(dtf, date2) {
  try {
    const formatted = dtf.formatToParts(date2);
    const filled = [];
    for (let i2 = 0; i2 < formatted.length; i2++) {
      const pos = typeToPos[formatted[i2].type];
      if (pos !== void 0) {
        filled[pos] = parseInt(formatted[i2].value, 10);
      }
    }
    return filled;
  } catch (error2) {
    if (error2 instanceof RangeError) {
      return [NaN];
    }
    throw error2;
  }
}
function hackyOffset(dtf, date2) {
  const formatted = dtf.format(date2);
  const parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
  return [
    parseInt(parsed[3], 10),
    parseInt(parsed[1], 10),
    parseInt(parsed[2], 10),
    parseInt(parsed[4], 10),
    parseInt(parsed[5], 10),
    parseInt(parsed[6], 10)
  ];
}
const dtfCache = {};
const testDateFormatted = new Intl.DateTimeFormat("en-US", {
  hourCycle: "h23",
  timeZone: "America/New_York",
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit"
}).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z"));
const hourCycleSupported = testDateFormatted === "06/25/2014, 00:00:00" || testDateFormatted === "06/25/2014 00:00:00";
function getDateTimeFormat(timeZone) {
  if (!dtfCache[timeZone]) {
    dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return dtfCache[timeZone];
}
function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {
  const utcDate = /* @__PURE__ */ new Date(0);
  utcDate.setUTCFullYear(fullYear, month, day);
  utcDate.setUTCHours(hour, minute, second, millisecond);
  return utcDate;
}
const MILLISECONDS_IN_HOUR$1 = 36e5;
const MILLISECONDS_IN_MINUTE$2 = 6e4;
const patterns$1 = {
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
};
function tzParseTimezone(timezoneString, date2, isUtcDate) {
  if (!timezoneString) {
    return 0;
  }
  let token = patterns$1.timezoneZ.exec(timezoneString);
  if (token) {
    return 0;
  }
  let hours;
  let absoluteOffset;
  token = patterns$1.timezoneHH.exec(timezoneString);
  if (token) {
    hours = parseInt(token[1], 10);
    if (!validateTimezone(hours)) {
      return NaN;
    }
    return -(hours * MILLISECONDS_IN_HOUR$1);
  }
  token = patterns$1.timezoneHHMM.exec(timezoneString);
  if (token) {
    hours = parseInt(token[2], 10);
    const minutes = parseInt(token[3], 10);
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2;
    return token[1] === "+" ? -absoluteOffset : absoluteOffset;
  }
  if (isValidTimezoneIANAString(timezoneString)) {
    date2 = new Date(date2 || Date.now());
    const utcDate = isUtcDate ? date2 : toUtcDate(date2);
    const offset = calcOffset(utcDate, timezoneString);
    const fixedOffset = isUtcDate ? offset : fixOffset(date2, offset, timezoneString);
    return -fixedOffset;
  }
  return NaN;
}
function toUtcDate(date2) {
  return newDateUTC(date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds());
}
function calcOffset(date2, timezoneString) {
  const tokens = tzTokenizeDate(date2, timezoneString);
  const asUTC = newDateUTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5], 0).getTime();
  let asTS = date2.getTime();
  const over = asTS % 1e3;
  asTS -= over >= 0 ? over : 1e3 + over;
  return asUTC - asTS;
}
function fixOffset(date2, offset, timezoneString) {
  const localTS = date2.getTime();
  let utcGuess = localTS - offset;
  const o2 = calcOffset(new Date(utcGuess), timezoneString);
  if (offset === o2) {
    return offset;
  }
  utcGuess -= o2 - offset;
  const o3 = calcOffset(new Date(utcGuess), timezoneString);
  if (o2 === o3) {
    return o2;
  }
  return Math.max(o2, o3);
}
function validateTimezone(hours, minutes) {
  return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);
}
const validIANATimezoneCache = {};
function isValidTimezoneIANAString(timeZoneString) {
  if (validIANATimezoneCache[timeZoneString])
    return true;
  try {
    new Intl.DateTimeFormat(void 0, { timeZone: timeZoneString });
    validIANATimezoneCache[timeZoneString] = true;
    return true;
  } catch (error2) {
    return false;
  }
}
const MILLISECONDS_IN_MINUTE$1 = 60 * 1e3;
const formatters = {
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date2, token, options) {
    const timezoneOffset = getTimeZoneOffset(options.timeZone, date2);
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimeter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimeter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimeter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date2, token, options) {
    const timezoneOffset = getTimeZoneOffset(options.timeZone, date2);
    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimeter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimeter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimeter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date2, token, options) {
    const timezoneOffset = getTimeZoneOffset(options.timeZone, date2);
    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date2, token, options) {
    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return tzIntlTimeZoneName("short", date2, options);
      // Long
      case "zzzz":
      default:
        return tzIntlTimeZoneName("long", date2, options);
    }
  }
};
function getTimeZoneOffset(timeZone, originalDate) {
  var _a;
  const timeZoneOffset = timeZone ? tzParseTimezone(timeZone, originalDate, true) / MILLISECONDS_IN_MINUTE$1 : (_a = originalDate == null ? void 0 : originalDate.getTimezoneOffset()) != null ? _a : 0;
  if (Number.isNaN(timeZoneOffset)) {
    throw new RangeError("Invalid time zone specified: " + timeZone);
  }
  return timeZoneOffset;
}
function addLeadingZeros(number2, targetLength) {
  const sign = number2 < 0 ? "-" : "";
  let output3 = Math.abs(number2).toString();
  while (output3.length < targetLength) {
    output3 = "0" + output3;
  }
  return sign + output3;
}
function formatTimezone(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  const minutes = addLeadingZeros(Math.floor(absOffset % 60), 2);
  return sign + hours + delimiter + minutes;
}
function formatTimezoneWithOptionalMinutes(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, delimiter);
}
function formatTimezoneShort(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.floor(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function getTimezoneOffsetInMilliseconds(date2) {
  const utcDate = new Date(Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds()));
  utcDate.setUTCFullYear(date2.getFullYear());
  return +date2 - +utcDate;
}
const tzPattern = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;
const MILLISECONDS_IN_HOUR = 36e5;
const MILLISECONDS_IN_MINUTE = 6e4;
const DEFAULT_ADDITIONAL_DIGITS = 2;
const patterns = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    // 0 additional digits
    /^([+-]\d{3})$/,
    // 1 additional digit
    /^([+-]\d{4})$/
    // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    // 0 additional digits
    /^([+-]\d{5})/,
    // 1 additional digit
    /^([+-]\d{6})/
    // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // time zone tokens (to identify the presence of a tz)
  timeZone: tzPattern
};
function toDate(argument, options = {}) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  if (argument === null) {
    return /* @__PURE__ */ new Date(NaN);
  }
  const additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (argument instanceof Date || typeof argument === "object" && Object.prototype.toString.call(argument) === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || Object.prototype.toString.call(argument) === "[object Number]") {
    return new Date(argument);
  } else if (!(Object.prototype.toString.call(argument) === "[object String]")) {
    return /* @__PURE__ */ new Date(NaN);
  }
  const dateStrings = splitDateString(argument);
  const { year, restDateString } = parseYear(dateStrings.date, additionalDigits);
  const date2 = parseDate(restDateString, year);
  if (date2 === null || isNaN(date2.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (date2) {
    const timestamp = date2.getTime();
    let time = 0;
    let offset;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (time === null || isNaN(time)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    }
    if (dateStrings.timeZone || options.timeZone) {
      offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));
      if (isNaN(offset)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    } else {
      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));
      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset));
    }
    return new Date(timestamp + time + offset);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}
function splitDateString(dateString) {
  const dateStrings = {};
  let parts = patterns.dateTimePattern.exec(dateString);
  let timeString;
  if (!parts) {
    parts = patterns.datePattern.exec(dateString);
    if (parts) {
      dateStrings.date = parts[1];
      timeString = parts[2];
    } else {
      dateStrings.date = null;
      timeString = dateString;
    }
  } else {
    dateStrings.date = parts[1];
    timeString = parts[3];
  }
  if (timeString) {
    const token = patterns.timeZone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timeZone = token[1].trim();
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  if (dateString) {
    const patternYYY = patterns.YYY[additionalDigits];
    const patternYYYYY = patterns.YYYYY[additionalDigits];
    let token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
    if (token) {
      const yearString = token[1];
      return {
        year: parseInt(yearString, 10),
        restDateString: dateString.slice(yearString.length)
      };
    }
    token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);
    if (token) {
      const centuryString = token[1];
      return {
        year: parseInt(centuryString, 10) * 100,
        restDateString: dateString.slice(centuryString.length)
      };
    }
  }
  return {
    year: null
  };
}
function parseDate(dateString, year) {
  if (year === null) {
    return null;
  }
  let date2;
  let month;
  let week;
  if (!dateString || !dateString.length) {
    date2 = /* @__PURE__ */ new Date(0);
    date2.setUTCFullYear(year);
    return date2;
  }
  let token = patterns.MM.exec(dateString);
  if (token) {
    date2 = /* @__PURE__ */ new Date(0);
    month = parseInt(token[1], 10) - 1;
    if (!validateDate(year, month)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date2.setUTCFullYear(year, month);
    return date2;
  }
  token = patterns.DDD.exec(dateString);
  if (token) {
    date2 = /* @__PURE__ */ new Date(0);
    const dayOfYear = parseInt(token[1], 10);
    if (!validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date2.setUTCFullYear(year, 0, dayOfYear);
    return date2;
  }
  token = patterns.MMDD.exec(dateString);
  if (token) {
    date2 = /* @__PURE__ */ new Date(0);
    month = parseInt(token[1], 10) - 1;
    const day = parseInt(token[2], 10);
    if (!validateDate(year, month, day)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date2.setUTCFullYear(year, month, day);
    return date2;
  }
  token = patterns.Www.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    if (!validateWeekDate(week)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week);
  }
  token = patterns.WwwD.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    const dayOfWeek = parseInt(token[2], 10) - 1;
    if (!validateWeekDate(week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  }
  return null;
}
function parseTime(timeString) {
  let hours;
  let minutes;
  let token = patterns.HH.exec(timeString);
  if (token) {
    hours = parseFloat(token[1].replace(",", "."));
    if (!validateTime(hours)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR;
  }
  token = patterns.HHMM.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseFloat(token[2].replace(",", "."));
    if (!validateTime(hours, minutes)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
  }
  token = patterns.HHMMSS.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseInt(token[2], 10);
    const seconds = parseFloat(token[3].replace(",", "."));
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1e3;
  }
  return null;
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  week = week || 0;
  day = day || 0;
  const date2 = /* @__PURE__ */ new Date(0);
  date2.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date2.getUTCDay() || 7;
  const diff = week * 7 + day + 1 - fourthOfJanuaryDay;
  date2.setUTCDate(date2.getUTCDate() + diff);
  return date2;
}
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date2) {
  if (month < 0 || month > 11) {
    return false;
  }
  if (date2 != null) {
    if (date2 < 1) {
      return false;
    }
    const isLeapYear = isLeapYearIndex(year);
    if (isLeapYear && date2 > DAYS_IN_MONTH_LEAP_YEAR[month]) {
      return false;
    }
    if (!isLeapYear && date2 > DAYS_IN_MONTH[month]) {
      return false;
    }
  }
  return true;
}
function validateDayOfYearDate(year, dayOfYear) {
  if (dayOfYear < 1) {
    return false;
  }
  const isLeapYear = isLeapYearIndex(year);
  if (isLeapYear && dayOfYear > 366) {
    return false;
  }
  if (!isLeapYear && dayOfYear > 365) {
    return false;
  }
  return true;
}
function validateWeekDate(week, day) {
  if (week < 0 || week > 52) {
    return false;
  }
  if (day != null && (day < 0 || day > 6)) {
    return false;
  }
  return true;
}
function validateTime(hours, minutes, seconds) {
  if (hours < 0 || hours >= 25) {
    return false;
  }
  if (minutes != null && (minutes < 0 || minutes >= 60)) {
    return false;
  }
  if (seconds != null && (seconds < 0 || seconds >= 60)) {
    return false;
  }
  return true;
}
const tzFormattingTokensRegExp = /([xXOz]+)|''|'(''|[^'])+('|$)/g;
function format(date2, formatStr, options = {}) {
  formatStr = String(formatStr);
  const matches2 = formatStr.match(tzFormattingTokensRegExp);
  if (matches2) {
    const d2 = toDate(options.originalDate || date2, options);
    formatStr = matches2.reduce(function(result, token) {
      if (token[0] === "'") {
        return result;
      }
      const pos = result.indexOf(token);
      const precededByQuotedSection = result[pos - 1] === "'";
      const replaced = result.replace(token, "'" + formatters[token[0]](d2, token, options) + "'");
      return precededByQuotedSection ? replaced.substring(0, pos - 1) + replaced.substring(pos + 1) : replaced;
    }, formatStr);
  }
  return format$1(date2, formatStr, options);
}
function toZonedTime(date2, timeZone, options) {
  date2 = toDate(date2, options);
  const offsetMilliseconds = tzParseTimezone(timeZone, date2, true);
  const d2 = new Date(date2.getTime() - offsetMilliseconds);
  const resultDate = /* @__PURE__ */ new Date(0);
  resultDate.setFullYear(d2.getUTCFullYear(), d2.getUTCMonth(), d2.getUTCDate());
  resultDate.setHours(d2.getUTCHours(), d2.getUTCMinutes(), d2.getUTCSeconds(), d2.getUTCMilliseconds());
  return resultDate;
}
function formatInTimeZone(date2, timeZone, formatStr, options) {
  options = {
    ...options,
    timeZone,
    originalDate: date2
  };
  return format(toZonedTime(date2, timeZone, { timeZone: options.timeZone }), formatStr, options);
}
function fromZonedTime(date2, timeZone, options) {
  if (typeof date2 === "string" && !date2.match(tzPattern)) {
    return toDate(date2, { ...options, timeZone });
  }
  date2 = toDate(date2, options);
  const utc = newDateUTC(date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds()).getTime();
  const offsetMilliseconds = tzParseTimezone(timeZone, new Date(utc));
  return new Date(utc + offsetMilliseconds);
}
/*! Capacitor: https://capacitorjs.com/ - MIT License */
var ExceptionCode;
(function(ExceptionCode2) {
  ExceptionCode2["Unimplemented"] = "UNIMPLEMENTED";
  ExceptionCode2["Unavailable"] = "UNAVAILABLE";
})(ExceptionCode || (ExceptionCode = {}));
class CapacitorException extends Error {
  constructor(message2, code, data) {
    super(message2);
    this.message = message2;
    this.code = code;
    this.data = data;
  }
}
const getPlatformId = (win2) => {
  var _a, _b;
  if (win2 === null || win2 === void 0 ? void 0 : win2.androidBridge) {
    return "android";
  } else if ((_b = (_a = win2 === null || win2 === void 0 ? void 0 : win2.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
    return "ios";
  } else {
    return "web";
  }
};
const createCapacitor = (win2) => {
  const capCustomPlatform = win2.CapacitorCustomPlatform || null;
  const cap = win2.Capacitor || {};
  const Plugins = cap.Plugins = cap.Plugins || {};
  const getPlatform = () => {
    return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win2);
  };
  const isNativePlatform = () => getPlatform() !== "web";
  const isPluginAvailable = (pluginName) => {
    const plugin = registeredPlugins.get(pluginName);
    if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
      return true;
    }
    if (getPluginHeader(pluginName)) {
      return true;
    }
    return false;
  };
  const getPluginHeader = (pluginName) => {
    var _a;
    return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find((h2) => h2.name === pluginName);
  };
  const handleError = (err2) => win2.console.error(err2);
  const registeredPlugins = /* @__PURE__ */ new Map();
  const registerPlugin2 = (pluginName, jsImplementations = {}) => {
    const registeredPlugin = registeredPlugins.get(pluginName);
    if (registeredPlugin) {
      console.warn('Capacitor plugin "'.concat(pluginName, '" already registered. Cannot register plugins twice.'));
      return registeredPlugin.proxy;
    }
    const platform = getPlatform();
    const pluginHeader = getPluginHeader(pluginName);
    let jsImplementation;
    const loadPluginImplementation = async () => {
      if (!jsImplementation && platform in jsImplementations) {
        jsImplementation = typeof jsImplementations[platform] === "function" ? jsImplementation = await jsImplementations[platform]() : jsImplementation = jsImplementations[platform];
      } else if (capCustomPlatform !== null && !jsImplementation && "web" in jsImplementations) {
        jsImplementation = typeof jsImplementations["web"] === "function" ? jsImplementation = await jsImplementations["web"]() : jsImplementation = jsImplementations["web"];
      }
      return jsImplementation;
    };
    const createPluginMethod = (impl, prop) => {
      var _a, _b;
      if (pluginHeader) {
        const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m2) => prop === m2.name);
        if (methodHeader) {
          if (methodHeader.rtype === "promise") {
            return (options) => cap.nativePromise(pluginName, prop.toString(), options);
          } else {
            return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
          }
        } else if (impl) {
          return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);
        }
      } else if (impl) {
        return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);
      } else {
        throw new CapacitorException('"'.concat(pluginName, '" plugin is not implemented on ').concat(platform), ExceptionCode.Unimplemented);
      }
    };
    const createPluginMethodWrapper = (prop) => {
      let remove4;
      const wrapper = (...args) => {
        const p2 = loadPluginImplementation().then((impl) => {
          const fn2 = createPluginMethod(impl, prop);
          if (fn2) {
            const p22 = fn2(...args);
            remove4 = p22 === null || p22 === void 0 ? void 0 : p22.remove;
            return p22;
          } else {
            throw new CapacitorException('"'.concat(pluginName, ".").concat(prop, '()" is not implemented on ').concat(platform), ExceptionCode.Unimplemented);
          }
        });
        if (prop === "addListener") {
          p2.remove = async () => remove4();
        }
        return p2;
      };
      wrapper.toString = () => "".concat(prop.toString(), "() { [capacitor code] }");
      Object.defineProperty(wrapper, "name", {
        value: prop,
        writable: false,
        configurable: false
      });
      return wrapper;
    };
    const addListener2 = createPluginMethodWrapper("addListener");
    const removeListener2 = createPluginMethodWrapper("removeListener");
    const addListenerNative = (eventName, callback) => {
      const call = addListener2({ eventName }, callback);
      const remove4 = async () => {
        const callbackId = await call;
        removeListener2({
          eventName,
          callbackId
        }, callback);
      };
      const p2 = new Promise((resolve) => call.then(() => resolve({ remove: remove4 })));
      p2.remove = async () => {
        console.warn("Using addListener() without 'await' is deprecated.");
        await remove4();
      };
      return p2;
    };
    const proxy = new Proxy({}, {
      get(_23, prop) {
        switch (prop) {
          // https://github.com/facebook/react/issues/20030
          case "$$typeof":
            return void 0;
          case "toJSON":
            return () => ({});
          case "addListener":
            return pluginHeader ? addListenerNative : addListener2;
          case "removeListener":
            return removeListener2;
          default:
            return createPluginMethodWrapper(prop);
        }
      }
    });
    Plugins[pluginName] = proxy;
    registeredPlugins.set(pluginName, {
      name: pluginName,
      proxy,
      platforms: /* @__PURE__ */ new Set([...Object.keys(jsImplementations), ...pluginHeader ? [platform] : []])
    });
    return proxy;
  };
  if (!cap.convertFileSrc) {
    cap.convertFileSrc = (filePath) => filePath;
  }
  cap.getPlatform = getPlatform;
  cap.handleError = handleError;
  cap.isNativePlatform = isNativePlatform;
  cap.isPluginAvailable = isPluginAvailable;
  cap.registerPlugin = registerPlugin2;
  cap.Exception = CapacitorException;
  cap.DEBUG = !!cap.DEBUG;
  cap.isLoggingEnabled = !!cap.isLoggingEnabled;
  return cap;
};
const initCapacitorGlobal = (win2) => win2.Capacitor = createCapacitor(win2);
const Capacitor = /* @__PURE__ */ initCapacitorGlobal(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {});
const registerPlugin = Capacitor.registerPlugin;
class WebPlugin {
  constructor() {
    this.listeners = {};
    this.retainedEventArguments = {};
    this.windowListeners = {};
  }
  addListener(eventName, listenerFunc) {
    let firstListener = false;
    const listeners = this.listeners[eventName];
    if (!listeners) {
      this.listeners[eventName] = [];
      firstListener = true;
    }
    this.listeners[eventName].push(listenerFunc);
    const windowListener = this.windowListeners[eventName];
    if (windowListener && !windowListener.registered) {
      this.addWindowListener(windowListener);
    }
    if (firstListener) {
      this.sendRetainedArgumentsForEvent(eventName);
    }
    const remove4 = async () => this.removeListener(eventName, listenerFunc);
    const p2 = Promise.resolve({ remove: remove4 });
    return p2;
  }
  async removeAllListeners() {
    this.listeners = {};
    for (const listener in this.windowListeners) {
      this.removeWindowListener(this.windowListeners[listener]);
    }
    this.windowListeners = {};
  }
  notifyListeners(eventName, data, retainUntilConsumed) {
    const listeners = this.listeners[eventName];
    if (!listeners) {
      if (retainUntilConsumed) {
        let args = this.retainedEventArguments[eventName];
        if (!args) {
          args = [];
        }
        args.push(data);
        this.retainedEventArguments[eventName] = args;
      }
      return;
    }
    listeners.forEach((listener) => listener(data));
  }
  hasListeners(eventName) {
    var _a;
    return !!((_a = this.listeners[eventName]) === null || _a === void 0 ? void 0 : _a.length);
  }
  registerWindowListener(windowEventName, pluginEventName) {
    this.windowListeners[pluginEventName] = {
      registered: false,
      windowEventName,
      pluginEventName,
      handler: (event2) => {
        this.notifyListeners(pluginEventName, event2);
      }
    };
  }
  unimplemented(msg = "not implemented") {
    return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
  }
  unavailable(msg = "not available") {
    return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
  }
  async removeListener(eventName, listenerFunc) {
    const listeners = this.listeners[eventName];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listenerFunc);
    this.listeners[eventName].splice(index, 1);
    if (!this.listeners[eventName].length) {
      this.removeWindowListener(this.windowListeners[eventName]);
    }
  }
  addWindowListener(handle2) {
    window.addEventListener(handle2.windowEventName, handle2.handler);
    handle2.registered = true;
  }
  removeWindowListener(handle2) {
    if (!handle2) {
      return;
    }
    window.removeEventListener(handle2.windowEventName, handle2.handler);
    handle2.registered = false;
  }
  sendRetainedArgumentsForEvent(eventName) {
    const args = this.retainedEventArguments[eventName];
    if (!args) {
      return;
    }
    delete this.retainedEventArguments[eventName];
    args.forEach((arg) => {
      this.notifyListeners(eventName, arg);
    });
  }
}
const encode = (str) => encodeURIComponent(str).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
const decode = (str) => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
class CapacitorCookiesPluginWeb extends WebPlugin {
  async getCookies() {
    const cookies = document.cookie;
    const cookieMap = {};
    cookies.split(";").forEach((cookie2) => {
      if (cookie2.length <= 0)
        return;
      let [key, value] = cookie2.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
      key = decode(key).trim();
      value = decode(value).trim();
      cookieMap[key] = value;
    });
    return cookieMap;
  }
  async setCookie(options) {
    try {
      const encodedKey = encode(options.key);
      const encodedValue = encode(options.value);
      const expires = "; expires=".concat((options.expires || "").replace("expires=", ""));
      const path2 = (options.path || "/").replace("path=", "");
      const domain = options.url != null && options.url.length > 0 ? "domain=".concat(options.url) : "";
      document.cookie = "".concat(encodedKey, "=").concat(encodedValue || "").concat(expires, "; path=").concat(path2, "; ").concat(domain, ";");
    } catch (error2) {
      return Promise.reject(error2);
    }
  }
  async deleteCookie(options) {
    try {
      document.cookie = "".concat(options.key, "=; Max-Age=0");
    } catch (error2) {
      return Promise.reject(error2);
    }
  }
  async clearCookies() {
    try {
      const cookies = document.cookie.split(";") || [];
      for (const cookie2 of cookies) {
        document.cookie = cookie2.replace(/^ +/, "").replace(/=.*/, "=;expires=".concat((/* @__PURE__ */ new Date()).toUTCString(), ";path=/"));
      }
    } catch (error2) {
      return Promise.reject(error2);
    }
  }
  async clearAllCookies() {
    try {
      await this.clearCookies();
    } catch (error2) {
      return Promise.reject(error2);
    }
  }
}
registerPlugin("CapacitorCookies", {
  web: () => new CapacitorCookiesPluginWeb()
});
const readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    const base64String = reader.result;
    resolve(base64String.indexOf(",") >= 0 ? base64String.split(",")[1] : base64String);
  };
  reader.onerror = (error2) => reject(error2);
  reader.readAsDataURL(blob);
});
const normalizeHttpHeaders = (headers = {}) => {
  const originalKeys = Object.keys(headers);
  const loweredKeys = Object.keys(headers).map((k2) => k2.toLocaleLowerCase());
  const normalized = loweredKeys.reduce((acc, key, index) => {
    acc[key] = headers[originalKeys[index]];
    return acc;
  }, {});
  return normalized;
};
const buildUrlParams = (params, shouldEncode = true) => {
  if (!params)
    return null;
  const output3 = Object.entries(params).reduce((accumulator, entry) => {
    const [key, value] = entry;
    let encodedValue;
    let item;
    if (Array.isArray(value)) {
      item = "";
      value.forEach((str) => {
        encodedValue = shouldEncode ? encodeURIComponent(str) : str;
        item += "".concat(key, "=").concat(encodedValue, "&");
      });
      item.slice(0, -1);
    } else {
      encodedValue = shouldEncode ? encodeURIComponent(value) : value;
      item = "".concat(key, "=").concat(encodedValue);
    }
    return "".concat(accumulator, "&").concat(item);
  }, "");
  return output3.substr(1);
};
const buildRequestInit = (options, extra = {}) => {
  const output3 = Object.assign({ method: options.method || "GET", headers: options.headers }, extra);
  const headers = normalizeHttpHeaders(options.headers);
  const type = headers["content-type"] || "";
  if (typeof options.data === "string") {
    output3.body = options.data;
  } else if (type.includes("application/x-www-form-urlencoded")) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(options.data || {})) {
      params.set(key, value);
    }
    output3.body = params.toString();
  } else if (type.includes("multipart/form-data") || options.data instanceof FormData) {
    const form = new FormData();
    if (options.data instanceof FormData) {
      options.data.forEach((value, key) => {
        form.append(key, value);
      });
    } else {
      for (const key of Object.keys(options.data)) {
        form.append(key, options.data[key]);
      }
    }
    output3.body = form;
    const headers2 = new Headers(output3.headers);
    headers2.delete("content-type");
    output3.headers = headers2;
  } else if (type.includes("application/json") || typeof options.data === "object") {
    output3.body = JSON.stringify(options.data);
  }
  return output3;
};
class CapacitorHttpPluginWeb extends WebPlugin {
  /**
   * Perform an Http request given a set of options
   * @param options Options to build the HTTP request
   */
  async request(options) {
    const requestInit = buildRequestInit(options, options.webFetchExtra);
    const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
    const url = urlParams ? "".concat(options.url, "?").concat(urlParams) : options.url;
    const response = await fetch(url, requestInit);
    const contentType = response.headers.get("content-type") || "";
    let { responseType = "text" } = response.ok ? options : {};
    if (contentType.includes("application/json")) {
      responseType = "json";
    }
    let data;
    let blob;
    switch (responseType) {
      case "arraybuffer":
      case "blob":
        blob = await response.blob();
        data = await readBlobAsBase64(blob);
        break;
      case "json":
        data = await response.json();
        break;
      case "document":
      case "text":
      default:
        data = await response.text();
    }
    const headers = {};
    response.headers.forEach((value, key) => {
      headers[key] = value;
    });
    return {
      data,
      headers,
      status: response.status,
      url: response.url
    };
  }
  /**
   * Perform an Http GET request given a set of options
   * @param options Options to build the HTTP request
   */
  async get(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "GET" }));
  }
  /**
   * Perform an Http POST request given a set of options
   * @param options Options to build the HTTP request
   */
  async post(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "POST" }));
  }
  /**
   * Perform an Http PUT request given a set of options
   * @param options Options to build the HTTP request
   */
  async put(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PUT" }));
  }
  /**
   * Perform an Http PATCH request given a set of options
   * @param options Options to build the HTTP request
   */
  async patch(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PATCH" }));
  }
  /**
   * Perform an Http DELETE request given a set of options
   * @param options Options to build the HTTP request
   */
  async delete(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "DELETE" }));
  }
}
registerPlugin("CapacitorHttp", {
  web: () => new CapacitorHttpPluginWeb()
});
function _inheritsLoose(t2, o2) {
  t2.prototype = Object.create(o2.prototype), t2.prototype.constructor = t2, _setPrototypeOf$1(t2, o2);
}
var propTypes = { exports: {} };
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret;
  return ReactPropTypesSecret_1;
}
var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  factoryWithThrowingShims = function() {
    function shim2(props, propName, componentName, location2, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err2 = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err2.name = "Invariant Violation";
      throw err2;
    }
    shim2.isRequired = shim2;
    function getShim() {
      return shim2;
    }
    var ReactPropTypes = {
      array: shim2,
      bigint: shim2,
      bool: shim2,
      func: shim2,
      number: shim2,
      object: shim2,
      string: shim2,
      symbol: shim2,
      any: shim2,
      arrayOf: getShim,
      element: shim2,
      elementType: shim2,
      instanceOf: getShim,
      node: shim2,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithThrowingShims;
}
var hasRequiredPropTypes;
function requirePropTypes() {
  if (hasRequiredPropTypes) return propTypes.exports;
  hasRequiredPropTypes = 1;
  {
    propTypes.exports = /* @__PURE__ */ requireFactoryWithThrowingShims()();
  }
  return propTypes.exports;
}
var propTypesExports = /* @__PURE__ */ requirePropTypes();
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
function isAbsolute(pathname) {
  return pathname.charAt(0) === "/";
}
function spliceOne(list, index) {
  for (var i2 = index, k2 = i2 + 1, n2 = list.length; k2 < n2; i2 += 1, k2 += 1) {
    list[i2] = list[k2];
  }
  list.pop();
}
function resolvePathname(to2, from) {
  if (from === void 0) from = "";
  var toParts = to2 && to2.split("/") || [];
  var fromParts = from && from.split("/") || [];
  var isToAbs = to2 && isAbsolute(to2);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;
  if (to2 && isAbsolute(to2)) {
    fromParts = toParts;
  } else if (toParts.length) {
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }
  if (!fromParts.length) return "/";
  var hasTrailingSlash;
  if (fromParts.length) {
    var last3 = fromParts[fromParts.length - 1];
    hasTrailingSlash = last3 === "." || last3 === ".." || last3 === "";
  } else {
    hasTrailingSlash = false;
  }
  var up = 0;
  for (var i2 = fromParts.length; i2 >= 0; i2--) {
    var part = fromParts[i2];
    if (part === ".") {
      spliceOne(fromParts, i2);
    } else if (part === "..") {
      spliceOne(fromParts, i2);
      up++;
    } else if (up) {
      spliceOne(fromParts, i2);
      up--;
    }
  }
  if (!mustEndAbs) for (; up--; up) fromParts.unshift("..");
  if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0])))
    fromParts.unshift("");
  var result = fromParts.join("/");
  if (hasTrailingSlash && result.substr(-1) !== "/") result += "/";
  return result;
}
function valueOf(obj) {
  return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);
}
function valueEqual(a2, b2) {
  if (a2 === b2) return true;
  if (a2 == null || b2 == null) return false;
  if (Array.isArray(a2)) {
    return Array.isArray(b2) && a2.length === b2.length && a2.every(function(item, index) {
      return valueEqual(item, b2[index]);
    });
  }
  if (typeof a2 === "object" || typeof b2 === "object") {
    var aValue = valueOf(a2);
    var bValue = valueOf(b2);
    if (aValue !== a2 || bValue !== b2) return valueEqual(aValue, bValue);
    return Object.keys(Object.assign({}, a2, b2)).every(function(key) {
      return valueEqual(a2[key], b2[key]);
    });
  }
  return false;
}
var prefix = "Invariant failed";
function invariant(condition, message2) {
  {
    throw new Error(prefix);
  }
}
function addLeadingSlash$1(path2) {
  return path2.charAt(0) === "/" ? path2 : "/" + path2;
}
function stripLeadingSlash(path2) {
  return path2.charAt(0) === "/" ? path2.substr(1) : path2;
}
function hasBasename(path2, prefix2) {
  return path2.toLowerCase().indexOf(prefix2.toLowerCase()) === 0 && "/?#".indexOf(path2.charAt(prefix2.length)) !== -1;
}
function stripBasename$1(path2, prefix2) {
  return hasBasename(path2, prefix2) ? path2.substr(prefix2.length) : path2;
}
function stripTrailingSlash(path2) {
  return path2.charAt(path2.length - 1) === "/" ? path2.slice(0, -1) : path2;
}
function parsePath(path2) {
  var pathname = path2 || "/";
  var search = "";
  var hash2 = "";
  var hashIndex = pathname.indexOf("#");
  if (hashIndex !== -1) {
    hash2 = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }
  var searchIndex = pathname.indexOf("?");
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }
  return {
    pathname,
    search: search === "?" ? "" : search,
    hash: hash2 === "#" ? "" : hash2
  };
}
function createPath(location2) {
  var pathname = location2.pathname, search = location2.search, hash2 = location2.hash;
  var path2 = pathname || "/";
  if (search && search !== "?") path2 += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#") path2 += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return path2;
}
function createLocation(path2, state, key, currentLocation) {
  var location2;
  if (typeof path2 === "string") {
    location2 = parsePath(path2);
    location2.state = state;
  } else {
    location2 = _extends$2({}, path2);
    if (location2.pathname === void 0) location2.pathname = "";
    if (location2.search) {
      if (location2.search.charAt(0) !== "?") location2.search = "?" + location2.search;
    } else {
      location2.search = "";
    }
    if (location2.hash) {
      if (location2.hash.charAt(0) !== "#") location2.hash = "#" + location2.hash;
    } else {
      location2.hash = "";
    }
    if (state !== void 0 && location2.state === void 0) location2.state = state;
  }
  try {
    location2.pathname = decodeURI(location2.pathname);
  } catch (e2) {
    if (e2 instanceof URIError) {
      throw new URIError('Pathname "' + location2.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
    } else {
      throw e2;
    }
  }
  if (key) location2.key = key;
  if (currentLocation) {
    if (!location2.pathname) {
      location2.pathname = currentLocation.pathname;
    } else if (location2.pathname.charAt(0) !== "/") {
      location2.pathname = resolvePathname(location2.pathname, currentLocation.pathname);
    }
  } else {
    if (!location2.pathname) {
      location2.pathname = "/";
    }
  }
  return location2;
}
function locationsAreEqual(a2, b2) {
  return a2.pathname === b2.pathname && a2.search === b2.search && a2.hash === b2.hash && a2.key === b2.key && valueEqual(a2.state, b2.state);
}
function createTransitionManager() {
  var prompt = null;
  function setPrompt(nextPrompt) {
    prompt = nextPrompt;
    return function() {
      if (prompt === nextPrompt) prompt = null;
    };
  }
  function confirmTransitionTo(location2, action, getUserConfirmation, callback) {
    if (prompt != null) {
      var result = typeof prompt === "function" ? prompt(location2, action) : prompt;
      if (typeof result === "string") {
        if (typeof getUserConfirmation === "function") {
          getUserConfirmation(result, callback);
        } else {
          callback(true);
        }
      } else {
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }
  var listeners = [];
  function appendListener(fn2) {
    var isActive = true;
    function listener() {
      if (isActive) fn2.apply(void 0, arguments);
    }
    listeners.push(listener);
    return function() {
      isActive = false;
      listeners = listeners.filter(function(item) {
        return item !== listener;
      });
    };
  }
  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    listeners.forEach(function(listener) {
      return listener.apply(void 0, args);
    });
  }
  return {
    setPrompt,
    confirmTransitionTo,
    appendListener,
    notifyListeners
  };
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function getConfirmation(message2, callback) {
  callback(window.confirm(message2));
}
function supportsHistory() {
  var ua = window.navigator.userAgent;
  if ((ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) && ua.indexOf("Mobile Safari") !== -1 && ua.indexOf("Chrome") === -1 && ua.indexOf("Windows Phone") === -1) return false;
  return window.history && "pushState" in window.history;
}
function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf("Trident") === -1;
}
function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf("Firefox") === -1;
}
function isExtraneousPopstateEvent(event2) {
  return event2.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
}
var PopStateEvent = "popstate";
var HashChangeEvent = "hashchange";
function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e2) {
    return {};
  }
}
function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? invariant() : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : "";
  function getDOMLocation(historyState) {
    var _ref = historyState || {}, key = _ref.key, state = _ref.state;
    var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash2 = _window$location.hash;
    var path2 = pathname + search + hash2;
    if (basename) path2 = stripBasename$1(path2, basename);
    return createLocation(path2, state, key);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$2(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function handlePopState(event2) {
    if (isExtraneousPopstateEvent(event2)) return;
    handlePop(getDOMLocation(event2.state));
  }
  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }
  var forceNextPop = false;
  function handlePop(location2) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
        if (ok2) {
          setState({
            action,
            location: location2
          });
        } else {
          revertPop(location2);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go2(delta);
    }
  }
  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];
  function createHref(location2) {
    return basename + createPath(location2);
  }
  function push(path2, state) {
    var action = "PUSH";
    var location2 = createLocation(path2, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2) return;
      var href = createHref(location2);
      var key = location2.key, state2 = location2.state;
      if (canUseHistory) {
        globalHistory.pushState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location2.key);
          allKeys = nextKeys;
          setState({
            action,
            location: location2
          });
        }
      } else {
        window.location.href = href;
      }
    });
  }
  function replace2(path2, state) {
    var action = "REPLACE";
    var location2 = createLocation(path2, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2) return;
      var href = createHref(location2);
      var key = location2.key, state2 = location2.state;
      if (canUseHistory) {
        globalHistory.replaceState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1) allKeys[prevIndex] = location2.key;
          setState({
            action,
            location: location2
          });
        }
      } else {
        window.location.replace(href);
      }
    });
  }
  function go2(n2) {
    globalHistory.go(n2);
  }
  function goBack() {
    go2(-1);
  }
  function goForward() {
    go2(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace: replace2,
    go: go2,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
var HashChangeEvent$1 = "hashchange";
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path2) {
      return path2.charAt(0) === "!" ? path2 : "!/" + stripLeadingSlash(path2);
    },
    decodePath: function decodePath(path2) {
      return path2.charAt(0) === "!" ? path2.substr(1) : path2;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash$1
  },
  slash: {
    encodePath: addLeadingSlash$1,
    decodePath: addLeadingSlash$1
  }
};
function stripHash(url) {
  var hashIndex = url.indexOf("#");
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}
function getHashPath() {
  var href = window.location.href;
  var hashIndex = href.indexOf("#");
  return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
}
function pushHashPath(path2) {
  window.location.hash = path2;
}
function replaceHashPath(path2) {
  window.location.replace(stripHash(window.location.href) + "#" + path2);
}
function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? invariant() : void 0;
  var globalHistory = window.history;
  supportsGoWithoutReloadUsingHash();
  var _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : "";
  var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath2 = _HashPathCoders$hashT.encodePath, decodePath2 = _HashPathCoders$hashT.decodePath;
  function getDOMLocation() {
    var path22 = decodePath2(getHashPath());
    if (basename) path22 = stripBasename$1(path22, basename);
    return createLocation(path22);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$2(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  var forceNextPop = false;
  var ignorePath = null;
  function locationsAreEqual$$1(a2, b2) {
    return a2.pathname === b2.pathname && a2.search === b2.search && a2.hash === b2.hash;
  }
  function handleHashChange() {
    var path22 = getHashPath();
    var encodedPath2 = encodePath2(path22);
    if (path22 !== encodedPath2) {
      replaceHashPath(encodedPath2);
    } else {
      var location2 = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location2)) return;
      if (ignorePath === createPath(location2)) return;
      ignorePath = null;
      handlePop(location2);
    }
  }
  function handlePop(location2) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
        if (ok2) {
          setState({
            action,
            location: location2
          });
        } else {
          revertPop(location2);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go2(delta);
    }
  }
  var path2 = getHashPath();
  var encodedPath = encodePath2(path2);
  if (path2 !== encodedPath) replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)];
  function createHref(location2) {
    var baseTag = document.querySelector("base");
    var href = "";
    if (baseTag && baseTag.getAttribute("href")) {
      href = stripHash(window.location.href);
    }
    return href + "#" + encodePath2(basename + createPath(location2));
  }
  function push(path22, state) {
    var action = "PUSH";
    var location2 = createLocation(path22, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2) return;
      var path3 = createPath(location2);
      var encodedPath2 = encodePath2(basename + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        pushHashPath(encodedPath2);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path3);
        allPaths = nextPaths;
        setState({
          action,
          location: location2
        });
      } else {
        setState();
      }
    });
  }
  function replace2(path22, state) {
    var action = "REPLACE";
    var location2 = createLocation(path22, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2) return;
      var path3 = createPath(location2);
      var encodedPath2 = encodePath2(basename + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        replaceHashPath(encodedPath2);
      }
      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1) allPaths[prevIndex] = path3;
      setState({
        action,
        location: location2
      });
    });
  }
  function go2(n2) {
    globalHistory.go(n2);
  }
  function goBack() {
    go2(-1);
  }
  function goForward() {
    go2(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace: replace2,
    go: go2,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
function clamp(n2, lowerBound, upperBound) {
  return Math.min(Math.max(n2, lowerBound), upperBound);
}
function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }
  var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$2(history, nextState);
    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries3 = initialEntries.map(function(entry) {
    return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
  });
  var createHref = createPath;
  function push(path2, state) {
    var action = "PUSH";
    var location2 = createLocation(path2, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2) return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location2);
      } else {
        nextEntries.push(location2);
      }
      setState({
        action,
        location: location2,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }
  function replace2(path2, state) {
    var action = "REPLACE";
    var location2 = createLocation(path2, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2) return;
      history.entries[history.index] = location2;
      setState({
        action,
        location: location2
      });
    });
  }
  function go2(n2) {
    var nextIndex = clamp(history.index + n2, 0, history.entries.length - 1);
    var action = "POP";
    var location2 = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (ok2) {
        setState({
          action,
          location: location2,
          index: nextIndex
        });
      } else {
        setState();
      }
    });
  }
  function goBack() {
    go2(-1);
  }
  function goForward() {
    go2(1);
  }
  function canGo(n2) {
    var nextIndex = history.index + n2;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    return transitionManager.setPrompt(prompt);
  }
  function listen(listener) {
    return transitionManager.appendListener(listener);
  }
  var history = {
    length: entries3.length,
    action: "POP",
    location: entries3[index],
    index,
    entries: entries3,
    createHref,
    push,
    replace: replace2,
    go: go2,
    goBack,
    goForward,
    canGo,
    block,
    listen
  };
  return history;
}
var pathToRegexp$1 = { exports: {} };
var isarray;
var hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  isarray = Array.isArray || function(arr2) {
    return Object.prototype.toString.call(arr2) == "[object Array]";
  };
  return isarray;
}
var hasRequiredPathToRegexp;
function requirePathToRegexp() {
  if (hasRequiredPathToRegexp) return pathToRegexp$1.exports;
  hasRequiredPathToRegexp = 1;
  var isarray2 = requireIsarray();
  pathToRegexp$1.exports = pathToRegexp2;
  pathToRegexp$1.exports.parse = parse2;
  pathToRegexp$1.exports.compile = compile;
  pathToRegexp$1.exports.tokensToFunction = tokensToFunction;
  pathToRegexp$1.exports.tokensToRegExp = tokensToRegExp;
  var PATH_REGEXP = new RegExp([
    // Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    "(\\\\.)",
    // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
    // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
    // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
    "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
  ].join("|"), "g");
  function parse2(str, options) {
    var tokens = [];
    var key = 0;
    var index = 0;
    var path2 = "";
    var defaultDelimiter = options && options.delimiter || "/";
    var res;
    while ((res = PATH_REGEXP.exec(str)) != null) {
      var m2 = res[0];
      var escaped = res[1];
      var offset = res.index;
      path2 += str.slice(index, offset);
      index = offset + m2.length;
      if (escaped) {
        path2 += escaped[1];
        continue;
      }
      var next = str[index];
      var prefix2 = res[2];
      var name = res[3];
      var capture = res[4];
      var group = res[5];
      var modifier = res[6];
      var asterisk = res[7];
      if (path2) {
        tokens.push(path2);
        path2 = "";
      }
      var partial = prefix2 != null && next != null && next !== prefix2;
      var repeat = modifier === "+" || modifier === "*";
      var optional = modifier === "?" || modifier === "*";
      var delimiter = prefix2 || defaultDelimiter;
      var pattern = capture || group;
      var prevText = prefix2 || (typeof tokens[tokens.length - 1] === "string" ? tokens[tokens.length - 1] : "");
      tokens.push({
        name: name || key++,
        prefix: prefix2 || "",
        delimiter,
        optional,
        repeat,
        partial,
        asterisk: !!asterisk,
        pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : restrictBacktrack(delimiter, prevText)
      });
    }
    if (index < str.length) {
      path2 += str.substr(index);
    }
    if (path2) {
      tokens.push(path2);
    }
    return tokens;
  }
  function restrictBacktrack(delimiter, prevText) {
    if (!prevText || prevText.indexOf(delimiter) > -1) {
      return "[^" + escapeString(delimiter) + "]+?";
    }
    return escapeString(prevText) + "|(?:(?!" + escapeString(prevText) + ")[^" + escapeString(delimiter) + "])+?";
  }
  function compile(str, options) {
    return tokensToFunction(parse2(str, options), options);
  }
  function encodeURIComponentPretty(str) {
    return encodeURI(str).replace(/[\/?#]/g, function(c2) {
      return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeAsterisk(str) {
    return encodeURI(str).replace(/[?#]/g, function(c2) {
      return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function tokensToFunction(tokens, options) {
    var matches2 = new Array(tokens.length);
    for (var i2 = 0; i2 < tokens.length; i2++) {
      if (typeof tokens[i2] === "object") {
        matches2[i2] = new RegExp("^(?:" + tokens[i2].pattern + ")$", flags(options));
      }
    }
    return function(obj, opts) {
      var path2 = "";
      var data = obj || {};
      var options2 = opts || {};
      var encode2 = options2.pretty ? encodeURIComponentPretty : encodeURIComponent;
      for (var i3 = 0; i3 < tokens.length; i3++) {
        var token = tokens[i3];
        if (typeof token === "string") {
          path2 += token;
          continue;
        }
        var value = data[token.name];
        var segment;
        if (value == null) {
          if (token.optional) {
            if (token.partial) {
              path2 += token.prefix;
            }
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to be defined');
          }
        }
        if (isarray2(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
          }
          if (value.length === 0) {
            if (token.optional) {
              continue;
            } else {
              throw new TypeError('Expected "' + token.name + '" to not be empty');
            }
          }
          for (var j2 = 0; j2 < value.length; j2++) {
            segment = encode2(value[j2]);
            if (!matches2[i3].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
            }
            path2 += (j2 === 0 ? token.prefix : token.delimiter) + segment;
          }
          continue;
        }
        segment = token.asterisk ? encodeAsterisk(value) : encode2(value);
        if (!matches2[i3].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
        }
        path2 += token.prefix + segment;
      }
      return path2;
    };
  }
  function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
  }
  function escapeGroup(group) {
    return group.replace(/([=!:$\/()])/g, "\\$1");
  }
  function attachKeys(re2, keys2) {
    re2.keys = keys2;
    return re2;
  }
  function flags(options) {
    return options && options.sensitive ? "" : "i";
  }
  function regexpToRegexp(path2, keys2) {
    var groups = path2.source.match(/\((?!\?)/g);
    if (groups) {
      for (var i2 = 0; i2 < groups.length; i2++) {
        keys2.push({
          name: i2,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          partial: false,
          asterisk: false,
          pattern: null
        });
      }
    }
    return attachKeys(path2, keys2);
  }
  function arrayToRegexp(path2, keys2, options) {
    var parts = [];
    for (var i2 = 0; i2 < path2.length; i2++) {
      parts.push(pathToRegexp2(path2[i2], keys2, options).source);
    }
    var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options));
    return attachKeys(regexp, keys2);
  }
  function stringToRegexp(path2, keys2, options) {
    return tokensToRegExp(parse2(path2, options), keys2, options);
  }
  function tokensToRegExp(tokens, keys2, options) {
    if (!isarray2(keys2)) {
      options = /** @type {!Object} */
      keys2 || options;
      keys2 = [];
    }
    options = options || {};
    var strict = options.strict;
    var end = options.end !== false;
    var route = "";
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      if (typeof token === "string") {
        route += escapeString(token);
      } else {
        var prefix2 = escapeString(token.prefix);
        var capture = "(?:" + token.pattern + ")";
        keys2.push(token);
        if (token.repeat) {
          capture += "(?:" + prefix2 + capture + ")*";
        }
        if (token.optional) {
          if (!token.partial) {
            capture = "(?:" + prefix2 + "(" + capture + "))?";
          } else {
            capture = prefix2 + "(" + capture + ")?";
          }
        } else {
          capture = prefix2 + "(" + capture + ")";
        }
        route += capture;
      }
    }
    var delimiter = escapeString(options.delimiter || "/");
    var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
    if (!strict) {
      route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?";
    }
    if (end) {
      route += "$";
    } else {
      route += strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)";
    }
    return attachKeys(new RegExp("^" + route, flags(options)), keys2);
  }
  function pathToRegexp2(path2, keys2, options) {
    if (!isarray2(keys2)) {
      options = /** @type {!Object} */
      keys2 || options;
      keys2 = [];
    }
    options = options || {};
    if (path2 instanceof RegExp) {
      return regexpToRegexp(
        path2,
        /** @type {!Array} */
        keys2
      );
    }
    if (isarray2(path2)) {
      return arrayToRegexp(
        /** @type {!Array} */
        path2,
        /** @type {!Array} */
        keys2,
        options
      );
    }
    return stringToRegexp(
      /** @type {string} */
      path2,
      /** @type {!Array} */
      keys2,
      options
    );
  }
  return pathToRegexp$1.exports;
}
var pathToRegexpExports = requirePathToRegexp();
const pathToRegexp = /* @__PURE__ */ getDefaultExportFromCjs(pathToRegexpExports);
requireReactIs$1();
var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== "undefined" ? (
  // eslint-disable-next-line no-undef
  globalThis
) : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
function getUniqueId() {
  var key = "__global_unique_id__";
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
}
function objectIs(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function createEventEmitter(value) {
  var handlers2 = [];
  return {
    on: function on(handler) {
      handlers2.push(handler);
    },
    off: function off(handler) {
      handlers2 = handlers2.filter(function(h2) {
        return h2 !== handler;
      });
    },
    get: function get11() {
      return value;
    },
    set: function set3(newValue, changedBits) {
      value = newValue;
      handlers2.forEach(function(handler) {
        return handler(value, changedBits);
      });
    }
  };
}
function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}
function createReactContext(defaultValue2, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;
  var contextProp = "__create-react-context-" + getUniqueId() + "__";
  var Provider2 = /* @__PURE__ */ (function(_React$Component) {
    _inheritsLoose(Provider22, _React$Component);
    function Provider22() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }
    var _proto = Provider22.prototype;
    _proto.getChildContext = function getChildContext() {
      var _ref;
      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };
    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;
        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          changedBits |= 0;
          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };
    _proto.render = function render3() {
      return this.props.children;
    };
    return Provider22;
  })(React.Component);
  Provider2.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = PropTypes.object.isRequired, _Provider$childContex);
  var Consumer = /* @__PURE__ */ (function(_React$Component2) {
    _inheritsLoose(Consumer2, _React$Component2);
    function Consumer2() {
      var _this2;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _this2 = _React$Component2.call.apply(_React$Component2, [this].concat(args)) || this;
      _this2.observedBits = void 0;
      _this2.state = {
        value: _this2.getValue()
      };
      _this2.onUpdate = function(newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };
      return _this2;
    }
    var _proto2 = Consumer2.prototype;
    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };
    _proto2.getValue = function getValue2() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue2;
      }
    };
    _proto2.render = function render3() {
      return onlyChild(this.props.children)(this.state.value);
    };
    return Consumer2;
  })(React.Component);
  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = PropTypes.object, _Consumer$contextType);
  return {
    Provider: Provider2,
    Consumer
  };
}
var createContext = React.createContext || createReactContext;
var createNamedContext = function createNamedContext2(name) {
  var context2 = createContext();
  context2.displayName = name;
  return context2;
};
var historyContext = /* @__PURE__ */ createNamedContext("Router-History");
var context = /* @__PURE__ */ createNamedContext("Router");
var Router = /* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(Router2, _React$Component);
  Router2.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };
  function Router2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    };
    _this._isMounted = false;
    _this._pendingLocation = null;
    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function(location2) {
        _this._pendingLocation = location2;
      });
    }
    return _this;
  }
  var _proto = Router2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;
    this._isMounted = true;
    if (this.unlisten) {
      this.unlisten();
    }
    if (!this.props.staticContext) {
      this.unlisten = this.props.history.listen(function(location2) {
        if (_this2._isMounted) {
          _this2.setState({
            location: location2
          });
        }
      });
    }
    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) {
      this.unlisten();
      this._isMounted = false;
      this._pendingLocation = null;
    }
  };
  _proto.render = function render3() {
    return /* @__PURE__ */ React.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router2.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, /* @__PURE__ */ React.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };
  return Router2;
})(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(MemoryRouter2, _React$Component);
  function MemoryRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }
  var _proto = MemoryRouter2.prototype;
  _proto.render = function render3() {
    return /* @__PURE__ */ React.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return MemoryRouter2;
})(React.Component);
var Lifecycle = /* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(Lifecycle2, _React$Component);
  function Lifecycle2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Lifecycle2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount) this.props.onUnmount.call(this, this);
  };
  _proto.render = function render3() {
    return null;
  };
  return Lifecycle2;
})(React.Component);
var cache = {};
var cacheLimit = 1e4;
var cacheCount = 0;
function compilePath(path2) {
  if (cache[path2]) return cache[path2];
  var generator = pathToRegexp.compile(path2);
  if (cacheCount < cacheLimit) {
    cache[path2] = generator;
    cacheCount++;
  }
  return generator;
}
function generatePath(path2, params) {
  if (path2 === void 0) {
    path2 = "/";
  }
  if (params === void 0) {
    params = {};
  }
  return path2 === "/" ? path2 : compilePath(path2)(params, {
    pretty: true
  });
}
function Redirect(_ref) {
  var computedMatch = _ref.computedMatch, to2 = _ref.to, _ref$push = _ref.push, push = _ref$push === void 0 ? false : _ref$push;
  return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context2) {
    !context2 ? invariant() : void 0;
    var history = context2.history, staticContext = context2.staticContext;
    var method = push ? history.push : history.replace;
    var location2 = createLocation(computedMatch ? typeof to2 === "string" ? generatePath(to2, computedMatch.params) : _extends$2({}, to2, {
      pathname: generatePath(to2.pathname, computedMatch.params)
    }) : to2);
    if (staticContext) {
      method(location2);
      return null;
    }
    return /* @__PURE__ */ React.createElement(Lifecycle, {
      onMount: function onMount() {
        method(location2);
      },
      onUpdate: function onUpdate(self2, prevProps) {
        var prevLocation = createLocation(prevProps.to);
        if (!locationsAreEqual(prevLocation, _extends$2({}, location2, {
          key: prevLocation.key
        }))) {
          method(location2);
        }
      },
      to: to2
    });
  });
}
var cache$1 = {};
var cacheLimit$1 = 1e4;
var cacheCount$1 = 0;
function compilePath$1(path2, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path2]) return pathCache[path2];
  var keys2 = [];
  var regexp = pathToRegexp(path2, keys2, options);
  var result = {
    regexp,
    keys: keys2
  };
  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path2] = result;
    cacheCount$1++;
  }
  return result;
}
function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }
  var _options = options, path2 = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path2);
  return paths.reduce(function(matched, path22) {
    if (!path22 && path22 !== "") return null;
    if (matched) return matched;
    var _compilePath = compilePath$1(path22, {
      end: exact,
      strict,
      sensitive
    }), regexp = _compilePath.regexp, keys2 = _compilePath.keys;
    var match2 = regexp.exec(pathname);
    if (!match2) return null;
    var url = match2[0], values2 = match2.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact) return null;
    return {
      path: path22,
      // the path used to match
      url: path22 === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact,
      // whether or not we matched exactly
      params: keys2.reduce(function(memo, key, index) {
        memo[key.name] = values2[index];
        return memo;
      }, {})
    };
  }, null);
}
function isEmptyChildren(children) {
  return React.Children.count(children) === 0;
}
var Route = /* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(Route2, _React$Component);
  function Route2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Route2.prototype;
  _proto.render = function render3() {
    var _this = this;
    return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context$1) {
      !context$1 ? invariant() : void 0;
      var location2 = _this.props.location || context$1.location;
      var match2 = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath(location2.pathname, _this.props) : context$1.match;
      var props = _extends$2({}, context$1, {
        location: location2,
        match: match2
      });
      var _this$props = _this.props, children = _this$props.children, component = _this$props.component, render22 = _this$props.render;
      if (Array.isArray(children) && isEmptyChildren(children)) {
        children = null;
      }
      return /* @__PURE__ */ React.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ? children(props) : children : component ? /* @__PURE__ */ React.createElement(component, props) : render22 ? render22(props) : null : typeof children === "function" ? children(props) : null);
    });
  };
  return Route2;
})(React.Component);
function addLeadingSlash(path2) {
  return path2.charAt(0) === "/" ? path2 : "/" + path2;
}
function addBasename(basename, location2) {
  if (!basename) return location2;
  return _extends$2({}, location2, {
    pathname: addLeadingSlash(basename) + location2.pathname
  });
}
function stripBasename(basename, location2) {
  if (!basename) return location2;
  var base = addLeadingSlash(basename);
  if (location2.pathname.indexOf(base) !== 0) return location2;
  return _extends$2({}, location2, {
    pathname: location2.pathname.substr(base.length)
  });
}
function createURL(location2) {
  return typeof location2 === "string" ? location2 : createPath(location2);
}
function staticHandler(methodName) {
  return function() {
    invariant();
  };
}
function noop() {
}
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(StaticRouter2, _React$Component);
  function StaticRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handlePush = function(location2) {
      return _this.navigateTo(location2, "PUSH");
    };
    _this.handleReplace = function(location2) {
      return _this.navigateTo(location2, "REPLACE");
    };
    _this.handleListen = function() {
      return noop;
    };
    _this.handleBlock = function() {
      return noop;
    };
    return _this;
  }
  var _proto = StaticRouter2.prototype;
  _proto.navigateTo = function navigateTo(location2, action) {
    var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
    context2.action = action;
    context2.location = addBasename(basename, createLocation(location2));
    context2.url = createURL(context2.location);
  };
  _proto.render = function render3() {
    var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location2 = _this$props2$location === void 0 ? "/" : _this$props2$location, rest2 = _objectWithoutPropertiesLoose$1(_this$props2, ["basename", "context", "location"]);
    var history = {
      createHref: function createHref(path2) {
        return addLeadingSlash(basename + createURL(path2));
      },
      action: "POP",
      location: stripBasename(basename, createLocation(location2)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler(),
      goBack: staticHandler(),
      goForward: staticHandler(),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return /* @__PURE__ */ React.createElement(Router, _extends$2({}, rest2, {
      history,
      staticContext: context2
    }));
  };
  return StaticRouter2;
})(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(Switch2, _React$Component);
  function Switch2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Switch2.prototype;
  _proto.render = function render3() {
    var _this = this;
    return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context2) {
      !context2 ? invariant() : void 0;
      var location2 = _this.props.location || context2.location;
      var element, match2;
      React.Children.forEach(_this.props.children, function(child) {
        if (match2 == null && /* @__PURE__ */ React.isValidElement(child)) {
          element = child;
          var path2 = child.props.path || child.props.from;
          match2 = path2 ? matchPath(location2.pathname, _extends$2({}, child.props, {
            path: path2
          })) : context2.match;
        }
      });
      return match2 ? /* @__PURE__ */ React.cloneElement(element, {
        location: location2,
        computedMatch: match2
      }) : null;
    });
  };
  return Switch2;
})(React.Component);
function withRouter(Component) {
  var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";
  var C = function C2(props) {
    var wrappedComponentRef = props.wrappedComponentRef, remainingProps = _objectWithoutPropertiesLoose$1(props, ["wrappedComponentRef"]);
    return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context2) {
      !context2 ? invariant() : void 0;
      return /* @__PURE__ */ React.createElement(Component, _extends$2({}, remainingProps, context2, {
        ref: wrappedComponentRef
      }));
    });
  };
  C.displayName = displayName;
  C.WrappedComponent = Component;
  return hoistStatics(C, Component);
}
var useContext = React.useContext;
function useHistory() {
  return useContext(historyContext);
}
function useLocation() {
  return useContext(context).location;
}
function useParams() {
  var match2 = useContext(context).match;
  return match2 ? match2.params : {};
}
function useLoadGsiScript$1(options = {}) {
  const { nonce, onScriptLoadSuccess, onScriptLoadError } = options;
  const [scriptLoadedSuccessfully, setScriptLoadedSuccessfully] = reactExports.useState(false);
  const onScriptLoadSuccessRef = reactExports.useRef(onScriptLoadSuccess);
  onScriptLoadSuccessRef.current = onScriptLoadSuccess;
  const onScriptLoadErrorRef = reactExports.useRef(onScriptLoadError);
  onScriptLoadErrorRef.current = onScriptLoadError;
  reactExports.useEffect(() => {
    const scriptTag = document.createElement("script");
    scriptTag.src = "https://accounts.google.com/gsi/client";
    scriptTag.async = true;
    scriptTag.defer = true;
    scriptTag.nonce = nonce;
    scriptTag.onload = () => {
      var _a;
      setScriptLoadedSuccessfully(true);
      (_a = onScriptLoadSuccessRef.current) === null || _a === void 0 ? void 0 : _a.call(onScriptLoadSuccessRef);
    };
    scriptTag.onerror = () => {
      var _a;
      setScriptLoadedSuccessfully(false);
      (_a = onScriptLoadErrorRef.current) === null || _a === void 0 ? void 0 : _a.call(onScriptLoadErrorRef);
    };
    document.body.appendChild(scriptTag);
    return () => {
      document.body.removeChild(scriptTag);
    };
  }, [nonce]);
  return scriptLoadedSuccessfully;
}
const GoogleOAuthContext$1 = reactExports.createContext(null);
function GoogleOAuthProvider$1({ clientId, nonce, onScriptLoadSuccess, onScriptLoadError, children }) {
  const scriptLoadedSuccessfully = useLoadGsiScript$1({
    nonce,
    onScriptLoadSuccess,
    onScriptLoadError
  });
  const contextValue = reactExports.useMemo(() => ({
    clientId,
    scriptLoadedSuccessfully
  }), [clientId, scriptLoadedSuccessfully]);
  return React.createElement(GoogleOAuthContext$1.Provider, { value: contextValue }, children);
}
function useGoogleOAuth$1() {
  const context2 = reactExports.useContext(GoogleOAuthContext$1);
  if (!context2) {
    throw new Error("Google OAuth components must be used within GoogleOAuthProvider");
  }
  return context2;
}
function useGoogleLogin$1({ flow = "implicit", scope = "", onSuccess, onError, onNonOAuthError, overrideScope, state, ...props }) {
  const { clientId, scriptLoadedSuccessfully } = useGoogleOAuth$1();
  const clientRef = reactExports.useRef();
  const onSuccessRef = reactExports.useRef(onSuccess);
  onSuccessRef.current = onSuccess;
  const onErrorRef = reactExports.useRef(onError);
  onErrorRef.current = onError;
  const onNonOAuthErrorRef = reactExports.useRef(onNonOAuthError);
  onNonOAuthErrorRef.current = onNonOAuthError;
  reactExports.useEffect(() => {
    var _a;
    if (!scriptLoadedSuccessfully)
      return;
    const clientMethod = flow === "implicit" ? "initTokenClient" : "initCodeClient";
    const client2 = (_a = window === null || window === void 0 ? void 0 : window.google) === null || _a === void 0 ? void 0 : _a.accounts.oauth2[clientMethod]({
      client_id: clientId,
      scope: overrideScope ? scope : "openid profile email ".concat(scope),
      callback: (response) => {
        var _a2, _b;
        if (response.error)
          return (_a2 = onErrorRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onErrorRef, response);
        (_b = onSuccessRef.current) === null || _b === void 0 ? void 0 : _b.call(onSuccessRef, response);
      },
      error_callback: (nonOAuthError) => {
        var _a2;
        (_a2 = onNonOAuthErrorRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onNonOAuthErrorRef, nonOAuthError);
      },
      state,
      ...props
    });
    clientRef.current = client2;
  }, [clientId, scriptLoadedSuccessfully, flow, scope, state]);
  const loginImplicitFlow = reactExports.useCallback((overrideConfig) => {
    var _a;
    return (_a = clientRef.current) === null || _a === void 0 ? void 0 : _a.requestAccessToken(overrideConfig);
  }, []);
  const loginAuthCodeFlow = reactExports.useCallback(() => {
    var _a;
    return (_a = clientRef.current) === null || _a === void 0 ? void 0 : _a.requestCode();
  }, []);
  return flow === "implicit" ? loginImplicitFlow : loginAuthCodeFlow;
}
const instanceOfAny = (object2, constructors) => constructors.some((c2) => object2 instanceof c2);
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const cursorRequestMap = /* @__PURE__ */ new WeakMap();
const transactionDoneMap = /* @__PURE__ */ new WeakMap();
const transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
const transformCache = /* @__PURE__ */ new WeakMap();
const reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request3) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request3.removeEventListener("success", success);
      request3.removeEventListener("error", error2);
    };
    const success = () => {
      resolve(wrap(request3.result));
      unlisten();
    };
    const error2 = () => {
      reject(request3.error);
      unlisten();
    };
    request3.addEventListener("success", success);
    request3.addEventListener("error", error2);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request3);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request3);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error2);
      tx.removeEventListener("abort", error2);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error2 = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error2);
    tx.addEventListener("abort", error2);
  });
  transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);
function openDB(name, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request3 = indexedDB.open(name, version2);
  const openPromise = wrap(request3);
  if (upgrade) {
    request3.addEventListener("upgradeneeded", (event2) => {
      upgrade(wrap(request3.result), event2.oldVersion, event2.newVersion, wrap(request3.transaction), event2);
    });
  }
  if (blocked) {
    request3.addEventListener("blocked", (event2) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event2.oldVersion,
      event2.newVersion,
      event2
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event2) => blocking(event2.oldVersion, event2.newVersion, event2));
    }
  }).catch(() => {
  });
  return openPromise;
}
function deleteDB(name, { blocked } = {}) {
  const request3 = indexedDB.deleteDatabase(name);
  if (blocked) {
    request3.addEventListener("blocked", (event2) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event2.oldVersion,
      event2
    ));
  }
  return wrap(request3).then(() => void 0);
}
const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
const writeMethods = ["put", "add", "delete", "clear"];
const cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
const ErrorBoundaryContext$1 = reactExports.createContext(null);
const initialState$2 = {
  didCatch: false,
  error: null
};
let ErrorBoundary$1 = class ErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
    this.state = initialState$2;
  }
  static getDerivedStateFromError(error2) {
    return {
      didCatch: true,
      error: error2
    };
  }
  resetErrorBoundary() {
    const {
      error: error2
    } = this.state;
    if (error2 !== null) {
      var _this$props$onReset, _this$props;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
        args,
        reason: "imperative-api"
      });
      this.setState(initialState$2);
    }
  }
  componentDidCatch(error2, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error2, info);
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      didCatch
    } = this.state;
    const {
      resetKeys
    } = this.props;
    if (didCatch && prevState.error !== null && hasArrayChanged$1(prevProps.resetKeys, resetKeys)) {
      var _this$props$onReset2, _this$props3;
      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      });
      this.setState(initialState$2);
    }
  }
  render() {
    const {
      children,
      fallbackRender,
      FallbackComponent,
      fallback
    } = this.props;
    const {
      didCatch,
      error: error2
    } = this.state;
    let childToRender = children;
    if (didCatch) {
      const props = {
        error: error2,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof fallbackRender === "function") {
        childToRender = fallbackRender(props);
      } else if (FallbackComponent) {
        childToRender = reactExports.createElement(FallbackComponent, props);
      } else if (fallback !== void 0) {
        childToRender = fallback;
      } else {
        throw error2;
      }
    }
    return reactExports.createElement(ErrorBoundaryContext$1.Provider, {
      value: {
        didCatch,
        error: error2,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
};
function hasArrayChanged$1() {
  let a2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let b2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return a2.length !== b2.length || a2.some((item, index) => !Object.is(item, b2[index]));
}
class ClipboardWeb extends WebPlugin {
  async write(options) {
    if (typeof navigator === "undefined" || !navigator.clipboard) {
      throw this.unavailable("Clipboard API not available in this browser");
    }
    if (options.string !== void 0) {
      await this.writeText(options.string);
    } else if (options.url) {
      await this.writeText(options.url);
    } else if (options.image) {
      if (typeof ClipboardItem !== "undefined") {
        try {
          const blob = await (await fetch(options.image)).blob();
          const clipboardItemInput = new ClipboardItem({ [blob.type]: blob });
          await navigator.clipboard.write([clipboardItemInput]);
        } catch (err2) {
          throw new Error("Failed to write image");
        }
      } else {
        throw this.unavailable("Writing images to the clipboard is not supported in this browser");
      }
    } else {
      throw new Error("Nothing to write");
    }
  }
  async read() {
    if (typeof navigator === "undefined" || !navigator.clipboard) {
      throw this.unavailable("Clipboard API not available in this browser");
    }
    if (typeof ClipboardItem !== "undefined") {
      try {
        const clipboardItems = await navigator.clipboard.read();
        const type = clipboardItems[0].types[0];
        const clipboardBlob = await clipboardItems[0].getType(type);
        const data = await this._getBlobData(clipboardBlob, type);
        return { value: data, type };
      } catch (err2) {
        return this.readText();
      }
    } else {
      return this.readText();
    }
  }
  async readText() {
    if (typeof navigator === "undefined" || !navigator.clipboard || !navigator.clipboard.readText) {
      throw this.unavailable("Reading from clipboard not supported in this browser");
    }
    const text = await navigator.clipboard.readText();
    return { value: text, type: "text/plain" };
  }
  async writeText(text) {
    if (typeof navigator === "undefined" || !navigator.clipboard || !navigator.clipboard.writeText) {
      throw this.unavailable("Writting to clipboard not supported in this browser");
    }
    await navigator.clipboard.writeText(text);
  }
  _getBlobData(clipboardBlob, type) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      if (type.includes("image")) {
        reader.readAsDataURL(clipboardBlob);
      } else {
        reader.readAsText(clipboardBlob);
      }
      reader.onloadend = () => {
        const r2 = reader.result;
        resolve(r2);
      };
      reader.onerror = (e2) => {
        reject(e2);
      };
    });
  }
}
const Clipboard = registerPlugin("Clipboard", {
  web: () => new ClipboardWeb()
});
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
function useAttribution(map3, attribution) {
  const attributionRef = reactExports.useRef(attribution);
  reactExports.useEffect(function updateAttribution() {
    if (attribution !== attributionRef.current && map3.attributionControl != null) {
      if (attributionRef.current != null) {
        map3.attributionControl.removeAttribution(attributionRef.current);
      }
      if (attribution != null) {
        map3.attributionControl.addAttribution(attribution);
      }
    }
    attributionRef.current = attribution;
  }, [
    map3,
    attribution
  ]);
}
const CONTEXT_VERSION = 1;
function createLeafletContext(map3) {
  return Object.freeze({
    __version: CONTEXT_VERSION,
    map: map3
  });
}
const LeafletContext = reactExports.createContext(null);
const LeafletProvider = LeafletContext.Provider;
function useLeafletContext() {
  const context2 = reactExports.useContext(LeafletContext);
  if (context2 == null) {
    throw new Error("No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>");
  }
  return context2;
}
function createLeafComponent(useElement) {
  function LeafComponent(props, forwardedRef) {
    const { instance: instance2 } = useElement(props).current;
    reactExports.useImperativeHandle(forwardedRef, () => instance2);
    return null;
  }
  return /* @__PURE__ */ reactExports.forwardRef(LeafComponent);
}
function useEventHandlers(element, eventHandlers) {
  const eventHandlersRef = reactExports.useRef();
  reactExports.useEffect(function addEventHandlers() {
    if (eventHandlers != null) {
      element.instance.on(eventHandlers);
    }
    eventHandlersRef.current = eventHandlers;
    return function removeEventHandlers() {
      if (eventHandlersRef.current != null) {
        element.instance.off(eventHandlersRef.current);
      }
      eventHandlersRef.current = null;
    };
  }, [
    element,
    eventHandlers
  ]);
}
function withPane(props, context2) {
  var _a;
  const pane = (_a = props.pane) != null ? _a : context2.pane;
  return pane ? {
    ...props,
    pane
  } : props;
}
function createElementObject(instance2, context2, container) {
  return Object.freeze({
    instance: instance2,
    context: context2,
    container
  });
}
function createElementHook(createElement2, updateElement2) {
  if (updateElement2 == null) {
    return function useImmutableLeafletElement(props, context2) {
      const elementRef = reactExports.useRef();
      if (!elementRef.current) elementRef.current = createElement2(props, context2);
      return elementRef;
    };
  }
  return function useMutableLeafletElement(props, context2) {
    const elementRef = reactExports.useRef();
    if (!elementRef.current) elementRef.current = createElement2(props, context2);
    const propsRef = reactExports.useRef(props);
    const { instance: instance2 } = elementRef.current;
    reactExports.useEffect(function updateElementProps() {
      if (propsRef.current !== props) {
        updateElement2(instance2, props, propsRef.current);
        propsRef.current = props;
      }
    }, [
      instance2,
      props,
      context2
    ]);
    return elementRef;
  };
}
function useLayerLifecycle(element, context2) {
  reactExports.useEffect(function addLayer() {
    var _a;
    const container = (_a = context2.layerContainer) != null ? _a : context2.map;
    container.addLayer(element.instance);
    return function removeLayer() {
      var _a2;
      (_a2 = context2.layerContainer) == null ? void 0 : _a2.removeLayer(element.instance);
      context2.map.removeLayer(element.instance);
    };
  }, [
    context2,
    element
  ]);
}
function createLayerHook(useElement) {
  return function useLayer(props) {
    const context2 = useLeafletContext();
    const elementRef = useElement(withPane(props, context2), context2);
    useAttribution(context2.map, props.attribution);
    useEventHandlers(elementRef.current, props.eventHandlers);
    useLayerLifecycle(elementRef.current, context2);
    return elementRef;
  };
}
function createTileLayerComponent(createElement2, updateElement2) {
  const useElement = createElementHook(createElement2, updateElement2);
  const useLayer = createLayerHook(useElement);
  return createLeafComponent(useLayer);
}
function updateGridLayer(layer, props, prevProps) {
  const { opacity, zIndex } = props;
  if (opacity != null && opacity !== prevProps.opacity) {
    layer.setOpacity(opacity);
  }
  if (zIndex != null && zIndex !== prevProps.zIndex) {
    layer.setZIndex(zIndex);
  }
}
function useMap() {
  return useLeafletContext().map;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function MapContainerComponent({ bounds, boundsOptions, center, children, className, id, placeholder, style, whenReady, zoom: zoom2, ...options }, forwardedRef) {
  const [props] = reactExports.useState({
    className,
    id,
    style
  });
  const [context2, setContext] = reactExports.useState(null);
  reactExports.useImperativeHandle(forwardedRef, () => {
    var _a;
    return (_a = context2 == null ? void 0 : context2.map) != null ? _a : null;
  }, [
    context2
  ]);
  const mapRef = reactExports.useCallback((node) => {
    if (node !== null && context2 === null) {
      const map3 = new leafletSrcExports.Map(node, options);
      if (center != null && zoom2 != null) {
        map3.setView(center, zoom2);
      } else if (bounds != null) {
        map3.fitBounds(bounds, boundsOptions);
      }
      if (whenReady != null) {
        map3.whenReady(whenReady);
      }
      setContext(createLeafletContext(map3));
    }
  }, []);
  reactExports.useEffect(() => {
    return () => {
      context2 == null ? void 0 : context2.map.remove();
    };
  }, [
    context2
  ]);
  const contents = context2 ? /* @__PURE__ */ React.createElement(LeafletProvider, {
    value: context2
  }, children) : placeholder != null ? placeholder : null;
  return /* @__PURE__ */ React.createElement("div", _extends({}, props, {
    ref: mapRef
  }), contents);
}
const MapContainer = /* @__PURE__ */ reactExports.forwardRef(MapContainerComponent);
const TileLayer = createTileLayerComponent(function createTileLayer({ url, ...options }, context2) {
  const layer = new leafletSrcExports.TileLayer(url, withPane(options, context2));
  return createElementObject(layer, context2);
}, function updateTileLayer(layer, props, prevProps) {
  updateGridLayer(layer, props, prevProps);
  const { url } = props;
  if (url != null && url !== prevProps.url) {
    layer.setUrl(url);
  }
});
function e() {
  return e = Object.assign ? Object.assign.bind() : function(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var r2 = arguments[e2];
      for (var n2 in r2) Object.prototype.hasOwnProperty.call(r2, n2) && (t2[n2] = r2[n2]);
    }
    return t2;
  }, e.apply(this, arguments);
}
function r(t2, e2) {
  t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, n(t2, e2);
}
function n(t2, e2) {
  return n = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, n(t2, e2);
}
function o() {
  if ("undefined" == typeof Reflect || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if ("function" == typeof Proxy) return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch (t2) {
    return false;
  }
}
function i(t2, e2, r2) {
  return i = o() ? Reflect.construct.bind() : function(t3, e3, r3) {
    var o2 = [null];
    o2.push.apply(o2, e3);
    var i2 = new (Function.bind.apply(t3, o2))();
    return r3 && n(i2, r3.prototype), i2;
  }, i.apply(null, arguments);
}
function s(t2, e2, r2, n2) {
  void 0 === e2 && (e2 = ""), void 0 === n2 && (n2 = {});
  var o2 = document.createElement(t2);
  return e2 && (o2.className = e2), Object.keys(n2).forEach(function(t3) {
    if ("function" == typeof n2[t3]) {
      var e3 = 0 === t3.indexOf("on") ? t3.substr(2).toLowerCase() : t3;
      o2.addEventListener(e3, n2[t3]);
    } else "html" === t3 ? o2.innerHTML = n2[t3] : "text" === t3 ? o2.innerText = n2[t3] : o2.setAttribute(t3, n2[t3]);
  }), r2 && r2.appendChild(o2), o2;
}
function a(t2) {
  t2.preventDefault(), t2.stopPropagation();
}
var l = function() {
  return [].slice.call(arguments).filter(Boolean).join(" ").trim();
};
function c(t2, e2) {
  t2 && t2.classList && (Array.isArray(e2) ? e2 : [e2]).forEach(function(e3) {
    t2.classList.contains(e3) || t2.classList.add(e3);
  });
}
function u(t2, e2) {
  t2 && t2.classList && (Array.isArray(e2) ? e2 : [e2]).forEach(function(e3) {
    t2.classList.contains(e3) && t2.classList.remove(e3);
  });
}
var h, p = 13, d = 40, f = 38, m = [p, 27, d, f, 37, 39], v = /* @__PURE__ */ (function() {
  function t2(t3) {
    var e3 = this, r2 = t3.handleSubmit, n2 = t3.searchLabel, o2 = t3.classNames, i2 = void 0 === o2 ? {} : o2;
    this.container = void 0, this.form = void 0, this.input = void 0, this.handleSubmit = void 0, this.hasError = false, this.container = s("div", l("geosearch", i2.container)), this.form = s("form", ["", i2.form].join(" "), this.container, { autocomplete: "none", onClick: a, onDblClick: a, touchStart: a, touchEnd: a }), this.input = s("input", ["glass", i2.input].join(" "), this.form, { type: "text", placeholder: n2 || "search", onInput: this.onInput, onKeyUp: function(t4) {
      return e3.onKeyUp(t4);
    }, onKeyPress: function(t4) {
      return e3.onKeyPress(t4);
    }, onFocus: this.onFocus, onBlur: this.onBlur, onClick: function() {
      e3.input.focus(), e3.input.dispatchEvent(new Event("focus"));
    } }), this.handleSubmit = r2;
  }
  var e2 = t2.prototype;
  return e2.onFocus = function() {
    c(this.form, "active");
  }, e2.onBlur = function() {
    u(this.form, "active");
  }, e2.onSubmit = function(t3) {
    try {
      var e3 = this;
      return a(t3), u(r2 = e3.container, "error"), c(r2, "pending"), Promise.resolve(e3.handleSubmit({ query: e3.input.value })).then(function() {
        u(e3.container, "pending");
      });
    } catch (t4) {
      return Promise.reject(t4);
    }
    var r2;
  }, e2.onInput = function() {
    this.hasError && (u(this.container, "error"), this.hasError = false);
  }, e2.onKeyUp = function(t3) {
    27 === t3.keyCode && (u(this.container, ["pending", "active"]), this.input.value = "", document.body.focus(), document.body.blur());
  }, e2.onKeyPress = function(t3) {
    t3.keyCode === p && this.onSubmit(t3);
  }, e2.setQuery = function(t3) {
    this.input.value = t3;
  }, t2;
})(), g = /* @__PURE__ */ (function() {
  function t2(t3) {
    var e3 = this, r2 = t3.handleClick, n2 = t3.classNames, o2 = void 0 === n2 ? {} : n2, i2 = t3.notFoundMessage;
    this.handleClick = void 0, this.selected = -1, this.results = [], this.container = void 0, this.resultItem = void 0, this.notFoundMessage = void 0, this.onClick = function(t4) {
      if ("function" == typeof e3.handleClick) {
        var r3 = t4.target;
        if (r3 && e3.container.contains(r3) && r3.hasAttribute("data-key")) {
          var n3 = Number(r3.getAttribute("data-key"));
          e3.handleClick({ result: e3.results[n3] });
        }
      }
    }, this.handleClick = r2, this.notFoundMessage = i2 ? s("div", l(o2.notfound), void 0, { html: i2 }) : void 0, this.container = s("div", l("results", o2.resultlist)), this.container.addEventListener("click", this.onClick, true), this.resultItem = s("div", l(o2.item));
  }
  var e2 = t2.prototype;
  return e2.render = function(t3, e3) {
    var r2 = this;
    void 0 === t3 && (t3 = []), this.clear(), t3.forEach(function(t4, n2) {
      var o2 = r2.resultItem.cloneNode(true);
      o2.setAttribute("data-key", "" + n2), o2.innerHTML = e3({ result: t4 }), r2.container.appendChild(o2);
    }), t3.length > 0 ? (c(this.container.parentElement, "open"), c(this.container, "active")) : this.notFoundMessage && (this.container.appendChild(this.notFoundMessage), c(this.container.parentElement, "open")), this.results = t3;
  }, e2.select = function(t3) {
    return Array.from(this.container.children).forEach(function(e3, r2) {
      return r2 === t3 ? c(e3, "active") : u(e3, "active");
    }), this.selected = t3, this.results[t3];
  }, e2.count = function() {
    return this.results ? this.results.length : 0;
  }, e2.clear = function() {
    for (this.selected = -1; this.container.lastChild; ) this.container.removeChild(this.container.lastChild);
    u(this.container.parentElement, "open"), u(this.container, "active");
  }, t2;
})(), y = { position: "topleft", style: "button", showMarker: true, showPopup: false, popupFormat: function(t2) {
  return "" + t2.result.label;
}, resultFormat: function(t2) {
  return "" + t2.result.label;
}, marker: { icon: t$1 && leafletSrcExports.Icon ? new leafletSrcExports.Icon.Default() : void 0, draggable: false }, maxMarkers: 1, maxSuggestions: 5, retainZoomLevel: false, animateZoom: true, searchLabel: "Enter address", clearSearchLabel: "Clear search", notFoundMessage: "", messageHideDelay: 3e3, zoomLevel: 18, classNames: { container: "leaflet-bar leaflet-control leaflet-control-geosearch", button: "leaflet-bar-part leaflet-bar-part-single", resetButton: "reset", msgbox: "leaflet-bar message", form: "", input: "", resultlist: "", item: "", notfound: "leaflet-bar-notfound" }, autoComplete: true, autoCompleteDelay: 250, autoClose: false, keepResult: false, updateMap: true }, b = "Leaflet must be loaded before instantiating the GeoSearch control", E = { options: e({}, y), classNames: e({}, y.classNames), initialize: function(r2) {
  var n2, o2, i2, a2, l2 = this;
  if (!t$1) throw new Error(b);
  if (!r2.provider) throw new Error("Provider is missing from options");
  this.options = e({}, y, r2), this.classNames = e({}, this.classNames, r2.classNames), this.markers = new leafletSrcExports.FeatureGroup(), this.classNames.container += " leaflet-geosearch-" + this.options.style, this.searchElement = new v({ searchLabel: this.options.searchLabel, classNames: { container: this.classNames.container, form: this.classNames.form, input: this.classNames.input }, handleSubmit: function(t2) {
    return l2.onSubmit(t2);
  } }), this.button = s("a", this.classNames.button, this.searchElement.container, { title: this.options.searchLabel, href: "#", onClick: function(t2) {
    return l2.onClick(t2);
  } }), leafletSrcExports.DomEvent.disableClickPropagation(this.button), this.resetButton = s("button", this.classNames.resetButton, this.searchElement.form, { text: "", "aria-label": this.options.clearSearchLabel, onClick: function() {
    "" === l2.searchElement.input.value ? l2.close() : l2.clearResults(null, true);
  } }), leafletSrcExports.DomEvent.disableClickPropagation(this.resetButton), this.options.autoComplete && (this.resultList = new g({ handleClick: function(t2) {
    var e2 = t2.result;
    l2.searchElement.input.value = e2.label, l2.onSubmit({ query: e2.label, data: e2 });
  }, classNames: { resultlist: this.classNames.resultlist, item: this.classNames.item, notfound: this.classNames.notfound }, notFoundMessage: this.options.notFoundMessage }), this.searchElement.form.appendChild(this.resultList.container), this.searchElement.input.addEventListener("keyup", (n2 = function(t2) {
    return l2.autoSearch(t2);
  }, void 0 === (o2 = this.options.autoCompleteDelay) && (o2 = 250), void 0 === i2 && (i2 = false), function() {
    var t2 = [].slice.call(arguments);
    a2 && clearTimeout(a2), a2 = setTimeout(function() {
      a2 = null, i2 || n2.apply(void 0, t2);
    }, o2), i2 && !a2 && n2.apply(void 0, t2);
  }), true), this.searchElement.input.addEventListener("keydown", function(t2) {
    return l2.selectResult(t2);
  }, true), this.searchElement.input.addEventListener("keydown", function(t2) {
    return l2.clearResults(t2, true);
  }, true)), this.searchElement.form.addEventListener("click", function(t2) {
    t2.preventDefault();
  }, false);
}, onAdd: function(e2) {
  var r2 = this.options, n2 = r2.showMarker, o2 = r2.style;
  if (this.map = e2, n2 && this.markers.addTo(e2), "bar" === o2) {
    var i2 = e2.getContainer().querySelector(".leaflet-control-container");
    this.container = s("div", "leaflet-control-geosearch leaflet-geosearch-bar"), this.container.appendChild(this.searchElement.form), i2.appendChild(this.container);
  }
  return leafletSrcExports.DomEvent.disableClickPropagation(this.searchElement.form), this.searchElement.container;
}, onRemove: function() {
  var t2;
  return null == (t2 = this.container) || t2.remove(), this;
}, open: function() {
  var t2 = this.searchElement, e2 = t2.input;
  c(t2.container, "active"), e2.focus();
}, close: function() {
  u(this.searchElement.container, "active"), this.clearResults();
}, onClick: function(t2) {
  t2.preventDefault(), t2.stopPropagation(), this.searchElement.container.classList.contains("active") ? this.close() : this.open();
}, selectResult: function(t2) {
  if (-1 !== [p, d, f].indexOf(t2.keyCode)) if (t2.preventDefault(), t2.keyCode !== p) {
    var e2 = this.resultList.count() - 1;
    if (!(e2 < 0)) {
      var r2 = this.resultList.selected, n2 = t2.keyCode === d ? r2 + 1 : r2 - 1, o2 = this.resultList.select(n2 < 0 ? e2 : n2 > e2 ? 0 : n2);
      this.searchElement.input.value = o2.label;
    }
  } else {
    var i2 = this.resultList.select(this.resultList.selected);
    this.onSubmit({ query: this.searchElement.input.value, data: i2 });
  }
}, clearResults: function(t2, e2) {
  if (void 0 === e2 && (e2 = false), !t2 || 27 === t2.keyCode) {
    var r2 = this.options, n2 = r2.autoComplete;
    !e2 && r2.keepResult || (this.searchElement.input.value = "", this.markers.clearLayers()), n2 && this.resultList.clear();
  }
}, autoSearch: function(t2) {
  try {
    var e2 = this;
    if (m.indexOf(t2.keyCode) > -1) return Promise.resolve();
    var r2 = t2.target.value, n2 = e2.options.provider, o2 = (function() {
      if (r2.length) return Promise.resolve(n2.search({ query: r2 })).then(function(t3) {
        t3 = t3.slice(0, e2.options.maxSuggestions), e2.resultList.render(t3, e2.options.resultFormat);
      });
      e2.resultList.clear();
    })();
    return Promise.resolve(o2 && o2.then ? o2.then(function() {
    }) : void 0);
  } catch (t3) {
    return Promise.reject(t3);
  }
}, onSubmit: function(t2) {
  try {
    var e2 = this;
    return e2.resultList.clear(), Promise.resolve(e2.options.provider.search(t2)).then(function(r2) {
      r2 && r2.length > 0 && e2.showResult(r2[0], t2);
    });
  } catch (t3) {
    return Promise.reject(t3);
  }
}, showResult: function(t2, e2) {
  var r2 = this.options, n2 = r2.autoClose, o2 = r2.updateMap, i2 = this.markers.getLayers();
  i2.length >= this.options.maxMarkers && this.markers.removeLayer(i2[0]);
  var s2 = this.addMarker(t2, e2);
  o2 && this.centerMap(t2), this.map.fireEvent("geosearch/showlocation", { location: t2, marker: s2 }), n2 && this.closeResults();
}, closeResults: function() {
  var t2 = this.searchElement.container;
  t2.classList.contains("active") && u(t2, "active"), this.clearResults();
}, addMarker: function(e2, r2) {
  var n2 = this, o2 = this.options, i2 = o2.marker, s2 = o2.showPopup, a2 = o2.popupFormat, l2 = new leafletSrcExports.Marker([e2.y, e2.x], i2), c2 = e2.label;
  return "function" == typeof a2 && (c2 = a2({ query: r2, result: e2 })), l2.bindPopup(c2), this.markers.addLayer(l2), s2 && l2.openPopup(), i2.draggable && l2.on("dragend", function(t2) {
    n2.map.fireEvent("geosearch/marker/dragend", { location: l2.getLatLng(), event: t2 });
  }), l2;
}, centerMap: function(e2) {
  var r2 = this.options, n2 = r2.retainZoomLevel, o2 = r2.animateZoom, i2 = e2.bounds ? new leafletSrcExports.LatLngBounds(e2.bounds) : new leafletSrcExports.LatLng(e2.y, e2.x).toBounds(10), s2 = i2.isValid() ? i2 : this.markers.getBounds();
  !n2 && i2.isValid() && !e2.bounds || n2 || !i2.isValid() ? this.map.setView(s2.getCenter(), this.getZoom(), { animate: o2 }) : this.map.fitBounds(s2, { animate: o2 });
}, getZoom: function() {
  var t2 = this.options, e2 = t2.zoomLevel;
  return t2.retainZoomLevel ? this.map.getZoom() : e2;
} };
function w() {
  if (!t$1) throw new Error(b);
  var e2 = leafletSrcExports.Control.extend(E);
  return i(e2, [].slice.call(arguments));
}
!(function(t2) {
  t2[t2.SEARCH = 0] = "SEARCH", t2[t2.REVERSE = 1] = "REVERSE";
})(h || (h = {}));
var x, k = /* @__PURE__ */ (function() {
  function t2(t3) {
    void 0 === t3 && (t3 = {}), this.options = void 0, this.options = t3;
  }
  var r2 = t2.prototype;
  return r2.getParamString = function(t3) {
    void 0 === t3 && (t3 = {});
    var r3 = e({}, this.options.params, t3);
    return Object.keys(r3).map(function(t4) {
      return encodeURIComponent(t4) + "=" + encodeURIComponent(r3[t4]);
    }).join("&");
  }, r2.getUrl = function(t3, e2) {
    return t3 + "?" + this.getParamString(e2);
  }, r2.search = function(t3) {
    try {
      var e2 = this, r3 = e2.endpoint({ query: t3.query, type: h.SEARCH });
      return Promise.resolve(fetch(r3)).then(function(t4) {
        return Promise.resolve(t4.json()).then(function(t5) {
          return e2.parse({ data: t5 });
        });
      });
    } catch (t4) {
      return Promise.reject(t4);
    }
  }, t2;
})();
!(function(t2) {
  t2[t2.INITIALIZED = 0] = "INITIALIZED", t2[t2.LOADING = 1] = "LOADING", t2[t2.SUCCESS = 2] = "SUCCESS", t2[t2.FAILURE = 3] = "FAILURE";
})(x || (x = {}));
var O = /* @__PURE__ */ (function(t2) {
  function e2(e3) {
    var r2;
    void 0 === e3 && (e3 = {}), (r2 = t2.call(this, e3) || this).searchUrl = void 0, r2.reverseUrl = void 0;
    var n3 = "https://nominatim.openstreetmap.org";
    return r2.searchUrl = e3.searchUrl || n3 + "/search", r2.reverseUrl = e3.reverseUrl || n3 + "/reverse", r2;
  }
  r(e2, t2);
  var n2 = e2.prototype;
  return n2.endpoint = function(t3) {
    var e3 = t3.query, r2 = t3.type, n3 = "string" == typeof e3 ? { q: e3 } : e3;
    return n3.format = "json", this.getUrl(r2 === h.REVERSE ? this.reverseUrl : this.searchUrl, n3);
  }, n2.parse = function(t3) {
    return (Array.isArray(t3.data) ? t3.data : [t3.data]).map(function(t4) {
      return { x: Number(t4.lon), y: Number(t4.lat), label: t4.display_name, bounds: [[parseFloat(t4.boundingbox[0]), parseFloat(t4.boundingbox[2])], [parseFloat(t4.boundingbox[1]), parseFloat(t4.boundingbox[3])]], raw: t4 };
    });
  }, e2;
})(k);
var build = { exports: {} };
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build.exports;
  hasRequiredBuild = 1;
  (() => {
    var e2 = { 296: (e22, t22, r22) => {
      var o22 = /^\s+|\s+$/g, n2 = /^[-+]0x[0-9a-f]+$/i, i2 = /^0b[01]+$/i, c2 = /^0o[0-7]+$/i, u2 = parseInt, s2 = "object" == typeof r22.g && r22.g && r22.g.Object === Object && r22.g, l2 = "object" == typeof self && self && self.Object === Object && self, a2 = s2 || l2 || Function("return this")(), f2 = Object.prototype.toString, p2 = Math.max, y2 = Math.min, b2 = function() {
        return a2.Date.now();
      };
      function d2(e3) {
        var t3 = typeof e3;
        return !!e3 && ("object" == t3 || "function" == t3);
      }
      function h2(e3) {
        if ("number" == typeof e3) return e3;
        if ((function(e4) {
          return "symbol" == typeof e4 || /* @__PURE__ */ (function(e5) {
            return !!e5 && "object" == typeof e5;
          })(e4) && "[object Symbol]" == f2.call(e4);
        })(e3)) return NaN;
        if (d2(e3)) {
          var t3 = "function" == typeof e3.valueOf ? e3.valueOf() : e3;
          e3 = d2(t3) ? t3 + "" : t3;
        }
        if ("string" != typeof e3) return 0 === e3 ? e3 : +e3;
        e3 = e3.replace(o22, "");
        var r3 = i2.test(e3);
        return r3 || c2.test(e3) ? u2(e3.slice(2), r3 ? 2 : 8) : n2.test(e3) ? NaN : +e3;
      }
      e22.exports = function(e3, t3, r3) {
        var o3, n22, i22, c22, u22, s22, l22 = 0, a22 = false, f22 = false, v2 = true;
        if ("function" != typeof e3) throw new TypeError("Expected a function");
        function m2(t4) {
          var r4 = o3, i3 = n22;
          return o3 = n22 = void 0, l22 = t4, c22 = e3.apply(i3, r4);
        }
        function O2(e4) {
          var r4 = e4 - s22;
          return void 0 === s22 || r4 >= t3 || r4 < 0 || f22 && e4 - l22 >= i22;
        }
        function w2() {
          var e4 = b2();
          if (O2(e4)) return g2(e4);
          u22 = setTimeout(w2, (function(e5) {
            var r4 = t3 - (e5 - s22);
            return f22 ? y2(r4, i22 - (e5 - l22)) : r4;
          })(e4));
        }
        function g2(e4) {
          return u22 = void 0, v2 && o3 ? m2(e4) : (o3 = n22 = void 0, c22);
        }
        function P() {
          var e4 = b2(), r4 = O2(e4);
          if (o3 = arguments, n22 = this, s22 = e4, r4) {
            if (void 0 === u22) return (function(e5) {
              return l22 = e5, u22 = setTimeout(w2, t3), a22 ? m2(e5) : c22;
            })(s22);
            if (f22) return u22 = setTimeout(w2, t3), m2(s22);
          }
          return void 0 === u22 && (u22 = setTimeout(w2, t3)), c22;
        }
        return t3 = h2(t3) || 0, d2(r3) && (a22 = !!r3.leading, i22 = (f22 = "maxWait" in r3) ? p2(h2(r3.maxWait) || 0, t3) : i22, v2 = "trailing" in r3 ? !!r3.trailing : v2), P.cancel = function() {
          void 0 !== u22 && clearTimeout(u22), l22 = 0, o3 = s22 = n22 = u22 = void 0;
        }, P.flush = function() {
          return void 0 === u22 ? c22 : g2(b2());
        }, P;
      };
    }, 96: (e22, t22, r22) => {
      var o22 = "Expected a function", n2 = NaN, i2 = "[object Symbol]", c2 = /^\s+|\s+$/g, u2 = /^[-+]0x[0-9a-f]+$/i, s2 = /^0b[01]+$/i, l2 = /^0o[0-7]+$/i, a2 = parseInt, f2 = "object" == typeof r22.g && r22.g && r22.g.Object === Object && r22.g, p2 = "object" == typeof self && self && self.Object === Object && self, y2 = f2 || p2 || Function("return this")(), b2 = Object.prototype.toString, d2 = Math.max, h2 = Math.min, v2 = function() {
        return y2.Date.now();
      };
      function m2(e3) {
        var t3 = typeof e3;
        return !!e3 && ("object" == t3 || "function" == t3);
      }
      function O2(e3) {
        if ("number" == typeof e3) return e3;
        if ((function(e4) {
          return "symbol" == typeof e4 || /* @__PURE__ */ (function(e5) {
            return !!e5 && "object" == typeof e5;
          })(e4) && b2.call(e4) == i2;
        })(e3)) return n2;
        if (m2(e3)) {
          var t3 = "function" == typeof e3.valueOf ? e3.valueOf() : e3;
          e3 = m2(t3) ? t3 + "" : t3;
        }
        if ("string" != typeof e3) return 0 === e3 ? e3 : +e3;
        e3 = e3.replace(c2, "");
        var r3 = s2.test(e3);
        return r3 || l2.test(e3) ? a2(e3.slice(2), r3 ? 2 : 8) : u2.test(e3) ? n2 : +e3;
      }
      e22.exports = function(e3, t3, r3) {
        var n22 = true, i22 = true;
        if ("function" != typeof e3) throw new TypeError(o22);
        return m2(r3) && (n22 = "leading" in r3 ? !!r3.leading : n22, i22 = "trailing" in r3 ? !!r3.trailing : i22), (function(e4, t4, r4) {
          var n3, i3, c22, u22, s22, l22, a22 = 0, f22 = false, p22 = false, y22 = true;
          if ("function" != typeof e4) throw new TypeError(o22);
          function b22(t5) {
            var r5 = n3, o3 = i3;
            return n3 = i3 = void 0, a22 = t5, u22 = e4.apply(o3, r5);
          }
          function w2(e5) {
            var r5 = e5 - l22;
            return void 0 === l22 || r5 >= t4 || r5 < 0 || p22 && e5 - a22 >= c22;
          }
          function g2() {
            var e5 = v2();
            if (w2(e5)) return P(e5);
            s22 = setTimeout(g2, (function(e6) {
              var r5 = t4 - (e6 - l22);
              return p22 ? h2(r5, c22 - (e6 - a22)) : r5;
            })(e5));
          }
          function P(e5) {
            return s22 = void 0, y22 && n3 ? b22(e5) : (n3 = i3 = void 0, u22);
          }
          function j2() {
            var e5 = v2(), r5 = w2(e5);
            if (n3 = arguments, i3 = this, l22 = e5, r5) {
              if (void 0 === s22) return (function(e6) {
                return a22 = e6, s22 = setTimeout(g2, t4), f22 ? b22(e6) : u22;
              })(l22);
              if (p22) return s22 = setTimeout(g2, t4), b22(l22);
            }
            return void 0 === s22 && (s22 = setTimeout(g2, t4)), u22;
          }
          return t4 = O2(t4) || 0, m2(r4) && (f22 = !!r4.leading, c22 = (p22 = "maxWait" in r4) ? d2(O2(r4.maxWait) || 0, t4) : c22, y22 = "trailing" in r4 ? !!r4.trailing : y22), j2.cancel = function() {
            void 0 !== s22 && clearTimeout(s22), a22 = 0, n3 = l22 = i3 = s22 = void 0;
          }, j2.flush = function() {
            return void 0 === s22 ? u22 : P(v2());
          }, j2;
        })(e3, t3, { leading: n22, maxWait: t3, trailing: i22 });
      };
    }, 703: (e22, t22, r22) => {
      var o22 = r22(414);
      function n2() {
      }
      function i2() {
      }
      i2.resetWarningCache = n2, e22.exports = function() {
        function e3(e4, t4, r4, n22, i22, c2) {
          if (c2 !== o22) {
            var u2 = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw u2.name = "Invariant Violation", u2;
          }
        }
        function t3() {
          return e3;
        }
        e3.isRequired = e3;
        var r3 = { array: e3, bigint: e3, bool: e3, func: e3, number: e3, object: e3, string: e3, symbol: e3, any: e3, arrayOf: t3, element: e3, elementType: e3, instanceOf: t3, node: e3, objectOf: t3, oneOf: t3, oneOfType: t3, shape: t3, exact: t3, checkPropTypes: i2, resetWarningCache: n2 };
        return r3.PropTypes = r3, r3;
      };
    }, 697: (e22, t22, r22) => {
      e22.exports = r22(703)();
    }, 414: (e22) => {
      e22.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    } }, t2 = {};
    function r2(o22) {
      var n2 = t2[o22];
      if (void 0 !== n2) return n2.exports;
      var i2 = t2[o22] = { exports: {} };
      return e2[o22](i2, i2.exports, r2), i2.exports;
    }
    r2.n = (e22) => {
      var t22 = e22 && e22.__esModule ? () => e22.default : () => e22;
      return r2.d(t22, { a: t22 }), t22;
    }, r2.d = (e22, t22) => {
      for (var o22 in t22) r2.o(t22, o22) && !r2.o(e22, o22) && Object.defineProperty(e22, o22, { enumerable: true, get: t22[o22] });
    }, r2.g = (function() {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (e22) {
        if ("object" == typeof window) return window;
      }
    })(), r2.o = (e22, t22) => Object.prototype.hasOwnProperty.call(e22, t22), r2.r = (e22) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e22, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e22, "__esModule", { value: true });
    };
    var o2 = {};
    (() => {
      r2.r(o2), r2.d(o2, { LazyLoadComponent: () => Y2, LazyLoadImage: () => ne2, trackWindowScroll: () => D2 });
      const e22 = requireReact();
      var t22 = r2.n(e22), n2 = r2(697);
      function i2() {
        return "undefined" != typeof window && "IntersectionObserver" in window && "isIntersecting" in window.IntersectionObserverEntry.prototype;
      }
      function c2(e3) {
        return c2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, c2(e3);
      }
      function u2(e3, t3) {
        var r22 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var o22 = Object.getOwnPropertySymbols(e3);
          t3 && (o22 = o22.filter((function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          }))), r22.push.apply(r22, o22);
        }
        return r22;
      }
      function s2(e3, t3, r22) {
        return (t3 = a2(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r22, enumerable: true, configurable: true, writable: true }) : e3[t3] = r22, e3;
      }
      function l2(e3, t3) {
        for (var r22 = 0; r22 < t3.length; r22++) {
          var o22 = t3[r22];
          o22.enumerable = o22.enumerable || false, o22.configurable = true, "value" in o22 && (o22.writable = true), Object.defineProperty(e3, a2(o22.key), o22);
        }
      }
      function a2(e3) {
        var t3 = (function(e4, t4) {
          if ("object" !== c2(e4) || null === e4) return e4;
          var r22 = e4[Symbol.toPrimitive];
          if (void 0 !== r22) {
            var o22 = r22.call(e4, "string");
            if ("object" !== c2(o22)) return o22;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(e4);
        })(e3);
        return "symbol" === c2(t3) ? t3 : String(t3);
      }
      function f2(e3, t3) {
        return f2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
          return e4.__proto__ = t4, e4;
        }, f2(e3, t3);
      }
      function p2(e3) {
        return p2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
          return e4.__proto__ || Object.getPrototypeOf(e4);
        }, p2(e3);
      }
      var y2 = function(e3) {
        e3.forEach((function(e4) {
          e4.isIntersecting && e4.target.onVisible();
        }));
      }, b2 = {}, d2 = (function(e3) {
        !(function(e4, t3) {
          if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
          e4.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t3 && f2(e4, t3);
        })(h22, e3);
        var r22, o22, n22, a22, d22 = (n22 = h22, a22 = (function() {
          if ("undefined" == typeof Reflect || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if ("function" == typeof Proxy) return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
            }))), true;
          } catch (e4) {
            return false;
          }
        })(), function() {
          var e4, t3 = p2(n22);
          if (a22) {
            var r3 = p2(this).constructor;
            e4 = Reflect.construct(t3, arguments, r3);
          } else e4 = t3.apply(this, arguments);
          return (function(e5, t4) {
            if (t4 && ("object" === c2(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return (function(e6) {
              if (void 0 === e6) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e6;
            })(e5);
          })(this, e4);
        });
        function h22(e4) {
          var t3;
          if ((function(e5, t4) {
            if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
          })(this, h22), (t3 = d22.call(this, e4)).supportsObserver = !e4.scrollPosition && e4.useIntersectionObserver && i2(), t3.supportsObserver) {
            var r3 = e4.threshold;
            t3.observer = (function(e5) {
              return b2[e5] = b2[e5] || new IntersectionObserver(y2, { rootMargin: e5 + "px" }), b2[e5];
            })(r3);
          }
          return t3;
        }
        return r22 = h22, o22 = [{ key: "componentDidMount", value: function() {
          this.placeholder && this.observer && (this.placeholder.onVisible = this.props.onVisible, this.observer.observe(this.placeholder)), this.supportsObserver || this.updateVisibility();
        } }, { key: "componentWillUnmount", value: function() {
          this.observer && this.placeholder && this.observer.unobserve(this.placeholder);
        } }, { key: "componentDidUpdate", value: function() {
          this.supportsObserver || this.updateVisibility();
        } }, { key: "getPlaceholderBoundingBox", value: function() {
          var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props.scrollPosition, t3 = this.placeholder.getBoundingClientRect(), r3 = this.placeholder.style, o3 = parseInt(r3.getPropertyValue("margin-left"), 10) || 0, n3 = parseInt(r3.getPropertyValue("margin-top"), 10) || 0;
          return { bottom: e4.y + t3.bottom + n3, left: e4.x + t3.left + o3, right: e4.x + t3.right + o3, top: e4.y + t3.top + n3 };
        } }, { key: "isPlaceholderInViewport", value: function() {
          if ("undefined" == typeof window || !this.placeholder) return false;
          var e4 = this.props, t3 = e4.scrollPosition, r3 = e4.threshold, o3 = this.getPlaceholderBoundingBox(t3), n3 = t3.y + window.innerHeight, i22 = t3.x, c22 = t3.x + window.innerWidth, u22 = t3.y;
          return Boolean(u22 - r3 <= o3.bottom && n3 + r3 >= o3.top && i22 - r3 <= o3.right && c22 + r3 >= o3.left);
        } }, { key: "updateVisibility", value: function() {
          this.isPlaceholderInViewport() && this.props.onVisible();
        } }, { key: "render", value: function() {
          var e4 = this, r3 = this.props, o3 = r3.className, n3 = r3.height, i22 = r3.placeholder, c22 = r3.style, l22 = r3.width;
          if (i22 && "function" != typeof i22.type) return t22().cloneElement(i22, { ref: function(t3) {
            return e4.placeholder = t3;
          } });
          var a3 = (function(e5) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var r4 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? u2(Object(r4), true).forEach((function(t4) {
                s2(e5, t4, r4[t4]);
              })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(r4)) : u2(Object(r4)).forEach((function(t4) {
                Object.defineProperty(e5, t4, Object.getOwnPropertyDescriptor(r4, t4));
              }));
            }
            return e5;
          })({ display: "inline-block" }, c22);
          return void 0 !== l22 && (a3.width = l22), void 0 !== n3 && (a3.height = n3), t22().createElement("span", { className: o3, ref: function(t3) {
            return e4.placeholder = t3;
          }, style: a3 }, i22);
        } }], o22 && l2(r22.prototype, o22), Object.defineProperty(r22, "prototype", { writable: false }), h22;
      })(t22().Component);
      d2.propTypes = { onVisible: n2.PropTypes.func.isRequired, className: n2.PropTypes.string, height: n2.PropTypes.oneOfType([n2.PropTypes.number, n2.PropTypes.string]), placeholder: n2.PropTypes.element, threshold: n2.PropTypes.number, useIntersectionObserver: n2.PropTypes.bool, scrollPosition: n2.PropTypes.shape({ x: n2.PropTypes.number.isRequired, y: n2.PropTypes.number.isRequired }), width: n2.PropTypes.oneOfType([n2.PropTypes.number, n2.PropTypes.string]) }, d2.defaultProps = { className: "", placeholder: null, threshold: 100, useIntersectionObserver: true };
      const h2 = d2;
      var v2 = r2(296), m2 = r2.n(v2), O2 = r2(96), w2 = r2.n(O2), g2 = function(e3) {
        var t3 = getComputedStyle(e3, null);
        return t3.getPropertyValue("overflow") + t3.getPropertyValue("overflow-y") + t3.getPropertyValue("overflow-x");
      };
      const P = function(e3) {
        if (!(e3 instanceof HTMLElement)) return window;
        for (var t3 = e3; t3 && t3 instanceof HTMLElement; ) {
          if (/(scroll|auto)/.test(g2(t3))) return t3;
          t3 = t3.parentNode;
        }
        return window;
      };
      function j2(e3) {
        return j2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, j2(e3);
      }
      var T = ["delayMethod", "delayTime"];
      function S2() {
        return S2 = Object.assign ? Object.assign.bind() : function(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r22 = arguments[t3];
            for (var o22 in r22) Object.prototype.hasOwnProperty.call(r22, o22) && (e3[o22] = r22[o22]);
          }
          return e3;
        }, S2.apply(this, arguments);
      }
      function E2(e3, t3) {
        for (var r22 = 0; r22 < t3.length; r22++) {
          var o22 = t3[r22];
          o22.enumerable = o22.enumerable || false, o22.configurable = true, "value" in o22 && (o22.writable = true), Object.defineProperty(e3, (n22 = (function(e4, t4) {
            if ("object" !== j2(e4) || null === e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var o3 = r3.call(e4, "string");
              if ("object" !== j2(o3)) return o3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e4);
          })(o22.key), "symbol" === j2(n22) ? n22 : String(n22)), o22);
        }
        var n22;
      }
      function L(e3, t3) {
        return L = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
          return e4.__proto__ = t4, e4;
        }, L(e3, t3);
      }
      function _23(e3, t3) {
        if (t3 && ("object" === j2(t3) || "function" == typeof t3)) return t3;
        if (void 0 !== t3) throw new TypeError("Derived constructors may only return object or undefined");
        return I(e3);
      }
      function I(e3) {
        if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e3;
      }
      function x2(e3) {
        return x2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
          return e4.__proto__ || Object.getPrototypeOf(e4);
        }, x2(e3);
      }
      var R = function() {
        return "undefined" == typeof window ? 0 : window.scrollX || window.pageXOffset;
      }, k2 = function() {
        return "undefined" == typeof window ? 0 : window.scrollY || window.pageYOffset;
      };
      const D2 = function(e3) {
        var r22 = (function(r3) {
          !(function(e4, t3) {
            if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t3 && L(e4, t3);
          })(l22, r3);
          var o22, n22, c22, u22, s22 = (c22 = l22, u22 = (function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
              }))), true;
            } catch (e4) {
              return false;
            }
          })(), function() {
            var e4, t3 = x2(c22);
            if (u22) {
              var r4 = x2(this).constructor;
              e4 = Reflect.construct(t3, arguments, r4);
            } else e4 = t3.apply(this, arguments);
            return _23(this, e4);
          });
          function l22(e4) {
            var r4;
            if ((function(e5, t3) {
              if (!(e5 instanceof t3)) throw new TypeError("Cannot call a class as a function");
            })(this, l22), (r4 = s22.call(this, e4)).useIntersectionObserver = e4.useIntersectionObserver && i2(), r4.useIntersectionObserver) return _23(r4);
            var o3 = r4.onChangeScroll.bind(I(r4));
            return "debounce" === e4.delayMethod ? r4.delayedScroll = m2()(o3, e4.delayTime) : "throttle" === e4.delayMethod && (r4.delayedScroll = w2()(o3, e4.delayTime)), r4.state = { scrollPosition: { x: R(), y: k2() } }, r4.baseComponentRef = t22().createRef(), r4;
          }
          return o22 = l22, (n22 = [{ key: "componentDidMount", value: function() {
            this.addListeners();
          } }, { key: "componentWillUnmount", value: function() {
            this.removeListeners();
          } }, { key: "componentDidUpdate", value: function() {
            "undefined" == typeof window || this.useIntersectionObserver || P(this.baseComponentRef.current) !== this.scrollElement && (this.removeListeners(), this.addListeners());
          } }, { key: "addListeners", value: function() {
            "undefined" == typeof window || this.useIntersectionObserver || (this.scrollElement = P(this.baseComponentRef.current), this.scrollElement.addEventListener("scroll", this.delayedScroll, { passive: true }), window.addEventListener("resize", this.delayedScroll, { passive: true }), this.scrollElement !== window && window.addEventListener("scroll", this.delayedScroll, { passive: true }));
          } }, { key: "removeListeners", value: function() {
            "undefined" == typeof window || this.useIntersectionObserver || (this.scrollElement.removeEventListener("scroll", this.delayedScroll), window.removeEventListener("resize", this.delayedScroll), this.scrollElement !== window && window.removeEventListener("scroll", this.delayedScroll));
          } }, { key: "onChangeScroll", value: function() {
            this.useIntersectionObserver || this.setState({ scrollPosition: { x: R(), y: k2() } });
          } }, { key: "render", value: function() {
            var r4 = this.props, o3 = (r4.delayMethod, r4.delayTime, (function(e4, t3) {
              if (null == e4) return {};
              var r5, o4, n4 = (function(e5, t4) {
                if (null == e5) return {};
                var r6, o5, n5 = {}, i3 = Object.keys(e5);
                for (o5 = 0; o5 < i3.length; o5++) r6 = i3[o5], t4.indexOf(r6) >= 0 || (n5[r6] = e5[r6]);
                return n5;
              })(e4, t3);
              if (Object.getOwnPropertySymbols) {
                var i22 = Object.getOwnPropertySymbols(e4);
                for (o4 = 0; o4 < i22.length; o4++) r5 = i22[o4], t3.indexOf(r5) >= 0 || Object.prototype.propertyIsEnumerable.call(e4, r5) && (n4[r5] = e4[r5]);
              }
              return n4;
            })(r4, T)), n3 = this.useIntersectionObserver ? null : this.state.scrollPosition;
            return t22().createElement(e3, S2({ forwardRef: this.baseComponentRef, scrollPosition: n3 }, o3));
          } }]) && E2(o22.prototype, n22), Object.defineProperty(o22, "prototype", { writable: false }), l22;
        })(t22().Component);
        return r22.propTypes = { delayMethod: n2.PropTypes.oneOf(["debounce", "throttle"]), delayTime: n2.PropTypes.number, useIntersectionObserver: n2.PropTypes.bool }, r22.defaultProps = { delayMethod: "throttle", delayTime: 300, useIntersectionObserver: true }, r22;
      };
      function C(e3) {
        return C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, C(e3);
      }
      function B(e3, t3) {
        for (var r22 = 0; r22 < t3.length; r22++) {
          var o22 = t3[r22];
          o22.enumerable = o22.enumerable || false, o22.configurable = true, "value" in o22 && (o22.writable = true), Object.defineProperty(e3, (n22 = (function(e4, t4) {
            if ("object" !== C(e4) || null === e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var o3 = r3.call(e4, "string");
              if ("object" !== C(o3)) return o3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e4);
          })(o22.key), "symbol" === C(n22) ? n22 : String(n22)), o22);
        }
        var n22;
      }
      function M2(e3, t3) {
        return M2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
          return e4.__proto__ = t4, e4;
        }, M2(e3, t3);
      }
      function N2(e3) {
        return N2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
          return e4.__proto__ || Object.getPrototypeOf(e4);
        }, N2(e3);
      }
      var V2 = (function(e3) {
        !(function(e4, t3) {
          if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
          e4.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t3 && M2(e4, t3);
        })(u22, e3);
        var r22, o22, n22, i22, c22 = (n22 = u22, i22 = (function() {
          if ("undefined" == typeof Reflect || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if ("function" == typeof Proxy) return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
            }))), true;
          } catch (e4) {
            return false;
          }
        })(), function() {
          var e4, t3 = N2(n22);
          if (i22) {
            var r3 = N2(this).constructor;
            e4 = Reflect.construct(t3, arguments, r3);
          } else e4 = t3.apply(this, arguments);
          return (function(e5, t4) {
            if (t4 && ("object" === C(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return (function(e6) {
              if (void 0 === e6) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e6;
            })(e5);
          })(this, e4);
        });
        function u22(e4) {
          return (function(e5, t3) {
            if (!(e5 instanceof t3)) throw new TypeError("Cannot call a class as a function");
          })(this, u22), c22.call(this, e4);
        }
        return r22 = u22, (o22 = [{ key: "render", value: function() {
          return t22().createElement(h2, this.props);
        } }]) && B(r22.prototype, o22), Object.defineProperty(r22, "prototype", { writable: false }), u22;
      })(t22().Component);
      const W = D2(V2);
      function z2(e3) {
        return z2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, z2(e3);
      }
      function $2(e3, t3) {
        for (var r22 = 0; r22 < t3.length; r22++) {
          var o22 = t3[r22];
          o22.enumerable = o22.enumerable || false, o22.configurable = true, "value" in o22 && (o22.writable = true), Object.defineProperty(e3, (n22 = (function(e4, t4) {
            if ("object" !== z2(e4) || null === e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var o3 = r3.call(e4, "string");
              if ("object" !== z2(o3)) return o3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e4);
          })(o22.key), "symbol" === z2(n22) ? n22 : String(n22)), o22);
        }
        var n22;
      }
      function U2(e3, t3) {
        return U2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
          return e4.__proto__ = t4, e4;
        }, U2(e3, t3);
      }
      function F(e3) {
        if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e3;
      }
      function q2(e3) {
        return q2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
          return e4.__proto__ || Object.getPrototypeOf(e4);
        }, q2(e3);
      }
      var H2 = (function(e3) {
        !(function(e4, t3) {
          if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
          e4.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t3 && U2(e4, t3);
        })(s22, e3);
        var r22, o22, n22, c22, u22 = (n22 = s22, c22 = (function() {
          if ("undefined" == typeof Reflect || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if ("function" == typeof Proxy) return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
            }))), true;
          } catch (e4) {
            return false;
          }
        })(), function() {
          var e4, t3 = q2(n22);
          if (c22) {
            var r3 = q2(this).constructor;
            e4 = Reflect.construct(t3, arguments, r3);
          } else e4 = t3.apply(this, arguments);
          return (function(e5, t4) {
            if (t4 && ("object" === z2(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return F(e5);
          })(this, e4);
        });
        function s22(e4) {
          var t3;
          !(function(e5, t4) {
            if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
          })(this, s22), t3 = u22.call(this, e4);
          var r3 = e4.afterLoad, o3 = e4.beforeLoad, n3 = e4.scrollPosition, i22 = e4.visibleByDefault;
          return t3.state = { visible: i22 }, i22 && (o3(), r3()), t3.onVisible = t3.onVisible.bind(F(t3)), t3.isScrollTracked = Boolean(n3 && Number.isFinite(n3.x) && n3.x >= 0 && Number.isFinite(n3.y) && n3.y >= 0), t3;
        }
        return r22 = s22, (o22 = [{ key: "componentDidUpdate", value: function(e4, t3) {
          t3.visible !== this.state.visible && this.props.afterLoad();
        } }, { key: "onVisible", value: function() {
          this.props.beforeLoad(), this.setState({ visible: true });
        } }, { key: "render", value: function() {
          if (this.state.visible) return this.props.children;
          var e4 = this.props, r3 = e4.className, o3 = e4.delayMethod, n3 = e4.delayTime, c3 = e4.height, u3 = e4.placeholder, s3 = e4.scrollPosition, l22 = e4.style, a22 = e4.threshold, f22 = e4.useIntersectionObserver, p22 = e4.width;
          return this.isScrollTracked || f22 && i2() ? t22().createElement(h2, { className: r3, height: c3, onVisible: this.onVisible, placeholder: u3, scrollPosition: s3, style: l22, threshold: a22, useIntersectionObserver: f22, width: p22 }) : t22().createElement(W, { className: r3, delayMethod: o3, delayTime: n3, height: c3, onVisible: this.onVisible, placeholder: u3, style: l22, threshold: a22, width: p22 });
        } }]) && $2(r22.prototype, o22), Object.defineProperty(r22, "prototype", { writable: false }), s22;
      })(t22().Component);
      H2.propTypes = { afterLoad: n2.PropTypes.func, beforeLoad: n2.PropTypes.func, useIntersectionObserver: n2.PropTypes.bool, visibleByDefault: n2.PropTypes.bool }, H2.defaultProps = { afterLoad: function() {
        return {};
      }, beforeLoad: function() {
        return {};
      }, useIntersectionObserver: true, visibleByDefault: false };
      const Y2 = H2;
      function X2(e3) {
        return X2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, X2(e3);
      }
      var A2 = ["afterLoad", "beforeLoad", "delayMethod", "delayTime", "effect", "placeholder", "placeholderSrc", "scrollPosition", "threshold", "useIntersectionObserver", "visibleByDefault", "wrapperClassName", "wrapperProps"];
      function G2(e3, t3) {
        var r22 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var o22 = Object.getOwnPropertySymbols(e3);
          t3 && (o22 = o22.filter((function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          }))), r22.push.apply(r22, o22);
        }
        return r22;
      }
      function J2(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var r22 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? G2(Object(r22), true).forEach((function(t4) {
            K2(e3, t4, r22[t4]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r22)) : G2(Object(r22)).forEach((function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r22, t4));
          }));
        }
        return e3;
      }
      function K2(e3, t3, r22) {
        return (t3 = ee2(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r22, enumerable: true, configurable: true, writable: true }) : e3[t3] = r22, e3;
      }
      function Q() {
        return Q = Object.assign ? Object.assign.bind() : function(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r22 = arguments[t3];
            for (var o22 in r22) Object.prototype.hasOwnProperty.call(r22, o22) && (e3[o22] = r22[o22]);
          }
          return e3;
        }, Q.apply(this, arguments);
      }
      function Z2(e3, t3) {
        for (var r22 = 0; r22 < t3.length; r22++) {
          var o22 = t3[r22];
          o22.enumerable = o22.enumerable || false, o22.configurable = true, "value" in o22 && (o22.writable = true), Object.defineProperty(e3, ee2(o22.key), o22);
        }
      }
      function ee2(e3) {
        var t3 = (function(e4, t4) {
          if ("object" !== X2(e4) || null === e4) return e4;
          var r22 = e4[Symbol.toPrimitive];
          if (void 0 !== r22) {
            var o22 = r22.call(e4, "string");
            if ("object" !== X2(o22)) return o22;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(e4);
        })(e3);
        return "symbol" === X2(t3) ? t3 : String(t3);
      }
      function te2(e3, t3) {
        return te2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
          return e4.__proto__ = t4, e4;
        }, te2(e3, t3);
      }
      function re2(e3) {
        return re2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
          return e4.__proto__ || Object.getPrototypeOf(e4);
        }, re2(e3);
      }
      var oe2 = (function(e3) {
        !(function(e4, t3) {
          if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
          e4.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t3 && te2(e4, t3);
        })(u22, e3);
        var r22, o22, n22, i22, c22 = (n22 = u22, i22 = (function() {
          if ("undefined" == typeof Reflect || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if ("function" == typeof Proxy) return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
            }))), true;
          } catch (e4) {
            return false;
          }
        })(), function() {
          var e4, t3 = re2(n22);
          if (i22) {
            var r3 = re2(this).constructor;
            e4 = Reflect.construct(t3, arguments, r3);
          } else e4 = t3.apply(this, arguments);
          return (function(e5, t4) {
            if (t4 && ("object" === X2(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return (function(e6) {
              if (void 0 === e6) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e6;
            })(e5);
          })(this, e4);
        });
        function u22(e4) {
          var t3;
          return (function(e5, t4) {
            if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
          })(this, u22), (t3 = c22.call(this, e4)).state = { loaded: false }, t3;
        }
        return r22 = u22, (o22 = [{ key: "onImageLoad", value: function() {
          var e4 = this;
          return this.state.loaded ? null : function(t3) {
            e4.props.onLoad(t3), e4.props.afterLoad(), e4.setState({ loaded: true });
          };
        } }, { key: "getImg", value: function() {
          var e4 = this.props, r3 = (e4.afterLoad, e4.beforeLoad, e4.delayMethod, e4.delayTime, e4.effect, e4.placeholder, e4.placeholderSrc, e4.scrollPosition, e4.threshold, e4.useIntersectionObserver, e4.visibleByDefault, e4.wrapperClassName, e4.wrapperProps, (function(e5, t3) {
            if (null == e5) return {};
            var r4, o3, n3 = (function(e6, t4) {
              if (null == e6) return {};
              var r5, o4, n4 = {}, i4 = Object.keys(e6);
              for (o4 = 0; o4 < i4.length; o4++) r5 = i4[o4], t4.indexOf(r5) >= 0 || (n4[r5] = e6[r5]);
              return n4;
            })(e5, t3);
            if (Object.getOwnPropertySymbols) {
              var i3 = Object.getOwnPropertySymbols(e5);
              for (o3 = 0; o3 < i3.length; o3++) r4 = i3[o3], t3.indexOf(r4) >= 0 || Object.prototype.propertyIsEnumerable.call(e5, r4) && (n3[r4] = e5[r4]);
            }
            return n3;
          })(e4, A2));
          return t22().createElement("img", Q({}, r3, { onLoad: this.onImageLoad() }));
        } }, { key: "getLazyLoadImage", value: function() {
          var e4 = this.props, r3 = e4.beforeLoad, o3 = e4.className, n3 = e4.delayMethod, i3 = e4.delayTime, c3 = e4.height, u3 = e4.placeholder, s22 = e4.scrollPosition, l22 = e4.style, a22 = e4.threshold, f22 = e4.useIntersectionObserver, p22 = e4.visibleByDefault, y22 = e4.width;
          return t22().createElement(Y2, { beforeLoad: r3, className: o3, delayMethod: n3, delayTime: i3, height: c3, placeholder: u3, scrollPosition: s22, style: l22, threshold: a22, useIntersectionObserver: f22, visibleByDefault: p22, width: y22 }, this.getImg());
        } }, { key: "getWrappedLazyLoadImage", value: function(e4) {
          var r3 = this.props, o3 = r3.effect, n3 = r3.height, i3 = r3.placeholderSrc, c3 = r3.width, u3 = r3.wrapperClassName, s22 = r3.wrapperProps, l22 = this.state.loaded, a22 = l22 ? " lazy-load-image-loaded" : "", f22 = l22 || !i3 ? {} : { backgroundImage: "url(".concat(i3, ")"), backgroundSize: "100% 100%" };
          return t22().createElement("span", Q({ className: u3 + " lazy-load-image-background " + o3 + a22, style: J2(J2({}, f22), {}, { color: "transparent", display: "inline-block", height: n3, width: c3 }) }, s22), e4);
        } }, { key: "render", value: function() {
          var e4 = this.props, t3 = e4.effect, r3 = e4.placeholderSrc, o3 = e4.visibleByDefault, n3 = e4.wrapperClassName, i3 = e4.wrapperProps, c3 = this.getLazyLoadImage();
          return (t3 || r3) && !o3 || n3 || i3 ? this.getWrappedLazyLoadImage(c3) : c3;
        } }]) && Z2(r22.prototype, o22), Object.defineProperty(r22, "prototype", { writable: false }), u22;
      })(t22().Component);
      oe2.propTypes = { onLoad: n2.PropTypes.func, afterLoad: n2.PropTypes.func, beforeLoad: n2.PropTypes.func, delayMethod: n2.PropTypes.string, delayTime: n2.PropTypes.number, effect: n2.PropTypes.string, placeholderSrc: n2.PropTypes.string, threshold: n2.PropTypes.number, useIntersectionObserver: n2.PropTypes.bool, visibleByDefault: n2.PropTypes.bool, wrapperClassName: n2.PropTypes.string, wrapperProps: n2.PropTypes.object }, oe2.defaultProps = { onLoad: function() {
      }, afterLoad: function() {
        return {};
      }, beforeLoad: function() {
        return {};
      }, delayMethod: "throttle", delayTime: 300, effect: "", placeholderSrc: null, threshold: 100, useIntersectionObserver: true, visibleByDefault: false, wrapperClassName: "" };
      const ne2 = oe2;
    })(), build.exports = o2;
  })();
  return build.exports;
}
var buildExports = requireBuild();
function _typeof$1(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  return Constructor;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf(o2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf(o2, p2);
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var PersistGate = /* @__PURE__ */ (function(_PureComponent) {
  _inherits(PersistGate2, _PureComponent);
  function PersistGate2() {
    var _getPrototypeOf2;
    var _this;
    _classCallCheck(this, PersistGate2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PersistGate2)).call.apply(_getPrototypeOf2, [this].concat(args)));
    _defineProperty$3(_assertThisInitialized(_this), "state", {
      bootstrapped: false
    });
    _defineProperty$3(_assertThisInitialized(_this), "_unsubscribe", void 0);
    _defineProperty$3(_assertThisInitialized(_this), "handlePersistorState", function() {
      var persistor = _this.props.persistor;
      var _persistor$getState = persistor.getState(), bootstrapped = _persistor$getState.bootstrapped;
      if (bootstrapped) {
        if (_this.props.onBeforeLift) {
          Promise.resolve(_this.props.onBeforeLift()).finally(function() {
            return _this.setState({
              bootstrapped: true
            });
          });
        } else {
          _this.setState({
            bootstrapped: true
          });
        }
        _this._unsubscribe && _this._unsubscribe();
      }
    });
    return _this;
  }
  _createClass(PersistGate2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._unsubscribe = this.props.persistor.subscribe(this.handlePersistorState);
      this.handlePersistorState();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._unsubscribe && this._unsubscribe();
    }
  }, {
    key: "render",
    value: function render3() {
      if (typeof this.props.children === "function") {
        return this.props.children(this.state.bootstrapped);
      }
      return this.state.bootstrapped ? this.props.children : this.props.loading;
    }
  }]);
  return PersistGate2;
})(reactExports.PureComponent);
_defineProperty$3(PersistGate, "defaultProps", {
  children: null,
  loading: null
});
var KEY_PREFIX = "persist:";
var FLUSH = "persist/FLUSH";
var REHYDRATE = "persist/REHYDRATE";
var PAUSE = "persist/PAUSE";
var PERSIST = "persist/PERSIST";
var PURGE = "persist/PURGE";
var REGISTER = "persist/REGISTER";
var DEFAULT_VERSION = -1;
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function ownKeys$2(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(source, true).forEach(function(key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(source).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function autoMergeLevel1(inboundState, originalState, reducedState, _ref) {
  _ref.debug;
  var newState = _objectSpread$2({}, reducedState);
  if (inboundState && _typeof(inboundState) === "object") {
    Object.keys(inboundState).forEach(function(key) {
      if (key === "_persist") return;
      if (originalState[key] !== reducedState[key]) {
        return;
      }
      newState[key] = inboundState[key];
    });
  }
  return newState;
}
function createPersistoid(config) {
  var blacklist = config.blacklist || null;
  var whitelist = config.whitelist || null;
  var transforms = config.transforms || [];
  var throttle = config.throttle || 0;
  var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
  var storage2 = config.storage;
  var serialize;
  if (config.serialize === false) {
    serialize = function serialize2(x2) {
      return x2;
    };
  } else if (typeof config.serialize === "function") {
    serialize = config.serialize;
  } else {
    serialize = defaultSerialize;
  }
  var writeFailHandler = config.writeFailHandler || null;
  var lastState = {};
  var stagedState = {};
  var keysToProcess = [];
  var timeIterator = null;
  var writePromise = null;
  var update8 = function update22(state) {
    Object.keys(state).forEach(function(key) {
      if (!passWhitelistBlacklist(key)) return;
      if (lastState[key] === state[key]) return;
      if (keysToProcess.indexOf(key) !== -1) return;
      keysToProcess.push(key);
    });
    Object.keys(lastState).forEach(function(key) {
      if (state[key] === void 0 && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== void 0) {
        keysToProcess.push(key);
      }
    });
    if (timeIterator === null) {
      timeIterator = setInterval(processNextKey, throttle);
    }
    lastState = state;
  };
  function processNextKey() {
    if (keysToProcess.length === 0) {
      if (timeIterator) clearInterval(timeIterator);
      timeIterator = null;
      return;
    }
    var key = keysToProcess.shift();
    var endState = transforms.reduce(function(subState, transformer) {
      return transformer.in(subState, key, lastState);
    }, lastState[key]);
    if (endState !== void 0) {
      try {
        stagedState[key] = serialize(endState);
      } catch (err2) {
        console.error("redux-persist/createPersistoid: error serializing state", err2);
      }
    } else {
      delete stagedState[key];
    }
    if (keysToProcess.length === 0) {
      writeStagedState();
    }
  }
  function writeStagedState() {
    Object.keys(stagedState).forEach(function(key) {
      if (lastState[key] === void 0) {
        delete stagedState[key];
      }
    });
    writePromise = storage2.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);
  }
  function passWhitelistBlacklist(key) {
    if (whitelist && whitelist.indexOf(key) === -1 && key !== "_persist") return false;
    if (blacklist && blacklist.indexOf(key) !== -1) return false;
    return true;
  }
  function onWriteFail(err2) {
    if (writeFailHandler) writeFailHandler(err2);
  }
  var flush2 = function flush22() {
    while (keysToProcess.length !== 0) {
      processNextKey();
    }
    return writePromise || Promise.resolve();
  };
  return {
    update: update8,
    flush: flush2
  };
}
function defaultSerialize(data) {
  return JSON.stringify(data);
}
function getStoredState(config) {
  var transforms = config.transforms || [];
  var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
  var storage2 = config.storage;
  config.debug;
  var deserialize;
  if (config.deserialize === false) {
    deserialize = function deserialize2(x2) {
      return x2;
    };
  } else if (typeof config.deserialize === "function") {
    deserialize = config.deserialize;
  } else {
    deserialize = defaultDeserialize;
  }
  return storage2.getItem(storageKey).then(function(serialized) {
    if (!serialized) return void 0;
    else {
      try {
        var state = {};
        var rawState = deserialize(serialized);
        Object.keys(rawState).forEach(function(key) {
          state[key] = transforms.reduceRight(function(subState, transformer) {
            return transformer.out(subState, key, rawState);
          }, deserialize(rawState[key]));
        });
        return state;
      } catch (err2) {
        throw err2;
      }
    }
  });
}
function defaultDeserialize(serial) {
  return JSON.parse(serial);
}
function purgeStoredState(config) {
  var storage2 = config.storage;
  var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
  return storage2.removeItem(storageKey, warnIfRemoveError);
}
function warnIfRemoveError(err2) {
}
function ownKeys$1(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(source, true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(source).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var DEFAULT_TIMEOUT = 5e3;
function persistReducer(config, baseReducer) {
  var version2 = config.version !== void 0 ? config.version : DEFAULT_VERSION;
  config.debug || false;
  var stateReconciler = config.stateReconciler === void 0 ? autoMergeLevel1 : config.stateReconciler;
  var getStoredState$1 = config.getStoredState || getStoredState;
  var timeout = config.timeout !== void 0 ? config.timeout : DEFAULT_TIMEOUT;
  var _persistoid = null;
  var _purge = false;
  var _paused = true;
  var conditionalUpdate = function conditionalUpdate2(state) {
    state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state);
    return state;
  };
  return function(state, action) {
    var _ref = state || {}, _persist = _ref._persist, rest2 = _objectWithoutProperties(_ref, ["_persist"]);
    var restState = rest2;
    if (action.type === PERSIST) {
      var _sealed = false;
      var _rehydrate = function _rehydrate2(payload, err2) {
        if (!_sealed) {
          action.rehydrate(config.key, payload, err2);
          _sealed = true;
        }
      };
      timeout && setTimeout(function() {
        !_sealed && _rehydrate(void 0, new Error('redux-persist: persist timed out for persist key "'.concat(config.key, '"')));
      }, timeout);
      _paused = false;
      if (!_persistoid) _persistoid = createPersistoid(config);
      if (_persist) {
        return _objectSpread$1({}, baseReducer(restState, action), {
          _persist
        });
      }
      if (typeof action.rehydrate !== "function" || typeof action.register !== "function") throw new Error("redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.");
      action.register(config.key);
      getStoredState$1(config).then(function(restoredState) {
        var migrate = config.migrate || function(s2, v2) {
          return Promise.resolve(s2);
        };
        migrate(restoredState, version2).then(function(migratedState) {
          _rehydrate(migratedState);
        }, function(migrateErr) {
          _rehydrate(void 0, migrateErr);
        });
      }, function(err2) {
        _rehydrate(void 0, err2);
      });
      return _objectSpread$1({}, baseReducer(restState, action), {
        _persist: {
          version: version2,
          rehydrated: false
        }
      });
    } else if (action.type === PURGE) {
      _purge = true;
      action.result(purgeStoredState(config));
      return _objectSpread$1({}, baseReducer(restState, action), {
        _persist
      });
    } else if (action.type === FLUSH) {
      action.result(_persistoid && _persistoid.flush());
      return _objectSpread$1({}, baseReducer(restState, action), {
        _persist
      });
    } else if (action.type === PAUSE) {
      _paused = true;
    } else if (action.type === REHYDRATE) {
      if (_purge) return _objectSpread$1({}, restState, {
        _persist: _objectSpread$1({}, _persist, {
          rehydrated: true
        })
        // @NOTE if key does not match, will continue to default else below
      });
      if (action.key === config.key) {
        var reducedState = baseReducer(restState, action);
        var inboundState = action.payload;
        var reconciledRest = stateReconciler !== false && inboundState !== void 0 ? stateReconciler(inboundState, state, reducedState, config) : reducedState;
        var _newState = _objectSpread$1({}, reconciledRest, {
          _persist: _objectSpread$1({}, _persist, {
            rehydrated: true
          })
        });
        return conditionalUpdate(_newState);
      }
    }
    if (!_persist) return baseReducer(state, action);
    var newState = baseReducer(restState, action);
    if (newState === restState) return state;
    return conditionalUpdate(_objectSpread$1({}, newState, {
      _persist
    }));
  };
}
function _toConsumableArray(arr2) {
  return _arrayWithoutHoles(arr2) || _iterableToArray(arr2) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles(arr2) {
  if (Array.isArray(arr2)) {
    for (var i2 = 0, arr22 = new Array(arr2.length); i2 < arr2.length; i2++) {
      arr22[i2] = arr2[i2];
    }
    return arr22;
  }
}
function ownKeys(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(source, true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var initialState$1 = {
  registry: [],
  bootstrapped: false
};
var persistorReducer = function persistorReducer2() {
  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState$1;
  var action = arguments.length > 1 ? arguments[1] : void 0;
  switch (action.type) {
    case REGISTER:
      return _objectSpread({}, state, {
        registry: [].concat(_toConsumableArray(state.registry), [action.key])
      });
    case REHYDRATE:
      var firstIndex = state.registry.indexOf(action.key);
      var registry = _toConsumableArray(state.registry);
      registry.splice(firstIndex, 1);
      return _objectSpread({}, state, {
        registry,
        bootstrapped: registry.length === 0
      });
    default:
      return state;
  }
};
function persistStore(store, options, cb) {
  var _pStore = createStore(persistorReducer, initialState$1, void 0);
  var register2 = function register22(key) {
    _pStore.dispatch({
      type: REGISTER,
      key
    });
  };
  var rehydrate = function rehydrate2(key, payload, err2) {
    var rehydrateAction = {
      type: REHYDRATE,
      payload,
      err: err2,
      key
      // dispatch to `store` to rehydrate and `persistor` to track result
    };
    store.dispatch(rehydrateAction);
    _pStore.dispatch(rehydrateAction);
  };
  var persistor = _objectSpread({}, _pStore, {
    purge: function purge() {
      var results = [];
      store.dispatch({
        type: PURGE,
        result: function result(purgeResult) {
          results.push(purgeResult);
        }
      });
      return Promise.all(results);
    },
    flush: function flush2() {
      var results = [];
      store.dispatch({
        type: FLUSH,
        result: function result(flushResult) {
          results.push(flushResult);
        }
      });
      return Promise.all(results);
    },
    pause: function pause() {
      store.dispatch({
        type: PAUSE
      });
    },
    persist: function persist() {
      store.dispatch({
        type: PERSIST,
        register: register2,
        rehydrate
      });
    }
  });
  {
    persistor.persist();
  }
  return persistor;
}
var storage$1 = {};
var createWebStorage = {};
var getStorage = {};
var hasRequiredGetStorage;
function requireGetStorage() {
  if (hasRequiredGetStorage) return getStorage;
  hasRequiredGetStorage = 1;
  getStorage.__esModule = true;
  getStorage.default = getStorage$1;
  function _typeof2(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function _typeof22(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function _typeof22(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  function noop2() {
  }
  var noopStorage = {
    getItem: noop2,
    setItem: noop2,
    removeItem: noop2
  };
  function hasStorage(storageType) {
    if ((typeof self === "undefined" ? "undefined" : _typeof2(self)) !== "object" || !(storageType in self)) {
      return false;
    }
    try {
      var storage2 = self[storageType];
      var testKey = "redux-persist ".concat(storageType, " test");
      storage2.setItem(testKey, "test");
      storage2.getItem(testKey);
      storage2.removeItem(testKey);
    } catch (e2) {
      return false;
    }
    return true;
  }
  function getStorage$1(type) {
    var storageType = "".concat(type, "Storage");
    if (hasStorage(storageType)) return self[storageType];
    else {
      return noopStorage;
    }
  }
  return getStorage;
}
var hasRequiredCreateWebStorage;
function requireCreateWebStorage() {
  if (hasRequiredCreateWebStorage) return createWebStorage;
  hasRequiredCreateWebStorage = 1;
  createWebStorage.__esModule = true;
  createWebStorage.default = createWebStorage$1;
  var _getStorage = _interopRequireDefault(requireGetStorage());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function createWebStorage$1(type) {
    var storage2 = (0, _getStorage.default)(type);
    return {
      getItem: function getItem(key) {
        return new Promise(function(resolve, reject) {
          resolve(storage2.getItem(key));
        });
      },
      setItem: function setItem(key, item) {
        return new Promise(function(resolve, reject) {
          resolve(storage2.setItem(key, item));
        });
      },
      removeItem: function removeItem(key) {
        return new Promise(function(resolve, reject) {
          resolve(storage2.removeItem(key));
        });
      }
    };
  }
  return createWebStorage;
}
var hasRequiredStorage;
function requireStorage() {
  if (hasRequiredStorage) return storage$1;
  hasRequiredStorage = 1;
  storage$1.__esModule = true;
  storage$1.default = void 0;
  var _createWebStorage = _interopRequireDefault(requireCreateWebStorage());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _default = (0, _createWebStorage.default)("local");
  storage$1.default = _default;
  return storage$1;
}
var storageExports = requireStorage();
const storage = /* @__PURE__ */ getDefaultExportFromCjs(storageExports);
const ErrorBoundaryContext = reactExports.createContext(null);
const initialState = {
  didCatch: false,
  error: null
};
class ErrorBoundary2 extends reactExports.Component {
  constructor(props) {
    super(props);
    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
    this.state = initialState;
  }
  static getDerivedStateFromError(error2) {
    return {
      didCatch: true,
      error: error2
    };
  }
  resetErrorBoundary() {
    const {
      error: error2
    } = this.state;
    if (error2 !== null) {
      var _this$props$onReset, _this$props;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
        args,
        reason: "imperative-api"
      });
      this.setState(initialState);
    }
  }
  componentDidCatch(error2, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error2, info);
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      didCatch
    } = this.state;
    const {
      resetKeys
    } = this.props;
    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
      var _this$props$onReset2, _this$props3;
      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      });
      this.setState(initialState);
    }
  }
  render() {
    const {
      children,
      fallbackRender,
      FallbackComponent,
      fallback
    } = this.props;
    const {
      didCatch,
      error: error2
    } = this.state;
    let childToRender = children;
    if (didCatch) {
      const props = {
        error: error2,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof fallbackRender === "function") {
        childToRender = fallbackRender(props);
      } else if (FallbackComponent) {
        childToRender = reactExports.createElement(FallbackComponent, props);
      } else if (fallback !== void 0) {
        childToRender = fallback;
      } else {
        throw error2;
      }
    }
    return reactExports.createElement(ErrorBoundaryContext.Provider, {
      value: {
        didCatch,
        error: error2,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
}
function hasArrayChanged() {
  let a2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let b2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return a2.length !== b2.length || a2.some((item, index) => !Object.is(item, b2[index]));
}
function useLoadGsiScript(options = {}) {
  const { nonce, onScriptLoadSuccess, onScriptLoadError } = options;
  const [scriptLoadedSuccessfully, setScriptLoadedSuccessfully] = reactExports.useState(false);
  const onScriptLoadSuccessRef = reactExports.useRef(onScriptLoadSuccess);
  onScriptLoadSuccessRef.current = onScriptLoadSuccess;
  const onScriptLoadErrorRef = reactExports.useRef(onScriptLoadError);
  onScriptLoadErrorRef.current = onScriptLoadError;
  reactExports.useEffect(() => {
    const scriptTag = document.createElement("script");
    scriptTag.src = "https://accounts.google.com/gsi/client";
    scriptTag.async = true;
    scriptTag.defer = true;
    scriptTag.nonce = nonce;
    scriptTag.onload = () => {
      var _a;
      setScriptLoadedSuccessfully(true);
      (_a = onScriptLoadSuccessRef.current) === null || _a === void 0 ? void 0 : _a.call(onScriptLoadSuccessRef);
    };
    scriptTag.onerror = () => {
      var _a;
      setScriptLoadedSuccessfully(false);
      (_a = onScriptLoadErrorRef.current) === null || _a === void 0 ? void 0 : _a.call(onScriptLoadErrorRef);
    };
    document.body.appendChild(scriptTag);
    return () => {
      document.body.removeChild(scriptTag);
    };
  }, [nonce]);
  return scriptLoadedSuccessfully;
}
const GoogleOAuthContext = reactExports.createContext(null);
function GoogleOAuthProvider({ clientId, nonce, onScriptLoadSuccess, onScriptLoadError, children }) {
  const scriptLoadedSuccessfully = useLoadGsiScript({
    nonce,
    onScriptLoadSuccess,
    onScriptLoadError
  });
  const contextValue = reactExports.useMemo(() => ({
    clientId,
    scriptLoadedSuccessfully
  }), [clientId, scriptLoadedSuccessfully]);
  return React.createElement(GoogleOAuthContext.Provider, { value: contextValue }, children);
}
function useGoogleOAuth() {
  const context2 = reactExports.useContext(GoogleOAuthContext);
  if (!context2) {
    throw new Error("Google OAuth components must be used within GoogleOAuthProvider");
  }
  return context2;
}
function useGoogleLogin({ flow = "implicit", scope = "", onSuccess, onError, onNonOAuthError, overrideScope, state, ...props }) {
  const { clientId, scriptLoadedSuccessfully } = useGoogleOAuth();
  const clientRef = reactExports.useRef();
  const onSuccessRef = reactExports.useRef(onSuccess);
  onSuccessRef.current = onSuccess;
  const onErrorRef = reactExports.useRef(onError);
  onErrorRef.current = onError;
  const onNonOAuthErrorRef = reactExports.useRef(onNonOAuthError);
  onNonOAuthErrorRef.current = onNonOAuthError;
  reactExports.useEffect(() => {
    var _a, _b;
    if (!scriptLoadedSuccessfully)
      return;
    const clientMethod = flow === "implicit" ? "initTokenClient" : "initCodeClient";
    const client2 = (_b = (_a = window === null || window === void 0 ? void 0 : window.google) === null || _a === void 0 ? void 0 : _a.accounts) === null || _b === void 0 ? void 0 : _b.oauth2[clientMethod]({
      client_id: clientId,
      scope: overrideScope ? scope : "openid profile email ".concat(scope),
      callback: (response) => {
        var _a2, _b2;
        if (response.error)
          return (_a2 = onErrorRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onErrorRef, response);
        (_b2 = onSuccessRef.current) === null || _b2 === void 0 ? void 0 : _b2.call(onSuccessRef, response);
      },
      error_callback: (nonOAuthError) => {
        var _a2;
        (_a2 = onNonOAuthErrorRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onNonOAuthErrorRef, nonOAuthError);
      },
      state,
      ...props
    });
    clientRef.current = client2;
  }, [clientId, scriptLoadedSuccessfully, flow, scope, state]);
  const loginImplicitFlow = reactExports.useCallback((overrideConfig) => {
    var _a;
    return (_a = clientRef.current) === null || _a === void 0 ? void 0 : _a.requestAccessToken(overrideConfig);
  }, []);
  const loginAuthCodeFlow = reactExports.useCallback(() => {
    var _a;
    return (_a = clientRef.current) === null || _a === void 0 ? void 0 : _a.requestCode();
  }, []);
  return flow === "implicit" ? loginImplicitFlow : loginAuthCodeFlow;
}
export {
  o$1 as $,
  fetchBaseQuery as A,
  Build as B,
  gBase64 as C,
  createApi as D,
  humpsExports as E,
  createAction as F,
  createSlice as G,
  H,
  isRejectedWithValue as I,
  combineReducers as J,
  configureStore as K,
  persistStore as L,
  persistReducer as M,
  FLUSH as N,
  REHYDRATE as O,
  PAUSE as P,
  PERSIST as Q,
  React as R,
  PURGE as S,
  REGISTER as T,
  storage as U,
  clientExports as V,
  Provider as W,
  PersistGate as X,
  ErrorBoundary2 as Y,
  useForm as Z,
  __rest as _,
  Host as a,
  O as a$,
  t as a0,
  create$3 as a1,
  create$6 as a2,
  Controller$1 as a3,
  yup as a4,
  setLocale as a5,
  lodashExports as a6,
  useWatch as a7,
  DraftExports as a8,
  reactDraftWysiwygExports as a9,
  isValid as aA,
  useDispatch as aB,
  useSelector as aC,
  useTranslation as aD,
  useHistory as aE,
  GoogleOAuthProvider$1 as aF,
  useGoogleLogin$1 as aG,
  ErrorBoundary$1 as aH,
  Redirect as aI,
  useLocation as aJ,
  useParams as aK,
  create$5 as aL,
  create$7 as aM,
  create$2 as aN,
  useGoogleLogin as aO,
  GoogleOAuthProvider as aP,
  addMinutes as aQ,
  startOfMonth as aR,
  startOfWeek as aS,
  endOfMonth as aT,
  addDays as aU,
  startOfDay as aV,
  isSameDay as aW,
  subMonths as aX,
  addMonths as aY,
  isSameMonth as aZ,
  isPast as a_,
  draftToHtml as aa,
  qr as ab,
  Swiper2 as ac,
  l$2 as ad,
  c$1 as ae,
  SwiperSlide$1 as af,
  register as ag,
  V as ah,
  arrayMove as ai,
  useSensors as aj,
  useSensor as ak,
  DndContext as al,
  closestCenter as am,
  SortableContext as an,
  verticalListSortingStrategy as ao,
  TouchSensor as ap,
  sortableKeyboardCoordinates as aq,
  KeyboardSensor as ar,
  PointerSensor as as,
  useSortable as at,
  CSS as au,
  parseISO as av,
  formatInTimeZone as aw,
  toZonedTime as ax,
  format$1 as ay,
  fromZonedTime as az,
  getAssetPath as b,
  w as b0,
  useMap as b1,
  MapContainer as b2,
  TileLayer as b3,
  buildExports as b4,
  isToday as b5,
  isSameWeek as b6,
  Clipboard as b7,
  differenceInCalendarMonths as b8,
  getMonth as b9,
  eachDayOfInterval as ba,
  parse as bb,
  isWithinInterval as bc,
  differenceInMinutes as bd,
  createEvent as c,
  deleteDB as d,
  reactExports as e,
  forceUpdate as f,
  getMode as g,
  h$1 as h,
  ao as i,
  jsxRuntimeExports as j,
  reactDomExports as k,
  createBrowserHistory as l,
  Router as m,
  withRouter as n,
  openDB as o,
  proxyCustomElement as p,
  Route as q,
  readTask as r,
  setMode as s,
  createHashHistory as t,
  matchPath as u,
  instance as v,
  writeTask as w,
  Backend as x,
  Browser as y,
  initReactI18next as z
};
